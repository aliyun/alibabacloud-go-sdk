// This file is auto-generated, don't edit it. Thanks.
/**
 *
 */
package client

import (
	openapi "github.com/alibabacloud-go/darabonba-openapi/v2/client"
	endpointutil "github.com/alibabacloud-go/endpoint-util/service"
	openapiutil "github.com/alibabacloud-go/openapi-util/service"
	util "github.com/alibabacloud-go/tea-utils/v2/service"
	"github.com/alibabacloud-go/tea/tea"
)

type ActivateMigrationTargetInstanceRequest struct {
	// The ID of the destination instance. You can call the [DescribeDBInstances](~~26232~~) operation to query the IDs of instances.
	DBInstanceName *string `json:"DBInstanceName,omitempty" xml:"DBInstanceName,omitempty"`
	// Specifies whether to forcefully perform a switchover. Set the value to 1. The value 1 specifies a forceful switchover.
	ForceSwitch     *string `json:"ForceSwitch,omitempty" xml:"ForceSwitch,omitempty"`
	ResourceOwnerId *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// A reserved parameter. This parameter does not take effect.
	SwitchTime *string `json:"SwitchTime,omitempty" xml:"SwitchTime,omitempty"`
	// The time when you want to perform the switchover.
	//
	// Set the value to 0. The value 0 specifies an immediate switchover.
	SwitchTimeMode *string `json:"SwitchTimeMode,omitempty" xml:"SwitchTimeMode,omitempty"`
}

func (s ActivateMigrationTargetInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s ActivateMigrationTargetInstanceRequest) GoString() string {
	return s.String()
}

func (s *ActivateMigrationTargetInstanceRequest) SetDBInstanceName(v string) *ActivateMigrationTargetInstanceRequest {
	s.DBInstanceName = &v
	return s
}

func (s *ActivateMigrationTargetInstanceRequest) SetForceSwitch(v string) *ActivateMigrationTargetInstanceRequest {
	s.ForceSwitch = &v
	return s
}

func (s *ActivateMigrationTargetInstanceRequest) SetResourceOwnerId(v int64) *ActivateMigrationTargetInstanceRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ActivateMigrationTargetInstanceRequest) SetSwitchTime(v string) *ActivateMigrationTargetInstanceRequest {
	s.SwitchTime = &v
	return s
}

func (s *ActivateMigrationTargetInstanceRequest) SetSwitchTimeMode(v string) *ActivateMigrationTargetInstanceRequest {
	s.SwitchTimeMode = &v
	return s
}

type ActivateMigrationTargetInstanceResponseBody struct {
	// The name of the destination instance.
	DBInstanceName *string `json:"DBInstanceName,omitempty" xml:"DBInstanceName,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The private IP address that is used to connect to the self-managed PostgreSQL instance.
	SourceIpAddress *string `json:"SourceIpAddress,omitempty" xml:"SourceIpAddress,omitempty"`
	// The port number that is used to connect to the self-managed PostgreSQL instance.
	SourcePort *int64 `json:"SourcePort,omitempty" xml:"SourcePort,omitempty"`
	// The ID of the identification task.
	TaskId *int64 `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
}

func (s ActivateMigrationTargetInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ActivateMigrationTargetInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *ActivateMigrationTargetInstanceResponseBody) SetDBInstanceName(v string) *ActivateMigrationTargetInstanceResponseBody {
	s.DBInstanceName = &v
	return s
}

func (s *ActivateMigrationTargetInstanceResponseBody) SetRequestId(v string) *ActivateMigrationTargetInstanceResponseBody {
	s.RequestId = &v
	return s
}

func (s *ActivateMigrationTargetInstanceResponseBody) SetSourceIpAddress(v string) *ActivateMigrationTargetInstanceResponseBody {
	s.SourceIpAddress = &v
	return s
}

func (s *ActivateMigrationTargetInstanceResponseBody) SetSourcePort(v int64) *ActivateMigrationTargetInstanceResponseBody {
	s.SourcePort = &v
	return s
}

func (s *ActivateMigrationTargetInstanceResponseBody) SetTaskId(v int64) *ActivateMigrationTargetInstanceResponseBody {
	s.TaskId = &v
	return s
}

type ActivateMigrationTargetInstanceResponse struct {
	Headers    map[string]*string                           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ActivateMigrationTargetInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ActivateMigrationTargetInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s ActivateMigrationTargetInstanceResponse) GoString() string {
	return s.String()
}

func (s *ActivateMigrationTargetInstanceResponse) SetHeaders(v map[string]*string) *ActivateMigrationTargetInstanceResponse {
	s.Headers = v
	return s
}

func (s *ActivateMigrationTargetInstanceResponse) SetStatusCode(v int32) *ActivateMigrationTargetInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *ActivateMigrationTargetInstanceResponse) SetBody(v *ActivateMigrationTargetInstanceResponseBody) *ActivateMigrationTargetInstanceResponse {
	s.Body = v
	return s
}

type AddTagsToResourceRequest struct {
	Tag []*AddTagsToResourceRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the generated token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The instance ID.
	//
	// >  You can enter up to 30 instance IDs in a single request. If you enter more than one instance ID, you must separate the instance IDs with commas (,).
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID. You can call the [DescribeRegions](~~26243~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The tags that you want to add. Each tag consists of a tag key and a tag value. You can specify a maximum of five tags in the following format for each request: {"key1":"value1","key2":"value2"...}.
	//
	// >  The tag key is required and the tag value is optional.
	Tags *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
	// The ID of the proxy mode.
	ProxyId *string `json:"proxyId,omitempty" xml:"proxyId,omitempty"`
}

func (s AddTagsToResourceRequest) String() string {
	return tea.Prettify(s)
}

func (s AddTagsToResourceRequest) GoString() string {
	return s.String()
}

func (s *AddTagsToResourceRequest) SetTag(v []*AddTagsToResourceRequestTag) *AddTagsToResourceRequest {
	s.Tag = v
	return s
}

func (s *AddTagsToResourceRequest) SetClientToken(v string) *AddTagsToResourceRequest {
	s.ClientToken = &v
	return s
}

func (s *AddTagsToResourceRequest) SetDBInstanceId(v string) *AddTagsToResourceRequest {
	s.DBInstanceId = &v
	return s
}

func (s *AddTagsToResourceRequest) SetOwnerAccount(v string) *AddTagsToResourceRequest {
	s.OwnerAccount = &v
	return s
}

func (s *AddTagsToResourceRequest) SetOwnerId(v int64) *AddTagsToResourceRequest {
	s.OwnerId = &v
	return s
}

func (s *AddTagsToResourceRequest) SetRegionId(v string) *AddTagsToResourceRequest {
	s.RegionId = &v
	return s
}

func (s *AddTagsToResourceRequest) SetResourceGroupId(v string) *AddTagsToResourceRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *AddTagsToResourceRequest) SetResourceOwnerAccount(v string) *AddTagsToResourceRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *AddTagsToResourceRequest) SetResourceOwnerId(v int64) *AddTagsToResourceRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *AddTagsToResourceRequest) SetTags(v string) *AddTagsToResourceRequest {
	s.Tags = &v
	return s
}

func (s *AddTagsToResourceRequest) SetProxyId(v string) *AddTagsToResourceRequest {
	s.ProxyId = &v
	return s
}

type AddTagsToResourceRequestTag struct {
	// The tag key of the first tag that you want to add. Each tag consists of a tag key and a tag value. You can specify up to five tags in a single request. You cannot specify an empty string as the tag key. You can specify an empty string as the tag value.
	Key *string `json:"key,omitempty" xml:"key,omitempty"`
	// The tag value of the first tag that you want to add. Each tag consists of a tag key and a tag value. You can specify up to five tags in a single request. You cannot specify an empty string as the tag key. You can specify an empty string as the tag value.
	Value *string `json:"value,omitempty" xml:"value,omitempty"`
}

func (s AddTagsToResourceRequestTag) String() string {
	return tea.Prettify(s)
}

func (s AddTagsToResourceRequestTag) GoString() string {
	return s.String()
}

func (s *AddTagsToResourceRequestTag) SetKey(v string) *AddTagsToResourceRequestTag {
	s.Key = &v
	return s
}

func (s *AddTagsToResourceRequestTag) SetValue(v string) *AddTagsToResourceRequestTag {
	s.Value = &v
	return s
}

type AddTagsToResourceResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AddTagsToResourceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddTagsToResourceResponseBody) GoString() string {
	return s.String()
}

func (s *AddTagsToResourceResponseBody) SetRequestId(v string) *AddTagsToResourceResponseBody {
	s.RequestId = &v
	return s
}

type AddTagsToResourceResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddTagsToResourceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddTagsToResourceResponse) String() string {
	return tea.Prettify(s)
}

func (s AddTagsToResourceResponse) GoString() string {
	return s.String()
}

func (s *AddTagsToResourceResponse) SetHeaders(v map[string]*string) *AddTagsToResourceResponse {
	s.Headers = v
	return s
}

func (s *AddTagsToResourceResponse) SetStatusCode(v int32) *AddTagsToResourceResponse {
	s.StatusCode = &v
	return s
}

func (s *AddTagsToResourceResponse) SetBody(v *AddTagsToResourceResponseBody) *AddTagsToResourceResponse {
	s.Body = v
	return s
}

type AllocateInstancePublicConnectionRequest struct {
	// The Tabular Data Stream (TDS) port of the instance for which Babelfish is enabled.
	//
	// > This parameter applies only to ApsaraDB RDS for PostgreSQL instances. For more information about Babelfish for ApsaraDB RDS for PostgreSQL, see [Introduction to Babelfish](~~428613~~).
	BabelfishPort *string `json:"BabelfishPort,omitempty" xml:"BabelfishPort,omitempty"`
	// The prefix of the public endpoint. A valid public endpoint is in the following format: `Prefix.Database engine.rds.aliyuncs.com`. Example: `test1234.mysql.rds.aliyuncs.com`.
	//
	// > The value can be 5 to 40 characters in length and can contain letters, digits, and hyphens (-). The value cannot contain any of the following characters: ~ ! # % ^ & \* = + | {} ; : \" " , <> / ?
	ConnectionStringPrefix *string `json:"ConnectionStringPrefix,omitempty" xml:"ConnectionStringPrefix,omitempty"`
	// The ID of the instance. You can call the [DescribeDBInstances](~~610396~~) operation to query the ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The name of the dedicated cluster to which the instance belongs. This parameter is available only when the instance is created in an ApsaraDB MyBase cluster that runs MySQL on Standard Edition.
	GeneralGroupName *string `json:"GeneralGroupName,omitempty" xml:"GeneralGroupName,omitempty"`
	OwnerAccount     *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId          *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The PgBouncer port.
	//
	// > This parameter is available only for instances that run PostgreSQL.
	PGBouncerPort *string `json:"PGBouncerPort,omitempty" xml:"PGBouncerPort,omitempty"`
	// The public port of the instance. Valid values: **1000 to 5999**.
	Port                 *string `json:"Port,omitempty" xml:"Port,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s AllocateInstancePublicConnectionRequest) String() string {
	return tea.Prettify(s)
}

func (s AllocateInstancePublicConnectionRequest) GoString() string {
	return s.String()
}

func (s *AllocateInstancePublicConnectionRequest) SetBabelfishPort(v string) *AllocateInstancePublicConnectionRequest {
	s.BabelfishPort = &v
	return s
}

func (s *AllocateInstancePublicConnectionRequest) SetConnectionStringPrefix(v string) *AllocateInstancePublicConnectionRequest {
	s.ConnectionStringPrefix = &v
	return s
}

func (s *AllocateInstancePublicConnectionRequest) SetDBInstanceId(v string) *AllocateInstancePublicConnectionRequest {
	s.DBInstanceId = &v
	return s
}

func (s *AllocateInstancePublicConnectionRequest) SetGeneralGroupName(v string) *AllocateInstancePublicConnectionRequest {
	s.GeneralGroupName = &v
	return s
}

func (s *AllocateInstancePublicConnectionRequest) SetOwnerAccount(v string) *AllocateInstancePublicConnectionRequest {
	s.OwnerAccount = &v
	return s
}

func (s *AllocateInstancePublicConnectionRequest) SetOwnerId(v int64) *AllocateInstancePublicConnectionRequest {
	s.OwnerId = &v
	return s
}

func (s *AllocateInstancePublicConnectionRequest) SetPGBouncerPort(v string) *AllocateInstancePublicConnectionRequest {
	s.PGBouncerPort = &v
	return s
}

func (s *AllocateInstancePublicConnectionRequest) SetPort(v string) *AllocateInstancePublicConnectionRequest {
	s.Port = &v
	return s
}

func (s *AllocateInstancePublicConnectionRequest) SetResourceOwnerAccount(v string) *AllocateInstancePublicConnectionRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *AllocateInstancePublicConnectionRequest) SetResourceOwnerId(v int64) *AllocateInstancePublicConnectionRequest {
	s.ResourceOwnerId = &v
	return s
}

type AllocateInstancePublicConnectionResponseBody struct {
	// The endpoint that is used to connect to the database instance.
	ConnectionString *string `json:"ConnectionString,omitempty" xml:"ConnectionString,omitempty"`
	// The ID of the instance.
	DbInstanceName *string `json:"DbInstanceName,omitempty" xml:"DbInstanceName,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AllocateInstancePublicConnectionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AllocateInstancePublicConnectionResponseBody) GoString() string {
	return s.String()
}

func (s *AllocateInstancePublicConnectionResponseBody) SetConnectionString(v string) *AllocateInstancePublicConnectionResponseBody {
	s.ConnectionString = &v
	return s
}

func (s *AllocateInstancePublicConnectionResponseBody) SetDbInstanceName(v string) *AllocateInstancePublicConnectionResponseBody {
	s.DbInstanceName = &v
	return s
}

func (s *AllocateInstancePublicConnectionResponseBody) SetRequestId(v string) *AllocateInstancePublicConnectionResponseBody {
	s.RequestId = &v
	return s
}

type AllocateInstancePublicConnectionResponse struct {
	Headers    map[string]*string                            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AllocateInstancePublicConnectionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AllocateInstancePublicConnectionResponse) String() string {
	return tea.Prettify(s)
}

func (s AllocateInstancePublicConnectionResponse) GoString() string {
	return s.String()
}

func (s *AllocateInstancePublicConnectionResponse) SetHeaders(v map[string]*string) *AllocateInstancePublicConnectionResponse {
	s.Headers = v
	return s
}

func (s *AllocateInstancePublicConnectionResponse) SetStatusCode(v int32) *AllocateInstancePublicConnectionResponse {
	s.StatusCode = &v
	return s
}

func (s *AllocateInstancePublicConnectionResponse) SetBody(v *AllocateInstancePublicConnectionResponseBody) *AllocateInstancePublicConnectionResponse {
	s.Body = v
	return s
}

type AllocateReadWriteSplittingConnectionRequest struct {
	// The prefix of the read-only routing endpoint. The prefix must be unique. It can be up to 30 characters in length and can contain lowercase letters and hyphens (-). It must start with a lowercase letter.
	//
	// >  The default prefix consists of the name of the primary instance followed by the letters rw.
	ConnectionStringPrefix *string `json:"ConnectionStringPrefix,omitempty" xml:"ConnectionStringPrefix,omitempty"`
	// The ID of the primary instance. You can call the [DescribeDBInstances](~~26232~~) operation to query the ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The method that is used to assign read weights. Valid values:
	//
	// *   **Standard**: ApsaraDB RDS automatically assigns read weights to the primary and read-only instances based on the specifications of these instances.
	// *   **Custom**: You must manually assign a read weight to each instance.
	DistributionType *string `json:"DistributionType,omitempty" xml:"DistributionType,omitempty"`
	// The threshold of the latency that is allowed on the read-only instances. Valid values: 0 to 7200. Default value: 30. Unit: seconds.
	//
	// >  If the latency on a read-only instance exceeds the specified threshold, ApsaraDB RDS does not forward read requests to the read-only instance.
	MaxDelayTime *string `json:"MaxDelayTime,omitempty" xml:"MaxDelayTime,omitempty"`
	// The network type of the read-only routing endpoint. Valid values:
	//
	// *   **Internet**: Internet
	// *   **Intranet**: internal network
	//
	// >  The default value is Intranet. Make sure that the network type of the read-only routing endpoint is the same as that of the primary instance.
	NetType      *string `json:"NetType,omitempty" xml:"NetType,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The port that is associated with the read-only routing endpoint. Valid values: 1000 to 5999. Default value: 1433.
	Port                 *string `json:"Port,omitempty" xml:"Port,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The read weights of the primary instance and its read-only instances. The read weight is increased in increments of 100. The maximum value is 10000.
	//
	// * For ApsaraDB RDS instances, the value of this parameter is in the following format: `{"<ID of the read-only instance >":<Weight>,"master":<Weight>,"slave":<Weight>}`.
	// * For ApsaraDB MyBase instances, the value of this parameter is in the following format: `[{"instanceName":"<ID of the primary instance>","weight":<Weight>,"role":"master"},{"instanceName":"<ID of the primary instance>","weight":<Weight>,"role":"slave"},{"instanceName":"<ID of the read-only instance>","weight":<Weight>,"role":"master"}]`
	//
	// > * If you set the **DistributionType** parameter to **Custom**, you must also specify this parameter.
	// > * If you set the **DistributionType** parameter to **Standard**, this parameter is invalid.
	Weight *string `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s AllocateReadWriteSplittingConnectionRequest) String() string {
	return tea.Prettify(s)
}

func (s AllocateReadWriteSplittingConnectionRequest) GoString() string {
	return s.String()
}

func (s *AllocateReadWriteSplittingConnectionRequest) SetConnectionStringPrefix(v string) *AllocateReadWriteSplittingConnectionRequest {
	s.ConnectionStringPrefix = &v
	return s
}

func (s *AllocateReadWriteSplittingConnectionRequest) SetDBInstanceId(v string) *AllocateReadWriteSplittingConnectionRequest {
	s.DBInstanceId = &v
	return s
}

func (s *AllocateReadWriteSplittingConnectionRequest) SetDistributionType(v string) *AllocateReadWriteSplittingConnectionRequest {
	s.DistributionType = &v
	return s
}

func (s *AllocateReadWriteSplittingConnectionRequest) SetMaxDelayTime(v string) *AllocateReadWriteSplittingConnectionRequest {
	s.MaxDelayTime = &v
	return s
}

func (s *AllocateReadWriteSplittingConnectionRequest) SetNetType(v string) *AllocateReadWriteSplittingConnectionRequest {
	s.NetType = &v
	return s
}

func (s *AllocateReadWriteSplittingConnectionRequest) SetOwnerAccount(v string) *AllocateReadWriteSplittingConnectionRequest {
	s.OwnerAccount = &v
	return s
}

func (s *AllocateReadWriteSplittingConnectionRequest) SetOwnerId(v int64) *AllocateReadWriteSplittingConnectionRequest {
	s.OwnerId = &v
	return s
}

func (s *AllocateReadWriteSplittingConnectionRequest) SetPort(v string) *AllocateReadWriteSplittingConnectionRequest {
	s.Port = &v
	return s
}

func (s *AllocateReadWriteSplittingConnectionRequest) SetResourceOwnerAccount(v string) *AllocateReadWriteSplittingConnectionRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *AllocateReadWriteSplittingConnectionRequest) SetResourceOwnerId(v int64) *AllocateReadWriteSplittingConnectionRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *AllocateReadWriteSplittingConnectionRequest) SetWeight(v string) *AllocateReadWriteSplittingConnectionRequest {
	s.Weight = &v
	return s
}

type AllocateReadWriteSplittingConnectionResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AllocateReadWriteSplittingConnectionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AllocateReadWriteSplittingConnectionResponseBody) GoString() string {
	return s.String()
}

func (s *AllocateReadWriteSplittingConnectionResponseBody) SetRequestId(v string) *AllocateReadWriteSplittingConnectionResponseBody {
	s.RequestId = &v
	return s
}

type AllocateReadWriteSplittingConnectionResponse struct {
	Headers    map[string]*string                                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AllocateReadWriteSplittingConnectionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AllocateReadWriteSplittingConnectionResponse) String() string {
	return tea.Prettify(s)
}

func (s AllocateReadWriteSplittingConnectionResponse) GoString() string {
	return s.String()
}

func (s *AllocateReadWriteSplittingConnectionResponse) SetHeaders(v map[string]*string) *AllocateReadWriteSplittingConnectionResponse {
	s.Headers = v
	return s
}

func (s *AllocateReadWriteSplittingConnectionResponse) SetStatusCode(v int32) *AllocateReadWriteSplittingConnectionResponse {
	s.StatusCode = &v
	return s
}

func (s *AllocateReadWriteSplittingConnectionResponse) SetBody(v *AllocateReadWriteSplittingConnectionResponseBody) *AllocateReadWriteSplittingConnectionResponse {
	s.Body = v
	return s
}

type AttachWhitelistTemplateToInstanceRequest struct {
	// The name of the instance.
	InsName *string `json:"InsName,omitempty" xml:"InsName,omitempty"`
	// The ID of the resource group. For more information about resource groups, see Resource groups.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the whitelist template. You can call the DescribeAllWhitelistTemplate operation to obtain the ID of the whitelist template.
	TemplateId *int32 `json:"TemplateId,omitempty" xml:"TemplateId,omitempty"`
}

func (s AttachWhitelistTemplateToInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s AttachWhitelistTemplateToInstanceRequest) GoString() string {
	return s.String()
}

func (s *AttachWhitelistTemplateToInstanceRequest) SetInsName(v string) *AttachWhitelistTemplateToInstanceRequest {
	s.InsName = &v
	return s
}

func (s *AttachWhitelistTemplateToInstanceRequest) SetResourceGroupId(v string) *AttachWhitelistTemplateToInstanceRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *AttachWhitelistTemplateToInstanceRequest) SetResourceOwnerAccount(v string) *AttachWhitelistTemplateToInstanceRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *AttachWhitelistTemplateToInstanceRequest) SetResourceOwnerId(v int64) *AttachWhitelistTemplateToInstanceRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *AttachWhitelistTemplateToInstanceRequest) SetTemplateId(v int32) *AttachWhitelistTemplateToInstanceRequest {
	s.TemplateId = &v
	return s
}

type AttachWhitelistTemplateToInstanceResponseBody struct {
	// The response code returned. Valid values:
	//
	// *   **200**: success
	// *   **400**: client error
	// *   **401**: identity authentication failed
	// *   **404**: request page not found
	// *   **500**: server error
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data returned.
	Data *AttachWhitelistTemplateToInstanceResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The HTTP status code returned. Valid values:
	//
	// *   **200**: success
	// *   **400**: client error
	// *   **500**: server error
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful. Valid values:
	//
	// *   **true**
	// *   **false**
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s AttachWhitelistTemplateToInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AttachWhitelistTemplateToInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *AttachWhitelistTemplateToInstanceResponseBody) SetCode(v string) *AttachWhitelistTemplateToInstanceResponseBody {
	s.Code = &v
	return s
}

func (s *AttachWhitelistTemplateToInstanceResponseBody) SetData(v *AttachWhitelistTemplateToInstanceResponseBodyData) *AttachWhitelistTemplateToInstanceResponseBody {
	s.Data = v
	return s
}

func (s *AttachWhitelistTemplateToInstanceResponseBody) SetHttpStatusCode(v int32) *AttachWhitelistTemplateToInstanceResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *AttachWhitelistTemplateToInstanceResponseBody) SetMessage(v string) *AttachWhitelistTemplateToInstanceResponseBody {
	s.Message = &v
	return s
}

func (s *AttachWhitelistTemplateToInstanceResponseBody) SetRequestId(v string) *AttachWhitelistTemplateToInstanceResponseBody {
	s.RequestId = &v
	return s
}

func (s *AttachWhitelistTemplateToInstanceResponseBody) SetSuccess(v bool) *AttachWhitelistTemplateToInstanceResponseBody {
	s.Success = &v
	return s
}

type AttachWhitelistTemplateToInstanceResponseBodyData struct {
	// The status code returned. Valid values:
	//
	// *   **ok**: The request is successful.
	// *   **error**: The request fails.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s AttachWhitelistTemplateToInstanceResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s AttachWhitelistTemplateToInstanceResponseBodyData) GoString() string {
	return s.String()
}

func (s *AttachWhitelistTemplateToInstanceResponseBodyData) SetStatus(v string) *AttachWhitelistTemplateToInstanceResponseBodyData {
	s.Status = &v
	return s
}

type AttachWhitelistTemplateToInstanceResponse struct {
	Headers    map[string]*string                             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AttachWhitelistTemplateToInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AttachWhitelistTemplateToInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s AttachWhitelistTemplateToInstanceResponse) GoString() string {
	return s.String()
}

func (s *AttachWhitelistTemplateToInstanceResponse) SetHeaders(v map[string]*string) *AttachWhitelistTemplateToInstanceResponse {
	s.Headers = v
	return s
}

func (s *AttachWhitelistTemplateToInstanceResponse) SetStatusCode(v int32) *AttachWhitelistTemplateToInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *AttachWhitelistTemplateToInstanceResponse) SetBody(v *AttachWhitelistTemplateToInstanceResponseBody) *AttachWhitelistTemplateToInstanceResponse {
	s.Body = v
	return s
}

type CalculateDBInstanceWeightRequest struct {
	// The ID of the primary instance. You can call the [DescribeDBInstances](~~610396~~) operation to query the instance ID.
	DBInstanceId    *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	ResourceOwnerId *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s CalculateDBInstanceWeightRequest) String() string {
	return tea.Prettify(s)
}

func (s CalculateDBInstanceWeightRequest) GoString() string {
	return s.String()
}

func (s *CalculateDBInstanceWeightRequest) SetDBInstanceId(v string) *CalculateDBInstanceWeightRequest {
	s.DBInstanceId = &v
	return s
}

func (s *CalculateDBInstanceWeightRequest) SetResourceOwnerId(v int64) *CalculateDBInstanceWeightRequest {
	s.ResourceOwnerId = &v
	return s
}

type CalculateDBInstanceWeightResponseBody struct {
	// An array that consists of information about the system-assigned read weight.
	Items *CalculateDBInstanceWeightResponseBodyItems `json:"Items,omitempty" xml:"Items,omitempty" type:"Struct"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CalculateDBInstanceWeightResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CalculateDBInstanceWeightResponseBody) GoString() string {
	return s.String()
}

func (s *CalculateDBInstanceWeightResponseBody) SetItems(v *CalculateDBInstanceWeightResponseBodyItems) *CalculateDBInstanceWeightResponseBody {
	s.Items = v
	return s
}

func (s *CalculateDBInstanceWeightResponseBody) SetRequestId(v string) *CalculateDBInstanceWeightResponseBody {
	s.RequestId = &v
	return s
}

type CalculateDBInstanceWeightResponseBodyItems struct {
	DBInstanceWeight []*CalculateDBInstanceWeightResponseBodyItemsDBInstanceWeight `json:"DBInstanceWeight,omitempty" xml:"DBInstanceWeight,omitempty" type:"Repeated"`
}

func (s CalculateDBInstanceWeightResponseBodyItems) String() string {
	return tea.Prettify(s)
}

func (s CalculateDBInstanceWeightResponseBodyItems) GoString() string {
	return s.String()
}

func (s *CalculateDBInstanceWeightResponseBodyItems) SetDBInstanceWeight(v []*CalculateDBInstanceWeightResponseBodyItemsDBInstanceWeight) *CalculateDBInstanceWeightResponseBodyItems {
	s.DBInstanceWeight = v
	return s
}

type CalculateDBInstanceWeightResponseBodyItemsDBInstanceWeight struct {
	// The instance ID
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The type of the instance. Valid values:
	//
	// *   **Master**: primary instance
	// *   **Readonly**: read-only instance
	DBInstanceType *string `json:"DBInstanceType,omitempty" xml:"DBInstanceType,omitempty"`
	// The latency at which the read-only instances replicate data. The read-only instances replicate data from the primary instance at the latency that is specified by the **ReadonlyInstanceSQLDelayedTime** parameter. Unit: seconds.
	ReadonlyInstanceSQLDelayedTime *string `json:"ReadonlyInstanceSQLDelayedTime,omitempty" xml:"ReadonlyInstanceSQLDelayedTime,omitempty"`
	// The read weight that the system calculates in real time for the instance.
	Weight *string `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s CalculateDBInstanceWeightResponseBodyItemsDBInstanceWeight) String() string {
	return tea.Prettify(s)
}

func (s CalculateDBInstanceWeightResponseBodyItemsDBInstanceWeight) GoString() string {
	return s.String()
}

func (s *CalculateDBInstanceWeightResponseBodyItemsDBInstanceWeight) SetDBInstanceId(v string) *CalculateDBInstanceWeightResponseBodyItemsDBInstanceWeight {
	s.DBInstanceId = &v
	return s
}

func (s *CalculateDBInstanceWeightResponseBodyItemsDBInstanceWeight) SetDBInstanceType(v string) *CalculateDBInstanceWeightResponseBodyItemsDBInstanceWeight {
	s.DBInstanceType = &v
	return s
}

func (s *CalculateDBInstanceWeightResponseBodyItemsDBInstanceWeight) SetReadonlyInstanceSQLDelayedTime(v string) *CalculateDBInstanceWeightResponseBodyItemsDBInstanceWeight {
	s.ReadonlyInstanceSQLDelayedTime = &v
	return s
}

func (s *CalculateDBInstanceWeightResponseBodyItemsDBInstanceWeight) SetWeight(v string) *CalculateDBInstanceWeightResponseBodyItemsDBInstanceWeight {
	s.Weight = &v
	return s
}

type CalculateDBInstanceWeightResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CalculateDBInstanceWeightResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CalculateDBInstanceWeightResponse) String() string {
	return tea.Prettify(s)
}

func (s CalculateDBInstanceWeightResponse) GoString() string {
	return s.String()
}

func (s *CalculateDBInstanceWeightResponse) SetHeaders(v map[string]*string) *CalculateDBInstanceWeightResponse {
	s.Headers = v
	return s
}

func (s *CalculateDBInstanceWeightResponse) SetStatusCode(v int32) *CalculateDBInstanceWeightResponse {
	s.StatusCode = &v
	return s
}

func (s *CalculateDBInstanceWeightResponse) SetBody(v *CalculateDBInstanceWeightResponseBody) *CalculateDBInstanceWeightResponse {
	s.Body = v
	return s
}

type CancelImportRequest struct {
	// The ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The ID of the migration task.
	//
	// > This parameter is returned when the migration task is started. For more information, see [ImportDatabaseBetweenInstances](~~26301~~).
	ImportId     *int32  `json:"ImportId,omitempty" xml:"ImportId,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s CancelImportRequest) String() string {
	return tea.Prettify(s)
}

func (s CancelImportRequest) GoString() string {
	return s.String()
}

func (s *CancelImportRequest) SetDBInstanceId(v string) *CancelImportRequest {
	s.DBInstanceId = &v
	return s
}

func (s *CancelImportRequest) SetImportId(v int32) *CancelImportRequest {
	s.ImportId = &v
	return s
}

func (s *CancelImportRequest) SetOwnerAccount(v string) *CancelImportRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CancelImportRequest) SetOwnerId(v int64) *CancelImportRequest {
	s.OwnerId = &v
	return s
}

func (s *CancelImportRequest) SetResourceGroupId(v string) *CancelImportRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *CancelImportRequest) SetResourceOwnerAccount(v string) *CancelImportRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CancelImportRequest) SetResourceOwnerId(v int64) *CancelImportRequest {
	s.ResourceOwnerId = &v
	return s
}

type CancelImportResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CancelImportResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CancelImportResponseBody) GoString() string {
	return s.String()
}

func (s *CancelImportResponseBody) SetRequestId(v string) *CancelImportResponseBody {
	s.RequestId = &v
	return s
}

type CancelImportResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CancelImportResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CancelImportResponse) String() string {
	return tea.Prettify(s)
}

func (s CancelImportResponse) GoString() string {
	return s.String()
}

func (s *CancelImportResponse) SetHeaders(v map[string]*string) *CancelImportResponse {
	s.Headers = v
	return s
}

func (s *CancelImportResponse) SetStatusCode(v int32) *CancelImportResponse {
	s.StatusCode = &v
	return s
}

func (s *CancelImportResponse) SetBody(v *CancelImportResponseBody) *CancelImportResponse {
	s.Body = v
	return s
}

type CheckAccountNameAvailableRequest struct {
	// The username of the account.
	//
	// *   The value must be unique.
	//
	// *   The value must start with a lowercase letter, and end with a lowercase letter or a digit.
	//
	// *   The value can contain lowercase letters, digits, and underscores (\_).
	//
	// *   The length of the value must meet the following requirements:
	//
	//     *   If the instance runs MySQL 5.7 or MySQL 8.0, the value must be 2 to 32 characters in length.
	//     *   If the instance runs MySQL 5.6, the value must be 2 to 16 characters in length.
	//     *   If the instance runs SQL Server, the value must be 2 to 64 characters in length.
	//     *   If the instance runs PostgreSQL with cloud disks, the value must be 2 to 63 characters in length.
	//     *   If the instance runs PostgreSQL with local disks, the value must be 2 to 16 characters in length.
	//     *   If the instance runs MariaDB, the value must be 2 to 16 characters in length.
	//
	// *   For more information about invalid characters, see [Forbidden keywords table](~~26317~~).
	AccountName *string `json:"AccountName,omitempty" xml:"AccountName,omitempty"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The instance ID. You can call the [DescribeDBInstances](~~610396~~) operation to query the ID of the instance.
	//
	// >  This operation is not supported for instances that run SQL Server 2017 (cluster edition).
	DBInstanceId         *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
}

func (s CheckAccountNameAvailableRequest) String() string {
	return tea.Prettify(s)
}

func (s CheckAccountNameAvailableRequest) GoString() string {
	return s.String()
}

func (s *CheckAccountNameAvailableRequest) SetAccountName(v string) *CheckAccountNameAvailableRequest {
	s.AccountName = &v
	return s
}

func (s *CheckAccountNameAvailableRequest) SetClientToken(v string) *CheckAccountNameAvailableRequest {
	s.ClientToken = &v
	return s
}

func (s *CheckAccountNameAvailableRequest) SetDBInstanceId(v string) *CheckAccountNameAvailableRequest {
	s.DBInstanceId = &v
	return s
}

func (s *CheckAccountNameAvailableRequest) SetOwnerAccount(v string) *CheckAccountNameAvailableRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CheckAccountNameAvailableRequest) SetOwnerId(v int64) *CheckAccountNameAvailableRequest {
	s.OwnerId = &v
	return s
}

func (s *CheckAccountNameAvailableRequest) SetResourceOwnerAccount(v string) *CheckAccountNameAvailableRequest {
	s.ResourceOwnerAccount = &v
	return s
}

type CheckAccountNameAvailableResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CheckAccountNameAvailableResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CheckAccountNameAvailableResponseBody) GoString() string {
	return s.String()
}

func (s *CheckAccountNameAvailableResponseBody) SetRequestId(v string) *CheckAccountNameAvailableResponseBody {
	s.RequestId = &v
	return s
}

type CheckAccountNameAvailableResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CheckAccountNameAvailableResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CheckAccountNameAvailableResponse) String() string {
	return tea.Prettify(s)
}

func (s CheckAccountNameAvailableResponse) GoString() string {
	return s.String()
}

func (s *CheckAccountNameAvailableResponse) SetHeaders(v map[string]*string) *CheckAccountNameAvailableResponse {
	s.Headers = v
	return s
}

func (s *CheckAccountNameAvailableResponse) SetStatusCode(v int32) *CheckAccountNameAvailableResponse {
	s.StatusCode = &v
	return s
}

func (s *CheckAccountNameAvailableResponse) SetBody(v *CheckAccountNameAvailableResponseBody) *CheckAccountNameAvailableResponse {
	s.Body = v
	return s
}

type CheckCloudResourceAuthorizedRequest struct {
	// The ID of the instance. You can call the [DescribeDBInstances](~~26232~~) operation to query the ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the instance. You can call the [DescribeRegions](~~26243~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	SecurityToken        *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
	// The ID of the destination region. You can call the [DescribeRegions](~~26243~~) operation to query the most recent region list.
	TargetRegionId *string `json:"TargetRegionId,omitempty" xml:"TargetRegionId,omitempty"`
}

func (s CheckCloudResourceAuthorizedRequest) String() string {
	return tea.Prettify(s)
}

func (s CheckCloudResourceAuthorizedRequest) GoString() string {
	return s.String()
}

func (s *CheckCloudResourceAuthorizedRequest) SetDBInstanceId(v string) *CheckCloudResourceAuthorizedRequest {
	s.DBInstanceId = &v
	return s
}

func (s *CheckCloudResourceAuthorizedRequest) SetOwnerAccount(v string) *CheckCloudResourceAuthorizedRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CheckCloudResourceAuthorizedRequest) SetOwnerId(v int64) *CheckCloudResourceAuthorizedRequest {
	s.OwnerId = &v
	return s
}

func (s *CheckCloudResourceAuthorizedRequest) SetRegionId(v string) *CheckCloudResourceAuthorizedRequest {
	s.RegionId = &v
	return s
}

func (s *CheckCloudResourceAuthorizedRequest) SetResourceGroupId(v string) *CheckCloudResourceAuthorizedRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *CheckCloudResourceAuthorizedRequest) SetResourceOwnerAccount(v string) *CheckCloudResourceAuthorizedRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CheckCloudResourceAuthorizedRequest) SetResourceOwnerId(v int64) *CheckCloudResourceAuthorizedRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CheckCloudResourceAuthorizedRequest) SetSecurityToken(v string) *CheckCloudResourceAuthorizedRequest {
	s.SecurityToken = &v
	return s
}

func (s *CheckCloudResourceAuthorizedRequest) SetTargetRegionId(v string) *CheckCloudResourceAuthorizedRequest {
	s.TargetRegionId = &v
	return s
}

type CheckCloudResourceAuthorizedResponseBody struct {
	// The authorization status. Valid values:
	//
	// *   **1**: authorized
	// *   **0**: not authorized
	AuthorizationState *int32 `json:"AuthorizationState,omitempty" xml:"AuthorizationState,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The Alibaba Cloud Resource Name (ARN) of the RAM role. A RAM role is a virtual identity that you can create within your Alibaba Cloud account. For more information, see [RAM role overview](~~93689~~).
	//
	// >  This parameter is available only when the instance runs MySQL.
	RoleArn *string `json:"RoleArn,omitempty" xml:"RoleArn,omitempty"`
}

func (s CheckCloudResourceAuthorizedResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CheckCloudResourceAuthorizedResponseBody) GoString() string {
	return s.String()
}

func (s *CheckCloudResourceAuthorizedResponseBody) SetAuthorizationState(v int32) *CheckCloudResourceAuthorizedResponseBody {
	s.AuthorizationState = &v
	return s
}

func (s *CheckCloudResourceAuthorizedResponseBody) SetRequestId(v string) *CheckCloudResourceAuthorizedResponseBody {
	s.RequestId = &v
	return s
}

func (s *CheckCloudResourceAuthorizedResponseBody) SetRoleArn(v string) *CheckCloudResourceAuthorizedResponseBody {
	s.RoleArn = &v
	return s
}

type CheckCloudResourceAuthorizedResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CheckCloudResourceAuthorizedResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CheckCloudResourceAuthorizedResponse) String() string {
	return tea.Prettify(s)
}

func (s CheckCloudResourceAuthorizedResponse) GoString() string {
	return s.String()
}

func (s *CheckCloudResourceAuthorizedResponse) SetHeaders(v map[string]*string) *CheckCloudResourceAuthorizedResponse {
	s.Headers = v
	return s
}

func (s *CheckCloudResourceAuthorizedResponse) SetStatusCode(v int32) *CheckCloudResourceAuthorizedResponse {
	s.StatusCode = &v
	return s
}

func (s *CheckCloudResourceAuthorizedResponse) SetBody(v *CheckCloudResourceAuthorizedResponseBody) *CheckCloudResourceAuthorizedResponse {
	s.Body = v
	return s
}

type CheckCreateDdrDBInstanceRequest struct {
	// The ID of the backup set that is used for the restoration. You can call the [DescribeCrossRegionBackups](~~121733~~) operation to query the ID of the backup set.
	//
	// > If you set **RestoreType** to **0**, you must also specify this parameter.
	BackupSetId *string `json:"BackupSetId,omitempty" xml:"BackupSetId,omitempty"`
	// The instance type of the destination instance. For more information, see [Primary ApsaraDB RDS instance types](~~26312~~).
	DBInstanceClass *string `json:"DBInstanceClass,omitempty" xml:"DBInstanceClass,omitempty"`
	// The storage capacity of the destination instance. Valid values: **5 to 2000**. Unit: GB. You can increase the storage capacity in increments of 5 GB. For more information, see [Primary instance types](~~26312~~).
	DBInstanceStorage *int32 `json:"DBInstanceStorage,omitempty" xml:"DBInstanceStorage,omitempty"`
	// The database engine of the destination instance. Valid values:
	//
	// *   **MySQL**
	// *   **SQLServer**
	// *   **PostgreSQL**
	Engine *string `json:"Engine,omitempty" xml:"Engine,omitempty"`
	// The major engine version of the destination instance. The value of this parameter varies based on the value of **Engine**.
	//
	// *   Valid values when Engine is set to MySQL: **5.5, 5.6, 5.7, and 8.0**
	// *   Valid values when Engine is set to SQLServer: **2008r2, 08r2\_ent_ha, 2012, 2012\_ent_ha, 2012\_std_ha, 2012\_web, 2014\_std_ha, 2016\_ent_ha, 2016\_std_ha, 2016\_web, 2017\_std_ha, 2017\_ent, 2019\_std_ha, and 2019\_ent**
	// *   PostgreSQL: **10.0, 11.0, 12.0, 13.0, 14.0, and 15.0**
	EngineVersion *string `json:"EngineVersion,omitempty" xml:"EngineVersion,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the destination instance. You can call the [DescribeRegions](~~26243~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group. You can call the [DescribeDBInstanceAttribute](~~610394~~) to obtain the ID of the resource group.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The point in time to which you want to restore data. The point in time that you specify must be earlier than the current time. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// > If you set **RestoreType** to **1**, you must also specify this parameter.
	RestoreTime *string `json:"RestoreTime,omitempty" xml:"RestoreTime,omitempty"`
	// The method that is used to restore data. Valid values:
	//
	// *   **0**: restores data from a backup set. If you set this parameter to 0, you must also specify the **BackupSetId** parameter.
	// *   **1**: restores data to a point in time. If you set this parameter to 1, you must also specify the **RestoreTime**, **SourceRegion**, and **SourceDBInstanceName** parameters.
	//
	// Default value: **0**.
	RestoreType *string `json:"RestoreType,omitempty" xml:"RestoreType,omitempty"`
	// The ID of the source instance if you want to restore data to a point in time.
	//
	// > If you set **RestoreType** to **1**, you must also specify this parameter.
	SourceDBInstanceName *string `json:"SourceDBInstanceName,omitempty" xml:"SourceDBInstanceName,omitempty"`
	// The region ID of the source instance if you want to restore data to a point in time.
	//
	// > If you set **RestoreType** to **1**, you must also specify this parameter.
	SourceRegion *string `json:"SourceRegion,omitempty" xml:"SourceRegion,omitempty"`
}

func (s CheckCreateDdrDBInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s CheckCreateDdrDBInstanceRequest) GoString() string {
	return s.String()
}

func (s *CheckCreateDdrDBInstanceRequest) SetBackupSetId(v string) *CheckCreateDdrDBInstanceRequest {
	s.BackupSetId = &v
	return s
}

func (s *CheckCreateDdrDBInstanceRequest) SetDBInstanceClass(v string) *CheckCreateDdrDBInstanceRequest {
	s.DBInstanceClass = &v
	return s
}

func (s *CheckCreateDdrDBInstanceRequest) SetDBInstanceStorage(v int32) *CheckCreateDdrDBInstanceRequest {
	s.DBInstanceStorage = &v
	return s
}

func (s *CheckCreateDdrDBInstanceRequest) SetEngine(v string) *CheckCreateDdrDBInstanceRequest {
	s.Engine = &v
	return s
}

func (s *CheckCreateDdrDBInstanceRequest) SetEngineVersion(v string) *CheckCreateDdrDBInstanceRequest {
	s.EngineVersion = &v
	return s
}

func (s *CheckCreateDdrDBInstanceRequest) SetOwnerId(v int64) *CheckCreateDdrDBInstanceRequest {
	s.OwnerId = &v
	return s
}

func (s *CheckCreateDdrDBInstanceRequest) SetRegionId(v string) *CheckCreateDdrDBInstanceRequest {
	s.RegionId = &v
	return s
}

func (s *CheckCreateDdrDBInstanceRequest) SetResourceGroupId(v string) *CheckCreateDdrDBInstanceRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *CheckCreateDdrDBInstanceRequest) SetResourceOwnerAccount(v string) *CheckCreateDdrDBInstanceRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CheckCreateDdrDBInstanceRequest) SetResourceOwnerId(v int64) *CheckCreateDdrDBInstanceRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CheckCreateDdrDBInstanceRequest) SetRestoreTime(v string) *CheckCreateDdrDBInstanceRequest {
	s.RestoreTime = &v
	return s
}

func (s *CheckCreateDdrDBInstanceRequest) SetRestoreType(v string) *CheckCreateDdrDBInstanceRequest {
	s.RestoreType = &v
	return s
}

func (s *CheckCreateDdrDBInstanceRequest) SetSourceDBInstanceName(v string) *CheckCreateDdrDBInstanceRequest {
	s.SourceDBInstanceName = &v
	return s
}

func (s *CheckCreateDdrDBInstanceRequest) SetSourceRegion(v string) *CheckCreateDdrDBInstanceRequest {
	s.SourceRegion = &v
	return s
}

type CheckCreateDdrDBInstanceResponseBody struct {
	// Indicates whether the data of the source instance can be restored across regions. Valid values:
	//
	// *   **true**
	// *   **false**
	IsValid *string `json:"IsValid,omitempty" xml:"IsValid,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CheckCreateDdrDBInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CheckCreateDdrDBInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *CheckCreateDdrDBInstanceResponseBody) SetIsValid(v string) *CheckCreateDdrDBInstanceResponseBody {
	s.IsValid = &v
	return s
}

func (s *CheckCreateDdrDBInstanceResponseBody) SetRequestId(v string) *CheckCreateDdrDBInstanceResponseBody {
	s.RequestId = &v
	return s
}

type CheckCreateDdrDBInstanceResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CheckCreateDdrDBInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CheckCreateDdrDBInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s CheckCreateDdrDBInstanceResponse) GoString() string {
	return s.String()
}

func (s *CheckCreateDdrDBInstanceResponse) SetHeaders(v map[string]*string) *CheckCreateDdrDBInstanceResponse {
	s.Headers = v
	return s
}

func (s *CheckCreateDdrDBInstanceResponse) SetStatusCode(v int32) *CheckCreateDdrDBInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *CheckCreateDdrDBInstanceResponse) SetBody(v *CheckCreateDdrDBInstanceResponseBody) *CheckCreateDdrDBInstanceResponse {
	s.Body = v
	return s
}

type CheckDBNameAvailableRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The instance ID. You can call the [DescribeDBInstances](~~610396~~) operation to query the ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The database name that you want to check.
	DBName               *string `json:"DBName,omitempty" xml:"DBName,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s CheckDBNameAvailableRequest) String() string {
	return tea.Prettify(s)
}

func (s CheckDBNameAvailableRequest) GoString() string {
	return s.String()
}

func (s *CheckDBNameAvailableRequest) SetClientToken(v string) *CheckDBNameAvailableRequest {
	s.ClientToken = &v
	return s
}

func (s *CheckDBNameAvailableRequest) SetDBInstanceId(v string) *CheckDBNameAvailableRequest {
	s.DBInstanceId = &v
	return s
}

func (s *CheckDBNameAvailableRequest) SetDBName(v string) *CheckDBNameAvailableRequest {
	s.DBName = &v
	return s
}

func (s *CheckDBNameAvailableRequest) SetOwnerAccount(v string) *CheckDBNameAvailableRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CheckDBNameAvailableRequest) SetOwnerId(v int64) *CheckDBNameAvailableRequest {
	s.OwnerId = &v
	return s
}

func (s *CheckDBNameAvailableRequest) SetResourceOwnerAccount(v string) *CheckDBNameAvailableRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CheckDBNameAvailableRequest) SetResourceOwnerId(v int64) *CheckDBNameAvailableRequest {
	s.ResourceOwnerId = &v
	return s
}

type CheckDBNameAvailableResponseBody struct {
	// The request ID.
	//
	// >  If this operation returns only the ID of the request, the database name conforms to the naming conventions. If an error message is returned, the database name is duplicate or does not conform to the naming conventions.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CheckDBNameAvailableResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CheckDBNameAvailableResponseBody) GoString() string {
	return s.String()
}

func (s *CheckDBNameAvailableResponseBody) SetRequestId(v string) *CheckDBNameAvailableResponseBody {
	s.RequestId = &v
	return s
}

type CheckDBNameAvailableResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CheckDBNameAvailableResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CheckDBNameAvailableResponse) String() string {
	return tea.Prettify(s)
}

func (s CheckDBNameAvailableResponse) GoString() string {
	return s.String()
}

func (s *CheckDBNameAvailableResponse) SetHeaders(v map[string]*string) *CheckDBNameAvailableResponse {
	s.Headers = v
	return s
}

func (s *CheckDBNameAvailableResponse) SetStatusCode(v int32) *CheckDBNameAvailableResponse {
	s.StatusCode = &v
	return s
}

func (s *CheckDBNameAvailableResponse) SetBody(v *CheckDBNameAvailableResponseBody) *CheckDBNameAvailableResponse {
	s.Body = v
	return s
}

type CheckInstanceExistRequest struct {
	// The ID of the instance.
	DBInstanceId         *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s CheckInstanceExistRequest) String() string {
	return tea.Prettify(s)
}

func (s CheckInstanceExistRequest) GoString() string {
	return s.String()
}

func (s *CheckInstanceExistRequest) SetDBInstanceId(v string) *CheckInstanceExistRequest {
	s.DBInstanceId = &v
	return s
}

func (s *CheckInstanceExistRequest) SetOwnerId(v int64) *CheckInstanceExistRequest {
	s.OwnerId = &v
	return s
}

func (s *CheckInstanceExistRequest) SetResourceOwnerAccount(v string) *CheckInstanceExistRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CheckInstanceExistRequest) SetResourceOwnerId(v int64) *CheckInstanceExistRequest {
	s.ResourceOwnerId = &v
	return s
}

type CheckInstanceExistResponseBody struct {
	// Indicates whether the instance exists. Valid values:
	//
	// *   **true**: The instance exists.
	// *   **false**: The instance does not exist.
	IsExistInstance *bool `json:"IsExistInstance,omitempty" xml:"IsExistInstance,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CheckInstanceExistResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CheckInstanceExistResponseBody) GoString() string {
	return s.String()
}

func (s *CheckInstanceExistResponseBody) SetIsExistInstance(v bool) *CheckInstanceExistResponseBody {
	s.IsExistInstance = &v
	return s
}

func (s *CheckInstanceExistResponseBody) SetRequestId(v string) *CheckInstanceExistResponseBody {
	s.RequestId = &v
	return s
}

type CheckInstanceExistResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CheckInstanceExistResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CheckInstanceExistResponse) String() string {
	return tea.Prettify(s)
}

func (s CheckInstanceExistResponse) GoString() string {
	return s.String()
}

func (s *CheckInstanceExistResponse) SetHeaders(v map[string]*string) *CheckInstanceExistResponse {
	s.Headers = v
	return s
}

func (s *CheckInstanceExistResponse) SetStatusCode(v int32) *CheckInstanceExistResponse {
	s.StatusCode = &v
	return s
}

func (s *CheckInstanceExistResponse) SetBody(v *CheckInstanceExistResponseBody) *CheckInstanceExistResponse {
	s.Body = v
	return s
}

type CheckServiceLinkedRoleRequest struct {
	OwnerId *int64 `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the instance.
	//
	// >  The configuration of the RegionId parameter does not affect your query results. You can configure any region for this parameter. You can call the [DescribeRegions](~~26243~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group to which the instance belongs.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The name of the SLR.
	//
	// >  For more information about the SLRs supported by ApsaraDB RDS, see [Service-linked roles](~~342840~~).
	ServiceLinkedRole *string `json:"ServiceLinkedRole,omitempty" xml:"ServiceLinkedRole,omitempty"`
}

func (s CheckServiceLinkedRoleRequest) String() string {
	return tea.Prettify(s)
}

func (s CheckServiceLinkedRoleRequest) GoString() string {
	return s.String()
}

func (s *CheckServiceLinkedRoleRequest) SetOwnerId(v int64) *CheckServiceLinkedRoleRequest {
	s.OwnerId = &v
	return s
}

func (s *CheckServiceLinkedRoleRequest) SetRegionId(v string) *CheckServiceLinkedRoleRequest {
	s.RegionId = &v
	return s
}

func (s *CheckServiceLinkedRoleRequest) SetResourceGroupId(v string) *CheckServiceLinkedRoleRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *CheckServiceLinkedRoleRequest) SetResourceOwnerAccount(v string) *CheckServiceLinkedRoleRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CheckServiceLinkedRoleRequest) SetResourceOwnerId(v int64) *CheckServiceLinkedRoleRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CheckServiceLinkedRoleRequest) SetServiceLinkedRole(v string) *CheckServiceLinkedRoleRequest {
	s.ServiceLinkedRole = &v
	return s
}

type CheckServiceLinkedRoleResponseBody struct {
	// Indicates whether an SLR is created.
	HasServiceLinkedRole *string `json:"HasServiceLinkedRole,omitempty" xml:"HasServiceLinkedRole,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CheckServiceLinkedRoleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CheckServiceLinkedRoleResponseBody) GoString() string {
	return s.String()
}

func (s *CheckServiceLinkedRoleResponseBody) SetHasServiceLinkedRole(v string) *CheckServiceLinkedRoleResponseBody {
	s.HasServiceLinkedRole = &v
	return s
}

func (s *CheckServiceLinkedRoleResponseBody) SetRequestId(v string) *CheckServiceLinkedRoleResponseBody {
	s.RequestId = &v
	return s
}

type CheckServiceLinkedRoleResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CheckServiceLinkedRoleResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CheckServiceLinkedRoleResponse) String() string {
	return tea.Prettify(s)
}

func (s CheckServiceLinkedRoleResponse) GoString() string {
	return s.String()
}

func (s *CheckServiceLinkedRoleResponse) SetHeaders(v map[string]*string) *CheckServiceLinkedRoleResponse {
	s.Headers = v
	return s
}

func (s *CheckServiceLinkedRoleResponse) SetStatusCode(v int32) *CheckServiceLinkedRoleResponse {
	s.StatusCode = &v
	return s
}

func (s *CheckServiceLinkedRoleResponse) SetBody(v *CheckServiceLinkedRoleResponseBody) *CheckServiceLinkedRoleResponse {
	s.Body = v
	return s
}

type CloneDBInstanceRequest struct {
	// Specifies whether to automatically complete the payment. Valid values:
	//
	// 1.  **true**: automatically completes the payment. You must make sure that your account balance is sufficient.
	// 2.  **false**: does not automatically complete the payment. An unpaid order is generated.
	//
	// > The default value is true. If your account balance is insufficient, you can set AutoPay to false to generate an unpaid order. Then, you can pay for the order in the ApsaraDB RDS console.
	AutoPay *bool `json:"AutoPay,omitempty" xml:"AutoPay,omitempty"`
	// The ID of the backup set.
	//
	// You can call the [DescribeBackups](~~26273~~) operation to query the backup sets.
	//
	// > You must specify at least one of the **BackupId** and **RestoreTime** parameters.
	BackupId *string `json:"BackupId,omitempty" xml:"BackupId,omitempty"`
	// The type of backup that is used to restore the data of the original instance. Valid values:
	//
	// *   **FullBackup**
	// *   **IncrementalBackup**
	BackupType *string `json:"BackupType,omitempty" xml:"BackupType,omitempty"`
	// A reserved parameter. You do not need to specify this parameter.
	BpeEnabled *string `json:"BpeEnabled,omitempty" xml:"BpeEnabled,omitempty"`
	// A reserved parameter. You do not need to specify this parameter.
	BurstingEnabled *bool `json:"BurstingEnabled,omitempty" xml:"BurstingEnabled,omitempty"`
	// The RDS edition of the instance. Valid values:
	//
	// *   **Basic**: RDS Basic Edition.
	// *   **HighAvailability**: RDS High-availability Edition.
	// *   **AlwaysOn**: RDS Cluster Edition for SQL Server.
	// *   **cluster**: RDS Cluster Edition for MySQL.
	// *   **Finance**: RDS Enterprise Edition. This edition is available only on the China site (aliyun.com).
	//
	// **Serverless instance**
	//
	// *   **serverless_basic**: RDS Serverless Basic Edition. This edition is available only for instances that run MySQL and PostgreSQL.
	// *   **serverless_standard**: RDS Serverless High-availability Edition for MySQL.
	// *   **serverless_ha**: RDS Serverless High-availability Edition for SQL Server.
	//
	// >  You do not need to configure this parameter. The value of this parameter is the same as that of the original instance.
	Category *string `json:"Category,omitempty" xml:"Category,omitempty"`
	// The instance type of the new instance. For information, see [Primary ApsaraDB RDS instance types](~~26312~~).
	//
	// > By default, the new instance uses the same instance type as the original primary instance.
	DBInstanceClass *string `json:"DBInstanceClass,omitempty" xml:"DBInstanceClass,omitempty"`
	// The instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The storage capacity of the new instance. Unit: GB. You can increase the storage capacity in increments of 5 GB. For more information, see [Primary ApsaraDB RDS instance types](~~26312~~).
	//
	// > By default, the new instance has the same storage capacity as the original primary instance.
	DBInstanceStorage *int32 `json:"DBInstanceStorage,omitempty" xml:"DBInstanceStorage,omitempty"`
	// The storage type of the instance. Valid values:
	//
	// *   **local_ssd**: local SSDs
	// *   **cloud_ssd**: standard SSDs
	// *   **cloud_essd**: enhanced SSDs (ESSDs) of performance level 1 (PL1)
	// *   **cloud_essd2**: ESSDs of PL2
	// *   **cloud_essd3**: ESSD of PL3
	//
	// > Serverless instances support only ESSDs of PL 1. For a serverless instance, you must set this parameter to **cloud_essd**.
	DBInstanceStorageType *string `json:"DBInstanceStorageType,omitempty" xml:"DBInstanceStorageType,omitempty"`
	// The name of the database. If you specify more than one database, the value is in the following format: `Original database name 1,Original database name 2`.
	DbNames *string `json:"DbNames,omitempty" xml:"DbNames,omitempty"`
	// The ID of the dedicated cluster.
	DedicatedHostGroupId *string `json:"DedicatedHostGroupId,omitempty" xml:"DedicatedHostGroupId,omitempty"`
	// Specifies whether to enable the release protection feature for the instance. Valid values:
	//
	// *   **true**: enables the feature.
	// *   **false** (default): disables the feature.
	DeletionProtection *bool `json:"DeletionProtection,omitempty" xml:"DeletionProtection,omitempty"`
	// The network type of the new instance. Valid values:
	//
	// *   **VPC**
	// *   **Classic**
	//
	// > By default, the new instance has the same network type as the original primary instance.
	InstanceNetworkType *string `json:"InstanceNetworkType,omitempty" xml:"InstanceNetworkType,omitempty"`
	// The billing method of the instance. Valid values:
	//
	// *   **Postpaid**: pay-as-you-go.
	// *   **Prepaid**: subscription.
	// *   **Serverless**: serverless. This value is not supported for instances that run MariaDB. For more information, see [Overview of serverless ApsaraDB RDS for MySQL instances](~~411291~~), [Overview of serverless ApsaraDB RDS for SQL Server instances](~~604344~~), and [Overview of serverless ApsaraDB RDS for PostgreSQL instances](~~607742~~).
	PayType *string `json:"PayType,omitempty" xml:"PayType,omitempty"`
	// The unit that is used to calculate the billing cycle of the new instance. Valid values:
	//
	// *   **Year**
	// *   **Month**
	//
	// > If you set the PayType parameter to **Prepaid**, you must also specify this parameter.
	Period *string `json:"Period,omitempty" xml:"Period,omitempty"`
	// The internal IP address of the new instance, which must be within the CIDR block supported by the specified vSwitch. The system automatically assigns an internal IP address based on the values of the **VPCId** and **VSwitchId** parameters.
	PrivateIpAddress *string `json:"PrivateIpAddress,omitempty" xml:"PrivateIpAddress,omitempty"`
	// The region ID of the new instance. You can call the [DescribeRegions](~~26243~~) operation to query the most recent region list.
	RegionId        *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerId *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// Specifies whether to restore only the databases and tables that you specify. The value **1** specifies to restore only the specified databases and tables. If you do not want to restore only the specified databases or tables, you do not need to specify this parameter.
	RestoreTable *string `json:"RestoreTable,omitempty" xml:"RestoreTable,omitempty"`
	// The point in time to which you want to restore data. The point in time must fall within the specified backup retention period. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
	//
	// > You must specify at least one of the **BackupId** and **RestoreTime** parameters.
	RestoreTime *string `json:"RestoreTime,omitempty" xml:"RestoreTime,omitempty"`
	// The configuration of the serverless instance. You must specify this parameter only when you restore data to a new serverless instance.
	ServerlessConfig *CloneDBInstanceRequestServerlessConfig `json:"ServerlessConfig,omitempty" xml:"ServerlessConfig,omitempty" type:"Struct"`
	// The information about the database and table that you want to restore. The value is in the following format: `[{"type":"db","name":"Name of Database 1","newname":"New name of Database 1","tables":[{"type":"table","name":"Name of Table 1 in Database 1","newname":"New name of Table 1"},{"type":"table","name":"Name of Table 2 in Database 1","newname":"New name of Table 2"}]},{"type":"db","name":"Name of Database 2","newname":"New name of Database 2","tables":[{"type":"table","name":"Name of Table 1 in Database 2","newname":"New name of Table 1"},{"type":"table","name":"Name of Table 2 in Database 2","newname":"New name of Table 2"}]}]`
	TableMeta *string `json:"TableMeta,omitempty" xml:"TableMeta,omitempty"`
	// The subscription duration of the new instance. Valid values:
	//
	// *   If you set the **Period** parameter to **Year**, the value of the UsedTime parameter ranges from **1 to 3**.
	// *   If you set the **Period** parameter to **Month**, the value of the UsedTime parameter ranges from **1 to 9**.
	//
	// > If you set the PayType parameter to **Prepaid**, you must also specify this parameter.
	UsedTime *int32 `json:"UsedTime,omitempty" xml:"UsedTime,omitempty"`
	// The ID of the virtual private cloud (VPC).
	//
	// >  Make sure that the VPC belongs to the required region.
	VPCId *string `json:"VPCId,omitempty" xml:"VPCId,omitempty"`
	// The ID of the vSwitch. The vSwitch must belong to the zone that is specified by **ZoneId**.
	//
	// *   If you set **InstanceNetworkType** to **VPC**, you must also specify this parameter.
	// *   If you specify the **ZoneSlaveId1** parameter, you must specify the IDs of two vSwitches for this parameter and separate the IDs with a comma (,).
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
	// The zone ID of the primary instance. You can call the [DescribeRegions](~~26243~~) operation to query the most recent zone list.
	//
	// > By default, the new instance resides in the same region as the original instance.
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
	// The zone ID of the secondary instance. If you set the ZoneIdSlave1 parameter and the **ZoneId** parameter to the same value, the single-zone deployment method is used. If you set the ZoneIdSlave1 parameter and the **ZoneId** parameter to different values, the multi-zone deployment method is used.
	ZoneIdSlave1 *string `json:"ZoneIdSlave1,omitempty" xml:"ZoneIdSlave1,omitempty"`
	// The zone ID of the logger instance. If you set the ZoneIdSlave2 parameter to the same value as the **ZoneId** parameter, the single-zone deployment method is used. If you set the ZoneIdSlave2 parameter to a different value from the **ZoneId** parameter, the multi-zone deployment method is used.
	ZoneIdSlave2 *string `json:"ZoneIdSlave2,omitempty" xml:"ZoneIdSlave2,omitempty"`
}

func (s CloneDBInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s CloneDBInstanceRequest) GoString() string {
	return s.String()
}

func (s *CloneDBInstanceRequest) SetAutoPay(v bool) *CloneDBInstanceRequest {
	s.AutoPay = &v
	return s
}

func (s *CloneDBInstanceRequest) SetBackupId(v string) *CloneDBInstanceRequest {
	s.BackupId = &v
	return s
}

func (s *CloneDBInstanceRequest) SetBackupType(v string) *CloneDBInstanceRequest {
	s.BackupType = &v
	return s
}

func (s *CloneDBInstanceRequest) SetBpeEnabled(v string) *CloneDBInstanceRequest {
	s.BpeEnabled = &v
	return s
}

func (s *CloneDBInstanceRequest) SetBurstingEnabled(v bool) *CloneDBInstanceRequest {
	s.BurstingEnabled = &v
	return s
}

func (s *CloneDBInstanceRequest) SetCategory(v string) *CloneDBInstanceRequest {
	s.Category = &v
	return s
}

func (s *CloneDBInstanceRequest) SetDBInstanceClass(v string) *CloneDBInstanceRequest {
	s.DBInstanceClass = &v
	return s
}

func (s *CloneDBInstanceRequest) SetDBInstanceId(v string) *CloneDBInstanceRequest {
	s.DBInstanceId = &v
	return s
}

func (s *CloneDBInstanceRequest) SetDBInstanceStorage(v int32) *CloneDBInstanceRequest {
	s.DBInstanceStorage = &v
	return s
}

func (s *CloneDBInstanceRequest) SetDBInstanceStorageType(v string) *CloneDBInstanceRequest {
	s.DBInstanceStorageType = &v
	return s
}

func (s *CloneDBInstanceRequest) SetDbNames(v string) *CloneDBInstanceRequest {
	s.DbNames = &v
	return s
}

func (s *CloneDBInstanceRequest) SetDedicatedHostGroupId(v string) *CloneDBInstanceRequest {
	s.DedicatedHostGroupId = &v
	return s
}

func (s *CloneDBInstanceRequest) SetDeletionProtection(v bool) *CloneDBInstanceRequest {
	s.DeletionProtection = &v
	return s
}

func (s *CloneDBInstanceRequest) SetInstanceNetworkType(v string) *CloneDBInstanceRequest {
	s.InstanceNetworkType = &v
	return s
}

func (s *CloneDBInstanceRequest) SetPayType(v string) *CloneDBInstanceRequest {
	s.PayType = &v
	return s
}

func (s *CloneDBInstanceRequest) SetPeriod(v string) *CloneDBInstanceRequest {
	s.Period = &v
	return s
}

func (s *CloneDBInstanceRequest) SetPrivateIpAddress(v string) *CloneDBInstanceRequest {
	s.PrivateIpAddress = &v
	return s
}

func (s *CloneDBInstanceRequest) SetRegionId(v string) *CloneDBInstanceRequest {
	s.RegionId = &v
	return s
}

func (s *CloneDBInstanceRequest) SetResourceOwnerId(v int64) *CloneDBInstanceRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CloneDBInstanceRequest) SetRestoreTable(v string) *CloneDBInstanceRequest {
	s.RestoreTable = &v
	return s
}

func (s *CloneDBInstanceRequest) SetRestoreTime(v string) *CloneDBInstanceRequest {
	s.RestoreTime = &v
	return s
}

func (s *CloneDBInstanceRequest) SetServerlessConfig(v *CloneDBInstanceRequestServerlessConfig) *CloneDBInstanceRequest {
	s.ServerlessConfig = v
	return s
}

func (s *CloneDBInstanceRequest) SetTableMeta(v string) *CloneDBInstanceRequest {
	s.TableMeta = &v
	return s
}

func (s *CloneDBInstanceRequest) SetUsedTime(v int32) *CloneDBInstanceRequest {
	s.UsedTime = &v
	return s
}

func (s *CloneDBInstanceRequest) SetVPCId(v string) *CloneDBInstanceRequest {
	s.VPCId = &v
	return s
}

func (s *CloneDBInstanceRequest) SetVSwitchId(v string) *CloneDBInstanceRequest {
	s.VSwitchId = &v
	return s
}

func (s *CloneDBInstanceRequest) SetZoneId(v string) *CloneDBInstanceRequest {
	s.ZoneId = &v
	return s
}

func (s *CloneDBInstanceRequest) SetZoneIdSlave1(v string) *CloneDBInstanceRequest {
	s.ZoneIdSlave1 = &v
	return s
}

func (s *CloneDBInstanceRequest) SetZoneIdSlave2(v string) *CloneDBInstanceRequest {
	s.ZoneIdSlave2 = &v
	return s
}

type CloneDBInstanceRequestServerlessConfig struct {
	// Specifies whether to enable the automatic start and stop feature for the serverless ApsaraDB RDS for MySQL instance. After the automatic start and stop feature is enabled, if no connections to the instance are established within 10 minutes, the instance is suspended. After a connection is established to the instance, the instance is automatically resumed. Valid values:
	//
	// *   **true**: enables the feature.
	// *   **false** (default): disables the feature.
	//
	// > This parameter is supported only for serverless ApsaraDB RDS for MySQL instances.
	AutoPause *bool `json:"AutoPause,omitempty" xml:"AutoPause,omitempty"`
	// The maximum number of RDS Capacity Units (RCUs). Valid values:
	//
	// *   Serverless ApsaraDB RDS for MySQL instances: **1 to 8**
	// *   Serverless ApsaraDB RDS for SQL Server instances: **2 to 8**
	// *   Serverless ApsaraDB RDS for PostgreSQL instances: **1 to 12**
	//
	// > The value of this parameter must be greater than or equal to the value of **MinCapacity** and can be specified only to an **integer**.
	MaxCapacity *float64 `json:"MaxCapacity,omitempty" xml:"MaxCapacity,omitempty"`
	// The minimum number of RCUs. Valid values:
	//
	// *   Serverless ApsaraDB RDS for MySQL instances: **0.5 to 8**.
	// *   Serverless ApsaraDB RDS for SQL Server instances: **2 to 8**. Only integers are supported.
	// *   Serverless ApsaraDB RDS for PostgreSQL instances: **0.5 to 12**.
	//
	// > The value of this parameter must be less than or equal to the value of **MaxCapacity**.
	MinCapacity *float64 `json:"MinCapacity,omitempty" xml:"MinCapacity,omitempty"`
	// Specifies whether to enable the forced scaling feature for the serverless ApsaraDB RDS for MySQL instance. In most cases, ApsaraDB RDS automatically scales in or out the RCUs of a serverless instance based on business requirements in real time. In rare cases, the scaling does not take effect in real time. You can enable the forced scaling feature to forcefully scales in or out the RCUs of the instance. Valid values:
	//
	// *   **true**: enables the feature.
	// *   **false** (default): disables the feature.
	//
	// > This parameter is supported only for serverless ApsaraDB RDS for MySQL instances.
	SwitchForce *bool `json:"SwitchForce,omitempty" xml:"SwitchForce,omitempty"`
}

func (s CloneDBInstanceRequestServerlessConfig) String() string {
	return tea.Prettify(s)
}

func (s CloneDBInstanceRequestServerlessConfig) GoString() string {
	return s.String()
}

func (s *CloneDBInstanceRequestServerlessConfig) SetAutoPause(v bool) *CloneDBInstanceRequestServerlessConfig {
	s.AutoPause = &v
	return s
}

func (s *CloneDBInstanceRequestServerlessConfig) SetMaxCapacity(v float64) *CloneDBInstanceRequestServerlessConfig {
	s.MaxCapacity = &v
	return s
}

func (s *CloneDBInstanceRequestServerlessConfig) SetMinCapacity(v float64) *CloneDBInstanceRequestServerlessConfig {
	s.MinCapacity = &v
	return s
}

func (s *CloneDBInstanceRequestServerlessConfig) SetSwitchForce(v bool) *CloneDBInstanceRequestServerlessConfig {
	s.SwitchForce = &v
	return s
}

type CloneDBInstanceShrinkRequest struct {
	// Specifies whether to automatically complete the payment. Valid values:
	//
	// 1.  **true**: automatically completes the payment. You must make sure that your account balance is sufficient.
	// 2.  **false**: does not automatically complete the payment. An unpaid order is generated.
	//
	// > The default value is true. If your account balance is insufficient, you can set AutoPay to false to generate an unpaid order. Then, you can pay for the order in the ApsaraDB RDS console.
	AutoPay *bool `json:"AutoPay,omitempty" xml:"AutoPay,omitempty"`
	// The ID of the backup set.
	//
	// You can call the [DescribeBackups](~~26273~~) operation to query the backup sets.
	//
	// > You must specify at least one of the **BackupId** and **RestoreTime** parameters.
	BackupId *string `json:"BackupId,omitempty" xml:"BackupId,omitempty"`
	// The type of backup that is used to restore the data of the original instance. Valid values:
	//
	// *   **FullBackup**
	// *   **IncrementalBackup**
	BackupType *string `json:"BackupType,omitempty" xml:"BackupType,omitempty"`
	// A reserved parameter. You do not need to specify this parameter.
	BpeEnabled *string `json:"BpeEnabled,omitempty" xml:"BpeEnabled,omitempty"`
	// A reserved parameter. You do not need to specify this parameter.
	BurstingEnabled *bool `json:"BurstingEnabled,omitempty" xml:"BurstingEnabled,omitempty"`
	// The RDS edition of the instance. Valid values:
	//
	// *   **Basic**: RDS Basic Edition.
	// *   **HighAvailability**: RDS High-availability Edition.
	// *   **AlwaysOn**: RDS Cluster Edition for SQL Server.
	// *   **cluster**: RDS Cluster Edition for MySQL.
	// *   **Finance**: RDS Enterprise Edition. This edition is available only on the China site (aliyun.com).
	//
	// **Serverless instance**
	//
	// *   **serverless_basic**: RDS Serverless Basic Edition. This edition is available only for instances that run MySQL and PostgreSQL.
	// *   **serverless_standard**: RDS Serverless High-availability Edition for MySQL.
	// *   **serverless_ha**: RDS Serverless High-availability Edition for SQL Server.
	//
	// >  You do not need to configure this parameter. The value of this parameter is the same as that of the original instance.
	Category *string `json:"Category,omitempty" xml:"Category,omitempty"`
	// The instance type of the new instance. For information, see [Primary ApsaraDB RDS instance types](~~26312~~).
	//
	// > By default, the new instance uses the same instance type as the original primary instance.
	DBInstanceClass *string `json:"DBInstanceClass,omitempty" xml:"DBInstanceClass,omitempty"`
	// The instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The storage capacity of the new instance. Unit: GB. You can increase the storage capacity in increments of 5 GB. For more information, see [Primary ApsaraDB RDS instance types](~~26312~~).
	//
	// > By default, the new instance has the same storage capacity as the original primary instance.
	DBInstanceStorage *int32 `json:"DBInstanceStorage,omitempty" xml:"DBInstanceStorage,omitempty"`
	// The storage type of the instance. Valid values:
	//
	// *   **local_ssd**: local SSDs
	// *   **cloud_ssd**: standard SSDs
	// *   **cloud_essd**: enhanced SSDs (ESSDs) of performance level 1 (PL1)
	// *   **cloud_essd2**: ESSDs of PL2
	// *   **cloud_essd3**: ESSD of PL3
	//
	// > Serverless instances support only ESSDs of PL 1. For a serverless instance, you must set this parameter to **cloud_essd**.
	DBInstanceStorageType *string `json:"DBInstanceStorageType,omitempty" xml:"DBInstanceStorageType,omitempty"`
	// The name of the database. If you specify more than one database, the value is in the following format: `Original database name 1,Original database name 2`.
	DbNames *string `json:"DbNames,omitempty" xml:"DbNames,omitempty"`
	// The ID of the dedicated cluster.
	DedicatedHostGroupId *string `json:"DedicatedHostGroupId,omitempty" xml:"DedicatedHostGroupId,omitempty"`
	// Specifies whether to enable the release protection feature for the instance. Valid values:
	//
	// *   **true**: enables the feature.
	// *   **false** (default): disables the feature.
	DeletionProtection *bool `json:"DeletionProtection,omitempty" xml:"DeletionProtection,omitempty"`
	// The network type of the new instance. Valid values:
	//
	// *   **VPC**
	// *   **Classic**
	//
	// > By default, the new instance has the same network type as the original primary instance.
	InstanceNetworkType *string `json:"InstanceNetworkType,omitempty" xml:"InstanceNetworkType,omitempty"`
	// The billing method of the instance. Valid values:
	//
	// *   **Postpaid**: pay-as-you-go.
	// *   **Prepaid**: subscription.
	// *   **Serverless**: serverless. This value is not supported for instances that run MariaDB. For more information, see [Overview of serverless ApsaraDB RDS for MySQL instances](~~411291~~), [Overview of serverless ApsaraDB RDS for SQL Server instances](~~604344~~), and [Overview of serverless ApsaraDB RDS for PostgreSQL instances](~~607742~~).
	PayType *string `json:"PayType,omitempty" xml:"PayType,omitempty"`
	// The unit that is used to calculate the billing cycle of the new instance. Valid values:
	//
	// *   **Year**
	// *   **Month**
	//
	// > If you set the PayType parameter to **Prepaid**, you must also specify this parameter.
	Period *string `json:"Period,omitempty" xml:"Period,omitempty"`
	// The internal IP address of the new instance, which must be within the CIDR block supported by the specified vSwitch. The system automatically assigns an internal IP address based on the values of the **VPCId** and **VSwitchId** parameters.
	PrivateIpAddress *string `json:"PrivateIpAddress,omitempty" xml:"PrivateIpAddress,omitempty"`
	// The region ID of the new instance. You can call the [DescribeRegions](~~26243~~) operation to query the most recent region list.
	RegionId        *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerId *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// Specifies whether to restore only the databases and tables that you specify. The value **1** specifies to restore only the specified databases and tables. If you do not want to restore only the specified databases or tables, you do not need to specify this parameter.
	RestoreTable *string `json:"RestoreTable,omitempty" xml:"RestoreTable,omitempty"`
	// The point in time to which you want to restore data. The point in time must fall within the specified backup retention period. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
	//
	// > You must specify at least one of the **BackupId** and **RestoreTime** parameters.
	RestoreTime *string `json:"RestoreTime,omitempty" xml:"RestoreTime,omitempty"`
	// The configuration of the serverless instance. You must specify this parameter only when you restore data to a new serverless instance.
	ServerlessConfigShrink *string `json:"ServerlessConfig,omitempty" xml:"ServerlessConfig,omitempty"`
	// The information about the database and table that you want to restore. The value is in the following format: `[{"type":"db","name":"Name of Database 1","newname":"New name of Database 1","tables":[{"type":"table","name":"Name of Table 1 in Database 1","newname":"New name of Table 1"},{"type":"table","name":"Name of Table 2 in Database 1","newname":"New name of Table 2"}]},{"type":"db","name":"Name of Database 2","newname":"New name of Database 2","tables":[{"type":"table","name":"Name of Table 1 in Database 2","newname":"New name of Table 1"},{"type":"table","name":"Name of Table 2 in Database 2","newname":"New name of Table 2"}]}]`
	TableMeta *string `json:"TableMeta,omitempty" xml:"TableMeta,omitempty"`
	// The subscription duration of the new instance. Valid values:
	//
	// *   If you set the **Period** parameter to **Year**, the value of the UsedTime parameter ranges from **1 to 3**.
	// *   If you set the **Period** parameter to **Month**, the value of the UsedTime parameter ranges from **1 to 9**.
	//
	// > If you set the PayType parameter to **Prepaid**, you must also specify this parameter.
	UsedTime *int32 `json:"UsedTime,omitempty" xml:"UsedTime,omitempty"`
	// The ID of the virtual private cloud (VPC).
	//
	// >  Make sure that the VPC belongs to the required region.
	VPCId *string `json:"VPCId,omitempty" xml:"VPCId,omitempty"`
	// The ID of the vSwitch. The vSwitch must belong to the zone that is specified by **ZoneId**.
	//
	// *   If you set **InstanceNetworkType** to **VPC**, you must also specify this parameter.
	// *   If you specify the **ZoneSlaveId1** parameter, you must specify the IDs of two vSwitches for this parameter and separate the IDs with a comma (,).
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
	// The zone ID of the primary instance. You can call the [DescribeRegions](~~26243~~) operation to query the most recent zone list.
	//
	// > By default, the new instance resides in the same region as the original instance.
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
	// The zone ID of the secondary instance. If you set the ZoneIdSlave1 parameter and the **ZoneId** parameter to the same value, the single-zone deployment method is used. If you set the ZoneIdSlave1 parameter and the **ZoneId** parameter to different values, the multi-zone deployment method is used.
	ZoneIdSlave1 *string `json:"ZoneIdSlave1,omitempty" xml:"ZoneIdSlave1,omitempty"`
	// The zone ID of the logger instance. If you set the ZoneIdSlave2 parameter to the same value as the **ZoneId** parameter, the single-zone deployment method is used. If you set the ZoneIdSlave2 parameter to a different value from the **ZoneId** parameter, the multi-zone deployment method is used.
	ZoneIdSlave2 *string `json:"ZoneIdSlave2,omitempty" xml:"ZoneIdSlave2,omitempty"`
}

func (s CloneDBInstanceShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s CloneDBInstanceShrinkRequest) GoString() string {
	return s.String()
}

func (s *CloneDBInstanceShrinkRequest) SetAutoPay(v bool) *CloneDBInstanceShrinkRequest {
	s.AutoPay = &v
	return s
}

func (s *CloneDBInstanceShrinkRequest) SetBackupId(v string) *CloneDBInstanceShrinkRequest {
	s.BackupId = &v
	return s
}

func (s *CloneDBInstanceShrinkRequest) SetBackupType(v string) *CloneDBInstanceShrinkRequest {
	s.BackupType = &v
	return s
}

func (s *CloneDBInstanceShrinkRequest) SetBpeEnabled(v string) *CloneDBInstanceShrinkRequest {
	s.BpeEnabled = &v
	return s
}

func (s *CloneDBInstanceShrinkRequest) SetBurstingEnabled(v bool) *CloneDBInstanceShrinkRequest {
	s.BurstingEnabled = &v
	return s
}

func (s *CloneDBInstanceShrinkRequest) SetCategory(v string) *CloneDBInstanceShrinkRequest {
	s.Category = &v
	return s
}

func (s *CloneDBInstanceShrinkRequest) SetDBInstanceClass(v string) *CloneDBInstanceShrinkRequest {
	s.DBInstanceClass = &v
	return s
}

func (s *CloneDBInstanceShrinkRequest) SetDBInstanceId(v string) *CloneDBInstanceShrinkRequest {
	s.DBInstanceId = &v
	return s
}

func (s *CloneDBInstanceShrinkRequest) SetDBInstanceStorage(v int32) *CloneDBInstanceShrinkRequest {
	s.DBInstanceStorage = &v
	return s
}

func (s *CloneDBInstanceShrinkRequest) SetDBInstanceStorageType(v string) *CloneDBInstanceShrinkRequest {
	s.DBInstanceStorageType = &v
	return s
}

func (s *CloneDBInstanceShrinkRequest) SetDbNames(v string) *CloneDBInstanceShrinkRequest {
	s.DbNames = &v
	return s
}

func (s *CloneDBInstanceShrinkRequest) SetDedicatedHostGroupId(v string) *CloneDBInstanceShrinkRequest {
	s.DedicatedHostGroupId = &v
	return s
}

func (s *CloneDBInstanceShrinkRequest) SetDeletionProtection(v bool) *CloneDBInstanceShrinkRequest {
	s.DeletionProtection = &v
	return s
}

func (s *CloneDBInstanceShrinkRequest) SetInstanceNetworkType(v string) *CloneDBInstanceShrinkRequest {
	s.InstanceNetworkType = &v
	return s
}

func (s *CloneDBInstanceShrinkRequest) SetPayType(v string) *CloneDBInstanceShrinkRequest {
	s.PayType = &v
	return s
}

func (s *CloneDBInstanceShrinkRequest) SetPeriod(v string) *CloneDBInstanceShrinkRequest {
	s.Period = &v
	return s
}

func (s *CloneDBInstanceShrinkRequest) SetPrivateIpAddress(v string) *CloneDBInstanceShrinkRequest {
	s.PrivateIpAddress = &v
	return s
}

func (s *CloneDBInstanceShrinkRequest) SetRegionId(v string) *CloneDBInstanceShrinkRequest {
	s.RegionId = &v
	return s
}

func (s *CloneDBInstanceShrinkRequest) SetResourceOwnerId(v int64) *CloneDBInstanceShrinkRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CloneDBInstanceShrinkRequest) SetRestoreTable(v string) *CloneDBInstanceShrinkRequest {
	s.RestoreTable = &v
	return s
}

func (s *CloneDBInstanceShrinkRequest) SetRestoreTime(v string) *CloneDBInstanceShrinkRequest {
	s.RestoreTime = &v
	return s
}

func (s *CloneDBInstanceShrinkRequest) SetServerlessConfigShrink(v string) *CloneDBInstanceShrinkRequest {
	s.ServerlessConfigShrink = &v
	return s
}

func (s *CloneDBInstanceShrinkRequest) SetTableMeta(v string) *CloneDBInstanceShrinkRequest {
	s.TableMeta = &v
	return s
}

func (s *CloneDBInstanceShrinkRequest) SetUsedTime(v int32) *CloneDBInstanceShrinkRequest {
	s.UsedTime = &v
	return s
}

func (s *CloneDBInstanceShrinkRequest) SetVPCId(v string) *CloneDBInstanceShrinkRequest {
	s.VPCId = &v
	return s
}

func (s *CloneDBInstanceShrinkRequest) SetVSwitchId(v string) *CloneDBInstanceShrinkRequest {
	s.VSwitchId = &v
	return s
}

func (s *CloneDBInstanceShrinkRequest) SetZoneId(v string) *CloneDBInstanceShrinkRequest {
	s.ZoneId = &v
	return s
}

func (s *CloneDBInstanceShrinkRequest) SetZoneIdSlave1(v string) *CloneDBInstanceShrinkRequest {
	s.ZoneIdSlave1 = &v
	return s
}

func (s *CloneDBInstanceShrinkRequest) SetZoneIdSlave2(v string) *CloneDBInstanceShrinkRequest {
	s.ZoneIdSlave2 = &v
	return s
}

type CloneDBInstanceResponseBody struct {
	// The instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The ID of the order.
	OrderId *string `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CloneDBInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CloneDBInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *CloneDBInstanceResponseBody) SetDBInstanceId(v string) *CloneDBInstanceResponseBody {
	s.DBInstanceId = &v
	return s
}

func (s *CloneDBInstanceResponseBody) SetOrderId(v string) *CloneDBInstanceResponseBody {
	s.OrderId = &v
	return s
}

func (s *CloneDBInstanceResponseBody) SetRequestId(v string) *CloneDBInstanceResponseBody {
	s.RequestId = &v
	return s
}

type CloneDBInstanceResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CloneDBInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CloneDBInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s CloneDBInstanceResponse) GoString() string {
	return s.String()
}

func (s *CloneDBInstanceResponse) SetHeaders(v map[string]*string) *CloneDBInstanceResponse {
	s.Headers = v
	return s
}

func (s *CloneDBInstanceResponse) SetStatusCode(v int32) *CloneDBInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *CloneDBInstanceResponse) SetBody(v *CloneDBInstanceResponseBody) *CloneDBInstanceResponse {
	s.Body = v
	return s
}

type CloneParameterGroupRequest struct {
	OwnerId *int64 `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The description of the parameter template in the destination region.
	ParameterGroupDesc *string `json:"ParameterGroupDesc,omitempty" xml:"ParameterGroupDesc,omitempty"`
	// The ID of the parameter template. You can call the [DescribeParameterGroups](~~144491~~) operation to query the most recent parameter templates in a region.
	ParameterGroupId *string `json:"ParameterGroupId,omitempty" xml:"ParameterGroupId,omitempty"`
	// The name of the parameter template in the destination region.
	ParameterGroupName *string `json:"ParameterGroupName,omitempty" xml:"ParameterGroupName,omitempty"`
	// The ID of the source region to which the parameter template belongs. You can call the [DescribeRegions](~~26243~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group. You can leave this parameter empty.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the destination region. You can call the [DescribeRegions](~~26243~~) operation to query the most recent region list.
	TargetRegionId *string `json:"TargetRegionId,omitempty" xml:"TargetRegionId,omitempty"`
}

func (s CloneParameterGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s CloneParameterGroupRequest) GoString() string {
	return s.String()
}

func (s *CloneParameterGroupRequest) SetOwnerId(v int64) *CloneParameterGroupRequest {
	s.OwnerId = &v
	return s
}

func (s *CloneParameterGroupRequest) SetParameterGroupDesc(v string) *CloneParameterGroupRequest {
	s.ParameterGroupDesc = &v
	return s
}

func (s *CloneParameterGroupRequest) SetParameterGroupId(v string) *CloneParameterGroupRequest {
	s.ParameterGroupId = &v
	return s
}

func (s *CloneParameterGroupRequest) SetParameterGroupName(v string) *CloneParameterGroupRequest {
	s.ParameterGroupName = &v
	return s
}

func (s *CloneParameterGroupRequest) SetRegionId(v string) *CloneParameterGroupRequest {
	s.RegionId = &v
	return s
}

func (s *CloneParameterGroupRequest) SetResourceGroupId(v string) *CloneParameterGroupRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *CloneParameterGroupRequest) SetResourceOwnerAccount(v string) *CloneParameterGroupRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CloneParameterGroupRequest) SetResourceOwnerId(v int64) *CloneParameterGroupRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CloneParameterGroupRequest) SetTargetRegionId(v string) *CloneParameterGroupRequest {
	s.TargetRegionId = &v
	return s
}

type CloneParameterGroupResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CloneParameterGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CloneParameterGroupResponseBody) GoString() string {
	return s.String()
}

func (s *CloneParameterGroupResponseBody) SetRequestId(v string) *CloneParameterGroupResponseBody {
	s.RequestId = &v
	return s
}

type CloneParameterGroupResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CloneParameterGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CloneParameterGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s CloneParameterGroupResponse) GoString() string {
	return s.String()
}

func (s *CloneParameterGroupResponse) SetHeaders(v map[string]*string) *CloneParameterGroupResponse {
	s.Headers = v
	return s
}

func (s *CloneParameterGroupResponse) SetStatusCode(v int32) *CloneParameterGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *CloneParameterGroupResponse) SetBody(v *CloneParameterGroupResponseBody) *CloneParameterGroupResponse {
	s.Body = v
	return s
}

type ConfirmNotifyRequest struct {
	// The ID of the Alibaba Cloud account that is used to confirm the notification. You can set this parameter to **0**, which indicates that the notification is confirmed by the system.
	Confirmor *int64 `json:"Confirmor,omitempty" xml:"Confirmor,omitempty"`
	// The IDs of the notifications that needs to be confirmed. You can call the [QueryNotify](~~427959~~) operation to query notifications for an instance.
	NotifyIdList []*int64 `json:"NotifyIdList,omitempty" xml:"NotifyIdList,omitempty" type:"Repeated"`
}

func (s ConfirmNotifyRequest) String() string {
	return tea.Prettify(s)
}

func (s ConfirmNotifyRequest) GoString() string {
	return s.String()
}

func (s *ConfirmNotifyRequest) SetConfirmor(v int64) *ConfirmNotifyRequest {
	s.Confirmor = &v
	return s
}

func (s *ConfirmNotifyRequest) SetNotifyIdList(v []*int64) *ConfirmNotifyRequest {
	s.NotifyIdList = v
	return s
}

type ConfirmNotifyShrinkRequest struct {
	// The ID of the Alibaba Cloud account that is used to confirm the notification. You can set this parameter to **0**, which indicates that the notification is confirmed by the system.
	Confirmor *int64 `json:"Confirmor,omitempty" xml:"Confirmor,omitempty"`
	// The IDs of the notifications that needs to be confirmed. You can call the [QueryNotify](~~427959~~) operation to query notifications for an instance.
	NotifyIdListShrink *string `json:"NotifyIdList,omitempty" xml:"NotifyIdList,omitempty"`
}

func (s ConfirmNotifyShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s ConfirmNotifyShrinkRequest) GoString() string {
	return s.String()
}

func (s *ConfirmNotifyShrinkRequest) SetConfirmor(v int64) *ConfirmNotifyShrinkRequest {
	s.Confirmor = &v
	return s
}

func (s *ConfirmNotifyShrinkRequest) SetNotifyIdListShrink(v string) *ConfirmNotifyShrinkRequest {
	s.NotifyIdListShrink = &v
	return s
}

type ConfirmNotifyResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ConfirmNotifyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ConfirmNotifyResponseBody) GoString() string {
	return s.String()
}

func (s *ConfirmNotifyResponseBody) SetRequestId(v string) *ConfirmNotifyResponseBody {
	s.RequestId = &v
	return s
}

type ConfirmNotifyResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ConfirmNotifyResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ConfirmNotifyResponse) String() string {
	return tea.Prettify(s)
}

func (s ConfirmNotifyResponse) GoString() string {
	return s.String()
}

func (s *ConfirmNotifyResponse) SetHeaders(v map[string]*string) *ConfirmNotifyResponse {
	s.Headers = v
	return s
}

func (s *ConfirmNotifyResponse) SetStatusCode(v int32) *ConfirmNotifyResponse {
	s.StatusCode = &v
	return s
}

func (s *ConfirmNotifyResponse) SetBody(v *ConfirmNotifyResponseBody) *ConfirmNotifyResponse {
	s.Body = v
	return s
}

type CopyDatabaseRequest struct {
	OwnerId *int64 `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s CopyDatabaseRequest) String() string {
	return tea.Prettify(s)
}

func (s CopyDatabaseRequest) GoString() string {
	return s.String()
}

func (s *CopyDatabaseRequest) SetOwnerId(v int64) *CopyDatabaseRequest {
	s.OwnerId = &v
	return s
}

func (s *CopyDatabaseRequest) SetResourceGroupId(v string) *CopyDatabaseRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *CopyDatabaseRequest) SetResourceOwnerAccount(v string) *CopyDatabaseRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CopyDatabaseRequest) SetResourceOwnerId(v int64) *CopyDatabaseRequest {
	s.ResourceOwnerId = &v
	return s
}

type CopyDatabaseResponseBody struct {
	// The name of the database.
	DBName *string `json:"DBName,omitempty" xml:"DBName,omitempty"`
	// The status of the database. Valid values:
	//
	// *   **Creating**
	// *   **Running**
	// *   **Deleting**
	DBStatus *string `json:"DBStatus,omitempty" xml:"DBStatus,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the task.
	TaskId *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
}

func (s CopyDatabaseResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CopyDatabaseResponseBody) GoString() string {
	return s.String()
}

func (s *CopyDatabaseResponseBody) SetDBName(v string) *CopyDatabaseResponseBody {
	s.DBName = &v
	return s
}

func (s *CopyDatabaseResponseBody) SetDBStatus(v string) *CopyDatabaseResponseBody {
	s.DBStatus = &v
	return s
}

func (s *CopyDatabaseResponseBody) SetRequestId(v string) *CopyDatabaseResponseBody {
	s.RequestId = &v
	return s
}

func (s *CopyDatabaseResponseBody) SetTaskId(v string) *CopyDatabaseResponseBody {
	s.TaskId = &v
	return s
}

type CopyDatabaseResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CopyDatabaseResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CopyDatabaseResponse) String() string {
	return tea.Prettify(s)
}

func (s CopyDatabaseResponse) GoString() string {
	return s.String()
}

func (s *CopyDatabaseResponse) SetHeaders(v map[string]*string) *CopyDatabaseResponse {
	s.Headers = v
	return s
}

func (s *CopyDatabaseResponse) SetStatusCode(v int32) *CopyDatabaseResponse {
	s.StatusCode = &v
	return s
}

func (s *CopyDatabaseResponse) SetBody(v *CopyDatabaseResponseBody) *CopyDatabaseResponse {
	s.Body = v
	return s
}

type CopyDatabaseBetweenInstancesRequest struct {
	// The ID of the backup set by which you want to restore databases of the source instance. When you replicate databases by backup set, you can call the [DescribeBackups](~~610544~~) operation to obtain the ID of the backup set.
	//
	// > : You must specify one of the **BackupId** and **RestoreTime** parameters.
	BackupId *string `json:"BackupId,omitempty" xml:"BackupId,omitempty"`
	// The ID of the source instance. You can call the [DescribeDBInstances](~~610396~~) operation to query the ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The names of the databases. Format: `{"Original database name 1":"New database name 1","Original database name 2":"New database name 2"}`.
	DbNames         *string `json:"DbNames,omitempty" xml:"DbNames,omitempty"`
	ResourceOwnerId *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The point in time when the system replicates databases. You can select a point in time within the backup retention period. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
	//
	// > You must specify one of the **BackupId** and **RestoreTime** parameters.
	RestoreTime *string `json:"RestoreTime,omitempty" xml:"RestoreTime,omitempty"`
	// Specifies whether to copy users and permissions.
	//
	// *   **YES**: copies users and permissions. If the destination instance has a user whose name is the same as a user in the source instance, the permissions of the user in the source instance will also be granted to the user in the destination instance after you copy user permissions.
	// *   **NO**: does not copy users and permissions.
	//
	// Default value: **NO**.
	SyncUserPrivilege *string `json:"SyncUserPrivilege,omitempty" xml:"SyncUserPrivilege,omitempty"`
	// The ID of the destination instance. You can call the [DescribeDBInstances](~~610396~~) operation to query the ID of the instance.
	TargetDBInstanceId *string `json:"TargetDBInstanceId,omitempty" xml:"TargetDBInstanceId,omitempty"`
}

func (s CopyDatabaseBetweenInstancesRequest) String() string {
	return tea.Prettify(s)
}

func (s CopyDatabaseBetweenInstancesRequest) GoString() string {
	return s.String()
}

func (s *CopyDatabaseBetweenInstancesRequest) SetBackupId(v string) *CopyDatabaseBetweenInstancesRequest {
	s.BackupId = &v
	return s
}

func (s *CopyDatabaseBetweenInstancesRequest) SetDBInstanceId(v string) *CopyDatabaseBetweenInstancesRequest {
	s.DBInstanceId = &v
	return s
}

func (s *CopyDatabaseBetweenInstancesRequest) SetDbNames(v string) *CopyDatabaseBetweenInstancesRequest {
	s.DbNames = &v
	return s
}

func (s *CopyDatabaseBetweenInstancesRequest) SetResourceOwnerId(v int64) *CopyDatabaseBetweenInstancesRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CopyDatabaseBetweenInstancesRequest) SetRestoreTime(v string) *CopyDatabaseBetweenInstancesRequest {
	s.RestoreTime = &v
	return s
}

func (s *CopyDatabaseBetweenInstancesRequest) SetSyncUserPrivilege(v string) *CopyDatabaseBetweenInstancesRequest {
	s.SyncUserPrivilege = &v
	return s
}

func (s *CopyDatabaseBetweenInstancesRequest) SetTargetDBInstanceId(v string) *CopyDatabaseBetweenInstancesRequest {
	s.TargetDBInstanceId = &v
	return s
}

type CopyDatabaseBetweenInstancesResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CopyDatabaseBetweenInstancesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CopyDatabaseBetweenInstancesResponseBody) GoString() string {
	return s.String()
}

func (s *CopyDatabaseBetweenInstancesResponseBody) SetRequestId(v string) *CopyDatabaseBetweenInstancesResponseBody {
	s.RequestId = &v
	return s
}

type CopyDatabaseBetweenInstancesResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CopyDatabaseBetweenInstancesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CopyDatabaseBetweenInstancesResponse) String() string {
	return tea.Prettify(s)
}

func (s CopyDatabaseBetweenInstancesResponse) GoString() string {
	return s.String()
}

func (s *CopyDatabaseBetweenInstancesResponse) SetHeaders(v map[string]*string) *CopyDatabaseBetweenInstancesResponse {
	s.Headers = v
	return s
}

func (s *CopyDatabaseBetweenInstancesResponse) SetStatusCode(v int32) *CopyDatabaseBetweenInstancesResponse {
	s.StatusCode = &v
	return s
}

func (s *CopyDatabaseBetweenInstancesResponse) SetBody(v *CopyDatabaseBetweenInstancesResponseBody) *CopyDatabaseBetweenInstancesResponse {
	s.Body = v
	return s
}

type CreateAccountRequest struct {
	// The description of the account. The value must be 2 to 256 characters in length. The value can contain letters, digits, underscores (\_), and hyphens (-), and must start with a letter.
	//
	// > : The name cannot start with http:// or https://.
	AccountDescription *string `json:"AccountDescription,omitempty" xml:"AccountDescription,omitempty"`
	// The username of the account.
	//
	// *   The value must be unique.
	//
	// *   The value must start with a lowercase letter, and end with a lowercase letter or a digit.
	//
	// *   The value can contain lowercase letters, digits, and underscores (\_).
	//
	// *   The length of the value must meet the following requirements:
	//
	//     *   If the instance runs MySQL 5.7 or MySQL 8.0, the value must be 2 to 32 characters in length.
	//     *   If the instance runs MySQL 5.6, the value must be 2 to 16 characters in length.
	//     *   If the instance runs SQL Server, the value must be 2 to 64 characters in length.
	//     *   If the instance runs PostgreSQL with cloud disks, the value must be 2 to 63 characters in length.
	//     *   If the instance runs PostgreSQL with local disks, the value must be 2 to 16 characters in length.
	//     *   If the instance runs MariaDB, the value must be 2 to 16 characters in length.
	//
	// *   For more information about invalid characters, see [Forbidden keywords table](~~26317~~).
	AccountName *string `json:"AccountName,omitempty" xml:"AccountName,omitempty"`
	// The password of the account.
	//
	//
	// *   The value must be 8 to 32 characters in length.
	//
	// *   The password must contain at least three of the following character types: uppercase letters, lowercase letters, digits, and special characters.
	//
	// *   Special characters include `! @ # $ % ^ & * ( ) _ + - =`
	AccountPassword *string `json:"AccountPassword,omitempty" xml:"AccountPassword,omitempty"`
	// The account type. Valid values:
	//
	// *   **Normal**: standard account
	// *   **Super**: privileged account
	//
	// Default value: **Normal**.
	AccountType *string `json:"AccountType,omitempty" xml:"AccountType,omitempty"`
	// The instance ID. You can call the DescribeDBInstances operation to query the instance ID.
	DBInstanceId         *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s CreateAccountRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateAccountRequest) GoString() string {
	return s.String()
}

func (s *CreateAccountRequest) SetAccountDescription(v string) *CreateAccountRequest {
	s.AccountDescription = &v
	return s
}

func (s *CreateAccountRequest) SetAccountName(v string) *CreateAccountRequest {
	s.AccountName = &v
	return s
}

func (s *CreateAccountRequest) SetAccountPassword(v string) *CreateAccountRequest {
	s.AccountPassword = &v
	return s
}

func (s *CreateAccountRequest) SetAccountType(v string) *CreateAccountRequest {
	s.AccountType = &v
	return s
}

func (s *CreateAccountRequest) SetDBInstanceId(v string) *CreateAccountRequest {
	s.DBInstanceId = &v
	return s
}

func (s *CreateAccountRequest) SetOwnerAccount(v string) *CreateAccountRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateAccountRequest) SetOwnerId(v int64) *CreateAccountRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateAccountRequest) SetResourceOwnerAccount(v string) *CreateAccountRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateAccountRequest) SetResourceOwnerId(v int64) *CreateAccountRequest {
	s.ResourceOwnerId = &v
	return s
}

type CreateAccountResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateAccountResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateAccountResponseBody) GoString() string {
	return s.String()
}

func (s *CreateAccountResponseBody) SetRequestId(v string) *CreateAccountResponseBody {
	s.RequestId = &v
	return s
}

type CreateAccountResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateAccountResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateAccountResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateAccountResponse) GoString() string {
	return s.String()
}

func (s *CreateAccountResponse) SetHeaders(v map[string]*string) *CreateAccountResponse {
	s.Headers = v
	return s
}

func (s *CreateAccountResponse) SetStatusCode(v int32) *CreateAccountResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateAccountResponse) SetBody(v *CreateAccountResponseBody) *CreateAccountResponse {
	s.Body = v
	return s
}

type CreateBackupRequest struct {
	// The backup type of the instance. Valid values:
	//
	// *   **Logical**: logical backup
	// *   **Physical**: physical backup
	// *   **Snapshot**: snapshot backup
	//
	// Default value: **Physical**.
	//
	// > *   You can perform a logical backup only when databases are created on the instance.
	// > *   When you perform a snapshot backup on an ApsaraDB RDS for MariaDB instance, you must set this parameter to **Physical**.
	// > *   For more information about the supported backup types, see [Use the data backup feature](~~98818~~).
	// > *   When you perform a snapshot backup on an ApsaraDB RDS for SQL Server instance that uses cloud disks, you must set this parameter to **Snapshot**.
	BackupMethod *string `json:"BackupMethod,omitempty" xml:"BackupMethod,omitempty"`
	// The backup policy. Valid values:
	//
	// *   **db**: a database-level backup.
	// *   **instance**: an instance-level backup.
	//
	// > You can specify this parameter when you perform a logical backup on an ApsaraDB RDS for MySQL instance. You can also specify this parameter when you perform a full physical backup on an ApsaraDB RDS for SQL Server instance.
	BackupStrategy *string `json:"BackupStrategy,omitempty" xml:"BackupStrategy,omitempty"`
	// The backup method. Valid values:
	//
	// *   **Auto**: full or incremental backup that is automatically selected
	// *   **FullBackup**: full backup
	//
	// Default value: **Auto**.
	//
	// > *   You must set this parameter only when the instance runs SQL Server.
	// > *   This parameter is valid only when you set the **BackupMethod** parameter to **Physical**.
	BackupType *string `json:"BackupType,omitempty" xml:"BackupType,omitempty"`
	// The instance ID. You can call the [DescribeDBInstances](~~610396~~) operation to query the ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The names of the databases whose data you want to back up. Separate the names of the databases with commas (,).
	//
	// > You can specify this parameter when you perform a logical backup on individual databases of an ApsaraDB RDS for MySQL instance. You can also specify this parameter when you perform a full physical backup on individual databases of an ApsaraDB RDS for SQL Server instance.
	DBName *string `json:"DBName,omitempty" xml:"DBName,omitempty"`
	// The resource group ID. You can call the [DescribeDBInstanceAttribute](~~610394~~) operation to obtain the ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerId *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s CreateBackupRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateBackupRequest) GoString() string {
	return s.String()
}

func (s *CreateBackupRequest) SetBackupMethod(v string) *CreateBackupRequest {
	s.BackupMethod = &v
	return s
}

func (s *CreateBackupRequest) SetBackupStrategy(v string) *CreateBackupRequest {
	s.BackupStrategy = &v
	return s
}

func (s *CreateBackupRequest) SetBackupType(v string) *CreateBackupRequest {
	s.BackupType = &v
	return s
}

func (s *CreateBackupRequest) SetDBInstanceId(v string) *CreateBackupRequest {
	s.DBInstanceId = &v
	return s
}

func (s *CreateBackupRequest) SetDBName(v string) *CreateBackupRequest {
	s.DBName = &v
	return s
}

func (s *CreateBackupRequest) SetResourceGroupId(v string) *CreateBackupRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *CreateBackupRequest) SetResourceOwnerId(v int64) *CreateBackupRequest {
	s.ResourceOwnerId = &v
	return s
}

type CreateBackupResponseBody struct {
	// The ID of the backup task.
	BackupJobId *string `json:"BackupJobId,omitempty" xml:"BackupJobId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateBackupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateBackupResponseBody) GoString() string {
	return s.String()
}

func (s *CreateBackupResponseBody) SetBackupJobId(v string) *CreateBackupResponseBody {
	s.BackupJobId = &v
	return s
}

func (s *CreateBackupResponseBody) SetRequestId(v string) *CreateBackupResponseBody {
	s.RequestId = &v
	return s
}

type CreateBackupResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateBackupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateBackupResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateBackupResponse) GoString() string {
	return s.String()
}

func (s *CreateBackupResponse) SetHeaders(v map[string]*string) *CreateBackupResponse {
	s.Headers = v
	return s
}

func (s *CreateBackupResponse) SetStatusCode(v int32) *CreateBackupResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateBackupResponse) SetBody(v *CreateBackupResponseBody) *CreateBackupResponse {
	s.Body = v
	return s
}

type CreateCloudMigrationPrecheckTaskRequest struct {
	// The ID of the instance. You can call the [DescribeDBInstances](~~26232~~) operation to query the IDs of instances.
	DBInstanceName  *string `json:"DBInstanceName,omitempty" xml:"DBInstanceName,omitempty"`
	ResourceOwnerId *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The username of the account that is used to connect to the self-managed PostgreSQL instance. Enter the username of the account that you created in the [Create an account for cloud migration on a self-managed PostgreSQL instance](~~369500~~) topic.
	SourceAccount *string `json:"SourceAccount,omitempty" xml:"SourceAccount,omitempty"`
	// The environment in which the self-managed PostgreSQL instance runs.
	//
	// *   **idcOnVpc**: The self-managed PostgreSQL instance resides in a data center. The data center can communicate with the VPC to which the ApsaraDB RDS for PostgreSQL instance belongs.
	// *   **ecsOnVpc**: The self-managed PostgreSQL instance resides on an ECS instance.
	SourceCategory *string `json:"SourceCategory,omitempty" xml:"SourceCategory,omitempty"`
	// The private IP address that is used to connect to the self-managed PostgreSQL instance.
	//
	// *   If the self-managed PostgreSQL instance resides on an ECS instance, enter the private IP address of the ECS instance. For more information about how to obtain the private IP address of an ECS instance, see [View IP addresses](~~273914~~).
	// *   If the self-managed PostgreSQL instance resides in an on-premises data center, enter the private IP address of the on-premises data center.
	SourceIpAddress *string `json:"SourceIpAddress,omitempty" xml:"SourceIpAddress,omitempty"`
	// The password of the account that is used to connect to the self-managed PostgreSQL instance. Enter the password of the account that you created in the [Create an account for cloud migration on a self-managed PostgreSQL instance](~~369500~~) topic.
	SourcePassword *string `json:"SourcePassword,omitempty" xml:"SourcePassword,omitempty"`
	// The port that is used to connect to the self-managed PostgreSQL instance. You can run the `netstat -a | grep PGSQL` command to view the port.
	SourcePort *int64 `json:"SourcePort,omitempty" xml:"SourcePort,omitempty"`
	// The name of the task. If you do not specify this parameter, ApsaraDB RDS automatically generates a name for the cloud migration task.
	TaskName *string `json:"TaskName,omitempty" xml:"TaskName,omitempty"`
}

func (s CreateCloudMigrationPrecheckTaskRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateCloudMigrationPrecheckTaskRequest) GoString() string {
	return s.String()
}

func (s *CreateCloudMigrationPrecheckTaskRequest) SetDBInstanceName(v string) *CreateCloudMigrationPrecheckTaskRequest {
	s.DBInstanceName = &v
	return s
}

func (s *CreateCloudMigrationPrecheckTaskRequest) SetResourceOwnerId(v int64) *CreateCloudMigrationPrecheckTaskRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreateCloudMigrationPrecheckTaskRequest) SetSourceAccount(v string) *CreateCloudMigrationPrecheckTaskRequest {
	s.SourceAccount = &v
	return s
}

func (s *CreateCloudMigrationPrecheckTaskRequest) SetSourceCategory(v string) *CreateCloudMigrationPrecheckTaskRequest {
	s.SourceCategory = &v
	return s
}

func (s *CreateCloudMigrationPrecheckTaskRequest) SetSourceIpAddress(v string) *CreateCloudMigrationPrecheckTaskRequest {
	s.SourceIpAddress = &v
	return s
}

func (s *CreateCloudMigrationPrecheckTaskRequest) SetSourcePassword(v string) *CreateCloudMigrationPrecheckTaskRequest {
	s.SourcePassword = &v
	return s
}

func (s *CreateCloudMigrationPrecheckTaskRequest) SetSourcePort(v int64) *CreateCloudMigrationPrecheckTaskRequest {
	s.SourcePort = &v
	return s
}

func (s *CreateCloudMigrationPrecheckTaskRequest) SetTaskName(v string) *CreateCloudMigrationPrecheckTaskRequest {
	s.TaskName = &v
	return s
}

type CreateCloudMigrationPrecheckTaskResponseBody struct {
	// The name of the instance.
	DBInstanceName *string `json:"DBInstanceName,omitempty" xml:"DBInstanceName,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the task.
	TaskId *int64 `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
	// The name of the task.
	TaskName *string `json:"TaskName,omitempty" xml:"TaskName,omitempty"`
}

func (s CreateCloudMigrationPrecheckTaskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateCloudMigrationPrecheckTaskResponseBody) GoString() string {
	return s.String()
}

func (s *CreateCloudMigrationPrecheckTaskResponseBody) SetDBInstanceName(v string) *CreateCloudMigrationPrecheckTaskResponseBody {
	s.DBInstanceName = &v
	return s
}

func (s *CreateCloudMigrationPrecheckTaskResponseBody) SetRequestId(v string) *CreateCloudMigrationPrecheckTaskResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateCloudMigrationPrecheckTaskResponseBody) SetTaskId(v int64) *CreateCloudMigrationPrecheckTaskResponseBody {
	s.TaskId = &v
	return s
}

func (s *CreateCloudMigrationPrecheckTaskResponseBody) SetTaskName(v string) *CreateCloudMigrationPrecheckTaskResponseBody {
	s.TaskName = &v
	return s
}

type CreateCloudMigrationPrecheckTaskResponse struct {
	Headers    map[string]*string                            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateCloudMigrationPrecheckTaskResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateCloudMigrationPrecheckTaskResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateCloudMigrationPrecheckTaskResponse) GoString() string {
	return s.String()
}

func (s *CreateCloudMigrationPrecheckTaskResponse) SetHeaders(v map[string]*string) *CreateCloudMigrationPrecheckTaskResponse {
	s.Headers = v
	return s
}

func (s *CreateCloudMigrationPrecheckTaskResponse) SetStatusCode(v int32) *CreateCloudMigrationPrecheckTaskResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateCloudMigrationPrecheckTaskResponse) SetBody(v *CreateCloudMigrationPrecheckTaskResponseBody) *CreateCloudMigrationPrecheckTaskResponse {
	s.Body = v
	return s
}

type CreateCloudMigrationTaskRequest struct {
	// The ID of the instance. You can call the [DescribeDBInstances](~~26232~~) operation to query the ID of the instance.
	DBInstanceName  *string `json:"DBInstanceName,omitempty" xml:"DBInstanceName,omitempty"`
	ResourceOwnerId *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The username of the account that is used to connect to the self-managed PostgreSQL instance. Enter the username of the account that you created in the [Create an account for cloud migration on a self-managed PostgreSQL instance](~~369500~~) topic.
	SourceAccount *string `json:"SourceAccount,omitempty" xml:"SourceAccount,omitempty"`
	// The environment in which the self-managed PostgreSQL instance runs.
	//
	// *   **idcOnVpc**: The self-managed PostgreSQL instance resides in a data center. The data center can communicate with the VPC to which the ApsaraDB RDS for PostgreSQL instance belongs.
	// *   **ecsOnVpc**: The self-managed PostgreSQL instance resides on an ECS instance.
	SourceCategory *string `json:"SourceCategory,omitempty" xml:"SourceCategory,omitempty"`
	// The private or public IP address that is used to connect to the self-managed PostgreSQL instance.
	//
	// *   If the self-managed PostgreSQL instance resides on an Elastic Compute Service (ECS) instance, enter the private IP address of the ECS instance. For more information about how to obtain the private IP address of an ECS instance, see [View IP addresses](~~273914~~).
	// *   If the self-managed PostgreSQL instance resides in a data center, enter the private IP address of the data center.
	SourceIpAddress *string `json:"SourceIpAddress,omitempty" xml:"SourceIpAddress,omitempty"`
	// The password of the account that is used to connect to the self-managed PostgreSQL instance. Enter the password of the account that you created in the [Create an account for cloud migration on a self-managed PostgreSQL instance](~~369500~~) topic.
	SourcePassword *string `json:"SourcePassword,omitempty" xml:"SourcePassword,omitempty"`
	// The port number that is used to connect to the self-managed PostgreSQL instance. You can run the `netstat -a | grep PGSQL` command to obtain the port number.
	SourcePort *int64 `json:"SourcePort,omitempty" xml:"SourcePort,omitempty"`
	// The name of the task. If you do not specify this parameter, ApsaraDB RDS automatically generates a name for the cloud migration task.
	TaskName *string `json:"TaskName,omitempty" xml:"TaskName,omitempty"`
}

func (s CreateCloudMigrationTaskRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateCloudMigrationTaskRequest) GoString() string {
	return s.String()
}

func (s *CreateCloudMigrationTaskRequest) SetDBInstanceName(v string) *CreateCloudMigrationTaskRequest {
	s.DBInstanceName = &v
	return s
}

func (s *CreateCloudMigrationTaskRequest) SetResourceOwnerId(v int64) *CreateCloudMigrationTaskRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreateCloudMigrationTaskRequest) SetSourceAccount(v string) *CreateCloudMigrationTaskRequest {
	s.SourceAccount = &v
	return s
}

func (s *CreateCloudMigrationTaskRequest) SetSourceCategory(v string) *CreateCloudMigrationTaskRequest {
	s.SourceCategory = &v
	return s
}

func (s *CreateCloudMigrationTaskRequest) SetSourceIpAddress(v string) *CreateCloudMigrationTaskRequest {
	s.SourceIpAddress = &v
	return s
}

func (s *CreateCloudMigrationTaskRequest) SetSourcePassword(v string) *CreateCloudMigrationTaskRequest {
	s.SourcePassword = &v
	return s
}

func (s *CreateCloudMigrationTaskRequest) SetSourcePort(v int64) *CreateCloudMigrationTaskRequest {
	s.SourcePort = &v
	return s
}

func (s *CreateCloudMigrationTaskRequest) SetTaskName(v string) *CreateCloudMigrationTaskRequest {
	s.TaskName = &v
	return s
}

type CreateCloudMigrationTaskResponseBody struct {
	// The name of the instance.
	DBInstanceName *string `json:"DBInstanceName,omitempty" xml:"DBInstanceName,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the task.
	TaskId *int64 `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
	// The name of the task.
	TaskName *string `json:"TaskName,omitempty" xml:"TaskName,omitempty"`
}

func (s CreateCloudMigrationTaskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateCloudMigrationTaskResponseBody) GoString() string {
	return s.String()
}

func (s *CreateCloudMigrationTaskResponseBody) SetDBInstanceName(v string) *CreateCloudMigrationTaskResponseBody {
	s.DBInstanceName = &v
	return s
}

func (s *CreateCloudMigrationTaskResponseBody) SetRequestId(v string) *CreateCloudMigrationTaskResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateCloudMigrationTaskResponseBody) SetTaskId(v int64) *CreateCloudMigrationTaskResponseBody {
	s.TaskId = &v
	return s
}

func (s *CreateCloudMigrationTaskResponseBody) SetTaskName(v string) *CreateCloudMigrationTaskResponseBody {
	s.TaskName = &v
	return s
}

type CreateCloudMigrationTaskResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateCloudMigrationTaskResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateCloudMigrationTaskResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateCloudMigrationTaskResponse) GoString() string {
	return s.String()
}

func (s *CreateCloudMigrationTaskResponse) SetHeaders(v map[string]*string) *CreateCloudMigrationTaskResponse {
	s.Headers = v
	return s
}

func (s *CreateCloudMigrationTaskResponse) SetStatusCode(v int32) *CreateCloudMigrationTaskResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateCloudMigrationTaskResponse) SetBody(v *CreateCloudMigrationTaskResponseBody) *CreateCloudMigrationTaskResponse {
	s.Body = v
	return s
}

type CreateDBInstanceRequest struct {
	// The number of ApsaraDB RDS for MySQL instances that you want to create. The parameter takes effect only when you create multiple ApsaraDB RDS for MySQL instances at a time by using a single request.
	//
	// Valid values: **1** to **20**. Default value: **1**.
	//
	// > *   If you want to create multiple ApsaraDB RDS for MySQL instances at a time by using a single request, you can add tags to all the instances by using the **Tag.Key** parameter and the **Tag.Value** parameter. After the instances are created, you can manage the instances based on the tags.
	// > *   After you submit a request to create multiple ApsaraDB RDS for MySQL instances, this operation returns **TaskId**, **RequestId**, and **Message**. You can call the [DescribeDBInstanceAttribute](~~610394~~) operation to query the details of an instance.
	// > *   If the value of the **Engine** parameter is not **MySQL** and the value of the Amount parameter is greater than **1**, this operation fails and returns an error code `InvalidParam.Engine`.
	Amount *int32 `json:"Amount,omitempty" xml:"Amount,omitempty"`
	// Specifies whether to automatically complete the payment. Default value: true. Valid values:
	//
	// *   **true**: automatically completes the payment. You must make sure that your account balance is sufficient.
	// *   **false**: does not automatically complete the payment. An unpaid order is generated.
	//
	// >  Default value: true. If your account balance is insufficient, you can set AutoPay to false to generate an unpaid order. Then, you can pay for the order in the ApsaraDB RDS console.
	AutoPay *bool `json:"AutoPay,omitempty" xml:"AutoPay,omitempty"`
	// Specifies whether to enable auto-renewal for the instance. You must specify this parameter only if the instance uses the subscription billing method. Valid values:
	//
	// *   **true**
	// *   **false**
	//
	// > *   The auto-renewal cycle is one month for a monthly subscription.
	// > *   The auto-renewal cycle is one year for a yearly subscription.
	AutoRenew *string `json:"AutoRenew,omitempty" xml:"AutoRenew,omitempty"`
	// The configuration of the Babelfish feature for the instance that runs PostgreSQL.
	//
	// Format:{"babelfishEnabled":"true","migrationMode":"xxxxxxx","masterUsername":"xxxxxxx","masterUserPassword":"xxxxxxxx"}
	//
	// The following list describes the fields in the format:
	//
	// *   **babelfishEnabled**: specifies whether to enable Babelfish for the instance. If you set this field to **true**, you enable Babelfish for the instance. If you leave this parameter empty, Babelfish is disabled for the instance.
	// *   **migrationMode**: The migration mode of the instance. Valid values: **single-db** and **multi-db**.
	// *   **masterUsername**: The username of the administrator account. The username can contain lowercase letters, digits, and underscores (\_). It must start with a letter and end with a letter or digit. It can be up to 63 characters in length and cannot start with pg.
	// *   **masterUserPassword**: The password of the administrator account. The password must contain at least three of the following character types: uppercase letters, lowercase letters, digits, and special characters. It must be 8 to 32 characters in length. The password can contain any of the following characters: `! @ # $ % ^ & * ( ) _ + - =`.
	//
	// > : This parameter applies only to ApsaraDB RDS for PostgreSQL instances. For more information about Babelfish for ApsaraDB RDS for PostgreSQL, see [Introduction to Babelfish](~~428613~~).
	BabelfishConfig *string `json:"BabelfishConfig,omitempty" xml:"BabelfishConfig,omitempty"`
	// A reserved parameter. You do not need to specify this parameter.
	BpeEnabled *string `json:"BpeEnabled,omitempty" xml:"BpeEnabled,omitempty"`
	// A reserved parameter. You do not need to specify this parameter.
	BurstingEnabled *bool `json:"BurstingEnabled,omitempty" xml:"BurstingEnabled,omitempty"`
	// The additional business information about the instance.
	BusinessInfo *string `json:"BusinessInfo,omitempty" xml:"BusinessInfo,omitempty"`
	// The RDS edition of the instance. Valid values:
	//
	// *   Regular RDS instance
	//
	//     *   **Basic**: RDS Basic Edition.
	//     *   **HighAvailability**: RDS High-availability Edition.
	//     *   **cluster**: RDS Cluster Edition for ApsaraDB RDS for MySQL.
	//     *   **AlwaysOn**: RDS Cluster Edition for ApsaraDB RDS for SQL Server.
	//     *   **Finance**: RDS Enterprise Edition.
	//
	// *   Serverless instance
	//
	//     *   **serverless_basic**: RDS Basic Edition. This edition is available only for instances that run MySQL and PostgreSQL.
	//     *   **serverless_standard**: RDS High-availability Edition. This edition is available only for instances that run MySQL and PostgreSQL.
	//     *   **serverless_ha**: RDS High-availability Edition for ApsaraDB RDS for SQL Server.
	//
	//     **
	//
	//     **Note** This parameter is required when you create a serverless instance.
	Category *string `json:"Category,omitempty" xml:"Category,omitempty"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The connection mode of the instance. Valid values:
	//
	// *   **Standard**: standard mode
	// *   **Safe**: database proxy mode
	//
	// ApsaraDB RDS automatically assigns a connection mode to the instance.
	//
	// > : SQL Server 2012, SQL Server 2016, and SQL Server 2017 support only the standard mode.
	ConnectionMode *string `json:"ConnectionMode,omitempty" xml:"ConnectionMode,omitempty"`
	// The internal endpoint that is used to connect to the instance.
	ConnectionString *string `json:"ConnectionString,omitempty" xml:"ConnectionString,omitempty"`
	// The policy based on which multiple instances are created. The parameter takes effect only when the value of the **Amount** parameter is greater than 1. Valid values:
	//
	// *   **Atomicity** (default): atomicity. The instances are all created together. If one instance cannot be created, none of the instances are created.
	// *   **Partial**: non-atomicity. Each instance is independently created. The failure in creating an instance does not affect the creation of the other instances.
	CreateStrategy *string `json:"CreateStrategy,omitempty" xml:"CreateStrategy,omitempty"`
	// The instance type of the instance. For more information, see [Primary ApsaraDB RDS instance types](~~26312~~).
	//
	// To create a serverless instance, set this parameter to one of the following values:
	//
	// *   If you want to create a serverless instance that runs MySQL on RDS Basic Edition, set this parameter to **mysql.n2.serverless.1c**.
	// *   If you want to create a serverless instance that runs MySQL on RDS High-availability Edition, set this parameter to **mysql.n2.serverless.2c**.
	// *   If you want to create a serverless instance that runs SQL Server, set this parameter to **mssql.mem2.serverless.s2**.
	// *   If you want to create a serverless instance that runs PostgreSQL on RDS Basic Edition, set this parameter to **pg.n2.serverless.1c**.
	// *   If you want to create a serverless instance that runs PostgreSQL on RDS High-availability Edition, set this parameter to **pg.n2.serverless.2c**.
	DBInstanceClass *string `json:"DBInstanceClass,omitempty" xml:"DBInstanceClass,omitempty"`
	// The instance name. The name must be 2 to 255 characters in length and can contain letters, digits, underscores (\_), and hyphens (-). The name must start with a letter.
	//
	// > : The name cannot start with http:// or https://.
	DBInstanceDescription *string `json:"DBInstanceDescription,omitempty" xml:"DBInstanceDescription,omitempty"`
	// The network connection type of the instance. The value of this parameter is fixed as **Intranet**, indicating an internal network connection.
	DBInstanceNetType *string `json:"DBInstanceNetType,omitempty" xml:"DBInstanceNetType,omitempty"`
	// The storage capacity of the instance. Unit: GB. The storage capacity increases in increments of 5 GB. For more information, see [Primary ApsaraDB RDS instance types](~~26312~~).
	DBInstanceStorage *int32 `json:"DBInstanceStorage,omitempty" xml:"DBInstanceStorage,omitempty"`
	// The storage type of the instance. Valid values:
	//
	// *   **local_ssd**: local SSD. This is the recommended storage type.
	// *   **cloud_ssd**: standard SSD. This storage type is not recommended. Standard SSDs are no longer available for purchase in some Alibaba Cloud regions.
	// *   **cloud_essd**: enhanced SSD (ESSD) of performance level 1 (PL1).
	// *   **cloud_essd2**: ESSD of PL2.
	// *   **cloud_essd3**: ESSD of PL3.
	//
	// The default value of this parameter is determined by the instance type specified by the **DBInstanceClass** parameter.
	//
	// *   If the instance type specifies the local SSD storage type, the default value of this parameter is **local_ssd**.
	// *   If the instance type specifies the standard SSD or ESSD storage type, the default value of this parameter is **cloud_essd**.
	//
	// >  Serverless instances use only ESSDs of PL1. If you create a serverless instance, you must set this parameter to **cloud_essd**.
	DBInstanceStorageType *string `json:"DBInstanceStorageType,omitempty" xml:"DBInstanceStorageType,omitempty"`
	// Specifies whether the table name is case-sensitive. Valid values:
	//
	// *   **true**: Table names are not case-sensitive. This is the default value.
	// *   **false**: Table names are case-sensitive.
	DBIsIgnoreCase *string `json:"DBIsIgnoreCase,omitempty" xml:"DBIsIgnoreCase,omitempty"`
	// The ID of the parameter template. You can call the [DescribeParameterGroups](~~610588~~) operation to query the ID of the parameter template.
	//
	// > : This parameter is available if you want to create an instance that runs MySQL or PostgreSQL . If you do not configure this parameter, the default parameter template is used. If you want to use a custom parameter template, you can customize a parameter template and set this parameter to the ID of the custom template. For more information, see [Create a parameter template](~~610585~~).
	DBParamGroupId *string `json:"DBParamGroupId,omitempty" xml:"DBParamGroupId,omitempty"`
	// The time zone of the instance. This parameter takes effect only when you set the **Engine** parameter to **MySQL** or **PostgreSQL**.
	//
	// *   If you set **Engine** to **MySQL**:
	//
	//     *   The time zone of the instance is in UTC. Valid values: \*\*-12:59\*\* to **+13:00**.
	//     *   If the instance uses local SSDs, you can specify the name of the time zone. Example: Asia/Hong_Kong. For more information, see [Time zones](~~297356~~).
	//
	// *   If you set **Engine** to **PostgreSQL**:
	//
	//     *   The time zone of the instance is not in UTC. For more information, see [Time zones](~~297356~~).
	//     *   You can specify this parameter only when the instance runs PostgreSQL with standard SSDs or ESSDs.
	//
	// > *   You can specify the time zone when you create a primary instance. You cannot specify the time zone when you create a read-only instance. Read-only instances inherit the time zone of their primary instance.
	// > *   If you do not specify this parameter, the system automatically assigns the default time zone of the region in which the instance resides.
	DBTimeZone *string `json:"DBTimeZone,omitempty" xml:"DBTimeZone,omitempty"`
	// The ID of the dedicated cluster to which the instance belongs.
	//
	// If you create the instance in a dedicated cluster, you must specify this parameter.
	//
	// *   You can call the [DescribeDedicatedHostGroups](~~610640~~) operation to query the details of a dedicated cluster.
	// *   If no dedicated clusters are created, you can call the [CreateDedicatedHostGroup](~~209828~~) operation to create a dedicated cluster.
	DedicatedHostGroupId *string `json:"DedicatedHostGroupId,omitempty" xml:"DedicatedHostGroupId,omitempty"`
	// Specifies whether to enable the release protection feature for the instance. This feature is available only for pay-as-you-go instances. Valid values:
	//
	// *   **true**
	// *   **false** (default)
	DeletionProtection *bool `json:"DeletionProtection,omitempty" xml:"DeletionProtection,omitempty"`
	// Specifies whether to perform a dry run. Valid values:
	//
	// *   **true**: performs a dry run but does not perform the actual request. The system checks items such as the request parameters, request format, service limits, and available resources.
	// *   **false** (default): performs a dry run and performs the actual request. If the request passes the dry run, the instance is created.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The ID of the key that is used to encrypt data on standard SSDs or ESSDs in the region of the instance. If you specify the EncryptionKey parameter, cloud disk encryption is automatically enabled. In this case, you must also specify the **RoleARN** parameter. Cloud disk encryption cannot be disabled after it is enabled.
	//
	// You can obtain the ID of the key from the Key Management Service (KMS) console. You can also create a key. For more information, see [Create a CMK](~~181610~~).
	//
	// >  This parameter is optional when you create an ApsaraDB RDS for PostgreSQL instance. You need to only specify the **RoleARN** parameter to create an instance that has cloud disk encryption enabled by using the obtained key ID.
	EncryptionKey *string `json:"EncryptionKey,omitempty" xml:"EncryptionKey,omitempty"`
	// The database engine of the instance. Valid values:
	//
	// *   **MySQL**
	// *   **SQLServer**
	// *   **PostgreSQL**
	// *   **MariaDB**
	Engine *string `json:"Engine,omitempty" xml:"Engine,omitempty"`
	// The database engine version of the instance.
	//
	// *   Regular RDS instance
	//
	//     *   Valid values when you set Engine to MySQL: **5.5**, **5.6**, **5.7**, and **8.0**
	//     *   Valid values when you set Engine to SQLServer: **08r2\_ent_ha**(cloud disks, discontinued), **2008r2**(local disks, discontinued), **2012**(SQL Server EE Basic), **2012\_ent_ha**, **2012\_std_ha**, **2012\_web**, **2014\_ent_ha**, **2014\_std_ha**, **2016\_ent_ha**, **2016\_std_ha**, **2016\_web**, **2017\_ent**, **2017\_std_ha**, **2017\_web**, **2019\_ent**, **2019\_std_ha**, **2019\_web**, **2022\_ent**, **2022\_std_ha**, and **2022\_web**
	//     *   Valid values when you set Engine to PostgreSQL: **10.0**, **11.0**, **12.0**, **13.0**, **14.0**, and **15.0**
	//     *   Valid value when you set Engine to MariaDB: **10.3**
	//
	// *   Serverless instance
	//
	//     *   Valid values when you set Engine to MySQL: **5.7** and **8.0**
	//     *   Valid values when you set Engine to SQLServer: **2016\_std_sl**, **2017\_std_sl**, and **2019\_std_sl**
	//     *   Valid value when you set Engine to PostgreSQL: **14.0**
	//
	// <!---->
	//
	// *   ApsaraDB RDS for MariaDB does not support serverless instances.
	// *   For ApsaraDB RDS for SQL Server instances, `_ent` indicates SQL Server EE on RDS Cluster Edition, `_ent_ha` indicates SQL Server EE, `_std_ha` indicates SQL Server SE, and `_web` indicates SQL Server Web.
	//
	// >
	//
	// *   ApsaraDB RDS for MariaDB does not support serverless instances.
	//
	// *   Valid value if you set Engine to SQL Server: `_ent` specifies SQL Server EE on RDS Cluster Edition, `_ent_ha` specifies SQL Server EE, `_std_ha` specifies SQL Server SE, and `_web` specifies SQL Server Web.
	//
	// *   RDS instances that run SQL Server 2014 are not available for purchase on the international site.
	EngineVersion *string `json:"EngineVersion,omitempty" xml:"EngineVersion,omitempty"`
	// The network type of the instance. Valid values:
	//
	// *   **VPC**: virtual private cloud (VPC).
	// *   **Classic**: the classic network
	//
	// >
	//
	// *   If the instance runs MySQL and uses cloud disks, you must set this parameter to **VPC**.
	//
	// *   If the instance runs PostgreSQL or MariaDB, you must set this parameter to **VPC**.
	//
	// *   RDS instances that run SQL Server Basic and SQL Server Web can reside in the classic network and virtual private clouds (VPCs). If the instance runs other database engines, you must set this parameter to **VPC**.
	InstanceNetworkType *string `json:"InstanceNetworkType,omitempty" xml:"InstanceNetworkType,omitempty"`
	// The billing method of the instance. Valid values:
	//
	// *   **Postpaid**: pay-as-you-go.
	// *   **Prepaid**: subscription.
	// *   **Serverless**: serverless. This value is not supported for instances that run MariaDB. For more information, see [Overview of serverless ApsaraDB RDS for MySQL instances](~~411291~~), [Overview of serverless ApsaraDB RDS for SQL Server instances](~~604344~~), and [Overview of serverless ApsaraDB RDS for PostgreSQL instances](~~607742~~).
	//
	// > : The system automatically generates a purchase order and completes the payment.
	PayType *string `json:"PayType,omitempty" xml:"PayType,omitempty"`
	// The unit of the subscription duration. Valid values:
	//
	// *   **Year**
	// *   **Month**
	//
	// >  If you set the PayType parameter to **Prepaid**, you must specify the UsedTime parameter.
	Period *string `json:"Period,omitempty" xml:"Period,omitempty"`
	// The port. You can initialize the port when you create the instance.
	//
	// *   Valid values if the instance runs MySQL: 1000 to 65534
	// *   Valid values if the instance runs PostgreSQL, SQL Server, or MariaDB: 1000 to 5999
	Port *string `json:"Port,omitempty" xml:"Port,omitempty"`
	// The private IP address of the instance. The private IP address must be within the CIDR block that is supported by the specified vSwitch. ApsaraDB RDS automatically assigns a private IP address to the instance based on the values of the **VPCId** and **vSwitchId** parameters.
	PrivateIpAddress *string `json:"PrivateIpAddress,omitempty" xml:"PrivateIpAddress,omitempty"`
	// The region ID. You can call the [DescribeRegions](~~610399~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerId *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The Alibaba Cloud Resource Name (ARN) that is provided by your Alibaba Cloud account for RAM users. RAM users can use the ARN to connect ApsaraDB RDS to KMS. You can call the [CheckCloudResourceAuthorized](~~610408~~) operation to query the ARN.
	RoleARN *string `json:"RoleARN,omitempty" xml:"RoleARN,omitempty"`
	// The IP address whitelist of the instance. For more information, see [Use a database client or the CLI to connect to an ApsaraDB RDS for MySQL instance](~~43185~~). If the IP address whitelist contains more than one entry, separate the entries with commas (,). Each entry must be unique. The IP address whitelist can contain up to 1,000 entries. The entries in the IP address whitelist must be in one of the following formats:
	//
	// *   IP addresses, such as 10.10.XX.XX.
	// *   CIDR blocks, such as 10.10.XX.XX/24. In this example, 24 indicates that the prefix of each IP address in the IP address whitelist is 24 bits in length. You can replace 24 with a value within the range of 1 to 32.
	SecurityIPList *string `json:"SecurityIPList,omitempty" xml:"SecurityIPList,omitempty"`
	// The settings of the serverless instance. This parameter is required when you create a serverless instance.
	//
	// >  ApsaraDB RDS for MariaDB does not support serverless instances.
	ServerlessConfig *CreateDBInstanceRequestServerlessConfig `json:"ServerlessConfig,omitempty" xml:"ServerlessConfig,omitempty" type:"Struct"`
	// Specifies whether to enable the automatic storage expansion feature for the instance. This feature is supported if your RDS instance runs MySQL or PostgreSQL. Valid values:
	//
	// *   **Enable**
	// *   **Disable** (default)
	//
	// >  After the instance is created, you can call the [ModifyDasInstanceConfig](~~610391~~) operation to adjust the settings of automatic storage expansion for the instance. For more information, see [Configure automatic storage expansion for an ApsaraDB RDS for MySQL instance](~~173826~~).
	StorageAutoScale *string `json:"StorageAutoScale,omitempty" xml:"StorageAutoScale,omitempty"`
	// The threshold in percentage based on which automatic storage expansion is triggered.
	//
	// *   **10**
	// *   **20**
	// *   **30**
	// *   **40**
	// *   **50**
	//
	// >  If you set the **StorageAutoScale** parameter to **Enable**, you must specify this parameter.
	StorageThreshold *int32 `json:"StorageThreshold,omitempty" xml:"StorageThreshold,omitempty"`
	// The maximum storage capacity that is allowed for automatic storage expansion. The storage capacity of the instance cannot exceed the maximum storage capacity. Unit: GB.
	//
	// > *   Valid values: an integer greater than or equal to 0.
	// > *   If you set **StorageAutoScale** to **Enable**, you must specify this parameter.
	StorageUpperBound *int32 `json:"StorageUpperBound,omitempty" xml:"StorageUpperBound,omitempty"`
	// A deprecated parameter. You do not need to specify this parameter.
	SystemDBCharset *string `json:"SystemDBCharset,omitempty" xml:"SystemDBCharset,omitempty"`
	// The tags.
	Tag []*CreateDBInstanceRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
	// The ID of the host to which the logger instance belongs in the specified dedicated cluster.
	//
	// If you want to create an instance that runs RDS Enterprise Edition in a dedicated cluster, you must specify this parameter. If you do not specify this parameter, the system automatically assigns a host.
	//
	// *   You can call the [DescribeDedicatedHosts](~~610641~~) operation to query the details of the hosts in a dedicated cluster.
	// *   If no hosts are created, you can call the [CreateDedicatedHost](~~210864~~) operation to create a host.
	TargetDedicatedHostIdForLog *string `json:"TargetDedicatedHostIdForLog,omitempty" xml:"TargetDedicatedHostIdForLog,omitempty"`
	// The ID of the host to which the instance belongs in the specified dedicated cluster.
	//
	// If you create the instance in a dedicated cluster, you must specify this parameter. If you do not specify this parameter, the system automatically assigns a host.
	//
	// *   You can call the [DescribeDedicatedHost](~~610641~~) operation to query the details about the hosts in a dedicated cluster.
	// *   If no hosts are created, you can call the [CreateDedicatedHost](~~210864~~) operation to create a host.
	TargetDedicatedHostIdForMaster *string `json:"TargetDedicatedHostIdForMaster,omitempty" xml:"TargetDedicatedHostIdForMaster,omitempty"`
	// The ID of the host to which the secondary instance belongs in the specified dedicated cluster.
	//
	// If you want to create an instance that runs RDS High-availability Edition or RDS Enterprise Edition in a dedicated cluster, you must specify this parameter. If you do not specify this parameter, the system automatically assigns a host.
	//
	// *   You can call the [DescribeDedicatedHosts](~~610641~~) operation to query the details of the hosts in a dedicated cluster.
	// *   If no hosts are created, you can call the [CreateDedicatedHost](~~210864~~) operation to create a host.
	TargetDedicatedHostIdForSlave *string `json:"TargetDedicatedHostIdForSlave,omitempty" xml:"TargetDedicatedHostIdForSlave,omitempty"`
	// The minor engine version of the instance. This parameter is required only when you create an instance that runs MySQL or PostgreSQL. The value format varies based on the database engine of the instance.
	//
	// *   If you create an instance that runs MySQL, the value is in the following format: `<RDS edition>_<Minor engine version>`. Examples: `rds_20200229`, `xcluster_20200229`, and `xcluster80_20200229`. The following list describes the fields in the example values:
	//
	//     *   rds: The instance runs RDS Basic Edition or RDS High-availability Edition.
	//     *   xcluster: The instance runs MySQL 5.7 on RDS Enterprise Edition.
	//     *   xcluster80: The instance runs MySQL 8.0 on RDS Enterprise Edition.
	//
	//     **
	//
	//     **Note** You can call the [DescribeDBMiniEngineVersions](~~610643~~) operation to query the minor engine version. For more information about minor engine versions, see [Release notes of minor AliSQL versions](~~96060~~).
	//
	// *   If you create an instance that runs PostgreSQL, the value is in the following format: `rds_postgres_<Major engine version>00_<Minor engine version>`. Example: `rds_postgres_1400_20220830`. The following list describes the fields in the example values:
	//
	//     *   1400: The major engine version is PostgreSQL 14.
	//     *   20220830: the AliPG version. You can call the [DescribeDBMiniEngineVersions](~~610643~~) operation to query the AliPG version. For more information about minor engine versions, see [Release notes for AliPG](~~126002~~).
	//
	//     **
	//
	//     **Note** If you configure the **BabelfishConfig** parameter for your instance that runs PostgreSQL and set the babelfishEnabled field to true, the value of this parameter is in the following format: `rds_postgres_Major engine version00_AliPG version_babelfish`.
	TargetMinorVersion *string `json:"TargetMinorVersion,omitempty" xml:"TargetMinorVersion,omitempty"`
	// The subscription duration of the instance.
	//
	// *   If you set the **Period** parameter to **Year**, the value of the **UsedTime** parameter ranges from **1 to 5**.
	// *   If you set the **Period** parameter to **Month**, the value of the **UsedTime** parameter ranges from **1 to 11**.
	//
	// >  If you set the PayType parameter to **Prepaid**, you must specify the UsedTime parameter.
	UsedTime *string `json:"UsedTime,omitempty" xml:"UsedTime,omitempty"`
	// The ID of the backup file. You can call the [ListUserBackupFiles](~~610600~~) operation to query backup files. If you want to create an instance by using the data of a backup file, you must specify this parameter.
	//
	// This parameter is supported only when the following requirements are met:
	//
	// *   The **PayType** parameter is set to **Postpaid**.
	// *   The **Engine** parameter is set to **MySQL**.
	// *   The **EngineVersion** parameter is set to **5.7**.
	// *   The **Category** parameter is set to **Basic**.
	UserBackupId *string `json:"UserBackupId,omitempty" xml:"UserBackupId,omitempty"`
	// The ID of the VPC to which the instance belongs.
	//
	// > : This parameter is available when you set the **InstanceNetworkType** parameter to **VPC**.
	VPCId *string `json:"VPCId,omitempty" xml:"VPCId,omitempty"`
	// The ID of the vSwitch. The vSwitch must belong to the zone that is specified by **ZoneId**.
	//
	// *   If you set **InstanceNetworkType** to **VPC**, you must also specify this parameter.
	// *   If you specify the ZoneSlaveId1 parameter, you must specify the IDs of two vSwitches for this parameter and separate the IDs with a comma (,).
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
	// The zone ID of the primary instance.
	//
	// *   If you specify a virtual private cloud (VPC) and a vSwitch, you must specify the ID of the zone to which the specified vSwitch belongs. Otherwise, the instance cannot be created.
	// *   If the instance runs RDS High-availability Edition, you must specify the **ZoneIdSlave1** parameter. The ZoneIdSlave1 parameter specifies whether to use the single-zone deployment method or the multi-zone deployment method.
	// *   If the instance runs RDS Enterprise Edition, you must specify the **ZoneIdSlave1** and **ZoneIdSlave2** parameters. The ZoneIdSlave1 and ZoneIdSlave2 parameters specify whether to use the single-zone deployment method or the multi-zone deployment method.
	// *   If the instance runs MySQL on RDS Cluster Edition, you must specify the **ZoneIdSlave1** parameter for the RDS cluster that has two nodes and the **ZoneIdSlave1** and **ZoneIdSlave2** parameters for the RDS cluster that has three nodes.
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
	// The zone ID of the secondary instance.
	//
	// *   If you set this parameter to **Auto**, the multi-zone deployment method is used and the zone of the secondary instance is automatically configured.
	// *   If you set this parameter to the same value as the **ZoneId** parameter, the single-zone deployment method is used.
	// *   If you set this parameter to a value that is different from the value of the **ZoneId** parameter, the multiple-zone deployment method is used.
	ZoneIdSlave1 *string `json:"ZoneIdSlave1,omitempty" xml:"ZoneIdSlave1,omitempty"`
	// This parameter is deprecated.
	ZoneIdSlave2 *string `json:"ZoneIdSlave2,omitempty" xml:"ZoneIdSlave2,omitempty"`
}

func (s CreateDBInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateDBInstanceRequest) GoString() string {
	return s.String()
}

func (s *CreateDBInstanceRequest) SetAmount(v int32) *CreateDBInstanceRequest {
	s.Amount = &v
	return s
}

func (s *CreateDBInstanceRequest) SetAutoPay(v bool) *CreateDBInstanceRequest {
	s.AutoPay = &v
	return s
}

func (s *CreateDBInstanceRequest) SetAutoRenew(v string) *CreateDBInstanceRequest {
	s.AutoRenew = &v
	return s
}

func (s *CreateDBInstanceRequest) SetBabelfishConfig(v string) *CreateDBInstanceRequest {
	s.BabelfishConfig = &v
	return s
}

func (s *CreateDBInstanceRequest) SetBpeEnabled(v string) *CreateDBInstanceRequest {
	s.BpeEnabled = &v
	return s
}

func (s *CreateDBInstanceRequest) SetBurstingEnabled(v bool) *CreateDBInstanceRequest {
	s.BurstingEnabled = &v
	return s
}

func (s *CreateDBInstanceRequest) SetBusinessInfo(v string) *CreateDBInstanceRequest {
	s.BusinessInfo = &v
	return s
}

func (s *CreateDBInstanceRequest) SetCategory(v string) *CreateDBInstanceRequest {
	s.Category = &v
	return s
}

func (s *CreateDBInstanceRequest) SetClientToken(v string) *CreateDBInstanceRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateDBInstanceRequest) SetConnectionMode(v string) *CreateDBInstanceRequest {
	s.ConnectionMode = &v
	return s
}

func (s *CreateDBInstanceRequest) SetConnectionString(v string) *CreateDBInstanceRequest {
	s.ConnectionString = &v
	return s
}

func (s *CreateDBInstanceRequest) SetCreateStrategy(v string) *CreateDBInstanceRequest {
	s.CreateStrategy = &v
	return s
}

func (s *CreateDBInstanceRequest) SetDBInstanceClass(v string) *CreateDBInstanceRequest {
	s.DBInstanceClass = &v
	return s
}

func (s *CreateDBInstanceRequest) SetDBInstanceDescription(v string) *CreateDBInstanceRequest {
	s.DBInstanceDescription = &v
	return s
}

func (s *CreateDBInstanceRequest) SetDBInstanceNetType(v string) *CreateDBInstanceRequest {
	s.DBInstanceNetType = &v
	return s
}

func (s *CreateDBInstanceRequest) SetDBInstanceStorage(v int32) *CreateDBInstanceRequest {
	s.DBInstanceStorage = &v
	return s
}

func (s *CreateDBInstanceRequest) SetDBInstanceStorageType(v string) *CreateDBInstanceRequest {
	s.DBInstanceStorageType = &v
	return s
}

func (s *CreateDBInstanceRequest) SetDBIsIgnoreCase(v string) *CreateDBInstanceRequest {
	s.DBIsIgnoreCase = &v
	return s
}

func (s *CreateDBInstanceRequest) SetDBParamGroupId(v string) *CreateDBInstanceRequest {
	s.DBParamGroupId = &v
	return s
}

func (s *CreateDBInstanceRequest) SetDBTimeZone(v string) *CreateDBInstanceRequest {
	s.DBTimeZone = &v
	return s
}

func (s *CreateDBInstanceRequest) SetDedicatedHostGroupId(v string) *CreateDBInstanceRequest {
	s.DedicatedHostGroupId = &v
	return s
}

func (s *CreateDBInstanceRequest) SetDeletionProtection(v bool) *CreateDBInstanceRequest {
	s.DeletionProtection = &v
	return s
}

func (s *CreateDBInstanceRequest) SetDryRun(v bool) *CreateDBInstanceRequest {
	s.DryRun = &v
	return s
}

func (s *CreateDBInstanceRequest) SetEncryptionKey(v string) *CreateDBInstanceRequest {
	s.EncryptionKey = &v
	return s
}

func (s *CreateDBInstanceRequest) SetEngine(v string) *CreateDBInstanceRequest {
	s.Engine = &v
	return s
}

func (s *CreateDBInstanceRequest) SetEngineVersion(v string) *CreateDBInstanceRequest {
	s.EngineVersion = &v
	return s
}

func (s *CreateDBInstanceRequest) SetInstanceNetworkType(v string) *CreateDBInstanceRequest {
	s.InstanceNetworkType = &v
	return s
}

func (s *CreateDBInstanceRequest) SetPayType(v string) *CreateDBInstanceRequest {
	s.PayType = &v
	return s
}

func (s *CreateDBInstanceRequest) SetPeriod(v string) *CreateDBInstanceRequest {
	s.Period = &v
	return s
}

func (s *CreateDBInstanceRequest) SetPort(v string) *CreateDBInstanceRequest {
	s.Port = &v
	return s
}

func (s *CreateDBInstanceRequest) SetPrivateIpAddress(v string) *CreateDBInstanceRequest {
	s.PrivateIpAddress = &v
	return s
}

func (s *CreateDBInstanceRequest) SetRegionId(v string) *CreateDBInstanceRequest {
	s.RegionId = &v
	return s
}

func (s *CreateDBInstanceRequest) SetResourceGroupId(v string) *CreateDBInstanceRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *CreateDBInstanceRequest) SetResourceOwnerId(v int64) *CreateDBInstanceRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreateDBInstanceRequest) SetRoleARN(v string) *CreateDBInstanceRequest {
	s.RoleARN = &v
	return s
}

func (s *CreateDBInstanceRequest) SetSecurityIPList(v string) *CreateDBInstanceRequest {
	s.SecurityIPList = &v
	return s
}

func (s *CreateDBInstanceRequest) SetServerlessConfig(v *CreateDBInstanceRequestServerlessConfig) *CreateDBInstanceRequest {
	s.ServerlessConfig = v
	return s
}

func (s *CreateDBInstanceRequest) SetStorageAutoScale(v string) *CreateDBInstanceRequest {
	s.StorageAutoScale = &v
	return s
}

func (s *CreateDBInstanceRequest) SetStorageThreshold(v int32) *CreateDBInstanceRequest {
	s.StorageThreshold = &v
	return s
}

func (s *CreateDBInstanceRequest) SetStorageUpperBound(v int32) *CreateDBInstanceRequest {
	s.StorageUpperBound = &v
	return s
}

func (s *CreateDBInstanceRequest) SetSystemDBCharset(v string) *CreateDBInstanceRequest {
	s.SystemDBCharset = &v
	return s
}

func (s *CreateDBInstanceRequest) SetTag(v []*CreateDBInstanceRequestTag) *CreateDBInstanceRequest {
	s.Tag = v
	return s
}

func (s *CreateDBInstanceRequest) SetTargetDedicatedHostIdForLog(v string) *CreateDBInstanceRequest {
	s.TargetDedicatedHostIdForLog = &v
	return s
}

func (s *CreateDBInstanceRequest) SetTargetDedicatedHostIdForMaster(v string) *CreateDBInstanceRequest {
	s.TargetDedicatedHostIdForMaster = &v
	return s
}

func (s *CreateDBInstanceRequest) SetTargetDedicatedHostIdForSlave(v string) *CreateDBInstanceRequest {
	s.TargetDedicatedHostIdForSlave = &v
	return s
}

func (s *CreateDBInstanceRequest) SetTargetMinorVersion(v string) *CreateDBInstanceRequest {
	s.TargetMinorVersion = &v
	return s
}

func (s *CreateDBInstanceRequest) SetUsedTime(v string) *CreateDBInstanceRequest {
	s.UsedTime = &v
	return s
}

func (s *CreateDBInstanceRequest) SetUserBackupId(v string) *CreateDBInstanceRequest {
	s.UserBackupId = &v
	return s
}

func (s *CreateDBInstanceRequest) SetVPCId(v string) *CreateDBInstanceRequest {
	s.VPCId = &v
	return s
}

func (s *CreateDBInstanceRequest) SetVSwitchId(v string) *CreateDBInstanceRequest {
	s.VSwitchId = &v
	return s
}

func (s *CreateDBInstanceRequest) SetZoneId(v string) *CreateDBInstanceRequest {
	s.ZoneId = &v
	return s
}

func (s *CreateDBInstanceRequest) SetZoneIdSlave1(v string) *CreateDBInstanceRequest {
	s.ZoneIdSlave1 = &v
	return s
}

func (s *CreateDBInstanceRequest) SetZoneIdSlave2(v string) *CreateDBInstanceRequest {
	s.ZoneIdSlave2 = &v
	return s
}

type CreateDBInstanceRequestServerlessConfig struct {
	// Specifies whether to enable the automatic startup and stop feature for the serverless instance. Valid values:
	//
	// *   **true**
	// *   **false** (default)
	//
	// >  This parameter is required only for serverless instances that run MySQL and PostgreSQL. After the automatic start and stop feature is enabled, if no connections to the instance are established within 10 minutes, the instance is suspended. After a connection to the instance is established, the instance is resumed.
	AutoPause *bool `json:"AutoPause,omitempty" xml:"AutoPause,omitempty"`
	// The maximum number of RDS Capacity Units (RCUs). Valid values:
	//
	// *   Serverless ApsaraDB RDS for MySQL instances: **1 to 8**
	// *   Serverless ApsaraDB RDS for SQL Server instances: **2 to 8**
	// *   Serverless ApsaraDB RDS for PostgreSQL instances: **1 to 12**
	//
	// >  The value of this parameter must be greater than or equal to the value of **MinCapacity** and can be specified only to an **integer**.
	MaxCapacity *float64 `json:"MaxCapacity,omitempty" xml:"MaxCapacity,omitempty"`
	// The minimum number of RCUs. Valid values:
	//
	// *   Serverless ApsaraDB RDS for MySQL instances: **0.5 to 8**.
	// *   Serverless ApsaraDB RDS for SQL Server instances: **2 to 8**. Only integers are supported.
	// *   Serverless ApsaraDB RDS for PostgreSQL instances: **0.5 to 12**.
	//
	// >  The value of this parameter must be less than or equal to the value of **MaxCapacity**.
	MinCapacity *float64 `json:"MinCapacity,omitempty" xml:"MinCapacity,omitempty"`
	// Specifies whether to enable the forced scaling feature for the serverless instance. Valid values:
	//
	// *   **true**
	// *   **false** (default)
	//
	// >
	//
	// *   This parameter is required if you want to create a serverless instance that run MySQL and PostgreSQL. If you set this parameter to true, a transient connection that lasts approximately 1 minute occurs during forced scaling. Process with caution.
	//
	// *   The RCU scaling for a serverless instance immediately takes effect. In some cases, such as the execution of large transactions, the scaling does not immediately take effect. In this case, you can enable this feature to forcefully scale the RCUs of the instance.
	SwitchForce *bool `json:"SwitchForce,omitempty" xml:"SwitchForce,omitempty"`
}

func (s CreateDBInstanceRequestServerlessConfig) String() string {
	return tea.Prettify(s)
}

func (s CreateDBInstanceRequestServerlessConfig) GoString() string {
	return s.String()
}

func (s *CreateDBInstanceRequestServerlessConfig) SetAutoPause(v bool) *CreateDBInstanceRequestServerlessConfig {
	s.AutoPause = &v
	return s
}

func (s *CreateDBInstanceRequestServerlessConfig) SetMaxCapacity(v float64) *CreateDBInstanceRequestServerlessConfig {
	s.MaxCapacity = &v
	return s
}

func (s *CreateDBInstanceRequestServerlessConfig) SetMinCapacity(v float64) *CreateDBInstanceRequestServerlessConfig {
	s.MinCapacity = &v
	return s
}

func (s *CreateDBInstanceRequestServerlessConfig) SetSwitchForce(v bool) *CreateDBInstanceRequestServerlessConfig {
	s.SwitchForce = &v
	return s
}

type CreateDBInstanceRequestTag struct {
	// The key of the tag that you want to add to the instance. You can use this parameter to add tags to the instance.
	//
	// *   If the specified tag key is an existing key, the system directly adds the tag key to the instance. You can call the [ListTagResources](~~610627~~) operation to query the details of the existing tags.
	// *   If the specified tag key is not an existing key, the system creates the tag key and adds the tag key to the instance.
	// *   A tag key cannot be an empty string.
	// *   This parameter must be used together with the **Tag.Value** parameter.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value that is associated with the specified tag key. You can use this parameter to add tags to the instance.
	//
	// *   If the specified tag value is found in the specified tag key, the system directly adds the tag value to the instance. You can call the [ListTagResources](~~610627~~) operation to query the details of the existing tags.
	// *   If the specified tag value is not found in the specified tag key, the system creates the tag value and adds the tag value to the instance.
	// *   This parameter must be used together with the **Tag.Key** parameter.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateDBInstanceRequestTag) String() string {
	return tea.Prettify(s)
}

func (s CreateDBInstanceRequestTag) GoString() string {
	return s.String()
}

func (s *CreateDBInstanceRequestTag) SetKey(v string) *CreateDBInstanceRequestTag {
	s.Key = &v
	return s
}

func (s *CreateDBInstanceRequestTag) SetValue(v string) *CreateDBInstanceRequestTag {
	s.Value = &v
	return s
}

type CreateDBInstanceShrinkRequest struct {
	// The number of ApsaraDB RDS for MySQL instances that you want to create. The parameter takes effect only when you create multiple ApsaraDB RDS for MySQL instances at a time by using a single request.
	//
	// Valid values: **1** to **20**. Default value: **1**.
	//
	// > *   If you want to create multiple ApsaraDB RDS for MySQL instances at a time by using a single request, you can add tags to all the instances by using the **Tag.Key** parameter and the **Tag.Value** parameter. After the instances are created, you can manage the instances based on the tags.
	// > *   After you submit a request to create multiple ApsaraDB RDS for MySQL instances, this operation returns **TaskId**, **RequestId**, and **Message**. You can call the [DescribeDBInstanceAttribute](~~610394~~) operation to query the details of an instance.
	// > *   If the value of the **Engine** parameter is not **MySQL** and the value of the Amount parameter is greater than **1**, this operation fails and returns an error code `InvalidParam.Engine`.
	Amount *int32 `json:"Amount,omitempty" xml:"Amount,omitempty"`
	// Specifies whether to automatically complete the payment. Default value: true. Valid values:
	//
	// *   **true**: automatically completes the payment. You must make sure that your account balance is sufficient.
	// *   **false**: does not automatically complete the payment. An unpaid order is generated.
	//
	// >  Default value: true. If your account balance is insufficient, you can set AutoPay to false to generate an unpaid order. Then, you can pay for the order in the ApsaraDB RDS console.
	AutoPay *bool `json:"AutoPay,omitempty" xml:"AutoPay,omitempty"`
	// Specifies whether to enable auto-renewal for the instance. You must specify this parameter only if the instance uses the subscription billing method. Valid values:
	//
	// *   **true**
	// *   **false**
	//
	// > *   The auto-renewal cycle is one month for a monthly subscription.
	// > *   The auto-renewal cycle is one year for a yearly subscription.
	AutoRenew *string `json:"AutoRenew,omitempty" xml:"AutoRenew,omitempty"`
	// The configuration of the Babelfish feature for the instance that runs PostgreSQL.
	//
	// Format:{"babelfishEnabled":"true","migrationMode":"xxxxxxx","masterUsername":"xxxxxxx","masterUserPassword":"xxxxxxxx"}
	//
	// The following list describes the fields in the format:
	//
	// *   **babelfishEnabled**: specifies whether to enable Babelfish for the instance. If you set this field to **true**, you enable Babelfish for the instance. If you leave this parameter empty, Babelfish is disabled for the instance.
	// *   **migrationMode**: The migration mode of the instance. Valid values: **single-db** and **multi-db**.
	// *   **masterUsername**: The username of the administrator account. The username can contain lowercase letters, digits, and underscores (\_). It must start with a letter and end with a letter or digit. It can be up to 63 characters in length and cannot start with pg.
	// *   **masterUserPassword**: The password of the administrator account. The password must contain at least three of the following character types: uppercase letters, lowercase letters, digits, and special characters. It must be 8 to 32 characters in length. The password can contain any of the following characters: `! @ # $ % ^ & * ( ) _ + - =`.
	//
	// > : This parameter applies only to ApsaraDB RDS for PostgreSQL instances. For more information about Babelfish for ApsaraDB RDS for PostgreSQL, see [Introduction to Babelfish](~~428613~~).
	BabelfishConfig *string `json:"BabelfishConfig,omitempty" xml:"BabelfishConfig,omitempty"`
	// A reserved parameter. You do not need to specify this parameter.
	BpeEnabled *string `json:"BpeEnabled,omitempty" xml:"BpeEnabled,omitempty"`
	// A reserved parameter. You do not need to specify this parameter.
	BurstingEnabled *bool `json:"BurstingEnabled,omitempty" xml:"BurstingEnabled,omitempty"`
	// The additional business information about the instance.
	BusinessInfo *string `json:"BusinessInfo,omitempty" xml:"BusinessInfo,omitempty"`
	// The RDS edition of the instance. Valid values:
	//
	// *   Regular RDS instance
	//
	//     *   **Basic**: RDS Basic Edition.
	//     *   **HighAvailability**: RDS High-availability Edition.
	//     *   **cluster**: RDS Cluster Edition for ApsaraDB RDS for MySQL.
	//     *   **AlwaysOn**: RDS Cluster Edition for ApsaraDB RDS for SQL Server.
	//     *   **Finance**: RDS Enterprise Edition.
	//
	// *   Serverless instance
	//
	//     *   **serverless_basic**: RDS Basic Edition. This edition is available only for instances that run MySQL and PostgreSQL.
	//     *   **serverless_standard**: RDS High-availability Edition. This edition is available only for instances that run MySQL and PostgreSQL.
	//     *   **serverless_ha**: RDS High-availability Edition for ApsaraDB RDS for SQL Server.
	//
	//     **
	//
	//     **Note** This parameter is required when you create a serverless instance.
	Category *string `json:"Category,omitempty" xml:"Category,omitempty"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The connection mode of the instance. Valid values:
	//
	// *   **Standard**: standard mode
	// *   **Safe**: database proxy mode
	//
	// ApsaraDB RDS automatically assigns a connection mode to the instance.
	//
	// > : SQL Server 2012, SQL Server 2016, and SQL Server 2017 support only the standard mode.
	ConnectionMode *string `json:"ConnectionMode,omitempty" xml:"ConnectionMode,omitempty"`
	// The internal endpoint that is used to connect to the instance.
	ConnectionString *string `json:"ConnectionString,omitempty" xml:"ConnectionString,omitempty"`
	// The policy based on which multiple instances are created. The parameter takes effect only when the value of the **Amount** parameter is greater than 1. Valid values:
	//
	// *   **Atomicity** (default): atomicity. The instances are all created together. If one instance cannot be created, none of the instances are created.
	// *   **Partial**: non-atomicity. Each instance is independently created. The failure in creating an instance does not affect the creation of the other instances.
	CreateStrategy *string `json:"CreateStrategy,omitempty" xml:"CreateStrategy,omitempty"`
	// The instance type of the instance. For more information, see [Primary ApsaraDB RDS instance types](~~26312~~).
	//
	// To create a serverless instance, set this parameter to one of the following values:
	//
	// *   If you want to create a serverless instance that runs MySQL on RDS Basic Edition, set this parameter to **mysql.n2.serverless.1c**.
	// *   If you want to create a serverless instance that runs MySQL on RDS High-availability Edition, set this parameter to **mysql.n2.serverless.2c**.
	// *   If you want to create a serverless instance that runs SQL Server, set this parameter to **mssql.mem2.serverless.s2**.
	// *   If you want to create a serverless instance that runs PostgreSQL on RDS Basic Edition, set this parameter to **pg.n2.serverless.1c**.
	// *   If you want to create a serverless instance that runs PostgreSQL on RDS High-availability Edition, set this parameter to **pg.n2.serverless.2c**.
	DBInstanceClass *string `json:"DBInstanceClass,omitempty" xml:"DBInstanceClass,omitempty"`
	// The instance name. The name must be 2 to 255 characters in length and can contain letters, digits, underscores (\_), and hyphens (-). The name must start with a letter.
	//
	// > : The name cannot start with http:// or https://.
	DBInstanceDescription *string `json:"DBInstanceDescription,omitempty" xml:"DBInstanceDescription,omitempty"`
	// The network connection type of the instance. The value of this parameter is fixed as **Intranet**, indicating an internal network connection.
	DBInstanceNetType *string `json:"DBInstanceNetType,omitempty" xml:"DBInstanceNetType,omitempty"`
	// The storage capacity of the instance. Unit: GB. The storage capacity increases in increments of 5 GB. For more information, see [Primary ApsaraDB RDS instance types](~~26312~~).
	DBInstanceStorage *int32 `json:"DBInstanceStorage,omitempty" xml:"DBInstanceStorage,omitempty"`
	// The storage type of the instance. Valid values:
	//
	// *   **local_ssd**: local SSD. This is the recommended storage type.
	// *   **cloud_ssd**: standard SSD. This storage type is not recommended. Standard SSDs are no longer available for purchase in some Alibaba Cloud regions.
	// *   **cloud_essd**: enhanced SSD (ESSD) of performance level 1 (PL1).
	// *   **cloud_essd2**: ESSD of PL2.
	// *   **cloud_essd3**: ESSD of PL3.
	//
	// The default value of this parameter is determined by the instance type specified by the **DBInstanceClass** parameter.
	//
	// *   If the instance type specifies the local SSD storage type, the default value of this parameter is **local_ssd**.
	// *   If the instance type specifies the standard SSD or ESSD storage type, the default value of this parameter is **cloud_essd**.
	//
	// >  Serverless instances use only ESSDs of PL1. If you create a serverless instance, you must set this parameter to **cloud_essd**.
	DBInstanceStorageType *string `json:"DBInstanceStorageType,omitempty" xml:"DBInstanceStorageType,omitempty"`
	// Specifies whether the table name is case-sensitive. Valid values:
	//
	// *   **true**: Table names are not case-sensitive. This is the default value.
	// *   **false**: Table names are case-sensitive.
	DBIsIgnoreCase *string `json:"DBIsIgnoreCase,omitempty" xml:"DBIsIgnoreCase,omitempty"`
	// The ID of the parameter template. You can call the [DescribeParameterGroups](~~610588~~) operation to query the ID of the parameter template.
	//
	// > : This parameter is available if you want to create an instance that runs MySQL or PostgreSQL . If you do not configure this parameter, the default parameter template is used. If you want to use a custom parameter template, you can customize a parameter template and set this parameter to the ID of the custom template. For more information, see [Create a parameter template](~~610585~~).
	DBParamGroupId *string `json:"DBParamGroupId,omitempty" xml:"DBParamGroupId,omitempty"`
	// The time zone of the instance. This parameter takes effect only when you set the **Engine** parameter to **MySQL** or **PostgreSQL**.
	//
	// *   If you set **Engine** to **MySQL**:
	//
	//     *   The time zone of the instance is in UTC. Valid values: \*\*-12:59\*\* to **+13:00**.
	//     *   If the instance uses local SSDs, you can specify the name of the time zone. Example: Asia/Hong_Kong. For more information, see [Time zones](~~297356~~).
	//
	// *   If you set **Engine** to **PostgreSQL**:
	//
	//     *   The time zone of the instance is not in UTC. For more information, see [Time zones](~~297356~~).
	//     *   You can specify this parameter only when the instance runs PostgreSQL with standard SSDs or ESSDs.
	//
	// > *   You can specify the time zone when you create a primary instance. You cannot specify the time zone when you create a read-only instance. Read-only instances inherit the time zone of their primary instance.
	// > *   If you do not specify this parameter, the system automatically assigns the default time zone of the region in which the instance resides.
	DBTimeZone *string `json:"DBTimeZone,omitempty" xml:"DBTimeZone,omitempty"`
	// The ID of the dedicated cluster to which the instance belongs.
	//
	// If you create the instance in a dedicated cluster, you must specify this parameter.
	//
	// *   You can call the [DescribeDedicatedHostGroups](~~610640~~) operation to query the details of a dedicated cluster.
	// *   If no dedicated clusters are created, you can call the [CreateDedicatedHostGroup](~~209828~~) operation to create a dedicated cluster.
	DedicatedHostGroupId *string `json:"DedicatedHostGroupId,omitempty" xml:"DedicatedHostGroupId,omitempty"`
	// Specifies whether to enable the release protection feature for the instance. This feature is available only for pay-as-you-go instances. Valid values:
	//
	// *   **true**
	// *   **false** (default)
	DeletionProtection *bool `json:"DeletionProtection,omitempty" xml:"DeletionProtection,omitempty"`
	// Specifies whether to perform a dry run. Valid values:
	//
	// *   **true**: performs a dry run but does not perform the actual request. The system checks items such as the request parameters, request format, service limits, and available resources.
	// *   **false** (default): performs a dry run and performs the actual request. If the request passes the dry run, the instance is created.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The ID of the key that is used to encrypt data on standard SSDs or ESSDs in the region of the instance. If you specify the EncryptionKey parameter, cloud disk encryption is automatically enabled. In this case, you must also specify the **RoleARN** parameter. Cloud disk encryption cannot be disabled after it is enabled.
	//
	// You can obtain the ID of the key from the Key Management Service (KMS) console. You can also create a key. For more information, see [Create a CMK](~~181610~~).
	//
	// >  This parameter is optional when you create an ApsaraDB RDS for PostgreSQL instance. You need to only specify the **RoleARN** parameter to create an instance that has cloud disk encryption enabled by using the obtained key ID.
	EncryptionKey *string `json:"EncryptionKey,omitempty" xml:"EncryptionKey,omitempty"`
	// The database engine of the instance. Valid values:
	//
	// *   **MySQL**
	// *   **SQLServer**
	// *   **PostgreSQL**
	// *   **MariaDB**
	Engine *string `json:"Engine,omitempty" xml:"Engine,omitempty"`
	// The database engine version of the instance.
	//
	// *   Regular RDS instance
	//
	//     *   Valid values when you set Engine to MySQL: **5.5**, **5.6**, **5.7**, and **8.0**
	//     *   Valid values when you set Engine to SQLServer: **08r2\_ent_ha**(cloud disks, discontinued), **2008r2**(local disks, discontinued), **2012**(SQL Server EE Basic), **2012\_ent_ha**, **2012\_std_ha**, **2012\_web**, **2014\_ent_ha**, **2014\_std_ha**, **2016\_ent_ha**, **2016\_std_ha**, **2016\_web**, **2017\_ent**, **2017\_std_ha**, **2017\_web**, **2019\_ent**, **2019\_std_ha**, **2019\_web**, **2022\_ent**, **2022\_std_ha**, and **2022\_web**
	//     *   Valid values when you set Engine to PostgreSQL: **10.0**, **11.0**, **12.0**, **13.0**, **14.0**, and **15.0**
	//     *   Valid value when you set Engine to MariaDB: **10.3**
	//
	// *   Serverless instance
	//
	//     *   Valid values when you set Engine to MySQL: **5.7** and **8.0**
	//     *   Valid values when you set Engine to SQLServer: **2016\_std_sl**, **2017\_std_sl**, and **2019\_std_sl**
	//     *   Valid value when you set Engine to PostgreSQL: **14.0**
	//
	// <!---->
	//
	// *   ApsaraDB RDS for MariaDB does not support serverless instances.
	// *   For ApsaraDB RDS for SQL Server instances, `_ent` indicates SQL Server EE on RDS Cluster Edition, `_ent_ha` indicates SQL Server EE, `_std_ha` indicates SQL Server SE, and `_web` indicates SQL Server Web.
	//
	// >
	//
	// *   ApsaraDB RDS for MariaDB does not support serverless instances.
	//
	// *   Valid value if you set Engine to SQL Server: `_ent` specifies SQL Server EE on RDS Cluster Edition, `_ent_ha` specifies SQL Server EE, `_std_ha` specifies SQL Server SE, and `_web` specifies SQL Server Web.
	//
	// *   RDS instances that run SQL Server 2014 are not available for purchase on the international site.
	EngineVersion *string `json:"EngineVersion,omitempty" xml:"EngineVersion,omitempty"`
	// The network type of the instance. Valid values:
	//
	// *   **VPC**: virtual private cloud (VPC).
	// *   **Classic**: the classic network
	//
	// >
	//
	// *   If the instance runs MySQL and uses cloud disks, you must set this parameter to **VPC**.
	//
	// *   If the instance runs PostgreSQL or MariaDB, you must set this parameter to **VPC**.
	//
	// *   RDS instances that run SQL Server Basic and SQL Server Web can reside in the classic network and virtual private clouds (VPCs). If the instance runs other database engines, you must set this parameter to **VPC**.
	InstanceNetworkType *string `json:"InstanceNetworkType,omitempty" xml:"InstanceNetworkType,omitempty"`
	// The billing method of the instance. Valid values:
	//
	// *   **Postpaid**: pay-as-you-go.
	// *   **Prepaid**: subscription.
	// *   **Serverless**: serverless. This value is not supported for instances that run MariaDB. For more information, see [Overview of serverless ApsaraDB RDS for MySQL instances](~~411291~~), [Overview of serverless ApsaraDB RDS for SQL Server instances](~~604344~~), and [Overview of serverless ApsaraDB RDS for PostgreSQL instances](~~607742~~).
	//
	// > : The system automatically generates a purchase order and completes the payment.
	PayType *string `json:"PayType,omitempty" xml:"PayType,omitempty"`
	// The unit of the subscription duration. Valid values:
	//
	// *   **Year**
	// *   **Month**
	//
	// >  If you set the PayType parameter to **Prepaid**, you must specify the UsedTime parameter.
	Period *string `json:"Period,omitempty" xml:"Period,omitempty"`
	// The port. You can initialize the port when you create the instance.
	//
	// *   Valid values if the instance runs MySQL: 1000 to 65534
	// *   Valid values if the instance runs PostgreSQL, SQL Server, or MariaDB: 1000 to 5999
	Port *string `json:"Port,omitempty" xml:"Port,omitempty"`
	// The private IP address of the instance. The private IP address must be within the CIDR block that is supported by the specified vSwitch. ApsaraDB RDS automatically assigns a private IP address to the instance based on the values of the **VPCId** and **vSwitchId** parameters.
	PrivateIpAddress *string `json:"PrivateIpAddress,omitempty" xml:"PrivateIpAddress,omitempty"`
	// The region ID. You can call the [DescribeRegions](~~610399~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerId *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The Alibaba Cloud Resource Name (ARN) that is provided by your Alibaba Cloud account for RAM users. RAM users can use the ARN to connect ApsaraDB RDS to KMS. You can call the [CheckCloudResourceAuthorized](~~610408~~) operation to query the ARN.
	RoleARN *string `json:"RoleARN,omitempty" xml:"RoleARN,omitempty"`
	// The IP address whitelist of the instance. For more information, see [Use a database client or the CLI to connect to an ApsaraDB RDS for MySQL instance](~~43185~~). If the IP address whitelist contains more than one entry, separate the entries with commas (,). Each entry must be unique. The IP address whitelist can contain up to 1,000 entries. The entries in the IP address whitelist must be in one of the following formats:
	//
	// *   IP addresses, such as 10.10.XX.XX.
	// *   CIDR blocks, such as 10.10.XX.XX/24. In this example, 24 indicates that the prefix of each IP address in the IP address whitelist is 24 bits in length. You can replace 24 with a value within the range of 1 to 32.
	SecurityIPList *string `json:"SecurityIPList,omitempty" xml:"SecurityIPList,omitempty"`
	// The settings of the serverless instance. This parameter is required when you create a serverless instance.
	//
	// >  ApsaraDB RDS for MariaDB does not support serverless instances.
	ServerlessConfigShrink *string `json:"ServerlessConfig,omitempty" xml:"ServerlessConfig,omitempty"`
	// Specifies whether to enable the automatic storage expansion feature for the instance. This feature is supported if your RDS instance runs MySQL or PostgreSQL. Valid values:
	//
	// *   **Enable**
	// *   **Disable** (default)
	//
	// >  After the instance is created, you can call the [ModifyDasInstanceConfig](~~610391~~) operation to adjust the settings of automatic storage expansion for the instance. For more information, see [Configure automatic storage expansion for an ApsaraDB RDS for MySQL instance](~~173826~~).
	StorageAutoScale *string `json:"StorageAutoScale,omitempty" xml:"StorageAutoScale,omitempty"`
	// The threshold in percentage based on which automatic storage expansion is triggered.
	//
	// *   **10**
	// *   **20**
	// *   **30**
	// *   **40**
	// *   **50**
	//
	// >  If you set the **StorageAutoScale** parameter to **Enable**, you must specify this parameter.
	StorageThreshold *int32 `json:"StorageThreshold,omitempty" xml:"StorageThreshold,omitempty"`
	// The maximum storage capacity that is allowed for automatic storage expansion. The storage capacity of the instance cannot exceed the maximum storage capacity. Unit: GB.
	//
	// > *   Valid values: an integer greater than or equal to 0.
	// > *   If you set **StorageAutoScale** to **Enable**, you must specify this parameter.
	StorageUpperBound *int32 `json:"StorageUpperBound,omitempty" xml:"StorageUpperBound,omitempty"`
	// A deprecated parameter. You do not need to specify this parameter.
	SystemDBCharset *string `json:"SystemDBCharset,omitempty" xml:"SystemDBCharset,omitempty"`
	// The tags.
	Tag []*CreateDBInstanceShrinkRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
	// The ID of the host to which the logger instance belongs in the specified dedicated cluster.
	//
	// If you want to create an instance that runs RDS Enterprise Edition in a dedicated cluster, you must specify this parameter. If you do not specify this parameter, the system automatically assigns a host.
	//
	// *   You can call the [DescribeDedicatedHosts](~~610641~~) operation to query the details of the hosts in a dedicated cluster.
	// *   If no hosts are created, you can call the [CreateDedicatedHost](~~210864~~) operation to create a host.
	TargetDedicatedHostIdForLog *string `json:"TargetDedicatedHostIdForLog,omitempty" xml:"TargetDedicatedHostIdForLog,omitempty"`
	// The ID of the host to which the instance belongs in the specified dedicated cluster.
	//
	// If you create the instance in a dedicated cluster, you must specify this parameter. If you do not specify this parameter, the system automatically assigns a host.
	//
	// *   You can call the [DescribeDedicatedHost](~~610641~~) operation to query the details about the hosts in a dedicated cluster.
	// *   If no hosts are created, you can call the [CreateDedicatedHost](~~210864~~) operation to create a host.
	TargetDedicatedHostIdForMaster *string `json:"TargetDedicatedHostIdForMaster,omitempty" xml:"TargetDedicatedHostIdForMaster,omitempty"`
	// The ID of the host to which the secondary instance belongs in the specified dedicated cluster.
	//
	// If you want to create an instance that runs RDS High-availability Edition or RDS Enterprise Edition in a dedicated cluster, you must specify this parameter. If you do not specify this parameter, the system automatically assigns a host.
	//
	// *   You can call the [DescribeDedicatedHosts](~~610641~~) operation to query the details of the hosts in a dedicated cluster.
	// *   If no hosts are created, you can call the [CreateDedicatedHost](~~210864~~) operation to create a host.
	TargetDedicatedHostIdForSlave *string `json:"TargetDedicatedHostIdForSlave,omitempty" xml:"TargetDedicatedHostIdForSlave,omitempty"`
	// The minor engine version of the instance. This parameter is required only when you create an instance that runs MySQL or PostgreSQL. The value format varies based on the database engine of the instance.
	//
	// *   If you create an instance that runs MySQL, the value is in the following format: `<RDS edition>_<Minor engine version>`. Examples: `rds_20200229`, `xcluster_20200229`, and `xcluster80_20200229`. The following list describes the fields in the example values:
	//
	//     *   rds: The instance runs RDS Basic Edition or RDS High-availability Edition.
	//     *   xcluster: The instance runs MySQL 5.7 on RDS Enterprise Edition.
	//     *   xcluster80: The instance runs MySQL 8.0 on RDS Enterprise Edition.
	//
	//     **
	//
	//     **Note** You can call the [DescribeDBMiniEngineVersions](~~610643~~) operation to query the minor engine version. For more information about minor engine versions, see [Release notes of minor AliSQL versions](~~96060~~).
	//
	// *   If you create an instance that runs PostgreSQL, the value is in the following format: `rds_postgres_<Major engine version>00_<Minor engine version>`. Example: `rds_postgres_1400_20220830`. The following list describes the fields in the example values:
	//
	//     *   1400: The major engine version is PostgreSQL 14.
	//     *   20220830: the AliPG version. You can call the [DescribeDBMiniEngineVersions](~~610643~~) operation to query the AliPG version. For more information about minor engine versions, see [Release notes for AliPG](~~126002~~).
	//
	//     **
	//
	//     **Note** If you configure the **BabelfishConfig** parameter for your instance that runs PostgreSQL and set the babelfishEnabled field to true, the value of this parameter is in the following format: `rds_postgres_Major engine version00_AliPG version_babelfish`.
	TargetMinorVersion *string `json:"TargetMinorVersion,omitempty" xml:"TargetMinorVersion,omitempty"`
	// The subscription duration of the instance.
	//
	// *   If you set the **Period** parameter to **Year**, the value of the **UsedTime** parameter ranges from **1 to 5**.
	// *   If you set the **Period** parameter to **Month**, the value of the **UsedTime** parameter ranges from **1 to 11**.
	//
	// >  If you set the PayType parameter to **Prepaid**, you must specify the UsedTime parameter.
	UsedTime *string `json:"UsedTime,omitempty" xml:"UsedTime,omitempty"`
	// The ID of the backup file. You can call the [ListUserBackupFiles](~~610600~~) operation to query backup files. If you want to create an instance by using the data of a backup file, you must specify this parameter.
	//
	// This parameter is supported only when the following requirements are met:
	//
	// *   The **PayType** parameter is set to **Postpaid**.
	// *   The **Engine** parameter is set to **MySQL**.
	// *   The **EngineVersion** parameter is set to **5.7**.
	// *   The **Category** parameter is set to **Basic**.
	UserBackupId *string `json:"UserBackupId,omitempty" xml:"UserBackupId,omitempty"`
	// The ID of the VPC to which the instance belongs.
	//
	// > : This parameter is available when you set the **InstanceNetworkType** parameter to **VPC**.
	VPCId *string `json:"VPCId,omitempty" xml:"VPCId,omitempty"`
	// The ID of the vSwitch. The vSwitch must belong to the zone that is specified by **ZoneId**.
	//
	// *   If you set **InstanceNetworkType** to **VPC**, you must also specify this parameter.
	// *   If you specify the ZoneSlaveId1 parameter, you must specify the IDs of two vSwitches for this parameter and separate the IDs with a comma (,).
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
	// The zone ID of the primary instance.
	//
	// *   If you specify a virtual private cloud (VPC) and a vSwitch, you must specify the ID of the zone to which the specified vSwitch belongs. Otherwise, the instance cannot be created.
	// *   If the instance runs RDS High-availability Edition, you must specify the **ZoneIdSlave1** parameter. The ZoneIdSlave1 parameter specifies whether to use the single-zone deployment method or the multi-zone deployment method.
	// *   If the instance runs RDS Enterprise Edition, you must specify the **ZoneIdSlave1** and **ZoneIdSlave2** parameters. The ZoneIdSlave1 and ZoneIdSlave2 parameters specify whether to use the single-zone deployment method or the multi-zone deployment method.
	// *   If the instance runs MySQL on RDS Cluster Edition, you must specify the **ZoneIdSlave1** parameter for the RDS cluster that has two nodes and the **ZoneIdSlave1** and **ZoneIdSlave2** parameters for the RDS cluster that has three nodes.
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
	// The zone ID of the secondary instance.
	//
	// *   If you set this parameter to **Auto**, the multi-zone deployment method is used and the zone of the secondary instance is automatically configured.
	// *   If you set this parameter to the same value as the **ZoneId** parameter, the single-zone deployment method is used.
	// *   If you set this parameter to a value that is different from the value of the **ZoneId** parameter, the multiple-zone deployment method is used.
	ZoneIdSlave1 *string `json:"ZoneIdSlave1,omitempty" xml:"ZoneIdSlave1,omitempty"`
	// This parameter is deprecated.
	ZoneIdSlave2 *string `json:"ZoneIdSlave2,omitempty" xml:"ZoneIdSlave2,omitempty"`
}

func (s CreateDBInstanceShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateDBInstanceShrinkRequest) GoString() string {
	return s.String()
}

func (s *CreateDBInstanceShrinkRequest) SetAmount(v int32) *CreateDBInstanceShrinkRequest {
	s.Amount = &v
	return s
}

func (s *CreateDBInstanceShrinkRequest) SetAutoPay(v bool) *CreateDBInstanceShrinkRequest {
	s.AutoPay = &v
	return s
}

func (s *CreateDBInstanceShrinkRequest) SetAutoRenew(v string) *CreateDBInstanceShrinkRequest {
	s.AutoRenew = &v
	return s
}

func (s *CreateDBInstanceShrinkRequest) SetBabelfishConfig(v string) *CreateDBInstanceShrinkRequest {
	s.BabelfishConfig = &v
	return s
}

func (s *CreateDBInstanceShrinkRequest) SetBpeEnabled(v string) *CreateDBInstanceShrinkRequest {
	s.BpeEnabled = &v
	return s
}

func (s *CreateDBInstanceShrinkRequest) SetBurstingEnabled(v bool) *CreateDBInstanceShrinkRequest {
	s.BurstingEnabled = &v
	return s
}

func (s *CreateDBInstanceShrinkRequest) SetBusinessInfo(v string) *CreateDBInstanceShrinkRequest {
	s.BusinessInfo = &v
	return s
}

func (s *CreateDBInstanceShrinkRequest) SetCategory(v string) *CreateDBInstanceShrinkRequest {
	s.Category = &v
	return s
}

func (s *CreateDBInstanceShrinkRequest) SetClientToken(v string) *CreateDBInstanceShrinkRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateDBInstanceShrinkRequest) SetConnectionMode(v string) *CreateDBInstanceShrinkRequest {
	s.ConnectionMode = &v
	return s
}

func (s *CreateDBInstanceShrinkRequest) SetConnectionString(v string) *CreateDBInstanceShrinkRequest {
	s.ConnectionString = &v
	return s
}

func (s *CreateDBInstanceShrinkRequest) SetCreateStrategy(v string) *CreateDBInstanceShrinkRequest {
	s.CreateStrategy = &v
	return s
}

func (s *CreateDBInstanceShrinkRequest) SetDBInstanceClass(v string) *CreateDBInstanceShrinkRequest {
	s.DBInstanceClass = &v
	return s
}

func (s *CreateDBInstanceShrinkRequest) SetDBInstanceDescription(v string) *CreateDBInstanceShrinkRequest {
	s.DBInstanceDescription = &v
	return s
}

func (s *CreateDBInstanceShrinkRequest) SetDBInstanceNetType(v string) *CreateDBInstanceShrinkRequest {
	s.DBInstanceNetType = &v
	return s
}

func (s *CreateDBInstanceShrinkRequest) SetDBInstanceStorage(v int32) *CreateDBInstanceShrinkRequest {
	s.DBInstanceStorage = &v
	return s
}

func (s *CreateDBInstanceShrinkRequest) SetDBInstanceStorageType(v string) *CreateDBInstanceShrinkRequest {
	s.DBInstanceStorageType = &v
	return s
}

func (s *CreateDBInstanceShrinkRequest) SetDBIsIgnoreCase(v string) *CreateDBInstanceShrinkRequest {
	s.DBIsIgnoreCase = &v
	return s
}

func (s *CreateDBInstanceShrinkRequest) SetDBParamGroupId(v string) *CreateDBInstanceShrinkRequest {
	s.DBParamGroupId = &v
	return s
}

func (s *CreateDBInstanceShrinkRequest) SetDBTimeZone(v string) *CreateDBInstanceShrinkRequest {
	s.DBTimeZone = &v
	return s
}

func (s *CreateDBInstanceShrinkRequest) SetDedicatedHostGroupId(v string) *CreateDBInstanceShrinkRequest {
	s.DedicatedHostGroupId = &v
	return s
}

func (s *CreateDBInstanceShrinkRequest) SetDeletionProtection(v bool) *CreateDBInstanceShrinkRequest {
	s.DeletionProtection = &v
	return s
}

func (s *CreateDBInstanceShrinkRequest) SetDryRun(v bool) *CreateDBInstanceShrinkRequest {
	s.DryRun = &v
	return s
}

func (s *CreateDBInstanceShrinkRequest) SetEncryptionKey(v string) *CreateDBInstanceShrinkRequest {
	s.EncryptionKey = &v
	return s
}

func (s *CreateDBInstanceShrinkRequest) SetEngine(v string) *CreateDBInstanceShrinkRequest {
	s.Engine = &v
	return s
}

func (s *CreateDBInstanceShrinkRequest) SetEngineVersion(v string) *CreateDBInstanceShrinkRequest {
	s.EngineVersion = &v
	return s
}

func (s *CreateDBInstanceShrinkRequest) SetInstanceNetworkType(v string) *CreateDBInstanceShrinkRequest {
	s.InstanceNetworkType = &v
	return s
}

func (s *CreateDBInstanceShrinkRequest) SetPayType(v string) *CreateDBInstanceShrinkRequest {
	s.PayType = &v
	return s
}

func (s *CreateDBInstanceShrinkRequest) SetPeriod(v string) *CreateDBInstanceShrinkRequest {
	s.Period = &v
	return s
}

func (s *CreateDBInstanceShrinkRequest) SetPort(v string) *CreateDBInstanceShrinkRequest {
	s.Port = &v
	return s
}

func (s *CreateDBInstanceShrinkRequest) SetPrivateIpAddress(v string) *CreateDBInstanceShrinkRequest {
	s.PrivateIpAddress = &v
	return s
}

func (s *CreateDBInstanceShrinkRequest) SetRegionId(v string) *CreateDBInstanceShrinkRequest {
	s.RegionId = &v
	return s
}

func (s *CreateDBInstanceShrinkRequest) SetResourceGroupId(v string) *CreateDBInstanceShrinkRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *CreateDBInstanceShrinkRequest) SetResourceOwnerId(v int64) *CreateDBInstanceShrinkRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreateDBInstanceShrinkRequest) SetRoleARN(v string) *CreateDBInstanceShrinkRequest {
	s.RoleARN = &v
	return s
}

func (s *CreateDBInstanceShrinkRequest) SetSecurityIPList(v string) *CreateDBInstanceShrinkRequest {
	s.SecurityIPList = &v
	return s
}

func (s *CreateDBInstanceShrinkRequest) SetServerlessConfigShrink(v string) *CreateDBInstanceShrinkRequest {
	s.ServerlessConfigShrink = &v
	return s
}

func (s *CreateDBInstanceShrinkRequest) SetStorageAutoScale(v string) *CreateDBInstanceShrinkRequest {
	s.StorageAutoScale = &v
	return s
}

func (s *CreateDBInstanceShrinkRequest) SetStorageThreshold(v int32) *CreateDBInstanceShrinkRequest {
	s.StorageThreshold = &v
	return s
}

func (s *CreateDBInstanceShrinkRequest) SetStorageUpperBound(v int32) *CreateDBInstanceShrinkRequest {
	s.StorageUpperBound = &v
	return s
}

func (s *CreateDBInstanceShrinkRequest) SetSystemDBCharset(v string) *CreateDBInstanceShrinkRequest {
	s.SystemDBCharset = &v
	return s
}

func (s *CreateDBInstanceShrinkRequest) SetTag(v []*CreateDBInstanceShrinkRequestTag) *CreateDBInstanceShrinkRequest {
	s.Tag = v
	return s
}

func (s *CreateDBInstanceShrinkRequest) SetTargetDedicatedHostIdForLog(v string) *CreateDBInstanceShrinkRequest {
	s.TargetDedicatedHostIdForLog = &v
	return s
}

func (s *CreateDBInstanceShrinkRequest) SetTargetDedicatedHostIdForMaster(v string) *CreateDBInstanceShrinkRequest {
	s.TargetDedicatedHostIdForMaster = &v
	return s
}

func (s *CreateDBInstanceShrinkRequest) SetTargetDedicatedHostIdForSlave(v string) *CreateDBInstanceShrinkRequest {
	s.TargetDedicatedHostIdForSlave = &v
	return s
}

func (s *CreateDBInstanceShrinkRequest) SetTargetMinorVersion(v string) *CreateDBInstanceShrinkRequest {
	s.TargetMinorVersion = &v
	return s
}

func (s *CreateDBInstanceShrinkRequest) SetUsedTime(v string) *CreateDBInstanceShrinkRequest {
	s.UsedTime = &v
	return s
}

func (s *CreateDBInstanceShrinkRequest) SetUserBackupId(v string) *CreateDBInstanceShrinkRequest {
	s.UserBackupId = &v
	return s
}

func (s *CreateDBInstanceShrinkRequest) SetVPCId(v string) *CreateDBInstanceShrinkRequest {
	s.VPCId = &v
	return s
}

func (s *CreateDBInstanceShrinkRequest) SetVSwitchId(v string) *CreateDBInstanceShrinkRequest {
	s.VSwitchId = &v
	return s
}

func (s *CreateDBInstanceShrinkRequest) SetZoneId(v string) *CreateDBInstanceShrinkRequest {
	s.ZoneId = &v
	return s
}

func (s *CreateDBInstanceShrinkRequest) SetZoneIdSlave1(v string) *CreateDBInstanceShrinkRequest {
	s.ZoneIdSlave1 = &v
	return s
}

func (s *CreateDBInstanceShrinkRequest) SetZoneIdSlave2(v string) *CreateDBInstanceShrinkRequest {
	s.ZoneIdSlave2 = &v
	return s
}

type CreateDBInstanceShrinkRequestTag struct {
	// The key of the tag that you want to add to the instance. You can use this parameter to add tags to the instance.
	//
	// *   If the specified tag key is an existing key, the system directly adds the tag key to the instance. You can call the [ListTagResources](~~610627~~) operation to query the details of the existing tags.
	// *   If the specified tag key is not an existing key, the system creates the tag key and adds the tag key to the instance.
	// *   A tag key cannot be an empty string.
	// *   This parameter must be used together with the **Tag.Value** parameter.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value that is associated with the specified tag key. You can use this parameter to add tags to the instance.
	//
	// *   If the specified tag value is found in the specified tag key, the system directly adds the tag value to the instance. You can call the [ListTagResources](~~610627~~) operation to query the details of the existing tags.
	// *   If the specified tag value is not found in the specified tag key, the system creates the tag value and adds the tag value to the instance.
	// *   This parameter must be used together with the **Tag.Key** parameter.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateDBInstanceShrinkRequestTag) String() string {
	return tea.Prettify(s)
}

func (s CreateDBInstanceShrinkRequestTag) GoString() string {
	return s.String()
}

func (s *CreateDBInstanceShrinkRequestTag) SetKey(v string) *CreateDBInstanceShrinkRequestTag {
	s.Key = &v
	return s
}

func (s *CreateDBInstanceShrinkRequestTag) SetValue(v string) *CreateDBInstanceShrinkRequestTag {
	s.Value = &v
	return s
}

type CreateDBInstanceResponseBody struct {
	// The internal endpoint of the instance.
	ConnectionString *string `json:"ConnectionString,omitempty" xml:"ConnectionString,omitempty"`
	// The instance ID. If the value of the **Amount** parameter is greater than **1**, more than one instance ID is returned. The number of instance IDs that are returned is the same as the value of the Amount parameter. The returned instance IDs are separated by commas (,).
	//
	// For example, if the value of the **Amount** parameter is **3**, three instance IDs are returned. Examples: `rm-uf6wjk5*****1,rm-uf6wjk5*****2,rm-uf6wjk5*****3`
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// Indicates that the system performed a dry run.
	//
	// *   The value is fixed as **true**.
	// *   If the system does not perform a dry run, this parameter is not returned.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// Indicates whether the request passed the dry run. Valid values:
	//
	// *   **true**
	// *   **false**
	//
	// > *   If the system does not perform a dry run, this parameter is not returned.
	// > *   If the request failed the dry run, an error message is returned.
	DryRunResult *bool `json:"DryRunResult,omitempty" xml:"DryRunResult,omitempty"`
	// The message that indicates whether multiple instances are created.
	//
	// > The parameter is returned only when the value of the **Amount** parameter is greater than 1.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The order ID.
	OrderId *string `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The internal IP address and port number that are used to connect to the instance.
	Port *string `json:"Port,omitempty" xml:"Port,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the specified tag is added to the instance. Valid values:
	//
	// *   **true**: The specified tag is added to the instance.
	// *   **false**: The specified tag fails to be added to the instance.
	//
	// > If you do not add a tag to the instance, this parameter is not returned.
	TagResult *bool `json:"TagResult,omitempty" xml:"TagResult,omitempty"`
	// The ID of the task that is run to create multiple instances.
	//
	// *   This parameter is returned only when the value of **Amount** is greater than 1.
	// *   The **TaskID** parameter cannot be used to query a task.
	TaskId *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
}

func (s CreateDBInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateDBInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *CreateDBInstanceResponseBody) SetConnectionString(v string) *CreateDBInstanceResponseBody {
	s.ConnectionString = &v
	return s
}

func (s *CreateDBInstanceResponseBody) SetDBInstanceId(v string) *CreateDBInstanceResponseBody {
	s.DBInstanceId = &v
	return s
}

func (s *CreateDBInstanceResponseBody) SetDryRun(v bool) *CreateDBInstanceResponseBody {
	s.DryRun = &v
	return s
}

func (s *CreateDBInstanceResponseBody) SetDryRunResult(v bool) *CreateDBInstanceResponseBody {
	s.DryRunResult = &v
	return s
}

func (s *CreateDBInstanceResponseBody) SetMessage(v string) *CreateDBInstanceResponseBody {
	s.Message = &v
	return s
}

func (s *CreateDBInstanceResponseBody) SetOrderId(v string) *CreateDBInstanceResponseBody {
	s.OrderId = &v
	return s
}

func (s *CreateDBInstanceResponseBody) SetPort(v string) *CreateDBInstanceResponseBody {
	s.Port = &v
	return s
}

func (s *CreateDBInstanceResponseBody) SetRequestId(v string) *CreateDBInstanceResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateDBInstanceResponseBody) SetTagResult(v bool) *CreateDBInstanceResponseBody {
	s.TagResult = &v
	return s
}

func (s *CreateDBInstanceResponseBody) SetTaskId(v string) *CreateDBInstanceResponseBody {
	s.TaskId = &v
	return s
}

type CreateDBInstanceResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateDBInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateDBInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateDBInstanceResponse) GoString() string {
	return s.String()
}

func (s *CreateDBInstanceResponse) SetHeaders(v map[string]*string) *CreateDBInstanceResponse {
	s.Headers = v
	return s
}

func (s *CreateDBInstanceResponse) SetStatusCode(v int32) *CreateDBInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateDBInstanceResponse) SetBody(v *CreateDBInstanceResponseBody) *CreateDBInstanceResponse {
	s.Body = v
	return s
}

type CreateDBInstanceEndpointRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests.
	//
	// The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The prefix of the internal endpoint.
	//
	// When you create any type of endpoint, an internal endpoint is automatically created for the endpoint. This parameter specifies the prefix of the internal endpoint.
	ConnectionStringPrefix *string `json:"ConnectionStringPrefix,omitempty" xml:"ConnectionStringPrefix,omitempty"`
	// The user-defined description of the endpoint.
	DBInstanceEndpointDescription *string `json:"DBInstanceEndpointDescription,omitempty" xml:"DBInstanceEndpointDescription,omitempty"`
	// The type of the endpoint. Valid values:
	//
	// *   Primary: read/write endpoint of the instance
	// *   Readonly: read-only endpoint of the instance
	DBInstanceEndpointType *string `json:"DBInstanceEndpointType,omitempty" xml:"DBInstanceEndpointType,omitempty"`
	// The instance ID. You can call the [DescribeDBInstances](~~610396~~) operation to query the ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The information about the node that is configured for the endpoint.
	NodeItems []*CreateDBInstanceEndpointRequestNodeItems `json:"NodeItems,omitempty" xml:"NodeItems,omitempty" type:"Repeated"`
	// The port number of the internal endpoint. You can specify the port number for the internal endpoint.
	//
	// Valid values: 3000 to 5999.
	Port *string `json:"Port,omitempty" xml:"Port,omitempty"`
	// The IP address of the internal endpoint.
	PrivateIpAddress *string `json:"PrivateIpAddress,omitempty" xml:"PrivateIpAddress,omitempty"`
	// The ID of the resource group. You can call the [DescribeDBInstanceAttribute](~~610394~~) to obtain the ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerId *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The vSwitch ID of the internal endpoint.
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
	// The virtual private cloud (VPC) ID of the internal endpoint.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s CreateDBInstanceEndpointRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateDBInstanceEndpointRequest) GoString() string {
	return s.String()
}

func (s *CreateDBInstanceEndpointRequest) SetClientToken(v string) *CreateDBInstanceEndpointRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateDBInstanceEndpointRequest) SetConnectionStringPrefix(v string) *CreateDBInstanceEndpointRequest {
	s.ConnectionStringPrefix = &v
	return s
}

func (s *CreateDBInstanceEndpointRequest) SetDBInstanceEndpointDescription(v string) *CreateDBInstanceEndpointRequest {
	s.DBInstanceEndpointDescription = &v
	return s
}

func (s *CreateDBInstanceEndpointRequest) SetDBInstanceEndpointType(v string) *CreateDBInstanceEndpointRequest {
	s.DBInstanceEndpointType = &v
	return s
}

func (s *CreateDBInstanceEndpointRequest) SetDBInstanceId(v string) *CreateDBInstanceEndpointRequest {
	s.DBInstanceId = &v
	return s
}

func (s *CreateDBInstanceEndpointRequest) SetNodeItems(v []*CreateDBInstanceEndpointRequestNodeItems) *CreateDBInstanceEndpointRequest {
	s.NodeItems = v
	return s
}

func (s *CreateDBInstanceEndpointRequest) SetPort(v string) *CreateDBInstanceEndpointRequest {
	s.Port = &v
	return s
}

func (s *CreateDBInstanceEndpointRequest) SetPrivateIpAddress(v string) *CreateDBInstanceEndpointRequest {
	s.PrivateIpAddress = &v
	return s
}

func (s *CreateDBInstanceEndpointRequest) SetResourceGroupId(v string) *CreateDBInstanceEndpointRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *CreateDBInstanceEndpointRequest) SetResourceOwnerId(v int64) *CreateDBInstanceEndpointRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreateDBInstanceEndpointRequest) SetVSwitchId(v string) *CreateDBInstanceEndpointRequest {
	s.VSwitchId = &v
	return s
}

func (s *CreateDBInstanceEndpointRequest) SetVpcId(v string) *CreateDBInstanceEndpointRequest {
	s.VpcId = &v
	return s
}

type CreateDBInstanceEndpointRequestNodeItems struct {
	// The instance ID. You can call the [DescribeDBInstances](~~610396~~) operation to query the ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The node ID.
	NodeId *string `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	// The weight of the node. Read requests are distributed based on the weight.
	//
	// Valid values: 0 to 100.
	Weight *int64 `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s CreateDBInstanceEndpointRequestNodeItems) String() string {
	return tea.Prettify(s)
}

func (s CreateDBInstanceEndpointRequestNodeItems) GoString() string {
	return s.String()
}

func (s *CreateDBInstanceEndpointRequestNodeItems) SetDBInstanceId(v string) *CreateDBInstanceEndpointRequestNodeItems {
	s.DBInstanceId = &v
	return s
}

func (s *CreateDBInstanceEndpointRequestNodeItems) SetNodeId(v string) *CreateDBInstanceEndpointRequestNodeItems {
	s.NodeId = &v
	return s
}

func (s *CreateDBInstanceEndpointRequestNodeItems) SetWeight(v int64) *CreateDBInstanceEndpointRequestNodeItems {
	s.Weight = &v
	return s
}

type CreateDBInstanceEndpointShrinkRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests.
	//
	// The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The prefix of the internal endpoint.
	//
	// When you create any type of endpoint, an internal endpoint is automatically created for the endpoint. This parameter specifies the prefix of the internal endpoint.
	ConnectionStringPrefix *string `json:"ConnectionStringPrefix,omitempty" xml:"ConnectionStringPrefix,omitempty"`
	// The user-defined description of the endpoint.
	DBInstanceEndpointDescription *string `json:"DBInstanceEndpointDescription,omitempty" xml:"DBInstanceEndpointDescription,omitempty"`
	// The type of the endpoint. Valid values:
	//
	// *   Primary: read/write endpoint of the instance
	// *   Readonly: read-only endpoint of the instance
	DBInstanceEndpointType *string `json:"DBInstanceEndpointType,omitempty" xml:"DBInstanceEndpointType,omitempty"`
	// The instance ID. You can call the [DescribeDBInstances](~~610396~~) operation to query the ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The information about the node that is configured for the endpoint.
	NodeItemsShrink *string `json:"NodeItems,omitempty" xml:"NodeItems,omitempty"`
	// The port number of the internal endpoint. You can specify the port number for the internal endpoint.
	//
	// Valid values: 3000 to 5999.
	Port *string `json:"Port,omitempty" xml:"Port,omitempty"`
	// The IP address of the internal endpoint.
	PrivateIpAddress *string `json:"PrivateIpAddress,omitempty" xml:"PrivateIpAddress,omitempty"`
	// The ID of the resource group. You can call the [DescribeDBInstanceAttribute](~~610394~~) to obtain the ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerId *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The vSwitch ID of the internal endpoint.
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
	// The virtual private cloud (VPC) ID of the internal endpoint.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s CreateDBInstanceEndpointShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateDBInstanceEndpointShrinkRequest) GoString() string {
	return s.String()
}

func (s *CreateDBInstanceEndpointShrinkRequest) SetClientToken(v string) *CreateDBInstanceEndpointShrinkRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateDBInstanceEndpointShrinkRequest) SetConnectionStringPrefix(v string) *CreateDBInstanceEndpointShrinkRequest {
	s.ConnectionStringPrefix = &v
	return s
}

func (s *CreateDBInstanceEndpointShrinkRequest) SetDBInstanceEndpointDescription(v string) *CreateDBInstanceEndpointShrinkRequest {
	s.DBInstanceEndpointDescription = &v
	return s
}

func (s *CreateDBInstanceEndpointShrinkRequest) SetDBInstanceEndpointType(v string) *CreateDBInstanceEndpointShrinkRequest {
	s.DBInstanceEndpointType = &v
	return s
}

func (s *CreateDBInstanceEndpointShrinkRequest) SetDBInstanceId(v string) *CreateDBInstanceEndpointShrinkRequest {
	s.DBInstanceId = &v
	return s
}

func (s *CreateDBInstanceEndpointShrinkRequest) SetNodeItemsShrink(v string) *CreateDBInstanceEndpointShrinkRequest {
	s.NodeItemsShrink = &v
	return s
}

func (s *CreateDBInstanceEndpointShrinkRequest) SetPort(v string) *CreateDBInstanceEndpointShrinkRequest {
	s.Port = &v
	return s
}

func (s *CreateDBInstanceEndpointShrinkRequest) SetPrivateIpAddress(v string) *CreateDBInstanceEndpointShrinkRequest {
	s.PrivateIpAddress = &v
	return s
}

func (s *CreateDBInstanceEndpointShrinkRequest) SetResourceGroupId(v string) *CreateDBInstanceEndpointShrinkRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *CreateDBInstanceEndpointShrinkRequest) SetResourceOwnerId(v int64) *CreateDBInstanceEndpointShrinkRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreateDBInstanceEndpointShrinkRequest) SetVSwitchId(v string) *CreateDBInstanceEndpointShrinkRequest {
	s.VSwitchId = &v
	return s
}

func (s *CreateDBInstanceEndpointShrinkRequest) SetVpcId(v string) *CreateDBInstanceEndpointShrinkRequest {
	s.VpcId = &v
	return s
}

type CreateDBInstanceEndpointResponseBody struct {
	// The data returned.
	Data *CreateDBInstanceEndpointResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateDBInstanceEndpointResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateDBInstanceEndpointResponseBody) GoString() string {
	return s.String()
}

func (s *CreateDBInstanceEndpointResponseBody) SetData(v *CreateDBInstanceEndpointResponseBodyData) *CreateDBInstanceEndpointResponseBody {
	s.Data = v
	return s
}

func (s *CreateDBInstanceEndpointResponseBody) SetRequestId(v string) *CreateDBInstanceEndpointResponseBody {
	s.RequestId = &v
	return s
}

type CreateDBInstanceEndpointResponseBodyData struct {
	// The internal endpoint.
	ConnectionString *string `json:"ConnectionString,omitempty" xml:"ConnectionString,omitempty"`
	// The endpoint ID of the instance.
	DBInstanceEndpointId *string `json:"DBInstanceEndpointId,omitempty" xml:"DBInstanceEndpointId,omitempty"`
	// The ID of the instance.
	DBInstanceName *string `json:"DBInstanceName,omitempty" xml:"DBInstanceName,omitempty"`
}

func (s CreateDBInstanceEndpointResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s CreateDBInstanceEndpointResponseBodyData) GoString() string {
	return s.String()
}

func (s *CreateDBInstanceEndpointResponseBodyData) SetConnectionString(v string) *CreateDBInstanceEndpointResponseBodyData {
	s.ConnectionString = &v
	return s
}

func (s *CreateDBInstanceEndpointResponseBodyData) SetDBInstanceEndpointId(v string) *CreateDBInstanceEndpointResponseBodyData {
	s.DBInstanceEndpointId = &v
	return s
}

func (s *CreateDBInstanceEndpointResponseBodyData) SetDBInstanceName(v string) *CreateDBInstanceEndpointResponseBodyData {
	s.DBInstanceName = &v
	return s
}

type CreateDBInstanceEndpointResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateDBInstanceEndpointResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateDBInstanceEndpointResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateDBInstanceEndpointResponse) GoString() string {
	return s.String()
}

func (s *CreateDBInstanceEndpointResponse) SetHeaders(v map[string]*string) *CreateDBInstanceEndpointResponse {
	s.Headers = v
	return s
}

func (s *CreateDBInstanceEndpointResponse) SetStatusCode(v int32) *CreateDBInstanceEndpointResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateDBInstanceEndpointResponse) SetBody(v *CreateDBInstanceEndpointResponseBody) *CreateDBInstanceEndpointResponse {
	s.Body = v
	return s
}

type CreateDBInstanceEndpointAddressRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests.
	//
	// The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The prefix of the public endpoint.
	ConnectionStringPrefix *string `json:"ConnectionStringPrefix,omitempty" xml:"ConnectionStringPrefix,omitempty"`
	// The endpoint ID of the instance. You can call the [DescribeDBInstanceEndpoints](~~610488~~) operation to query the endpoint ID of the instance.
	DBInstanceEndpointId *string `json:"DBInstanceEndpointId,omitempty" xml:"DBInstanceEndpointId,omitempty"`
	// The instance ID. You can call the [DescribeDBInstances](~~610396~~) operation to query the ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The network type of the endpoint. Only Internet is supported. Set the value to **Public**.
	IpType *string `json:"IpType,omitempty" xml:"IpType,omitempty"`
	// The port number of the public endpoint.
	Port *string `json:"Port,omitempty" xml:"Port,omitempty"`
	// The ID of the resource group. You can call the [DescribeDBInstanceAttribute](~~610394~~) to obtain the ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerId *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s CreateDBInstanceEndpointAddressRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateDBInstanceEndpointAddressRequest) GoString() string {
	return s.String()
}

func (s *CreateDBInstanceEndpointAddressRequest) SetClientToken(v string) *CreateDBInstanceEndpointAddressRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateDBInstanceEndpointAddressRequest) SetConnectionStringPrefix(v string) *CreateDBInstanceEndpointAddressRequest {
	s.ConnectionStringPrefix = &v
	return s
}

func (s *CreateDBInstanceEndpointAddressRequest) SetDBInstanceEndpointId(v string) *CreateDBInstanceEndpointAddressRequest {
	s.DBInstanceEndpointId = &v
	return s
}

func (s *CreateDBInstanceEndpointAddressRequest) SetDBInstanceId(v string) *CreateDBInstanceEndpointAddressRequest {
	s.DBInstanceId = &v
	return s
}

func (s *CreateDBInstanceEndpointAddressRequest) SetIpType(v string) *CreateDBInstanceEndpointAddressRequest {
	s.IpType = &v
	return s
}

func (s *CreateDBInstanceEndpointAddressRequest) SetPort(v string) *CreateDBInstanceEndpointAddressRequest {
	s.Port = &v
	return s
}

func (s *CreateDBInstanceEndpointAddressRequest) SetResourceGroupId(v string) *CreateDBInstanceEndpointAddressRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *CreateDBInstanceEndpointAddressRequest) SetResourceOwnerId(v int64) *CreateDBInstanceEndpointAddressRequest {
	s.ResourceOwnerId = &v
	return s
}

type CreateDBInstanceEndpointAddressResponseBody struct {
	// The data returned.
	Data *CreateDBInstanceEndpointAddressResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateDBInstanceEndpointAddressResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateDBInstanceEndpointAddressResponseBody) GoString() string {
	return s.String()
}

func (s *CreateDBInstanceEndpointAddressResponseBody) SetData(v *CreateDBInstanceEndpointAddressResponseBodyData) *CreateDBInstanceEndpointAddressResponseBody {
	s.Data = v
	return s
}

func (s *CreateDBInstanceEndpointAddressResponseBody) SetRequestId(v string) *CreateDBInstanceEndpointAddressResponseBody {
	s.RequestId = &v
	return s
}

type CreateDBInstanceEndpointAddressResponseBodyData struct {
	// The public endpoint.
	ConnectionString *string `json:"ConnectionString,omitempty" xml:"ConnectionString,omitempty"`
	// The endpoint ID of the instance.
	DBInstanceEndpointId *string `json:"DBInstanceEndpointId,omitempty" xml:"DBInstanceEndpointId,omitempty"`
	// The ID of the instance.
	DBInstanceName *string `json:"DBInstanceName,omitempty" xml:"DBInstanceName,omitempty"`
}

func (s CreateDBInstanceEndpointAddressResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s CreateDBInstanceEndpointAddressResponseBodyData) GoString() string {
	return s.String()
}

func (s *CreateDBInstanceEndpointAddressResponseBodyData) SetConnectionString(v string) *CreateDBInstanceEndpointAddressResponseBodyData {
	s.ConnectionString = &v
	return s
}

func (s *CreateDBInstanceEndpointAddressResponseBodyData) SetDBInstanceEndpointId(v string) *CreateDBInstanceEndpointAddressResponseBodyData {
	s.DBInstanceEndpointId = &v
	return s
}

func (s *CreateDBInstanceEndpointAddressResponseBodyData) SetDBInstanceName(v string) *CreateDBInstanceEndpointAddressResponseBodyData {
	s.DBInstanceName = &v
	return s
}

type CreateDBInstanceEndpointAddressResponse struct {
	Headers    map[string]*string                           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateDBInstanceEndpointAddressResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateDBInstanceEndpointAddressResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateDBInstanceEndpointAddressResponse) GoString() string {
	return s.String()
}

func (s *CreateDBInstanceEndpointAddressResponse) SetHeaders(v map[string]*string) *CreateDBInstanceEndpointAddressResponse {
	s.Headers = v
	return s
}

func (s *CreateDBInstanceEndpointAddressResponse) SetStatusCode(v int32) *CreateDBInstanceEndpointAddressResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateDBInstanceEndpointAddressResponse) SetBody(v *CreateDBInstanceEndpointAddressResponseBody) *CreateDBInstanceEndpointAddressResponse {
	s.Body = v
	return s
}

type CreateDBInstanceForRebuildRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests.
	//
	// The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The name of the instance. The name must be 2 to 256 characters in length. The name can contain letters, digits, underscores (\_), and hyphens (-). The name must start with a letter.
	//
	// > : The name cannot start with http:// or https://.
	DBInstanceDescription *string `json:"DBInstanceDescription,omitempty" xml:"DBInstanceDescription,omitempty"`
	// The instance ID. You can call the [DescribeDBInstances](~~610396~~) operation to query the ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The type of the network connection to the instance. Valid values:
	//
	// *   **Internet**
	// *   **Intranet**
	DBInstanceNetType *string `json:"DBInstanceNetType,omitempty" xml:"DBInstanceNetType,omitempty"`
	// The network type of the instance. Valid values:
	//
	// *   **VPC**
	// *   **Classic**
	//
	// Default value: Classic.
	//
	// >  The **VPCId** and **VSwitchId** parameters must be specified when this parameter is set to **VPC**.
	InstanceNetworkType *string `json:"InstanceNetworkType,omitempty" xml:"InstanceNetworkType,omitempty"`
	OwnerAccount        *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId             *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The billing method of the destination instance. Valid values:
	//
	// *   **Postpaid**: pay-as-you-go
	// *   **Prepaid**: subscription
	PayType *string `json:"PayType,omitempty" xml:"PayType,omitempty"`
	// The unit of the subscription duration. Valid values:
	//
	// *   **Year**
	// *   **Month**
	//
	// >  If you set the PayType parameter to **Prepaid**, you must specify this parameter.
	Period *string `json:"Period,omitempty" xml:"Period,omitempty"`
	// The region ID. You can call the [DescribeRegions](~~610399~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group. The value of this parameter can be NULL.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The IP address whitelist of the serverless instance. For more information, see [Use a database client or the CLI to connect to an ApsaraDB RDS for PostgreSQL instance](~~43185~~). If the IP address whitelist contains more than one entry, separate the entries with commas (,). Each entry must be unique. You can specify up to 1,000 entries. The entries in the IP address whitelist must be in one of the following formats:
	//
	// *   IP addresses, such as 10.10.XX.XX.
	// *   CIDR blocks, such as 10.10.XX.XX/24. In this example, 24 indicates that the prefix of each IP address in the IP address whitelist is 24 bits in length. You can replace 24 with a value within the range of 1 to 32.
	//
	// If this parameter is not specified, the default IP address whitelist is used.
	SecurityIPList *string `json:"SecurityIPList,omitempty" xml:"SecurityIPList,omitempty"`
	SecurityToken  *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
	// The subscription duration of the instance. Valid values:
	//
	// *   If you set **Period** to **Year**, the value of **UsedTime** ranges from **1** to **5**.
	// *   If you set **Period** to **Month**, the value of **UsedTime** ranges from **1** to **11**.
	//
	// > If you set **PayType** to **Prepaid**, you must specify this parameter.
	UsedTime *string `json:"UsedTime,omitempty" xml:"UsedTime,omitempty"`
	// The VPC ID of the instance. If you set **InstanceNetworkType** to **VPC**, you must specify this parameter.
	//
	// > : If you specify this parameter, you must also specify **ZoneId**.
	VPCId *string `json:"VPCId,omitempty" xml:"VPCId,omitempty"`
	// The ID of the vSwitch. The vSwitch must belong to the zone that is specified by **ZoneId**.
	//
	// >
	//
	// *   If you set **InstanceNetworkType** to **VPC**, you must also specify this parameter.
	//
	// *   If you specify the ZoneSlaveId1 parameter, you must specify the IDs of two vSwitches for this parameter and separate the IDs with a comma (,).
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
	// The zone ID of the primary instance. You can call the [DescribeRegions](~~26243~~) operation to query the most recent zone list.
	//
	// > If you specify a virtual private cloud (VPC) and a vSwitch, you must specify this parameter to identify the zone for the vSwitch.
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
	// The zone ID of the secondary instance.
	//
	// >  If the instance does not run RDS Basic Edition, you must specify this parameter.
	ZoneIdSlave1 *string `json:"ZoneIdSlave1,omitempty" xml:"ZoneIdSlave1,omitempty"`
	// The zone ID of the logger instance.
	//
	// >  This parameter is available only when the instance runs RDS Enterprise Edition.
	ZoneIdSlave2 *string `json:"ZoneIdSlave2,omitempty" xml:"ZoneIdSlave2,omitempty"`
}

func (s CreateDBInstanceForRebuildRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateDBInstanceForRebuildRequest) GoString() string {
	return s.String()
}

func (s *CreateDBInstanceForRebuildRequest) SetClientToken(v string) *CreateDBInstanceForRebuildRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateDBInstanceForRebuildRequest) SetDBInstanceDescription(v string) *CreateDBInstanceForRebuildRequest {
	s.DBInstanceDescription = &v
	return s
}

func (s *CreateDBInstanceForRebuildRequest) SetDBInstanceId(v string) *CreateDBInstanceForRebuildRequest {
	s.DBInstanceId = &v
	return s
}

func (s *CreateDBInstanceForRebuildRequest) SetDBInstanceNetType(v string) *CreateDBInstanceForRebuildRequest {
	s.DBInstanceNetType = &v
	return s
}

func (s *CreateDBInstanceForRebuildRequest) SetInstanceNetworkType(v string) *CreateDBInstanceForRebuildRequest {
	s.InstanceNetworkType = &v
	return s
}

func (s *CreateDBInstanceForRebuildRequest) SetOwnerAccount(v string) *CreateDBInstanceForRebuildRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateDBInstanceForRebuildRequest) SetOwnerId(v int64) *CreateDBInstanceForRebuildRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateDBInstanceForRebuildRequest) SetPayType(v string) *CreateDBInstanceForRebuildRequest {
	s.PayType = &v
	return s
}

func (s *CreateDBInstanceForRebuildRequest) SetPeriod(v string) *CreateDBInstanceForRebuildRequest {
	s.Period = &v
	return s
}

func (s *CreateDBInstanceForRebuildRequest) SetRegionId(v string) *CreateDBInstanceForRebuildRequest {
	s.RegionId = &v
	return s
}

func (s *CreateDBInstanceForRebuildRequest) SetResourceGroupId(v string) *CreateDBInstanceForRebuildRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *CreateDBInstanceForRebuildRequest) SetResourceOwnerAccount(v string) *CreateDBInstanceForRebuildRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateDBInstanceForRebuildRequest) SetResourceOwnerId(v int64) *CreateDBInstanceForRebuildRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreateDBInstanceForRebuildRequest) SetSecurityIPList(v string) *CreateDBInstanceForRebuildRequest {
	s.SecurityIPList = &v
	return s
}

func (s *CreateDBInstanceForRebuildRequest) SetSecurityToken(v string) *CreateDBInstanceForRebuildRequest {
	s.SecurityToken = &v
	return s
}

func (s *CreateDBInstanceForRebuildRequest) SetUsedTime(v string) *CreateDBInstanceForRebuildRequest {
	s.UsedTime = &v
	return s
}

func (s *CreateDBInstanceForRebuildRequest) SetVPCId(v string) *CreateDBInstanceForRebuildRequest {
	s.VPCId = &v
	return s
}

func (s *CreateDBInstanceForRebuildRequest) SetVSwitchId(v string) *CreateDBInstanceForRebuildRequest {
	s.VSwitchId = &v
	return s
}

func (s *CreateDBInstanceForRebuildRequest) SetZoneId(v string) *CreateDBInstanceForRebuildRequest {
	s.ZoneId = &v
	return s
}

func (s *CreateDBInstanceForRebuildRequest) SetZoneIdSlave1(v string) *CreateDBInstanceForRebuildRequest {
	s.ZoneIdSlave1 = &v
	return s
}

func (s *CreateDBInstanceForRebuildRequest) SetZoneIdSlave2(v string) *CreateDBInstanceForRebuildRequest {
	s.ZoneIdSlave2 = &v
	return s
}

type CreateDBInstanceForRebuildResponseBody struct {
	// The instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The response parameters.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the order.
	OrderId *string `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the task.
	TaskId *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
}

func (s CreateDBInstanceForRebuildResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateDBInstanceForRebuildResponseBody) GoString() string {
	return s.String()
}

func (s *CreateDBInstanceForRebuildResponseBody) SetDBInstanceId(v string) *CreateDBInstanceForRebuildResponseBody {
	s.DBInstanceId = &v
	return s
}

func (s *CreateDBInstanceForRebuildResponseBody) SetMessage(v string) *CreateDBInstanceForRebuildResponseBody {
	s.Message = &v
	return s
}

func (s *CreateDBInstanceForRebuildResponseBody) SetOrderId(v string) *CreateDBInstanceForRebuildResponseBody {
	s.OrderId = &v
	return s
}

func (s *CreateDBInstanceForRebuildResponseBody) SetRequestId(v string) *CreateDBInstanceForRebuildResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateDBInstanceForRebuildResponseBody) SetTaskId(v string) *CreateDBInstanceForRebuildResponseBody {
	s.TaskId = &v
	return s
}

type CreateDBInstanceForRebuildResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateDBInstanceForRebuildResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateDBInstanceForRebuildResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateDBInstanceForRebuildResponse) GoString() string {
	return s.String()
}

func (s *CreateDBInstanceForRebuildResponse) SetHeaders(v map[string]*string) *CreateDBInstanceForRebuildResponse {
	s.Headers = v
	return s
}

func (s *CreateDBInstanceForRebuildResponse) SetStatusCode(v int32) *CreateDBInstanceForRebuildResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateDBInstanceForRebuildResponse) SetBody(v *CreateDBInstanceForRebuildResponseBody) *CreateDBInstanceForRebuildResponse {
	s.Body = v
	return s
}

type CreateDBNodesRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests.
	//
	// The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The instance ID. You can call the [DescribeDBInstances](~~610396~~) operation to query the instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// An array that consists of the details of the node.
	DBNode       []*CreateDBNodesRequestDBNode `json:"DBNode,omitempty" xml:"DBNode,omitempty" type:"Repeated"`
	OwnerAccount *string                       `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64                        `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the resource group. You can call the [DescribeDBInstanceAttribute](~~26231~~) operation to obtain the ID of the resource group.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s CreateDBNodesRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateDBNodesRequest) GoString() string {
	return s.String()
}

func (s *CreateDBNodesRequest) SetClientToken(v string) *CreateDBNodesRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateDBNodesRequest) SetDBInstanceId(v string) *CreateDBNodesRequest {
	s.DBInstanceId = &v
	return s
}

func (s *CreateDBNodesRequest) SetDBNode(v []*CreateDBNodesRequestDBNode) *CreateDBNodesRequest {
	s.DBNode = v
	return s
}

func (s *CreateDBNodesRequest) SetOwnerAccount(v string) *CreateDBNodesRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateDBNodesRequest) SetOwnerId(v int64) *CreateDBNodesRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateDBNodesRequest) SetResourceGroupId(v string) *CreateDBNodesRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *CreateDBNodesRequest) SetResourceOwnerAccount(v string) *CreateDBNodesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateDBNodesRequest) SetResourceOwnerId(v int64) *CreateDBNodesRequest {
	s.ResourceOwnerId = &v
	return s
}

type CreateDBNodesRequestDBNode struct {
	// The specification information of the node.
	ClassCode *string `json:"classCode,omitempty" xml:"classCode,omitempty"`
	// The zone ID of the node.
	ZoneId *string `json:"zoneId,omitempty" xml:"zoneId,omitempty"`
}

func (s CreateDBNodesRequestDBNode) String() string {
	return tea.Prettify(s)
}

func (s CreateDBNodesRequestDBNode) GoString() string {
	return s.String()
}

func (s *CreateDBNodesRequestDBNode) SetClassCode(v string) *CreateDBNodesRequestDBNode {
	s.ClassCode = &v
	return s
}

func (s *CreateDBNodesRequestDBNode) SetZoneId(v string) *CreateDBNodesRequestDBNode {
	s.ZoneId = &v
	return s
}

type CreateDBNodesShrinkRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests.
	//
	// The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The instance ID. You can call the [DescribeDBInstances](~~610396~~) operation to query the instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// An array that consists of the details of the node.
	DBNodeShrink *string `json:"DBNode,omitempty" xml:"DBNode,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the resource group. You can call the [DescribeDBInstanceAttribute](~~26231~~) operation to obtain the ID of the resource group.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s CreateDBNodesShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateDBNodesShrinkRequest) GoString() string {
	return s.String()
}

func (s *CreateDBNodesShrinkRequest) SetClientToken(v string) *CreateDBNodesShrinkRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateDBNodesShrinkRequest) SetDBInstanceId(v string) *CreateDBNodesShrinkRequest {
	s.DBInstanceId = &v
	return s
}

func (s *CreateDBNodesShrinkRequest) SetDBNodeShrink(v string) *CreateDBNodesShrinkRequest {
	s.DBNodeShrink = &v
	return s
}

func (s *CreateDBNodesShrinkRequest) SetOwnerAccount(v string) *CreateDBNodesShrinkRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateDBNodesShrinkRequest) SetOwnerId(v int64) *CreateDBNodesShrinkRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateDBNodesShrinkRequest) SetResourceGroupId(v string) *CreateDBNodesShrinkRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *CreateDBNodesShrinkRequest) SetResourceOwnerAccount(v string) *CreateDBNodesShrinkRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateDBNodesShrinkRequest) SetResourceOwnerId(v int64) *CreateDBNodesShrinkRequest {
	s.ResourceOwnerId = &v
	return s
}

type CreateDBNodesResponseBody struct {
	// The ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The ID of the created node. The value is a string. Multiple values are separated by commas (`,`).
	NodeIds *string `json:"NodeIds,omitempty" xml:"NodeIds,omitempty"`
	// The ID of the order.
	OrderId *int64 `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateDBNodesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateDBNodesResponseBody) GoString() string {
	return s.String()
}

func (s *CreateDBNodesResponseBody) SetDBInstanceId(v string) *CreateDBNodesResponseBody {
	s.DBInstanceId = &v
	return s
}

func (s *CreateDBNodesResponseBody) SetNodeIds(v string) *CreateDBNodesResponseBody {
	s.NodeIds = &v
	return s
}

func (s *CreateDBNodesResponseBody) SetOrderId(v int64) *CreateDBNodesResponseBody {
	s.OrderId = &v
	return s
}

func (s *CreateDBNodesResponseBody) SetRequestId(v string) *CreateDBNodesResponseBody {
	s.RequestId = &v
	return s
}

type CreateDBNodesResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateDBNodesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateDBNodesResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateDBNodesResponse) GoString() string {
	return s.String()
}

func (s *CreateDBNodesResponse) SetHeaders(v map[string]*string) *CreateDBNodesResponse {
	s.Headers = v
	return s
}

func (s *CreateDBNodesResponse) SetStatusCode(v int32) *CreateDBNodesResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateDBNodesResponse) SetBody(v *CreateDBNodesResponseBody) *CreateDBNodesResponse {
	s.Body = v
	return s
}

type CreateDBProxyEndpointAddressRequest struct {
	// The prefix of the proxy endpoint. Enter a custom prefix.
	ConnectionStringPrefix *string `json:"ConnectionStringPrefix,omitempty" xml:"ConnectionStringPrefix,omitempty"`
	// The instance ID. You can call the [DescribeDBInstances](~~610396~~) operation to query the ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The network type of the proxy endpoint. Valid values:
	//
	// *   **Public**: Internet
	// *   **VPC**: Virtual Private Cloud (VPC)
	// *   **Classic**: classic network
	//
	// Default value: **Classic**
	DBProxyConnectStringNetType *string `json:"DBProxyConnectStringNetType,omitempty" xml:"DBProxyConnectStringNetType,omitempty"`
	// The ID of the proxy endpoint. You can call the [DescribeDBProxyEndpoint](~~610507~~) operation to query the ID of the proxy endpoint.
	DBProxyEndpointId *string `json:"DBProxyEndpointId,omitempty" xml:"DBProxyEndpointId,omitempty"`
	// A reserved parameter. You do not need to specify this parameter.
	DBProxyEngineType *string `json:"DBProxyEngineType,omitempty" xml:"DBProxyEngineType,omitempty"`
	// The port number that is associated with the proxy endpoint.
	//
	// *   If the instance runs MySQL, the default value is **3306**.
	// *   If the instance runs PostgreSQL, the default value is **5432**.
	DBProxyNewConnectStringPort *string `json:"DBProxyNewConnectStringPort,omitempty" xml:"DBProxyNewConnectStringPort,omitempty"`
	// The region ID. You can call the [DescribeRegions](~~610399~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The ID of the VPC to which the proxy endpoint belongs. You can call the [DescribeDBInstanceAttribute](~~610394~~) operation to query the VPC ID of the instance.
	//
	// >  This parameter must be specified when DBProxyConnectStringNetType is set to **VPC**.
	VPCId *string `json:"VPCId,omitempty" xml:"VPCId,omitempty"`
	// The ID of the vSwitch that is associated with the specified VPC. You can call the [DescribeDBInstanceAttribute](~~610394~~) operation to query the vSwitch ID of the instance.
	//
	// >  This parameter must be specified when DBProxyConnectStringNetType is set to **VPC**.
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
}

func (s CreateDBProxyEndpointAddressRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateDBProxyEndpointAddressRequest) GoString() string {
	return s.String()
}

func (s *CreateDBProxyEndpointAddressRequest) SetConnectionStringPrefix(v string) *CreateDBProxyEndpointAddressRequest {
	s.ConnectionStringPrefix = &v
	return s
}

func (s *CreateDBProxyEndpointAddressRequest) SetDBInstanceId(v string) *CreateDBProxyEndpointAddressRequest {
	s.DBInstanceId = &v
	return s
}

func (s *CreateDBProxyEndpointAddressRequest) SetDBProxyConnectStringNetType(v string) *CreateDBProxyEndpointAddressRequest {
	s.DBProxyConnectStringNetType = &v
	return s
}

func (s *CreateDBProxyEndpointAddressRequest) SetDBProxyEndpointId(v string) *CreateDBProxyEndpointAddressRequest {
	s.DBProxyEndpointId = &v
	return s
}

func (s *CreateDBProxyEndpointAddressRequest) SetDBProxyEngineType(v string) *CreateDBProxyEndpointAddressRequest {
	s.DBProxyEngineType = &v
	return s
}

func (s *CreateDBProxyEndpointAddressRequest) SetDBProxyNewConnectStringPort(v string) *CreateDBProxyEndpointAddressRequest {
	s.DBProxyNewConnectStringPort = &v
	return s
}

func (s *CreateDBProxyEndpointAddressRequest) SetRegionId(v string) *CreateDBProxyEndpointAddressRequest {
	s.RegionId = &v
	return s
}

func (s *CreateDBProxyEndpointAddressRequest) SetResourceGroupId(v string) *CreateDBProxyEndpointAddressRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *CreateDBProxyEndpointAddressRequest) SetVPCId(v string) *CreateDBProxyEndpointAddressRequest {
	s.VPCId = &v
	return s
}

func (s *CreateDBProxyEndpointAddressRequest) SetVSwitchId(v string) *CreateDBProxyEndpointAddressRequest {
	s.VSwitchId = &v
	return s
}

type CreateDBProxyEndpointAddressResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateDBProxyEndpointAddressResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateDBProxyEndpointAddressResponseBody) GoString() string {
	return s.String()
}

func (s *CreateDBProxyEndpointAddressResponseBody) SetRequestId(v string) *CreateDBProxyEndpointAddressResponseBody {
	s.RequestId = &v
	return s
}

type CreateDBProxyEndpointAddressResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateDBProxyEndpointAddressResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateDBProxyEndpointAddressResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateDBProxyEndpointAddressResponse) GoString() string {
	return s.String()
}

func (s *CreateDBProxyEndpointAddressResponse) SetHeaders(v map[string]*string) *CreateDBProxyEndpointAddressResponse {
	s.Headers = v
	return s
}

func (s *CreateDBProxyEndpointAddressResponse) SetStatusCode(v int32) *CreateDBProxyEndpointAddressResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateDBProxyEndpointAddressResponse) SetBody(v *CreateDBProxyEndpointAddressResponseBody) *CreateDBProxyEndpointAddressResponse {
	s.Body = v
	return s
}

type CreateDatabaseRequest struct {
	// The character set.
	//
	// *   Valid values for MySQL or MariaDB databases: **utf8, gbk, latin1, and utf8mb4**
	//
	// *   Valid values for SQL Server databases: **Chinese_PRC_CI_AS, Chinese_PRC_CS_AS, SQL_Latin1\_General_CP1\_CI_AS, SQL_Latin1\_General_CP1\_CS_AS, and Chinese_PRC_BIN**
	//
	// *   Valid values for PostgreSQL databases: a value in the `Character set,<Collate>,<Ctype>` format. Example: `UTF8,C,en_US.utf8`.
	//
	//     *   Valid values for the character set: **KOI8U, UTF8, WIN866, WIN874, WIN1250, WIN1251, WIN1252, WIN1253, WIN1254, WIN1255, WIN1256, WIN1257, WIN1258, EUC_CN, EUC_KR, EUC_TW, EUC_JP, EUC_JIS\_2004, KOI8R, MULE_INTERNAL, LATIN1, LATIN2, LATIN3, LATIN4, LATIN5, LATIN6, LATIN7, LATIN8, LATIN9, LATIN10, ISO\_8859\_5, ISO\_8859\_6, ISO\_8859\_7, ISO\_8859\_8, and SQL_ASCII**
	//     *   Valid values for the **Collate** field: You can execute the `SELECT DISTINCT collname FROM pg_collation;` statement to obtain the field value. The default value is **C**.
	//     *   Valid values for the **Ctype** field: You can execute the `SELECT DISTINCT collctype FROM pg_collation;` statement to obtain the field value. The default value is **en_US.utf8**.
	CharacterSetName *string `json:"CharacterSetName,omitempty" xml:"CharacterSetName,omitempty"`
	// The description of the database. The description must be 2 to 256 characters in length and can contain letters, digits, underscores (\_), and hyphens (-). The description must start with a letter.
	//
	// > The value cannot start with `http://` or `https://`.
	DBDescription *string `json:"DBDescription,omitempty" xml:"DBDescription,omitempty"`
	// The instance ID. You can call the [DescribeDBInstances](~~610396~~) operation to query the ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The name of the database.
	//
	// >
	//
	// *   The name must be 2 to 64 characters in length.
	//
	// *   The name must start with a lowercase letter and end with a lowercase letter or digit.
	// *   The name can contain lowercase letters, digits, underscores (\_), and hyphens (-).
	// *   The name must be unique within the instance.
	// *   For more information about invalid characters, see [Forbidden keywords table](~~26317~~).
	DBName       *string `json:"DBName,omitempty" xml:"DBName,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s CreateDatabaseRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateDatabaseRequest) GoString() string {
	return s.String()
}

func (s *CreateDatabaseRequest) SetCharacterSetName(v string) *CreateDatabaseRequest {
	s.CharacterSetName = &v
	return s
}

func (s *CreateDatabaseRequest) SetDBDescription(v string) *CreateDatabaseRequest {
	s.DBDescription = &v
	return s
}

func (s *CreateDatabaseRequest) SetDBInstanceId(v string) *CreateDatabaseRequest {
	s.DBInstanceId = &v
	return s
}

func (s *CreateDatabaseRequest) SetDBName(v string) *CreateDatabaseRequest {
	s.DBName = &v
	return s
}

func (s *CreateDatabaseRequest) SetOwnerAccount(v string) *CreateDatabaseRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateDatabaseRequest) SetOwnerId(v int64) *CreateDatabaseRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateDatabaseRequest) SetResourceGroupId(v string) *CreateDatabaseRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *CreateDatabaseRequest) SetResourceOwnerAccount(v string) *CreateDatabaseRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateDatabaseRequest) SetResourceOwnerId(v int64) *CreateDatabaseRequest {
	s.ResourceOwnerId = &v
	return s
}

type CreateDatabaseResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateDatabaseResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateDatabaseResponseBody) GoString() string {
	return s.String()
}

func (s *CreateDatabaseResponseBody) SetRequestId(v string) *CreateDatabaseResponseBody {
	s.RequestId = &v
	return s
}

type CreateDatabaseResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateDatabaseResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateDatabaseResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateDatabaseResponse) GoString() string {
	return s.String()
}

func (s *CreateDatabaseResponse) SetHeaders(v map[string]*string) *CreateDatabaseResponse {
	s.Headers = v
	return s
}

func (s *CreateDatabaseResponse) SetStatusCode(v int32) *CreateDatabaseResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateDatabaseResponse) SetBody(v *CreateDatabaseResponseBody) *CreateDatabaseResponse {
	s.Body = v
	return s
}

type CreateDdrInstanceRequest struct {
	// The ID of the backup set that is used for the restoration. You can call the [DescribeCrossRegionBackups](~~121733~~) operation to query the ID of the backup set.
	//
	// > If you set **RestoreType** to **BackupSet**, you must specify this parameter.
	BackupSetId *string `json:"BackupSetId,omitempty" xml:"BackupSetId,omitempty"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The connection mode of the destination instance. Valid values:
	//
	// *   **Standard**: standard mode
	// *   **Safe**: database proxy mode
	//
	// Default value: **Standard**.
	ConnectionMode *string `json:"ConnectionMode,omitempty" xml:"ConnectionMode,omitempty"`
	// The instance type of the destination instance. For more information, see [Primary ApsaraDB RDS instance types](~~26312~~).
	DBInstanceClass *string `json:"DBInstanceClass,omitempty" xml:"DBInstanceClass,omitempty"`
	// The name of the instance. The name must be 2 to 256 characters in length. The name can contain letters, digits, underscores (\_), and hyphens (-). The name must start with a letter.
	//
	// > The name cannot start with http:// or https://.
	DBInstanceDescription *string `json:"DBInstanceDescription,omitempty" xml:"DBInstanceDescription,omitempty"`
	// The network connection type of the destination instance. Valid values:
	//
	// *   **Internet**
	// *   **Intranet**
	DBInstanceNetType *string `json:"DBInstanceNetType,omitempty" xml:"DBInstanceNetType,omitempty"`
	// The storage capacity of the destination instance. Valid values: **5 to 2000**. Unit: GB. You can increase the storage capacity at a step size of 5 GB. For more information, see [Primary instance types](~~26312~~).
	DBInstanceStorage *int32 `json:"DBInstanceStorage,omitempty" xml:"DBInstanceStorage,omitempty"`
	// The storage type of the destination instance. Only the local SSD storage type is supported. Default value: **local_ssd**.
	DBInstanceStorageType *string `json:"DBInstanceStorageType,omitempty" xml:"DBInstanceStorageType,omitempty"`
	// The database engine of the destination instance. Valid values:
	//
	// *   **MySQL**
	// *   **SQLServer**
	// *   **PostgreSQL**
	Engine *string `json:"Engine,omitempty" xml:"Engine,omitempty"`
	// The major engine version of the destination instance. The value of this parameter varies based on the value of **Engine**.
	//
	// *   Valid values when Engine is set to MySQL: **5.5, 5.6, 5.7, and 8.0**
	// *   Valid values when Engine is set to SQLServer: **2008r2, 08r2\_ent_ha, 2012, 2012\_ent_ha, 2012\_std_ha, 2012\_web, 2014\_std_ha, 2016\_ent_ha, 2016\_std_ha, 2016\_web, 2017\_std_ha, 2017\_ent, 2019\_std_ha, and 2019\_ent**
	// *   Valid values when Engine is set to PostgreSQL: **9.4, 10.0, 11.0, 12.0, and 13.0**
	EngineVersion *string `json:"EngineVersion,omitempty" xml:"EngineVersion,omitempty"`
	// The network type of the instance. Valid values:
	//
	// *   **VPC**
	// *   **Classic**
	//
	// Default value: Classic.
	//
	// > If you set this parameter to **VPC**, you must also specify **VpcId** and **VSwitchId**.
	InstanceNetworkType *string `json:"InstanceNetworkType,omitempty" xml:"InstanceNetworkType,omitempty"`
	OwnerAccount        *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId             *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The billing method of the instance. Valid values:
	//
	// *   **Postpaid**: pay-as-you-go
	// *   **Prepaid**: subscription
	PayType *string `json:"PayType,omitempty" xml:"PayType,omitempty"`
	// The unit that is used to measure the subscription duration of the destination instance. Valid values:
	//
	// *   **Year**
	// *   **Month**
	//
	// > If you set PayType to **Prepaid**, you must specify UsedTime.
	Period *string `json:"Period,omitempty" xml:"Period,omitempty"`
	// The private IP address of the destination instance. The private IP address must be within the CIDR block that is supported by the specified vSwitch. The system automatically assigns a private IP address to an instance based on the values of **VPCId** and **VSwitchId**.
	PrivateIpAddress *string `json:"PrivateIpAddress,omitempty" xml:"PrivateIpAddress,omitempty"`
	// The region ID of the destination instance. You can call the [DescribeRegions](~~26243~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The point in time to which you want to restore data. The point in time that you specify must be earlier than the current time. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
	//
	// > If **RestoreType** is set to **BackupTime**, you must specify this parameter.
	RestoreTime *string `json:"RestoreTime,omitempty" xml:"RestoreTime,omitempty"`
	// The method that is used to restore data. Valid values:
	//
	// *   **BackupSet**: restores data from a backup set. If you use this value, you must also specify **BackupSetID**.
	// *   **BackupTime**: restores data to a point in time. If you use this value, you must also specify **RestoreTime**, **SourceRegion**, and **SourceDBInstanceName**.
	RestoreType *string `json:"RestoreType,omitempty" xml:"RestoreType,omitempty"`
	// The IP address whitelist of the destination instance. If you want to add more than one entry to the IP address whitelist, separate the entries with commas (,). Each entry must be unique. You can add a maximum of 1,000 entries. For more information, see [Configure an IP address whitelist for an ApsaraDB RDS for MySQL instance](~~43185~~). The entries in the IP address whitelist must be in one of the following formats:
	//
	// *   IP address. Example: 10.23.12.24.
	// *   CIDR block. Example: 10.23.12.24/24. In this example, 24 indicates that the prefix of the CIDR block is 24 bits in length. You can replace 24 with a value that ranges from 1 to 32.
	SecurityIPList *string `json:"SecurityIPList,omitempty" xml:"SecurityIPList,omitempty"`
	// The ID of the source instance if you want to restore data to a point in time.
	//
	// > If you set **RestoreType** to **BackupTime**, you must specify this parameter.
	SourceDBInstanceName *string `json:"SourceDBInstanceName,omitempty" xml:"SourceDBInstanceName,omitempty"`
	// The region ID of the source instance if you want to restore data to a point in time.
	//
	// > If you set **RestoreType** to **BackupTime**, you must specify this parameter.
	SourceRegion *string `json:"SourceRegion,omitempty" xml:"SourceRegion,omitempty"`
	// The character set of the destination instance. Valid values:
	//
	// *   **utf8**
	// *   **gbk**
	// *   **latin1**
	// *   **utf8mb4**
	SystemDBCharset *string `json:"SystemDBCharset,omitempty" xml:"SystemDBCharset,omitempty"`
	// The subscription duration of the instance.
	//
	// *   If you set **Period** to **Year**, the value of UsedTime ranges from **1 to 3**.
	// *   If you set **Period** to **Month**, the value of UsedTime ranges from **1 to 9**.
	//
	// > If you set PayType to **Prepaid**, you must specify UsedTime.
	UsedTime *string `json:"UsedTime,omitempty" xml:"UsedTime,omitempty"`
	// The VPC ID of the instance. This parameter is available only when you set **InstanceNetworkType** to **VPC**.
	//
	// > If you specify this parameter, you must also specify **ZoneId**.
	VPCId *string `json:"VPCId,omitempty" xml:"VPCId,omitempty"`
	// The vSwitch ID of the destination instance. If you specify more than one vSwitch, separate the IDs of the vSwitches with commas (,). This parameter is available only when you set **InstanceNetworkType** to **VPC**.
	//
	// > If you specify this parameter, you must also specify **ZoneId**.
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
	// The zone ID of the destination instance. If the destination instance is deployed in multiple zones, separate the IDs of the zones with colons (:).
	//
	// > If you specify a virtual private cloud (VPC) and a vSwitch, you must specify this parameter to identify the zone for the vSwitch.
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
}

func (s CreateDdrInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateDdrInstanceRequest) GoString() string {
	return s.String()
}

func (s *CreateDdrInstanceRequest) SetBackupSetId(v string) *CreateDdrInstanceRequest {
	s.BackupSetId = &v
	return s
}

func (s *CreateDdrInstanceRequest) SetClientToken(v string) *CreateDdrInstanceRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateDdrInstanceRequest) SetConnectionMode(v string) *CreateDdrInstanceRequest {
	s.ConnectionMode = &v
	return s
}

func (s *CreateDdrInstanceRequest) SetDBInstanceClass(v string) *CreateDdrInstanceRequest {
	s.DBInstanceClass = &v
	return s
}

func (s *CreateDdrInstanceRequest) SetDBInstanceDescription(v string) *CreateDdrInstanceRequest {
	s.DBInstanceDescription = &v
	return s
}

func (s *CreateDdrInstanceRequest) SetDBInstanceNetType(v string) *CreateDdrInstanceRequest {
	s.DBInstanceNetType = &v
	return s
}

func (s *CreateDdrInstanceRequest) SetDBInstanceStorage(v int32) *CreateDdrInstanceRequest {
	s.DBInstanceStorage = &v
	return s
}

func (s *CreateDdrInstanceRequest) SetDBInstanceStorageType(v string) *CreateDdrInstanceRequest {
	s.DBInstanceStorageType = &v
	return s
}

func (s *CreateDdrInstanceRequest) SetEngine(v string) *CreateDdrInstanceRequest {
	s.Engine = &v
	return s
}

func (s *CreateDdrInstanceRequest) SetEngineVersion(v string) *CreateDdrInstanceRequest {
	s.EngineVersion = &v
	return s
}

func (s *CreateDdrInstanceRequest) SetInstanceNetworkType(v string) *CreateDdrInstanceRequest {
	s.InstanceNetworkType = &v
	return s
}

func (s *CreateDdrInstanceRequest) SetOwnerAccount(v string) *CreateDdrInstanceRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateDdrInstanceRequest) SetOwnerId(v int64) *CreateDdrInstanceRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateDdrInstanceRequest) SetPayType(v string) *CreateDdrInstanceRequest {
	s.PayType = &v
	return s
}

func (s *CreateDdrInstanceRequest) SetPeriod(v string) *CreateDdrInstanceRequest {
	s.Period = &v
	return s
}

func (s *CreateDdrInstanceRequest) SetPrivateIpAddress(v string) *CreateDdrInstanceRequest {
	s.PrivateIpAddress = &v
	return s
}

func (s *CreateDdrInstanceRequest) SetRegionId(v string) *CreateDdrInstanceRequest {
	s.RegionId = &v
	return s
}

func (s *CreateDdrInstanceRequest) SetResourceGroupId(v string) *CreateDdrInstanceRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *CreateDdrInstanceRequest) SetResourceOwnerAccount(v string) *CreateDdrInstanceRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateDdrInstanceRequest) SetResourceOwnerId(v int64) *CreateDdrInstanceRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreateDdrInstanceRequest) SetRestoreTime(v string) *CreateDdrInstanceRequest {
	s.RestoreTime = &v
	return s
}

func (s *CreateDdrInstanceRequest) SetRestoreType(v string) *CreateDdrInstanceRequest {
	s.RestoreType = &v
	return s
}

func (s *CreateDdrInstanceRequest) SetSecurityIPList(v string) *CreateDdrInstanceRequest {
	s.SecurityIPList = &v
	return s
}

func (s *CreateDdrInstanceRequest) SetSourceDBInstanceName(v string) *CreateDdrInstanceRequest {
	s.SourceDBInstanceName = &v
	return s
}

func (s *CreateDdrInstanceRequest) SetSourceRegion(v string) *CreateDdrInstanceRequest {
	s.SourceRegion = &v
	return s
}

func (s *CreateDdrInstanceRequest) SetSystemDBCharset(v string) *CreateDdrInstanceRequest {
	s.SystemDBCharset = &v
	return s
}

func (s *CreateDdrInstanceRequest) SetUsedTime(v string) *CreateDdrInstanceRequest {
	s.UsedTime = &v
	return s
}

func (s *CreateDdrInstanceRequest) SetVPCId(v string) *CreateDdrInstanceRequest {
	s.VPCId = &v
	return s
}

func (s *CreateDdrInstanceRequest) SetVSwitchId(v string) *CreateDdrInstanceRequest {
	s.VSwitchId = &v
	return s
}

func (s *CreateDdrInstanceRequest) SetZoneId(v string) *CreateDdrInstanceRequest {
	s.ZoneId = &v
	return s
}

type CreateDdrInstanceResponseBody struct {
	// The endpoint that is used to connect to the destination instance.
	//
	// > **DBInstanceNetType** indicates whether the endpoint is internal or public.
	ConnectionString *string `json:"ConnectionString,omitempty" xml:"ConnectionString,omitempty"`
	// The ID of the destination instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The ID of the order.
	OrderId *string `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The port number that is used to connect to the destination instance.
	//
	// > **DBInstanceNetType** indicates whether the port is internal or public.
	Port *string `json:"Port,omitempty" xml:"Port,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateDdrInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateDdrInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *CreateDdrInstanceResponseBody) SetConnectionString(v string) *CreateDdrInstanceResponseBody {
	s.ConnectionString = &v
	return s
}

func (s *CreateDdrInstanceResponseBody) SetDBInstanceId(v string) *CreateDdrInstanceResponseBody {
	s.DBInstanceId = &v
	return s
}

func (s *CreateDdrInstanceResponseBody) SetOrderId(v string) *CreateDdrInstanceResponseBody {
	s.OrderId = &v
	return s
}

func (s *CreateDdrInstanceResponseBody) SetPort(v string) *CreateDdrInstanceResponseBody {
	s.Port = &v
	return s
}

func (s *CreateDdrInstanceResponseBody) SetRequestId(v string) *CreateDdrInstanceResponseBody {
	s.RequestId = &v
	return s
}

type CreateDdrInstanceResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateDdrInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateDdrInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateDdrInstanceResponse) GoString() string {
	return s.String()
}

func (s *CreateDdrInstanceResponse) SetHeaders(v map[string]*string) *CreateDdrInstanceResponse {
	s.Headers = v
	return s
}

func (s *CreateDdrInstanceResponse) SetStatusCode(v int32) *CreateDdrInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateDdrInstanceResponse) SetBody(v *CreateDdrInstanceResponseBody) *CreateDdrInstanceResponse {
	s.Body = v
	return s
}

type CreateDiagnosticReportRequest struct {
	// The ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The end time of the monitored data that is used to generate the diagnostic report. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm*Z format. The time must be in UTC.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The start time of the monitored data that is used to generate the diagnostic report. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm*Z format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s CreateDiagnosticReportRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateDiagnosticReportRequest) GoString() string {
	return s.String()
}

func (s *CreateDiagnosticReportRequest) SetDBInstanceId(v string) *CreateDiagnosticReportRequest {
	s.DBInstanceId = &v
	return s
}

func (s *CreateDiagnosticReportRequest) SetEndTime(v string) *CreateDiagnosticReportRequest {
	s.EndTime = &v
	return s
}

func (s *CreateDiagnosticReportRequest) SetStartTime(v string) *CreateDiagnosticReportRequest {
	s.StartTime = &v
	return s
}

type CreateDiagnosticReportResponseBody struct {
	// The ID of the diagnostic report.
	ReportId *string `json:"ReportId,omitempty" xml:"ReportId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateDiagnosticReportResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateDiagnosticReportResponseBody) GoString() string {
	return s.String()
}

func (s *CreateDiagnosticReportResponseBody) SetReportId(v string) *CreateDiagnosticReportResponseBody {
	s.ReportId = &v
	return s
}

func (s *CreateDiagnosticReportResponseBody) SetRequestId(v string) *CreateDiagnosticReportResponseBody {
	s.RequestId = &v
	return s
}

type CreateDiagnosticReportResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateDiagnosticReportResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateDiagnosticReportResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateDiagnosticReportResponse) GoString() string {
	return s.String()
}

func (s *CreateDiagnosticReportResponse) SetHeaders(v map[string]*string) *CreateDiagnosticReportResponse {
	s.Headers = v
	return s
}

func (s *CreateDiagnosticReportResponse) SetStatusCode(v int32) *CreateDiagnosticReportResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateDiagnosticReportResponse) SetBody(v *CreateDiagnosticReportResponseBody) *CreateDiagnosticReportResponse {
	s.Body = v
	return s
}

type CreateGADInstanceRequest struct {
	// The ID of the primary instance. You can call the [DescribeDBInstances](~~26232~~) operation to query the ID of instance. The primary instance serves as the central node of the global active database cluster.
	//
	// >
	//
	// *   A primary instance can serve as the central node only of a single global active database cluster.
	//
	// *   Only a primary instance that is created in one of the following regions can serve as the central node of a global active database cluster: China (Hangzhou), China (Shanghai), China (Qingdao), China (Beijing), China (Zhangjiakou), China (Shenzhen), and China (Chengdu).
	CentralDBInstanceId *string `json:"CentralDBInstanceId,omitempty" xml:"CentralDBInstanceId,omitempty"`
	// The username of the privileged account of the central node. You can call the [DescribeAccounts](~~26265~~) operation to query the privileged account of the central node.
	CentralRdsDtsAdminAccount *string `json:"CentralRdsDtsAdminAccount,omitempty" xml:"CentralRdsDtsAdminAccount,omitempty"`
	// The password of the privileged account of the central node.
	CentralRdsDtsAdminPassword *string `json:"CentralRdsDtsAdminPassword,omitempty" xml:"CentralRdsDtsAdminPassword,omitempty"`
	// The region ID of the central node. You can call the [DescribeRegions](~~26243~~) operation to query the most recent region list.
	CentralRegionId *string `json:"CentralRegionId,omitempty" xml:"CentralRegionId,omitempty"`
	// A JSON array that consists of the information about a specified database on the central node. All database information that you specify in this array is synchronized to the unit nodes of the global active database cluster. The JSON array contains the following fields:
	//
	// *   **name**: the name of the database.
	// *   **all**: specifies whether to synchronize all data in the database or the table. Valid values: **true** and **false**.
	// *   **Table**: the name of the table. If you set the **all** field to **false**, you must nest the name of the table that you want to synchronize into the JSON array.
	//
	// Example: `{ "testdb": { "name": "testdb", "all": false, "Table": { "order": { "name": "order", "all": true }, "ordernew": { "name": "ordernew", "all": true } } } }`
	DBList *string `json:"DBList,omitempty" xml:"DBList,omitempty"`
	// The name of the global active database cluster.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// An array that consists of the details about the tag.
	Tag []*CreateGADInstanceRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
	// An array that consists of the details about the unit node.
	UnitNode []*CreateGADInstanceRequestUnitNode `json:"UnitNode,omitempty" xml:"UnitNode,omitempty" type:"Repeated"`
}

func (s CreateGADInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateGADInstanceRequest) GoString() string {
	return s.String()
}

func (s *CreateGADInstanceRequest) SetCentralDBInstanceId(v string) *CreateGADInstanceRequest {
	s.CentralDBInstanceId = &v
	return s
}

func (s *CreateGADInstanceRequest) SetCentralRdsDtsAdminAccount(v string) *CreateGADInstanceRequest {
	s.CentralRdsDtsAdminAccount = &v
	return s
}

func (s *CreateGADInstanceRequest) SetCentralRdsDtsAdminPassword(v string) *CreateGADInstanceRequest {
	s.CentralRdsDtsAdminPassword = &v
	return s
}

func (s *CreateGADInstanceRequest) SetCentralRegionId(v string) *CreateGADInstanceRequest {
	s.CentralRegionId = &v
	return s
}

func (s *CreateGADInstanceRequest) SetDBList(v string) *CreateGADInstanceRequest {
	s.DBList = &v
	return s
}

func (s *CreateGADInstanceRequest) SetDescription(v string) *CreateGADInstanceRequest {
	s.Description = &v
	return s
}

func (s *CreateGADInstanceRequest) SetResourceGroupId(v string) *CreateGADInstanceRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *CreateGADInstanceRequest) SetTag(v []*CreateGADInstanceRequestTag) *CreateGADInstanceRequest {
	s.Tag = v
	return s
}

func (s *CreateGADInstanceRequest) SetUnitNode(v []*CreateGADInstanceRequestUnitNode) *CreateGADInstanceRequest {
	s.UnitNode = v
	return s
}

type CreateGADInstanceRequestTag struct {
	// The key of the tag. You can create N tag keys at a time. Valid values of N: **1 to 20**. The value of this parameter cannot be an empty string.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The value of the tag. You can create N tag values at a time. Valid values of N: **1 to 20**. The value of this parameter can be an empty string.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateGADInstanceRequestTag) String() string {
	return tea.Prettify(s)
}

func (s CreateGADInstanceRequestTag) GoString() string {
	return s.String()
}

func (s *CreateGADInstanceRequestTag) SetKey(v string) *CreateGADInstanceRequestTag {
	s.Key = &v
	return s
}

func (s *CreateGADInstanceRequestTag) SetValue(v string) *CreateGADInstanceRequestTag {
	s.Value = &v
	return s
}

type CreateGADInstanceRequestUnitNode struct {
	// The name of the unit node that you want to create. The name must meet the following requirements:
	//
	// *   The name must be **2 to 255** characters in length.
	// *   The name can contain letters, digits, underscores (\_), and hyphens (-) and must start with a letter.
	// *   It cannot start with `http://` or `https://`.
	//
	// **N** specifies unit node N. The value of N is an integer that ranges from **1 to 10**. You can create up to 10 unit nodes in a global active database cluster.
	DBInstanceDescription *string `json:"DBInstanceDescription,omitempty" xml:"DBInstanceDescription,omitempty"`
	// The storage capacity of the unit node that you want to create. Unit: GB. The storage capacity increases in increments of 5 GB. For more information, see [Primary ApsaraDB RDS instance types](~~26312~~). You can also call the [DescribeAvailableResource](~~134039~~) operation to query the storage capacity range that is supported for a specified instance type in a region.
	//
	// **N** specifies unit node N. The value of N is an integer that ranges from **1 to 10**. You can create up to 10 unit nodes in a global active database cluster.
	DBInstanceStorage *int64 `json:"DBInstanceStorage,omitempty" xml:"DBInstanceStorage,omitempty"`
	// The storage type that is used by the instance. Valid values:
	//
	// *   **local_ssd**: local SSD (recommended).
	// *   **cloud_ssd**: standard SSD. This storage type is not recommended. Standard SSDs are no longer available for purchase in some Alibaba Cloud regions.
	// *   **cloud_essd**: ESSD of performance level 1 (PL1).
	// *   **cloud_essd2**: ESSD of PL2.
	// *   **cloud_essd3**: ESSDs of PL3.
	//
	// The default value of this parameter is determined by the instance type specified by the **DBInstanceClass** parameter.
	//
	// *   If the instance type specifies the local disk storage type, the default value of this parameter is **local_ssd**.
	// *   If the instance type specifies the cloud disk storage type, the default value of this parameter is **cloud_essd**.
	DBInstanceStorageType *string `json:"DBInstanceStorageType,omitempty" xml:"DBInstanceStorageType,omitempty"`
	// The instance type of the unit node that you want to create. For more information, see [Primary ApsaraDB RDS instance types](~~26312~~). You can call the [DescribeAvailableResource](~~134039~~) operation to query the available instance types in a region.
	//
	// **N** specifies unit node N. The value of N is an integer that ranges from **1 to 10**. You can create up to 10 unit nodes in a global active database cluster.
	DbInstanceClass *string `json:"DbInstanceClass,omitempty" xml:"DbInstanceClass,omitempty"`
	// The conflict resolution policy based on which Data Transmission Service (DTS) responds to primary key conflicts during data synchronization to the unit node that you want to create. Valid values:
	//
	// *   **overwrite**: DTS overwrites the conflicting primary key on the destination node.
	// *   **interrupt**: DTS stops the synchronization task, reports an error, and then exits.
	// *   **ignore**: DTS hides the conflicting primary key on the node.
	//
	// **N** specifies unit node N. The value of N is an integer that ranges from **1 to 10**. You can create up to 10 unit nodes in a global active database cluster.
	DtsConflict *string `json:"DtsConflict,omitempty" xml:"DtsConflict,omitempty"`
	// The specifications of the data synchronization task for the unit node that you want to create. Valid values:
	//
	// *   **small**
	// *   **medium**
	// *   **large**
	// *   **micro**
	//
	// > For more information, see [Specifications of data synchronization tasks](~~26605~~).
	//
	// **N** specifies unit node N. The value of N is an integer that ranges from **1 to 10**. You can create up to 10 unit nodes in a global active database cluster.
	DtsInstanceClass *string `json:"DtsInstanceClass,omitempty" xml:"DtsInstanceClass,omitempty"`
	// The database engine of the unit node that you want to create. Set the value to **MySQL**.
	//
	// **N** specifies unit node N. The value of N is an integer that ranges from **1 to 10**. You can create up to 10 unit nodes in a global active database cluster.
	Engine *string `json:"Engine,omitempty" xml:"Engine,omitempty"`
	// The database engine version of the unit node that you want to create. Valid values:
	//
	// *   **8.0**
	// *   **5.7**
	// *   **5.6**
	// *   **5.5**
	//
	// **N** specifies unit node N. The value of N is an integer that ranges from **1 to 10**. You can create up to 10 unit nodes in a global active database cluster.
	EngineVersion *string `json:"EngineVersion,omitempty" xml:"EngineVersion,omitempty"`
	// The billing method of the unit node that you want to create. Valid values:
	//
	// *   **Postpaid**: pay-as-you-go.
	// *   **Prepaid**: subscription.
	//
	// > The system automatically generates a purchase order and completes the payment.
	//
	// **N** specifies unit node N. The value of N is an integer that ranges from **1 to 10**. You can create up to 10 unit nodes in a global active database cluster.
	PayType *string `json:"PayType,omitempty" xml:"PayType,omitempty"`
	// The region ID of the unit node that you want to create. You can call the [DescribeRegions](~~26243~~) operation to query the most recent region list.
	//
	// **N** specifies unit node N. The value of N is an integer that ranges from **1 to 10**. You can create up to 10 unit nodes in a global active database cluster.
	RegionID *string `json:"RegionID,omitempty" xml:"RegionID,omitempty"`
	// The IP address whitelist of the unit node that you want to create. For more information, see [IP address whitelist](~~43185~~). If you want to add more than one entry to the IP address whitelist, separate the entries with commas (,). Each entry must be unique. The IP address whitelist can contain up to 1,000 entries. The entries in the IP address whitelist must be in one of the following formats:
	//
	// *   IP addresses, such as `10.10.10.10`.
	// *   CIDR blocks, such as `10.10.10.10/24`. In this example, **24** indicates that the prefix of each IP address in the IP address whitelist is 24 bits in length. You can replace 24 with a value within the range of **1 to 32**.
	//
	// **N** specifies unit node N. The value of N is an integer that ranges from **1 to 10**. You can create up to 10 unit nodes in a global active database cluster.
	SecurityIPList *string `json:"SecurityIPList,omitempty" xml:"SecurityIPList,omitempty"`
	// The vSwitch ID of the unit node that you want to create.
	//
	// **N** specifies unit node N. The value of N is an integer that ranges from **1 to 10**. You can create up to 10 unit nodes in a global active database cluster.
	VSwitchID *string `json:"VSwitchID,omitempty" xml:"VSwitchID,omitempty"`
	// The virtual private cloud (VPC) ID of the unit node that you want to create.
	//
	// **N** specifies unit node N. The value of N is an integer that ranges from **1 to 10**. You can create up to 10 unit nodes in a global active database cluster.
	VpcID *string `json:"VpcID,omitempty" xml:"VpcID,omitempty"`
	// The zone ID of the unit node that you want to create. You can call the [DescribeRegions](~~26243~~) operation to query the ID of the zone.
	//
	// **N** specifies unit node N. The value of N is an integer that ranges from **1 to 10**. You can create up to 10 unit nodes in a global active database cluster.
	ZoneID *string `json:"ZoneID,omitempty" xml:"ZoneID,omitempty"`
	// The zone ID of the secondary node of the unit node that you want to create. You can call the [DescribeRegions](~~26243~~) operation to query the ID of the zone.
	//
	// *   If the value of this parameter is the same as the **zone ID** of the unit node that you want to create, the single-zone deployment method is used.
	// *   If the value of this parameter is different from the **zone ID** of the unit node that you want to create, the multiple-zone deployment method is used.
	//
	// **N** specifies unit node N. The value of N is an integer that ranges from **1 to 10**. You can create up to 10 unit nodes in a global active database cluster.
	ZoneIDSlave1 *string `json:"ZoneIDSlave1,omitempty" xml:"ZoneIDSlave1,omitempty"`
	// The zone ID of the logger node of the unit node that you want to create. You can call the [DescribeRegions](~~26243~~) operation to query the ID of the zone.
	//
	// *   If the value of this parameter is the same as the **zone ID** of the unit node that you want to create, the single-zone deployment method is used.
	// *   If the value of this parameter is different from the **zone ID** of the unit node that you want to create, the multiple-zone deployment method is used.
	//
	// **N** specifies unit node N. The value of N is an integer that ranges from **1 to 10**. You can create up to 10 unit nodes in a global active database cluster.
	ZoneIDSlave2 *string `json:"ZoneIDSlave2,omitempty" xml:"ZoneIDSlave2,omitempty"`
}

func (s CreateGADInstanceRequestUnitNode) String() string {
	return tea.Prettify(s)
}

func (s CreateGADInstanceRequestUnitNode) GoString() string {
	return s.String()
}

func (s *CreateGADInstanceRequestUnitNode) SetDBInstanceDescription(v string) *CreateGADInstanceRequestUnitNode {
	s.DBInstanceDescription = &v
	return s
}

func (s *CreateGADInstanceRequestUnitNode) SetDBInstanceStorage(v int64) *CreateGADInstanceRequestUnitNode {
	s.DBInstanceStorage = &v
	return s
}

func (s *CreateGADInstanceRequestUnitNode) SetDBInstanceStorageType(v string) *CreateGADInstanceRequestUnitNode {
	s.DBInstanceStorageType = &v
	return s
}

func (s *CreateGADInstanceRequestUnitNode) SetDbInstanceClass(v string) *CreateGADInstanceRequestUnitNode {
	s.DbInstanceClass = &v
	return s
}

func (s *CreateGADInstanceRequestUnitNode) SetDtsConflict(v string) *CreateGADInstanceRequestUnitNode {
	s.DtsConflict = &v
	return s
}

func (s *CreateGADInstanceRequestUnitNode) SetDtsInstanceClass(v string) *CreateGADInstanceRequestUnitNode {
	s.DtsInstanceClass = &v
	return s
}

func (s *CreateGADInstanceRequestUnitNode) SetEngine(v string) *CreateGADInstanceRequestUnitNode {
	s.Engine = &v
	return s
}

func (s *CreateGADInstanceRequestUnitNode) SetEngineVersion(v string) *CreateGADInstanceRequestUnitNode {
	s.EngineVersion = &v
	return s
}

func (s *CreateGADInstanceRequestUnitNode) SetPayType(v string) *CreateGADInstanceRequestUnitNode {
	s.PayType = &v
	return s
}

func (s *CreateGADInstanceRequestUnitNode) SetRegionID(v string) *CreateGADInstanceRequestUnitNode {
	s.RegionID = &v
	return s
}

func (s *CreateGADInstanceRequestUnitNode) SetSecurityIPList(v string) *CreateGADInstanceRequestUnitNode {
	s.SecurityIPList = &v
	return s
}

func (s *CreateGADInstanceRequestUnitNode) SetVSwitchID(v string) *CreateGADInstanceRequestUnitNode {
	s.VSwitchID = &v
	return s
}

func (s *CreateGADInstanceRequestUnitNode) SetVpcID(v string) *CreateGADInstanceRequestUnitNode {
	s.VpcID = &v
	return s
}

func (s *CreateGADInstanceRequestUnitNode) SetZoneID(v string) *CreateGADInstanceRequestUnitNode {
	s.ZoneID = &v
	return s
}

func (s *CreateGADInstanceRequestUnitNode) SetZoneIDSlave1(v string) *CreateGADInstanceRequestUnitNode {
	s.ZoneIDSlave1 = &v
	return s
}

func (s *CreateGADInstanceRequestUnitNode) SetZoneIDSlave2(v string) *CreateGADInstanceRequestUnitNode {
	s.ZoneIDSlave2 = &v
	return s
}

type CreateGADInstanceResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// An array that consists of the information returned.
	Result *CreateGADInstanceResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Struct"`
}

func (s CreateGADInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateGADInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *CreateGADInstanceResponseBody) SetRequestId(v string) *CreateGADInstanceResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateGADInstanceResponseBody) SetResult(v *CreateGADInstanceResponseBodyResult) *CreateGADInstanceResponseBody {
	s.Result = v
	return s
}

type CreateGADInstanceResponseBodyResult struct {
	// The number of unit nodes that are created by calling this operation.
	CreateMemberCount *string `json:"CreateMemberCount,omitempty" xml:"CreateMemberCount,omitempty"`
	// The ID of the global active database cluster.
	GadInstanceName *string `json:"GadInstanceName,omitempty" xml:"GadInstanceName,omitempty"`
	// The ID of the task.
	TaskID *string `json:"TaskID,omitempty" xml:"TaskID,omitempty"`
}

func (s CreateGADInstanceResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s CreateGADInstanceResponseBodyResult) GoString() string {
	return s.String()
}

func (s *CreateGADInstanceResponseBodyResult) SetCreateMemberCount(v string) *CreateGADInstanceResponseBodyResult {
	s.CreateMemberCount = &v
	return s
}

func (s *CreateGADInstanceResponseBodyResult) SetGadInstanceName(v string) *CreateGADInstanceResponseBodyResult {
	s.GadInstanceName = &v
	return s
}

func (s *CreateGADInstanceResponseBodyResult) SetTaskID(v string) *CreateGADInstanceResponseBodyResult {
	s.TaskID = &v
	return s
}

type CreateGADInstanceResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateGADInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateGADInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateGADInstanceResponse) GoString() string {
	return s.String()
}

func (s *CreateGADInstanceResponse) SetHeaders(v map[string]*string) *CreateGADInstanceResponse {
	s.Headers = v
	return s
}

func (s *CreateGADInstanceResponse) SetStatusCode(v int32) *CreateGADInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateGADInstanceResponse) SetBody(v *CreateGADInstanceResponseBody) *CreateGADInstanceResponse {
	s.Body = v
	return s
}

type CreateGadInstanceMemberRequest struct {
	// The ID of the central node. You can call the [DescribeGadInstances](~~330105~~) operation to query the ID of the central node.
	CentralDBInstanceId *string `json:"CentralDBInstanceId,omitempty" xml:"CentralDBInstanceId,omitempty"`
	// The username of the privileged account of the central node. You can call the [DescribeAccounts](~~26265~~) operation to query the privileged account of the central node.
	CentralRdsDtsAdminAccount *string `json:"CentralRdsDtsAdminAccount,omitempty" xml:"CentralRdsDtsAdminAccount,omitempty"`
	// The password of the privileged account of the central node.
	CentralRdsDtsAdminPassword *string `json:"CentralRdsDtsAdminPassword,omitempty" xml:"CentralRdsDtsAdminPassword,omitempty"`
	// The region ID of the central node. You can call the [DescribeRegions](~~26243~~) operation to query the most recent region list.
	CentralRegionId *string `json:"CentralRegionId,omitempty" xml:"CentralRegionId,omitempty"`
	// A JSON array that consists of the information about the databases on the central node. All database information that you specify in this array is synchronized to the unit nodes of the global active database cluster. The JSON array contains the following fields:
	//
	// *   **name**: the name of the database.
	// *   **all**: specifies whether to synchronize all data in the database or the table. Valid values: **true** and **false**.
	// *   **Table**: the name of the table. If you set the **all** field to **false**, you must nest the name of the table that you want to synchronize into the JSON array.
	//
	// Example: `{ "testdb": { "name": "testdb", "all": false, "Table": { "order": { "name": "order", "all": true }, "ordernew": { "name": "ordernew", "all": true } } } }`
	//
	// >  For more information, see [Objects of DTS tasks](~~209545~~).
	DBList *string `json:"DBList,omitempty" xml:"DBList,omitempty"`
	// The ID of the global active database cluster. You can call the [DescribeGadInstances](~~330105~~) operation to query the ID of the global active database cluster.
	GadInstanceId *string `json:"GadInstanceId,omitempty" xml:"GadInstanceId,omitempty"`
	// The information about the unit node.
	UnitNode []*CreateGadInstanceMemberRequestUnitNode `json:"UnitNode,omitempty" xml:"UnitNode,omitempty" type:"Repeated"`
}

func (s CreateGadInstanceMemberRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateGadInstanceMemberRequest) GoString() string {
	return s.String()
}

func (s *CreateGadInstanceMemberRequest) SetCentralDBInstanceId(v string) *CreateGadInstanceMemberRequest {
	s.CentralDBInstanceId = &v
	return s
}

func (s *CreateGadInstanceMemberRequest) SetCentralRdsDtsAdminAccount(v string) *CreateGadInstanceMemberRequest {
	s.CentralRdsDtsAdminAccount = &v
	return s
}

func (s *CreateGadInstanceMemberRequest) SetCentralRdsDtsAdminPassword(v string) *CreateGadInstanceMemberRequest {
	s.CentralRdsDtsAdminPassword = &v
	return s
}

func (s *CreateGadInstanceMemberRequest) SetCentralRegionId(v string) *CreateGadInstanceMemberRequest {
	s.CentralRegionId = &v
	return s
}

func (s *CreateGadInstanceMemberRequest) SetDBList(v string) *CreateGadInstanceMemberRequest {
	s.DBList = &v
	return s
}

func (s *CreateGadInstanceMemberRequest) SetGadInstanceId(v string) *CreateGadInstanceMemberRequest {
	s.GadInstanceId = &v
	return s
}

func (s *CreateGadInstanceMemberRequest) SetUnitNode(v []*CreateGadInstanceMemberRequestUnitNode) *CreateGadInstanceMemberRequest {
	s.UnitNode = v
	return s
}

type CreateGadInstanceMemberRequestUnitNode struct {
	// The name of the unit node that you want to create. The name must meet the following requirements:
	//
	// *   The name must be **2 to 255** characters in length.
	// *   The name can contain letters, digits, underscores (\_), and hyphens (-) and must start with a letter.
	// *   The name cannot start with `http://` or `https://`.
	//
	// **N** specifies unit node N. The value of N is an integer that ranges from **1 to 10**. You can create up to 10 unit nodes in a global active database cluster.
	DBInstanceDescription *string `json:"DBInstanceDescription,omitempty" xml:"DBInstanceDescription,omitempty"`
	// The storage capacity of the unit node that you want to create. Unit: GB. You can adjust the storage capacity in increments of 5 GB. For more information, see [Primary ApsaraDB RDS instance types](~~26312~~). You can call the [DescribeAvailableResource](~~134039~~) operation to query the storage capacity range that is supported for a specified instance type in a region.
	//
	// **N** specifies unit node N. The value of N is an integer that ranges from **1 to 10**. You can create up to 10 unit nodes in a global active database cluster.
	DBInstanceStorage *int64 `json:"DBInstanceStorage,omitempty" xml:"DBInstanceStorage,omitempty"`
	// The storage type of the new instance. Valid values:
	//
	// *   **local_ssd**: local SSDs
	// *   **cloud_ssd**: standard SSDs
	// *   **cloud_essd**: enhanced SSDs (ESSDs) of performance level 1 (PL1)
	// *   **cloud_essd2**: ESSDs of PL2.
	// *   **cloud_essd3**: ESSD of PL3.
	DBInstanceStorageType *string `json:"DBInstanceStorageType,omitempty" xml:"DBInstanceStorageType,omitempty"`
	// The instance type of the unit node that you want to create. For more information, see [Primary ApsaraDB RDS instance types](~~26312~~). You can call the [DescribeAvailableResource](~~134039~~) operation to query the available instance types in a region.
	//
	// **N** specifies unit node N. The value of N is an integer that ranges from **1 to 10**. You can create up to 10 unit nodes in a global active database cluster.
	DbInstanceClass *string `json:"DbInstanceClass,omitempty" xml:"DbInstanceClass,omitempty"`
	// The conflict resolution policy based on which Data Transmission Service (DTS) responds to primary key conflicts during data synchronization to the unit node that you want to create. Valid values:
	//
	// *   **overwrite**: DTS overwrites the conflicting primary key on the destination node.
	// *   **interrupt**: DTS stops the synchronization task, reports an error, and then exits.
	// *   **ignore**: DTS overwrites the conflicting primary key on the logger node.
	//
	// **N** specifies unit node N. The value of N is an integer that ranges from **1 to 10**. You can create up to 10 unit nodes in a global active database cluster.
	DtsConflict *string `json:"DtsConflict,omitempty" xml:"DtsConflict,omitempty"`
	// The specifications of the data synchronization task for the unit node that you want to create. Valid values:
	//
	// *   **small**
	// *   **medium**
	// *   **large**
	// *   **micro**
	//
	// >  For more information, see [Specifications of data synchronization instances](~~26605~~).
	//
	// **N** specifies unit node N. The value of N is an integer that ranges from **1 to 10**. You can create up to 10 unit nodes in a global active database cluster.
	DtsInstanceClass *string `json:"DtsInstanceClass,omitempty" xml:"DtsInstanceClass,omitempty"`
	// The database engine of the unit node that you want to create. Set the value to **MySQL**.
	//
	// **N** specifies unit node N. The value of N is an integer that ranges from **1 to 10**. You can create up to 10 unit nodes in a global active database cluster.
	Engine *string `json:"Engine,omitempty" xml:"Engine,omitempty"`
	// The database engine version of the unit node that you want to create. Valid values:
	//
	// *   **8.0**
	// *   **5.7**
	// *   **5.6**
	// *   **5.5**
	//
	// **N** specifies unit node N. The value of N is an integer that ranges from **1 to 10**. You can create up to 10 unit nodes in a global active database cluster.
	EngineVersion *string `json:"EngineVersion,omitempty" xml:"EngineVersion,omitempty"`
	// The region ID of the unit node that you want to create. You can call the [DescribeRegions](~~26243~~) operation to query the most recent region list.
	//
	// **N** specifies unit node N. The value of N is an integer that ranges from **1 to 10**. You can create up to 10 unit nodes in a global active database cluster.
	RegionID *string `json:"RegionID,omitempty" xml:"RegionID,omitempty"`
	// The IP address whitelist of the unit node that you want to create. For more information, see [IP address whitelist](~~43185~~). If you want to add more than one entry to the IP address whitelist, separate the entries with commas (,). Each entry must be unique. The IP address whitelist can contain up to 1,000 entries. The entries in the IP address whitelist must be in one of the following formats:
	//
	// *   IP addresses, such as `10.10.XX.XX`.
	// *   CIDR blocks, such as `10.10.XX.XX/24`. In this example, **24** indicates that the prefix of each IP address in the IP address whitelist is 24 bits in length. You can replace 24 with a value within the range of **1 to 32**.
	//
	// **N** specifies unit node N. The value of N is an integer that ranges from **1 to 10**. You can create up to 10 unit nodes in a global active database cluster.
	SecurityIPList *string `json:"SecurityIPList,omitempty" xml:"SecurityIPList,omitempty"`
	// The vSwitch ID of the unit node that you want to create.
	//
	// **N** specifies unit node N. The value of N is an integer that ranges from **1 to 10**. You can create up to 10 unit nodes in a global active database cluster.
	VSwitchID *string `json:"VSwitchID,omitempty" xml:"VSwitchID,omitempty"`
	// The virtual private cloud (VPC) ID of the unit node that you want to create.
	//
	// **N** specifies unit node N. The value of N is an integer that ranges from **1 to 10**. You can create up to 10 unit nodes in a global active database cluster.
	VpcID *string `json:"VpcID,omitempty" xml:"VpcID,omitempty"`
	// The zone ID of the unit node that you want to create. You can call the [DescribeRegions](~~26243~~) operation to query the ID of the zone.
	//
	// **N** specifies unit node N. The value of N is an integer that ranges from **1 to 10**. You can create up to 10 unit nodes in a global active database cluster.
	ZoneID *string `json:"ZoneID,omitempty" xml:"ZoneID,omitempty"`
	// The zone ID of the secondary node of the unit node that you want to create. You can call the [DescribeRegions](~~26243~~) operation to query the ID of the zone.
	//
	// *   If the value of this parameter is the same as the **zone ID** of the unit node that you want to create, the single-zone deployment method is used.
	// *   If the value of this parameter is different from the **zone ID** of the unit node that you want to create, the multiple-zone deployment method is used.
	//
	// **N** specifies unit node N. The value of N is an integer that ranges from **1 to 10**. You can create up to 10 unit nodes in a global active database cluster.
	ZoneIDSlave1 *string `json:"ZoneIDSlave1,omitempty" xml:"ZoneIDSlave1,omitempty"`
	// The zone ID of the logger node of the unit node that you want to create. You can call the [DescribeRegions](~~26243~~) operation to query the ID of the zone.
	//
	// *   If the value of this parameter is the same as the **zone ID** of the unit node that you want to create, the single-zone deployment method is used.
	// *   If the value of this parameter is different from the **zone ID** of the unit node that you want to create, the multiple-zone deployment method is used.
	//
	// **N** specifies unit node N. The value of N is an integer that ranges from **1 to 10**. You can create up to 10 unit nodes in a global active database cluster.
	ZoneIDSlave2 *string `json:"ZoneIDSlave2,omitempty" xml:"ZoneIDSlave2,omitempty"`
}

func (s CreateGadInstanceMemberRequestUnitNode) String() string {
	return tea.Prettify(s)
}

func (s CreateGadInstanceMemberRequestUnitNode) GoString() string {
	return s.String()
}

func (s *CreateGadInstanceMemberRequestUnitNode) SetDBInstanceDescription(v string) *CreateGadInstanceMemberRequestUnitNode {
	s.DBInstanceDescription = &v
	return s
}

func (s *CreateGadInstanceMemberRequestUnitNode) SetDBInstanceStorage(v int64) *CreateGadInstanceMemberRequestUnitNode {
	s.DBInstanceStorage = &v
	return s
}

func (s *CreateGadInstanceMemberRequestUnitNode) SetDBInstanceStorageType(v string) *CreateGadInstanceMemberRequestUnitNode {
	s.DBInstanceStorageType = &v
	return s
}

func (s *CreateGadInstanceMemberRequestUnitNode) SetDbInstanceClass(v string) *CreateGadInstanceMemberRequestUnitNode {
	s.DbInstanceClass = &v
	return s
}

func (s *CreateGadInstanceMemberRequestUnitNode) SetDtsConflict(v string) *CreateGadInstanceMemberRequestUnitNode {
	s.DtsConflict = &v
	return s
}

func (s *CreateGadInstanceMemberRequestUnitNode) SetDtsInstanceClass(v string) *CreateGadInstanceMemberRequestUnitNode {
	s.DtsInstanceClass = &v
	return s
}

func (s *CreateGadInstanceMemberRequestUnitNode) SetEngine(v string) *CreateGadInstanceMemberRequestUnitNode {
	s.Engine = &v
	return s
}

func (s *CreateGadInstanceMemberRequestUnitNode) SetEngineVersion(v string) *CreateGadInstanceMemberRequestUnitNode {
	s.EngineVersion = &v
	return s
}

func (s *CreateGadInstanceMemberRequestUnitNode) SetRegionID(v string) *CreateGadInstanceMemberRequestUnitNode {
	s.RegionID = &v
	return s
}

func (s *CreateGadInstanceMemberRequestUnitNode) SetSecurityIPList(v string) *CreateGadInstanceMemberRequestUnitNode {
	s.SecurityIPList = &v
	return s
}

func (s *CreateGadInstanceMemberRequestUnitNode) SetVSwitchID(v string) *CreateGadInstanceMemberRequestUnitNode {
	s.VSwitchID = &v
	return s
}

func (s *CreateGadInstanceMemberRequestUnitNode) SetVpcID(v string) *CreateGadInstanceMemberRequestUnitNode {
	s.VpcID = &v
	return s
}

func (s *CreateGadInstanceMemberRequestUnitNode) SetZoneID(v string) *CreateGadInstanceMemberRequestUnitNode {
	s.ZoneID = &v
	return s
}

func (s *CreateGadInstanceMemberRequestUnitNode) SetZoneIDSlave1(v string) *CreateGadInstanceMemberRequestUnitNode {
	s.ZoneIDSlave1 = &v
	return s
}

func (s *CreateGadInstanceMemberRequestUnitNode) SetZoneIDSlave2(v string) *CreateGadInstanceMemberRequestUnitNode {
	s.ZoneIDSlave2 = &v
	return s
}

type CreateGadInstanceMemberResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// An array that consists of the information returned.
	Result *CreateGadInstanceMemberResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Struct"`
}

func (s CreateGadInstanceMemberResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateGadInstanceMemberResponseBody) GoString() string {
	return s.String()
}

func (s *CreateGadInstanceMemberResponseBody) SetRequestId(v string) *CreateGadInstanceMemberResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateGadInstanceMemberResponseBody) SetResult(v *CreateGadInstanceMemberResponseBodyResult) *CreateGadInstanceMemberResponseBody {
	s.Result = v
	return s
}

type CreateGadInstanceMemberResponseBodyResult struct {
	// The number of unit nodes that are created by calling this operation.
	CreateCount *string `json:"CreateCount,omitempty" xml:"CreateCount,omitempty"`
	// The ID of the global active database cluster.
	GadInstanceName *string `json:"GadInstanceName,omitempty" xml:"GadInstanceName,omitempty"`
}

func (s CreateGadInstanceMemberResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s CreateGadInstanceMemberResponseBodyResult) GoString() string {
	return s.String()
}

func (s *CreateGadInstanceMemberResponseBodyResult) SetCreateCount(v string) *CreateGadInstanceMemberResponseBodyResult {
	s.CreateCount = &v
	return s
}

func (s *CreateGadInstanceMemberResponseBodyResult) SetGadInstanceName(v string) *CreateGadInstanceMemberResponseBodyResult {
	s.GadInstanceName = &v
	return s
}

type CreateGadInstanceMemberResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateGadInstanceMemberResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateGadInstanceMemberResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateGadInstanceMemberResponse) GoString() string {
	return s.String()
}

func (s *CreateGadInstanceMemberResponse) SetHeaders(v map[string]*string) *CreateGadInstanceMemberResponse {
	s.Headers = v
	return s
}

func (s *CreateGadInstanceMemberResponse) SetStatusCode(v int32) *CreateGadInstanceMemberResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateGadInstanceMemberResponse) SetBody(v *CreateGadInstanceMemberResponseBody) *CreateGadInstanceMemberResponse {
	s.Body = v
	return s
}

type CreateMigrateTaskRequest struct {
	// The type of the migration task. Valid values:
	//
	// *   **FULL**: The migration task migrates full backup files.
	// *   **UPDF**: The migration task migrates incremental or log backup files.
	BackupMode *string `json:"BackupMode,omitempty" xml:"BackupMode,omitempty"`
	// The consistency check method for the database. Valid values:
	//
	// *   **SyncExecuteDBCheck**: synchronous database check
	// *   **AsyncExecuteDBCheck**: asynchronous database check
	//
	// Default value: **AsyncExecuteDBCheck** (compatible with SQL Server 2008 R2).
	//
	// >  This parameter is valid when **IsOnlineDB** is set to **True**.
	CheckDBMode *string `json:"CheckDBMode,omitempty" xml:"CheckDBMode,omitempty"`
	// The instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The name of the destination database.
	DBName *string `json:"DBName,omitempty" xml:"DBName,omitempty"`
	// Specifies whether to make the restored database data available for user access. Valid values:
	//
	// *   **True**
	// *   **False**
	//
	// > Set the value to **True** for instances that run SQL Server 2008 R2.
	IsOnlineDB *string `json:"IsOnlineDB,omitempty" xml:"IsOnlineDB,omitempty"`
	// The ID of the migration task.
	//
	// *   If you set **BackupMode** to **FULL**, the value of this parameter is empty. The full backup mode is compatible with instance that runs SQL Server 2008 R2.
	// *   If you set **BackupMode** to **UPDF**, the value of this parameter is the ID of the required full migration task.
	//
	// > *   If you set **IsOnlineDB** to **True**, the value of **BackupMode** must be **FULL**.
	// > *   If you set **IsOnlineDB** to **False**, the value of **BackupMode** must be **UPDF**.
	MigrateTaskId *string `json:"MigrateTaskId,omitempty" xml:"MigrateTaskId,omitempty"`
	// The shared URL of the backup file in the OSS bucket. The URL must be encoded.
	//
	// If you specify multiple URLs, separate them with vertical bars (|) and then encode them.
	//
	// >  This parameter is required for instances that run SQL Server 2008 R2.
	OSSUrls *string `json:"OSSUrls,omitempty" xml:"OSSUrls,omitempty"`
	// The information about the backup file in the OSS bucket.
	//
	// The values consist of three parts that are separated by colons (:):
	//
	// *   OSS endpoint: oss-ap-southeast-1.aliyuncs.com.
	// *   Name of the OSS bucket: rdsmssqlsingapore.
	// *   Key of the backup file in the OSS bucket: autotest\_2008R2\_TestMigration_FULL.bak.
	//
	// > *   This parameter is optional for instances that run SQL Server 2008 R2.
	// > *   This parameter is required for instances that run a major engine version later than SQL Server 2008 R2.
	OssObjectPositions   *string `json:"OssObjectPositions,omitempty" xml:"OssObjectPositions,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s CreateMigrateTaskRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateMigrateTaskRequest) GoString() string {
	return s.String()
}

func (s *CreateMigrateTaskRequest) SetBackupMode(v string) *CreateMigrateTaskRequest {
	s.BackupMode = &v
	return s
}

func (s *CreateMigrateTaskRequest) SetCheckDBMode(v string) *CreateMigrateTaskRequest {
	s.CheckDBMode = &v
	return s
}

func (s *CreateMigrateTaskRequest) SetDBInstanceId(v string) *CreateMigrateTaskRequest {
	s.DBInstanceId = &v
	return s
}

func (s *CreateMigrateTaskRequest) SetDBName(v string) *CreateMigrateTaskRequest {
	s.DBName = &v
	return s
}

func (s *CreateMigrateTaskRequest) SetIsOnlineDB(v string) *CreateMigrateTaskRequest {
	s.IsOnlineDB = &v
	return s
}

func (s *CreateMigrateTaskRequest) SetMigrateTaskId(v string) *CreateMigrateTaskRequest {
	s.MigrateTaskId = &v
	return s
}

func (s *CreateMigrateTaskRequest) SetOSSUrls(v string) *CreateMigrateTaskRequest {
	s.OSSUrls = &v
	return s
}

func (s *CreateMigrateTaskRequest) SetOssObjectPositions(v string) *CreateMigrateTaskRequest {
	s.OssObjectPositions = &v
	return s
}

func (s *CreateMigrateTaskRequest) SetOwnerId(v int64) *CreateMigrateTaskRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateMigrateTaskRequest) SetResourceOwnerAccount(v string) *CreateMigrateTaskRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateMigrateTaskRequest) SetResourceOwnerId(v int64) *CreateMigrateTaskRequest {
	s.ResourceOwnerId = &v
	return s
}

type CreateMigrateTaskResponseBody struct {
	// The type of the migration task. Valid values:
	//
	// *   **FULL**: The migration task migrates full backup files.
	// *   **UPDF**: The migration task migrates incremental or log backup files.
	BackupMode *string `json:"BackupMode,omitempty" xml:"BackupMode,omitempty"`
	// The instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The name of the database.
	DBName *string `json:"DBName,omitempty" xml:"DBName,omitempty"`
	// The ID of the migration task.
	MigrateTaskId *string `json:"MigrateTaskId,omitempty" xml:"MigrateTaskId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The task ID.
	TaskId *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
}

func (s CreateMigrateTaskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateMigrateTaskResponseBody) GoString() string {
	return s.String()
}

func (s *CreateMigrateTaskResponseBody) SetBackupMode(v string) *CreateMigrateTaskResponseBody {
	s.BackupMode = &v
	return s
}

func (s *CreateMigrateTaskResponseBody) SetDBInstanceId(v string) *CreateMigrateTaskResponseBody {
	s.DBInstanceId = &v
	return s
}

func (s *CreateMigrateTaskResponseBody) SetDBName(v string) *CreateMigrateTaskResponseBody {
	s.DBName = &v
	return s
}

func (s *CreateMigrateTaskResponseBody) SetMigrateTaskId(v string) *CreateMigrateTaskResponseBody {
	s.MigrateTaskId = &v
	return s
}

func (s *CreateMigrateTaskResponseBody) SetRequestId(v string) *CreateMigrateTaskResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateMigrateTaskResponseBody) SetTaskId(v string) *CreateMigrateTaskResponseBody {
	s.TaskId = &v
	return s
}

type CreateMigrateTaskResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateMigrateTaskResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateMigrateTaskResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateMigrateTaskResponse) GoString() string {
	return s.String()
}

func (s *CreateMigrateTaskResponse) SetHeaders(v map[string]*string) *CreateMigrateTaskResponse {
	s.Headers = v
	return s
}

func (s *CreateMigrateTaskResponse) SetStatusCode(v int32) *CreateMigrateTaskResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateMigrateTaskResponse) SetBody(v *CreateMigrateTaskResponseBody) *CreateMigrateTaskResponse {
	s.Body = v
	return s
}

type CreateOnlineDatabaseTaskRequest struct {
	// The consistency check method after the database is open. Valid values:
	//
	// *   **SyncExecuteDBCheck**: synchronous database check
	// *   **AsyncExecuteDBCheck**: asynchronous database check
	//
	// > The check methods are supported for RDS instances that run SQL Server 2008 R2.
	CheckDBMode *string `json:"CheckDBMode,omitempty" xml:"CheckDBMode,omitempty"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The instance ID. You can call the [DescribeDBInstances](~~610396~~) operation to query the instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The name of the database.
	DBName *string `json:"DBName,omitempty" xml:"DBName,omitempty"`
	// The ID of the migration task.
	MigrateTaskId        *string `json:"MigrateTaskId,omitempty" xml:"MigrateTaskId,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s CreateOnlineDatabaseTaskRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateOnlineDatabaseTaskRequest) GoString() string {
	return s.String()
}

func (s *CreateOnlineDatabaseTaskRequest) SetCheckDBMode(v string) *CreateOnlineDatabaseTaskRequest {
	s.CheckDBMode = &v
	return s
}

func (s *CreateOnlineDatabaseTaskRequest) SetClientToken(v string) *CreateOnlineDatabaseTaskRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateOnlineDatabaseTaskRequest) SetDBInstanceId(v string) *CreateOnlineDatabaseTaskRequest {
	s.DBInstanceId = &v
	return s
}

func (s *CreateOnlineDatabaseTaskRequest) SetDBName(v string) *CreateOnlineDatabaseTaskRequest {
	s.DBName = &v
	return s
}

func (s *CreateOnlineDatabaseTaskRequest) SetMigrateTaskId(v string) *CreateOnlineDatabaseTaskRequest {
	s.MigrateTaskId = &v
	return s
}

func (s *CreateOnlineDatabaseTaskRequest) SetOwnerAccount(v string) *CreateOnlineDatabaseTaskRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateOnlineDatabaseTaskRequest) SetOwnerId(v int64) *CreateOnlineDatabaseTaskRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateOnlineDatabaseTaskRequest) SetResourceOwnerAccount(v string) *CreateOnlineDatabaseTaskRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateOnlineDatabaseTaskRequest) SetResourceOwnerId(v int64) *CreateOnlineDatabaseTaskRequest {
	s.ResourceOwnerId = &v
	return s
}

type CreateOnlineDatabaseTaskResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateOnlineDatabaseTaskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateOnlineDatabaseTaskResponseBody) GoString() string {
	return s.String()
}

func (s *CreateOnlineDatabaseTaskResponseBody) SetRequestId(v string) *CreateOnlineDatabaseTaskResponseBody {
	s.RequestId = &v
	return s
}

type CreateOnlineDatabaseTaskResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateOnlineDatabaseTaskResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateOnlineDatabaseTaskResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateOnlineDatabaseTaskResponse) GoString() string {
	return s.String()
}

func (s *CreateOnlineDatabaseTaskResponse) SetHeaders(v map[string]*string) *CreateOnlineDatabaseTaskResponse {
	s.Headers = v
	return s
}

func (s *CreateOnlineDatabaseTaskResponse) SetStatusCode(v int32) *CreateOnlineDatabaseTaskResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateOnlineDatabaseTaskResponse) SetBody(v *CreateOnlineDatabaseTaskResponseBody) *CreateOnlineDatabaseTaskResponse {
	s.Body = v
	return s
}

type CreateOrderForCreateDBNodesRequest struct {
	// Specifies whether to automatically complete the payment. Valid values:
	//
	// *   **true**: automatically completes the payment. You must make sure that your account balance is sufficient.
	// *   **false**: does not automatically complete the payment. An unpaid order is generated.
	//
	// >  Default value: true. If your account balance is insufficient, you can set the AutoPay parameter to false to generate an unpaid order. Then, you can log on to the ApsaraDB RDS console to complete the payment.
	AutoPay *bool `json:"AutoPay,omitempty" xml:"AutoPay,omitempty"`
	// The additional business information about the instance.
	BusinessInfo *string `json:"BusinessInfo,omitempty" xml:"BusinessInfo,omitempty"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The commodity code of the instance. Valid values:
	//
	// *   **bards**: The instance is a pay-as-you-go primary instance.
	// *   **rds**: The instance is a subscription primary instance.
	// *   **rords**: The instance is a pay-as-you-go read-only instance.
	// *   **rds_rordspre_public_cn**: The instance is a subscription read-only instance.
	// *   **bards_intl**: The instance is a pay-as-you-go primary instance.
	// *   **rds_intl**: The instance is a subscription primary instance.
	// *   **rords_intl**: The instance is a pay-as-you-go read-only instance.
	// *   **rds_rordspre_public_intl**: The instance is a subscription read-only instance.
	CommodityCode *string `json:"CommodityCode,omitempty" xml:"CommodityCode,omitempty"`
	// The instance ID. You can call the [DescribeDBInstances](~~610396~~) operation to query the ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The details about the node.
	DBNode []*CreateOrderForCreateDBNodesRequestDBNode `json:"DBNode,omitempty" xml:"DBNode,omitempty" type:"Repeated"`
	// The database engine version of the instance. Valid values:
	//
	// If the instance runs **MySQL**, set this parameter to **5.5**, **5.6**, **5.7**, or **8.0**.
	EngineVersion *string `json:"EngineVersion,omitempty" xml:"EngineVersion,omitempty"`
	// The type of the database node. Valid values:
	//
	// *   **Master**: the primary node
	// *   **Slave**: the secondary node
	NodeType *string `json:"NodeType,omitempty" xml:"NodeType,omitempty"`
	OwnerId  *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The coupon code.
	PromotionCode *string `json:"PromotionCode,omitempty" xml:"PromotionCode,omitempty"`
	// The region ID. You can call the [DescribeRegions](~~26243~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The resource of the instance.
	Resource *string `json:"Resource,omitempty" xml:"Resource,omitempty"`
	// The ID of the resource group.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The zone ID of the host. You can call the [DescribeRegions](~~26243~~) operation to query the zone ID of the host.
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
}

func (s CreateOrderForCreateDBNodesRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateOrderForCreateDBNodesRequest) GoString() string {
	return s.String()
}

func (s *CreateOrderForCreateDBNodesRequest) SetAutoPay(v bool) *CreateOrderForCreateDBNodesRequest {
	s.AutoPay = &v
	return s
}

func (s *CreateOrderForCreateDBNodesRequest) SetBusinessInfo(v string) *CreateOrderForCreateDBNodesRequest {
	s.BusinessInfo = &v
	return s
}

func (s *CreateOrderForCreateDBNodesRequest) SetClientToken(v string) *CreateOrderForCreateDBNodesRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateOrderForCreateDBNodesRequest) SetCommodityCode(v string) *CreateOrderForCreateDBNodesRequest {
	s.CommodityCode = &v
	return s
}

func (s *CreateOrderForCreateDBNodesRequest) SetDBInstanceId(v string) *CreateOrderForCreateDBNodesRequest {
	s.DBInstanceId = &v
	return s
}

func (s *CreateOrderForCreateDBNodesRequest) SetDBNode(v []*CreateOrderForCreateDBNodesRequestDBNode) *CreateOrderForCreateDBNodesRequest {
	s.DBNode = v
	return s
}

func (s *CreateOrderForCreateDBNodesRequest) SetEngineVersion(v string) *CreateOrderForCreateDBNodesRequest {
	s.EngineVersion = &v
	return s
}

func (s *CreateOrderForCreateDBNodesRequest) SetNodeType(v string) *CreateOrderForCreateDBNodesRequest {
	s.NodeType = &v
	return s
}

func (s *CreateOrderForCreateDBNodesRequest) SetOwnerId(v int64) *CreateOrderForCreateDBNodesRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateOrderForCreateDBNodesRequest) SetPromotionCode(v string) *CreateOrderForCreateDBNodesRequest {
	s.PromotionCode = &v
	return s
}

func (s *CreateOrderForCreateDBNodesRequest) SetRegionId(v string) *CreateOrderForCreateDBNodesRequest {
	s.RegionId = &v
	return s
}

func (s *CreateOrderForCreateDBNodesRequest) SetResource(v string) *CreateOrderForCreateDBNodesRequest {
	s.Resource = &v
	return s
}

func (s *CreateOrderForCreateDBNodesRequest) SetResourceGroupId(v string) *CreateOrderForCreateDBNodesRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *CreateOrderForCreateDBNodesRequest) SetResourceOwnerAccount(v string) *CreateOrderForCreateDBNodesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateOrderForCreateDBNodesRequest) SetResourceOwnerId(v int64) *CreateOrderForCreateDBNodesRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreateOrderForCreateDBNodesRequest) SetZoneId(v string) *CreateOrderForCreateDBNodesRequest {
	s.ZoneId = &v
	return s
}

type CreateOrderForCreateDBNodesRequestDBNode struct {
	// The specification information of the node.
	ClassCode *string `json:"classCode,omitempty" xml:"classCode,omitempty"`
	// The zone ID of the node.
	ZoneId *string `json:"zoneId,omitempty" xml:"zoneId,omitempty"`
}

func (s CreateOrderForCreateDBNodesRequestDBNode) String() string {
	return tea.Prettify(s)
}

func (s CreateOrderForCreateDBNodesRequestDBNode) GoString() string {
	return s.String()
}

func (s *CreateOrderForCreateDBNodesRequestDBNode) SetClassCode(v string) *CreateOrderForCreateDBNodesRequestDBNode {
	s.ClassCode = &v
	return s
}

func (s *CreateOrderForCreateDBNodesRequestDBNode) SetZoneId(v string) *CreateOrderForCreateDBNodesRequestDBNode {
	s.ZoneId = &v
	return s
}

type CreateOrderForCreateDBNodesShrinkRequest struct {
	// Specifies whether to automatically complete the payment. Valid values:
	//
	// *   **true**: automatically completes the payment. You must make sure that your account balance is sufficient.
	// *   **false**: does not automatically complete the payment. An unpaid order is generated.
	//
	// >  Default value: true. If your account balance is insufficient, you can set the AutoPay parameter to false to generate an unpaid order. Then, you can log on to the ApsaraDB RDS console to complete the payment.
	AutoPay *bool `json:"AutoPay,omitempty" xml:"AutoPay,omitempty"`
	// The additional business information about the instance.
	BusinessInfo *string `json:"BusinessInfo,omitempty" xml:"BusinessInfo,omitempty"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The commodity code of the instance. Valid values:
	//
	// *   **bards**: The instance is a pay-as-you-go primary instance.
	// *   **rds**: The instance is a subscription primary instance.
	// *   **rords**: The instance is a pay-as-you-go read-only instance.
	// *   **rds_rordspre_public_cn**: The instance is a subscription read-only instance.
	// *   **bards_intl**: The instance is a pay-as-you-go primary instance.
	// *   **rds_intl**: The instance is a subscription primary instance.
	// *   **rords_intl**: The instance is a pay-as-you-go read-only instance.
	// *   **rds_rordspre_public_intl**: The instance is a subscription read-only instance.
	CommodityCode *string `json:"CommodityCode,omitempty" xml:"CommodityCode,omitempty"`
	// The instance ID. You can call the [DescribeDBInstances](~~610396~~) operation to query the ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The details about the node.
	DBNodeShrink *string `json:"DBNode,omitempty" xml:"DBNode,omitempty"`
	// The database engine version of the instance. Valid values:
	//
	// If the instance runs **MySQL**, set this parameter to **5.5**, **5.6**, **5.7**, or **8.0**.
	EngineVersion *string `json:"EngineVersion,omitempty" xml:"EngineVersion,omitempty"`
	// The type of the database node. Valid values:
	//
	// *   **Master**: the primary node
	// *   **Slave**: the secondary node
	NodeType *string `json:"NodeType,omitempty" xml:"NodeType,omitempty"`
	OwnerId  *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The coupon code.
	PromotionCode *string `json:"PromotionCode,omitempty" xml:"PromotionCode,omitempty"`
	// The region ID. You can call the [DescribeRegions](~~26243~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The resource of the instance.
	Resource *string `json:"Resource,omitempty" xml:"Resource,omitempty"`
	// The ID of the resource group.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The zone ID of the host. You can call the [DescribeRegions](~~26243~~) operation to query the zone ID of the host.
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
}

func (s CreateOrderForCreateDBNodesShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateOrderForCreateDBNodesShrinkRequest) GoString() string {
	return s.String()
}

func (s *CreateOrderForCreateDBNodesShrinkRequest) SetAutoPay(v bool) *CreateOrderForCreateDBNodesShrinkRequest {
	s.AutoPay = &v
	return s
}

func (s *CreateOrderForCreateDBNodesShrinkRequest) SetBusinessInfo(v string) *CreateOrderForCreateDBNodesShrinkRequest {
	s.BusinessInfo = &v
	return s
}

func (s *CreateOrderForCreateDBNodesShrinkRequest) SetClientToken(v string) *CreateOrderForCreateDBNodesShrinkRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateOrderForCreateDBNodesShrinkRequest) SetCommodityCode(v string) *CreateOrderForCreateDBNodesShrinkRequest {
	s.CommodityCode = &v
	return s
}

func (s *CreateOrderForCreateDBNodesShrinkRequest) SetDBInstanceId(v string) *CreateOrderForCreateDBNodesShrinkRequest {
	s.DBInstanceId = &v
	return s
}

func (s *CreateOrderForCreateDBNodesShrinkRequest) SetDBNodeShrink(v string) *CreateOrderForCreateDBNodesShrinkRequest {
	s.DBNodeShrink = &v
	return s
}

func (s *CreateOrderForCreateDBNodesShrinkRequest) SetEngineVersion(v string) *CreateOrderForCreateDBNodesShrinkRequest {
	s.EngineVersion = &v
	return s
}

func (s *CreateOrderForCreateDBNodesShrinkRequest) SetNodeType(v string) *CreateOrderForCreateDBNodesShrinkRequest {
	s.NodeType = &v
	return s
}

func (s *CreateOrderForCreateDBNodesShrinkRequest) SetOwnerId(v int64) *CreateOrderForCreateDBNodesShrinkRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateOrderForCreateDBNodesShrinkRequest) SetPromotionCode(v string) *CreateOrderForCreateDBNodesShrinkRequest {
	s.PromotionCode = &v
	return s
}

func (s *CreateOrderForCreateDBNodesShrinkRequest) SetRegionId(v string) *CreateOrderForCreateDBNodesShrinkRequest {
	s.RegionId = &v
	return s
}

func (s *CreateOrderForCreateDBNodesShrinkRequest) SetResource(v string) *CreateOrderForCreateDBNodesShrinkRequest {
	s.Resource = &v
	return s
}

func (s *CreateOrderForCreateDBNodesShrinkRequest) SetResourceGroupId(v string) *CreateOrderForCreateDBNodesShrinkRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *CreateOrderForCreateDBNodesShrinkRequest) SetResourceOwnerAccount(v string) *CreateOrderForCreateDBNodesShrinkRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateOrderForCreateDBNodesShrinkRequest) SetResourceOwnerId(v int64) *CreateOrderForCreateDBNodesShrinkRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreateOrderForCreateDBNodesShrinkRequest) SetZoneId(v string) *CreateOrderForCreateDBNodesShrinkRequest {
	s.ZoneId = &v
	return s
}

type CreateOrderForCreateDBNodesResponseBody struct {
	// The instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The order ID.
	OrderId *int64 `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateOrderForCreateDBNodesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateOrderForCreateDBNodesResponseBody) GoString() string {
	return s.String()
}

func (s *CreateOrderForCreateDBNodesResponseBody) SetDBInstanceId(v string) *CreateOrderForCreateDBNodesResponseBody {
	s.DBInstanceId = &v
	return s
}

func (s *CreateOrderForCreateDBNodesResponseBody) SetOrderId(v int64) *CreateOrderForCreateDBNodesResponseBody {
	s.OrderId = &v
	return s
}

func (s *CreateOrderForCreateDBNodesResponseBody) SetRequestId(v string) *CreateOrderForCreateDBNodesResponseBody {
	s.RequestId = &v
	return s
}

type CreateOrderForCreateDBNodesResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateOrderForCreateDBNodesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateOrderForCreateDBNodesResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateOrderForCreateDBNodesResponse) GoString() string {
	return s.String()
}

func (s *CreateOrderForCreateDBNodesResponse) SetHeaders(v map[string]*string) *CreateOrderForCreateDBNodesResponse {
	s.Headers = v
	return s
}

func (s *CreateOrderForCreateDBNodesResponse) SetStatusCode(v int32) *CreateOrderForCreateDBNodesResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateOrderForCreateDBNodesResponse) SetBody(v *CreateOrderForCreateDBNodesResponseBody) *CreateOrderForCreateDBNodesResponse {
	s.Body = v
	return s
}

type CreateOrderForDeleteDBNodesRequest struct {
	// Specifies whether to automatically complete the payment. Valid values:
	//
	// 1.  **true**: You must make sure that your account balance is sufficient.
	// 2.  **false**: An unpaid order is generated.
	//
	// >  Default value: true. If your account balance is insufficient, you can set the AutoPay parameter to false to generate an unpaid order. Then, you can log on to the ApsaraDB RDS console to complete the payment.
	AutoPay *bool `json:"AutoPay,omitempty" xml:"AutoPay,omitempty"`
	// The additional business information about the instance.
	BusinessInfo *string `json:"BusinessInfo,omitempty" xml:"BusinessInfo,omitempty"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The commodity code. Valid values:
	//
	// *   **bards**: The instance is a pay-as-you-go primary instance.
	// *   **rds**: The instance is a subscription primary instance.
	// *   **rords**: The instance is a pay-as-you-go read-only instance.
	// *   **rds_rordspre_public_cn**: The instance is a subscription read-only instance.
	// *   **bards_intl**: The instance is a pay-as-you-go primary instance.
	// *   **rds_intl**: The instance is a subscription primary instance.
	// *   **rords_intl**: The instance is a pay-as-you-go read-only instance.
	// *   **rds_rordspre_public_intl**: The instance is a subscription read-only instance.
	CommodityCode *string `json:"CommodityCode,omitempty" xml:"CommodityCode,omitempty"`
	// The instance ID. You can call the [DescribeDBInstances](~~610396~~) operation to query the ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// An array that consists of information about the ID of the node.
	DBNodeId []*string `json:"DBNodeId,omitempty" xml:"DBNodeId,omitempty" type:"Repeated"`
	// The database engine version of the instance. Valid values:
	//
	// Valid values if you set Engine to MySQL: **5.5, 5.6, 5.7, and 8.0**
	EngineVersion *string `json:"EngineVersion,omitempty" xml:"EngineVersion,omitempty"`
	// The type of the database node. Valid values:
	//
	// *   **Master**: the primary node
	// *   **Slave**: the secondary node
	NodeType *string `json:"NodeType,omitempty" xml:"NodeType,omitempty"`
	OwnerId  *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The coupon code.
	PromotionCode *string `json:"PromotionCode,omitempty" xml:"PromotionCode,omitempty"`
	// The region ID. You can call the [DescribeRegions](~~610399~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The resources.
	Resource *string `json:"Resource,omitempty" xml:"Resource,omitempty"`
	// The resource group ID.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The zone ID.
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
}

func (s CreateOrderForDeleteDBNodesRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateOrderForDeleteDBNodesRequest) GoString() string {
	return s.String()
}

func (s *CreateOrderForDeleteDBNodesRequest) SetAutoPay(v bool) *CreateOrderForDeleteDBNodesRequest {
	s.AutoPay = &v
	return s
}

func (s *CreateOrderForDeleteDBNodesRequest) SetBusinessInfo(v string) *CreateOrderForDeleteDBNodesRequest {
	s.BusinessInfo = &v
	return s
}

func (s *CreateOrderForDeleteDBNodesRequest) SetClientToken(v string) *CreateOrderForDeleteDBNodesRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateOrderForDeleteDBNodesRequest) SetCommodityCode(v string) *CreateOrderForDeleteDBNodesRequest {
	s.CommodityCode = &v
	return s
}

func (s *CreateOrderForDeleteDBNodesRequest) SetDBInstanceId(v string) *CreateOrderForDeleteDBNodesRequest {
	s.DBInstanceId = &v
	return s
}

func (s *CreateOrderForDeleteDBNodesRequest) SetDBNodeId(v []*string) *CreateOrderForDeleteDBNodesRequest {
	s.DBNodeId = v
	return s
}

func (s *CreateOrderForDeleteDBNodesRequest) SetEngineVersion(v string) *CreateOrderForDeleteDBNodesRequest {
	s.EngineVersion = &v
	return s
}

func (s *CreateOrderForDeleteDBNodesRequest) SetNodeType(v string) *CreateOrderForDeleteDBNodesRequest {
	s.NodeType = &v
	return s
}

func (s *CreateOrderForDeleteDBNodesRequest) SetOwnerId(v int64) *CreateOrderForDeleteDBNodesRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateOrderForDeleteDBNodesRequest) SetPromotionCode(v string) *CreateOrderForDeleteDBNodesRequest {
	s.PromotionCode = &v
	return s
}

func (s *CreateOrderForDeleteDBNodesRequest) SetRegionId(v string) *CreateOrderForDeleteDBNodesRequest {
	s.RegionId = &v
	return s
}

func (s *CreateOrderForDeleteDBNodesRequest) SetResource(v string) *CreateOrderForDeleteDBNodesRequest {
	s.Resource = &v
	return s
}

func (s *CreateOrderForDeleteDBNodesRequest) SetResourceGroupId(v string) *CreateOrderForDeleteDBNodesRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *CreateOrderForDeleteDBNodesRequest) SetResourceOwnerAccount(v string) *CreateOrderForDeleteDBNodesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateOrderForDeleteDBNodesRequest) SetResourceOwnerId(v int64) *CreateOrderForDeleteDBNodesRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreateOrderForDeleteDBNodesRequest) SetZoneId(v string) *CreateOrderForDeleteDBNodesRequest {
	s.ZoneId = &v
	return s
}

type CreateOrderForDeleteDBNodesShrinkRequest struct {
	// Specifies whether to automatically complete the payment. Valid values:
	//
	// 1.  **true**: You must make sure that your account balance is sufficient.
	// 2.  **false**: An unpaid order is generated.
	//
	// >  Default value: true. If your account balance is insufficient, you can set the AutoPay parameter to false to generate an unpaid order. Then, you can log on to the ApsaraDB RDS console to complete the payment.
	AutoPay *bool `json:"AutoPay,omitempty" xml:"AutoPay,omitempty"`
	// The additional business information about the instance.
	BusinessInfo *string `json:"BusinessInfo,omitempty" xml:"BusinessInfo,omitempty"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The commodity code. Valid values:
	//
	// *   **bards**: The instance is a pay-as-you-go primary instance.
	// *   **rds**: The instance is a subscription primary instance.
	// *   **rords**: The instance is a pay-as-you-go read-only instance.
	// *   **rds_rordspre_public_cn**: The instance is a subscription read-only instance.
	// *   **bards_intl**: The instance is a pay-as-you-go primary instance.
	// *   **rds_intl**: The instance is a subscription primary instance.
	// *   **rords_intl**: The instance is a pay-as-you-go read-only instance.
	// *   **rds_rordspre_public_intl**: The instance is a subscription read-only instance.
	CommodityCode *string `json:"CommodityCode,omitempty" xml:"CommodityCode,omitempty"`
	// The instance ID. You can call the [DescribeDBInstances](~~610396~~) operation to query the ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// An array that consists of information about the ID of the node.
	DBNodeIdShrink *string `json:"DBNodeId,omitempty" xml:"DBNodeId,omitempty"`
	// The database engine version of the instance. Valid values:
	//
	// Valid values if you set Engine to MySQL: **5.5, 5.6, 5.7, and 8.0**
	EngineVersion *string `json:"EngineVersion,omitempty" xml:"EngineVersion,omitempty"`
	// The type of the database node. Valid values:
	//
	// *   **Master**: the primary node
	// *   **Slave**: the secondary node
	NodeType *string `json:"NodeType,omitempty" xml:"NodeType,omitempty"`
	OwnerId  *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The coupon code.
	PromotionCode *string `json:"PromotionCode,omitempty" xml:"PromotionCode,omitempty"`
	// The region ID. You can call the [DescribeRegions](~~610399~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The resources.
	Resource *string `json:"Resource,omitempty" xml:"Resource,omitempty"`
	// The resource group ID.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The zone ID.
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
}

func (s CreateOrderForDeleteDBNodesShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateOrderForDeleteDBNodesShrinkRequest) GoString() string {
	return s.String()
}

func (s *CreateOrderForDeleteDBNodesShrinkRequest) SetAutoPay(v bool) *CreateOrderForDeleteDBNodesShrinkRequest {
	s.AutoPay = &v
	return s
}

func (s *CreateOrderForDeleteDBNodesShrinkRequest) SetBusinessInfo(v string) *CreateOrderForDeleteDBNodesShrinkRequest {
	s.BusinessInfo = &v
	return s
}

func (s *CreateOrderForDeleteDBNodesShrinkRequest) SetClientToken(v string) *CreateOrderForDeleteDBNodesShrinkRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateOrderForDeleteDBNodesShrinkRequest) SetCommodityCode(v string) *CreateOrderForDeleteDBNodesShrinkRequest {
	s.CommodityCode = &v
	return s
}

func (s *CreateOrderForDeleteDBNodesShrinkRequest) SetDBInstanceId(v string) *CreateOrderForDeleteDBNodesShrinkRequest {
	s.DBInstanceId = &v
	return s
}

func (s *CreateOrderForDeleteDBNodesShrinkRequest) SetDBNodeIdShrink(v string) *CreateOrderForDeleteDBNodesShrinkRequest {
	s.DBNodeIdShrink = &v
	return s
}

func (s *CreateOrderForDeleteDBNodesShrinkRequest) SetEngineVersion(v string) *CreateOrderForDeleteDBNodesShrinkRequest {
	s.EngineVersion = &v
	return s
}

func (s *CreateOrderForDeleteDBNodesShrinkRequest) SetNodeType(v string) *CreateOrderForDeleteDBNodesShrinkRequest {
	s.NodeType = &v
	return s
}

func (s *CreateOrderForDeleteDBNodesShrinkRequest) SetOwnerId(v int64) *CreateOrderForDeleteDBNodesShrinkRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateOrderForDeleteDBNodesShrinkRequest) SetPromotionCode(v string) *CreateOrderForDeleteDBNodesShrinkRequest {
	s.PromotionCode = &v
	return s
}

func (s *CreateOrderForDeleteDBNodesShrinkRequest) SetRegionId(v string) *CreateOrderForDeleteDBNodesShrinkRequest {
	s.RegionId = &v
	return s
}

func (s *CreateOrderForDeleteDBNodesShrinkRequest) SetResource(v string) *CreateOrderForDeleteDBNodesShrinkRequest {
	s.Resource = &v
	return s
}

func (s *CreateOrderForDeleteDBNodesShrinkRequest) SetResourceGroupId(v string) *CreateOrderForDeleteDBNodesShrinkRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *CreateOrderForDeleteDBNodesShrinkRequest) SetResourceOwnerAccount(v string) *CreateOrderForDeleteDBNodesShrinkRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateOrderForDeleteDBNodesShrinkRequest) SetResourceOwnerId(v int64) *CreateOrderForDeleteDBNodesShrinkRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreateOrderForDeleteDBNodesShrinkRequest) SetZoneId(v string) *CreateOrderForDeleteDBNodesShrinkRequest {
	s.ZoneId = &v
	return s
}

type CreateOrderForDeleteDBNodesResponseBody struct {
	// The instance ID
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The order ID.
	OrderId *int64 `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateOrderForDeleteDBNodesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateOrderForDeleteDBNodesResponseBody) GoString() string {
	return s.String()
}

func (s *CreateOrderForDeleteDBNodesResponseBody) SetDBInstanceId(v string) *CreateOrderForDeleteDBNodesResponseBody {
	s.DBInstanceId = &v
	return s
}

func (s *CreateOrderForDeleteDBNodesResponseBody) SetOrderId(v int64) *CreateOrderForDeleteDBNodesResponseBody {
	s.OrderId = &v
	return s
}

func (s *CreateOrderForDeleteDBNodesResponseBody) SetRequestId(v string) *CreateOrderForDeleteDBNodesResponseBody {
	s.RequestId = &v
	return s
}

type CreateOrderForDeleteDBNodesResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateOrderForDeleteDBNodesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateOrderForDeleteDBNodesResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateOrderForDeleteDBNodesResponse) GoString() string {
	return s.String()
}

func (s *CreateOrderForDeleteDBNodesResponse) SetHeaders(v map[string]*string) *CreateOrderForDeleteDBNodesResponse {
	s.Headers = v
	return s
}

func (s *CreateOrderForDeleteDBNodesResponse) SetStatusCode(v int32) *CreateOrderForDeleteDBNodesResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateOrderForDeleteDBNodesResponse) SetBody(v *CreateOrderForDeleteDBNodesResponseBody) *CreateOrderForDeleteDBNodesResponse {
	s.Body = v
	return s
}

type CreateParameterGroupRequest struct {
	// The database engine. Valid values:
	//
	// *   **mysql**
	// *   **PostgreSQL**
	Engine *string `json:"Engine,omitempty" xml:"Engine,omitempty"`
	// The database engine version of the instance.
	//
	// *   If the instance runs MySQL, the instance must run one of the following MySQL versions:
	//
	//     *   **5.6**
	//     *   **5.7**
	//     *   **8.0**
	//
	// *   If the instance runs PostgreSQL, the instance must run one of the following PostgreSQL versions:
	//
	//     *   **10.0**
	//     *   **11.0**
	//     *   **12.0**
	//     *   **13.0**
	//     *   **14.0**
	//     *   **15.0**
	EngineVersion *string `json:"EngineVersion,omitempty" xml:"EngineVersion,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The description of the parameter template. The value can be up to 200 characters in length.
	ParameterGroupDesc *string `json:"ParameterGroupDesc,omitempty" xml:"ParameterGroupDesc,omitempty"`
	// The name of the parameter template.
	//
	// *   The value must start with a letter and can contain letters, digits, periods (.), and underscores (\_).
	// *   The value can be 8 to 64 characters in length.
	ParameterGroupName *string `json:"ParameterGroupName,omitempty" xml:"ParameterGroupName,omitempty"`
	// A JSON string that consists of parameters and their values in the parameter template. Format: {"Parameter 1":"Value of Parameter 1","Parameter 2":"Value of Parameter 2"...}. For more information about the parameters that can be modified, see [Modify the parameters of an ApsaraDB RDS for MySQL instance](~~96063~~) or [Modify the parameters of an ApsaraDB RDS for PostgreSQL instance](~~96751~~).
	Parameters *string `json:"Parameters,omitempty" xml:"Parameters,omitempty"`
	// The region ID of the parameter template. You can call the DescribeRegions operation to query the most recent zone list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The resource group ID. You can call the DescribeDBInstanceAttribute operation to obtain the resource group ID.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s CreateParameterGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateParameterGroupRequest) GoString() string {
	return s.String()
}

func (s *CreateParameterGroupRequest) SetEngine(v string) *CreateParameterGroupRequest {
	s.Engine = &v
	return s
}

func (s *CreateParameterGroupRequest) SetEngineVersion(v string) *CreateParameterGroupRequest {
	s.EngineVersion = &v
	return s
}

func (s *CreateParameterGroupRequest) SetOwnerId(v int64) *CreateParameterGroupRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateParameterGroupRequest) SetParameterGroupDesc(v string) *CreateParameterGroupRequest {
	s.ParameterGroupDesc = &v
	return s
}

func (s *CreateParameterGroupRequest) SetParameterGroupName(v string) *CreateParameterGroupRequest {
	s.ParameterGroupName = &v
	return s
}

func (s *CreateParameterGroupRequest) SetParameters(v string) *CreateParameterGroupRequest {
	s.Parameters = &v
	return s
}

func (s *CreateParameterGroupRequest) SetRegionId(v string) *CreateParameterGroupRequest {
	s.RegionId = &v
	return s
}

func (s *CreateParameterGroupRequest) SetResourceGroupId(v string) *CreateParameterGroupRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *CreateParameterGroupRequest) SetResourceOwnerAccount(v string) *CreateParameterGroupRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateParameterGroupRequest) SetResourceOwnerId(v int64) *CreateParameterGroupRequest {
	s.ResourceOwnerId = &v
	return s
}

type CreateParameterGroupResponseBody struct {
	// The ID of the parameter template. You can call the [DescribeParameterGroups](~~144491~~) operation to query the IDs of parameter templates.
	ParameterGroupId *string `json:"ParameterGroupId,omitempty" xml:"ParameterGroupId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateParameterGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateParameterGroupResponseBody) GoString() string {
	return s.String()
}

func (s *CreateParameterGroupResponseBody) SetParameterGroupId(v string) *CreateParameterGroupResponseBody {
	s.ParameterGroupId = &v
	return s
}

func (s *CreateParameterGroupResponseBody) SetRequestId(v string) *CreateParameterGroupResponseBody {
	s.RequestId = &v
	return s
}

type CreateParameterGroupResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateParameterGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateParameterGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateParameterGroupResponse) GoString() string {
	return s.String()
}

func (s *CreateParameterGroupResponse) SetHeaders(v map[string]*string) *CreateParameterGroupResponse {
	s.Headers = v
	return s
}

func (s *CreateParameterGroupResponse) SetStatusCode(v int32) *CreateParameterGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateParameterGroupResponse) SetBody(v *CreateParameterGroupResponseBody) *CreateParameterGroupResponse {
	s.Body = v
	return s
}

type CreatePostgresExtensionsRequest struct {
	// The account of the user who owns the extension. Only privileged accounts are supported.
	AccountName *string `json:"AccountName,omitempty" xml:"AccountName,omitempty"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the generated token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The instance ID. You can call the [DescribeDBInstances](~~610396~~) operation to query the ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The name of the database. You can call the [DescribeDatabases](~~610471~~) to obtain the name of the database.
	DBNames *string `json:"DBNames,omitempty" xml:"DBNames,omitempty"`
	// The extension that you want to install. If you want to install multiple extensions, separate them with commas (,). If you do not specify the **SourceDatabase** parameter, you must specify this parameter.
	Extensions   *string `json:"Extensions,omitempty" xml:"Extensions,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The source database from which you want to synchronize the extension to the destination database. If you do not specify the **Extensions** parameter, you must specify this parameter.
	SourceDatabase *string `json:"SourceDatabase,omitempty" xml:"SourceDatabase,omitempty"`
}

func (s CreatePostgresExtensionsRequest) String() string {
	return tea.Prettify(s)
}

func (s CreatePostgresExtensionsRequest) GoString() string {
	return s.String()
}

func (s *CreatePostgresExtensionsRequest) SetAccountName(v string) *CreatePostgresExtensionsRequest {
	s.AccountName = &v
	return s
}

func (s *CreatePostgresExtensionsRequest) SetClientToken(v string) *CreatePostgresExtensionsRequest {
	s.ClientToken = &v
	return s
}

func (s *CreatePostgresExtensionsRequest) SetDBInstanceId(v string) *CreatePostgresExtensionsRequest {
	s.DBInstanceId = &v
	return s
}

func (s *CreatePostgresExtensionsRequest) SetDBNames(v string) *CreatePostgresExtensionsRequest {
	s.DBNames = &v
	return s
}

func (s *CreatePostgresExtensionsRequest) SetExtensions(v string) *CreatePostgresExtensionsRequest {
	s.Extensions = &v
	return s
}

func (s *CreatePostgresExtensionsRequest) SetOwnerAccount(v string) *CreatePostgresExtensionsRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreatePostgresExtensionsRequest) SetOwnerId(v int64) *CreatePostgresExtensionsRequest {
	s.OwnerId = &v
	return s
}

func (s *CreatePostgresExtensionsRequest) SetResourceGroupId(v string) *CreatePostgresExtensionsRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *CreatePostgresExtensionsRequest) SetResourceOwnerAccount(v string) *CreatePostgresExtensionsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreatePostgresExtensionsRequest) SetResourceOwnerId(v int64) *CreatePostgresExtensionsRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreatePostgresExtensionsRequest) SetSourceDatabase(v string) *CreatePostgresExtensionsRequest {
	s.SourceDatabase = &v
	return s
}

type CreatePostgresExtensionsResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreatePostgresExtensionsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreatePostgresExtensionsResponseBody) GoString() string {
	return s.String()
}

func (s *CreatePostgresExtensionsResponseBody) SetRequestId(v string) *CreatePostgresExtensionsResponseBody {
	s.RequestId = &v
	return s
}

type CreatePostgresExtensionsResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreatePostgresExtensionsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreatePostgresExtensionsResponse) String() string {
	return tea.Prettify(s)
}

func (s CreatePostgresExtensionsResponse) GoString() string {
	return s.String()
}

func (s *CreatePostgresExtensionsResponse) SetHeaders(v map[string]*string) *CreatePostgresExtensionsResponse {
	s.Headers = v
	return s
}

func (s *CreatePostgresExtensionsResponse) SetStatusCode(v int32) *CreatePostgresExtensionsResponse {
	s.StatusCode = &v
	return s
}

func (s *CreatePostgresExtensionsResponse) SetBody(v *CreatePostgresExtensionsResponseBody) *CreatePostgresExtensionsResponse {
	s.Body = v
	return s
}

type CreateReadOnlyDBInstanceRequest struct {
	// Specifies whether to enable the automatic payment feature. Valid values:
	//
	// 1.  **true**: enables the feature. Make sure that your account balance is sufficient.
	// 2.  **false**: disables the feature. An unpaid order is generated.
	//
	// >  Default value: true. If your account balance is insufficient, you can set the AutoPay parameter to false to generate an unpaid order. Then, you can log on to the ApsaraDB RDS console to complete the payment.
	AutoPay *bool `json:"AutoPay,omitempty" xml:"AutoPay,omitempty"`
	// Specifies whether to enable the auto-renewal feature for the read-only instance. If you set the PayType parameter to Prepaid, you must also specify this parameter. Valid values:
	//
	// *   **true**: enables the feature.
	// *   **false**: disables the feature.
	//
	// > * If you set the Period parameter to Month, the auto-renewal cycle is one month.
	// > * If you set the Period parameter to Year, the auto-renewal cycle is one year.
	AutoRenew *string `json:"AutoRenew,omitempty" xml:"AutoRenew,omitempty"`
	// A reserved parameter. You do not need to specify this parameter.
	BpeEnabled *string `json:"BpeEnabled,omitempty" xml:"BpeEnabled,omitempty"`
	// A reserved parameter. You do not need to specify this parameter.
	BurstingEnabled *bool `json:"BurstingEnabled,omitempty" xml:"BurstingEnabled,omitempty"`
	// The RDS edition of the instance. Valid values:
	//
	// *   **Basic**: RDS Basic Edition
	// *   **HighAvailability** (default): RDS High-availability Edition
	// *   **AlwaysOn**: RDS Cluster Edition
	//
	// >  The read-only instances of the primary instance that run PostgreSQL and use cloud disks run RDS Basic Edition. Therefore, set this parameter to **Basic**.
	Category *string `json:"Category,omitempty" xml:"Category,omitempty"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The instance type of the read-only instance. For more information, see [Read-only ApsaraDB RDS instance types](~~145759~~). We recommend that you specify an instance type whose specifications are higher than or equal to the specifications of the instance type of the primary instance. If the specifications of the read-only instance are lower than the specifications of the primary instance, the read-only instance may encounter issues such as high latency and heavy load.
	DBInstanceClass *string `json:"DBInstanceClass,omitempty" xml:"DBInstanceClass,omitempty"`
	// The description of the read-only instance. The description must be 2 to 256 characters in length and can contain letters, digits, underscores (\_), and hyphens (-). The value must start with a letter
	//
	// > The value cannot start with [http:// or https://.](http://https://。)
	DBInstanceDescription *string `json:"DBInstanceDescription,omitempty" xml:"DBInstanceDescription,omitempty"`
	// The ID of the primary instance. You can call the [DescribeDBInstances](~~610396~~) operation to query the instance IDs.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The storage capacity of the read-only instance. For more information, see the **Storage space** column in [Read-only instance types](~~145759~~). This value must be a multiple of 5 GB. Unit: GB.
	DBInstanceStorage *int32 `json:"DBInstanceStorage,omitempty" xml:"DBInstanceStorage,omitempty"`
	// The storage type of the instance. Valid values:
	//
	// *   **local_ssd**: local SSDs
	// *   **cloud_ssd**: standard SSDs
	// *   **cloud_essd**: enhanced SSDs (ESSDs) of performance level 1 (PL1)
	// *   **cloud_essd2**: ESSDs of PL2
	// *   **cloud_essd3**: ESSDs of PL3
	//
	// > *   If the primary instance runs MySQL with local disks, you must set this parameter to **local_ssd**. If the primary instance runs MySQL with cloud disks, you must set this parameter to cloud_ssd, cloud_essd, cloud_essd2, or cloud_essd3.
	// > *   If the primary instance runs SQL Server, you must set this parameter to cloud_ssd, cloud_essd, cloud_essd2, or cloud_essd3.
	DBInstanceStorageType *string `json:"DBInstanceStorageType,omitempty" xml:"DBInstanceStorageType,omitempty"`
	// The ID of the dedicated cluster to which the read-only instance belongs. This parameter is valid when you create the read-only instance in a dedicated cluster.
	DedicatedHostGroupId *string `json:"DedicatedHostGroupId,omitempty" xml:"DedicatedHostGroupId,omitempty"`
	// Specifies whether to enable the release protection feature for the read-only instance. Valid values:
	//
	// *   **true**: enables the feature.
	// *   **false** (default): disables the feature.
	//
	// >  You can enable the release protection feature for the read-only instance only when you set the **Billing Method** parameter to **Pay-As-You-Go**.
	DeletionProtection *bool `json:"DeletionProtection,omitempty" xml:"DeletionProtection,omitempty"`
	// The version of the database engine. The read-only instance and the primary instance must run the same major engine version.
	//
	// *   If the read-only instance runs MySQL, set this parameter to **5.6**, **5.7**, or **8.0**.
	// *   If the read-only instance runs MySQL, set this parameter to **2017\_ent, 2019\_ent, or 2022\_ent**.
	// *   If the read-only instance runs PostgreSQL, set this parameter to **10.0, 11.0, 12.0, 13.0, 14.0, or 15.0**.
	EngineVersion *string `json:"EngineVersion,omitempty" xml:"EngineVersion,omitempty"`
	// A reserved parameter.
	GdnInstanceName *string `json:"GdnInstanceName,omitempty" xml:"GdnInstanceName,omitempty"`
	// The network type of the read-only instance. Valid values:
	//
	// *   **VPC**
	// *   **Classic**
	//
	// Default value: VPC. If you set this parameter to VPC, you must also specify the **VPCId** and **VSwitchId** parameters.
	//
	// > The network type of the read-only instance can be different from the network type of the primary instance.
	InstanceNetworkType *string `json:"InstanceNetworkType,omitempty" xml:"InstanceNetworkType,omitempty"`
	// A reserved parameter.
	InstructionSetArch *string `json:"InstructionSetArch,omitempty" xml:"InstructionSetArch,omitempty"`
	OwnerAccount       *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId            *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The billing method of the read-only instance. Valid values:
	//
	// *   **Postpaid**: pay-as-you-go
	// *   **Prepaid**: subscription
	PayType *string `json:"PayType,omitempty" xml:"PayType,omitempty"`
	// The renewal cycle of the read-only instance. Valid values:
	//
	// *   **Year**
	// *   **Month**
	Period *string `json:"Period,omitempty" xml:"Period,omitempty"`
	// The port that can be initialized when you create a read-only ApsaraDB RDS for MySQL instance.
	//
	// Valid values: 1000 to 65534.
	Port *string `json:"Port,omitempty" xml:"Port,omitempty"`
	// The private IP address of the read-only instance. The private IP address must be within the CIDR block that is supported by the specified vSwitch. The system assigns a private IP address to the read-only instance based on the values of the **VPCId** and **VSwitchId** parameters.
	PrivateIpAddress *string `json:"PrivateIpAddress,omitempty" xml:"PrivateIpAddress,omitempty"`
	// The region ID. The read-only instance and the primary instance must reside in the same region. You can call the [DescribeRegions](~~610399~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the host on which the primary instance resides. This parameter is valid when you create the read-only instance in a dedicated cluster.
	TargetDedicatedHostIdForMaster *string `json:"TargetDedicatedHostIdForMaster,omitempty" xml:"TargetDedicatedHostIdForMaster,omitempty"`
	// A reserved parameter.
	TddlBizType *string `json:"TddlBizType,omitempty" xml:"TddlBizType,omitempty"`
	// A reserved parameter.
	TddlRegionConfig *string `json:"TddlRegionConfig,omitempty" xml:"TddlRegionConfig,omitempty"`
	// The subscription duration of the read-only instance. Valid values:
	//
	// *   If you set the **Period** parameter to **Year**, the value of the **UsedTime** parameter ranges from **1** to **5**.
	// *   If you set the **Period** parameter to **Month**, the value of the **UsedTime** parameter ranges from **1** to **9**.
	//
	// > If you set the **PayType** parameter to **Prepaid**, you must specify the UsedTime parameter.
	UsedTime *string `json:"UsedTime,omitempty" xml:"UsedTime,omitempty"`
	// The virtual private cloud (VPC) ID of the read-only instance. If you leave the **InstanceNetworkType** parameter empty or set it to **VPC**, you must also specify this parameter.
	//
	// > * If the primary instance uses local disks, the read-only instance and the primary instance can belong to the same VPC or different VPCs.
	// > * If the primary instance uses cloud disks, the read-only instance and the primary instance must belong to the same VPC.
	VPCId *string `json:"VPCId,omitempty" xml:"VPCId,omitempty"`
	// The vSwitch ID of the read-only instance. If you leave the **InstanceNetworkType** parameter empty or set it to **VPC**, you must specify the VSwitchId parameter.
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
	// The zone ID. You can call the [DescribeRegions](~~610399~~) operation to query the most recent zone list.
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
}

func (s CreateReadOnlyDBInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateReadOnlyDBInstanceRequest) GoString() string {
	return s.String()
}

func (s *CreateReadOnlyDBInstanceRequest) SetAutoPay(v bool) *CreateReadOnlyDBInstanceRequest {
	s.AutoPay = &v
	return s
}

func (s *CreateReadOnlyDBInstanceRequest) SetAutoRenew(v string) *CreateReadOnlyDBInstanceRequest {
	s.AutoRenew = &v
	return s
}

func (s *CreateReadOnlyDBInstanceRequest) SetBpeEnabled(v string) *CreateReadOnlyDBInstanceRequest {
	s.BpeEnabled = &v
	return s
}

func (s *CreateReadOnlyDBInstanceRequest) SetBurstingEnabled(v bool) *CreateReadOnlyDBInstanceRequest {
	s.BurstingEnabled = &v
	return s
}

func (s *CreateReadOnlyDBInstanceRequest) SetCategory(v string) *CreateReadOnlyDBInstanceRequest {
	s.Category = &v
	return s
}

func (s *CreateReadOnlyDBInstanceRequest) SetClientToken(v string) *CreateReadOnlyDBInstanceRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateReadOnlyDBInstanceRequest) SetDBInstanceClass(v string) *CreateReadOnlyDBInstanceRequest {
	s.DBInstanceClass = &v
	return s
}

func (s *CreateReadOnlyDBInstanceRequest) SetDBInstanceDescription(v string) *CreateReadOnlyDBInstanceRequest {
	s.DBInstanceDescription = &v
	return s
}

func (s *CreateReadOnlyDBInstanceRequest) SetDBInstanceId(v string) *CreateReadOnlyDBInstanceRequest {
	s.DBInstanceId = &v
	return s
}

func (s *CreateReadOnlyDBInstanceRequest) SetDBInstanceStorage(v int32) *CreateReadOnlyDBInstanceRequest {
	s.DBInstanceStorage = &v
	return s
}

func (s *CreateReadOnlyDBInstanceRequest) SetDBInstanceStorageType(v string) *CreateReadOnlyDBInstanceRequest {
	s.DBInstanceStorageType = &v
	return s
}

func (s *CreateReadOnlyDBInstanceRequest) SetDedicatedHostGroupId(v string) *CreateReadOnlyDBInstanceRequest {
	s.DedicatedHostGroupId = &v
	return s
}

func (s *CreateReadOnlyDBInstanceRequest) SetDeletionProtection(v bool) *CreateReadOnlyDBInstanceRequest {
	s.DeletionProtection = &v
	return s
}

func (s *CreateReadOnlyDBInstanceRequest) SetEngineVersion(v string) *CreateReadOnlyDBInstanceRequest {
	s.EngineVersion = &v
	return s
}

func (s *CreateReadOnlyDBInstanceRequest) SetGdnInstanceName(v string) *CreateReadOnlyDBInstanceRequest {
	s.GdnInstanceName = &v
	return s
}

func (s *CreateReadOnlyDBInstanceRequest) SetInstanceNetworkType(v string) *CreateReadOnlyDBInstanceRequest {
	s.InstanceNetworkType = &v
	return s
}

func (s *CreateReadOnlyDBInstanceRequest) SetInstructionSetArch(v string) *CreateReadOnlyDBInstanceRequest {
	s.InstructionSetArch = &v
	return s
}

func (s *CreateReadOnlyDBInstanceRequest) SetOwnerAccount(v string) *CreateReadOnlyDBInstanceRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateReadOnlyDBInstanceRequest) SetOwnerId(v int64) *CreateReadOnlyDBInstanceRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateReadOnlyDBInstanceRequest) SetPayType(v string) *CreateReadOnlyDBInstanceRequest {
	s.PayType = &v
	return s
}

func (s *CreateReadOnlyDBInstanceRequest) SetPeriod(v string) *CreateReadOnlyDBInstanceRequest {
	s.Period = &v
	return s
}

func (s *CreateReadOnlyDBInstanceRequest) SetPort(v string) *CreateReadOnlyDBInstanceRequest {
	s.Port = &v
	return s
}

func (s *CreateReadOnlyDBInstanceRequest) SetPrivateIpAddress(v string) *CreateReadOnlyDBInstanceRequest {
	s.PrivateIpAddress = &v
	return s
}

func (s *CreateReadOnlyDBInstanceRequest) SetRegionId(v string) *CreateReadOnlyDBInstanceRequest {
	s.RegionId = &v
	return s
}

func (s *CreateReadOnlyDBInstanceRequest) SetResourceGroupId(v string) *CreateReadOnlyDBInstanceRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *CreateReadOnlyDBInstanceRequest) SetResourceOwnerAccount(v string) *CreateReadOnlyDBInstanceRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateReadOnlyDBInstanceRequest) SetResourceOwnerId(v int64) *CreateReadOnlyDBInstanceRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreateReadOnlyDBInstanceRequest) SetTargetDedicatedHostIdForMaster(v string) *CreateReadOnlyDBInstanceRequest {
	s.TargetDedicatedHostIdForMaster = &v
	return s
}

func (s *CreateReadOnlyDBInstanceRequest) SetTddlBizType(v string) *CreateReadOnlyDBInstanceRequest {
	s.TddlBizType = &v
	return s
}

func (s *CreateReadOnlyDBInstanceRequest) SetTddlRegionConfig(v string) *CreateReadOnlyDBInstanceRequest {
	s.TddlRegionConfig = &v
	return s
}

func (s *CreateReadOnlyDBInstanceRequest) SetUsedTime(v string) *CreateReadOnlyDBInstanceRequest {
	s.UsedTime = &v
	return s
}

func (s *CreateReadOnlyDBInstanceRequest) SetVPCId(v string) *CreateReadOnlyDBInstanceRequest {
	s.VPCId = &v
	return s
}

func (s *CreateReadOnlyDBInstanceRequest) SetVSwitchId(v string) *CreateReadOnlyDBInstanceRequest {
	s.VSwitchId = &v
	return s
}

func (s *CreateReadOnlyDBInstanceRequest) SetZoneId(v string) *CreateReadOnlyDBInstanceRequest {
	s.ZoneId = &v
	return s
}

type CreateReadOnlyDBInstanceResponseBody struct {
	// The internal endpoint that is used to connect to the read-only instance.
	ConnectionString *string `json:"ConnectionString,omitempty" xml:"ConnectionString,omitempty"`
	// The ID of the read-only instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The ID of the order.
	OrderId *string `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The internal port number that is used to connect to the read-only instance.
	Port *string `json:"Port,omitempty" xml:"Port,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateReadOnlyDBInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateReadOnlyDBInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *CreateReadOnlyDBInstanceResponseBody) SetConnectionString(v string) *CreateReadOnlyDBInstanceResponseBody {
	s.ConnectionString = &v
	return s
}

func (s *CreateReadOnlyDBInstanceResponseBody) SetDBInstanceId(v string) *CreateReadOnlyDBInstanceResponseBody {
	s.DBInstanceId = &v
	return s
}

func (s *CreateReadOnlyDBInstanceResponseBody) SetOrderId(v string) *CreateReadOnlyDBInstanceResponseBody {
	s.OrderId = &v
	return s
}

func (s *CreateReadOnlyDBInstanceResponseBody) SetPort(v string) *CreateReadOnlyDBInstanceResponseBody {
	s.Port = &v
	return s
}

func (s *CreateReadOnlyDBInstanceResponseBody) SetRequestId(v string) *CreateReadOnlyDBInstanceResponseBody {
	s.RequestId = &v
	return s
}

type CreateReadOnlyDBInstanceResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateReadOnlyDBInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateReadOnlyDBInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateReadOnlyDBInstanceResponse) GoString() string {
	return s.String()
}

func (s *CreateReadOnlyDBInstanceResponse) SetHeaders(v map[string]*string) *CreateReadOnlyDBInstanceResponse {
	s.Headers = v
	return s
}

func (s *CreateReadOnlyDBInstanceResponse) SetStatusCode(v int32) *CreateReadOnlyDBInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateReadOnlyDBInstanceResponse) SetBody(v *CreateReadOnlyDBInstanceResponseBody) *CreateReadOnlyDBInstanceResponse {
	s.Body = v
	return s
}

type CreateSecretRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the instance. You can call the [DescribeDBInstances](~~26232~~) operation to query the ID of the instance.
	DbInstanceId *string `json:"DbInstanceId,omitempty" xml:"DbInstanceId,omitempty"`
	// The name of the database.
	DbNames *string `json:"DbNames,omitempty" xml:"DbNames,omitempty"`
	// The description of the credential.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The engine of the database.
	//
	// > Only MySQL is supported.
	Engine  *string `json:"Engine,omitempty" xml:"Engine,omitempty"`
	OwnerId *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The password that is used to access the database.
	Password *string `json:"Password,omitempty" xml:"Password,omitempty"`
	// The region ID of the instance. You can call the [DescribeDBInstanceAttribute](~~26231~~) operation to query region ID of the instance.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group to which the instance belongs. You can call the [DescribeDBInstanceAttribute](~~26231~~) operation to query the ID of the resource group.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The name of the credential.
	SecretName *string `json:"SecretName,omitempty" xml:"SecretName,omitempty"`
	// The username that is used to access the database.
	Username *string `json:"Username,omitempty" xml:"Username,omitempty"`
}

func (s CreateSecretRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateSecretRequest) GoString() string {
	return s.String()
}

func (s *CreateSecretRequest) SetClientToken(v string) *CreateSecretRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateSecretRequest) SetDbInstanceId(v string) *CreateSecretRequest {
	s.DbInstanceId = &v
	return s
}

func (s *CreateSecretRequest) SetDbNames(v string) *CreateSecretRequest {
	s.DbNames = &v
	return s
}

func (s *CreateSecretRequest) SetDescription(v string) *CreateSecretRequest {
	s.Description = &v
	return s
}

func (s *CreateSecretRequest) SetEngine(v string) *CreateSecretRequest {
	s.Engine = &v
	return s
}

func (s *CreateSecretRequest) SetOwnerId(v int64) *CreateSecretRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateSecretRequest) SetPassword(v string) *CreateSecretRequest {
	s.Password = &v
	return s
}

func (s *CreateSecretRequest) SetRegionId(v string) *CreateSecretRequest {
	s.RegionId = &v
	return s
}

func (s *CreateSecretRequest) SetResourceGroupId(v string) *CreateSecretRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *CreateSecretRequest) SetResourceOwnerAccount(v string) *CreateSecretRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateSecretRequest) SetResourceOwnerId(v int64) *CreateSecretRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreateSecretRequest) SetSecretName(v string) *CreateSecretRequest {
	s.SecretName = &v
	return s
}

func (s *CreateSecretRequest) SetUsername(v string) *CreateSecretRequest {
	s.Username = &v
	return s
}

type CreateSecretResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ARN of the credential for the created Data API account.
	SecretArn *string `json:"SecretArn,omitempty" xml:"SecretArn,omitempty"`
	// The name of the credential.
	SecretName *string `json:"SecretName,omitempty" xml:"SecretName,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateSecretResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateSecretResponseBody) GoString() string {
	return s.String()
}

func (s *CreateSecretResponseBody) SetRequestId(v string) *CreateSecretResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateSecretResponseBody) SetSecretArn(v string) *CreateSecretResponseBody {
	s.SecretArn = &v
	return s
}

func (s *CreateSecretResponseBody) SetSecretName(v string) *CreateSecretResponseBody {
	s.SecretName = &v
	return s
}

func (s *CreateSecretResponseBody) SetSuccess(v bool) *CreateSecretResponseBody {
	s.Success = &v
	return s
}

type CreateSecretResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateSecretResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateSecretResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateSecretResponse) GoString() string {
	return s.String()
}

func (s *CreateSecretResponse) SetHeaders(v map[string]*string) *CreateSecretResponse {
	s.Headers = v
	return s
}

func (s *CreateSecretResponse) SetStatusCode(v int32) *CreateSecretResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateSecretResponse) SetBody(v *CreateSecretResponseBody) *CreateSecretResponse {
	s.Body = v
	return s
}

type CreateServiceLinkedRoleRequest struct {
	OwnerId *int64 `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID. You can call the [DescribeRegions](~~610399~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The name of the service-linked role.
	//
	// *   **AliyunServiceRoleForRdsPgsqlOnEcs**: the service-linked role for ApsaraDB RDS for PostgreSQL.
	// *   **AliyunServiceRoleForRDSProxyOnEcs**: the service-linked role for the database proxy feature of ApsaraDB RDS for PostgreSQL.
	ServiceLinkedRole *string `json:"ServiceLinkedRole,omitempty" xml:"ServiceLinkedRole,omitempty"`
}

func (s CreateServiceLinkedRoleRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateServiceLinkedRoleRequest) GoString() string {
	return s.String()
}

func (s *CreateServiceLinkedRoleRequest) SetOwnerId(v int64) *CreateServiceLinkedRoleRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateServiceLinkedRoleRequest) SetRegionId(v string) *CreateServiceLinkedRoleRequest {
	s.RegionId = &v
	return s
}

func (s *CreateServiceLinkedRoleRequest) SetResourceOwnerAccount(v string) *CreateServiceLinkedRoleRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateServiceLinkedRoleRequest) SetResourceOwnerId(v int64) *CreateServiceLinkedRoleRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreateServiceLinkedRoleRequest) SetServiceLinkedRole(v string) *CreateServiceLinkedRoleRequest {
	s.ServiceLinkedRole = &v
	return s
}

type CreateServiceLinkedRoleResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateServiceLinkedRoleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateServiceLinkedRoleResponseBody) GoString() string {
	return s.String()
}

func (s *CreateServiceLinkedRoleResponseBody) SetRequestId(v string) *CreateServiceLinkedRoleResponseBody {
	s.RequestId = &v
	return s
}

type CreateServiceLinkedRoleResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateServiceLinkedRoleResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateServiceLinkedRoleResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateServiceLinkedRoleResponse) GoString() string {
	return s.String()
}

func (s *CreateServiceLinkedRoleResponse) SetHeaders(v map[string]*string) *CreateServiceLinkedRoleResponse {
	s.Headers = v
	return s
}

func (s *CreateServiceLinkedRoleResponse) SetStatusCode(v int32) *CreateServiceLinkedRoleResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateServiceLinkedRoleResponse) SetBody(v *CreateServiceLinkedRoleResponseBody) *CreateServiceLinkedRoleResponse {
	s.Body = v
	return s
}

type CreateTempDBInstanceRequest struct {
	// The ID of the backup set. You can call the [DescribeBackups](~~610544~~) operation to query backup set IDs.
	//
	// >  You must specify at least one of the **BackupId** or **RestoreTime** parameters.
	BackupId *int32 `json:"BackupId,omitempty" xml:"BackupId,omitempty"`
	// The instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The specified point in time within the backup retention period. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
	//
	// > *   The time can be set to a point in time within the last seven days and must be more than 30 minutes earlier than the current time. The default time zone is UTC.
	// > *   You must specify at least one of the **BackupId** and **RestoreTime** parameters.
	RestoreTime *string `json:"RestoreTime,omitempty" xml:"RestoreTime,omitempty"`
}

func (s CreateTempDBInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateTempDBInstanceRequest) GoString() string {
	return s.String()
}

func (s *CreateTempDBInstanceRequest) SetBackupId(v int32) *CreateTempDBInstanceRequest {
	s.BackupId = &v
	return s
}

func (s *CreateTempDBInstanceRequest) SetDBInstanceId(v string) *CreateTempDBInstanceRequest {
	s.DBInstanceId = &v
	return s
}

func (s *CreateTempDBInstanceRequest) SetOwnerAccount(v string) *CreateTempDBInstanceRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateTempDBInstanceRequest) SetOwnerId(v int64) *CreateTempDBInstanceRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateTempDBInstanceRequest) SetResourceGroupId(v string) *CreateTempDBInstanceRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *CreateTempDBInstanceRequest) SetResourceOwnerAccount(v string) *CreateTempDBInstanceRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateTempDBInstanceRequest) SetResourceOwnerId(v int64) *CreateTempDBInstanceRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreateTempDBInstanceRequest) SetRestoreTime(v string) *CreateTempDBInstanceRequest {
	s.RestoreTime = &v
	return s
}

type CreateTempDBInstanceResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the temporary instance.
	TempDBInstanceId *string `json:"TempDBInstanceId,omitempty" xml:"TempDBInstanceId,omitempty"`
}

func (s CreateTempDBInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateTempDBInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *CreateTempDBInstanceResponseBody) SetRequestId(v string) *CreateTempDBInstanceResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateTempDBInstanceResponseBody) SetTempDBInstanceId(v string) *CreateTempDBInstanceResponseBody {
	s.TempDBInstanceId = &v
	return s
}

type CreateTempDBInstanceResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateTempDBInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateTempDBInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateTempDBInstanceResponse) GoString() string {
	return s.String()
}

func (s *CreateTempDBInstanceResponse) SetHeaders(v map[string]*string) *CreateTempDBInstanceResponse {
	s.Headers = v
	return s
}

func (s *CreateTempDBInstanceResponse) SetStatusCode(v int32) *CreateTempDBInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateTempDBInstanceResponse) SetBody(v *CreateTempDBInstanceResponseBody) *CreateTempDBInstanceResponse {
	s.Body = v
	return s
}

type CreateYouhuiForOrderRequest struct {
	// The ticket ID.
	ActivityId *int64  `json:"ActivityId,omitempty" xml:"ActivityId,omitempty"`
	OwnerId    *string `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The promotion ID. You can call the [GetResourcePrice](~~428503~~) operation to query the promotion ID.
	PromotionId *int64 `json:"PromotionId,omitempty" xml:"PromotionId,omitempty"`
	// The region ID. You can call the [DescribeRegions](~~26243~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *string `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s CreateYouhuiForOrderRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateYouhuiForOrderRequest) GoString() string {
	return s.String()
}

func (s *CreateYouhuiForOrderRequest) SetActivityId(v int64) *CreateYouhuiForOrderRequest {
	s.ActivityId = &v
	return s
}

func (s *CreateYouhuiForOrderRequest) SetOwnerId(v string) *CreateYouhuiForOrderRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateYouhuiForOrderRequest) SetPromotionId(v int64) *CreateYouhuiForOrderRequest {
	s.PromotionId = &v
	return s
}

func (s *CreateYouhuiForOrderRequest) SetRegionId(v string) *CreateYouhuiForOrderRequest {
	s.RegionId = &v
	return s
}

func (s *CreateYouhuiForOrderRequest) SetResourceOwnerAccount(v string) *CreateYouhuiForOrderRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateYouhuiForOrderRequest) SetResourceOwnerId(v string) *CreateYouhuiForOrderRequest {
	s.ResourceOwnerId = &v
	return s
}

type CreateYouhuiForOrderResponseBody struct {
	// The response parameters.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The coupon ID.
	YouhuiId *string `json:"YouhuiId,omitempty" xml:"YouhuiId,omitempty"`
}

func (s CreateYouhuiForOrderResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateYouhuiForOrderResponseBody) GoString() string {
	return s.String()
}

func (s *CreateYouhuiForOrderResponseBody) SetMessage(v string) *CreateYouhuiForOrderResponseBody {
	s.Message = &v
	return s
}

func (s *CreateYouhuiForOrderResponseBody) SetRequestId(v string) *CreateYouhuiForOrderResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateYouhuiForOrderResponseBody) SetYouhuiId(v string) *CreateYouhuiForOrderResponseBody {
	s.YouhuiId = &v
	return s
}

type CreateYouhuiForOrderResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateYouhuiForOrderResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateYouhuiForOrderResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateYouhuiForOrderResponse) GoString() string {
	return s.String()
}

func (s *CreateYouhuiForOrderResponse) SetHeaders(v map[string]*string) *CreateYouhuiForOrderResponse {
	s.Headers = v
	return s
}

func (s *CreateYouhuiForOrderResponse) SetStatusCode(v int32) *CreateYouhuiForOrderResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateYouhuiForOrderResponse) SetBody(v *CreateYouhuiForOrderResponseBody) *CreateYouhuiForOrderResponse {
	s.Body = v
	return s
}

type DeleteADSettingRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the instance. You can call the [DescribeDBInstances](~~26232~~) operation to query the instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DeleteADSettingRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteADSettingRequest) GoString() string {
	return s.String()
}

func (s *DeleteADSettingRequest) SetClientToken(v string) *DeleteADSettingRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteADSettingRequest) SetDBInstanceId(v string) *DeleteADSettingRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DeleteADSettingRequest) SetOwnerId(v int64) *DeleteADSettingRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteADSettingRequest) SetRegionId(v string) *DeleteADSettingRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteADSettingRequest) SetResourceOwnerAccount(v string) *DeleteADSettingRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteADSettingRequest) SetResourceOwnerId(v int64) *DeleteADSettingRequest {
	s.ResourceOwnerId = &v
	return s
}

type DeleteADSettingResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteADSettingResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteADSettingResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteADSettingResponseBody) SetRequestId(v string) *DeleteADSettingResponseBody {
	s.RequestId = &v
	return s
}

type DeleteADSettingResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteADSettingResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteADSettingResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteADSettingResponse) GoString() string {
	return s.String()
}

func (s *DeleteADSettingResponse) SetHeaders(v map[string]*string) *DeleteADSettingResponse {
	s.Headers = v
	return s
}

func (s *DeleteADSettingResponse) SetStatusCode(v int32) *DeleteADSettingResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteADSettingResponse) SetBody(v *DeleteADSettingResponseBody) *DeleteADSettingResponse {
	s.Body = v
	return s
}

type DeleteAccountRequest struct {
	// The name of the account.
	AccountName *string `json:"AccountName,omitempty" xml:"AccountName,omitempty"`
	// The instance ID. You can call the [DescribeDBInstances](~~610396~~) operation to query the ID of the instance.
	DBInstanceId         *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DeleteAccountRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteAccountRequest) GoString() string {
	return s.String()
}

func (s *DeleteAccountRequest) SetAccountName(v string) *DeleteAccountRequest {
	s.AccountName = &v
	return s
}

func (s *DeleteAccountRequest) SetDBInstanceId(v string) *DeleteAccountRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DeleteAccountRequest) SetOwnerAccount(v string) *DeleteAccountRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteAccountRequest) SetOwnerId(v int64) *DeleteAccountRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteAccountRequest) SetResourceOwnerAccount(v string) *DeleteAccountRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteAccountRequest) SetResourceOwnerId(v int64) *DeleteAccountRequest {
	s.ResourceOwnerId = &v
	return s
}

type DeleteAccountResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteAccountResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteAccountResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteAccountResponseBody) SetRequestId(v string) *DeleteAccountResponseBody {
	s.RequestId = &v
	return s
}

type DeleteAccountResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteAccountResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteAccountResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteAccountResponse) GoString() string {
	return s.String()
}

func (s *DeleteAccountResponse) SetHeaders(v map[string]*string) *DeleteAccountResponse {
	s.Headers = v
	return s
}

func (s *DeleteAccountResponse) SetStatusCode(v int32) *DeleteAccountResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteAccountResponse) SetBody(v *DeleteAccountResponseBody) *DeleteAccountResponse {
	s.Body = v
	return s
}

type DeleteBackupRequest struct {
	// The ID of the backup set. You can call the [DescribeBackups](~~610544~~) operation to query backup set IDs. Separate multiple values with commas (,). You can specify a maximum of 100 values in a single request.
	//
	// >  You can only delete backup sets whose **StoreStatus** is **Enabled** in [DescribeBackups](~~610544~~).
	BackupId *string `json:"BackupId,omitempty" xml:"BackupId,omitempty"`
	// The ID of the instance. You can call the [DescribeDBInstances](~~610396~~) operation to query the ID of the instance.
	DBInstanceId         *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DeleteBackupRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteBackupRequest) GoString() string {
	return s.String()
}

func (s *DeleteBackupRequest) SetBackupId(v string) *DeleteBackupRequest {
	s.BackupId = &v
	return s
}

func (s *DeleteBackupRequest) SetDBInstanceId(v string) *DeleteBackupRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DeleteBackupRequest) SetOwnerAccount(v string) *DeleteBackupRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteBackupRequest) SetOwnerId(v int64) *DeleteBackupRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteBackupRequest) SetResourceOwnerAccount(v string) *DeleteBackupRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteBackupRequest) SetResourceOwnerId(v int64) *DeleteBackupRequest {
	s.ResourceOwnerId = &v
	return s
}

type DeleteBackupResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteBackupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteBackupResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteBackupResponseBody) SetRequestId(v string) *DeleteBackupResponseBody {
	s.RequestId = &v
	return s
}

type DeleteBackupResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteBackupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteBackupResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteBackupResponse) GoString() string {
	return s.String()
}

func (s *DeleteBackupResponse) SetHeaders(v map[string]*string) *DeleteBackupResponse {
	s.Headers = v
	return s
}

func (s *DeleteBackupResponse) SetStatusCode(v int32) *DeleteBackupResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteBackupResponse) SetBody(v *DeleteBackupResponseBody) *DeleteBackupResponse {
	s.Body = v
	return s
}

type DeleteBackupFileRequest struct {
	// The ID of the backup set. You can specify the IDs of up to 100 backup sets at a time. Separate the IDs with commas (,).
	//
	// >
	//
	// *   Only the IDs of the backup sets for the database is supported.
	//
	// *   You can call the [DescribeBackups](~~26273~~) operation to query the IDs of backup sets.
	BackupId *string `json:"BackupId,omitempty" xml:"BackupId,omitempty"`
	// Specifies whether to delete the backup sets that are generated before the specified point in time. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	BackupTime *string `json:"BackupTime,omitempty" xml:"BackupTime,omitempty"`
	// The instance ID. You can call the [DescribeDBInstances](~~610396~~) operation to query the ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The name of the database.
	DBName  *string `json:"DBName,omitempty" xml:"DBName,omitempty"`
	OwnerId *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the instance. You can call the [DescribeDBInstanceAttribute](~~610394~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DeleteBackupFileRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteBackupFileRequest) GoString() string {
	return s.String()
}

func (s *DeleteBackupFileRequest) SetBackupId(v string) *DeleteBackupFileRequest {
	s.BackupId = &v
	return s
}

func (s *DeleteBackupFileRequest) SetBackupTime(v string) *DeleteBackupFileRequest {
	s.BackupTime = &v
	return s
}

func (s *DeleteBackupFileRequest) SetDBInstanceId(v string) *DeleteBackupFileRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DeleteBackupFileRequest) SetDBName(v string) *DeleteBackupFileRequest {
	s.DBName = &v
	return s
}

func (s *DeleteBackupFileRequest) SetOwnerId(v int64) *DeleteBackupFileRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteBackupFileRequest) SetRegionId(v string) *DeleteBackupFileRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteBackupFileRequest) SetResourceOwnerAccount(v string) *DeleteBackupFileRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteBackupFileRequest) SetResourceOwnerId(v int64) *DeleteBackupFileRequest {
	s.ResourceOwnerId = &v
	return s
}

type DeleteBackupFileResponseBody struct {
	// An array that consists of the IDs of deleted backup sets.
	DeletedBaksetIds *DeleteBackupFileResponseBodyDeletedBaksetIds `json:"DeletedBaksetIds,omitempty" xml:"DeletedBaksetIds,omitempty" type:"Struct"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteBackupFileResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteBackupFileResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteBackupFileResponseBody) SetDeletedBaksetIds(v *DeleteBackupFileResponseBodyDeletedBaksetIds) *DeleteBackupFileResponseBody {
	s.DeletedBaksetIds = v
	return s
}

func (s *DeleteBackupFileResponseBody) SetRequestId(v string) *DeleteBackupFileResponseBody {
	s.RequestId = &v
	return s
}

type DeleteBackupFileResponseBodyDeletedBaksetIds struct {
	DeletedBaksetIds []*int32 `json:"DeletedBaksetIds,omitempty" xml:"DeletedBaksetIds,omitempty" type:"Repeated"`
}

func (s DeleteBackupFileResponseBodyDeletedBaksetIds) String() string {
	return tea.Prettify(s)
}

func (s DeleteBackupFileResponseBodyDeletedBaksetIds) GoString() string {
	return s.String()
}

func (s *DeleteBackupFileResponseBodyDeletedBaksetIds) SetDeletedBaksetIds(v []*int32) *DeleteBackupFileResponseBodyDeletedBaksetIds {
	s.DeletedBaksetIds = v
	return s
}

type DeleteBackupFileResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteBackupFileResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteBackupFileResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteBackupFileResponse) GoString() string {
	return s.String()
}

func (s *DeleteBackupFileResponse) SetHeaders(v map[string]*string) *DeleteBackupFileResponse {
	s.Headers = v
	return s
}

func (s *DeleteBackupFileResponse) SetStatusCode(v int32) *DeleteBackupFileResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteBackupFileResponse) SetBody(v *DeleteBackupFileResponseBody) *DeleteBackupFileResponse {
	s.Body = v
	return s
}

type DeleteDBInstanceRequest struct {
	// The instance ID. You can call the DescribeDBInstances operation to query the instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The policy that is used to retain archived backup files if the instance is released. Default value: None. Valid values:
	//
	// *   **None**: No archived backup files are retained.
	// *   **Lastest**: Only the last archived backup file is retained.
	// *   **All**: All archived backup files are retained.
	//
	// > This parameter takes effect only when **BackupPolicyMode** is set to **DataBackupPolicy**.
	ReleasedKeepPolicy   *string `json:"ReleasedKeepPolicy,omitempty" xml:"ReleasedKeepPolicy,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DeleteDBInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteDBInstanceRequest) GoString() string {
	return s.String()
}

func (s *DeleteDBInstanceRequest) SetDBInstanceId(v string) *DeleteDBInstanceRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DeleteDBInstanceRequest) SetOwnerAccount(v string) *DeleteDBInstanceRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteDBInstanceRequest) SetOwnerId(v int64) *DeleteDBInstanceRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteDBInstanceRequest) SetReleasedKeepPolicy(v string) *DeleteDBInstanceRequest {
	s.ReleasedKeepPolicy = &v
	return s
}

func (s *DeleteDBInstanceRequest) SetResourceOwnerAccount(v string) *DeleteDBInstanceRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteDBInstanceRequest) SetResourceOwnerId(v int64) *DeleteDBInstanceRequest {
	s.ResourceOwnerId = &v
	return s
}

type DeleteDBInstanceResponseBody struct {
	// The region ID of the instance. You can call the [DescribeDBInstanceAttribute](~~26231~~) operation to query region ID of the instance.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteDBInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteDBInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteDBInstanceResponseBody) SetRegionId(v string) *DeleteDBInstanceResponseBody {
	s.RegionId = &v
	return s
}

func (s *DeleteDBInstanceResponseBody) SetRequestId(v string) *DeleteDBInstanceResponseBody {
	s.RequestId = &v
	return s
}

type DeleteDBInstanceResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteDBInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteDBInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteDBInstanceResponse) GoString() string {
	return s.String()
}

func (s *DeleteDBInstanceResponse) SetHeaders(v map[string]*string) *DeleteDBInstanceResponse {
	s.Headers = v
	return s
}

func (s *DeleteDBInstanceResponse) SetStatusCode(v int32) *DeleteDBInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteDBInstanceResponse) SetBody(v *DeleteDBInstanceResponseBody) *DeleteDBInstanceResponse {
	s.Body = v
	return s
}

type DeleteDBInstanceEndpointRequest struct {
	// The client token that is used to ensure the idempotency of requests. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The endpoint ID of the instance. You can call the [DescribeDBInstanceEndpoints](~~610488~~) operation to query the endpoint ID of the instance.
	DBInstanceEndpointId *string `json:"DBInstanceEndpointId,omitempty" xml:"DBInstanceEndpointId,omitempty"`
	// The instance ID. You can call the [DescribeDBInstances](~~610396~~) operation to query the ID of the instance.
	DBInstanceId    *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	ResourceOwnerId *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DeleteDBInstanceEndpointRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteDBInstanceEndpointRequest) GoString() string {
	return s.String()
}

func (s *DeleteDBInstanceEndpointRequest) SetClientToken(v string) *DeleteDBInstanceEndpointRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteDBInstanceEndpointRequest) SetDBInstanceEndpointId(v string) *DeleteDBInstanceEndpointRequest {
	s.DBInstanceEndpointId = &v
	return s
}

func (s *DeleteDBInstanceEndpointRequest) SetDBInstanceId(v string) *DeleteDBInstanceEndpointRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DeleteDBInstanceEndpointRequest) SetResourceOwnerId(v int64) *DeleteDBInstanceEndpointRequest {
	s.ResourceOwnerId = &v
	return s
}

type DeleteDBInstanceEndpointResponseBody struct {
	// The data returned.
	Data *DeleteDBInstanceEndpointResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteDBInstanceEndpointResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteDBInstanceEndpointResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteDBInstanceEndpointResponseBody) SetData(v *DeleteDBInstanceEndpointResponseBodyData) *DeleteDBInstanceEndpointResponseBody {
	s.Data = v
	return s
}

func (s *DeleteDBInstanceEndpointResponseBody) SetRequestId(v string) *DeleteDBInstanceEndpointResponseBody {
	s.RequestId = &v
	return s
}

type DeleteDBInstanceEndpointResponseBodyData struct {
	// The endpoint ID of the instance.
	DBInstanceEndpointId *string `json:"DBInstanceEndpointId,omitempty" xml:"DBInstanceEndpointId,omitempty"`
	// The ID of the instance.
	DBInstanceName *string `json:"DBInstanceName,omitempty" xml:"DBInstanceName,omitempty"`
}

func (s DeleteDBInstanceEndpointResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s DeleteDBInstanceEndpointResponseBodyData) GoString() string {
	return s.String()
}

func (s *DeleteDBInstanceEndpointResponseBodyData) SetDBInstanceEndpointId(v string) *DeleteDBInstanceEndpointResponseBodyData {
	s.DBInstanceEndpointId = &v
	return s
}

func (s *DeleteDBInstanceEndpointResponseBodyData) SetDBInstanceName(v string) *DeleteDBInstanceEndpointResponseBodyData {
	s.DBInstanceName = &v
	return s
}

type DeleteDBInstanceEndpointResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteDBInstanceEndpointResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteDBInstanceEndpointResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteDBInstanceEndpointResponse) GoString() string {
	return s.String()
}

func (s *DeleteDBInstanceEndpointResponse) SetHeaders(v map[string]*string) *DeleteDBInstanceEndpointResponse {
	s.Headers = v
	return s
}

func (s *DeleteDBInstanceEndpointResponse) SetStatusCode(v int32) *DeleteDBInstanceEndpointResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteDBInstanceEndpointResponse) SetBody(v *DeleteDBInstanceEndpointResponseBody) *DeleteDBInstanceEndpointResponse {
	s.Body = v
	return s
}

type DeleteDBInstanceEndpointAddressRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests.
	//
	// The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The public endpoint.
	ConnectionString *string `json:"ConnectionString,omitempty" xml:"ConnectionString,omitempty"`
	// The endpoint ID of the instance. You can call the [DescribeDBInstanceEndpoints](~~610488~~) operation to query the endpoint ID of the instance.
	DBInstanceEndpointId *string `json:"DBInstanceEndpointId,omitempty" xml:"DBInstanceEndpointId,omitempty"`
	// The ID of the instance. You can call the [DescribeDBInstances](~~610396~~) operation to query the ID of the instance.
	DBInstanceId    *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	ResourceOwnerId *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DeleteDBInstanceEndpointAddressRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteDBInstanceEndpointAddressRequest) GoString() string {
	return s.String()
}

func (s *DeleteDBInstanceEndpointAddressRequest) SetClientToken(v string) *DeleteDBInstanceEndpointAddressRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteDBInstanceEndpointAddressRequest) SetConnectionString(v string) *DeleteDBInstanceEndpointAddressRequest {
	s.ConnectionString = &v
	return s
}

func (s *DeleteDBInstanceEndpointAddressRequest) SetDBInstanceEndpointId(v string) *DeleteDBInstanceEndpointAddressRequest {
	s.DBInstanceEndpointId = &v
	return s
}

func (s *DeleteDBInstanceEndpointAddressRequest) SetDBInstanceId(v string) *DeleteDBInstanceEndpointAddressRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DeleteDBInstanceEndpointAddressRequest) SetResourceOwnerId(v int64) *DeleteDBInstanceEndpointAddressRequest {
	s.ResourceOwnerId = &v
	return s
}

type DeleteDBInstanceEndpointAddressResponseBody struct {
	// The returned data.
	Data *DeleteDBInstanceEndpointAddressResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteDBInstanceEndpointAddressResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteDBInstanceEndpointAddressResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteDBInstanceEndpointAddressResponseBody) SetData(v *DeleteDBInstanceEndpointAddressResponseBodyData) *DeleteDBInstanceEndpointAddressResponseBody {
	s.Data = v
	return s
}

func (s *DeleteDBInstanceEndpointAddressResponseBody) SetRequestId(v string) *DeleteDBInstanceEndpointAddressResponseBody {
	s.RequestId = &v
	return s
}

type DeleteDBInstanceEndpointAddressResponseBodyData struct {
	// The endpoint ID of the instance.
	DBInstanceEndpointId *string `json:"DBInstanceEndpointId,omitempty" xml:"DBInstanceEndpointId,omitempty"`
	// The ID of the instance.
	DBInstanceName *string `json:"DBInstanceName,omitempty" xml:"DBInstanceName,omitempty"`
}

func (s DeleteDBInstanceEndpointAddressResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s DeleteDBInstanceEndpointAddressResponseBodyData) GoString() string {
	return s.String()
}

func (s *DeleteDBInstanceEndpointAddressResponseBodyData) SetDBInstanceEndpointId(v string) *DeleteDBInstanceEndpointAddressResponseBodyData {
	s.DBInstanceEndpointId = &v
	return s
}

func (s *DeleteDBInstanceEndpointAddressResponseBodyData) SetDBInstanceName(v string) *DeleteDBInstanceEndpointAddressResponseBodyData {
	s.DBInstanceName = &v
	return s
}

type DeleteDBInstanceEndpointAddressResponse struct {
	Headers    map[string]*string                           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteDBInstanceEndpointAddressResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteDBInstanceEndpointAddressResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteDBInstanceEndpointAddressResponse) GoString() string {
	return s.String()
}

func (s *DeleteDBInstanceEndpointAddressResponse) SetHeaders(v map[string]*string) *DeleteDBInstanceEndpointAddressResponse {
	s.Headers = v
	return s
}

func (s *DeleteDBInstanceEndpointAddressResponse) SetStatusCode(v int32) *DeleteDBInstanceEndpointAddressResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteDBInstanceEndpointAddressResponse) SetBody(v *DeleteDBInstanceEndpointAddressResponseBody) *DeleteDBInstanceEndpointAddressResponse {
	s.Body = v
	return s
}

type DeleteDBNodesRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that it is unique among different requests.
	//
	// The token can only contain ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The instance ID. You can call the [DescribeDBInstances](~~610396~~) operation to query the ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The node IDs.
	DBNodeId     []*string `json:"DBNodeId,omitempty" xml:"DBNodeId,omitempty" type:"Repeated"`
	OwnerAccount *string   `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64    `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the resource group. You can call the [DescribeDBInstanceAttribute](~~610394~~) operation to obtain the ID of the resource group.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DeleteDBNodesRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteDBNodesRequest) GoString() string {
	return s.String()
}

func (s *DeleteDBNodesRequest) SetClientToken(v string) *DeleteDBNodesRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteDBNodesRequest) SetDBInstanceId(v string) *DeleteDBNodesRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DeleteDBNodesRequest) SetDBNodeId(v []*string) *DeleteDBNodesRequest {
	s.DBNodeId = v
	return s
}

func (s *DeleteDBNodesRequest) SetOwnerAccount(v string) *DeleteDBNodesRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteDBNodesRequest) SetOwnerId(v int64) *DeleteDBNodesRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteDBNodesRequest) SetResourceGroupId(v string) *DeleteDBNodesRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DeleteDBNodesRequest) SetResourceOwnerAccount(v string) *DeleteDBNodesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteDBNodesRequest) SetResourceOwnerId(v int64) *DeleteDBNodesRequest {
	s.ResourceOwnerId = &v
	return s
}

type DeleteDBNodesShrinkRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that it is unique among different requests.
	//
	// The token can only contain ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The instance ID. You can call the [DescribeDBInstances](~~610396~~) operation to query the ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The node IDs.
	DBNodeIdShrink *string `json:"DBNodeId,omitempty" xml:"DBNodeId,omitempty"`
	OwnerAccount   *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId        *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the resource group. You can call the [DescribeDBInstanceAttribute](~~610394~~) operation to obtain the ID of the resource group.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DeleteDBNodesShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteDBNodesShrinkRequest) GoString() string {
	return s.String()
}

func (s *DeleteDBNodesShrinkRequest) SetClientToken(v string) *DeleteDBNodesShrinkRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteDBNodesShrinkRequest) SetDBInstanceId(v string) *DeleteDBNodesShrinkRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DeleteDBNodesShrinkRequest) SetDBNodeIdShrink(v string) *DeleteDBNodesShrinkRequest {
	s.DBNodeIdShrink = &v
	return s
}

func (s *DeleteDBNodesShrinkRequest) SetOwnerAccount(v string) *DeleteDBNodesShrinkRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteDBNodesShrinkRequest) SetOwnerId(v int64) *DeleteDBNodesShrinkRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteDBNodesShrinkRequest) SetResourceGroupId(v string) *DeleteDBNodesShrinkRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DeleteDBNodesShrinkRequest) SetResourceOwnerAccount(v string) *DeleteDBNodesShrinkRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteDBNodesShrinkRequest) SetResourceOwnerId(v int64) *DeleteDBNodesShrinkRequest {
	s.ResourceOwnerId = &v
	return s
}

type DeleteDBNodesResponseBody struct {
	// The ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The ID of the order.
	OrderId *int64 `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteDBNodesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteDBNodesResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteDBNodesResponseBody) SetDBInstanceId(v string) *DeleteDBNodesResponseBody {
	s.DBInstanceId = &v
	return s
}

func (s *DeleteDBNodesResponseBody) SetOrderId(v int64) *DeleteDBNodesResponseBody {
	s.OrderId = &v
	return s
}

func (s *DeleteDBNodesResponseBody) SetRequestId(v string) *DeleteDBNodesResponseBody {
	s.RequestId = &v
	return s
}

type DeleteDBNodesResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteDBNodesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteDBNodesResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteDBNodesResponse) GoString() string {
	return s.String()
}

func (s *DeleteDBNodesResponse) SetHeaders(v map[string]*string) *DeleteDBNodesResponse {
	s.Headers = v
	return s
}

func (s *DeleteDBNodesResponse) SetStatusCode(v int32) *DeleteDBNodesResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteDBNodesResponse) SetBody(v *DeleteDBNodesResponseBody) *DeleteDBNodesResponse {
	s.Body = v
	return s
}

type DeleteDBProxyEndpointAddressRequest struct {
	// The instance ID. You can call the [DescribeDBInstances](~~610396~~) operation to query the ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The network type of the proxy endpoint. Valid values:
	//
	// *   **Public**: Internet
	// *   **VPC**: virtual private cloud (VPC)
	// *   **Classic**: classic network
	//
	// If the instance runs MySQL, the default value of this parameter is **Classic**.
	//
	// > If the instance runs PostgreSQL, you must set this parameter to **Public** or **VPC**.
	DBProxyConnectStringNetType *string `json:"DBProxyConnectStringNetType,omitempty" xml:"DBProxyConnectStringNetType,omitempty"`
	// The ID of the proxy endpoint. You can call the [DescribeDBProxyEndpoint](~~610507~~) operation to query the ID of the proxy endpoint.
	DBProxyEndpointId *string `json:"DBProxyEndpointId,omitempty" xml:"DBProxyEndpointId,omitempty"`
	// A reserved parameter. You do not need to specify this parameter.
	DBProxyEngineType *string `json:"DBProxyEngineType,omitempty" xml:"DBProxyEngineType,omitempty"`
	// The region ID. You can call the [DescribeRegions](~~610399~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DeleteDBProxyEndpointAddressRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteDBProxyEndpointAddressRequest) GoString() string {
	return s.String()
}

func (s *DeleteDBProxyEndpointAddressRequest) SetDBInstanceId(v string) *DeleteDBProxyEndpointAddressRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DeleteDBProxyEndpointAddressRequest) SetDBProxyConnectStringNetType(v string) *DeleteDBProxyEndpointAddressRequest {
	s.DBProxyConnectStringNetType = &v
	return s
}

func (s *DeleteDBProxyEndpointAddressRequest) SetDBProxyEndpointId(v string) *DeleteDBProxyEndpointAddressRequest {
	s.DBProxyEndpointId = &v
	return s
}

func (s *DeleteDBProxyEndpointAddressRequest) SetDBProxyEngineType(v string) *DeleteDBProxyEndpointAddressRequest {
	s.DBProxyEngineType = &v
	return s
}

func (s *DeleteDBProxyEndpointAddressRequest) SetRegionId(v string) *DeleteDBProxyEndpointAddressRequest {
	s.RegionId = &v
	return s
}

type DeleteDBProxyEndpointAddressResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteDBProxyEndpointAddressResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteDBProxyEndpointAddressResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteDBProxyEndpointAddressResponseBody) SetRequestId(v string) *DeleteDBProxyEndpointAddressResponseBody {
	s.RequestId = &v
	return s
}

type DeleteDBProxyEndpointAddressResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteDBProxyEndpointAddressResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteDBProxyEndpointAddressResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteDBProxyEndpointAddressResponse) GoString() string {
	return s.String()
}

func (s *DeleteDBProxyEndpointAddressResponse) SetHeaders(v map[string]*string) *DeleteDBProxyEndpointAddressResponse {
	s.Headers = v
	return s
}

func (s *DeleteDBProxyEndpointAddressResponse) SetStatusCode(v int32) *DeleteDBProxyEndpointAddressResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteDBProxyEndpointAddressResponse) SetBody(v *DeleteDBProxyEndpointAddressResponseBody) *DeleteDBProxyEndpointAddressResponse {
	s.Body = v
	return s
}

type DeleteDatabaseRequest struct {
	// The instance ID. You can call the [DescribeDBInstances](~~610396~~) operation to query the instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The name of the database.
	DBName          *string `json:"DBName,omitempty" xml:"DBName,omitempty"`
	ResourceOwnerId *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DeleteDatabaseRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteDatabaseRequest) GoString() string {
	return s.String()
}

func (s *DeleteDatabaseRequest) SetDBInstanceId(v string) *DeleteDatabaseRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DeleteDatabaseRequest) SetDBName(v string) *DeleteDatabaseRequest {
	s.DBName = &v
	return s
}

func (s *DeleteDatabaseRequest) SetResourceOwnerId(v int64) *DeleteDatabaseRequest {
	s.ResourceOwnerId = &v
	return s
}

type DeleteDatabaseResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteDatabaseResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteDatabaseResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteDatabaseResponseBody) SetRequestId(v string) *DeleteDatabaseResponseBody {
	s.RequestId = &v
	return s
}

type DeleteDatabaseResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteDatabaseResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteDatabaseResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteDatabaseResponse) GoString() string {
	return s.String()
}

func (s *DeleteDatabaseResponse) SetHeaders(v map[string]*string) *DeleteDatabaseResponse {
	s.Headers = v
	return s
}

func (s *DeleteDatabaseResponse) SetStatusCode(v int32) *DeleteDatabaseResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteDatabaseResponse) SetBody(v *DeleteDatabaseResponseBody) *DeleteDatabaseResponse {
	s.Body = v
	return s
}

type DeleteGadInstanceRequest struct {
	// The ID of the global active database cluster. You can call the [DescribeGadInstances](~~330105~~) operation to query the ID of the global active database cluster.
	GadInstanceName *string `json:"GadInstanceName,omitempty" xml:"GadInstanceName,omitempty"`
	// The region ID of the central node of the global active database cluster. You can call the [DescribeRegions](~~330105~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group. You can call the [DescribeDBInstanceAttribute](~~610394~~) operation to obtain the ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
}

func (s DeleteGadInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteGadInstanceRequest) GoString() string {
	return s.String()
}

func (s *DeleteGadInstanceRequest) SetGadInstanceName(v string) *DeleteGadInstanceRequest {
	s.GadInstanceName = &v
	return s
}

func (s *DeleteGadInstanceRequest) SetRegionId(v string) *DeleteGadInstanceRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteGadInstanceRequest) SetResourceGroupId(v string) *DeleteGadInstanceRequest {
	s.ResourceGroupId = &v
	return s
}

type DeleteGadInstanceResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteGadInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteGadInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteGadInstanceResponseBody) SetRequestId(v string) *DeleteGadInstanceResponseBody {
	s.RequestId = &v
	return s
}

type DeleteGadInstanceResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteGadInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteGadInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteGadInstanceResponse) GoString() string {
	return s.String()
}

func (s *DeleteGadInstanceResponse) SetHeaders(v map[string]*string) *DeleteGadInstanceResponse {
	s.Headers = v
	return s
}

func (s *DeleteGadInstanceResponse) SetStatusCode(v int32) *DeleteGadInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteGadInstanceResponse) SetBody(v *DeleteGadInstanceResponseBody) *DeleteGadInstanceResponse {
	s.Body = v
	return s
}

type DeleteParameterGroupRequest struct {
	OwnerId *int64 `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the parameter template. You can call the [DescribeParameterGroups](~~144491~~) operation to query the ID of the parameter template.
	ParameterGroupId *string `json:"ParameterGroupId,omitempty" xml:"ParameterGroupId,omitempty"`
	// The ID of the region. You can call the [DescribeRegions](~~26243~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The resource group ID. You can call the [DescribeDBInstanceAttribute](~~610394~~) to obtain the ID of the resource group.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DeleteParameterGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteParameterGroupRequest) GoString() string {
	return s.String()
}

func (s *DeleteParameterGroupRequest) SetOwnerId(v int64) *DeleteParameterGroupRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteParameterGroupRequest) SetParameterGroupId(v string) *DeleteParameterGroupRequest {
	s.ParameterGroupId = &v
	return s
}

func (s *DeleteParameterGroupRequest) SetRegionId(v string) *DeleteParameterGroupRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteParameterGroupRequest) SetResourceGroupId(v string) *DeleteParameterGroupRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DeleteParameterGroupRequest) SetResourceOwnerAccount(v string) *DeleteParameterGroupRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteParameterGroupRequest) SetResourceOwnerId(v int64) *DeleteParameterGroupRequest {
	s.ResourceOwnerId = &v
	return s
}

type DeleteParameterGroupResponseBody struct {
	// The ID of the parameter template.
	ParameterGroupId *string `json:"ParameterGroupId,omitempty" xml:"ParameterGroupId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteParameterGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteParameterGroupResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteParameterGroupResponseBody) SetParameterGroupId(v string) *DeleteParameterGroupResponseBody {
	s.ParameterGroupId = &v
	return s
}

func (s *DeleteParameterGroupResponseBody) SetRequestId(v string) *DeleteParameterGroupResponseBody {
	s.RequestId = &v
	return s
}

type DeleteParameterGroupResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteParameterGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteParameterGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteParameterGroupResponse) GoString() string {
	return s.String()
}

func (s *DeleteParameterGroupResponse) SetHeaders(v map[string]*string) *DeleteParameterGroupResponse {
	s.Headers = v
	return s
}

func (s *DeleteParameterGroupResponse) SetStatusCode(v int32) *DeleteParameterGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteParameterGroupResponse) SetBody(v *DeleteParameterGroupResponseBody) *DeleteParameterGroupResponse {
	s.Body = v
	return s
}

type DeletePostgresExtensionsRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The instance ID. You can call the [DescribeDBInstances](~~610396~~) operation to query the ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The database on which the extension is installed. If you want to specify multiple databases, separate the databases with commas (,).
	DBNames *string `json:"DBNames,omitempty" xml:"DBNames,omitempty"`
	// The name of the extension. If you want to specify multiple extensions, separate the extension names with commas (,).
	Extensions   *string `json:"Extensions,omitempty" xml:"Extensions,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DeletePostgresExtensionsRequest) String() string {
	return tea.Prettify(s)
}

func (s DeletePostgresExtensionsRequest) GoString() string {
	return s.String()
}

func (s *DeletePostgresExtensionsRequest) SetClientToken(v string) *DeletePostgresExtensionsRequest {
	s.ClientToken = &v
	return s
}

func (s *DeletePostgresExtensionsRequest) SetDBInstanceId(v string) *DeletePostgresExtensionsRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DeletePostgresExtensionsRequest) SetDBNames(v string) *DeletePostgresExtensionsRequest {
	s.DBNames = &v
	return s
}

func (s *DeletePostgresExtensionsRequest) SetExtensions(v string) *DeletePostgresExtensionsRequest {
	s.Extensions = &v
	return s
}

func (s *DeletePostgresExtensionsRequest) SetOwnerAccount(v string) *DeletePostgresExtensionsRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeletePostgresExtensionsRequest) SetOwnerId(v int64) *DeletePostgresExtensionsRequest {
	s.OwnerId = &v
	return s
}

func (s *DeletePostgresExtensionsRequest) SetResourceGroupId(v string) *DeletePostgresExtensionsRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DeletePostgresExtensionsRequest) SetResourceOwnerAccount(v string) *DeletePostgresExtensionsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeletePostgresExtensionsRequest) SetResourceOwnerId(v int64) *DeletePostgresExtensionsRequest {
	s.ResourceOwnerId = &v
	return s
}

type DeletePostgresExtensionsResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeletePostgresExtensionsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeletePostgresExtensionsResponseBody) GoString() string {
	return s.String()
}

func (s *DeletePostgresExtensionsResponseBody) SetRequestId(v string) *DeletePostgresExtensionsResponseBody {
	s.RequestId = &v
	return s
}

type DeletePostgresExtensionsResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeletePostgresExtensionsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeletePostgresExtensionsResponse) String() string {
	return tea.Prettify(s)
}

func (s DeletePostgresExtensionsResponse) GoString() string {
	return s.String()
}

func (s *DeletePostgresExtensionsResponse) SetHeaders(v map[string]*string) *DeletePostgresExtensionsResponse {
	s.Headers = v
	return s
}

func (s *DeletePostgresExtensionsResponse) SetStatusCode(v int32) *DeletePostgresExtensionsResponse {
	s.StatusCode = &v
	return s
}

func (s *DeletePostgresExtensionsResponse) SetBody(v *DeletePostgresExtensionsResponseBody) *DeletePostgresExtensionsResponse {
	s.Body = v
	return s
}

type DeleteSecretRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the instance. You can call the [DescribeDBInstances](~~26232~~) operation to query the ID of the instance.
	//
	// > If you specify this parameter, you must also specify **SecretName**.
	DbInstanceId *string `json:"DbInstanceId,omitempty" xml:"DbInstanceId,omitempty"`
	// The engine of the database.
	//
	// > Only MySQL is supported.
	Engine  *string `json:"Engine,omitempty" xml:"Engine,omitempty"`
	OwnerId *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the instance. You can call the [DescribeRegions](~~446624~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group. You can call the [DescribeDBInstanceAttribute](~~610394~~) operation to obtain the ID of the resource group.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The Alibaba Cloud Resource Name (ARN) of the credential for the created Data API account. You can call the [CreateSecret](~~446607~~) operation to obtain the value of this parameter.
	//
	// > You must specify one of **SecretName** and SecretArn.
	SecretArn *string `json:"SecretArn,omitempty" xml:"SecretArn,omitempty"`
	// The name of the credential.
	//
	// >
	//
	// *   You must specify one of **SecretArn** and SecretName.
	//
	// *   If you specify this parameter, you must also specify **DbInstanceId**.
	SecretName *string `json:"SecretName,omitempty" xml:"SecretName,omitempty"`
}

func (s DeleteSecretRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteSecretRequest) GoString() string {
	return s.String()
}

func (s *DeleteSecretRequest) SetClientToken(v string) *DeleteSecretRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteSecretRequest) SetDbInstanceId(v string) *DeleteSecretRequest {
	s.DbInstanceId = &v
	return s
}

func (s *DeleteSecretRequest) SetEngine(v string) *DeleteSecretRequest {
	s.Engine = &v
	return s
}

func (s *DeleteSecretRequest) SetOwnerId(v int64) *DeleteSecretRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteSecretRequest) SetRegionId(v string) *DeleteSecretRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteSecretRequest) SetResourceGroupId(v string) *DeleteSecretRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DeleteSecretRequest) SetResourceOwnerAccount(v string) *DeleteSecretRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteSecretRequest) SetResourceOwnerId(v int64) *DeleteSecretRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DeleteSecretRequest) SetSecretArn(v string) *DeleteSecretRequest {
	s.SecretArn = &v
	return s
}

func (s *DeleteSecretRequest) SetSecretName(v string) *DeleteSecretRequest {
	s.SecretName = &v
	return s
}

type DeleteSecretResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ARN of the credential for the Data API account.
	SecretArn *string `json:"SecretArn,omitempty" xml:"SecretArn,omitempty"`
	// The name of the credential.
	SecretName *string `json:"SecretName,omitempty" xml:"SecretName,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**
	// *   **false**
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteSecretResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteSecretResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteSecretResponseBody) SetRequestId(v string) *DeleteSecretResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteSecretResponseBody) SetSecretArn(v string) *DeleteSecretResponseBody {
	s.SecretArn = &v
	return s
}

func (s *DeleteSecretResponseBody) SetSecretName(v string) *DeleteSecretResponseBody {
	s.SecretName = &v
	return s
}

func (s *DeleteSecretResponseBody) SetSuccess(v bool) *DeleteSecretResponseBody {
	s.Success = &v
	return s
}

type DeleteSecretResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteSecretResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteSecretResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteSecretResponse) GoString() string {
	return s.String()
}

func (s *DeleteSecretResponse) SetHeaders(v map[string]*string) *DeleteSecretResponse {
	s.Headers = v
	return s
}

func (s *DeleteSecretResponse) SetStatusCode(v int32) *DeleteSecretResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteSecretResponse) SetBody(v *DeleteSecretResponseBody) *DeleteSecretResponse {
	s.Body = v
	return s
}

type DeleteSlotRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the instance. You can call the [DescribeDBInstances](~~26232~~) operation to query the IDs of instances.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the resource group. You can leave this parameter empty.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The name of the replication slot. You can call the [DescribeSlots](~~613399~~) operation to query the name of the replication slot.
	SlotName *string `json:"SlotName,omitempty" xml:"SlotName,omitempty"`
	// The status of the replication slot. You can call the [DescribeSlots](~~613399~~) operation to query the status of the replication slot. Valid values:
	//
	// *   ACTIVE
	// *   INACTIVE
	SlotStatus *string `json:"SlotStatus,omitempty" xml:"SlotStatus,omitempty"`
}

func (s DeleteSlotRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteSlotRequest) GoString() string {
	return s.String()
}

func (s *DeleteSlotRequest) SetClientToken(v string) *DeleteSlotRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteSlotRequest) SetDBInstanceId(v string) *DeleteSlotRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DeleteSlotRequest) SetOwnerAccount(v string) *DeleteSlotRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteSlotRequest) SetOwnerId(v int64) *DeleteSlotRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteSlotRequest) SetResourceGroupId(v string) *DeleteSlotRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DeleteSlotRequest) SetResourceOwnerAccount(v string) *DeleteSlotRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteSlotRequest) SetResourceOwnerId(v int64) *DeleteSlotRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DeleteSlotRequest) SetSlotName(v string) *DeleteSlotRequest {
	s.SlotName = &v
	return s
}

func (s *DeleteSlotRequest) SetSlotStatus(v string) *DeleteSlotRequest {
	s.SlotStatus = &v
	return s
}

type DeleteSlotResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The name of the replication slot.
	SlotName *string `json:"SlotName,omitempty" xml:"SlotName,omitempty"`
}

func (s DeleteSlotResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteSlotResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteSlotResponseBody) SetRequestId(v string) *DeleteSlotResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteSlotResponseBody) SetSlotName(v string) *DeleteSlotResponseBody {
	s.SlotName = &v
	return s
}

type DeleteSlotResponse struct {
	Headers    map[string]*string      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteSlotResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteSlotResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteSlotResponse) GoString() string {
	return s.String()
}

func (s *DeleteSlotResponse) SetHeaders(v map[string]*string) *DeleteSlotResponse {
	s.Headers = v
	return s
}

func (s *DeleteSlotResponse) SetStatusCode(v int32) *DeleteSlotResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteSlotResponse) SetBody(v *DeleteSlotResponseBody) *DeleteSlotResponse {
	s.Body = v
	return s
}

type DeleteUserBackupFileRequest struct {
	// The ID of the full backup file. You can call the [ListUserBackupFiles](~~257821~~) operation to query the ID of the file.
	BackupId *string `json:"BackupId,omitempty" xml:"BackupId,omitempty"`
	OwnerId  *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region. You can call the [DescribeRegions](~~26243~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group. You can call the [DescribeDBInstanceAttribute](~~610394~~) to obtain the ID of the resource group.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DeleteUserBackupFileRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteUserBackupFileRequest) GoString() string {
	return s.String()
}

func (s *DeleteUserBackupFileRequest) SetBackupId(v string) *DeleteUserBackupFileRequest {
	s.BackupId = &v
	return s
}

func (s *DeleteUserBackupFileRequest) SetOwnerId(v int64) *DeleteUserBackupFileRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteUserBackupFileRequest) SetRegionId(v string) *DeleteUserBackupFileRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteUserBackupFileRequest) SetResourceGroupId(v string) *DeleteUserBackupFileRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DeleteUserBackupFileRequest) SetResourceOwnerAccount(v string) *DeleteUserBackupFileRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteUserBackupFileRequest) SetResourceOwnerId(v int64) *DeleteUserBackupFileRequest {
	s.ResourceOwnerId = &v
	return s
}

type DeleteUserBackupFileResponseBody struct {
	// The ID of the deleted full backup file.
	BackupId *string `json:"BackupId,omitempty" xml:"BackupId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteUserBackupFileResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteUserBackupFileResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteUserBackupFileResponseBody) SetBackupId(v string) *DeleteUserBackupFileResponseBody {
	s.BackupId = &v
	return s
}

func (s *DeleteUserBackupFileResponseBody) SetRequestId(v string) *DeleteUserBackupFileResponseBody {
	s.RequestId = &v
	return s
}

type DeleteUserBackupFileResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteUserBackupFileResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteUserBackupFileResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteUserBackupFileResponse) GoString() string {
	return s.String()
}

func (s *DeleteUserBackupFileResponse) SetHeaders(v map[string]*string) *DeleteUserBackupFileResponse {
	s.Headers = v
	return s
}

func (s *DeleteUserBackupFileResponse) SetStatusCode(v int32) *DeleteUserBackupFileResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteUserBackupFileResponse) SetBody(v *DeleteUserBackupFileResponseBody) *DeleteUserBackupFileResponse {
	s.Body = v
	return s
}

type DescibeImportsFromDatabaseRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The instance ID. You can call the [DescribeDBInstances](~~610396~~) operation to query the ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The end of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm*Z format. The time must be in UTC.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The database engine of the instance. Set the value to **MySQL**
	Engine *string `json:"Engine,omitempty" xml:"Engine,omitempty"`
	// The ID of the migration task.
	ImportId     *int32  `json:"ImportId,omitempty" xml:"ImportId,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The page number. Valid values: any non-zero positive integer.
	//
	// Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Valid values:
	//
	// *   **30**
	// *   **50**
	// *   **100**
	//
	// Default value: **30**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the resource group. You can call the [DescribeDBInstanceAttribute](~~610394~~) operation to obtain the ID of the resource group.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm*Z format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescibeImportsFromDatabaseRequest) String() string {
	return tea.Prettify(s)
}

func (s DescibeImportsFromDatabaseRequest) GoString() string {
	return s.String()
}

func (s *DescibeImportsFromDatabaseRequest) SetClientToken(v string) *DescibeImportsFromDatabaseRequest {
	s.ClientToken = &v
	return s
}

func (s *DescibeImportsFromDatabaseRequest) SetDBInstanceId(v string) *DescibeImportsFromDatabaseRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DescibeImportsFromDatabaseRequest) SetEndTime(v string) *DescibeImportsFromDatabaseRequest {
	s.EndTime = &v
	return s
}

func (s *DescibeImportsFromDatabaseRequest) SetEngine(v string) *DescibeImportsFromDatabaseRequest {
	s.Engine = &v
	return s
}

func (s *DescibeImportsFromDatabaseRequest) SetImportId(v int32) *DescibeImportsFromDatabaseRequest {
	s.ImportId = &v
	return s
}

func (s *DescibeImportsFromDatabaseRequest) SetOwnerAccount(v string) *DescibeImportsFromDatabaseRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescibeImportsFromDatabaseRequest) SetOwnerId(v int64) *DescibeImportsFromDatabaseRequest {
	s.OwnerId = &v
	return s
}

func (s *DescibeImportsFromDatabaseRequest) SetPageNumber(v int32) *DescibeImportsFromDatabaseRequest {
	s.PageNumber = &v
	return s
}

func (s *DescibeImportsFromDatabaseRequest) SetPageSize(v int32) *DescibeImportsFromDatabaseRequest {
	s.PageSize = &v
	return s
}

func (s *DescibeImportsFromDatabaseRequest) SetResourceGroupId(v string) *DescibeImportsFromDatabaseRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescibeImportsFromDatabaseRequest) SetResourceOwnerAccount(v string) *DescibeImportsFromDatabaseRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescibeImportsFromDatabaseRequest) SetResourceOwnerId(v int64) *DescibeImportsFromDatabaseRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescibeImportsFromDatabaseRequest) SetStartTime(v string) *DescibeImportsFromDatabaseRequest {
	s.StartTime = &v
	return s
}

type DescibeImportsFromDatabaseResponseBody struct {
	// An array that consists of migration tasks.
	Items *DescibeImportsFromDatabaseResponseBodyItems `json:"Items,omitempty" xml:"Items,omitempty" type:"Struct"`
	// The page number.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries per page.
	PageRecordCount *int32 `json:"PageRecordCount,omitempty" xml:"PageRecordCount,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalRecordCount *int32 `json:"TotalRecordCount,omitempty" xml:"TotalRecordCount,omitempty"`
}

func (s DescibeImportsFromDatabaseResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescibeImportsFromDatabaseResponseBody) GoString() string {
	return s.String()
}

func (s *DescibeImportsFromDatabaseResponseBody) SetItems(v *DescibeImportsFromDatabaseResponseBodyItems) *DescibeImportsFromDatabaseResponseBody {
	s.Items = v
	return s
}

func (s *DescibeImportsFromDatabaseResponseBody) SetPageNumber(v int32) *DescibeImportsFromDatabaseResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescibeImportsFromDatabaseResponseBody) SetPageRecordCount(v int32) *DescibeImportsFromDatabaseResponseBody {
	s.PageRecordCount = &v
	return s
}

func (s *DescibeImportsFromDatabaseResponseBody) SetRequestId(v string) *DescibeImportsFromDatabaseResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescibeImportsFromDatabaseResponseBody) SetTotalRecordCount(v int32) *DescibeImportsFromDatabaseResponseBody {
	s.TotalRecordCount = &v
	return s
}

type DescibeImportsFromDatabaseResponseBodyItems struct {
	ImportResultFromDB []*DescibeImportsFromDatabaseResponseBodyItemsImportResultFromDB `json:"ImportResultFromDB,omitempty" xml:"ImportResultFromDB,omitempty" type:"Repeated"`
}

func (s DescibeImportsFromDatabaseResponseBodyItems) String() string {
	return tea.Prettify(s)
}

func (s DescibeImportsFromDatabaseResponseBodyItems) GoString() string {
	return s.String()
}

func (s *DescibeImportsFromDatabaseResponseBodyItems) SetImportResultFromDB(v []*DescibeImportsFromDatabaseResponseBodyItemsImportResultFromDB) *DescibeImportsFromDatabaseResponseBodyItems {
	s.ImportResultFromDB = v
	return s
}

type DescibeImportsFromDatabaseResponseBodyItemsImportResultFromDB struct {
	// The status of the migration task. Valid values:
	//
	// *   **NotStart**: The migration task has not started.
	// *   **FullExporting**: The migration task is exporting full data.
	// *   **FullImporting**: The migration task is importing full data.
	// *   **Success**: The migration task is successful.
	// *   **Failed**: The migration task fails.
	// *   **Canceled**: The migration task is canceled.
	// *   **Canceling**: The migration task is being canceled.
	// *   **IncrementalWaiting**: The migration task is waiting to synchronize incremental data.
	// *   **IncrementalImporting**: The migration task is synchronizing incremental data.
	// *   **StopSyncing**: The migration task stops synchronizing data.
	ImportDataStatus *string `json:"ImportDataStatus,omitempty" xml:"ImportDataStatus,omitempty"`
	// The description of the migration task.
	ImportDataStatusDescription *string `json:"ImportDataStatusDescription,omitempty" xml:"ImportDataStatusDescription,omitempty"`
	// The type of the migration task. Valid values:
	//
	// *   **Full**: full migration
	// *   **Incremental**: incremental migration
	ImportDataType *string `json:"ImportDataType,omitempty" xml:"ImportDataType,omitempty"`
	// The ID of the migration task.
	ImportId *int32 `json:"ImportId,omitempty" xml:"ImportId,omitempty"`
	// The time when the migration task synchronized incremental data. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	IncrementalImportingTime *string `json:"IncrementalImportingTime,omitempty" xml:"IncrementalImportingTime,omitempty"`
}

func (s DescibeImportsFromDatabaseResponseBodyItemsImportResultFromDB) String() string {
	return tea.Prettify(s)
}

func (s DescibeImportsFromDatabaseResponseBodyItemsImportResultFromDB) GoString() string {
	return s.String()
}

func (s *DescibeImportsFromDatabaseResponseBodyItemsImportResultFromDB) SetImportDataStatus(v string) *DescibeImportsFromDatabaseResponseBodyItemsImportResultFromDB {
	s.ImportDataStatus = &v
	return s
}

func (s *DescibeImportsFromDatabaseResponseBodyItemsImportResultFromDB) SetImportDataStatusDescription(v string) *DescibeImportsFromDatabaseResponseBodyItemsImportResultFromDB {
	s.ImportDataStatusDescription = &v
	return s
}

func (s *DescibeImportsFromDatabaseResponseBodyItemsImportResultFromDB) SetImportDataType(v string) *DescibeImportsFromDatabaseResponseBodyItemsImportResultFromDB {
	s.ImportDataType = &v
	return s
}

func (s *DescibeImportsFromDatabaseResponseBodyItemsImportResultFromDB) SetImportId(v int32) *DescibeImportsFromDatabaseResponseBodyItemsImportResultFromDB {
	s.ImportId = &v
	return s
}

func (s *DescibeImportsFromDatabaseResponseBodyItemsImportResultFromDB) SetIncrementalImportingTime(v string) *DescibeImportsFromDatabaseResponseBodyItemsImportResultFromDB {
	s.IncrementalImportingTime = &v
	return s
}

type DescibeImportsFromDatabaseResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescibeImportsFromDatabaseResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescibeImportsFromDatabaseResponse) String() string {
	return tea.Prettify(s)
}

func (s DescibeImportsFromDatabaseResponse) GoString() string {
	return s.String()
}

func (s *DescibeImportsFromDatabaseResponse) SetHeaders(v map[string]*string) *DescibeImportsFromDatabaseResponse {
	s.Headers = v
	return s
}

func (s *DescibeImportsFromDatabaseResponse) SetStatusCode(v int32) *DescibeImportsFromDatabaseResponse {
	s.StatusCode = &v
	return s
}

func (s *DescibeImportsFromDatabaseResponse) SetBody(v *DescibeImportsFromDatabaseResponseBody) *DescibeImportsFromDatabaseResponse {
	s.Body = v
	return s
}

type DescribeADInfoRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the generated token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The instance ID. You can call the [DescribeDBInstances](~~26232~~) operation to query the instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeADInfoRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeADInfoRequest) GoString() string {
	return s.String()
}

func (s *DescribeADInfoRequest) SetClientToken(v string) *DescribeADInfoRequest {
	s.ClientToken = &v
	return s
}

func (s *DescribeADInfoRequest) SetDBInstanceId(v string) *DescribeADInfoRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeADInfoRequest) SetOwnerId(v int64) *DescribeADInfoRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeADInfoRequest) SetRegionId(v string) *DescribeADInfoRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeADInfoRequest) SetResourceOwnerAccount(v string) *DescribeADInfoRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeADInfoRequest) SetResourceOwnerId(v int64) *DescribeADInfoRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeADInfoResponseBody struct {
	// The DNS information about the AD domain.
	ADDNS *string `json:"ADDNS,omitempty" xml:"ADDNS,omitempty"`
	// The service IP address of the AD domain.
	ADServerIpAddress *string `json:"ADServerIpAddress,omitempty" xml:"ADServerIpAddress,omitempty"`
	// The status of the AD domain. Valid values:
	//
	// *   **-1**: The instance is being added to the AD domain.
	// *   **0**: The instance fails to be added to the AD domain.
	// *   **1**: The instance is added to the AD domain.
	ADStatus *string `json:"ADStatus,omitempty" xml:"ADStatus,omitempty"`
	// The cause of the error.
	AbnormalReason *string `json:"AbnormalReason,omitempty" xml:"AbnormalReason,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The username of the AD domain.
	UserName *string `json:"UserName,omitempty" xml:"UserName,omitempty"`
}

func (s DescribeADInfoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeADInfoResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeADInfoResponseBody) SetADDNS(v string) *DescribeADInfoResponseBody {
	s.ADDNS = &v
	return s
}

func (s *DescribeADInfoResponseBody) SetADServerIpAddress(v string) *DescribeADInfoResponseBody {
	s.ADServerIpAddress = &v
	return s
}

func (s *DescribeADInfoResponseBody) SetADStatus(v string) *DescribeADInfoResponseBody {
	s.ADStatus = &v
	return s
}

func (s *DescribeADInfoResponseBody) SetAbnormalReason(v string) *DescribeADInfoResponseBody {
	s.AbnormalReason = &v
	return s
}

func (s *DescribeADInfoResponseBody) SetRequestId(v string) *DescribeADInfoResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeADInfoResponseBody) SetUserName(v string) *DescribeADInfoResponseBody {
	s.UserName = &v
	return s
}

type DescribeADInfoResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeADInfoResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeADInfoResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeADInfoResponse) GoString() string {
	return s.String()
}

func (s *DescribeADInfoResponse) SetHeaders(v map[string]*string) *DescribeADInfoResponse {
	s.Headers = v
	return s
}

func (s *DescribeADInfoResponse) SetStatusCode(v int32) *DescribeADInfoResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeADInfoResponse) SetBody(v *DescribeADInfoResponseBody) *DescribeADInfoResponse {
	s.Body = v
	return s
}

type DescribeAccountsRequest struct {
	// The name of the database account.
	AccountName *string `json:"AccountName,omitempty" xml:"AccountName,omitempty"`
	// The instance ID. You can call the DescribeDBInstances operation to query the instance ID.
	//
	// >  This parameter is not supported for RDS instances that run SQL Server 2017 on RDS Cluster Edition.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The page number. Default value: **1**. Valid values: any non-zero positive integer.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Valid value: **30 to 200**. Default value: **30**.
	PageSize             *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeAccountsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeAccountsRequest) GoString() string {
	return s.String()
}

func (s *DescribeAccountsRequest) SetAccountName(v string) *DescribeAccountsRequest {
	s.AccountName = &v
	return s
}

func (s *DescribeAccountsRequest) SetDBInstanceId(v string) *DescribeAccountsRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeAccountsRequest) SetPageNumber(v int32) *DescribeAccountsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeAccountsRequest) SetPageSize(v int32) *DescribeAccountsRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeAccountsRequest) SetResourceOwnerAccount(v string) *DescribeAccountsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeAccountsRequest) SetResourceOwnerId(v int64) *DescribeAccountsRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeAccountsResponseBody struct {
	// The details about the account.
	Accounts *DescribeAccountsResponseBodyAccounts `json:"Accounts,omitempty" xml:"Accounts,omitempty" type:"Struct"`
	// The page number.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The first time when the system admin account was enabled. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// >  This parameter is returned only for instances that run SQL Server.
	SystemAdminAccountFirstActivationTime *string `json:"SystemAdminAccountFirstActivationTime,omitempty" xml:"SystemAdminAccountFirstActivationTime,omitempty"`
	// Indicates whether the system admin account was enabled. Valid values:
	//
	// *   **true**: The system admin account was enabled.
	// *   **false**: The system admin account was disabled.
	//
	// >  The [system admin account](~~170736~~) is supported only for the instances that run SQL Server. If the instance runs SQL Server, a value is returned for this parameter. If the instance runs a different database engine, no value is returned for this parameter.
	SystemAdminAccountStatus *string `json:"SystemAdminAccountStatus,omitempty" xml:"SystemAdminAccountStatus,omitempty"`
	// The total number of entries that are returned.
	TotalRecordCount *int32 `json:"TotalRecordCount,omitempty" xml:"TotalRecordCount,omitempty"`
}

func (s DescribeAccountsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeAccountsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeAccountsResponseBody) SetAccounts(v *DescribeAccountsResponseBodyAccounts) *DescribeAccountsResponseBody {
	s.Accounts = v
	return s
}

func (s *DescribeAccountsResponseBody) SetPageNumber(v int32) *DescribeAccountsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeAccountsResponseBody) SetRequestId(v string) *DescribeAccountsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeAccountsResponseBody) SetSystemAdminAccountFirstActivationTime(v string) *DescribeAccountsResponseBody {
	s.SystemAdminAccountFirstActivationTime = &v
	return s
}

func (s *DescribeAccountsResponseBody) SetSystemAdminAccountStatus(v string) *DescribeAccountsResponseBody {
	s.SystemAdminAccountStatus = &v
	return s
}

func (s *DescribeAccountsResponseBody) SetTotalRecordCount(v int32) *DescribeAccountsResponseBody {
	s.TotalRecordCount = &v
	return s
}

type DescribeAccountsResponseBodyAccounts struct {
	DBInstanceAccount []*DescribeAccountsResponseBodyAccountsDBInstanceAccount `json:"DBInstanceAccount,omitempty" xml:"DBInstanceAccount,omitempty" type:"Repeated"`
}

func (s DescribeAccountsResponseBodyAccounts) String() string {
	return tea.Prettify(s)
}

func (s DescribeAccountsResponseBodyAccounts) GoString() string {
	return s.String()
}

func (s *DescribeAccountsResponseBodyAccounts) SetDBInstanceAccount(v []*DescribeAccountsResponseBodyAccountsDBInstanceAccount) *DescribeAccountsResponseBodyAccounts {
	s.DBInstanceAccount = v
	return s
}

type DescribeAccountsResponseBodyAccountsDBInstanceAccount struct {
	// The description of the account.
	AccountDescription *string `json:"AccountDescription,omitempty" xml:"AccountDescription,omitempty"`
	// The name of the database account.
	AccountName *string `json:"AccountName,omitempty" xml:"AccountName,omitempty"`
	// The status of the account. Valid values:
	//
	// *   **Unavailable**
	// *   **Available**
	AccountStatus *string `json:"AccountStatus,omitempty" xml:"AccountStatus,omitempty"`
	// The type of the account. Valid values:
	//
	// *   **Normal**: standard account
	// *   **Super**: privileged account
	// *   **Sysadmin**: system admin account, which is supported only for instances running SQL Server
	AccountType *string `json:"AccountType,omitempty" xml:"AccountType,omitempty"`
	// Indicates whether the account has the row-level security (RLS) permissions. Valid values:
	//
	// *   **t**: The account has the RLS permissions.
	// *   **f**: The account does not have the RLS permissions.
	//
	// >  This parameter is returned only for instances that run PostgreSQL.
	BypassRLS *string `json:"BypassRLS,omitempty" xml:"BypassRLS,omitempty"`
	// Indicates whether the account has the permissions to create databases. Valid values:
	//
	// *   **t**: The account has the permissions to create databases.
	// *   **f**: The account does not have the permissions to create databases.
	//
	// >  This parameter is returned only for instances that run PostgreSQL.
	CreateDB *string `json:"CreateDB,omitempty" xml:"CreateDB,omitempty"`
	// Indicates whether the account has the permissions to create roles. Valid values:
	//
	// *   **t**: The account has the permissions to create roles.
	// *   **f**: The account does not have the permissions to create roles.
	//
	// >  This parameter is returned only for instances that run PostgreSQL.
	CreateRole *string `json:"CreateRole,omitempty" xml:"CreateRole,omitempty"`
	// The ID of the instance to which the account belongs.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The details about the permissions that are granted to the account.
	DatabasePrivileges *DescribeAccountsResponseBodyAccountsDBInstanceAccountDatabasePrivileges `json:"DatabasePrivileges,omitempty" xml:"DatabasePrivileges,omitempty" type:"Struct"`
	// Indicates whether the number of databases that are managed by the account exceeds the upper limit. Valid values:
	//
	// *   **1**: The number of databases that are managed by the account exceeds the upper limit.
	// *   **0**: The number of databases that are managed by the account does not exceed the upper limit.
	PrivExceeded *string `json:"PrivExceeded,omitempty" xml:"PrivExceeded,omitempty"`
	// Indicates whether the account has the replication permissions. Valid values:
	//
	// *   **t**: The account has the replication permissions.
	// *   **f**: The account does not have the replication permissions.
	//
	// >  This parameter is returned only for instances that run PostgreSQL.
	Replication *string `json:"Replication,omitempty" xml:"Replication,omitempty"`
	// The expiration time of the password. Valid values:
	//
	// *   **infinity**: The password never expires.
	// *   **Empty**: The expiration time is not specified.
	// *   **Actual expiration time**: in the format of *yyyy-MM-dd*T*HH:mm:ss*Z in UTC. Example: 2022-10-01T00:00:00Z.
	//
	// >  This parameter is returned only for instances that run PostgreSQL.
	ValidUntil *string `json:"ValidUntil,omitempty" xml:"ValidUntil,omitempty"`
}

func (s DescribeAccountsResponseBodyAccountsDBInstanceAccount) String() string {
	return tea.Prettify(s)
}

func (s DescribeAccountsResponseBodyAccountsDBInstanceAccount) GoString() string {
	return s.String()
}

func (s *DescribeAccountsResponseBodyAccountsDBInstanceAccount) SetAccountDescription(v string) *DescribeAccountsResponseBodyAccountsDBInstanceAccount {
	s.AccountDescription = &v
	return s
}

func (s *DescribeAccountsResponseBodyAccountsDBInstanceAccount) SetAccountName(v string) *DescribeAccountsResponseBodyAccountsDBInstanceAccount {
	s.AccountName = &v
	return s
}

func (s *DescribeAccountsResponseBodyAccountsDBInstanceAccount) SetAccountStatus(v string) *DescribeAccountsResponseBodyAccountsDBInstanceAccount {
	s.AccountStatus = &v
	return s
}

func (s *DescribeAccountsResponseBodyAccountsDBInstanceAccount) SetAccountType(v string) *DescribeAccountsResponseBodyAccountsDBInstanceAccount {
	s.AccountType = &v
	return s
}

func (s *DescribeAccountsResponseBodyAccountsDBInstanceAccount) SetBypassRLS(v string) *DescribeAccountsResponseBodyAccountsDBInstanceAccount {
	s.BypassRLS = &v
	return s
}

func (s *DescribeAccountsResponseBodyAccountsDBInstanceAccount) SetCreateDB(v string) *DescribeAccountsResponseBodyAccountsDBInstanceAccount {
	s.CreateDB = &v
	return s
}

func (s *DescribeAccountsResponseBodyAccountsDBInstanceAccount) SetCreateRole(v string) *DescribeAccountsResponseBodyAccountsDBInstanceAccount {
	s.CreateRole = &v
	return s
}

func (s *DescribeAccountsResponseBodyAccountsDBInstanceAccount) SetDBInstanceId(v string) *DescribeAccountsResponseBodyAccountsDBInstanceAccount {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeAccountsResponseBodyAccountsDBInstanceAccount) SetDatabasePrivileges(v *DescribeAccountsResponseBodyAccountsDBInstanceAccountDatabasePrivileges) *DescribeAccountsResponseBodyAccountsDBInstanceAccount {
	s.DatabasePrivileges = v
	return s
}

func (s *DescribeAccountsResponseBodyAccountsDBInstanceAccount) SetPrivExceeded(v string) *DescribeAccountsResponseBodyAccountsDBInstanceAccount {
	s.PrivExceeded = &v
	return s
}

func (s *DescribeAccountsResponseBodyAccountsDBInstanceAccount) SetReplication(v string) *DescribeAccountsResponseBodyAccountsDBInstanceAccount {
	s.Replication = &v
	return s
}

func (s *DescribeAccountsResponseBodyAccountsDBInstanceAccount) SetValidUntil(v string) *DescribeAccountsResponseBodyAccountsDBInstanceAccount {
	s.ValidUntil = &v
	return s
}

type DescribeAccountsResponseBodyAccountsDBInstanceAccountDatabasePrivileges struct {
	DatabasePrivilege []*DescribeAccountsResponseBodyAccountsDBInstanceAccountDatabasePrivilegesDatabasePrivilege `json:"DatabasePrivilege,omitempty" xml:"DatabasePrivilege,omitempty" type:"Repeated"`
}

func (s DescribeAccountsResponseBodyAccountsDBInstanceAccountDatabasePrivileges) String() string {
	return tea.Prettify(s)
}

func (s DescribeAccountsResponseBodyAccountsDBInstanceAccountDatabasePrivileges) GoString() string {
	return s.String()
}

func (s *DescribeAccountsResponseBodyAccountsDBInstanceAccountDatabasePrivileges) SetDatabasePrivilege(v []*DescribeAccountsResponseBodyAccountsDBInstanceAccountDatabasePrivilegesDatabasePrivilege) *DescribeAccountsResponseBodyAccountsDBInstanceAccountDatabasePrivileges {
	s.DatabasePrivilege = v
	return s
}

type DescribeAccountsResponseBodyAccountsDBInstanceAccountDatabasePrivilegesDatabasePrivilege struct {
	// The type of the permissions. Valid values:
	//
	// *   **ReadWrite**: read and write permissions.
	// *   **ReadOnly**: read-only permissions.
	// *   **DDLOnly**: DDL-only permissions.
	// *   **DMLOnly**: DML-only permissions.
	// *   **Custom**: custom permissions. You can modify the permissions of the account by using SQL commands.
	AccountPrivilege *string `json:"AccountPrivilege,omitempty" xml:"AccountPrivilege,omitempty"`
	// The permissions that are granted to the account. For more information, see [Account permissions](~~146395~~).
	AccountPrivilegeDetail *string `json:"AccountPrivilegeDetail,omitempty" xml:"AccountPrivilegeDetail,omitempty"`
	// The name of the database.
	DBName *string `json:"DBName,omitempty" xml:"DBName,omitempty"`
}

func (s DescribeAccountsResponseBodyAccountsDBInstanceAccountDatabasePrivilegesDatabasePrivilege) String() string {
	return tea.Prettify(s)
}

func (s DescribeAccountsResponseBodyAccountsDBInstanceAccountDatabasePrivilegesDatabasePrivilege) GoString() string {
	return s.String()
}

func (s *DescribeAccountsResponseBodyAccountsDBInstanceAccountDatabasePrivilegesDatabasePrivilege) SetAccountPrivilege(v string) *DescribeAccountsResponseBodyAccountsDBInstanceAccountDatabasePrivilegesDatabasePrivilege {
	s.AccountPrivilege = &v
	return s
}

func (s *DescribeAccountsResponseBodyAccountsDBInstanceAccountDatabasePrivilegesDatabasePrivilege) SetAccountPrivilegeDetail(v string) *DescribeAccountsResponseBodyAccountsDBInstanceAccountDatabasePrivilegesDatabasePrivilege {
	s.AccountPrivilegeDetail = &v
	return s
}

func (s *DescribeAccountsResponseBodyAccountsDBInstanceAccountDatabasePrivilegesDatabasePrivilege) SetDBName(v string) *DescribeAccountsResponseBodyAccountsDBInstanceAccountDatabasePrivilegesDatabasePrivilege {
	s.DBName = &v
	return s
}

type DescribeAccountsResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeAccountsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeAccountsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeAccountsResponse) GoString() string {
	return s.String()
}

func (s *DescribeAccountsResponse) SetHeaders(v map[string]*string) *DescribeAccountsResponse {
	s.Headers = v
	return s
}

func (s *DescribeAccountsResponse) SetStatusCode(v int32) *DescribeAccountsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeAccountsResponse) SetBody(v *DescribeAccountsResponseBody) *DescribeAccountsResponse {
	s.Body = v
	return s
}

type DescribeActionEventPolicyRequest struct {
	OwnerId *int64 `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID. You can call the [DescribeRegions](~~610399~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group. You can call the [DescribeDBInstanceAttribute](~~610394~~) operation to obtain the ID of the resource group.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeActionEventPolicyRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeActionEventPolicyRequest) GoString() string {
	return s.String()
}

func (s *DescribeActionEventPolicyRequest) SetOwnerId(v int64) *DescribeActionEventPolicyRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeActionEventPolicyRequest) SetRegionId(v string) *DescribeActionEventPolicyRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeActionEventPolicyRequest) SetResourceGroupId(v string) *DescribeActionEventPolicyRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeActionEventPolicyRequest) SetResourceOwnerAccount(v string) *DescribeActionEventPolicyRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeActionEventPolicyRequest) SetResourceOwnerId(v int64) *DescribeActionEventPolicyRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeActionEventPolicyResponseBody struct {
	// Indicates whether the event history feature is enabled.
	EnableEventLog *string `json:"EnableEventLog,omitempty" xml:"EnableEventLog,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeActionEventPolicyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeActionEventPolicyResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeActionEventPolicyResponseBody) SetEnableEventLog(v string) *DescribeActionEventPolicyResponseBody {
	s.EnableEventLog = &v
	return s
}

func (s *DescribeActionEventPolicyResponseBody) SetRegionId(v string) *DescribeActionEventPolicyResponseBody {
	s.RegionId = &v
	return s
}

func (s *DescribeActionEventPolicyResponseBody) SetRequestId(v string) *DescribeActionEventPolicyResponseBody {
	s.RequestId = &v
	return s
}

type DescribeActionEventPolicyResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeActionEventPolicyResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeActionEventPolicyResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeActionEventPolicyResponse) GoString() string {
	return s.String()
}

func (s *DescribeActionEventPolicyResponse) SetHeaders(v map[string]*string) *DescribeActionEventPolicyResponse {
	s.Headers = v
	return s
}

func (s *DescribeActionEventPolicyResponse) SetStatusCode(v int32) *DescribeActionEventPolicyResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeActionEventPolicyResponse) SetBody(v *DescribeActionEventPolicyResponseBody) *DescribeActionEventPolicyResponse {
	s.Body = v
	return s
}

type DescribeActiveOperationTasksRequest struct {
	// The filter condition that is used to return tasks based on the settings of task cancellation. Default value: -1. Valid values:
	//
	// *   **-1**: returns all tasks.
	// *   **0**: returns only tasks that cannot be canceled.
	// *   **1**: returns only tasks that can be canceled.
	AllowCancel *int32 `json:"AllowCancel,omitempty" xml:"AllowCancel,omitempty"`
	// The filter condition that is used to return tasks based on the settings of the switching time. Default value: -1. Valid values:
	//
	// *   **-1**: returns all tasks.
	// *   **0**: returns only tasks for which the switching time cannot be changed.
	// *   **1**: returns only tasks for which the switching time can be changed.
	AllowChange *int32 `json:"AllowChange,omitempty" xml:"AllowChange,omitempty"`
	// The filter condition that is used to return tasks based on the task level. Default value: all. Valid values:
	//
	// *   **all**: all types
	// *   **S0**: returns the tasks of the exception fixing level.
	// *   **S1**: returns the tasks of the system O\&M level.
	ChangeLevel *string `json:"ChangeLevel,omitempty" xml:"ChangeLevel,omitempty"`
	// The type of the database. Default value: all. Valid values: mysql, pgsql, and mssql.
	DbType *string `json:"DbType,omitempty" xml:"DbType,omitempty"`
	// The name of the instance. You can leave this parameter empty. If you configure this parameter, you can specify the name only of one instance.
	InsName      *string `json:"InsName,omitempty" xml:"InsName,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The page number. Pages start from page 1. Default value: 1.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries per page. Valid values: 1 to 100. Default value: 25.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The name of the service. Valid values: RDS, POLARDB, MongoDB, and Redis. For RDS instances, set the value to RDS.
	ProductId *string `json:"ProductId,omitempty" xml:"ProductId,omitempty"`
	// The ID of the region to which the pending task belongs. You can call the [DescribeRegions](~~610399~~) operation to query the most recent region list.
	//
	// > The value **all** indicates all regions.
	Region               *string `json:"Region,omitempty" xml:"Region,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	SecurityToken        *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
	// The status of the task, which is used as a filter condition to return tasks.
	//
	// *   **-1**: all tasks
	// *   **3**: pending
	// *   **4**: being processed
	// *   **5**: completed
	// *   **6**: failed
	// *   **7**: canceled
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
	// The type of the task. Valid values:
	//
	// *   **rds_apsaradb_ha**: primary/secondary switchover
	// *   **rds_apsaradb_transfer**: instance migration
	// *   **rds_apsaradb_upgrade**: update of the minor engine version
	// *   **rds_apsaradb_maxscale**: update of the minor version of the proxy
	// *   **all**: all types
	TaskType *string `json:"TaskType,omitempty" xml:"TaskType,omitempty"`
}

func (s DescribeActiveOperationTasksRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeActiveOperationTasksRequest) GoString() string {
	return s.String()
}

func (s *DescribeActiveOperationTasksRequest) SetAllowCancel(v int32) *DescribeActiveOperationTasksRequest {
	s.AllowCancel = &v
	return s
}

func (s *DescribeActiveOperationTasksRequest) SetAllowChange(v int32) *DescribeActiveOperationTasksRequest {
	s.AllowChange = &v
	return s
}

func (s *DescribeActiveOperationTasksRequest) SetChangeLevel(v string) *DescribeActiveOperationTasksRequest {
	s.ChangeLevel = &v
	return s
}

func (s *DescribeActiveOperationTasksRequest) SetDbType(v string) *DescribeActiveOperationTasksRequest {
	s.DbType = &v
	return s
}

func (s *DescribeActiveOperationTasksRequest) SetInsName(v string) *DescribeActiveOperationTasksRequest {
	s.InsName = &v
	return s
}

func (s *DescribeActiveOperationTasksRequest) SetOwnerAccount(v string) *DescribeActiveOperationTasksRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeActiveOperationTasksRequest) SetOwnerId(v int64) *DescribeActiveOperationTasksRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeActiveOperationTasksRequest) SetPageNumber(v int32) *DescribeActiveOperationTasksRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeActiveOperationTasksRequest) SetPageSize(v int32) *DescribeActiveOperationTasksRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeActiveOperationTasksRequest) SetProductId(v string) *DescribeActiveOperationTasksRequest {
	s.ProductId = &v
	return s
}

func (s *DescribeActiveOperationTasksRequest) SetRegion(v string) *DescribeActiveOperationTasksRequest {
	s.Region = &v
	return s
}

func (s *DescribeActiveOperationTasksRequest) SetResourceOwnerAccount(v string) *DescribeActiveOperationTasksRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeActiveOperationTasksRequest) SetResourceOwnerId(v int64) *DescribeActiveOperationTasksRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeActiveOperationTasksRequest) SetSecurityToken(v string) *DescribeActiveOperationTasksRequest {
	s.SecurityToken = &v
	return s
}

func (s *DescribeActiveOperationTasksRequest) SetStatus(v int32) *DescribeActiveOperationTasksRequest {
	s.Status = &v
	return s
}

func (s *DescribeActiveOperationTasksRequest) SetTaskType(v string) *DescribeActiveOperationTasksRequest {
	s.TaskType = &v
	return s
}

type DescribeActiveOperationTasksResponseBody struct {
	// The details about the O\&M task.
	Items []*DescribeActiveOperationTasksResponseBodyItems `json:"Items,omitempty" xml:"Items,omitempty" type:"Repeated"`
	// The page number. Pages start from page 1. Default value: 1.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries per page. Valid values: 1 to 100. Default value: 25.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalRecordCount *int32 `json:"TotalRecordCount,omitempty" xml:"TotalRecordCount,omitempty"`
}

func (s DescribeActiveOperationTasksResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeActiveOperationTasksResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeActiveOperationTasksResponseBody) SetItems(v []*DescribeActiveOperationTasksResponseBodyItems) *DescribeActiveOperationTasksResponseBody {
	s.Items = v
	return s
}

func (s *DescribeActiveOperationTasksResponseBody) SetPageNumber(v int32) *DescribeActiveOperationTasksResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeActiveOperationTasksResponseBody) SetPageSize(v int32) *DescribeActiveOperationTasksResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeActiveOperationTasksResponseBody) SetRequestId(v string) *DescribeActiveOperationTasksResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeActiveOperationTasksResponseBody) SetTotalRecordCount(v int32) *DescribeActiveOperationTasksResponseBody {
	s.TotalRecordCount = &v
	return s
}

type DescribeActiveOperationTasksResponseBodyItems struct {
	// Indicates whether the task can be canceled. The value 1 indicates that the task can be canceled. The value 0 indicates that the task cannot be canceled.
	AllowCancel *string `json:"AllowCancel,omitempty" xml:"AllowCancel,omitempty"`
	// Indicates whether the switching time can be changed. The value 1 indicates that the switching time can be changed. The value 0 indicates that the switching time cannot be changed.
	AllowChange *string `json:"AllowChange,omitempty" xml:"AllowChange,omitempty"`
	// The code of the task level. The value S1 indicates the system O\&M level. The value S0 indicates the exception fixing level.
	ChangeLevel *string `json:"ChangeLevel,omitempty" xml:"ChangeLevel,omitempty"`
	// The level of the task in English.
	ChangeLevelEn *string `json:"ChangeLevelEn,omitempty" xml:"ChangeLevelEn,omitempty"`
	// The level of the task in Chinese.
	ChangeLevelZh *string `json:"ChangeLevelZh,omitempty" xml:"ChangeLevelZh,omitempty"`
	// The time when the task was created. The time follows the ISO 8601 standard in the yyyy-MM-ddThh:mm:ssZ format. The time is displayed in UTC.
	CreatedTime *string `json:"CreatedTime,omitempty" xml:"CreatedTime,omitempty"`
	// The current zone.
	CurrentAVZ *string `json:"CurrentAVZ,omitempty" xml:"CurrentAVZ,omitempty"`
	// The type of the database. Valid values: mysql, pgsql, and mssql.
	DbType *string `json:"DbType,omitempty" xml:"DbType,omitempty"`
	// The minor engine version.
	DbVersion *string `json:"DbVersion,omitempty" xml:"DbVersion,omitempty"`
	// The deadline of the switching time for the task. The time follows the ISO 8601 standard in the yyyy-MM-ddThh:mm:ssZ format. The time is displayed in UTC.
	Deadline *string `json:"Deadline,omitempty" xml:"Deadline,omitempty"`
	// The ID of the task.
	Id *int32 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The impact of the task.
	Impact *string `json:"Impact,omitempty" xml:"Impact,omitempty"`
	// The impact of the task in English.
	ImpactEn *string `json:"ImpactEn,omitempty" xml:"ImpactEn,omitempty"`
	// The impact of the task in Chinese.
	ImpactZh *string `json:"ImpactZh,omitempty" xml:"ImpactZh,omitempty"`
	// The alias and description of the instance.
	InsComment *string `json:"InsComment,omitempty" xml:"InsComment,omitempty"`
	// The instance ID.
	InsName *string `json:"InsName,omitempty" xml:"InsName,omitempty"`
	// The time after the modification. The time follows the ISO 8601 standard in the yyyy-MM-ddThh:mm:ssZ format. The time is displayed in UTC.
	ModifiedTime *string `json:"ModifiedTime,omitempty" xml:"ModifiedTime,omitempty"`
	// The required preparation period between the task start time and the switching time. The time is displayed in the HH:mm:ss format.
	PrepareInterval *string `json:"PrepareInterval,omitempty" xml:"PrepareInterval,omitempty"`
	// The region ID of the pending task.
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The information about the execution result.
	ResultInfo *string `json:"ResultInfo,omitempty" xml:"ResultInfo,omitempty"`
	// The time when the task was executed. The time follows the ISO 8601 standard in the yyyy-MM-ddThh:mm:ssZ format. The time is displayed in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The task status.
	//
	// *   **3**: pending
	// *   **4**: being processed
	// *   **5**: completed
	// *   **6**: failed
	// *   **7**: canceled
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
	// The subtasks of the instance.
	SubInsNames []*string `json:"SubInsNames,omitempty" xml:"SubInsNames,omitempty" type:"Repeated"`
	// The switching time of the task. The time follows the ISO 8601 standard in the yyyy-MM-ddThh:mm:ssZ format. The time is displayed in UTC.
	SwitchTime *string `json:"SwitchTime,omitempty" xml:"SwitchTime,omitempty"`
	// The task parameters.
	TaskParams *string `json:"TaskParams,omitempty" xml:"TaskParams,omitempty"`
	// The type of the O\&M task. Valid values:
	//
	// *   **rds_apsaradb_ha**: primary/secondary switchover
	// *   **rds_apsaradb_transfer**: instance migration
	// *   **rds_apsaradb_upgrade**: update of the minor engine version
	// *   **rds_apsaradb_maxscale**: minor version update of the database proxy
	TaskType *string `json:"TaskType,omitempty" xml:"TaskType,omitempty"`
	// The reason for the task in English.
	TaskTypeEn *string `json:"TaskTypeEn,omitempty" xml:"TaskTypeEn,omitempty"`
	// The reason for the task in Chinese.
	TaskTypeZh *string `json:"TaskTypeZh,omitempty" xml:"TaskTypeZh,omitempty"`
}

func (s DescribeActiveOperationTasksResponseBodyItems) String() string {
	return tea.Prettify(s)
}

func (s DescribeActiveOperationTasksResponseBodyItems) GoString() string {
	return s.String()
}

func (s *DescribeActiveOperationTasksResponseBodyItems) SetAllowCancel(v string) *DescribeActiveOperationTasksResponseBodyItems {
	s.AllowCancel = &v
	return s
}

func (s *DescribeActiveOperationTasksResponseBodyItems) SetAllowChange(v string) *DescribeActiveOperationTasksResponseBodyItems {
	s.AllowChange = &v
	return s
}

func (s *DescribeActiveOperationTasksResponseBodyItems) SetChangeLevel(v string) *DescribeActiveOperationTasksResponseBodyItems {
	s.ChangeLevel = &v
	return s
}

func (s *DescribeActiveOperationTasksResponseBodyItems) SetChangeLevelEn(v string) *DescribeActiveOperationTasksResponseBodyItems {
	s.ChangeLevelEn = &v
	return s
}

func (s *DescribeActiveOperationTasksResponseBodyItems) SetChangeLevelZh(v string) *DescribeActiveOperationTasksResponseBodyItems {
	s.ChangeLevelZh = &v
	return s
}

func (s *DescribeActiveOperationTasksResponseBodyItems) SetCreatedTime(v string) *DescribeActiveOperationTasksResponseBodyItems {
	s.CreatedTime = &v
	return s
}

func (s *DescribeActiveOperationTasksResponseBodyItems) SetCurrentAVZ(v string) *DescribeActiveOperationTasksResponseBodyItems {
	s.CurrentAVZ = &v
	return s
}

func (s *DescribeActiveOperationTasksResponseBodyItems) SetDbType(v string) *DescribeActiveOperationTasksResponseBodyItems {
	s.DbType = &v
	return s
}

func (s *DescribeActiveOperationTasksResponseBodyItems) SetDbVersion(v string) *DescribeActiveOperationTasksResponseBodyItems {
	s.DbVersion = &v
	return s
}

func (s *DescribeActiveOperationTasksResponseBodyItems) SetDeadline(v string) *DescribeActiveOperationTasksResponseBodyItems {
	s.Deadline = &v
	return s
}

func (s *DescribeActiveOperationTasksResponseBodyItems) SetId(v int32) *DescribeActiveOperationTasksResponseBodyItems {
	s.Id = &v
	return s
}

func (s *DescribeActiveOperationTasksResponseBodyItems) SetImpact(v string) *DescribeActiveOperationTasksResponseBodyItems {
	s.Impact = &v
	return s
}

func (s *DescribeActiveOperationTasksResponseBodyItems) SetImpactEn(v string) *DescribeActiveOperationTasksResponseBodyItems {
	s.ImpactEn = &v
	return s
}

func (s *DescribeActiveOperationTasksResponseBodyItems) SetImpactZh(v string) *DescribeActiveOperationTasksResponseBodyItems {
	s.ImpactZh = &v
	return s
}

func (s *DescribeActiveOperationTasksResponseBodyItems) SetInsComment(v string) *DescribeActiveOperationTasksResponseBodyItems {
	s.InsComment = &v
	return s
}

func (s *DescribeActiveOperationTasksResponseBodyItems) SetInsName(v string) *DescribeActiveOperationTasksResponseBodyItems {
	s.InsName = &v
	return s
}

func (s *DescribeActiveOperationTasksResponseBodyItems) SetModifiedTime(v string) *DescribeActiveOperationTasksResponseBodyItems {
	s.ModifiedTime = &v
	return s
}

func (s *DescribeActiveOperationTasksResponseBodyItems) SetPrepareInterval(v string) *DescribeActiveOperationTasksResponseBodyItems {
	s.PrepareInterval = &v
	return s
}

func (s *DescribeActiveOperationTasksResponseBodyItems) SetRegion(v string) *DescribeActiveOperationTasksResponseBodyItems {
	s.Region = &v
	return s
}

func (s *DescribeActiveOperationTasksResponseBodyItems) SetResultInfo(v string) *DescribeActiveOperationTasksResponseBodyItems {
	s.ResultInfo = &v
	return s
}

func (s *DescribeActiveOperationTasksResponseBodyItems) SetStartTime(v string) *DescribeActiveOperationTasksResponseBodyItems {
	s.StartTime = &v
	return s
}

func (s *DescribeActiveOperationTasksResponseBodyItems) SetStatus(v int32) *DescribeActiveOperationTasksResponseBodyItems {
	s.Status = &v
	return s
}

func (s *DescribeActiveOperationTasksResponseBodyItems) SetSubInsNames(v []*string) *DescribeActiveOperationTasksResponseBodyItems {
	s.SubInsNames = v
	return s
}

func (s *DescribeActiveOperationTasksResponseBodyItems) SetSwitchTime(v string) *DescribeActiveOperationTasksResponseBodyItems {
	s.SwitchTime = &v
	return s
}

func (s *DescribeActiveOperationTasksResponseBodyItems) SetTaskParams(v string) *DescribeActiveOperationTasksResponseBodyItems {
	s.TaskParams = &v
	return s
}

func (s *DescribeActiveOperationTasksResponseBodyItems) SetTaskType(v string) *DescribeActiveOperationTasksResponseBodyItems {
	s.TaskType = &v
	return s
}

func (s *DescribeActiveOperationTasksResponseBodyItems) SetTaskTypeEn(v string) *DescribeActiveOperationTasksResponseBodyItems {
	s.TaskTypeEn = &v
	return s
}

func (s *DescribeActiveOperationTasksResponseBodyItems) SetTaskTypeZh(v string) *DescribeActiveOperationTasksResponseBodyItems {
	s.TaskTypeZh = &v
	return s
}

type DescribeActiveOperationTasksResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeActiveOperationTasksResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeActiveOperationTasksResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeActiveOperationTasksResponse) GoString() string {
	return s.String()
}

func (s *DescribeActiveOperationTasksResponse) SetHeaders(v map[string]*string) *DescribeActiveOperationTasksResponse {
	s.Headers = v
	return s
}

func (s *DescribeActiveOperationTasksResponse) SetStatusCode(v int32) *DescribeActiveOperationTasksResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeActiveOperationTasksResponse) SetBody(v *DescribeActiveOperationTasksResponseBody) *DescribeActiveOperationTasksResponse {
	s.Body = v
	return s
}

type DescribeAllWhitelistTemplateRequest struct {
	// Specifies whether to enable fuzzy search. Valid values:
	//
	// *   **true**
	// *   **false**
	FuzzySearch *bool `json:"FuzzySearch,omitempty" xml:"FuzzySearch,omitempty"`
	// The number of entries to return on each page. Enumerated valid values: 10, 30, and 50.
	MaxRecordsPerPage *int32 `json:"MaxRecordsPerPage,omitempty" xml:"MaxRecordsPerPage,omitempty"`
	// The page number.
	PageNumbers *int32 `json:"PageNumbers,omitempty" xml:"PageNumbers,omitempty"`
	// The resource group ID. For more information about resource groups, see related documentation.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The name of the IP whitelist template. If you specify this parameter when you perform a fuzzy search, you can call the [DescribeWhitelistTemplate](~~2412074~~) operation.
	TemplateName *string `json:"TemplateName,omitempty" xml:"TemplateName,omitempty"`
}

func (s DescribeAllWhitelistTemplateRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeAllWhitelistTemplateRequest) GoString() string {
	return s.String()
}

func (s *DescribeAllWhitelistTemplateRequest) SetFuzzySearch(v bool) *DescribeAllWhitelistTemplateRequest {
	s.FuzzySearch = &v
	return s
}

func (s *DescribeAllWhitelistTemplateRequest) SetMaxRecordsPerPage(v int32) *DescribeAllWhitelistTemplateRequest {
	s.MaxRecordsPerPage = &v
	return s
}

func (s *DescribeAllWhitelistTemplateRequest) SetPageNumbers(v int32) *DescribeAllWhitelistTemplateRequest {
	s.PageNumbers = &v
	return s
}

func (s *DescribeAllWhitelistTemplateRequest) SetResourceGroupId(v string) *DescribeAllWhitelistTemplateRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeAllWhitelistTemplateRequest) SetResourceOwnerAccount(v string) *DescribeAllWhitelistTemplateRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeAllWhitelistTemplateRequest) SetResourceOwnerId(v int64) *DescribeAllWhitelistTemplateRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeAllWhitelistTemplateRequest) SetTemplateName(v string) *DescribeAllWhitelistTemplateRequest {
	s.TemplateName = &v
	return s
}

type DescribeAllWhitelistTemplateResponseBody struct {
	// The response code returned. Valid values:
	//
	// *   **200**: success
	// *   **400**: client error
	// *   **401**: identity authentication failed
	// *   **404**: request page not found
	// *   **500**: server error
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data returned.
	Data *DescribeAllWhitelistTemplateResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The HTTP status code returned. Valid values:
	//
	// *   **200**: success
	// *   **400**: client error
	// *   **500**: server error
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The response parameters.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful. Valid values:
	//
	// *   **true**
	// *   **false**
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DescribeAllWhitelistTemplateResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeAllWhitelistTemplateResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeAllWhitelistTemplateResponseBody) SetCode(v string) *DescribeAllWhitelistTemplateResponseBody {
	s.Code = &v
	return s
}

func (s *DescribeAllWhitelistTemplateResponseBody) SetData(v *DescribeAllWhitelistTemplateResponseBodyData) *DescribeAllWhitelistTemplateResponseBody {
	s.Data = v
	return s
}

func (s *DescribeAllWhitelistTemplateResponseBody) SetHttpStatusCode(v int32) *DescribeAllWhitelistTemplateResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *DescribeAllWhitelistTemplateResponseBody) SetMessage(v string) *DescribeAllWhitelistTemplateResponseBody {
	s.Message = &v
	return s
}

func (s *DescribeAllWhitelistTemplateResponseBody) SetRequestId(v string) *DescribeAllWhitelistTemplateResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeAllWhitelistTemplateResponseBody) SetSuccess(v bool) *DescribeAllWhitelistTemplateResponseBody {
	s.Success = &v
	return s
}

type DescribeAllWhitelistTemplateResponseBodyData struct {
	// The page number.
	CurrPageNumbers *int32 `json:"CurrPageNumbers,omitempty" xml:"CurrPageNumbers,omitempty"`
	// Indicates whether the data that meets the conditions is displayed on the next page. Valid values:
	//
	// *   **true**
	// *   **false**
	HasNext *bool `json:"HasNext,omitempty" xml:"HasNext,omitempty"`
	// Indicates whether the data that meets the conditions is displayed on the previous page. Valid values:
	//
	// *   **true**
	// *   **false**
	HasPrev *bool `json:"HasPrev,omitempty" xml:"HasPrev,omitempty"`
	// The number of entries to return on each page.
	MaxRecordsPerPage *int32 `json:"MaxRecordsPerPage,omitempty" xml:"MaxRecordsPerPage,omitempty"`
	// The information about whitelist templates that are returned by page.
	Templates []*DescribeAllWhitelistTemplateResponseBodyDataTemplates `json:"Templates,omitempty" xml:"Templates,omitempty" type:"Repeated"`
	// The total number of pages returned.
	TotalPageNumbers *int32 `json:"TotalPageNumbers,omitempty" xml:"TotalPageNumbers,omitempty"`
	// The total number of entries returned.
	TotalRecords *int32 `json:"TotalRecords,omitempty" xml:"TotalRecords,omitempty"`
}

func (s DescribeAllWhitelistTemplateResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s DescribeAllWhitelistTemplateResponseBodyData) GoString() string {
	return s.String()
}

func (s *DescribeAllWhitelistTemplateResponseBodyData) SetCurrPageNumbers(v int32) *DescribeAllWhitelistTemplateResponseBodyData {
	s.CurrPageNumbers = &v
	return s
}

func (s *DescribeAllWhitelistTemplateResponseBodyData) SetHasNext(v bool) *DescribeAllWhitelistTemplateResponseBodyData {
	s.HasNext = &v
	return s
}

func (s *DescribeAllWhitelistTemplateResponseBodyData) SetHasPrev(v bool) *DescribeAllWhitelistTemplateResponseBodyData {
	s.HasPrev = &v
	return s
}

func (s *DescribeAllWhitelistTemplateResponseBodyData) SetMaxRecordsPerPage(v int32) *DescribeAllWhitelistTemplateResponseBodyData {
	s.MaxRecordsPerPage = &v
	return s
}

func (s *DescribeAllWhitelistTemplateResponseBodyData) SetTemplates(v []*DescribeAllWhitelistTemplateResponseBodyDataTemplates) *DescribeAllWhitelistTemplateResponseBodyData {
	s.Templates = v
	return s
}

func (s *DescribeAllWhitelistTemplateResponseBodyData) SetTotalPageNumbers(v int32) *DescribeAllWhitelistTemplateResponseBodyData {
	s.TotalPageNumbers = &v
	return s
}

func (s *DescribeAllWhitelistTemplateResponseBodyData) SetTotalRecords(v int32) *DescribeAllWhitelistTemplateResponseBodyData {
	s.TotalRecords = &v
	return s
}

type DescribeAllWhitelistTemplateResponseBodyDataTemplates struct {
	// The primary key of the data table.
	Id *int32 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The IP addresses.
	Ips *string `json:"Ips,omitempty" xml:"Ips,omitempty"`
	// The ID of the whitelist template.
	TemplateId *int32 `json:"TemplateId,omitempty" xml:"TemplateId,omitempty"`
	// The name of the whitelist template.
	TemplateName *string `json:"TemplateName,omitempty" xml:"TemplateName,omitempty"`
	// The user ID.
	UserId *int32 `json:"UserId,omitempty" xml:"UserId,omitempty"`
}

func (s DescribeAllWhitelistTemplateResponseBodyDataTemplates) String() string {
	return tea.Prettify(s)
}

func (s DescribeAllWhitelistTemplateResponseBodyDataTemplates) GoString() string {
	return s.String()
}

func (s *DescribeAllWhitelistTemplateResponseBodyDataTemplates) SetId(v int32) *DescribeAllWhitelistTemplateResponseBodyDataTemplates {
	s.Id = &v
	return s
}

func (s *DescribeAllWhitelistTemplateResponseBodyDataTemplates) SetIps(v string) *DescribeAllWhitelistTemplateResponseBodyDataTemplates {
	s.Ips = &v
	return s
}

func (s *DescribeAllWhitelistTemplateResponseBodyDataTemplates) SetTemplateId(v int32) *DescribeAllWhitelistTemplateResponseBodyDataTemplates {
	s.TemplateId = &v
	return s
}

func (s *DescribeAllWhitelistTemplateResponseBodyDataTemplates) SetTemplateName(v string) *DescribeAllWhitelistTemplateResponseBodyDataTemplates {
	s.TemplateName = &v
	return s
}

func (s *DescribeAllWhitelistTemplateResponseBodyDataTemplates) SetUserId(v int32) *DescribeAllWhitelistTemplateResponseBodyDataTemplates {
	s.UserId = &v
	return s
}

type DescribeAllWhitelistTemplateResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeAllWhitelistTemplateResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeAllWhitelistTemplateResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeAllWhitelistTemplateResponse) GoString() string {
	return s.String()
}

func (s *DescribeAllWhitelistTemplateResponse) SetHeaders(v map[string]*string) *DescribeAllWhitelistTemplateResponse {
	s.Headers = v
	return s
}

func (s *DescribeAllWhitelistTemplateResponse) SetStatusCode(v int32) *DescribeAllWhitelistTemplateResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeAllWhitelistTemplateResponse) SetBody(v *DescribeAllWhitelistTemplateResponseBody) *DescribeAllWhitelistTemplateResponse {
	s.Body = v
	return s
}

type DescribeAnalyticdbByPrimaryDBInstanceRequest struct {
	// The ID of the instance. You can call the [DescribeDBInstances](~~26232~~) operation to query the ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the instance. You can call the [DescribeRegions](~~26243~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeAnalyticdbByPrimaryDBInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeAnalyticdbByPrimaryDBInstanceRequest) GoString() string {
	return s.String()
}

func (s *DescribeAnalyticdbByPrimaryDBInstanceRequest) SetDBInstanceId(v string) *DescribeAnalyticdbByPrimaryDBInstanceRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeAnalyticdbByPrimaryDBInstanceRequest) SetOwnerId(v int64) *DescribeAnalyticdbByPrimaryDBInstanceRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeAnalyticdbByPrimaryDBInstanceRequest) SetRegionId(v string) *DescribeAnalyticdbByPrimaryDBInstanceRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeAnalyticdbByPrimaryDBInstanceRequest) SetResourceOwnerAccount(v string) *DescribeAnalyticdbByPrimaryDBInstanceRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeAnalyticdbByPrimaryDBInstanceRequest) SetResourceOwnerId(v int64) *DescribeAnalyticdbByPrimaryDBInstanceRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeAnalyticdbByPrimaryDBInstanceResponseBody struct {
	// The number of associated analytic instances.
	AnalyticDBCount *int32 `json:"AnalyticDBCount,omitempty" xml:"AnalyticDBCount,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeAnalyticdbByPrimaryDBInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeAnalyticdbByPrimaryDBInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeAnalyticdbByPrimaryDBInstanceResponseBody) SetAnalyticDBCount(v int32) *DescribeAnalyticdbByPrimaryDBInstanceResponseBody {
	s.AnalyticDBCount = &v
	return s
}

func (s *DescribeAnalyticdbByPrimaryDBInstanceResponseBody) SetRequestId(v string) *DescribeAnalyticdbByPrimaryDBInstanceResponseBody {
	s.RequestId = &v
	return s
}

type DescribeAnalyticdbByPrimaryDBInstanceResponse struct {
	Headers    map[string]*string                                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeAnalyticdbByPrimaryDBInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeAnalyticdbByPrimaryDBInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeAnalyticdbByPrimaryDBInstanceResponse) GoString() string {
	return s.String()
}

func (s *DescribeAnalyticdbByPrimaryDBInstanceResponse) SetHeaders(v map[string]*string) *DescribeAnalyticdbByPrimaryDBInstanceResponse {
	s.Headers = v
	return s
}

func (s *DescribeAnalyticdbByPrimaryDBInstanceResponse) SetStatusCode(v int32) *DescribeAnalyticdbByPrimaryDBInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeAnalyticdbByPrimaryDBInstanceResponse) SetBody(v *DescribeAnalyticdbByPrimaryDBInstanceResponseBody) *DescribeAnalyticdbByPrimaryDBInstanceResponse {
	s.Body = v
	return s
}

type DescribeAvailableClassesRequest struct {
	// The RDS edition of the instance. Valid values:
	//
	// *   Regular instance
	//
	//     *   **Basic**: RDS Basic Edition
	//     *   **HighAvailability**: RDS High-availability Edition
	//     *   **cluster**: RDS Cluster Edition for ApsaraDB RDS for MySQL
	//     *   **AlwaysOn**: RDS Cluster Edition for ApsaraDB RDS for SQL Server
	//     *   **Finance**: RDS Enterprise Edition
	//
	// *   Serverless instance
	//
	//     *   **serverless_basic**: RDS Basic Edition. This edition is available only for serverless instances that run MySQL and PostgreSQL.
	//     *   **serverless_standard**: RDS High-availability Edition for ApsaraDB RDS for MySQL.
	//     *   **serverless_ha**: RDS High-availability Edition for ApsaraDB RDS for SQL Server.
	//
	//     **
	//
	//     **Note** If you create a serverless instance, you must specify this parameter.
	Category *string `json:"Category,omitempty" xml:"Category,omitempty"`
	// The commodity code of the instance. Valid values:
	//
	// *   **bards**: The instance is a pay-as-you-go primary instance. This value is available at the China site (aliyun.com).
	// *   **rds**: The instance is a subscription primary instance. This value is available at the China site (aliyun.com).
	// *   **rords**: The instance is a pay-as-you-go read-only instance. This value is available at the China site (aliyun.com).
	// *   **rds_rordspre_public_cn**: The instance is a subscription read-only instance. This value is available at the China site (aliyun.com).
	// *   **bards_intl**: The instance is a pay-as-you-go primary instance. This value is available at the International site (alibabacloud.com).
	// *   **rds_intl**: The instance is a subscription primary instance. This value is available at the International site (alibabacloud.com).
	// *   **rords_intl**: The instance is a pay-as-you-go read-only instance. This value is available at the International site (alibabacloud.com).
	// *   **rds_rordspre_public_intl**: The instance is a subscription read-only instance. This value is available at the International site (alibabacloud.com).
	// *   **rds_serverless_public_cn**: The instance is a serverless instance. This value is available at the China site (aliyun.com).
	// *   **rds_serverless_public_intl**: The instance is a serverless instance. This value is available at the International site (alibabacloud.com).
	//
	// > If you want to query the price of a read-only instance, you must specify this parameter.
	CommodityCode *string `json:"CommodityCode,omitempty" xml:"CommodityCode,omitempty"`
	// The instance ID. You can call the [DescribeDBInstances](~~610396~~) operation to query the instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The storage type of the instance. Valid values:
	//
	// *   **local_ssd**: local SSD. This is the recommended storage type.
	// *   **cloud_ssd**: standard SSD.
	// *   **cloud_essd**: enhanced SSDs (ESSDs) of performance level 1 (PL1)
	// *   **cloud_essd2**: ESSDs of PL2
	// *   **cloud_essd3**: ESSD of PL3
	//
	// > Serverless instances support only ESSDs of PL 1. For a serverless instance, you must set this parameter to **cloud_essd**.
	DBInstanceStorageType *string `json:"DBInstanceStorageType,omitempty" xml:"DBInstanceStorageType,omitempty"`
	// The database engine that is run by the instance. Valid values:
	//
	// * **MySQL**
	// * **SQLServer**
	// * **PostgreSQL**
	// * **MariaDB**
	Engine *string `json:"Engine,omitempty" xml:"Engine,omitempty"`
	// The database engine version of the instance. Valid values:
	//
	// *   Regular instance
	//
	//     *   Valid values if you set Engine to MySQL: **5.5, 5.6, 5.7, and 8.0**
	//     *   Valid values if you set Engine to SQLServer: **2008r2, 08r2\_ent_ha, 2012, 2012\_ent_ha, 2012\_std_ha, 2012\_web, 2014\_std_ha, 2016\_ent_ha, 2016\_std_ha, 2016\_web, 2017\_std_ha, 2017\_ent, 2019\_std_ha, and 2019\_ent**
	//     *   Valid values if you set Engine to PostgreSQL: **10.0, 11.0, 12.0, 13.0, 14.0, and 15.0**
	//     *   Valid value when you set Engine to MariaDB: **10.3**
	//
	// *   Serverless instance
	//
	//     *   Valid values if you set Engine to MySQL: **5.7** and **8.0**
	//     *   Valid values if you set Engine to SQLServer: **2016\_std_sl**, **2017\_std_sl**, and **2019\_std_sl**
	//     *   Valid value if you set Engine to PostgreSQL: **14.0**
	//
	//     **
	//
	//     **Note** ApsaraDB RDS for MariaDB does not support serverless instances.
	EngineVersion *string `json:"EngineVersion,omitempty" xml:"EngineVersion,omitempty"`
	// The billing method of the instance. Valid values:
	//
	// *   **Prepaid**: subscription
	// *   **Postpaid**: pay-as-you-go
	// *   **Serverless**: serverless
	//
	// > ApsaraDB RDS for MariaDB does not support serverless instances.
	InstanceChargeType *string `json:"InstanceChargeType,omitempty" xml:"InstanceChargeType,omitempty"`
	// The type of the order. Set the value to **BUY**
	OrderType *string `json:"OrderType,omitempty" xml:"OrderType,omitempty"`
	// The region ID of the instance. You can call the [DescribeDBInstanceAttribute](~~610394~~) operation to query the region ID of the instance.
	RegionId        *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerId *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The zone ID of the instance. You can call the [DescribeDBInstanceAttribute](~~610394~~) operation to query the zone ID of the instance.
	//
	// >  If the DescribeDBInstanceAttribute operation returns multiple zones, you must specify only one of the returned zones. For example, if the DescribeDBInstanceAttribute operation returns `cn-hangzhou-MAZ9(g,h)`, you can set this parameter to `cn-hangzhou-g` or `cn-hangzhou-h`.
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
}

func (s DescribeAvailableClassesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeAvailableClassesRequest) GoString() string {
	return s.String()
}

func (s *DescribeAvailableClassesRequest) SetCategory(v string) *DescribeAvailableClassesRequest {
	s.Category = &v
	return s
}

func (s *DescribeAvailableClassesRequest) SetCommodityCode(v string) *DescribeAvailableClassesRequest {
	s.CommodityCode = &v
	return s
}

func (s *DescribeAvailableClassesRequest) SetDBInstanceId(v string) *DescribeAvailableClassesRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeAvailableClassesRequest) SetDBInstanceStorageType(v string) *DescribeAvailableClassesRequest {
	s.DBInstanceStorageType = &v
	return s
}

func (s *DescribeAvailableClassesRequest) SetEngine(v string) *DescribeAvailableClassesRequest {
	s.Engine = &v
	return s
}

func (s *DescribeAvailableClassesRequest) SetEngineVersion(v string) *DescribeAvailableClassesRequest {
	s.EngineVersion = &v
	return s
}

func (s *DescribeAvailableClassesRequest) SetInstanceChargeType(v string) *DescribeAvailableClassesRequest {
	s.InstanceChargeType = &v
	return s
}

func (s *DescribeAvailableClassesRequest) SetOrderType(v string) *DescribeAvailableClassesRequest {
	s.OrderType = &v
	return s
}

func (s *DescribeAvailableClassesRequest) SetRegionId(v string) *DescribeAvailableClassesRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeAvailableClassesRequest) SetResourceOwnerId(v int64) *DescribeAvailableClassesRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeAvailableClassesRequest) SetZoneId(v string) *DescribeAvailableClassesRequest {
	s.ZoneId = &v
	return s
}

type DescribeAvailableClassesResponseBody struct {
	// An array that consists of the instance types available for the instance.
	DBInstanceClasses []*DescribeAvailableClassesResponseBodyDBInstanceClasses `json:"DBInstanceClasses,omitempty" xml:"DBInstanceClasses,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeAvailableClassesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeAvailableClassesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeAvailableClassesResponseBody) SetDBInstanceClasses(v []*DescribeAvailableClassesResponseBodyDBInstanceClasses) *DescribeAvailableClassesResponseBody {
	s.DBInstanceClasses = v
	return s
}

func (s *DescribeAvailableClassesResponseBody) SetRequestId(v string) *DescribeAvailableClassesResponseBody {
	s.RequestId = &v
	return s
}

type DescribeAvailableClassesResponseBodyDBInstanceClasses struct {
	// The instance type of the instance.
	DBInstanceClass *string `json:"DBInstanceClass,omitempty" xml:"DBInstanceClass,omitempty"`
	// The storage capacity range that is supported for the instance.
	DBInstanceStorageRange *DescribeAvailableClassesResponseBodyDBInstanceClassesDBInstanceStorageRange `json:"DBInstanceStorageRange,omitempty" xml:"DBInstanceStorageRange,omitempty" type:"Struct"`
}

func (s DescribeAvailableClassesResponseBodyDBInstanceClasses) String() string {
	return tea.Prettify(s)
}

func (s DescribeAvailableClassesResponseBodyDBInstanceClasses) GoString() string {
	return s.String()
}

func (s *DescribeAvailableClassesResponseBodyDBInstanceClasses) SetDBInstanceClass(v string) *DescribeAvailableClassesResponseBodyDBInstanceClasses {
	s.DBInstanceClass = &v
	return s
}

func (s *DescribeAvailableClassesResponseBodyDBInstanceClasses) SetDBInstanceStorageRange(v *DescribeAvailableClassesResponseBodyDBInstanceClassesDBInstanceStorageRange) *DescribeAvailableClassesResponseBodyDBInstanceClasses {
	s.DBInstanceStorageRange = v
	return s
}

type DescribeAvailableClassesResponseBodyDBInstanceClassesDBInstanceStorageRange struct {
	// The maximum storage capacity that is supported for the instance. Unit: GB.
	MaxValue *int32 `json:"MaxValue,omitempty" xml:"MaxValue,omitempty"`
	// The minimum storage capacity that is supported for the instance. Unit: GB.
	MinValue *int32 `json:"MinValue,omitempty" xml:"MinValue,omitempty"`
	// The minimum step size at which you can adjust the storage capacity of the instance. The minimum step size is 5 GB.
	Step *int32 `json:"Step,omitempty" xml:"Step,omitempty"`
}

func (s DescribeAvailableClassesResponseBodyDBInstanceClassesDBInstanceStorageRange) String() string {
	return tea.Prettify(s)
}

func (s DescribeAvailableClassesResponseBodyDBInstanceClassesDBInstanceStorageRange) GoString() string {
	return s.String()
}

func (s *DescribeAvailableClassesResponseBodyDBInstanceClassesDBInstanceStorageRange) SetMaxValue(v int32) *DescribeAvailableClassesResponseBodyDBInstanceClassesDBInstanceStorageRange {
	s.MaxValue = &v
	return s
}

func (s *DescribeAvailableClassesResponseBodyDBInstanceClassesDBInstanceStorageRange) SetMinValue(v int32) *DescribeAvailableClassesResponseBodyDBInstanceClassesDBInstanceStorageRange {
	s.MinValue = &v
	return s
}

func (s *DescribeAvailableClassesResponseBodyDBInstanceClassesDBInstanceStorageRange) SetStep(v int32) *DescribeAvailableClassesResponseBodyDBInstanceClassesDBInstanceStorageRange {
	s.Step = &v
	return s
}

type DescribeAvailableClassesResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeAvailableClassesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeAvailableClassesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeAvailableClassesResponse) GoString() string {
	return s.String()
}

func (s *DescribeAvailableClassesResponse) SetHeaders(v map[string]*string) *DescribeAvailableClassesResponse {
	s.Headers = v
	return s
}

func (s *DescribeAvailableClassesResponse) SetStatusCode(v int32) *DescribeAvailableClassesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeAvailableClassesResponse) SetBody(v *DescribeAvailableClassesResponseBody) *DescribeAvailableClassesResponse {
	s.Body = v
	return s
}

type DescribeAvailableCrossRegionRequest struct {
	OwnerId *int64 `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID. You can call the DescribeRegions operation to query the most recent zone list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeAvailableCrossRegionRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeAvailableCrossRegionRequest) GoString() string {
	return s.String()
}

func (s *DescribeAvailableCrossRegionRequest) SetOwnerId(v int64) *DescribeAvailableCrossRegionRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeAvailableCrossRegionRequest) SetRegionId(v string) *DescribeAvailableCrossRegionRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeAvailableCrossRegionRequest) SetResourceOwnerAccount(v string) *DescribeAvailableCrossRegionRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeAvailableCrossRegionRequest) SetResourceOwnerId(v int64) *DescribeAvailableCrossRegionRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeAvailableCrossRegionResponseBody struct {
	// An array that consists of destination regions for cross-region backups.
	Regions *DescribeAvailableCrossRegionResponseBodyRegions `json:"Regions,omitempty" xml:"Regions,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeAvailableCrossRegionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeAvailableCrossRegionResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeAvailableCrossRegionResponseBody) SetRegions(v *DescribeAvailableCrossRegionResponseBodyRegions) *DescribeAvailableCrossRegionResponseBody {
	s.Regions = v
	return s
}

func (s *DescribeAvailableCrossRegionResponseBody) SetRequestId(v string) *DescribeAvailableCrossRegionResponseBody {
	s.RequestId = &v
	return s
}

type DescribeAvailableCrossRegionResponseBodyRegions struct {
	Region []*string `json:"Region,omitempty" xml:"Region,omitempty" type:"Repeated"`
}

func (s DescribeAvailableCrossRegionResponseBodyRegions) String() string {
	return tea.Prettify(s)
}

func (s DescribeAvailableCrossRegionResponseBodyRegions) GoString() string {
	return s.String()
}

func (s *DescribeAvailableCrossRegionResponseBodyRegions) SetRegion(v []*string) *DescribeAvailableCrossRegionResponseBodyRegions {
	s.Region = v
	return s
}

type DescribeAvailableCrossRegionResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeAvailableCrossRegionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeAvailableCrossRegionResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeAvailableCrossRegionResponse) GoString() string {
	return s.String()
}

func (s *DescribeAvailableCrossRegionResponse) SetHeaders(v map[string]*string) *DescribeAvailableCrossRegionResponse {
	s.Headers = v
	return s
}

func (s *DescribeAvailableCrossRegionResponse) SetStatusCode(v int32) *DescribeAvailableCrossRegionResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeAvailableCrossRegionResponse) SetBody(v *DescribeAvailableCrossRegionResponseBody) *DescribeAvailableCrossRegionResponse {
	s.Body = v
	return s
}

type DescribeAvailableMetricsRequest struct {
	// The ID of the instance. You can call the [DescribeDBInstances](~~26232~~) operation to query the IDs of instances.
	DBInstanceName *string `json:"DBInstanceName,omitempty" xml:"DBInstanceName,omitempty"`
	// The resource group ID.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerId *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeAvailableMetricsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeAvailableMetricsRequest) GoString() string {
	return s.String()
}

func (s *DescribeAvailableMetricsRequest) SetDBInstanceName(v string) *DescribeAvailableMetricsRequest {
	s.DBInstanceName = &v
	return s
}

func (s *DescribeAvailableMetricsRequest) SetResourceGroupId(v string) *DescribeAvailableMetricsRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeAvailableMetricsRequest) SetResourceOwnerId(v int64) *DescribeAvailableMetricsRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeAvailableMetricsResponseBody struct {
	// The instance ID.
	DBInstanceName *string `json:"DBInstanceName,omitempty" xml:"DBInstanceName,omitempty"`
	// Details of the Enhanced Monitoring metric.
	Items []*DescribeAvailableMetricsResponseBodyItems `json:"Items,omitempty" xml:"Items,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of enhanced monitoring metrics that are available for the instance.
	TotalRecordCount *int32 `json:"TotalRecordCount,omitempty" xml:"TotalRecordCount,omitempty"`
}

func (s DescribeAvailableMetricsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeAvailableMetricsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeAvailableMetricsResponseBody) SetDBInstanceName(v string) *DescribeAvailableMetricsResponseBody {
	s.DBInstanceName = &v
	return s
}

func (s *DescribeAvailableMetricsResponseBody) SetItems(v []*DescribeAvailableMetricsResponseBodyItems) *DescribeAvailableMetricsResponseBody {
	s.Items = v
	return s
}

func (s *DescribeAvailableMetricsResponseBody) SetRequestId(v string) *DescribeAvailableMetricsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeAvailableMetricsResponseBody) SetTotalRecordCount(v int32) *DescribeAvailableMetricsResponseBody {
	s.TotalRecordCount = &v
	return s
}

type DescribeAvailableMetricsResponseBodyItems struct {
	// The description of the Enhanced Monitoring metric.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The category of the Enhanced Monitoring metric. Valid values:
	//
	// *   **os**: OS metric
	// *   **db**: database metric
	Dimension *string `json:"Dimension,omitempty" xml:"Dimension,omitempty"`
	// The key of the group to which the Enhanced Monitoring metric belongs.
	GroupKey *string `json:"GroupKey,omitempty" xml:"GroupKey,omitempty"`
	// The name of the group to which the Enhanced Monitoring metric belongs.
	GroupKeyType *string `json:"GroupKeyType,omitempty" xml:"GroupKeyType,omitempty"`
	// The method that is used to aggregate the monitoring data of the Enhanced Monitoring metric. Valid values:
	//
	// *   **avg**: The system calculates the average value of the Enhanced Monitoring metric.
	// *   **min**: The system calculates the minimum value of the Enhanced Monitoring metric.
	// *   **max**: The system calculates the maximum value of the Enhanced Monitoring metric.
	Method *string `json:"Method,omitempty" xml:"Method,omitempty"`
	// The key of the Enhanced Monitoring metric.
	MetricsKey *string `json:"MetricsKey,omitempty" xml:"MetricsKey,omitempty"`
	// The alias of the Enhanced Monitoring metric.
	MetricsKeyAlias *string `json:"MetricsKeyAlias,omitempty" xml:"MetricsKeyAlias,omitempty"`
	// The serial number of the Enhanced Monitoring metric.
	SortRule *int32 `json:"SortRule,omitempty" xml:"SortRule,omitempty"`
	// The unit of the Enhanced Monitoring metric.
	Unit *string `json:"Unit,omitempty" xml:"Unit,omitempty"`
}

func (s DescribeAvailableMetricsResponseBodyItems) String() string {
	return tea.Prettify(s)
}

func (s DescribeAvailableMetricsResponseBodyItems) GoString() string {
	return s.String()
}

func (s *DescribeAvailableMetricsResponseBodyItems) SetDescription(v string) *DescribeAvailableMetricsResponseBodyItems {
	s.Description = &v
	return s
}

func (s *DescribeAvailableMetricsResponseBodyItems) SetDimension(v string) *DescribeAvailableMetricsResponseBodyItems {
	s.Dimension = &v
	return s
}

func (s *DescribeAvailableMetricsResponseBodyItems) SetGroupKey(v string) *DescribeAvailableMetricsResponseBodyItems {
	s.GroupKey = &v
	return s
}

func (s *DescribeAvailableMetricsResponseBodyItems) SetGroupKeyType(v string) *DescribeAvailableMetricsResponseBodyItems {
	s.GroupKeyType = &v
	return s
}

func (s *DescribeAvailableMetricsResponseBodyItems) SetMethod(v string) *DescribeAvailableMetricsResponseBodyItems {
	s.Method = &v
	return s
}

func (s *DescribeAvailableMetricsResponseBodyItems) SetMetricsKey(v string) *DescribeAvailableMetricsResponseBodyItems {
	s.MetricsKey = &v
	return s
}

func (s *DescribeAvailableMetricsResponseBodyItems) SetMetricsKeyAlias(v string) *DescribeAvailableMetricsResponseBodyItems {
	s.MetricsKeyAlias = &v
	return s
}

func (s *DescribeAvailableMetricsResponseBodyItems) SetSortRule(v int32) *DescribeAvailableMetricsResponseBodyItems {
	s.SortRule = &v
	return s
}

func (s *DescribeAvailableMetricsResponseBodyItems) SetUnit(v string) *DescribeAvailableMetricsResponseBodyItems {
	s.Unit = &v
	return s
}

type DescribeAvailableMetricsResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeAvailableMetricsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeAvailableMetricsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeAvailableMetricsResponse) GoString() string {
	return s.String()
}

func (s *DescribeAvailableMetricsResponse) SetHeaders(v map[string]*string) *DescribeAvailableMetricsResponse {
	s.Headers = v
	return s
}

func (s *DescribeAvailableMetricsResponse) SetStatusCode(v int32) *DescribeAvailableMetricsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeAvailableMetricsResponse) SetBody(v *DescribeAvailableMetricsResponseBody) *DescribeAvailableMetricsResponse {
	s.Body = v
	return s
}

type DescribeAvailableRecoveryTimeRequest struct {
	// The ID of the cross-region data backup file. You can call the [DescribeCrossRegionBackups](~~121733~~) operation to query IDs of backup files.
	CrossBackupId *int32 `json:"CrossBackupId,omitempty" xml:"CrossBackupId,omitempty"`
	// The IDs of the instances. You can call the [DescribeDBInstances](~~26232~~) operation to query the ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of a resource group.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeAvailableRecoveryTimeRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeAvailableRecoveryTimeRequest) GoString() string {
	return s.String()
}

func (s *DescribeAvailableRecoveryTimeRequest) SetCrossBackupId(v int32) *DescribeAvailableRecoveryTimeRequest {
	s.CrossBackupId = &v
	return s
}

func (s *DescribeAvailableRecoveryTimeRequest) SetDBInstanceId(v string) *DescribeAvailableRecoveryTimeRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeAvailableRecoveryTimeRequest) SetOwnerId(v int64) *DescribeAvailableRecoveryTimeRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeAvailableRecoveryTimeRequest) SetRegionId(v string) *DescribeAvailableRecoveryTimeRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeAvailableRecoveryTimeRequest) SetResourceGroupId(v string) *DescribeAvailableRecoveryTimeRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeAvailableRecoveryTimeRequest) SetResourceOwnerAccount(v string) *DescribeAvailableRecoveryTimeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeAvailableRecoveryTimeRequest) SetResourceOwnerId(v int64) *DescribeAvailableRecoveryTimeRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeAvailableRecoveryTimeResponseBody struct {
	// The ID of the cross-region data backup file.
	CrossBackupId *int32 `json:"CrossBackupId,omitempty" xml:"CrossBackupId,omitempty"`
	// The start time to which data can be restored. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
	RecoveryBeginTime *string `json:"RecoveryBeginTime,omitempty" xml:"RecoveryBeginTime,omitempty"`
	// The end time to which data can be restored. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
	RecoveryEndTime *string `json:"RecoveryEndTime,omitempty" xml:"RecoveryEndTime,omitempty"`
	// The region where the source instance resides.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeAvailableRecoveryTimeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeAvailableRecoveryTimeResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeAvailableRecoveryTimeResponseBody) SetCrossBackupId(v int32) *DescribeAvailableRecoveryTimeResponseBody {
	s.CrossBackupId = &v
	return s
}

func (s *DescribeAvailableRecoveryTimeResponseBody) SetRecoveryBeginTime(v string) *DescribeAvailableRecoveryTimeResponseBody {
	s.RecoveryBeginTime = &v
	return s
}

func (s *DescribeAvailableRecoveryTimeResponseBody) SetRecoveryEndTime(v string) *DescribeAvailableRecoveryTimeResponseBody {
	s.RecoveryEndTime = &v
	return s
}

func (s *DescribeAvailableRecoveryTimeResponseBody) SetRegionId(v string) *DescribeAvailableRecoveryTimeResponseBody {
	s.RegionId = &v
	return s
}

func (s *DescribeAvailableRecoveryTimeResponseBody) SetRequestId(v string) *DescribeAvailableRecoveryTimeResponseBody {
	s.RequestId = &v
	return s
}

type DescribeAvailableRecoveryTimeResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeAvailableRecoveryTimeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeAvailableRecoveryTimeResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeAvailableRecoveryTimeResponse) GoString() string {
	return s.String()
}

func (s *DescribeAvailableRecoveryTimeResponse) SetHeaders(v map[string]*string) *DescribeAvailableRecoveryTimeResponse {
	s.Headers = v
	return s
}

func (s *DescribeAvailableRecoveryTimeResponse) SetStatusCode(v int32) *DescribeAvailableRecoveryTimeResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeAvailableRecoveryTimeResponse) SetBody(v *DescribeAvailableRecoveryTimeResponseBody) *DescribeAvailableRecoveryTimeResponse {
	s.Body = v
	return s
}

type DescribeAvailableZonesRequest struct {
	// The RDS edition of the instance. Valid values:
	//
	// *   Regular instance
	//
	//     *   **Basic**: RDS Basic Edition.
	//     *   **HighAvailability**: RDS High-availability Edition.
	//     *   **cluster**: RDS Cluster Edition for ApsaraDB RDS for MySQL.
	//     *   **AlwaysOn**: RDS Cluster Edition for ApsaraDB RDS for SQL Server.
	//     *   **Finance**: RDS Enterprise Edition.
	//
	// *   Serverless instance
	//
	//     *   **serverless_basic**: RDS Basic Edition. This edition is available only for instances that run MySQL and PostgreSQL.
	//     *   **serverless_standard**: RDS High-availability Edition for ApsaraDB RDS for MySQL.
	//     *   **serverless_ha**: RDS High-availability Edition for ApsaraDB RDS for SQL Server.
	Category *string `json:"Category,omitempty" xml:"Category,omitempty"`
	// The commodity code of the instance. This operation can return the resources that you can purchase based on the specified commodity code. Valid values:
	//
	// *   **bards**: The instance is a pay-as-you-go primary instance. This value is available at the China site (aliyun.com).
	// *   **rds**: The instance is a subscription primary instance. This value is available at the China site (aliyun.com).
	// *   **rords**: The instance is a pay-as-you-go read-only instance. This value is available at the China site (aliyun.com).
	// *   **rds_rordspre_public_cn**: The instance is a subscription read-only instance. This value is available at the China site (aliyun.com).
	// *   **bards_intl**: The instance is a pay-as-you-go primary instance. This value is available at the International site (alibabacloud.com).
	// *   **rds_intl**: The instance is a subscription primary instance. This value is available at the International site (alibabacloud.com).
	// *   **rords_intl**: The instance is a pay-as-you-go read-only instance. This value is available at the International site (alibabacloud.com).
	// *   **rds_rordspre_public_intl**: The instance is a subscription read-only instance. This value is available at the International site (alibabacloud.com).
	// *   **rds_serverless_public_cn**: The instance is a serverless instance. This value is available at the China site (aliyun.com).
	// *   **rds_serverless_public_intl**: The instance is a serverless instance. This value is available at the International site (alibabacloud.com).
	CommodityCode *string `json:"CommodityCode,omitempty" xml:"CommodityCode,omitempty"`
	// The ID of the primary instance. If you want to query the read-only instances that you can purchase for a primary instance, you can specify this parameter.
	//
	// If you set **CommodityCode** to one of the following values, you must specify this parameter:
	//
	// *   **rords_intl**
	// *   **rds_rordspre_public_intl**
	// *   **rords**
	// *   **rds_rordspre_public_cn**
	DBInstanceName *string `json:"DBInstanceName,omitempty" xml:"DBInstanceName,omitempty"`
	// Specifies whether to return the zones in which the single-zone deployment method is supported. Valid values:
	//
	// *   **1** (default): returns the zones.
	// *   **0**: does not return the zones.
	//
	// >  The single-zone deployment method allows you to deploy an instance that runs RDS Enterprise Edition in a single zone.
	DispenseMode *string `json:"DispenseMode,omitempty" xml:"DispenseMode,omitempty"`
	// The database engine of the instance. Valid values:
	//
	// *   **MySQL**
	// *   **SQLServer**
	// *   **PostgreSQL**
	// *   **MariaDB**
	Engine *string `json:"Engine,omitempty" xml:"Engine,omitempty"`
	// The database engine version. Valid values:
	//
	// *   Regular instance
	//
	//     *   Valid values if you set Engine to MySQL: **5.5**, **5.6**, **5.7**, and **8.0**
	//     *   Valid values if you set Engine to SQLServer: **2008r2**, **08r2\_ent_ha**, **2012**, **2012\_ent_ha**, **2012\_std_ha**, **2012\_web**, **2014\_std_ha**, **2016\_ent_ha**, **2016\_std_ha**, **2016\_web**, **2017\_std_ha**, **2017\_ent**, **2019\_std_ha**, and **2019\_ent**
	//     *   Valid values if you set Engine to PostgreSQL: **10.0**, **11.0**, **12.0**, **13.0**, **14.0**, and **15.0**
	//     *   Valid value when you set Engine to MariaDB: **10.3**
	//
	// *   Serverless instance
	//
	//     *   Valid values if you set Engine to MySQL: **5.7** and **8.0**
	//     *   Valid values if you set Engine to SQLServer: **2016\_std_sl**, **2017\_std_sl**, and **2019\_std_sl**
	//     *   Valid value if you set Engine to PostgreSQL: **14.0**
	//
	//     **
	//
	//     **Note**ApsaraDB RDS for MariaDB does not support serverless instances.
	EngineVersion *string `json:"EngineVersion,omitempty" xml:"EngineVersion,omitempty"`
	// The region ID. You can call the [DescribeRegions](~~610399~~) operation to query the most recent region list.
	RegionId        *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerId *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The zone ID of the instance. If the instance spans more than one zone, the value of this parameter contains an `MAZ` part, such as `cn-hangzhou-MAZ6(b,f)` and `cn-hangzhou-MAZ5(b,e,f)`. You can call the [DescribeRegions](~~26243~~) operation to query the most recent zone list.
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
}

func (s DescribeAvailableZonesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeAvailableZonesRequest) GoString() string {
	return s.String()
}

func (s *DescribeAvailableZonesRequest) SetCategory(v string) *DescribeAvailableZonesRequest {
	s.Category = &v
	return s
}

func (s *DescribeAvailableZonesRequest) SetCommodityCode(v string) *DescribeAvailableZonesRequest {
	s.CommodityCode = &v
	return s
}

func (s *DescribeAvailableZonesRequest) SetDBInstanceName(v string) *DescribeAvailableZonesRequest {
	s.DBInstanceName = &v
	return s
}

func (s *DescribeAvailableZonesRequest) SetDispenseMode(v string) *DescribeAvailableZonesRequest {
	s.DispenseMode = &v
	return s
}

func (s *DescribeAvailableZonesRequest) SetEngine(v string) *DescribeAvailableZonesRequest {
	s.Engine = &v
	return s
}

func (s *DescribeAvailableZonesRequest) SetEngineVersion(v string) *DescribeAvailableZonesRequest {
	s.EngineVersion = &v
	return s
}

func (s *DescribeAvailableZonesRequest) SetRegionId(v string) *DescribeAvailableZonesRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeAvailableZonesRequest) SetResourceOwnerId(v int64) *DescribeAvailableZonesRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeAvailableZonesRequest) SetZoneId(v string) *DescribeAvailableZonesRequest {
	s.ZoneId = &v
	return s
}

type DescribeAvailableZonesResponseBody struct {
	// The available zones in the region.
	AvailableZones []*DescribeAvailableZonesResponseBodyAvailableZones `json:"AvailableZones,omitempty" xml:"AvailableZones,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeAvailableZonesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeAvailableZonesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeAvailableZonesResponseBody) SetAvailableZones(v []*DescribeAvailableZonesResponseBodyAvailableZones) *DescribeAvailableZonesResponseBody {
	s.AvailableZones = v
	return s
}

func (s *DescribeAvailableZonesResponseBody) SetRequestId(v string) *DescribeAvailableZonesResponseBody {
	s.RequestId = &v
	return s
}

type DescribeAvailableZonesResponseBodyAvailableZones struct {
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The database engines that are available for purchase.
	SupportedEngines []*DescribeAvailableZonesResponseBodyAvailableZonesSupportedEngines `json:"SupportedEngines,omitempty" xml:"SupportedEngines,omitempty" type:"Repeated"`
	// The zone ID.
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
}

func (s DescribeAvailableZonesResponseBodyAvailableZones) String() string {
	return tea.Prettify(s)
}

func (s DescribeAvailableZonesResponseBodyAvailableZones) GoString() string {
	return s.String()
}

func (s *DescribeAvailableZonesResponseBodyAvailableZones) SetRegionId(v string) *DescribeAvailableZonesResponseBodyAvailableZones {
	s.RegionId = &v
	return s
}

func (s *DescribeAvailableZonesResponseBodyAvailableZones) SetSupportedEngines(v []*DescribeAvailableZonesResponseBodyAvailableZonesSupportedEngines) *DescribeAvailableZonesResponseBodyAvailableZones {
	s.SupportedEngines = v
	return s
}

func (s *DescribeAvailableZonesResponseBodyAvailableZones) SetZoneId(v string) *DescribeAvailableZonesResponseBodyAvailableZones {
	s.ZoneId = &v
	return s
}

type DescribeAvailableZonesResponseBodyAvailableZonesSupportedEngines struct {
	// The database engine of the instance.
	Engine *string `json:"Engine,omitempty" xml:"Engine,omitempty"`
	// The database engine versions that are available for purchase.
	SupportedEngineVersions []*DescribeAvailableZonesResponseBodyAvailableZonesSupportedEnginesSupportedEngineVersions `json:"SupportedEngineVersions,omitempty" xml:"SupportedEngineVersions,omitempty" type:"Repeated"`
}

func (s DescribeAvailableZonesResponseBodyAvailableZonesSupportedEngines) String() string {
	return tea.Prettify(s)
}

func (s DescribeAvailableZonesResponseBodyAvailableZonesSupportedEngines) GoString() string {
	return s.String()
}

func (s *DescribeAvailableZonesResponseBodyAvailableZonesSupportedEngines) SetEngine(v string) *DescribeAvailableZonesResponseBodyAvailableZonesSupportedEngines {
	s.Engine = &v
	return s
}

func (s *DescribeAvailableZonesResponseBodyAvailableZonesSupportedEngines) SetSupportedEngineVersions(v []*DescribeAvailableZonesResponseBodyAvailableZonesSupportedEnginesSupportedEngineVersions) *DescribeAvailableZonesResponseBodyAvailableZonesSupportedEngines {
	s.SupportedEngineVersions = v
	return s
}

type DescribeAvailableZonesResponseBodyAvailableZonesSupportedEnginesSupportedEngineVersions struct {
	// The RDS editions that are available that are available for purchase.
	SupportedCategorys []*DescribeAvailableZonesResponseBodyAvailableZonesSupportedEnginesSupportedEngineVersionsSupportedCategorys `json:"SupportedCategorys,omitempty" xml:"SupportedCategorys,omitempty" type:"Repeated"`
	// The database engine version.
	Version *string `json:"Version,omitempty" xml:"Version,omitempty"`
}

func (s DescribeAvailableZonesResponseBodyAvailableZonesSupportedEnginesSupportedEngineVersions) String() string {
	return tea.Prettify(s)
}

func (s DescribeAvailableZonesResponseBodyAvailableZonesSupportedEnginesSupportedEngineVersions) GoString() string {
	return s.String()
}

func (s *DescribeAvailableZonesResponseBodyAvailableZonesSupportedEnginesSupportedEngineVersions) SetSupportedCategorys(v []*DescribeAvailableZonesResponseBodyAvailableZonesSupportedEnginesSupportedEngineVersionsSupportedCategorys) *DescribeAvailableZonesResponseBodyAvailableZonesSupportedEnginesSupportedEngineVersions {
	s.SupportedCategorys = v
	return s
}

func (s *DescribeAvailableZonesResponseBodyAvailableZonesSupportedEnginesSupportedEngineVersions) SetVersion(v string) *DescribeAvailableZonesResponseBodyAvailableZonesSupportedEnginesSupportedEngineVersions {
	s.Version = &v
	return s
}

type DescribeAvailableZonesResponseBodyAvailableZonesSupportedEnginesSupportedEngineVersionsSupportedCategorys struct {
	// The RDS edition of the instance.
	Category *string `json:"Category,omitempty" xml:"Category,omitempty"`
	// The storage types that are available for purchase.
	SupportedStorageTypes []*DescribeAvailableZonesResponseBodyAvailableZonesSupportedEnginesSupportedEngineVersionsSupportedCategorysSupportedStorageTypes `json:"SupportedStorageTypes,omitempty" xml:"SupportedStorageTypes,omitempty" type:"Repeated"`
}

func (s DescribeAvailableZonesResponseBodyAvailableZonesSupportedEnginesSupportedEngineVersionsSupportedCategorys) String() string {
	return tea.Prettify(s)
}

func (s DescribeAvailableZonesResponseBodyAvailableZonesSupportedEnginesSupportedEngineVersionsSupportedCategorys) GoString() string {
	return s.String()
}

func (s *DescribeAvailableZonesResponseBodyAvailableZonesSupportedEnginesSupportedEngineVersionsSupportedCategorys) SetCategory(v string) *DescribeAvailableZonesResponseBodyAvailableZonesSupportedEnginesSupportedEngineVersionsSupportedCategorys {
	s.Category = &v
	return s
}

func (s *DescribeAvailableZonesResponseBodyAvailableZonesSupportedEnginesSupportedEngineVersionsSupportedCategorys) SetSupportedStorageTypes(v []*DescribeAvailableZonesResponseBodyAvailableZonesSupportedEnginesSupportedEngineVersionsSupportedCategorysSupportedStorageTypes) *DescribeAvailableZonesResponseBodyAvailableZonesSupportedEnginesSupportedEngineVersionsSupportedCategorys {
	s.SupportedStorageTypes = v
	return s
}

type DescribeAvailableZonesResponseBodyAvailableZonesSupportedEnginesSupportedEngineVersionsSupportedCategorysSupportedStorageTypes struct {
	// The storage type of the instance.
	StorageType *string `json:"StorageType,omitempty" xml:"StorageType,omitempty"`
}

func (s DescribeAvailableZonesResponseBodyAvailableZonesSupportedEnginesSupportedEngineVersionsSupportedCategorysSupportedStorageTypes) String() string {
	return tea.Prettify(s)
}

func (s DescribeAvailableZonesResponseBodyAvailableZonesSupportedEnginesSupportedEngineVersionsSupportedCategorysSupportedStorageTypes) GoString() string {
	return s.String()
}

func (s *DescribeAvailableZonesResponseBodyAvailableZonesSupportedEnginesSupportedEngineVersionsSupportedCategorysSupportedStorageTypes) SetStorageType(v string) *DescribeAvailableZonesResponseBodyAvailableZonesSupportedEnginesSupportedEngineVersionsSupportedCategorysSupportedStorageTypes {
	s.StorageType = &v
	return s
}

type DescribeAvailableZonesResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeAvailableZonesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeAvailableZonesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeAvailableZonesResponse) GoString() string {
	return s.String()
}

func (s *DescribeAvailableZonesResponse) SetHeaders(v map[string]*string) *DescribeAvailableZonesResponse {
	s.Headers = v
	return s
}

func (s *DescribeAvailableZonesResponse) SetStatusCode(v int32) *DescribeAvailableZonesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeAvailableZonesResponse) SetBody(v *DescribeAvailableZonesResponseBody) *DescribeAvailableZonesResponse {
	s.Body = v
	return s
}

type DescribeBackupDatabaseRequest struct {
	// The ID of the backup set.
	BackupId *string `json:"BackupId,omitempty" xml:"BackupId,omitempty"`
	// The ID of the instance.
	DBInstanceId         *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeBackupDatabaseRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeBackupDatabaseRequest) GoString() string {
	return s.String()
}

func (s *DescribeBackupDatabaseRequest) SetBackupId(v string) *DescribeBackupDatabaseRequest {
	s.BackupId = &v
	return s
}

func (s *DescribeBackupDatabaseRequest) SetDBInstanceId(v string) *DescribeBackupDatabaseRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeBackupDatabaseRequest) SetOwnerId(v int64) *DescribeBackupDatabaseRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeBackupDatabaseRequest) SetResourceOwnerAccount(v string) *DescribeBackupDatabaseRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeBackupDatabaseRequest) SetResourceOwnerId(v int64) *DescribeBackupDatabaseRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeBackupDatabaseResponseBody struct {
	// The name of the database. Format: "db1,db2".
	DatabaseNames *string `json:"DatabaseNames,omitempty" xml:"DatabaseNames,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeBackupDatabaseResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeBackupDatabaseResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeBackupDatabaseResponseBody) SetDatabaseNames(v string) *DescribeBackupDatabaseResponseBody {
	s.DatabaseNames = &v
	return s
}

func (s *DescribeBackupDatabaseResponseBody) SetRequestId(v string) *DescribeBackupDatabaseResponseBody {
	s.RequestId = &v
	return s
}

type DescribeBackupDatabaseResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeBackupDatabaseResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeBackupDatabaseResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeBackupDatabaseResponse) GoString() string {
	return s.String()
}

func (s *DescribeBackupDatabaseResponse) SetHeaders(v map[string]*string) *DescribeBackupDatabaseResponse {
	s.Headers = v
	return s
}

func (s *DescribeBackupDatabaseResponse) SetStatusCode(v int32) *DescribeBackupDatabaseResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeBackupDatabaseResponse) SetBody(v *DescribeBackupDatabaseResponseBody) *DescribeBackupDatabaseResponse {
	s.Body = v
	return s
}

type DescribeBackupPolicyRequest struct {
	// The backup type. Valid values:
	//
	// *   **DataBackupPolicy**: data backup
	// *   **LogBackupPolicy**: log backup
	BackupPolicyMode *string `json:"BackupPolicyMode,omitempty" xml:"BackupPolicyMode,omitempty"`
	// The method that is used to compress backup data. Valid values:
	//
	// *   **0**: Backup data is not compressed.
	// *   **1**: Backup data is compressed by using zlib.
	// *   **2**: Backup data is compressed by using zlib that invokes more than one thread in parallel for each backup.
	// *   **4**: Backup data is compressed by using QuickLZ and can be used to restore individual databases and tables.
	// *   **8**: Backup data is compressed by using QuickLZ but cannot be used to restore individual databases or tables. This value is available only when the instance runs MySQL 8.0.
	CompressType *string `json:"CompressType,omitempty" xml:"CompressType,omitempty"`
	// The instance ID. You can call the [DescribeDBInstances](~~610396~~) operation to query the ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The policy that is used to retain archived backup files if the instance is released. Valid values:
	//
	// *   **None**: No archived backup files are retained.
	// *   **Lastest**: Only the last archived backup file is retained.
	// *   **All**: All archived backup files are retained.
	ReleasedKeepPolicy   *string `json:"ReleasedKeepPolicy,omitempty" xml:"ReleasedKeepPolicy,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeBackupPolicyRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeBackupPolicyRequest) GoString() string {
	return s.String()
}

func (s *DescribeBackupPolicyRequest) SetBackupPolicyMode(v string) *DescribeBackupPolicyRequest {
	s.BackupPolicyMode = &v
	return s
}

func (s *DescribeBackupPolicyRequest) SetCompressType(v string) *DescribeBackupPolicyRequest {
	s.CompressType = &v
	return s
}

func (s *DescribeBackupPolicyRequest) SetDBInstanceId(v string) *DescribeBackupPolicyRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeBackupPolicyRequest) SetOwnerAccount(v string) *DescribeBackupPolicyRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeBackupPolicyRequest) SetOwnerId(v int64) *DescribeBackupPolicyRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeBackupPolicyRequest) SetReleasedKeepPolicy(v string) *DescribeBackupPolicyRequest {
	s.ReleasedKeepPolicy = &v
	return s
}

func (s *DescribeBackupPolicyRequest) SetResourceOwnerAccount(v string) *DescribeBackupPolicyRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeBackupPolicyRequest) SetResourceOwnerId(v int64) *DescribeBackupPolicyRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeBackupPolicyResponseBody struct {
	// The number of archived backup files that are retained.
	ArchiveBackupKeepCount *string `json:"ArchiveBackupKeepCount,omitempty" xml:"ArchiveBackupKeepCount,omitempty"`
	// The cycle based on which archived backup files are retained.
	ArchiveBackupKeepPolicy *string `json:"ArchiveBackupKeepPolicy,omitempty" xml:"ArchiveBackupKeepPolicy,omitempty"`
	// The number of days for which archived backup files are retained.
	ArchiveBackupRetentionPeriod *string `json:"ArchiveBackupRetentionPeriod,omitempty" xml:"ArchiveBackupRetentionPeriod,omitempty"`
	// The backup interval. Unit: minutes.
	//
	// *   If the instance runs MySQL, the interval is the same as the value of the Snapshot Backup Start Time parameter rather than the Snapshot Backup Period parameter in the ApsaraDB RDS console. For more information, see [Back up an ApsaraDB RDS for MySQL instance](~~98818~~).
	// *   If the instance runs SQL Server, the interval is the same as the log backup frequency.
	BackupInterval *string `json:"BackupInterval,omitempty" xml:"BackupInterval,omitempty"`
	// Indicates whether the log backup feature is enabled. Valid values:
	//
	// *   **Enable**
	// *   **Disabled**
	BackupLog *string `json:"BackupLog,omitempty" xml:"BackupLog,omitempty"`
	// The backup method of the instance. Valid values:
	//
	// *   **Physical**: physical backup
	// *   **Snapshot**: snapshot backup
	//
	// > This parameter is returned only when the instance runs SQL Server and uses cloud disks.
	BackupMethod *string `json:"BackupMethod,omitempty" xml:"BackupMethod,omitempty"`
	// The backup settings of the secondary instance. Valid values:
	//
	// *   **1**: Secondary instance preferred
	// *   **2**: Primary instance preferred
	//
	// >  This parameter is available only for instances that run SQL Server on RDS Cluster Edition. This parameter is returned only when SupportModifyBackupPriority is set to True.
	BackupPriority *int32 `json:"BackupPriority,omitempty" xml:"BackupPriority,omitempty"`
	// The number of days for which data backup files are retained.
	BackupRetentionPeriod *int32 `json:"BackupRetentionPeriod,omitempty" xml:"BackupRetentionPeriod,omitempty"`
	// Indicates whether to enable the single-digit second backup feature. This feature allows ApsaraDB RDS to complete a backup within single-digit seconds. Valid values:
	//
	// *   **Flash**: The single-digit second backup feature is enabled.
	// *   **Standard**: The single-digit second backup feature is disabled.
	//
	// > This parameter takes effect only when you set the **BackupPolicyMode** parameter to **DataBackupPolicy**.
	Category *string `json:"Category,omitempty" xml:"Category,omitempty"`
	// The method that is used to compress backup data. Valid values:
	//
	// *   **0**: Backup data is not compressed.
	// *   **1**: Backup data is compressed by using zlib.
	// *   **2**: Backup data is compressed by using zlib that invokes more than one thread in parallel for each backup.
	// *   **4**: Backup data is compressed by using QuickLZ and can be used to restore individual databases and tables.
	// *   **8**: Backup data is compressed by using QuickLZ but cannot be used to restore individual databases or tables. This value is available only when the instance runs MySQL 8.0.
	CompressType *string `json:"CompressType,omitempty" xml:"CompressType,omitempty"`
	// Indicates whether the log backup feature is enabled. Valid values:
	//
	// *   **1**: The log backup feature is enabled.
	// *   **0**: The log backup feature is disabled.
	EnableBackupLog *string `json:"EnableBackupLog,omitempty" xml:"EnableBackupLog,omitempty"`
	// Indicates whether incremental backup is enabled. Valid values:
	//
	// *   **True**: Incremental backup is enabled.
	// *   **False**: Incremental backup is disabled.
	EnableIncrementDataBackup *bool `json:"EnableIncrementDataBackup,omitempty" xml:"EnableIncrementDataBackup,omitempty"`
	// Indicates whether the log backup deletion feature is enabled. If the disk usage exceeds 80% or the remaining disk space is less than 5 GB on the instance, this feature deletes binary log files. Valid values:
	//
	// *   **Disable**
	// *   **Enable**
	HighSpaceUsageProtection *string `json:"HighSpaceUsageProtection,omitempty" xml:"HighSpaceUsageProtection,omitempty"`
	// The number of hours for which log backup files are retained on the instance.
	LocalLogRetentionHours *int32 `json:"LocalLogRetentionHours,omitempty" xml:"LocalLogRetentionHours,omitempty"`
	// The maximum storage usage that is allowed for log files on the instance.
	LocalLogRetentionSpace *string `json:"LocalLogRetentionSpace,omitempty" xml:"LocalLogRetentionSpace,omitempty"`
	// The backup frequency of logs. Valid values:
	//
	// *   **LogInterval**: Log backups are performed every 30 minutes.
	// *   Default value: same as the value of the **PreferredBackupPeriod** parameter.
	//
	// > The **LogBackupFrequency** parameter is supported only when the instance runs **SQL Server**.
	LogBackupFrequency *string `json:"LogBackupFrequency,omitempty" xml:"LogBackupFrequency,omitempty"`
	// The number of binary log files that you want to retain on the instance.
	LogBackupLocalRetentionNumber *int32 `json:"LogBackupLocalRetentionNumber,omitempty" xml:"LogBackupLocalRetentionNumber,omitempty"`
	// The number of days for which log backup files are retained.
	LogBackupRetentionPeriod *int32 `json:"LogBackupRetentionPeriod,omitempty" xml:"LogBackupRetentionPeriod,omitempty"`
	// The cycle based on which you want to perform a backup. Separate multiple values with commas (,). Valid values:
	//
	// *   **Monday**
	// *   **Tuesday**
	// *   **Wednesday**
	// *   **Thursday**
	// *   **Friday**
	// *   **Saturday**
	// *   **Sunday**
	PreferredBackupPeriod *string `json:"PreferredBackupPeriod,omitempty" xml:"PreferredBackupPeriod,omitempty"`
	// The time when a data backup is performed. The time follows the ISO 8601 standard in the *HH:mm*Z-*HH:mm*Z format. The time is displayed in UTC.
	PreferredBackupTime *string `json:"PreferredBackupTime,omitempty" xml:"PreferredBackupTime,omitempty"`
	// The time when the next backup is performed. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm*Z format. The time is displayed in UTC.
	PreferredNextBackupTime *string `json:"PreferredNextBackupTime,omitempty" xml:"PreferredNextBackupTime,omitempty"`
	// The policy that is used to retain archived backup files if the instance is released. Valid values:
	//
	// *   **None**: No archived backup files are retained.
	// *   **Lastest**: Only the last archived backup file is retained.
	// *   **All**: All archived backup files are retained.
	ReleasedKeepPolicy *string `json:"ReleasedKeepPolicy,omitempty" xml:"ReleasedKeepPolicy,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the backup settings of a secondary instance can be modified. Valid values:
	//
	// *   **True**
	// *   **False**
	SupportModifyBackupPriority *bool `json:"SupportModifyBackupPriority,omitempty" xml:"SupportModifyBackupPriority,omitempty"`
	// A reserved parameter.
	SupportReleasedKeep *int32 `json:"SupportReleasedKeep,omitempty" xml:"SupportReleasedKeep,omitempty"`
	// Indicates whether the instance supports snapshot backups. Valid values:
	//
	// *   **1**: The instance supports snapshot backups.
	// *   **0**: The instance does not support snapshot backups.
	//
	// > This parameter is returned only when the instance runs SQL Server.
	SupportVolumeShadowCopy *int32 `json:"SupportVolumeShadowCopy,omitempty" xml:"SupportVolumeShadowCopy,omitempty"`
}

func (s DescribeBackupPolicyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeBackupPolicyResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeBackupPolicyResponseBody) SetArchiveBackupKeepCount(v string) *DescribeBackupPolicyResponseBody {
	s.ArchiveBackupKeepCount = &v
	return s
}

func (s *DescribeBackupPolicyResponseBody) SetArchiveBackupKeepPolicy(v string) *DescribeBackupPolicyResponseBody {
	s.ArchiveBackupKeepPolicy = &v
	return s
}

func (s *DescribeBackupPolicyResponseBody) SetArchiveBackupRetentionPeriod(v string) *DescribeBackupPolicyResponseBody {
	s.ArchiveBackupRetentionPeriod = &v
	return s
}

func (s *DescribeBackupPolicyResponseBody) SetBackupInterval(v string) *DescribeBackupPolicyResponseBody {
	s.BackupInterval = &v
	return s
}

func (s *DescribeBackupPolicyResponseBody) SetBackupLog(v string) *DescribeBackupPolicyResponseBody {
	s.BackupLog = &v
	return s
}

func (s *DescribeBackupPolicyResponseBody) SetBackupMethod(v string) *DescribeBackupPolicyResponseBody {
	s.BackupMethod = &v
	return s
}

func (s *DescribeBackupPolicyResponseBody) SetBackupPriority(v int32) *DescribeBackupPolicyResponseBody {
	s.BackupPriority = &v
	return s
}

func (s *DescribeBackupPolicyResponseBody) SetBackupRetentionPeriod(v int32) *DescribeBackupPolicyResponseBody {
	s.BackupRetentionPeriod = &v
	return s
}

func (s *DescribeBackupPolicyResponseBody) SetCategory(v string) *DescribeBackupPolicyResponseBody {
	s.Category = &v
	return s
}

func (s *DescribeBackupPolicyResponseBody) SetCompressType(v string) *DescribeBackupPolicyResponseBody {
	s.CompressType = &v
	return s
}

func (s *DescribeBackupPolicyResponseBody) SetEnableBackupLog(v string) *DescribeBackupPolicyResponseBody {
	s.EnableBackupLog = &v
	return s
}

func (s *DescribeBackupPolicyResponseBody) SetEnableIncrementDataBackup(v bool) *DescribeBackupPolicyResponseBody {
	s.EnableIncrementDataBackup = &v
	return s
}

func (s *DescribeBackupPolicyResponseBody) SetHighSpaceUsageProtection(v string) *DescribeBackupPolicyResponseBody {
	s.HighSpaceUsageProtection = &v
	return s
}

func (s *DescribeBackupPolicyResponseBody) SetLocalLogRetentionHours(v int32) *DescribeBackupPolicyResponseBody {
	s.LocalLogRetentionHours = &v
	return s
}

func (s *DescribeBackupPolicyResponseBody) SetLocalLogRetentionSpace(v string) *DescribeBackupPolicyResponseBody {
	s.LocalLogRetentionSpace = &v
	return s
}

func (s *DescribeBackupPolicyResponseBody) SetLogBackupFrequency(v string) *DescribeBackupPolicyResponseBody {
	s.LogBackupFrequency = &v
	return s
}

func (s *DescribeBackupPolicyResponseBody) SetLogBackupLocalRetentionNumber(v int32) *DescribeBackupPolicyResponseBody {
	s.LogBackupLocalRetentionNumber = &v
	return s
}

func (s *DescribeBackupPolicyResponseBody) SetLogBackupRetentionPeriod(v int32) *DescribeBackupPolicyResponseBody {
	s.LogBackupRetentionPeriod = &v
	return s
}

func (s *DescribeBackupPolicyResponseBody) SetPreferredBackupPeriod(v string) *DescribeBackupPolicyResponseBody {
	s.PreferredBackupPeriod = &v
	return s
}

func (s *DescribeBackupPolicyResponseBody) SetPreferredBackupTime(v string) *DescribeBackupPolicyResponseBody {
	s.PreferredBackupTime = &v
	return s
}

func (s *DescribeBackupPolicyResponseBody) SetPreferredNextBackupTime(v string) *DescribeBackupPolicyResponseBody {
	s.PreferredNextBackupTime = &v
	return s
}

func (s *DescribeBackupPolicyResponseBody) SetReleasedKeepPolicy(v string) *DescribeBackupPolicyResponseBody {
	s.ReleasedKeepPolicy = &v
	return s
}

func (s *DescribeBackupPolicyResponseBody) SetRequestId(v string) *DescribeBackupPolicyResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeBackupPolicyResponseBody) SetSupportModifyBackupPriority(v bool) *DescribeBackupPolicyResponseBody {
	s.SupportModifyBackupPriority = &v
	return s
}

func (s *DescribeBackupPolicyResponseBody) SetSupportReleasedKeep(v int32) *DescribeBackupPolicyResponseBody {
	s.SupportReleasedKeep = &v
	return s
}

func (s *DescribeBackupPolicyResponseBody) SetSupportVolumeShadowCopy(v int32) *DescribeBackupPolicyResponseBody {
	s.SupportVolumeShadowCopy = &v
	return s
}

type DescribeBackupPolicyResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeBackupPolicyResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeBackupPolicyResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeBackupPolicyResponse) GoString() string {
	return s.String()
}

func (s *DescribeBackupPolicyResponse) SetHeaders(v map[string]*string) *DescribeBackupPolicyResponse {
	s.Headers = v
	return s
}

func (s *DescribeBackupPolicyResponse) SetStatusCode(v int32) *DescribeBackupPolicyResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeBackupPolicyResponse) SetBody(v *DescribeBackupPolicyResponseBody) *DescribeBackupPolicyResponse {
	s.Body = v
	return s
}

type DescribeBackupTasksRequest struct {
	// The ID of the backup task.
	BackupJobId *int32 `json:"BackupJobId,omitempty" xml:"BackupJobId,omitempty"`
	// The status of the backup task. Valid values:
	//
	// *   **NoStart**
	// *   **Progressing**
	//
	// By default, this operation returns backup tasks in both states.
	BackupJobStatus *string `json:"BackupJobStatus,omitempty" xml:"BackupJobStatus,omitempty"`
	// The backup mode. Valid values:
	//
	// *   **Automated**
	// *   **Manual**
	BackupMode *string `json:"BackupMode,omitempty" xml:"BackupMode,omitempty"`
	// Specifies the client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The instance ID. You can call the [DescribeDBInstances](~~610396~~) operation to query the ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// A reserved parameter.
	Flag                 *string `json:"Flag,omitempty" xml:"Flag,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeBackupTasksRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeBackupTasksRequest) GoString() string {
	return s.String()
}

func (s *DescribeBackupTasksRequest) SetBackupJobId(v int32) *DescribeBackupTasksRequest {
	s.BackupJobId = &v
	return s
}

func (s *DescribeBackupTasksRequest) SetBackupJobStatus(v string) *DescribeBackupTasksRequest {
	s.BackupJobStatus = &v
	return s
}

func (s *DescribeBackupTasksRequest) SetBackupMode(v string) *DescribeBackupTasksRequest {
	s.BackupMode = &v
	return s
}

func (s *DescribeBackupTasksRequest) SetClientToken(v string) *DescribeBackupTasksRequest {
	s.ClientToken = &v
	return s
}

func (s *DescribeBackupTasksRequest) SetDBInstanceId(v string) *DescribeBackupTasksRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeBackupTasksRequest) SetFlag(v string) *DescribeBackupTasksRequest {
	s.Flag = &v
	return s
}

func (s *DescribeBackupTasksRequest) SetOwnerAccount(v string) *DescribeBackupTasksRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeBackupTasksRequest) SetOwnerId(v int64) *DescribeBackupTasksRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeBackupTasksRequest) SetResourceOwnerAccount(v string) *DescribeBackupTasksRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeBackupTasksRequest) SetResourceOwnerId(v int64) *DescribeBackupTasksRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeBackupTasksResponseBody struct {
	// The backup tasks.
	Items *DescribeBackupTasksResponseBodyItems `json:"Items,omitempty" xml:"Items,omitempty" type:"Struct"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeBackupTasksResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeBackupTasksResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeBackupTasksResponseBody) SetItems(v *DescribeBackupTasksResponseBodyItems) *DescribeBackupTasksResponseBody {
	s.Items = v
	return s
}

func (s *DescribeBackupTasksResponseBody) SetRequestId(v string) *DescribeBackupTasksResponseBody {
	s.RequestId = &v
	return s
}

type DescribeBackupTasksResponseBodyItems struct {
	BackupJob []*DescribeBackupTasksResponseBodyItemsBackupJob `json:"BackupJob,omitempty" xml:"BackupJob,omitempty" type:"Repeated"`
}

func (s DescribeBackupTasksResponseBodyItems) String() string {
	return tea.Prettify(s)
}

func (s DescribeBackupTasksResponseBodyItems) GoString() string {
	return s.String()
}

func (s *DescribeBackupTasksResponseBodyItems) SetBackupJob(v []*DescribeBackupTasksResponseBodyItemsBackupJob) *DescribeBackupTasksResponseBodyItems {
	s.BackupJob = v
	return s
}

type DescribeBackupTasksResponseBodyItemsBackupJob struct {
	// The ID of the backup set that is generated by the backup task.
	//
	// >  If the value of the **BackupStatus** parameter is **Finished**, you can view the backup set ID only if you configure the **BackupJobId** parameter.
	BackupId *string `json:"BackupId,omitempty" xml:"BackupId,omitempty"`
	// The ID of the backup task.
	BackupJobId *string `json:"BackupJobId,omitempty" xml:"BackupJobId,omitempty"`
	// The status of the backup program. Valid values:
	//
	// *   **NoStart**
	// *   **Preparing**
	// *   **Waiting**
	// *   **Uploading**
	// *   **Checking**
	// *   **Finished**
	BackupProgressStatus *string `json:"BackupProgressStatus,omitempty" xml:"BackupProgressStatus,omitempty"`
	// The status of the backup task. Valid values:
	//
	// *   **NoStart**
	// *   **Checking**
	// *   **Preparing**
	// *   **Waiting**
	// *   **Uploading**
	// *   **Finished**
	// *   **Failed**
	//
	// >  This parameter is returned only after a backup task is run.
	BackupStatus *string `json:"BackupStatus,omitempty" xml:"BackupStatus,omitempty"`
	// The backup mode. Valid values:
	//
	// *   **Automated**
	// *   **Manual**
	JobMode *string `json:"JobMode,omitempty" xml:"JobMode,omitempty"`
	// The progress of the task in percentage.
	Process *string `json:"Process,omitempty" xml:"Process,omitempty"`
	// The type of the task. Valid values:
	//
	// *   **TempBackupTask**: The backup task is an adhoc backup task.
	// *   **NormalBackupTask**: The backup task is a common backup task.
	TaskAction *string `json:"TaskAction,omitempty" xml:"TaskAction,omitempty"`
}

func (s DescribeBackupTasksResponseBodyItemsBackupJob) String() string {
	return tea.Prettify(s)
}

func (s DescribeBackupTasksResponseBodyItemsBackupJob) GoString() string {
	return s.String()
}

func (s *DescribeBackupTasksResponseBodyItemsBackupJob) SetBackupId(v string) *DescribeBackupTasksResponseBodyItemsBackupJob {
	s.BackupId = &v
	return s
}

func (s *DescribeBackupTasksResponseBodyItemsBackupJob) SetBackupJobId(v string) *DescribeBackupTasksResponseBodyItemsBackupJob {
	s.BackupJobId = &v
	return s
}

func (s *DescribeBackupTasksResponseBodyItemsBackupJob) SetBackupProgressStatus(v string) *DescribeBackupTasksResponseBodyItemsBackupJob {
	s.BackupProgressStatus = &v
	return s
}

func (s *DescribeBackupTasksResponseBodyItemsBackupJob) SetBackupStatus(v string) *DescribeBackupTasksResponseBodyItemsBackupJob {
	s.BackupStatus = &v
	return s
}

func (s *DescribeBackupTasksResponseBodyItemsBackupJob) SetJobMode(v string) *DescribeBackupTasksResponseBodyItemsBackupJob {
	s.JobMode = &v
	return s
}

func (s *DescribeBackupTasksResponseBodyItemsBackupJob) SetProcess(v string) *DescribeBackupTasksResponseBodyItemsBackupJob {
	s.Process = &v
	return s
}

func (s *DescribeBackupTasksResponseBodyItemsBackupJob) SetTaskAction(v string) *DescribeBackupTasksResponseBodyItemsBackupJob {
	s.TaskAction = &v
	return s
}

type DescribeBackupTasksResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeBackupTasksResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeBackupTasksResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeBackupTasksResponse) GoString() string {
	return s.String()
}

func (s *DescribeBackupTasksResponse) SetHeaders(v map[string]*string) *DescribeBackupTasksResponse {
	s.Headers = v
	return s
}

func (s *DescribeBackupTasksResponse) SetStatusCode(v int32) *DescribeBackupTasksResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeBackupTasksResponse) SetBody(v *DescribeBackupTasksResponseBody) *DescribeBackupTasksResponse {
	s.Body = v
	return s
}

type DescribeBackupsRequest struct {
	// The ID of the backup set.
	BackupId *string `json:"BackupId,omitempty" xml:"BackupId,omitempty"`
	// The backup mode. Valid values:
	//
	// *   **Automated**
	// *   **Manual**
	BackupMode *string `json:"BackupMode,omitempty" xml:"BackupMode,omitempty"`
	// The status of the backup set. Valid values:
	//
	// *   **Success**
	// *   **Failed**
	BackupStatus *string `json:"BackupStatus,omitempty" xml:"BackupStatus,omitempty"`
	// The backup type. Valid values:
	//
	// *   **FullBackup**: full backup
	// *   **IncrementalBackup**: incremental backup
	BackupType *string `json:"BackupType,omitempty" xml:"BackupType,omitempty"`
	// The instance ID. You can call the [DescribeDBInstances](~~610396~~) operation to query the ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The end of the time range to query. The end time must be later than the start time. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm*Z format. The time must be in UTC.
	//
	// > We recommend that you specify a time range that is as short as possible to avoid timeout.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The number of the page to return. Valid values: any non-zero positive integer.
	//
	// Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Valid values:
	//
	// *   **30**
	// *   **50**
	// *   **100**
	//
	// Default value: **30**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The resource group ID.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerId *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm*Z format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeBackupsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeBackupsRequest) GoString() string {
	return s.String()
}

func (s *DescribeBackupsRequest) SetBackupId(v string) *DescribeBackupsRequest {
	s.BackupId = &v
	return s
}

func (s *DescribeBackupsRequest) SetBackupMode(v string) *DescribeBackupsRequest {
	s.BackupMode = &v
	return s
}

func (s *DescribeBackupsRequest) SetBackupStatus(v string) *DescribeBackupsRequest {
	s.BackupStatus = &v
	return s
}

func (s *DescribeBackupsRequest) SetBackupType(v string) *DescribeBackupsRequest {
	s.BackupType = &v
	return s
}

func (s *DescribeBackupsRequest) SetDBInstanceId(v string) *DescribeBackupsRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeBackupsRequest) SetEndTime(v string) *DescribeBackupsRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeBackupsRequest) SetPageNumber(v int32) *DescribeBackupsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeBackupsRequest) SetPageSize(v int32) *DescribeBackupsRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeBackupsRequest) SetResourceGroupId(v string) *DescribeBackupsRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeBackupsRequest) SetResourceOwnerId(v int64) *DescribeBackupsRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeBackupsRequest) SetStartTime(v string) *DescribeBackupsRequest {
	s.StartTime = &v
	return s
}

type DescribeBackupsResponseBody struct {
	// The queried backup sets.
	Items *DescribeBackupsResponseBodyItems `json:"Items,omitempty" xml:"Items,omitempty" type:"Struct"`
	// The page number of the returned page.
	PageNumber *string `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of backup sets on the current page.
	PageRecordCount *string `json:"PageRecordCount,omitempty" xml:"PageRecordCount,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The size of the snapshot chain of the instance. Unit: bytes.
	TotalEcsSnapshotSize *int64 `json:"TotalEcsSnapshotSize,omitempty" xml:"TotalEcsSnapshotSize,omitempty"`
	// The total number of entries returned.
	TotalRecordCount *string `json:"TotalRecordCount,omitempty" xml:"TotalRecordCount,omitempty"`
}

func (s DescribeBackupsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeBackupsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeBackupsResponseBody) SetItems(v *DescribeBackupsResponseBodyItems) *DescribeBackupsResponseBody {
	s.Items = v
	return s
}

func (s *DescribeBackupsResponseBody) SetPageNumber(v string) *DescribeBackupsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeBackupsResponseBody) SetPageRecordCount(v string) *DescribeBackupsResponseBody {
	s.PageRecordCount = &v
	return s
}

func (s *DescribeBackupsResponseBody) SetRequestId(v string) *DescribeBackupsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeBackupsResponseBody) SetTotalEcsSnapshotSize(v int64) *DescribeBackupsResponseBody {
	s.TotalEcsSnapshotSize = &v
	return s
}

func (s *DescribeBackupsResponseBody) SetTotalRecordCount(v string) *DescribeBackupsResponseBody {
	s.TotalRecordCount = &v
	return s
}

type DescribeBackupsResponseBodyItems struct {
	Backup []*DescribeBackupsResponseBodyItemsBackup `json:"Backup,omitempty" xml:"Backup,omitempty" type:"Repeated"`
}

func (s DescribeBackupsResponseBodyItems) String() string {
	return tea.Prettify(s)
}

func (s DescribeBackupsResponseBodyItems) GoString() string {
	return s.String()
}

func (s *DescribeBackupsResponseBodyItems) SetBackup(v []*DescribeBackupsResponseBodyItemsBackup) *DescribeBackupsResponseBodyItems {
	s.Backup = v
	return s
}

type DescribeBackupsResponseBodyItemsBackup struct {
	// An array consisting of URLs from which you can download backup sets of individual databases.
	BackupDownloadLinkByDB *DescribeBackupsResponseBodyItemsBackupBackupDownloadLinkByDB `json:"BackupDownloadLinkByDB,omitempty" xml:"BackupDownloadLinkByDB,omitempty" type:"Struct"`
	// The URL that is used to download the backup set over the Internet. If the backup set cannot be downloaded, null is returned.
	//
	// >  For example, if BackupMethod of an ApsaraDB RDS for SQL Server instance is set to **Snapshot**, a null string is returned.
	BackupDownloadURL *string `json:"BackupDownloadURL,omitempty" xml:"BackupDownloadURL,omitempty"`
	// The end time of the backup task. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm*Z format. The time is displayed in UTC.
	BackupEndTime *string `json:"BackupEndTime,omitempty" xml:"BackupEndTime,omitempty"`
	// The ID of the backup set.
	BackupId *string `json:"BackupId,omitempty" xml:"BackupId,omitempty"`
	// The initiator of the backup task. Valid values:
	//
	// *   **System**
	// *   **User**
	BackupInitiator *string `json:"BackupInitiator,omitempty" xml:"BackupInitiator,omitempty"`
	// The URL that is used to download the backup set over an internal network. If the backup set cannot be downloaded, null is returned.
	//
	// >  For example, if BackupMethod of an ApsaraDB RDS for SQL Server instance is set to **Snapshot**, a null string is returned.
	BackupIntranetDownloadURL *string `json:"BackupIntranetDownloadURL,omitempty" xml:"BackupIntranetDownloadURL,omitempty"`
	// The method that is used to generate the backup set. Valid values:
	//
	// *   **Logical**: logical backup
	// *   **Physical**: physical backup
	// *   **Snapshot**: snapshot backup
	BackupMethod *string `json:"BackupMethod,omitempty" xml:"BackupMethod,omitempty"`
	// The backup mode of the backup set. Valid values:
	//
	// *   **Automated**
	// *   **Manual**
	BackupMode *string `json:"BackupMode,omitempty" xml:"BackupMode,omitempty"`
	// The size of the data backup file. Unit: bytes.
	BackupSize *int64 `json:"BackupSize,omitempty" xml:"BackupSize,omitempty"`
	// The start time of the backup. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm*Z format. The time is displayed in UTC.
	BackupStartTime *string `json:"BackupStartTime,omitempty" xml:"BackupStartTime,omitempty"`
	// The state of the backup set.
	BackupStatus *string `json:"BackupStatus,omitempty" xml:"BackupStatus,omitempty"`
	// The backup type of the backup set. Valid values:
	//
	// *   **FullBackup**
	// *   **IncrementalBackup**
	BackupType *string `json:"BackupType,omitempty" xml:"BackupType,omitempty"`
	// The checksum. The value of this parameter is calculated by using the CRC64 algorithm.
	Checksum *string `json:"Checksum,omitempty" xml:"Checksum,omitempty"`
	// The point in time at which the data in the backup set is consistent. The return value of this parameter is a timestamp.
	//
	// >  If the instance runs MySQL 5.6, a timestamp is returned. Otherwise, the value 0 is returned.
	ConsistentTime *int64 `json:"ConsistentTime,omitempty" xml:"ConsistentTime,omitempty"`
	// The backup mode of the backup set. Valid values:
	//
	// *   0: the standard mode. This mode supports full backups and incremental backups.
	// *   1: the copy-only mode. This mode supports only full backups.
	//
	// >  This parameter is returned only when the instance runs SQL Server.
	CopyOnlyBackup *string `json:"CopyOnlyBackup,omitempty" xml:"CopyOnlyBackup,omitempty"`
	// The instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The encryption information about the backup set.
	Encryption *string `json:"Encryption,omitempty" xml:"Encryption,omitempty"`
	// The ID of the instance that generates the backup set. This parameter is used to indicate whether the instance that generates the backup set is a primary instance or a secondary instance.
	HostInstanceID *string `json:"HostInstanceID,omitempty" xml:"HostInstanceID,omitempty"`
	// Indicates whether the backup set is available. Valid values:
	//
	// *   **0**: The backup set is unavailable.
	// *   **1**: The backup set is available.
	IsAvail *int32 `json:"IsAvail,omitempty" xml:"IsAvail,omitempty"`
	// The status of the backup set that is used to restore individual databases or tables. Valid values:
	//
	// *   **OK**: The data backup file is normal.
	// *   **LARGE**: The data backup file contains an abnormally large number of tables. It cannot be used to restore individual databases or tables.
	// *   **EMPTY**: The data backup file is generated from a failed backup task.
	//
	// >  If an empty string is returned, the data backup file cannot be used to restore individual databases or tables.
	MetaStatus *string `json:"MetaStatus,omitempty" xml:"MetaStatus,omitempty"`
	// The resource group ID.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The storage class of the backup set. Valid values:
	//
	// *   **0**: regular storage
	// *   **1**: archive storage
	StorageClass *string `json:"StorageClass,omitempty" xml:"StorageClass,omitempty"`
	// Indicates whether the backup set can be deleted. Valid values:
	//
	// *   **Enabled**: The backup set can be deleted.
	// *   **Disabled**: The backup set cannot be deleted.
	StoreStatus *string `json:"StoreStatus,omitempty" xml:"StoreStatus,omitempty"`
}

func (s DescribeBackupsResponseBodyItemsBackup) String() string {
	return tea.Prettify(s)
}

func (s DescribeBackupsResponseBodyItemsBackup) GoString() string {
	return s.String()
}

func (s *DescribeBackupsResponseBodyItemsBackup) SetBackupDownloadLinkByDB(v *DescribeBackupsResponseBodyItemsBackupBackupDownloadLinkByDB) *DescribeBackupsResponseBodyItemsBackup {
	s.BackupDownloadLinkByDB = v
	return s
}

func (s *DescribeBackupsResponseBodyItemsBackup) SetBackupDownloadURL(v string) *DescribeBackupsResponseBodyItemsBackup {
	s.BackupDownloadURL = &v
	return s
}

func (s *DescribeBackupsResponseBodyItemsBackup) SetBackupEndTime(v string) *DescribeBackupsResponseBodyItemsBackup {
	s.BackupEndTime = &v
	return s
}

func (s *DescribeBackupsResponseBodyItemsBackup) SetBackupId(v string) *DescribeBackupsResponseBodyItemsBackup {
	s.BackupId = &v
	return s
}

func (s *DescribeBackupsResponseBodyItemsBackup) SetBackupInitiator(v string) *DescribeBackupsResponseBodyItemsBackup {
	s.BackupInitiator = &v
	return s
}

func (s *DescribeBackupsResponseBodyItemsBackup) SetBackupIntranetDownloadURL(v string) *DescribeBackupsResponseBodyItemsBackup {
	s.BackupIntranetDownloadURL = &v
	return s
}

func (s *DescribeBackupsResponseBodyItemsBackup) SetBackupMethod(v string) *DescribeBackupsResponseBodyItemsBackup {
	s.BackupMethod = &v
	return s
}

func (s *DescribeBackupsResponseBodyItemsBackup) SetBackupMode(v string) *DescribeBackupsResponseBodyItemsBackup {
	s.BackupMode = &v
	return s
}

func (s *DescribeBackupsResponseBodyItemsBackup) SetBackupSize(v int64) *DescribeBackupsResponseBodyItemsBackup {
	s.BackupSize = &v
	return s
}

func (s *DescribeBackupsResponseBodyItemsBackup) SetBackupStartTime(v string) *DescribeBackupsResponseBodyItemsBackup {
	s.BackupStartTime = &v
	return s
}

func (s *DescribeBackupsResponseBodyItemsBackup) SetBackupStatus(v string) *DescribeBackupsResponseBodyItemsBackup {
	s.BackupStatus = &v
	return s
}

func (s *DescribeBackupsResponseBodyItemsBackup) SetBackupType(v string) *DescribeBackupsResponseBodyItemsBackup {
	s.BackupType = &v
	return s
}

func (s *DescribeBackupsResponseBodyItemsBackup) SetChecksum(v string) *DescribeBackupsResponseBodyItemsBackup {
	s.Checksum = &v
	return s
}

func (s *DescribeBackupsResponseBodyItemsBackup) SetConsistentTime(v int64) *DescribeBackupsResponseBodyItemsBackup {
	s.ConsistentTime = &v
	return s
}

func (s *DescribeBackupsResponseBodyItemsBackup) SetCopyOnlyBackup(v string) *DescribeBackupsResponseBodyItemsBackup {
	s.CopyOnlyBackup = &v
	return s
}

func (s *DescribeBackupsResponseBodyItemsBackup) SetDBInstanceId(v string) *DescribeBackupsResponseBodyItemsBackup {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeBackupsResponseBodyItemsBackup) SetEncryption(v string) *DescribeBackupsResponseBodyItemsBackup {
	s.Encryption = &v
	return s
}

func (s *DescribeBackupsResponseBodyItemsBackup) SetHostInstanceID(v string) *DescribeBackupsResponseBodyItemsBackup {
	s.HostInstanceID = &v
	return s
}

func (s *DescribeBackupsResponseBodyItemsBackup) SetIsAvail(v int32) *DescribeBackupsResponseBodyItemsBackup {
	s.IsAvail = &v
	return s
}

func (s *DescribeBackupsResponseBodyItemsBackup) SetMetaStatus(v string) *DescribeBackupsResponseBodyItemsBackup {
	s.MetaStatus = &v
	return s
}

func (s *DescribeBackupsResponseBodyItemsBackup) SetResourceGroupId(v string) *DescribeBackupsResponseBodyItemsBackup {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeBackupsResponseBodyItemsBackup) SetStorageClass(v string) *DescribeBackupsResponseBodyItemsBackup {
	s.StorageClass = &v
	return s
}

func (s *DescribeBackupsResponseBodyItemsBackup) SetStoreStatus(v string) *DescribeBackupsResponseBodyItemsBackup {
	s.StoreStatus = &v
	return s
}

type DescribeBackupsResponseBodyItemsBackupBackupDownloadLinkByDB struct {
	BackupDownloadLinkByDB []*DescribeBackupsResponseBodyItemsBackupBackupDownloadLinkByDBBackupDownloadLinkByDB `json:"BackupDownloadLinkByDB,omitempty" xml:"BackupDownloadLinkByDB,omitempty" type:"Repeated"`
}

func (s DescribeBackupsResponseBodyItemsBackupBackupDownloadLinkByDB) String() string {
	return tea.Prettify(s)
}

func (s DescribeBackupsResponseBodyItemsBackupBackupDownloadLinkByDB) GoString() string {
	return s.String()
}

func (s *DescribeBackupsResponseBodyItemsBackupBackupDownloadLinkByDB) SetBackupDownloadLinkByDB(v []*DescribeBackupsResponseBodyItemsBackupBackupDownloadLinkByDBBackupDownloadLinkByDB) *DescribeBackupsResponseBodyItemsBackupBackupDownloadLinkByDB {
	s.BackupDownloadLinkByDB = v
	return s
}

type DescribeBackupsResponseBodyItemsBackupBackupDownloadLinkByDBBackupDownloadLinkByDB struct {
	// The name of the database.
	DataBase *string `json:"DataBase,omitempty" xml:"DataBase,omitempty"`
	// The public URL from which you can download the backup set.
	DownloadLink *string `json:"DownloadLink,omitempty" xml:"DownloadLink,omitempty"`
	// The internal URL from which you can download the backup set.
	IntranetDownloadLink *string `json:"IntranetDownloadLink,omitempty" xml:"IntranetDownloadLink,omitempty"`
}

func (s DescribeBackupsResponseBodyItemsBackupBackupDownloadLinkByDBBackupDownloadLinkByDB) String() string {
	return tea.Prettify(s)
}

func (s DescribeBackupsResponseBodyItemsBackupBackupDownloadLinkByDBBackupDownloadLinkByDB) GoString() string {
	return s.String()
}

func (s *DescribeBackupsResponseBodyItemsBackupBackupDownloadLinkByDBBackupDownloadLinkByDB) SetDataBase(v string) *DescribeBackupsResponseBodyItemsBackupBackupDownloadLinkByDBBackupDownloadLinkByDB {
	s.DataBase = &v
	return s
}

func (s *DescribeBackupsResponseBodyItemsBackupBackupDownloadLinkByDBBackupDownloadLinkByDB) SetDownloadLink(v string) *DescribeBackupsResponseBodyItemsBackupBackupDownloadLinkByDBBackupDownloadLinkByDB {
	s.DownloadLink = &v
	return s
}

func (s *DescribeBackupsResponseBodyItemsBackupBackupDownloadLinkByDBBackupDownloadLinkByDB) SetIntranetDownloadLink(v string) *DescribeBackupsResponseBodyItemsBackupBackupDownloadLinkByDBBackupDownloadLinkByDB {
	s.IntranetDownloadLink = &v
	return s
}

type DescribeBackupsResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeBackupsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeBackupsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeBackupsResponse) GoString() string {
	return s.String()
}

func (s *DescribeBackupsResponse) SetHeaders(v map[string]*string) *DescribeBackupsResponse {
	s.Headers = v
	return s
}

func (s *DescribeBackupsResponse) SetStatusCode(v int32) *DescribeBackupsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeBackupsResponse) SetBody(v *DescribeBackupsResponseBody) *DescribeBackupsResponse {
	s.Body = v
	return s
}

type DescribeBinlogFilesRequest struct {
	// The instance ID. You can call the [DescribeDBInstances](~~610396~~) operation to query the ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The end of the time range to query. The end time must be later than the start time.
	//
	// Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
	EndTime      *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The page number. Valid values: any non-zero positive integer.
	//
	// Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page.
	//
	// Valid values: **30** to **100**.
	//
	// Default value: **30**.
	PageSize             *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The beginning of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeBinlogFilesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeBinlogFilesRequest) GoString() string {
	return s.String()
}

func (s *DescribeBinlogFilesRequest) SetDBInstanceId(v string) *DescribeBinlogFilesRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeBinlogFilesRequest) SetEndTime(v string) *DescribeBinlogFilesRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeBinlogFilesRequest) SetOwnerAccount(v string) *DescribeBinlogFilesRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeBinlogFilesRequest) SetOwnerId(v int64) *DescribeBinlogFilesRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeBinlogFilesRequest) SetPageNumber(v int32) *DescribeBinlogFilesRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeBinlogFilesRequest) SetPageSize(v int32) *DescribeBinlogFilesRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeBinlogFilesRequest) SetResourceOwnerAccount(v string) *DescribeBinlogFilesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeBinlogFilesRequest) SetResourceOwnerId(v int64) *DescribeBinlogFilesRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeBinlogFilesRequest) SetStartTime(v string) *DescribeBinlogFilesRequest {
	s.StartTime = &v
	return s
}

type DescribeBinlogFilesResponseBody struct {
	// The details of the log file.
	Items *DescribeBinlogFilesResponseBodyItems `json:"Items,omitempty" xml:"Items,omitempty" type:"Struct"`
	// The page number.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of log files on the current page.
	PageRecordCount *int32 `json:"PageRecordCount,omitempty" xml:"PageRecordCount,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total size of the log file.
	TotalFileSize *int64 `json:"TotalFileSize,omitempty" xml:"TotalFileSize,omitempty"`
	// The total number of log files.
	TotalRecordCount *int32 `json:"TotalRecordCount,omitempty" xml:"TotalRecordCount,omitempty"`
}

func (s DescribeBinlogFilesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeBinlogFilesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeBinlogFilesResponseBody) SetItems(v *DescribeBinlogFilesResponseBodyItems) *DescribeBinlogFilesResponseBody {
	s.Items = v
	return s
}

func (s *DescribeBinlogFilesResponseBody) SetPageNumber(v int32) *DescribeBinlogFilesResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeBinlogFilesResponseBody) SetPageRecordCount(v int32) *DescribeBinlogFilesResponseBody {
	s.PageRecordCount = &v
	return s
}

func (s *DescribeBinlogFilesResponseBody) SetRequestId(v string) *DescribeBinlogFilesResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeBinlogFilesResponseBody) SetTotalFileSize(v int64) *DescribeBinlogFilesResponseBody {
	s.TotalFileSize = &v
	return s
}

func (s *DescribeBinlogFilesResponseBody) SetTotalRecordCount(v int32) *DescribeBinlogFilesResponseBody {
	s.TotalRecordCount = &v
	return s
}

type DescribeBinlogFilesResponseBodyItems struct {
	BinLogFile []*DescribeBinlogFilesResponseBodyItemsBinLogFile `json:"BinLogFile,omitempty" xml:"BinLogFile,omitempty" type:"Repeated"`
}

func (s DescribeBinlogFilesResponseBodyItems) String() string {
	return tea.Prettify(s)
}

func (s DescribeBinlogFilesResponseBodyItems) GoString() string {
	return s.String()
}

func (s *DescribeBinlogFilesResponseBodyItems) SetBinLogFile(v []*DescribeBinlogFilesResponseBodyItemsBinLogFile) *DescribeBinlogFilesResponseBodyItems {
	s.BinLogFile = v
	return s
}

type DescribeBinlogFilesResponseBodyItemsBinLogFile struct {
	// The checksum. The value of this parameter is calculated by using the CRC64 algorithm.
	Checksum *string `json:"Checksum,omitempty" xml:"Checksum,omitempty"`
	// The HTTP-based download URL of the log file. If the return value of this parameter is NULL, ApsaraDB RDS does not provide a download URL for the log file.
	DownloadLink *string `json:"DownloadLink,omitempty" xml:"DownloadLink,omitempty"`
	// The size of the log file.
	//
	// Unit: bytes.
	FileSize *int64 `json:"FileSize,omitempty" xml:"FileSize,omitempty"`
	// The ID of the instance to which the log file belongs. This parameter helps determine whether the log file is generated on the primary instance or the secondary instance.
	//
	// > You can log on to the ApsaraDB RDS console and go to the instance details page. In the left-side navigation pane, click **Service Availability** to view the values of **Primary Instance No.** and **Secondary Instance No.**.
	HostInstanceID *string `json:"HostInstanceID,omitempty" xml:"HostInstanceID,omitempty"`
	// The URL that is used to download files over an internal network.
	IntranetDownloadLink *string `json:"IntranetDownloadLink,omitempty" xml:"IntranetDownloadLink,omitempty"`
	// The expiration time of the URL.
	//
	// The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	LinkExpiredTime *string `json:"LinkExpiredTime,omitempty" xml:"LinkExpiredTime,omitempty"`
	// The start time of the log file.
	//
	// The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	LogBeginTime *string `json:"LogBeginTime,omitempty" xml:"LogBeginTime,omitempty"`
	// The end time of the log file.
	//
	// The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	LogEndTime *string `json:"LogEndTime,omitempty" xml:"LogEndTime,omitempty"`
	// The log file name.
	LogFileName *string `json:"LogFileName,omitempty" xml:"LogFileName,omitempty"`
	// The status of the log file that is stored in the Object Storage Service (OSS) bucket.
	//
	// Valid values:
	//
	// *   **Uploading**
	// *   **Completed**
	RemoteStatus *string `json:"RemoteStatus,omitempty" xml:"RemoteStatus,omitempty"`
}

func (s DescribeBinlogFilesResponseBodyItemsBinLogFile) String() string {
	return tea.Prettify(s)
}

func (s DescribeBinlogFilesResponseBodyItemsBinLogFile) GoString() string {
	return s.String()
}

func (s *DescribeBinlogFilesResponseBodyItemsBinLogFile) SetChecksum(v string) *DescribeBinlogFilesResponseBodyItemsBinLogFile {
	s.Checksum = &v
	return s
}

func (s *DescribeBinlogFilesResponseBodyItemsBinLogFile) SetDownloadLink(v string) *DescribeBinlogFilesResponseBodyItemsBinLogFile {
	s.DownloadLink = &v
	return s
}

func (s *DescribeBinlogFilesResponseBodyItemsBinLogFile) SetFileSize(v int64) *DescribeBinlogFilesResponseBodyItemsBinLogFile {
	s.FileSize = &v
	return s
}

func (s *DescribeBinlogFilesResponseBodyItemsBinLogFile) SetHostInstanceID(v string) *DescribeBinlogFilesResponseBodyItemsBinLogFile {
	s.HostInstanceID = &v
	return s
}

func (s *DescribeBinlogFilesResponseBodyItemsBinLogFile) SetIntranetDownloadLink(v string) *DescribeBinlogFilesResponseBodyItemsBinLogFile {
	s.IntranetDownloadLink = &v
	return s
}

func (s *DescribeBinlogFilesResponseBodyItemsBinLogFile) SetLinkExpiredTime(v string) *DescribeBinlogFilesResponseBodyItemsBinLogFile {
	s.LinkExpiredTime = &v
	return s
}

func (s *DescribeBinlogFilesResponseBodyItemsBinLogFile) SetLogBeginTime(v string) *DescribeBinlogFilesResponseBodyItemsBinLogFile {
	s.LogBeginTime = &v
	return s
}

func (s *DescribeBinlogFilesResponseBodyItemsBinLogFile) SetLogEndTime(v string) *DescribeBinlogFilesResponseBodyItemsBinLogFile {
	s.LogEndTime = &v
	return s
}

func (s *DescribeBinlogFilesResponseBodyItemsBinLogFile) SetLogFileName(v string) *DescribeBinlogFilesResponseBodyItemsBinLogFile {
	s.LogFileName = &v
	return s
}

func (s *DescribeBinlogFilesResponseBodyItemsBinLogFile) SetRemoteStatus(v string) *DescribeBinlogFilesResponseBodyItemsBinLogFile {
	s.RemoteStatus = &v
	return s
}

type DescribeBinlogFilesResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeBinlogFilesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeBinlogFilesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeBinlogFilesResponse) GoString() string {
	return s.String()
}

func (s *DescribeBinlogFilesResponse) SetHeaders(v map[string]*string) *DescribeBinlogFilesResponse {
	s.Headers = v
	return s
}

func (s *DescribeBinlogFilesResponse) SetStatusCode(v int32) *DescribeBinlogFilesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeBinlogFilesResponse) SetBody(v *DescribeBinlogFilesResponseBody) *DescribeBinlogFilesResponse {
	s.Body = v
	return s
}

type DescribeCharacterSetNameRequest struct {
	// The type of the database engine. Valid values:
	//
	// *   **mysql**
	// *   **mssql**
	// *   **PostgreSQL**
	// *   **MariaDB**
	Engine       *string `json:"Engine,omitempty" xml:"Engine,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID. You can call the DescribeRegions operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The resource group ID. You can call the DescribeDBInstanceAttribute operation to query the resource group ID.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeCharacterSetNameRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeCharacterSetNameRequest) GoString() string {
	return s.String()
}

func (s *DescribeCharacterSetNameRequest) SetEngine(v string) *DescribeCharacterSetNameRequest {
	s.Engine = &v
	return s
}

func (s *DescribeCharacterSetNameRequest) SetOwnerAccount(v string) *DescribeCharacterSetNameRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeCharacterSetNameRequest) SetOwnerId(v int64) *DescribeCharacterSetNameRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeCharacterSetNameRequest) SetRegionId(v string) *DescribeCharacterSetNameRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeCharacterSetNameRequest) SetResourceGroupId(v string) *DescribeCharacterSetNameRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeCharacterSetNameRequest) SetResourceOwnerAccount(v string) *DescribeCharacterSetNameRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeCharacterSetNameRequest) SetResourceOwnerId(v int64) *DescribeCharacterSetNameRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeCharacterSetNameResponseBody struct {
	// The character sets that are supported.
	CharacterSetNameItems *DescribeCharacterSetNameResponseBodyCharacterSetNameItems `json:"CharacterSetNameItems,omitempty" xml:"CharacterSetNameItems,omitempty" type:"Struct"`
	// The type of the database engine.
	Engine *string `json:"Engine,omitempty" xml:"Engine,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeCharacterSetNameResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeCharacterSetNameResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeCharacterSetNameResponseBody) SetCharacterSetNameItems(v *DescribeCharacterSetNameResponseBodyCharacterSetNameItems) *DescribeCharacterSetNameResponseBody {
	s.CharacterSetNameItems = v
	return s
}

func (s *DescribeCharacterSetNameResponseBody) SetEngine(v string) *DescribeCharacterSetNameResponseBody {
	s.Engine = &v
	return s
}

func (s *DescribeCharacterSetNameResponseBody) SetRequestId(v string) *DescribeCharacterSetNameResponseBody {
	s.RequestId = &v
	return s
}

type DescribeCharacterSetNameResponseBodyCharacterSetNameItems struct {
	CharacterSetName []*string `json:"CharacterSetName,omitempty" xml:"CharacterSetName,omitempty" type:"Repeated"`
}

func (s DescribeCharacterSetNameResponseBodyCharacterSetNameItems) String() string {
	return tea.Prettify(s)
}

func (s DescribeCharacterSetNameResponseBodyCharacterSetNameItems) GoString() string {
	return s.String()
}

func (s *DescribeCharacterSetNameResponseBodyCharacterSetNameItems) SetCharacterSetName(v []*string) *DescribeCharacterSetNameResponseBodyCharacterSetNameItems {
	s.CharacterSetName = v
	return s
}

type DescribeCharacterSetNameResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeCharacterSetNameResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeCharacterSetNameResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeCharacterSetNameResponse) GoString() string {
	return s.String()
}

func (s *DescribeCharacterSetNameResponse) SetHeaders(v map[string]*string) *DescribeCharacterSetNameResponse {
	s.Headers = v
	return s
}

func (s *DescribeCharacterSetNameResponse) SetStatusCode(v int32) *DescribeCharacterSetNameResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeCharacterSetNameResponse) SetBody(v *DescribeCharacterSetNameResponseBody) *DescribeCharacterSetNameResponse {
	s.Body = v
	return s
}

type DescribeClassDetailsRequest struct {
	// The code of the instance type.
	ClassCode *string `json:"ClassCode,omitempty" xml:"ClassCode,omitempty"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The commodity code of the instance. Valid values:
	//
	// *   **bards_intl**: The instance is a pay-as-you-go primary instance.
	// *   **rds_intl**: The instance is a subscription primary instance.
	// *   **rords_intl**: The instance is a pay-as-you-go read-only instance.
	// *   **rds_rordspre_public_intl**: The instance is a subscription read-only instance.
	CommodityCode *string `json:"CommodityCode,omitempty" xml:"CommodityCode,omitempty"`
	// The type of the database engine.
	Engine *string `json:"Engine,omitempty" xml:"Engine,omitempty"`
	// The database engine version of the instance.
	EngineVersion *string `json:"EngineVersion,omitempty" xml:"EngineVersion,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region. You can call the [DescribeRegions](~~26243~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The resource group ID. You can call the [DescribeDBInstanceAttribute](~~610394~~) operation to obtain the resource group ID.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeClassDetailsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeClassDetailsRequest) GoString() string {
	return s.String()
}

func (s *DescribeClassDetailsRequest) SetClassCode(v string) *DescribeClassDetailsRequest {
	s.ClassCode = &v
	return s
}

func (s *DescribeClassDetailsRequest) SetClientToken(v string) *DescribeClassDetailsRequest {
	s.ClientToken = &v
	return s
}

func (s *DescribeClassDetailsRequest) SetCommodityCode(v string) *DescribeClassDetailsRequest {
	s.CommodityCode = &v
	return s
}

func (s *DescribeClassDetailsRequest) SetEngine(v string) *DescribeClassDetailsRequest {
	s.Engine = &v
	return s
}

func (s *DescribeClassDetailsRequest) SetEngineVersion(v string) *DescribeClassDetailsRequest {
	s.EngineVersion = &v
	return s
}

func (s *DescribeClassDetailsRequest) SetOwnerId(v int64) *DescribeClassDetailsRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeClassDetailsRequest) SetRegionId(v string) *DescribeClassDetailsRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeClassDetailsRequest) SetResourceGroupId(v string) *DescribeClassDetailsRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeClassDetailsRequest) SetResourceOwnerAccount(v string) *DescribeClassDetailsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeClassDetailsRequest) SetResourceOwnerId(v int64) *DescribeClassDetailsRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeClassDetailsResponseBody struct {
	// The RDS edition of the instance. Valid values:
	//
	// *   **Basic**: RDS Basic Edition
	// *   **HighAvailability**: RDS High-availability Edition
	// *   **AlwaysOn**: RDS Cluster Edition
	// *   **Finance**: RDS Enterprise Edition
	Category *string `json:"Category,omitempty" xml:"Category,omitempty"`
	// The code of the instance type.
	ClassCode *string `json:"ClassCode,omitempty" xml:"ClassCode,omitempty"`
	// The instance family of the instance.
	ClassGroup *string `json:"ClassGroup,omitempty" xml:"ClassGroup,omitempty"`
	// The number of CPU cores that are supported by the instance type. Unit: cores.
	Cpu *string `json:"Cpu,omitempty" xml:"Cpu,omitempty"`
	// The storage type of the instance. Valid values:
	//
	// *   **local_ssd**: local SSDs
	// *   **cloud_ssd**: standard SSDs
	// *   **cloud_essd**: enhanced SSDs (ESSDs) of performance level 1 (PL1)
	// *   **cloud_essd2**: ESSDs of PL2
	// *   **cloud_essd3**: ESSD of PL3
	DBInstanceStorageType *string `json:"DBInstanceStorageType,omitempty" xml:"DBInstanceStorageType,omitempty"`
	// The architecture of the instance.
	InstructionSetArch *string `json:"InstructionSetArch,omitempty" xml:"InstructionSetArch,omitempty"`
	// The maximum number of connections.
	MaxConnections *string `json:"MaxConnections,omitempty" xml:"MaxConnections,omitempty"`
	// The maximum I/O bandwidth that is supported by the instance type. Unit: Mbit/s.
	MaxIOMBPS *string `json:"MaxIOMBPS,omitempty" xml:"MaxIOMBPS,omitempty"`
	// The maximum input/output operations per second (IOPS) that is supported by the instance type. Unit: operations per second.
	MaxIOPS *string `json:"MaxIOPS,omitempty" xml:"MaxIOPS,omitempty"`
	// The memory size. Unit: GB.
	MemoryClass *string `json:"MemoryClass,omitempty" xml:"MemoryClass,omitempty"`
	// The price.
	//
	// Unit: cents (US dollars).
	//
	// >
	//
	// *   If you set the CommodityCode parameter to a value that indicates the pay-as-you-go billing method, the ReferencePrice parameter specifies the hourly fee that you must pay.
	//
	// *   If you set the CommodityCode parameter to a value that indicates the subscription billing method, the ReferencePrice parameter specifies the monthly fee that you must pay.
	ReferencePrice *string `json:"ReferencePrice,omitempty" xml:"ReferencePrice,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeClassDetailsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeClassDetailsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeClassDetailsResponseBody) SetCategory(v string) *DescribeClassDetailsResponseBody {
	s.Category = &v
	return s
}

func (s *DescribeClassDetailsResponseBody) SetClassCode(v string) *DescribeClassDetailsResponseBody {
	s.ClassCode = &v
	return s
}

func (s *DescribeClassDetailsResponseBody) SetClassGroup(v string) *DescribeClassDetailsResponseBody {
	s.ClassGroup = &v
	return s
}

func (s *DescribeClassDetailsResponseBody) SetCpu(v string) *DescribeClassDetailsResponseBody {
	s.Cpu = &v
	return s
}

func (s *DescribeClassDetailsResponseBody) SetDBInstanceStorageType(v string) *DescribeClassDetailsResponseBody {
	s.DBInstanceStorageType = &v
	return s
}

func (s *DescribeClassDetailsResponseBody) SetInstructionSetArch(v string) *DescribeClassDetailsResponseBody {
	s.InstructionSetArch = &v
	return s
}

func (s *DescribeClassDetailsResponseBody) SetMaxConnections(v string) *DescribeClassDetailsResponseBody {
	s.MaxConnections = &v
	return s
}

func (s *DescribeClassDetailsResponseBody) SetMaxIOMBPS(v string) *DescribeClassDetailsResponseBody {
	s.MaxIOMBPS = &v
	return s
}

func (s *DescribeClassDetailsResponseBody) SetMaxIOPS(v string) *DescribeClassDetailsResponseBody {
	s.MaxIOPS = &v
	return s
}

func (s *DescribeClassDetailsResponseBody) SetMemoryClass(v string) *DescribeClassDetailsResponseBody {
	s.MemoryClass = &v
	return s
}

func (s *DescribeClassDetailsResponseBody) SetReferencePrice(v string) *DescribeClassDetailsResponseBody {
	s.ReferencePrice = &v
	return s
}

func (s *DescribeClassDetailsResponseBody) SetRequestId(v string) *DescribeClassDetailsResponseBody {
	s.RequestId = &v
	return s
}

type DescribeClassDetailsResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeClassDetailsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeClassDetailsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeClassDetailsResponse) GoString() string {
	return s.String()
}

func (s *DescribeClassDetailsResponse) SetHeaders(v map[string]*string) *DescribeClassDetailsResponse {
	s.Headers = v
	return s
}

func (s *DescribeClassDetailsResponse) SetStatusCode(v int32) *DescribeClassDetailsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeClassDetailsResponse) SetBody(v *DescribeClassDetailsResponseBody) *DescribeClassDetailsResponse {
	s.Body = v
	return s
}

type DescribeCloudMigrationPrecheckResultRequest struct {
	// The ID of the destination instance. You can call the [DescribeDBInstances](~~26232~~) operation to query the IDs of instances.
	DBInstanceName *string `json:"DBInstanceName,omitempty" xml:"DBInstanceName,omitempty"`
	// The page number. Pages start from page 1. Default value: **1**.
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries per page. Valid values: **30** to **100**. Default value: 30.
	PageSize        *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	ResourceOwnerId *int64 `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The private or public IP address that is used to connect to the self-managed PostgreSQL instance.
	//
	// *   If the self-managed PostgreSQL instance resides on an Elastic Compute Service (ECS) instance, enter the private IP address of the ECS instance. For more information about how to obtain the private IP address of an ECS instance, see [View IP addresses](~~273914~~).
	// *   If the self-managed PostgreSQL instance resides in an on-premises data center, enter the private IP address of the on-premises data center.
	SourceIpAddress *string `json:"SourceIpAddress,omitempty" xml:"SourceIpAddress,omitempty"`
	// The port number that is used to connect to the self-managed PostgreSQL instance. You can run the netstat -a | grep PGSQL command to obtain the port number.
	SourcePort *int64 `json:"SourcePort,omitempty" xml:"SourcePort,omitempty"`
	// The ID of the task. You can obtain the ID of the task from the response that is returned after you call the [CreateCloudMigrationPrecheckTask](~~409831~~) operation to create the task.
	TaskId *int64 `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
	// The name of the task. You can obtain the name of the task from the response that is returned after you call the [CreateCloudMigrationPrecheckTask](~~409831~~) operation to create the task.
	TaskName *string `json:"TaskName,omitempty" xml:"TaskName,omitempty"`
}

func (s DescribeCloudMigrationPrecheckResultRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeCloudMigrationPrecheckResultRequest) GoString() string {
	return s.String()
}

func (s *DescribeCloudMigrationPrecheckResultRequest) SetDBInstanceName(v string) *DescribeCloudMigrationPrecheckResultRequest {
	s.DBInstanceName = &v
	return s
}

func (s *DescribeCloudMigrationPrecheckResultRequest) SetPageNumber(v int64) *DescribeCloudMigrationPrecheckResultRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeCloudMigrationPrecheckResultRequest) SetPageSize(v int64) *DescribeCloudMigrationPrecheckResultRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeCloudMigrationPrecheckResultRequest) SetResourceOwnerId(v int64) *DescribeCloudMigrationPrecheckResultRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeCloudMigrationPrecheckResultRequest) SetSourceIpAddress(v string) *DescribeCloudMigrationPrecheckResultRequest {
	s.SourceIpAddress = &v
	return s
}

func (s *DescribeCloudMigrationPrecheckResultRequest) SetSourcePort(v int64) *DescribeCloudMigrationPrecheckResultRequest {
	s.SourcePort = &v
	return s
}

func (s *DescribeCloudMigrationPrecheckResultRequest) SetTaskId(v int64) *DescribeCloudMigrationPrecheckResultRequest {
	s.TaskId = &v
	return s
}

func (s *DescribeCloudMigrationPrecheckResultRequest) SetTaskName(v string) *DescribeCloudMigrationPrecheckResultRequest {
	s.TaskName = &v
	return s
}

type DescribeCloudMigrationPrecheckResultResponseBody struct {
	// The details about the assessment report.
	Items []*DescribeCloudMigrationPrecheckResultResponseBodyItems `json:"Items,omitempty" xml:"Items,omitempty" type:"Repeated"`
	// The page number.
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalSize *int32 `json:"TotalSize,omitempty" xml:"TotalSize,omitempty"`
}

func (s DescribeCloudMigrationPrecheckResultResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeCloudMigrationPrecheckResultResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeCloudMigrationPrecheckResultResponseBody) SetItems(v []*DescribeCloudMigrationPrecheckResultResponseBodyItems) *DescribeCloudMigrationPrecheckResultResponseBody {
	s.Items = v
	return s
}

func (s *DescribeCloudMigrationPrecheckResultResponseBody) SetPageNumber(v int64) *DescribeCloudMigrationPrecheckResultResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeCloudMigrationPrecheckResultResponseBody) SetPageSize(v int64) *DescribeCloudMigrationPrecheckResultResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeCloudMigrationPrecheckResultResponseBody) SetRequestId(v string) *DescribeCloudMigrationPrecheckResultResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeCloudMigrationPrecheckResultResponseBody) SetTotalSize(v int32) *DescribeCloudMigrationPrecheckResultResponseBody {
	s.TotalSize = &v
	return s
}

type DescribeCloudMigrationPrecheckResultResponseBodyItems struct {
	// The content of the assessment report.
	Detail *string `json:"Detail,omitempty" xml:"Detail,omitempty"`
	// The time when the task was created.
	GmtCreated *string `json:"GmtCreated,omitempty" xml:"GmtCreated,omitempty"`
	// The time when the task was modified.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The username.
	SourceAccount *string `json:"SourceAccount,omitempty" xml:"SourceAccount,omitempty"`
	// The environment in which the self-managed PostgreSQL instance runs.
	//
	// *   **idcOnVpc**: The self-managed PostgreSQL instance resides in a data center. The data center can communicate with the VPC to which the ApsaraDB RDS for PostgreSQL instance belongs.
	// *   **ecsOnVpc**: The self-managed PostgreSQL instance resides on an ECS instance.
	SourceCategory *string `json:"SourceCategory,omitempty" xml:"SourceCategory,omitempty"`
	// The private IP address that is used to connect to the self-managed PostgreSQL instance.
	SourceIpAddress *string `json:"SourceIpAddress,omitempty" xml:"SourceIpAddress,omitempty"`
	// The password.
	SourcePassword *string `json:"SourcePassword,omitempty" xml:"SourcePassword,omitempty"`
	// The port number that is used to connect to the self-managed PostgreSQL instance.
	SourcePort *int64 `json:"SourcePort,omitempty" xml:"SourcePort,omitempty"`
	// A reserved parameter. The return value of this parameter is empty.
	TargetEip *string `json:"TargetEip,omitempty" xml:"TargetEip,omitempty"`
	// The instance ID.
	TargetInstanceName *string `json:"TargetInstanceName,omitempty" xml:"TargetInstanceName,omitempty"`
	// The task ID.
	TaskId *int64 `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
	// The task name.
	TaskName *string `json:"TaskName,omitempty" xml:"TaskName,omitempty"`
}

func (s DescribeCloudMigrationPrecheckResultResponseBodyItems) String() string {
	return tea.Prettify(s)
}

func (s DescribeCloudMigrationPrecheckResultResponseBodyItems) GoString() string {
	return s.String()
}

func (s *DescribeCloudMigrationPrecheckResultResponseBodyItems) SetDetail(v string) *DescribeCloudMigrationPrecheckResultResponseBodyItems {
	s.Detail = &v
	return s
}

func (s *DescribeCloudMigrationPrecheckResultResponseBodyItems) SetGmtCreated(v string) *DescribeCloudMigrationPrecheckResultResponseBodyItems {
	s.GmtCreated = &v
	return s
}

func (s *DescribeCloudMigrationPrecheckResultResponseBodyItems) SetGmtModified(v string) *DescribeCloudMigrationPrecheckResultResponseBodyItems {
	s.GmtModified = &v
	return s
}

func (s *DescribeCloudMigrationPrecheckResultResponseBodyItems) SetSourceAccount(v string) *DescribeCloudMigrationPrecheckResultResponseBodyItems {
	s.SourceAccount = &v
	return s
}

func (s *DescribeCloudMigrationPrecheckResultResponseBodyItems) SetSourceCategory(v string) *DescribeCloudMigrationPrecheckResultResponseBodyItems {
	s.SourceCategory = &v
	return s
}

func (s *DescribeCloudMigrationPrecheckResultResponseBodyItems) SetSourceIpAddress(v string) *DescribeCloudMigrationPrecheckResultResponseBodyItems {
	s.SourceIpAddress = &v
	return s
}

func (s *DescribeCloudMigrationPrecheckResultResponseBodyItems) SetSourcePassword(v string) *DescribeCloudMigrationPrecheckResultResponseBodyItems {
	s.SourcePassword = &v
	return s
}

func (s *DescribeCloudMigrationPrecheckResultResponseBodyItems) SetSourcePort(v int64) *DescribeCloudMigrationPrecheckResultResponseBodyItems {
	s.SourcePort = &v
	return s
}

func (s *DescribeCloudMigrationPrecheckResultResponseBodyItems) SetTargetEip(v string) *DescribeCloudMigrationPrecheckResultResponseBodyItems {
	s.TargetEip = &v
	return s
}

func (s *DescribeCloudMigrationPrecheckResultResponseBodyItems) SetTargetInstanceName(v string) *DescribeCloudMigrationPrecheckResultResponseBodyItems {
	s.TargetInstanceName = &v
	return s
}

func (s *DescribeCloudMigrationPrecheckResultResponseBodyItems) SetTaskId(v int64) *DescribeCloudMigrationPrecheckResultResponseBodyItems {
	s.TaskId = &v
	return s
}

func (s *DescribeCloudMigrationPrecheckResultResponseBodyItems) SetTaskName(v string) *DescribeCloudMigrationPrecheckResultResponseBodyItems {
	s.TaskName = &v
	return s
}

type DescribeCloudMigrationPrecheckResultResponse struct {
	Headers    map[string]*string                                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeCloudMigrationPrecheckResultResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeCloudMigrationPrecheckResultResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeCloudMigrationPrecheckResultResponse) GoString() string {
	return s.String()
}

func (s *DescribeCloudMigrationPrecheckResultResponse) SetHeaders(v map[string]*string) *DescribeCloudMigrationPrecheckResultResponse {
	s.Headers = v
	return s
}

func (s *DescribeCloudMigrationPrecheckResultResponse) SetStatusCode(v int32) *DescribeCloudMigrationPrecheckResultResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeCloudMigrationPrecheckResultResponse) SetBody(v *DescribeCloudMigrationPrecheckResultResponseBody) *DescribeCloudMigrationPrecheckResultResponse {
	s.Body = v
	return s
}

type DescribeCloudMigrationResultRequest struct {
	// The ID of the destination instance. You can call the [DescribeDBInstances](~~26232~~) operation to query the ID of the instance.
	DBInstanceName *string `json:"DBInstanceName,omitempty" xml:"DBInstanceName,omitempty"`
	// The number of entries per page.
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The page number.
	PageSize        *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	ResourceOwnerId *int64 `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The private IP address that is used to connect to the self-managed PostgreSQL instance.
	//
	// *   If the self-managed PostgreSQL instance resides on an Elastic Compute Service (ECS) instance, enter the private IP address of the ECS instance. For more information about how to obtain the private IP address of an ECS instance, see [View IP addresses](~~273914~~).
	// *   If the self-managed PostgreSQL instance resides in a data center, enter the private IP address of the data center.
	SourceIpAddress *string `json:"SourceIpAddress,omitempty" xml:"SourceIpAddress,omitempty"`
	// The port number that is used to connect to the self-managed PostgreSQL instance. You can run the netstat -a | grep PGSQL command to obtain the port number.
	SourcePort *int64 `json:"SourcePort,omitempty" xml:"SourcePort,omitempty"`
	// The ID of the task. You can obtain the ID of a task from the response that is returned when you call the [CreateCloudMigrationTask](~~411690~~) operation to create the task.
	TaskId *int64 `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
	// The name of the task. You can obtain the ID of a task from the response that is returned when you call the [CreateCloudMigrationTask](~~411690~~) operation to create the task.
	TaskName *string `json:"TaskName,omitempty" xml:"TaskName,omitempty"`
}

func (s DescribeCloudMigrationResultRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeCloudMigrationResultRequest) GoString() string {
	return s.String()
}

func (s *DescribeCloudMigrationResultRequest) SetDBInstanceName(v string) *DescribeCloudMigrationResultRequest {
	s.DBInstanceName = &v
	return s
}

func (s *DescribeCloudMigrationResultRequest) SetPageNumber(v int64) *DescribeCloudMigrationResultRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeCloudMigrationResultRequest) SetPageSize(v int64) *DescribeCloudMigrationResultRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeCloudMigrationResultRequest) SetResourceOwnerId(v int64) *DescribeCloudMigrationResultRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeCloudMigrationResultRequest) SetSourceIpAddress(v string) *DescribeCloudMigrationResultRequest {
	s.SourceIpAddress = &v
	return s
}

func (s *DescribeCloudMigrationResultRequest) SetSourcePort(v int64) *DescribeCloudMigrationResultRequest {
	s.SourcePort = &v
	return s
}

func (s *DescribeCloudMigrationResultRequest) SetTaskId(v int64) *DescribeCloudMigrationResultRequest {
	s.TaskId = &v
	return s
}

func (s *DescribeCloudMigrationResultRequest) SetTaskName(v string) *DescribeCloudMigrationResultRequest {
	s.TaskName = &v
	return s
}

type DescribeCloudMigrationResultResponseBody struct {
	// The details about the cloud migration task.
	Items []*DescribeCloudMigrationResultResponseBodyItems `json:"Items,omitempty" xml:"Items,omitempty" type:"Repeated"`
	// The page number.
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries per page.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalSize *int32 `json:"TotalSize,omitempty" xml:"TotalSize,omitempty"`
}

func (s DescribeCloudMigrationResultResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeCloudMigrationResultResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeCloudMigrationResultResponseBody) SetItems(v []*DescribeCloudMigrationResultResponseBodyItems) *DescribeCloudMigrationResultResponseBody {
	s.Items = v
	return s
}

func (s *DescribeCloudMigrationResultResponseBody) SetPageNumber(v int64) *DescribeCloudMigrationResultResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeCloudMigrationResultResponseBody) SetPageSize(v int64) *DescribeCloudMigrationResultResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeCloudMigrationResultResponseBody) SetRequestId(v string) *DescribeCloudMigrationResultResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeCloudMigrationResultResponseBody) SetTotalSize(v int32) *DescribeCloudMigrationResultResponseBody {
	s.TotalSize = &v
	return s
}

type DescribeCloudMigrationResultResponseBodyItems struct {
	// The details about the migration task.
	Detail *string `json:"Detail,omitempty" xml:"Detail,omitempty"`
	// The time when the task was created.
	GmtCreated *string `json:"GmtCreated,omitempty" xml:"GmtCreated,omitempty"`
	// The time when the task was modified.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The migration phase of the migration task.
	//
	// *   **precheck**: precheck
	// *   **basebackup**: full data backup
	// *   **startup**: link establishment
	// *   **increment**: incremental data synchronization
	// *   **switch**: cloud migration-triggered switchover
	// *   **success**: cloud migration completed
	MigrateStage *string `json:"MigrateStage,omitempty" xml:"MigrateStage,omitempty"`
	// The information about the replication link.
	ReplicationInfo *string `json:"ReplicationInfo,omitempty" xml:"ReplicationInfo,omitempty"`
	// The status of data replication.
	//
	// *   **unstarted**
	// *   **catchup**
	// *   **streaming**
	// *   **disconnect**
	// *   **finish**
	ReplicationState *string `json:"ReplicationState,omitempty" xml:"ReplicationState,omitempty"`
	// The username.
	SourceAccount *string `json:"SourceAccount,omitempty" xml:"SourceAccount,omitempty"`
	// The environment in which the self-managed PostgreSQL instance runs.
	//
	// *   **idcOnVpc**: The self-managed PostgreSQL instance resides in a data center. The data center can communicate with the VPC to which the ApsaraDB RDS for PostgreSQL instance belongs.
	// *   **ecsOnVpc**: The self-managed PostgreSQL instance resides on an ECS instance.
	SourceCategory *string `json:"SourceCategory,omitempty" xml:"SourceCategory,omitempty"`
	// The private IP address that is used to connect to the self-managed PostgreSQL instance.
	SourceIpAddress *string `json:"SourceIpAddress,omitempty" xml:"SourceIpAddress,omitempty"`
	// The password.
	SourcePassword *string `json:"SourcePassword,omitempty" xml:"SourcePassword,omitempty"`
	// The port number that is used to connect to the self-managed PostgreSQL instance.
	SourcePort *int64 `json:"SourcePort,omitempty" xml:"SourcePort,omitempty"`
	// The time when the switchover was performed.
	SwitchTime *string `json:"SwitchTime,omitempty" xml:"SwitchTime,omitempty"`
	// A reserved parameter. The return value of this parameter is empty.
	TargetEip *string `json:"TargetEip,omitempty" xml:"TargetEip,omitempty"`
	// The ID of the destination instance.
	TargetInstanceName *string `json:"TargetInstanceName,omitempty" xml:"TargetInstanceName,omitempty"`
	// The task ID.
	TaskId *int64 `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
	// The task name.
	TaskName *string `json:"TaskName,omitempty" xml:"TaskName,omitempty"`
}

func (s DescribeCloudMigrationResultResponseBodyItems) String() string {
	return tea.Prettify(s)
}

func (s DescribeCloudMigrationResultResponseBodyItems) GoString() string {
	return s.String()
}

func (s *DescribeCloudMigrationResultResponseBodyItems) SetDetail(v string) *DescribeCloudMigrationResultResponseBodyItems {
	s.Detail = &v
	return s
}

func (s *DescribeCloudMigrationResultResponseBodyItems) SetGmtCreated(v string) *DescribeCloudMigrationResultResponseBodyItems {
	s.GmtCreated = &v
	return s
}

func (s *DescribeCloudMigrationResultResponseBodyItems) SetGmtModified(v string) *DescribeCloudMigrationResultResponseBodyItems {
	s.GmtModified = &v
	return s
}

func (s *DescribeCloudMigrationResultResponseBodyItems) SetMigrateStage(v string) *DescribeCloudMigrationResultResponseBodyItems {
	s.MigrateStage = &v
	return s
}

func (s *DescribeCloudMigrationResultResponseBodyItems) SetReplicationInfo(v string) *DescribeCloudMigrationResultResponseBodyItems {
	s.ReplicationInfo = &v
	return s
}

func (s *DescribeCloudMigrationResultResponseBodyItems) SetReplicationState(v string) *DescribeCloudMigrationResultResponseBodyItems {
	s.ReplicationState = &v
	return s
}

func (s *DescribeCloudMigrationResultResponseBodyItems) SetSourceAccount(v string) *DescribeCloudMigrationResultResponseBodyItems {
	s.SourceAccount = &v
	return s
}

func (s *DescribeCloudMigrationResultResponseBodyItems) SetSourceCategory(v string) *DescribeCloudMigrationResultResponseBodyItems {
	s.SourceCategory = &v
	return s
}

func (s *DescribeCloudMigrationResultResponseBodyItems) SetSourceIpAddress(v string) *DescribeCloudMigrationResultResponseBodyItems {
	s.SourceIpAddress = &v
	return s
}

func (s *DescribeCloudMigrationResultResponseBodyItems) SetSourcePassword(v string) *DescribeCloudMigrationResultResponseBodyItems {
	s.SourcePassword = &v
	return s
}

func (s *DescribeCloudMigrationResultResponseBodyItems) SetSourcePort(v int64) *DescribeCloudMigrationResultResponseBodyItems {
	s.SourcePort = &v
	return s
}

func (s *DescribeCloudMigrationResultResponseBodyItems) SetSwitchTime(v string) *DescribeCloudMigrationResultResponseBodyItems {
	s.SwitchTime = &v
	return s
}

func (s *DescribeCloudMigrationResultResponseBodyItems) SetTargetEip(v string) *DescribeCloudMigrationResultResponseBodyItems {
	s.TargetEip = &v
	return s
}

func (s *DescribeCloudMigrationResultResponseBodyItems) SetTargetInstanceName(v string) *DescribeCloudMigrationResultResponseBodyItems {
	s.TargetInstanceName = &v
	return s
}

func (s *DescribeCloudMigrationResultResponseBodyItems) SetTaskId(v int64) *DescribeCloudMigrationResultResponseBodyItems {
	s.TaskId = &v
	return s
}

func (s *DescribeCloudMigrationResultResponseBodyItems) SetTaskName(v string) *DescribeCloudMigrationResultResponseBodyItems {
	s.TaskName = &v
	return s
}

type DescribeCloudMigrationResultResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeCloudMigrationResultResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeCloudMigrationResultResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeCloudMigrationResultResponse) GoString() string {
	return s.String()
}

func (s *DescribeCloudMigrationResultResponse) SetHeaders(v map[string]*string) *DescribeCloudMigrationResultResponse {
	s.Headers = v
	return s
}

func (s *DescribeCloudMigrationResultResponse) SetStatusCode(v int32) *DescribeCloudMigrationResultResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeCloudMigrationResultResponse) SetBody(v *DescribeCloudMigrationResultResponseBody) *DescribeCloudMigrationResultResponse {
	s.Body = v
	return s
}

type DescribeCollationTimeZonesRequest struct {
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeCollationTimeZonesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeCollationTimeZonesRequest) GoString() string {
	return s.String()
}

func (s *DescribeCollationTimeZonesRequest) SetOwnerId(v int64) *DescribeCollationTimeZonesRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeCollationTimeZonesRequest) SetResourceOwnerAccount(v string) *DescribeCollationTimeZonesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeCollationTimeZonesRequest) SetResourceOwnerId(v int64) *DescribeCollationTimeZonesRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeCollationTimeZonesResponseBody struct {
	// The list of the character set collations and time zones that are available.
	CollationTimeZones *DescribeCollationTimeZonesResponseBodyCollationTimeZones `json:"CollationTimeZones,omitempty" xml:"CollationTimeZones,omitempty" type:"Struct"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeCollationTimeZonesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeCollationTimeZonesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeCollationTimeZonesResponseBody) SetCollationTimeZones(v *DescribeCollationTimeZonesResponseBodyCollationTimeZones) *DescribeCollationTimeZonesResponseBody {
	s.CollationTimeZones = v
	return s
}

func (s *DescribeCollationTimeZonesResponseBody) SetRequestId(v string) *DescribeCollationTimeZonesResponseBody {
	s.RequestId = &v
	return s
}

type DescribeCollationTimeZonesResponseBodyCollationTimeZones struct {
	CollationTimeZone []*DescribeCollationTimeZonesResponseBodyCollationTimeZonesCollationTimeZone `json:"CollationTimeZone,omitempty" xml:"CollationTimeZone,omitempty" type:"Repeated"`
}

func (s DescribeCollationTimeZonesResponseBodyCollationTimeZones) String() string {
	return tea.Prettify(s)
}

func (s DescribeCollationTimeZonesResponseBodyCollationTimeZones) GoString() string {
	return s.String()
}

func (s *DescribeCollationTimeZonesResponseBodyCollationTimeZones) SetCollationTimeZone(v []*DescribeCollationTimeZonesResponseBodyCollationTimeZonesCollationTimeZone) *DescribeCollationTimeZonesResponseBodyCollationTimeZones {
	s.CollationTimeZone = v
	return s
}

type DescribeCollationTimeZonesResponseBodyCollationTimeZonesCollationTimeZone struct {
	// The description.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The offset of the UTC time. The offset is in the following format: (UTC+*HH:mm*).
	StandardTimeOffset *string `json:"StandardTimeOffset,omitempty" xml:"StandardTimeOffset,omitempty"`
	// The time zone.
	TimeZone *string `json:"TimeZone,omitempty" xml:"TimeZone,omitempty"`
}

func (s DescribeCollationTimeZonesResponseBodyCollationTimeZonesCollationTimeZone) String() string {
	return tea.Prettify(s)
}

func (s DescribeCollationTimeZonesResponseBodyCollationTimeZonesCollationTimeZone) GoString() string {
	return s.String()
}

func (s *DescribeCollationTimeZonesResponseBodyCollationTimeZonesCollationTimeZone) SetDescription(v string) *DescribeCollationTimeZonesResponseBodyCollationTimeZonesCollationTimeZone {
	s.Description = &v
	return s
}

func (s *DescribeCollationTimeZonesResponseBodyCollationTimeZonesCollationTimeZone) SetStandardTimeOffset(v string) *DescribeCollationTimeZonesResponseBodyCollationTimeZonesCollationTimeZone {
	s.StandardTimeOffset = &v
	return s
}

func (s *DescribeCollationTimeZonesResponseBodyCollationTimeZonesCollationTimeZone) SetTimeZone(v string) *DescribeCollationTimeZonesResponseBodyCollationTimeZonesCollationTimeZone {
	s.TimeZone = &v
	return s
}

type DescribeCollationTimeZonesResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeCollationTimeZonesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeCollationTimeZonesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeCollationTimeZonesResponse) GoString() string {
	return s.String()
}

func (s *DescribeCollationTimeZonesResponse) SetHeaders(v map[string]*string) *DescribeCollationTimeZonesResponse {
	s.Headers = v
	return s
}

func (s *DescribeCollationTimeZonesResponse) SetStatusCode(v int32) *DescribeCollationTimeZonesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeCollationTimeZonesResponse) SetBody(v *DescribeCollationTimeZonesResponseBody) *DescribeCollationTimeZonesResponse {
	s.Body = v
	return s
}

type DescribeCrossBackupMetaListRequest struct {
	// The ID of the cross-region backup file that you want to use. You can call the [DescribeCrossRegionBackups](~~121733~~) operation to query the ID of the cross-region backup file.
	BackupSetId *string `json:"BackupSetId,omitempty" xml:"BackupSetId,omitempty"`
	// The name of the database that you want to query. The system implements exact match based on the value of this parameter and returns the name of the matched database and the names of the tables in the matched database.
	GetDbName *string `json:"GetDbName,omitempty" xml:"GetDbName,omitempty"`
	OwnerId   *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of the page to return. Valid values: any non-zero positive integer.
	//
	// > This parameter only takes effect when you specify the **PageSize** parameter.
	PageIndex *string `json:"PageIndex,omitempty" xml:"PageIndex,omitempty"`
	// The number of entries to return per page. Default value: **1**.
	//
	// > This parameter only takes effect when you specify the **PageIndex** parameter.
	PageSize *string `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The name of the database that you want to query. The system implements fuzzy match based on the value of this parameter and returns only the name of the matched database.
	//
	// > You can implement fuzzy match and then exact match. For example, you can set the Pattern parameter to test to query the testdb1 and testdb2 databases. Then, you can specify the **GetDbName** parameter to query only the matched database and the tables in the matched database.
	Pattern *string `json:"Pattern,omitempty" xml:"Pattern,omitempty"`
	// The region ID of the instance.
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The ID of the resource group.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeCrossBackupMetaListRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeCrossBackupMetaListRequest) GoString() string {
	return s.String()
}

func (s *DescribeCrossBackupMetaListRequest) SetBackupSetId(v string) *DescribeCrossBackupMetaListRequest {
	s.BackupSetId = &v
	return s
}

func (s *DescribeCrossBackupMetaListRequest) SetGetDbName(v string) *DescribeCrossBackupMetaListRequest {
	s.GetDbName = &v
	return s
}

func (s *DescribeCrossBackupMetaListRequest) SetOwnerId(v int64) *DescribeCrossBackupMetaListRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeCrossBackupMetaListRequest) SetPageIndex(v string) *DescribeCrossBackupMetaListRequest {
	s.PageIndex = &v
	return s
}

func (s *DescribeCrossBackupMetaListRequest) SetPageSize(v string) *DescribeCrossBackupMetaListRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeCrossBackupMetaListRequest) SetPattern(v string) *DescribeCrossBackupMetaListRequest {
	s.Pattern = &v
	return s
}

func (s *DescribeCrossBackupMetaListRequest) SetRegion(v string) *DescribeCrossBackupMetaListRequest {
	s.Region = &v
	return s
}

func (s *DescribeCrossBackupMetaListRequest) SetResourceGroupId(v string) *DescribeCrossBackupMetaListRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeCrossBackupMetaListRequest) SetResourceOwnerAccount(v string) *DescribeCrossBackupMetaListRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeCrossBackupMetaListRequest) SetResourceOwnerId(v int64) *DescribeCrossBackupMetaListRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeCrossBackupMetaListResponseBody struct {
	// The instance to which the cross-region backup file belongs.
	DBInstanceName *string `json:"DBInstanceName,omitempty" xml:"DBInstanceName,omitempty"`
	// An array that consists of the information about the databases and tables whose data is included in the cross-region backup file.
	Items *DescribeCrossBackupMetaListResponseBodyItems `json:"Items,omitempty" xml:"Items,omitempty" type:"Struct"`
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageRecordCount *int32 `json:"PageRecordCount,omitempty" xml:"PageRecordCount,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of pages returned.
	TotalPageCount *int32 `json:"TotalPageCount,omitempty" xml:"TotalPageCount,omitempty"`
	// The total number of returned entries.
	TotalRecordCount *int32 `json:"TotalRecordCount,omitempty" xml:"TotalRecordCount,omitempty"`
}

func (s DescribeCrossBackupMetaListResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeCrossBackupMetaListResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeCrossBackupMetaListResponseBody) SetDBInstanceName(v string) *DescribeCrossBackupMetaListResponseBody {
	s.DBInstanceName = &v
	return s
}

func (s *DescribeCrossBackupMetaListResponseBody) SetItems(v *DescribeCrossBackupMetaListResponseBodyItems) *DescribeCrossBackupMetaListResponseBody {
	s.Items = v
	return s
}

func (s *DescribeCrossBackupMetaListResponseBody) SetPageNumber(v int32) *DescribeCrossBackupMetaListResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeCrossBackupMetaListResponseBody) SetPageRecordCount(v int32) *DescribeCrossBackupMetaListResponseBody {
	s.PageRecordCount = &v
	return s
}

func (s *DescribeCrossBackupMetaListResponseBody) SetRequestId(v string) *DescribeCrossBackupMetaListResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeCrossBackupMetaListResponseBody) SetTotalPageCount(v int32) *DescribeCrossBackupMetaListResponseBody {
	s.TotalPageCount = &v
	return s
}

func (s *DescribeCrossBackupMetaListResponseBody) SetTotalRecordCount(v int32) *DescribeCrossBackupMetaListResponseBody {
	s.TotalRecordCount = &v
	return s
}

type DescribeCrossBackupMetaListResponseBodyItems struct {
	Meta []*DescribeCrossBackupMetaListResponseBodyItemsMeta `json:"Meta,omitempty" xml:"Meta,omitempty" type:"Repeated"`
}

func (s DescribeCrossBackupMetaListResponseBodyItems) String() string {
	return tea.Prettify(s)
}

func (s DescribeCrossBackupMetaListResponseBodyItems) GoString() string {
	return s.String()
}

func (s *DescribeCrossBackupMetaListResponseBodyItems) SetMeta(v []*DescribeCrossBackupMetaListResponseBodyItemsMeta) *DescribeCrossBackupMetaListResponseBodyItems {
	s.Meta = v
	return s
}

type DescribeCrossBackupMetaListResponseBodyItemsMeta struct {
	// The name of the database.
	Database *string `json:"Database,omitempty" xml:"Database,omitempty"`
	// The size of the table. Unit: KB. If the database contains more than one table, the names of these tables are separated by commas (,).
	Size *string `json:"Size,omitempty" xml:"Size,omitempty"`
	// An array that consists of the names of the tables that the database contains. If the database contains more than one table, the names of these tables are separated by commas (,).
	Tables *string `json:"Tables,omitempty" xml:"Tables,omitempty"`
}

func (s DescribeCrossBackupMetaListResponseBodyItemsMeta) String() string {
	return tea.Prettify(s)
}

func (s DescribeCrossBackupMetaListResponseBodyItemsMeta) GoString() string {
	return s.String()
}

func (s *DescribeCrossBackupMetaListResponseBodyItemsMeta) SetDatabase(v string) *DescribeCrossBackupMetaListResponseBodyItemsMeta {
	s.Database = &v
	return s
}

func (s *DescribeCrossBackupMetaListResponseBodyItemsMeta) SetSize(v string) *DescribeCrossBackupMetaListResponseBodyItemsMeta {
	s.Size = &v
	return s
}

func (s *DescribeCrossBackupMetaListResponseBodyItemsMeta) SetTables(v string) *DescribeCrossBackupMetaListResponseBodyItemsMeta {
	s.Tables = &v
	return s
}

type DescribeCrossBackupMetaListResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeCrossBackupMetaListResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeCrossBackupMetaListResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeCrossBackupMetaListResponse) GoString() string {
	return s.String()
}

func (s *DescribeCrossBackupMetaListResponse) SetHeaders(v map[string]*string) *DescribeCrossBackupMetaListResponse {
	s.Headers = v
	return s
}

func (s *DescribeCrossBackupMetaListResponse) SetStatusCode(v int32) *DescribeCrossBackupMetaListResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeCrossBackupMetaListResponse) SetBody(v *DescribeCrossBackupMetaListResponseBody) *DescribeCrossBackupMetaListResponse {
	s.Body = v
	return s
}

type DescribeCrossRegionBackupDBInstanceRequest struct {
	// The ID of the instance. Up to 30 instance IDs are allowed in a single request. If you enter more than one instance ID, separate them with commas (,).
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of the page to return. Valid values: any non-zero positive integer.
	//
	// Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return per page. Default value: 30.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the region.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeCrossRegionBackupDBInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeCrossRegionBackupDBInstanceRequest) GoString() string {
	return s.String()
}

func (s *DescribeCrossRegionBackupDBInstanceRequest) SetDBInstanceId(v string) *DescribeCrossRegionBackupDBInstanceRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeCrossRegionBackupDBInstanceRequest) SetOwnerId(v int64) *DescribeCrossRegionBackupDBInstanceRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeCrossRegionBackupDBInstanceRequest) SetPageNumber(v int32) *DescribeCrossRegionBackupDBInstanceRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeCrossRegionBackupDBInstanceRequest) SetPageSize(v int32) *DescribeCrossRegionBackupDBInstanceRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeCrossRegionBackupDBInstanceRequest) SetRegionId(v string) *DescribeCrossRegionBackupDBInstanceRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeCrossRegionBackupDBInstanceRequest) SetResourceOwnerAccount(v string) *DescribeCrossRegionBackupDBInstanceRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeCrossRegionBackupDBInstanceRequest) SetResourceOwnerId(v int64) *DescribeCrossRegionBackupDBInstanceRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeCrossRegionBackupDBInstanceResponseBody struct {
	// An array that consists of instances and their cross-region backup settings.
	Items *DescribeCrossRegionBackupDBInstanceResponseBodyItems `json:"Items,omitempty" xml:"Items,omitempty" type:"Struct"`
	// The total number of items returned for cross-region backup settings.
	ItemsNumbers *int32 `json:"ItemsNumbers,omitempty" xml:"ItemsNumbers,omitempty"`
	// The page number of the returned page. Valid values: any non-zero positive integer.
	//
	// Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page. Default value: 30.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of returned entries.
	TotalRecords *int32 `json:"TotalRecords,omitempty" xml:"TotalRecords,omitempty"`
}

func (s DescribeCrossRegionBackupDBInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeCrossRegionBackupDBInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeCrossRegionBackupDBInstanceResponseBody) SetItems(v *DescribeCrossRegionBackupDBInstanceResponseBodyItems) *DescribeCrossRegionBackupDBInstanceResponseBody {
	s.Items = v
	return s
}

func (s *DescribeCrossRegionBackupDBInstanceResponseBody) SetItemsNumbers(v int32) *DescribeCrossRegionBackupDBInstanceResponseBody {
	s.ItemsNumbers = &v
	return s
}

func (s *DescribeCrossRegionBackupDBInstanceResponseBody) SetPageNumber(v int32) *DescribeCrossRegionBackupDBInstanceResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeCrossRegionBackupDBInstanceResponseBody) SetPageSize(v int32) *DescribeCrossRegionBackupDBInstanceResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeCrossRegionBackupDBInstanceResponseBody) SetRegionId(v string) *DescribeCrossRegionBackupDBInstanceResponseBody {
	s.RegionId = &v
	return s
}

func (s *DescribeCrossRegionBackupDBInstanceResponseBody) SetRequestId(v string) *DescribeCrossRegionBackupDBInstanceResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeCrossRegionBackupDBInstanceResponseBody) SetTotalRecords(v int32) *DescribeCrossRegionBackupDBInstanceResponseBody {
	s.TotalRecords = &v
	return s
}

type DescribeCrossRegionBackupDBInstanceResponseBodyItems struct {
	Item []*DescribeCrossRegionBackupDBInstanceResponseBodyItemsItem `json:"Item,omitempty" xml:"Item,omitempty" type:"Repeated"`
}

func (s DescribeCrossRegionBackupDBInstanceResponseBodyItems) String() string {
	return tea.Prettify(s)
}

func (s DescribeCrossRegionBackupDBInstanceResponseBodyItems) GoString() string {
	return s.String()
}

func (s *DescribeCrossRegionBackupDBInstanceResponseBodyItems) SetItem(v []*DescribeCrossRegionBackupDBInstanceResponseBodyItemsItem) *DescribeCrossRegionBackupDBInstanceResponseBodyItems {
	s.Item = v
	return s
}

type DescribeCrossRegionBackupDBInstanceResponseBodyItemsItem struct {
	// The status of the cross-region backup feature on the instance. Valid values:
	//
	// *   **Disable**
	// *   **Enable**
	BackupEnabled *string `json:"BackupEnabled,omitempty" xml:"BackupEnabled,omitempty"`
	// The time when cross-region backup was enabled on the instance. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	BackupEnabledTime *string `json:"BackupEnabledTime,omitempty" xml:"BackupEnabledTime,omitempty"`
	// The ID of the region in which the cross-region data backup file is stored.
	CrossBackupRegion *string `json:"CrossBackupRegion,omitempty" xml:"CrossBackupRegion,omitempty"`
	// The policy that is used to save the cross-region backup files of the instance. Default value: **1**. The value 1 indicates that all cross-region backup files are saved.
	CrossBackupType *string `json:"CrossBackupType,omitempty" xml:"CrossBackupType,omitempty"`
	// The name of the instance. It must be 2 to 256 characters in length. The name can contain letters, digits, underscores (\_), and hyphens (-). The name must start with a letter.
	//
	// > The value cannot start with http:// or https://.
	DBInstanceDescription *string `json:"DBInstanceDescription,omitempty" xml:"DBInstanceDescription,omitempty"`
	// The ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The status of the instance. For more information, see [Instance states](~~26315~~).
	DBInstanceStatus *string `json:"DBInstanceStatus,omitempty" xml:"DBInstanceStatus,omitempty"`
	// The database engine of the instance.
	Engine *string `json:"Engine,omitempty" xml:"Engine,omitempty"`
	// The database engine version of the instance.
	EngineVersion *string `json:"EngineVersion,omitempty" xml:"EngineVersion,omitempty"`
	// The lock status of the instance. Valid values:
	//
	// *   **Unlock**: The instance is not locked.
	// *   **ManualLock**: The instance is manually locked.
	// *   **LockByExpiration**: The instance is automatically locked after it expires.
	// *   **LockByRestoration**: The instance is automatically locked before it is rolled back.
	// *   **LockByDiskQuota**: The instance is automatically locked because its storage capacity is exhausted and the instance is inaccessible.
	LockMode *string `json:"LockMode,omitempty" xml:"LockMode,omitempty"`
	// The status of the cross-region log backup feature on the instance. Valid values:
	//
	// *   **Disable**
	// *   **Enable**
	LogBackupEnabled *string `json:"LogBackupEnabled,omitempty" xml:"LogBackupEnabled,omitempty"`
	// The time when cross-region log backup was enabled on the instance. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	LogBackupEnabledTime *string `json:"LogBackupEnabledTime,omitempty" xml:"LogBackupEnabledTime,omitempty"`
	// The policy that is used to retain the cross-region backup files of the instance. Cross-region backups can be retained only based on the specified retention period. Default value: **1**.
	RetentType *int32 `json:"RetentType,omitempty" xml:"RetentType,omitempty"`
	// The number of days for which the cross-region backup files of the instance are retained. Valid values: **7 to 1825**.
	Retention *int32 `json:"Retention,omitempty" xml:"Retention,omitempty"`
}

func (s DescribeCrossRegionBackupDBInstanceResponseBodyItemsItem) String() string {
	return tea.Prettify(s)
}

func (s DescribeCrossRegionBackupDBInstanceResponseBodyItemsItem) GoString() string {
	return s.String()
}

func (s *DescribeCrossRegionBackupDBInstanceResponseBodyItemsItem) SetBackupEnabled(v string) *DescribeCrossRegionBackupDBInstanceResponseBodyItemsItem {
	s.BackupEnabled = &v
	return s
}

func (s *DescribeCrossRegionBackupDBInstanceResponseBodyItemsItem) SetBackupEnabledTime(v string) *DescribeCrossRegionBackupDBInstanceResponseBodyItemsItem {
	s.BackupEnabledTime = &v
	return s
}

func (s *DescribeCrossRegionBackupDBInstanceResponseBodyItemsItem) SetCrossBackupRegion(v string) *DescribeCrossRegionBackupDBInstanceResponseBodyItemsItem {
	s.CrossBackupRegion = &v
	return s
}

func (s *DescribeCrossRegionBackupDBInstanceResponseBodyItemsItem) SetCrossBackupType(v string) *DescribeCrossRegionBackupDBInstanceResponseBodyItemsItem {
	s.CrossBackupType = &v
	return s
}

func (s *DescribeCrossRegionBackupDBInstanceResponseBodyItemsItem) SetDBInstanceDescription(v string) *DescribeCrossRegionBackupDBInstanceResponseBodyItemsItem {
	s.DBInstanceDescription = &v
	return s
}

func (s *DescribeCrossRegionBackupDBInstanceResponseBodyItemsItem) SetDBInstanceId(v string) *DescribeCrossRegionBackupDBInstanceResponseBodyItemsItem {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeCrossRegionBackupDBInstanceResponseBodyItemsItem) SetDBInstanceStatus(v string) *DescribeCrossRegionBackupDBInstanceResponseBodyItemsItem {
	s.DBInstanceStatus = &v
	return s
}

func (s *DescribeCrossRegionBackupDBInstanceResponseBodyItemsItem) SetEngine(v string) *DescribeCrossRegionBackupDBInstanceResponseBodyItemsItem {
	s.Engine = &v
	return s
}

func (s *DescribeCrossRegionBackupDBInstanceResponseBodyItemsItem) SetEngineVersion(v string) *DescribeCrossRegionBackupDBInstanceResponseBodyItemsItem {
	s.EngineVersion = &v
	return s
}

func (s *DescribeCrossRegionBackupDBInstanceResponseBodyItemsItem) SetLockMode(v string) *DescribeCrossRegionBackupDBInstanceResponseBodyItemsItem {
	s.LockMode = &v
	return s
}

func (s *DescribeCrossRegionBackupDBInstanceResponseBodyItemsItem) SetLogBackupEnabled(v string) *DescribeCrossRegionBackupDBInstanceResponseBodyItemsItem {
	s.LogBackupEnabled = &v
	return s
}

func (s *DescribeCrossRegionBackupDBInstanceResponseBodyItemsItem) SetLogBackupEnabledTime(v string) *DescribeCrossRegionBackupDBInstanceResponseBodyItemsItem {
	s.LogBackupEnabledTime = &v
	return s
}

func (s *DescribeCrossRegionBackupDBInstanceResponseBodyItemsItem) SetRetentType(v int32) *DescribeCrossRegionBackupDBInstanceResponseBodyItemsItem {
	s.RetentType = &v
	return s
}

func (s *DescribeCrossRegionBackupDBInstanceResponseBodyItemsItem) SetRetention(v int32) *DescribeCrossRegionBackupDBInstanceResponseBodyItemsItem {
	s.Retention = &v
	return s
}

type DescribeCrossRegionBackupDBInstanceResponse struct {
	Headers    map[string]*string                               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeCrossRegionBackupDBInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeCrossRegionBackupDBInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeCrossRegionBackupDBInstanceResponse) GoString() string {
	return s.String()
}

func (s *DescribeCrossRegionBackupDBInstanceResponse) SetHeaders(v map[string]*string) *DescribeCrossRegionBackupDBInstanceResponse {
	s.Headers = v
	return s
}

func (s *DescribeCrossRegionBackupDBInstanceResponse) SetStatusCode(v int32) *DescribeCrossRegionBackupDBInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeCrossRegionBackupDBInstanceResponse) SetBody(v *DescribeCrossRegionBackupDBInstanceResponseBody) *DescribeCrossRegionBackupDBInstanceResponse {
	s.Body = v
	return s
}

type DescribeCrossRegionBackupsRequest struct {
	// The ID of the backup file.
	BackupId *int32 `json:"BackupId,omitempty" xml:"BackupId,omitempty"`
	// The ID of the cross-region data backup file.
	//
	// >  You must specify the **CrossBackupId** parameter. Alternatively, you must specify the **StartTime** and **EndTime** parameters.
	CrossBackupId *int32 `json:"CrossBackupId,omitempty" xml:"CrossBackupId,omitempty"`
	// The ID of the region in which the cross-region data backup file is stored.
	CrossBackupRegion *string `json:"CrossBackupRegion,omitempty" xml:"CrossBackupRegion,omitempty"`
	// The instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The end of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	OwnerId *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The page number. Valid values: any non-zero positive integer.
	//
	// Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries per page. Valid values:
	//
	// *   **30**
	// *   **50**
	// *   **100**
	//
	// Default value: 30.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeCrossRegionBackupsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeCrossRegionBackupsRequest) GoString() string {
	return s.String()
}

func (s *DescribeCrossRegionBackupsRequest) SetBackupId(v int32) *DescribeCrossRegionBackupsRequest {
	s.BackupId = &v
	return s
}

func (s *DescribeCrossRegionBackupsRequest) SetCrossBackupId(v int32) *DescribeCrossRegionBackupsRequest {
	s.CrossBackupId = &v
	return s
}

func (s *DescribeCrossRegionBackupsRequest) SetCrossBackupRegion(v string) *DescribeCrossRegionBackupsRequest {
	s.CrossBackupRegion = &v
	return s
}

func (s *DescribeCrossRegionBackupsRequest) SetDBInstanceId(v string) *DescribeCrossRegionBackupsRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeCrossRegionBackupsRequest) SetEndTime(v string) *DescribeCrossRegionBackupsRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeCrossRegionBackupsRequest) SetOwnerId(v int64) *DescribeCrossRegionBackupsRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeCrossRegionBackupsRequest) SetPageNumber(v int32) *DescribeCrossRegionBackupsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeCrossRegionBackupsRequest) SetPageSize(v int32) *DescribeCrossRegionBackupsRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeCrossRegionBackupsRequest) SetRegionId(v string) *DescribeCrossRegionBackupsRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeCrossRegionBackupsRequest) SetResourceGroupId(v string) *DescribeCrossRegionBackupsRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeCrossRegionBackupsRequest) SetResourceOwnerAccount(v string) *DescribeCrossRegionBackupsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeCrossRegionBackupsRequest) SetResourceOwnerId(v int64) *DescribeCrossRegionBackupsRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeCrossRegionBackupsRequest) SetStartTime(v string) *DescribeCrossRegionBackupsRequest {
	s.StartTime = &v
	return s
}

type DescribeCrossRegionBackupsResponseBody struct {
	// The end of the time range to query.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The cross-region data backup files.
	Items *DescribeCrossRegionBackupsResponseBodyItems `json:"Items,omitempty" xml:"Items,omitempty" type:"Struct"`
	// The page number. Pages start from page 1.
	//
	// Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of cross-region data backup files on the current page.
	PageRecordCount *int32 `json:"PageRecordCount,omitempty" xml:"PageRecordCount,omitempty"`
	// The region ID of the instance.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The beginning of the time range to query.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The total number of entries that are returned.
	TotalRecordCount *int32 `json:"TotalRecordCount,omitempty" xml:"TotalRecordCount,omitempty"`
}

func (s DescribeCrossRegionBackupsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeCrossRegionBackupsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeCrossRegionBackupsResponseBody) SetEndTime(v string) *DescribeCrossRegionBackupsResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeCrossRegionBackupsResponseBody) SetItems(v *DescribeCrossRegionBackupsResponseBodyItems) *DescribeCrossRegionBackupsResponseBody {
	s.Items = v
	return s
}

func (s *DescribeCrossRegionBackupsResponseBody) SetPageNumber(v int32) *DescribeCrossRegionBackupsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeCrossRegionBackupsResponseBody) SetPageRecordCount(v int32) *DescribeCrossRegionBackupsResponseBody {
	s.PageRecordCount = &v
	return s
}

func (s *DescribeCrossRegionBackupsResponseBody) SetRegionId(v string) *DescribeCrossRegionBackupsResponseBody {
	s.RegionId = &v
	return s
}

func (s *DescribeCrossRegionBackupsResponseBody) SetRequestId(v string) *DescribeCrossRegionBackupsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeCrossRegionBackupsResponseBody) SetStartTime(v string) *DescribeCrossRegionBackupsResponseBody {
	s.StartTime = &v
	return s
}

func (s *DescribeCrossRegionBackupsResponseBody) SetTotalRecordCount(v int32) *DescribeCrossRegionBackupsResponseBody {
	s.TotalRecordCount = &v
	return s
}

type DescribeCrossRegionBackupsResponseBodyItems struct {
	Item []*DescribeCrossRegionBackupsResponseBodyItemsItem `json:"Item,omitempty" xml:"Item,omitempty" type:"Repeated"`
}

func (s DescribeCrossRegionBackupsResponseBodyItems) String() string {
	return tea.Prettify(s)
}

func (s DescribeCrossRegionBackupsResponseBodyItems) GoString() string {
	return s.String()
}

func (s *DescribeCrossRegionBackupsResponseBodyItems) SetItem(v []*DescribeCrossRegionBackupsResponseBodyItemsItem) *DescribeCrossRegionBackupsResponseBodyItems {
	s.Item = v
	return s
}

type DescribeCrossRegionBackupsResponseBodyItemsItem struct {
	// The time when the cross-region data backup file was generated.
	BackupEndTime *string `json:"BackupEndTime,omitempty" xml:"BackupEndTime,omitempty"`
	// The method that is used to generate the cross-region data backup file. Valid values:
	//
	// *   **L**: logical backup
	// *   **P**: physical backup
	BackupMethod *string `json:"BackupMethod,omitempty" xml:"BackupMethod,omitempty"`
	// The level at which the cross-region data backup file is generated.
	//
	// *   **0**: instance-level backup
	// *   **1**: database-level backup
	BackupSetScale *int32 `json:"BackupSetScale,omitempty" xml:"BackupSetScale,omitempty"`
	// The status of the cross-region data backup. Valid values:
	//
	// *   **0**: The cross-region data backup is successful.
	// *   **1**: The cross-region data backup failed.
	BackupSetStatus *int32 `json:"BackupSetStatus,omitempty" xml:"BackupSetStatus,omitempty"`
	// The time when the cross-region data backup started.
	BackupStartTime *string `json:"BackupStartTime,omitempty" xml:"BackupStartTime,omitempty"`
	// The type of the cross-region data backup. Valid values:
	//
	// *   **F**: full data backup
	// *   **I**: incremental data backup
	BackupType *string `json:"BackupType,omitempty" xml:"BackupType,omitempty"`
	// The RDS edition of the instance. Valid values:
	//
	// *   **Basic**: RDS Basic Edition
	// *   **HighAvailability**: RDS High-availability Edition
	// *   **Finance**: Enterprise Edition. This edition is supported only by the China site (aliyun.com).
	Category *string `json:"Category,omitempty" xml:"Category,omitempty"`
	// The point in time that is indicated by the data in the cross-region data backup file.
	ConsistentTime *string `json:"ConsistentTime,omitempty" xml:"ConsistentTime,omitempty"`
	// The external URL from which you can download the cross-region data backup file.
	CrossBackupDownloadLink *string `json:"CrossBackupDownloadLink,omitempty" xml:"CrossBackupDownloadLink,omitempty"`
	// The ID of the cross-region data backup file.
	CrossBackupId *int32 `json:"CrossBackupId,omitempty" xml:"CrossBackupId,omitempty"`
	// The ID of the region in which the cross-region backup files of the instance are stored.
	CrossBackupRegion *string `json:"CrossBackupRegion,omitempty" xml:"CrossBackupRegion,omitempty"`
	// The name of the compressed package that contains the cross-region data backup file.
	CrossBackupSetFile *string `json:"CrossBackupSetFile,omitempty" xml:"CrossBackupSetFile,omitempty"`
	// The location where the cross-region data backup file is stored.
	CrossBackupSetLocation *string `json:"CrossBackupSetLocation,omitempty" xml:"CrossBackupSetLocation,omitempty"`
	// The size of the cross-region data backup file. Unit: bytes.
	CrossBackupSetSize *int64 `json:"CrossBackupSetSize,omitempty" xml:"CrossBackupSetSize,omitempty"`
	// The storage type. Valid values:
	//
	// *   **local_ssd**: local SSD. This is the recommended storage type.
	// *   **cloud_ssd**: standard SSD.
	// *   **cloud_essd**: enhanced SSD (ESSD)
	DBInstanceStorageType *string `json:"DBInstanceStorageType,omitempty" xml:"DBInstanceStorageType,omitempty"`
	// The database engine of the instance.
	Engine *string `json:"Engine,omitempty" xml:"Engine,omitempty"`
	// The database engine version of the instance.
	EngineVersion *string `json:"EngineVersion,omitempty" xml:"EngineVersion,omitempty"`
	// The ID of the instance. This parameter is used to determine whether the instance that generates the cross-region data backup file is a primary or secondary instance.
	InstanceId *int32 `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// An array that consists of the regions to which the cross-region data backup file can be restored.
	RestoreRegions *DescribeCrossRegionBackupsResponseBodyItemsItemRestoreRegions `json:"RestoreRegions,omitempty" xml:"RestoreRegions,omitempty" type:"Struct"`
}

func (s DescribeCrossRegionBackupsResponseBodyItemsItem) String() string {
	return tea.Prettify(s)
}

func (s DescribeCrossRegionBackupsResponseBodyItemsItem) GoString() string {
	return s.String()
}

func (s *DescribeCrossRegionBackupsResponseBodyItemsItem) SetBackupEndTime(v string) *DescribeCrossRegionBackupsResponseBodyItemsItem {
	s.BackupEndTime = &v
	return s
}

func (s *DescribeCrossRegionBackupsResponseBodyItemsItem) SetBackupMethod(v string) *DescribeCrossRegionBackupsResponseBodyItemsItem {
	s.BackupMethod = &v
	return s
}

func (s *DescribeCrossRegionBackupsResponseBodyItemsItem) SetBackupSetScale(v int32) *DescribeCrossRegionBackupsResponseBodyItemsItem {
	s.BackupSetScale = &v
	return s
}

func (s *DescribeCrossRegionBackupsResponseBodyItemsItem) SetBackupSetStatus(v int32) *DescribeCrossRegionBackupsResponseBodyItemsItem {
	s.BackupSetStatus = &v
	return s
}

func (s *DescribeCrossRegionBackupsResponseBodyItemsItem) SetBackupStartTime(v string) *DescribeCrossRegionBackupsResponseBodyItemsItem {
	s.BackupStartTime = &v
	return s
}

func (s *DescribeCrossRegionBackupsResponseBodyItemsItem) SetBackupType(v string) *DescribeCrossRegionBackupsResponseBodyItemsItem {
	s.BackupType = &v
	return s
}

func (s *DescribeCrossRegionBackupsResponseBodyItemsItem) SetCategory(v string) *DescribeCrossRegionBackupsResponseBodyItemsItem {
	s.Category = &v
	return s
}

func (s *DescribeCrossRegionBackupsResponseBodyItemsItem) SetConsistentTime(v string) *DescribeCrossRegionBackupsResponseBodyItemsItem {
	s.ConsistentTime = &v
	return s
}

func (s *DescribeCrossRegionBackupsResponseBodyItemsItem) SetCrossBackupDownloadLink(v string) *DescribeCrossRegionBackupsResponseBodyItemsItem {
	s.CrossBackupDownloadLink = &v
	return s
}

func (s *DescribeCrossRegionBackupsResponseBodyItemsItem) SetCrossBackupId(v int32) *DescribeCrossRegionBackupsResponseBodyItemsItem {
	s.CrossBackupId = &v
	return s
}

func (s *DescribeCrossRegionBackupsResponseBodyItemsItem) SetCrossBackupRegion(v string) *DescribeCrossRegionBackupsResponseBodyItemsItem {
	s.CrossBackupRegion = &v
	return s
}

func (s *DescribeCrossRegionBackupsResponseBodyItemsItem) SetCrossBackupSetFile(v string) *DescribeCrossRegionBackupsResponseBodyItemsItem {
	s.CrossBackupSetFile = &v
	return s
}

func (s *DescribeCrossRegionBackupsResponseBodyItemsItem) SetCrossBackupSetLocation(v string) *DescribeCrossRegionBackupsResponseBodyItemsItem {
	s.CrossBackupSetLocation = &v
	return s
}

func (s *DescribeCrossRegionBackupsResponseBodyItemsItem) SetCrossBackupSetSize(v int64) *DescribeCrossRegionBackupsResponseBodyItemsItem {
	s.CrossBackupSetSize = &v
	return s
}

func (s *DescribeCrossRegionBackupsResponseBodyItemsItem) SetDBInstanceStorageType(v string) *DescribeCrossRegionBackupsResponseBodyItemsItem {
	s.DBInstanceStorageType = &v
	return s
}

func (s *DescribeCrossRegionBackupsResponseBodyItemsItem) SetEngine(v string) *DescribeCrossRegionBackupsResponseBodyItemsItem {
	s.Engine = &v
	return s
}

func (s *DescribeCrossRegionBackupsResponseBodyItemsItem) SetEngineVersion(v string) *DescribeCrossRegionBackupsResponseBodyItemsItem {
	s.EngineVersion = &v
	return s
}

func (s *DescribeCrossRegionBackupsResponseBodyItemsItem) SetInstanceId(v int32) *DescribeCrossRegionBackupsResponseBodyItemsItem {
	s.InstanceId = &v
	return s
}

func (s *DescribeCrossRegionBackupsResponseBodyItemsItem) SetRestoreRegions(v *DescribeCrossRegionBackupsResponseBodyItemsItemRestoreRegions) *DescribeCrossRegionBackupsResponseBodyItemsItem {
	s.RestoreRegions = v
	return s
}

type DescribeCrossRegionBackupsResponseBodyItemsItemRestoreRegions struct {
	RestoreRegion []*string `json:"RestoreRegion,omitempty" xml:"RestoreRegion,omitempty" type:"Repeated"`
}

func (s DescribeCrossRegionBackupsResponseBodyItemsItemRestoreRegions) String() string {
	return tea.Prettify(s)
}

func (s DescribeCrossRegionBackupsResponseBodyItemsItemRestoreRegions) GoString() string {
	return s.String()
}

func (s *DescribeCrossRegionBackupsResponseBodyItemsItemRestoreRegions) SetRestoreRegion(v []*string) *DescribeCrossRegionBackupsResponseBodyItemsItemRestoreRegions {
	s.RestoreRegion = v
	return s
}

type DescribeCrossRegionBackupsResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeCrossRegionBackupsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeCrossRegionBackupsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeCrossRegionBackupsResponse) GoString() string {
	return s.String()
}

func (s *DescribeCrossRegionBackupsResponse) SetHeaders(v map[string]*string) *DescribeCrossRegionBackupsResponse {
	s.Headers = v
	return s
}

func (s *DescribeCrossRegionBackupsResponse) SetStatusCode(v int32) *DescribeCrossRegionBackupsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeCrossRegionBackupsResponse) SetBody(v *DescribeCrossRegionBackupsResponseBody) *DescribeCrossRegionBackupsResponse {
	s.Body = v
	return s
}

type DescribeCrossRegionLogBackupFilesRequest struct {
	// The ID of the region in which the cross-region data backup file is stored. You can call the [DescribeCrossRegionBackupDBInstance](~~121737~~) operation to query the most recent region list.
	CrossBackupRegion *string `json:"CrossBackupRegion,omitempty" xml:"CrossBackupRegion,omitempty"`
	// The instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The end of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	OwnerId *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The page number. Valid values: any non-zero positive integer.
	//
	// Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Valid values:
	//
	// *   **30**
	// *   **50**
	// *   **100**
	//
	// Default value: 30.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The region ID. You can call the [DescribeRegions](~~26243~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeCrossRegionLogBackupFilesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeCrossRegionLogBackupFilesRequest) GoString() string {
	return s.String()
}

func (s *DescribeCrossRegionLogBackupFilesRequest) SetCrossBackupRegion(v string) *DescribeCrossRegionLogBackupFilesRequest {
	s.CrossBackupRegion = &v
	return s
}

func (s *DescribeCrossRegionLogBackupFilesRequest) SetDBInstanceId(v string) *DescribeCrossRegionLogBackupFilesRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeCrossRegionLogBackupFilesRequest) SetEndTime(v string) *DescribeCrossRegionLogBackupFilesRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeCrossRegionLogBackupFilesRequest) SetOwnerId(v int64) *DescribeCrossRegionLogBackupFilesRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeCrossRegionLogBackupFilesRequest) SetPageNumber(v int32) *DescribeCrossRegionLogBackupFilesRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeCrossRegionLogBackupFilesRequest) SetPageSize(v int32) *DescribeCrossRegionLogBackupFilesRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeCrossRegionLogBackupFilesRequest) SetRegionId(v string) *DescribeCrossRegionLogBackupFilesRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeCrossRegionLogBackupFilesRequest) SetResourceOwnerAccount(v string) *DescribeCrossRegionLogBackupFilesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeCrossRegionLogBackupFilesRequest) SetResourceOwnerId(v int64) *DescribeCrossRegionLogBackupFilesRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeCrossRegionLogBackupFilesRequest) SetStartTime(v string) *DescribeCrossRegionLogBackupFilesRequest {
	s.StartTime = &v
	return s
}

type DescribeCrossRegionLogBackupFilesResponseBody struct {
	// The instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The end of the time range to query. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The cross-region log backup files.
	Items *DescribeCrossRegionLogBackupFilesResponseBodyItems `json:"Items,omitempty" xml:"Items,omitempty" type:"Struct"`
	// The page number. Pages start from page 1.
	//
	// Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of cross-region backup files on the current page.
	PageRecordCount *int32 `json:"PageRecordCount,omitempty" xml:"PageRecordCount,omitempty"`
	// The region ID of the instance.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The beginning of the time range to query. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The total number of entries that are returned.
	TotalRecordCount *int32 `json:"TotalRecordCount,omitempty" xml:"TotalRecordCount,omitempty"`
}

func (s DescribeCrossRegionLogBackupFilesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeCrossRegionLogBackupFilesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeCrossRegionLogBackupFilesResponseBody) SetDBInstanceId(v string) *DescribeCrossRegionLogBackupFilesResponseBody {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeCrossRegionLogBackupFilesResponseBody) SetEndTime(v string) *DescribeCrossRegionLogBackupFilesResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeCrossRegionLogBackupFilesResponseBody) SetItems(v *DescribeCrossRegionLogBackupFilesResponseBodyItems) *DescribeCrossRegionLogBackupFilesResponseBody {
	s.Items = v
	return s
}

func (s *DescribeCrossRegionLogBackupFilesResponseBody) SetPageNumber(v int32) *DescribeCrossRegionLogBackupFilesResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeCrossRegionLogBackupFilesResponseBody) SetPageRecordCount(v int32) *DescribeCrossRegionLogBackupFilesResponseBody {
	s.PageRecordCount = &v
	return s
}

func (s *DescribeCrossRegionLogBackupFilesResponseBody) SetRegionId(v string) *DescribeCrossRegionLogBackupFilesResponseBody {
	s.RegionId = &v
	return s
}

func (s *DescribeCrossRegionLogBackupFilesResponseBody) SetRequestId(v string) *DescribeCrossRegionLogBackupFilesResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeCrossRegionLogBackupFilesResponseBody) SetStartTime(v string) *DescribeCrossRegionLogBackupFilesResponseBody {
	s.StartTime = &v
	return s
}

func (s *DescribeCrossRegionLogBackupFilesResponseBody) SetTotalRecordCount(v int32) *DescribeCrossRegionLogBackupFilesResponseBody {
	s.TotalRecordCount = &v
	return s
}

type DescribeCrossRegionLogBackupFilesResponseBodyItems struct {
	Item []*DescribeCrossRegionLogBackupFilesResponseBodyItemsItem `json:"Item,omitempty" xml:"Item,omitempty" type:"Repeated"`
}

func (s DescribeCrossRegionLogBackupFilesResponseBodyItems) String() string {
	return tea.Prettify(s)
}

func (s DescribeCrossRegionLogBackupFilesResponseBodyItems) GoString() string {
	return s.String()
}

func (s *DescribeCrossRegionLogBackupFilesResponseBodyItems) SetItem(v []*DescribeCrossRegionLogBackupFilesResponseBodyItemsItem) *DescribeCrossRegionLogBackupFilesResponseBodyItems {
	s.Item = v
	return s
}

type DescribeCrossRegionLogBackupFilesResponseBodyItemsItem struct {
	// The ID of the destination region within which the cross-region backup file is stored.
	CrossBackupRegion *string `json:"CrossBackupRegion,omitempty" xml:"CrossBackupRegion,omitempty"`
	// The external URL from which you can download the cross-region log backup file.
	CrossDownloadLink *string `json:"CrossDownloadLink,omitempty" xml:"CrossDownloadLink,omitempty"`
	// The internal URL from which you can download the cross-region log backup file.
	CrossIntranetDownloadLink *string `json:"CrossIntranetDownloadLink,omitempty" xml:"CrossIntranetDownloadLink,omitempty"`
	// The ID of the cross-region log backup file.
	CrossLogBackupId *int32 `json:"CrossLogBackupId,omitempty" xml:"CrossLogBackupId,omitempty"`
	// The size of the cross-region log backup file. Unit: bytes.
	CrossLogBackupSize *int64 `json:"CrossLogBackupSize,omitempty" xml:"CrossLogBackupSize,omitempty"`
	// The instance ID.
	InstanceId *int32 `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The time when the URL expires. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	LinkExpiredTime *string `json:"LinkExpiredTime,omitempty" xml:"LinkExpiredTime,omitempty"`
	// The start time of the cross-region log backup file. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	LogBeginTime *string `json:"LogBeginTime,omitempty" xml:"LogBeginTime,omitempty"`
	// The end time of the cross-region log backup file. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	LogEndTime *string `json:"LogEndTime,omitempty" xml:"LogEndTime,omitempty"`
	// The name of the cross-region log backup file.
	LogFileName *string `json:"LogFileName,omitempty" xml:"LogFileName,omitempty"`
}

func (s DescribeCrossRegionLogBackupFilesResponseBodyItemsItem) String() string {
	return tea.Prettify(s)
}

func (s DescribeCrossRegionLogBackupFilesResponseBodyItemsItem) GoString() string {
	return s.String()
}

func (s *DescribeCrossRegionLogBackupFilesResponseBodyItemsItem) SetCrossBackupRegion(v string) *DescribeCrossRegionLogBackupFilesResponseBodyItemsItem {
	s.CrossBackupRegion = &v
	return s
}

func (s *DescribeCrossRegionLogBackupFilesResponseBodyItemsItem) SetCrossDownloadLink(v string) *DescribeCrossRegionLogBackupFilesResponseBodyItemsItem {
	s.CrossDownloadLink = &v
	return s
}

func (s *DescribeCrossRegionLogBackupFilesResponseBodyItemsItem) SetCrossIntranetDownloadLink(v string) *DescribeCrossRegionLogBackupFilesResponseBodyItemsItem {
	s.CrossIntranetDownloadLink = &v
	return s
}

func (s *DescribeCrossRegionLogBackupFilesResponseBodyItemsItem) SetCrossLogBackupId(v int32) *DescribeCrossRegionLogBackupFilesResponseBodyItemsItem {
	s.CrossLogBackupId = &v
	return s
}

func (s *DescribeCrossRegionLogBackupFilesResponseBodyItemsItem) SetCrossLogBackupSize(v int64) *DescribeCrossRegionLogBackupFilesResponseBodyItemsItem {
	s.CrossLogBackupSize = &v
	return s
}

func (s *DescribeCrossRegionLogBackupFilesResponseBodyItemsItem) SetInstanceId(v int32) *DescribeCrossRegionLogBackupFilesResponseBodyItemsItem {
	s.InstanceId = &v
	return s
}

func (s *DescribeCrossRegionLogBackupFilesResponseBodyItemsItem) SetLinkExpiredTime(v string) *DescribeCrossRegionLogBackupFilesResponseBodyItemsItem {
	s.LinkExpiredTime = &v
	return s
}

func (s *DescribeCrossRegionLogBackupFilesResponseBodyItemsItem) SetLogBeginTime(v string) *DescribeCrossRegionLogBackupFilesResponseBodyItemsItem {
	s.LogBeginTime = &v
	return s
}

func (s *DescribeCrossRegionLogBackupFilesResponseBodyItemsItem) SetLogEndTime(v string) *DescribeCrossRegionLogBackupFilesResponseBodyItemsItem {
	s.LogEndTime = &v
	return s
}

func (s *DescribeCrossRegionLogBackupFilesResponseBodyItemsItem) SetLogFileName(v string) *DescribeCrossRegionLogBackupFilesResponseBodyItemsItem {
	s.LogFileName = &v
	return s
}

type DescribeCrossRegionLogBackupFilesResponse struct {
	Headers    map[string]*string                             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeCrossRegionLogBackupFilesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeCrossRegionLogBackupFilesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeCrossRegionLogBackupFilesResponse) GoString() string {
	return s.String()
}

func (s *DescribeCrossRegionLogBackupFilesResponse) SetHeaders(v map[string]*string) *DescribeCrossRegionLogBackupFilesResponse {
	s.Headers = v
	return s
}

func (s *DescribeCrossRegionLogBackupFilesResponse) SetStatusCode(v int32) *DescribeCrossRegionLogBackupFilesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeCrossRegionLogBackupFilesResponse) SetBody(v *DescribeCrossRegionLogBackupFilesResponseBody) *DescribeCrossRegionLogBackupFilesResponse {
	s.Body = v
	return s
}

type DescribeCurrentModifyOrderRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the generated token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The instance ID. You can call the [DescribeDBInstances](https://help.aliyun.com/document_detail/26232.htm?spm=a2c4g.11186623.0.0.7cb2e918SkH1L2) operation to query the ID of the instance.
	DbInstanceId *string `json:"DbInstanceId,omitempty" xml:"DbInstanceId,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the instance.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The resource group ID.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeCurrentModifyOrderRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeCurrentModifyOrderRequest) GoString() string {
	return s.String()
}

func (s *DescribeCurrentModifyOrderRequest) SetClientToken(v string) *DescribeCurrentModifyOrderRequest {
	s.ClientToken = &v
	return s
}

func (s *DescribeCurrentModifyOrderRequest) SetDbInstanceId(v string) *DescribeCurrentModifyOrderRequest {
	s.DbInstanceId = &v
	return s
}

func (s *DescribeCurrentModifyOrderRequest) SetOwnerId(v int64) *DescribeCurrentModifyOrderRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeCurrentModifyOrderRequest) SetRegionId(v string) *DescribeCurrentModifyOrderRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeCurrentModifyOrderRequest) SetResourceGroupId(v string) *DescribeCurrentModifyOrderRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeCurrentModifyOrderRequest) SetResourceOwnerAccount(v string) *DescribeCurrentModifyOrderRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeCurrentModifyOrderRequest) SetResourceOwnerId(v int64) *DescribeCurrentModifyOrderRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeCurrentModifyOrderResponseBody struct {
	// The specification change order.
	ModifyOrder []*DescribeCurrentModifyOrderResponseBodyModifyOrder `json:"ModifyOrder,omitempty" xml:"ModifyOrder,omitempty" type:"Repeated"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeCurrentModifyOrderResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeCurrentModifyOrderResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeCurrentModifyOrderResponseBody) SetModifyOrder(v []*DescribeCurrentModifyOrderResponseBodyModifyOrder) *DescribeCurrentModifyOrderResponseBody {
	s.ModifyOrder = v
	return s
}

func (s *DescribeCurrentModifyOrderResponseBody) SetRequestId(v string) *DescribeCurrentModifyOrderResponseBody {
	s.RequestId = &v
	return s
}

type DescribeCurrentModifyOrderResponseBodyModifyOrder struct {
	// The instance family of the instance.
	ClassGroup *string `json:"ClassGroup,omitempty" xml:"ClassGroup,omitempty"`
	// The number of CPU cores that are supported by the instance type. Unit: cores.
	Cpu *string `json:"Cpu,omitempty" xml:"Cpu,omitempty"`
	// The instance ID.
	DbInstanceId *string `json:"DbInstanceId,omitempty" xml:"DbInstanceId,omitempty"`
	// The effective time. Valid values:
	//
	// *   **Immediate**: This is the default value.
	// *   **MaintainTime**: The effective time is within the maintenance window. For more information, see [ModifyDBInstanceMaintainTime](~~610402~~).
	EffectiveTime *string `json:"EffectiveTime,omitempty" xml:"EffectiveTime,omitempty"`
	// The description of the instance.
	Mark *string `json:"Mark,omitempty" xml:"Mark,omitempty"`
	// The memory capacity that is supported by the instance type. Unit: GB.
	MemoryClass *string `json:"MemoryClass,omitempty" xml:"MemoryClass,omitempty"`
	// The status of the task.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The storage capacity of the instance.
	Storage *string `json:"Storage,omitempty" xml:"Storage,omitempty"`
	// The new instance type of the instance. Valid values:
	TargetDBInstanceClass *string `json:"TargetDBInstanceClass,omitempty" xml:"TargetDBInstanceClass,omitempty"`
}

func (s DescribeCurrentModifyOrderResponseBodyModifyOrder) String() string {
	return tea.Prettify(s)
}

func (s DescribeCurrentModifyOrderResponseBodyModifyOrder) GoString() string {
	return s.String()
}

func (s *DescribeCurrentModifyOrderResponseBodyModifyOrder) SetClassGroup(v string) *DescribeCurrentModifyOrderResponseBodyModifyOrder {
	s.ClassGroup = &v
	return s
}

func (s *DescribeCurrentModifyOrderResponseBodyModifyOrder) SetCpu(v string) *DescribeCurrentModifyOrderResponseBodyModifyOrder {
	s.Cpu = &v
	return s
}

func (s *DescribeCurrentModifyOrderResponseBodyModifyOrder) SetDbInstanceId(v string) *DescribeCurrentModifyOrderResponseBodyModifyOrder {
	s.DbInstanceId = &v
	return s
}

func (s *DescribeCurrentModifyOrderResponseBodyModifyOrder) SetEffectiveTime(v string) *DescribeCurrentModifyOrderResponseBodyModifyOrder {
	s.EffectiveTime = &v
	return s
}

func (s *DescribeCurrentModifyOrderResponseBodyModifyOrder) SetMark(v string) *DescribeCurrentModifyOrderResponseBodyModifyOrder {
	s.Mark = &v
	return s
}

func (s *DescribeCurrentModifyOrderResponseBodyModifyOrder) SetMemoryClass(v string) *DescribeCurrentModifyOrderResponseBodyModifyOrder {
	s.MemoryClass = &v
	return s
}

func (s *DescribeCurrentModifyOrderResponseBodyModifyOrder) SetStatus(v string) *DescribeCurrentModifyOrderResponseBodyModifyOrder {
	s.Status = &v
	return s
}

func (s *DescribeCurrentModifyOrderResponseBodyModifyOrder) SetStorage(v string) *DescribeCurrentModifyOrderResponseBodyModifyOrder {
	s.Storage = &v
	return s
}

func (s *DescribeCurrentModifyOrderResponseBodyModifyOrder) SetTargetDBInstanceClass(v string) *DescribeCurrentModifyOrderResponseBodyModifyOrder {
	s.TargetDBInstanceClass = &v
	return s
}

type DescribeCurrentModifyOrderResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeCurrentModifyOrderResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeCurrentModifyOrderResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeCurrentModifyOrderResponse) GoString() string {
	return s.String()
}

func (s *DescribeCurrentModifyOrderResponse) SetHeaders(v map[string]*string) *DescribeCurrentModifyOrderResponse {
	s.Headers = v
	return s
}

func (s *DescribeCurrentModifyOrderResponse) SetStatusCode(v int32) *DescribeCurrentModifyOrderResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeCurrentModifyOrderResponse) SetBody(v *DescribeCurrentModifyOrderResponseBody) *DescribeCurrentModifyOrderResponse {
	s.Body = v
	return s
}

type DescribeCustinsResourceInfoRequest struct {
	// The instance ID. Separate multiple values with commas (,).
	DBInstanceIds *string `json:"DBInstanceIds,omitempty" xml:"DBInstanceIds,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeCustinsResourceInfoRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeCustinsResourceInfoRequest) GoString() string {
	return s.String()
}

func (s *DescribeCustinsResourceInfoRequest) SetDBInstanceIds(v string) *DescribeCustinsResourceInfoRequest {
	s.DBInstanceIds = &v
	return s
}

func (s *DescribeCustinsResourceInfoRequest) SetOwnerId(v int64) *DescribeCustinsResourceInfoRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeCustinsResourceInfoRequest) SetResourceGroupId(v string) *DescribeCustinsResourceInfoRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeCustinsResourceInfoRequest) SetResourceOwnerAccount(v string) *DescribeCustinsResourceInfoRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeCustinsResourceInfoRequest) SetResourceOwnerId(v int64) *DescribeCustinsResourceInfoRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeCustinsResourceInfoResponseBody struct {
	// The data returned.
	Data []*DescribeCustinsResourceInfoResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeCustinsResourceInfoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeCustinsResourceInfoResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeCustinsResourceInfoResponseBody) SetData(v []*DescribeCustinsResourceInfoResponseBodyData) *DescribeCustinsResourceInfoResponseBody {
	s.Data = v
	return s
}

func (s *DescribeCustinsResourceInfoResponseBody) SetRequestId(v string) *DescribeCustinsResourceInfoResponseBody {
	s.RequestId = &v
	return s
}

type DescribeCustinsResourceInfoResponseBodyData struct {
	// Cpu adjustment deadline.
	CpuAdjustDeadline *string `json:"CpuAdjustDeadline,omitempty" xml:"CpuAdjustDeadline,omitempty"`
	// Cpu adjustable maximum ratio.
	CpuAdjustableMaxRatio *string `json:"CpuAdjustableMaxRatio,omitempty" xml:"CpuAdjustableMaxRatio,omitempty"`
	// Maximum CPU usage.
	CpuAdjustableMaxValue *string `json:"CpuAdjustableMaxValue,omitempty" xml:"CpuAdjustableMaxValue,omitempty"`
	// CPU usage rate.
	CpuIncreaseRatio *string `json:"CpuIncreaseRatio,omitempty" xml:"CpuIncreaseRatio,omitempty"`
	// CPU usage rate.
	CpuIncreaseRatioValue *string `json:"CpuIncreaseRatioValue,omitempty" xml:"CpuIncreaseRatioValue,omitempty"`
	// The ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The maximum number of IO requests per second.
	IopsAdjustableMaxValue *string `json:"IopsAdjustableMaxValue,omitempty" xml:"IopsAdjustableMaxValue,omitempty"`
	// Maximum Connection Adjustment Deadline
	MaxConnAdjustDeadline *string `json:"MaxConnAdjustDeadline,omitempty" xml:"MaxConnAdjustDeadline,omitempty"`
	// Maximum number of concurrent connections.
	MaxConnAdjustableMaxValue *string `json:"MaxConnAdjustableMaxValue,omitempty" xml:"MaxConnAdjustableMaxValue,omitempty"`
	// Maximum number of concurrent connections.
	MaxConnIncreaseRatio *string `json:"MaxConnIncreaseRatio,omitempty" xml:"MaxConnIncreaseRatio,omitempty"`
	// Maximum number of concurrent connections.
	MaxConnIncreaseRatioValue *string `json:"MaxConnIncreaseRatioValue,omitempty" xml:"MaxConnIncreaseRatioValue,omitempty"`
	// Maximum iops adjustment deadline.
	MaxIopsAdjustDeadline *string `json:"MaxIopsAdjustDeadline,omitempty" xml:"MaxIopsAdjustDeadline,omitempty"`
	// The maximum number of IO requests per second.
	MaxIopsIncreaseRatio *string `json:"MaxIopsIncreaseRatio,omitempty" xml:"MaxIopsIncreaseRatio,omitempty"`
	// The maximum number of IO requests per second.
	MaxIopsIncreaseRatioValue *string `json:"MaxIopsIncreaseRatioValue,omitempty" xml:"MaxIopsIncreaseRatioValue,omitempty"`
	// Memory adjustable maximum ratio.
	MemAdjustableMaxRatio *string `json:"MemAdjustableMaxRatio,omitempty" xml:"MemAdjustableMaxRatio,omitempty"`
	// The maximum value of the resource to be evaluated.
	MemAdjustableMaxValue *string `json:"MemAdjustableMaxValue,omitempty" xml:"MemAdjustableMaxValue,omitempty"`
	// Memory adjustment deadline.
	MemoryAdjustDeadline *string `json:"MemoryAdjustDeadline,omitempty" xml:"MemoryAdjustDeadline,omitempty"`
	// Memory creation time.
	MemoryIncreaseRatio *string `json:"MemoryIncreaseRatio,omitempty" xml:"MemoryIncreaseRatio,omitempty"`
	// Memory usage.
	MemoryIncreaseRatioValue *string `json:"MemoryIncreaseRatioValue,omitempty" xml:"MemoryIncreaseRatioValue,omitempty"`
	// Number of instance CPUs.
	OriginCpu *string `json:"OriginCpu,omitempty" xml:"OriginCpu,omitempty"`
	// Maximum number of concurrent connections.
	OriginMaxConn *string `json:"OriginMaxConn,omitempty" xml:"OriginMaxConn,omitempty"`
	// The maximum number of IO requests per second.
	OriginMaxIops *string `json:"OriginMaxIops,omitempty" xml:"OriginMaxIops,omitempty"`
	// Actual memory used.
	OriginMemory *string `json:"OriginMemory,omitempty" xml:"OriginMemory,omitempty"`
}

func (s DescribeCustinsResourceInfoResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s DescribeCustinsResourceInfoResponseBodyData) GoString() string {
	return s.String()
}

func (s *DescribeCustinsResourceInfoResponseBodyData) SetCpuAdjustDeadline(v string) *DescribeCustinsResourceInfoResponseBodyData {
	s.CpuAdjustDeadline = &v
	return s
}

func (s *DescribeCustinsResourceInfoResponseBodyData) SetCpuAdjustableMaxRatio(v string) *DescribeCustinsResourceInfoResponseBodyData {
	s.CpuAdjustableMaxRatio = &v
	return s
}

func (s *DescribeCustinsResourceInfoResponseBodyData) SetCpuAdjustableMaxValue(v string) *DescribeCustinsResourceInfoResponseBodyData {
	s.CpuAdjustableMaxValue = &v
	return s
}

func (s *DescribeCustinsResourceInfoResponseBodyData) SetCpuIncreaseRatio(v string) *DescribeCustinsResourceInfoResponseBodyData {
	s.CpuIncreaseRatio = &v
	return s
}

func (s *DescribeCustinsResourceInfoResponseBodyData) SetCpuIncreaseRatioValue(v string) *DescribeCustinsResourceInfoResponseBodyData {
	s.CpuIncreaseRatioValue = &v
	return s
}

func (s *DescribeCustinsResourceInfoResponseBodyData) SetDBInstanceId(v string) *DescribeCustinsResourceInfoResponseBodyData {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeCustinsResourceInfoResponseBodyData) SetIopsAdjustableMaxValue(v string) *DescribeCustinsResourceInfoResponseBodyData {
	s.IopsAdjustableMaxValue = &v
	return s
}

func (s *DescribeCustinsResourceInfoResponseBodyData) SetMaxConnAdjustDeadline(v string) *DescribeCustinsResourceInfoResponseBodyData {
	s.MaxConnAdjustDeadline = &v
	return s
}

func (s *DescribeCustinsResourceInfoResponseBodyData) SetMaxConnAdjustableMaxValue(v string) *DescribeCustinsResourceInfoResponseBodyData {
	s.MaxConnAdjustableMaxValue = &v
	return s
}

func (s *DescribeCustinsResourceInfoResponseBodyData) SetMaxConnIncreaseRatio(v string) *DescribeCustinsResourceInfoResponseBodyData {
	s.MaxConnIncreaseRatio = &v
	return s
}

func (s *DescribeCustinsResourceInfoResponseBodyData) SetMaxConnIncreaseRatioValue(v string) *DescribeCustinsResourceInfoResponseBodyData {
	s.MaxConnIncreaseRatioValue = &v
	return s
}

func (s *DescribeCustinsResourceInfoResponseBodyData) SetMaxIopsAdjustDeadline(v string) *DescribeCustinsResourceInfoResponseBodyData {
	s.MaxIopsAdjustDeadline = &v
	return s
}

func (s *DescribeCustinsResourceInfoResponseBodyData) SetMaxIopsIncreaseRatio(v string) *DescribeCustinsResourceInfoResponseBodyData {
	s.MaxIopsIncreaseRatio = &v
	return s
}

func (s *DescribeCustinsResourceInfoResponseBodyData) SetMaxIopsIncreaseRatioValue(v string) *DescribeCustinsResourceInfoResponseBodyData {
	s.MaxIopsIncreaseRatioValue = &v
	return s
}

func (s *DescribeCustinsResourceInfoResponseBodyData) SetMemAdjustableMaxRatio(v string) *DescribeCustinsResourceInfoResponseBodyData {
	s.MemAdjustableMaxRatio = &v
	return s
}

func (s *DescribeCustinsResourceInfoResponseBodyData) SetMemAdjustableMaxValue(v string) *DescribeCustinsResourceInfoResponseBodyData {
	s.MemAdjustableMaxValue = &v
	return s
}

func (s *DescribeCustinsResourceInfoResponseBodyData) SetMemoryAdjustDeadline(v string) *DescribeCustinsResourceInfoResponseBodyData {
	s.MemoryAdjustDeadline = &v
	return s
}

func (s *DescribeCustinsResourceInfoResponseBodyData) SetMemoryIncreaseRatio(v string) *DescribeCustinsResourceInfoResponseBodyData {
	s.MemoryIncreaseRatio = &v
	return s
}

func (s *DescribeCustinsResourceInfoResponseBodyData) SetMemoryIncreaseRatioValue(v string) *DescribeCustinsResourceInfoResponseBodyData {
	s.MemoryIncreaseRatioValue = &v
	return s
}

func (s *DescribeCustinsResourceInfoResponseBodyData) SetOriginCpu(v string) *DescribeCustinsResourceInfoResponseBodyData {
	s.OriginCpu = &v
	return s
}

func (s *DescribeCustinsResourceInfoResponseBodyData) SetOriginMaxConn(v string) *DescribeCustinsResourceInfoResponseBodyData {
	s.OriginMaxConn = &v
	return s
}

func (s *DescribeCustinsResourceInfoResponseBodyData) SetOriginMaxIops(v string) *DescribeCustinsResourceInfoResponseBodyData {
	s.OriginMaxIops = &v
	return s
}

func (s *DescribeCustinsResourceInfoResponseBodyData) SetOriginMemory(v string) *DescribeCustinsResourceInfoResponseBodyData {
	s.OriginMemory = &v
	return s
}

type DescribeCustinsResourceInfoResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeCustinsResourceInfoResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeCustinsResourceInfoResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeCustinsResourceInfoResponse) GoString() string {
	return s.String()
}

func (s *DescribeCustinsResourceInfoResponse) SetHeaders(v map[string]*string) *DescribeCustinsResourceInfoResponse {
	s.Headers = v
	return s
}

func (s *DescribeCustinsResourceInfoResponse) SetStatusCode(v int32) *DescribeCustinsResourceInfoResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeCustinsResourceInfoResponse) SetBody(v *DescribeCustinsResourceInfoResponseBody) *DescribeCustinsResourceInfoResponse {
	s.Body = v
	return s
}

type DescribeDBInstanceAttributeRequest struct {
	// The instance ID. You can call the [DescribeDBInstances](~~610396~~) operation to query the ID of the instance.
	//
	// **
	//
	// **Warning**: Do not query the details of multiple instances at a time by using multiple instance IDs. Otherwise, the query times out and fails.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// Specifies whether the instance expires. Valid values:
	//
	// *   **True**: The instance expires.
	// *   **False:** The instance does not expire.
	Expired         *string `json:"Expired,omitempty" xml:"Expired,omitempty"`
	ResourceOwnerId *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeDBInstanceAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceAttributeRequest) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceAttributeRequest) SetDBInstanceId(v string) *DescribeDBInstanceAttributeRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeDBInstanceAttributeRequest) SetExpired(v string) *DescribeDBInstanceAttributeRequest {
	s.Expired = &v
	return s
}

func (s *DescribeDBInstanceAttributeRequest) SetResourceOwnerId(v int64) *DescribeDBInstanceAttributeRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeDBInstanceAttributeResponseBody struct {
	// An array that consists of the details about the instance.
	Items *DescribeDBInstanceAttributeResponseBodyItems `json:"Items,omitempty" xml:"Items,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDBInstanceAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceAttributeResponseBody) SetItems(v *DescribeDBInstanceAttributeResponseBodyItems) *DescribeDBInstanceAttributeResponseBody {
	s.Items = v
	return s
}

func (s *DescribeDBInstanceAttributeResponseBody) SetRequestId(v string) *DescribeDBInstanceAttributeResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDBInstanceAttributeResponseBodyItems struct {
	DBInstanceAttribute []*DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute `json:"DBInstanceAttribute,omitempty" xml:"DBInstanceAttribute,omitempty" type:"Repeated"`
}

func (s DescribeDBInstanceAttributeResponseBodyItems) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceAttributeResponseBodyItems) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceAttributeResponseBodyItems) SetDBInstanceAttribute(v []*DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute) *DescribeDBInstanceAttributeResponseBodyItems {
	s.DBInstanceAttribute = v
	return s
}

type DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute struct {
	// The maximum number of accounts that can be created on the instance.
	AccountMaxQuantity *int32 `json:"AccountMaxQuantity,omitempty" xml:"AccountMaxQuantity,omitempty"`
	// The advanced features that are enabled for the instance. If multiple advanced features are enabled, the advanced features are separated by commas (,). This parameter is available only to instances that run **SQL Server**. Valid values:
	//
	// *   **LinkedServer**
	// *   **DistributeTransaction**
	AdvancedFeatures *string `json:"AdvancedFeatures,omitempty" xml:"AdvancedFeatures,omitempty"`
	// The method that is used to update the minor engine version of the instance. Valid values:
	//
	// *   **Auto:** automatic update.
	// *   **Manual**: manual update. The minor engine version of the instance is forcefully updated only when the in-use minor engine version is phased out.
	AutoUpgradeMinorVersion *string `json:"AutoUpgradeMinorVersion,omitempty" xml:"AutoUpgradeMinorVersion,omitempty"`
	// The availability status of the instance in percentage.
	AvailabilityValue *string `json:"AvailabilityValue,omitempty" xml:"AvailabilityValue,omitempty"`
	// The configuration of the Babelfish feature for the ApsaraDB RDS for PostgreSQL instance.
	//
	// >  This parameter is suitable only for ApsaraDB RDS for PostgreSQL instances for which Babelfish is enabled. For more information, see Introduction to Babelfish.[](~~428613~~)
	BabelfishConfig *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeBabelfishConfig `json:"BabelfishConfig,omitempty" xml:"BabelfishConfig,omitempty" type:"Struct"`
	// This parameter is invalid. You do not need to specify this parameter.
	BpeEnabled *string `json:"BpeEnabled,omitempty" xml:"BpeEnabled,omitempty"`
	// This parameter is invalid. You do not need to specify this parameter.
	BurstingEnabled *bool `json:"BurstingEnabled,omitempty" xml:"BurstingEnabled,omitempty"`
	// The RDS edition of the instance. Valid values:
	//
	// *   **Basic**: RDS Basic Edition
	// *   **HighAvailability**: RDS High-availability Edition
	// *   **cluster**: RDS Cluster Edition for ApsaraDB RDS for MySQL
	// *   **AlwaysOn**: RDS Cluster Edition for ApsaraDB RDS for SQL Server
	// *   **Finance**: RDS Enterprise Edition
	// *   **Serverless_basic**: RDS Basic Edition for serverless instances
	Category *string `json:"Category,omitempty" xml:"Category,omitempty"`
	// The character set collation of the instance.
	Collation *string `json:"Collation,omitempty" xml:"Collation,omitempty"`
	// The connection mode of the instance. Valid values:
	//
	// *   **Standard**: standard mode
	// *   **Safe**: database proxy mode
	ConnectionMode *string `json:"ConnectionMode,omitempty" xml:"ConnectionMode,omitempty"`
	// The internal endpoint of the instance.
	ConnectionString *string `json:"ConnectionString,omitempty" xml:"ConnectionString,omitempty"`
	// The type of the proxy that is used by the instance. Valid values:
	//
	// *   **1**: shared proxy
	// *   **2**: dedicated proxy
	//
	// >  We recommend that you use the ProxyType parameter instead of this parameter.
	ConsoleVersion *string `json:"ConsoleVersion,omitempty" xml:"ConsoleVersion,omitempty"`
	// The creation time. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The minor engine version of the instance.
	CurrentKernelVersion *string `json:"CurrentKernelVersion,omitempty" xml:"CurrentKernelVersion,omitempty"`
	// The information about the node in the cluster.
	DBClusterNodes *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeDBClusterNodes `json:"DBClusterNodes,omitempty" xml:"DBClusterNodes,omitempty" type:"Struct"`
	// The number of CPU cores.
	DBInstanceCPU *string `json:"DBInstanceCPU,omitempty" xml:"DBInstanceCPU,omitempty"`
	// The instance type of the instance. For more information, see [Primary ApsaraDB RDS instance types](~~26312~~).
	DBInstanceClass *string `json:"DBInstanceClass,omitempty" xml:"DBInstanceClass,omitempty"`
	// The instance family to which the instance belongs. Valid values:
	//
	// *   **s**: shared instance family
	// *   **x**: general-purpose instance family
	// *   **d**: dedicated instance family
	// *   **h**: dedicated host instance family
	DBInstanceClassType *string `json:"DBInstanceClassType,omitempty" xml:"DBInstanceClassType,omitempty"`
	// The description of the instance.
	DBInstanceDescription *string `json:"DBInstanceDescription,omitempty" xml:"DBInstanceDescription,omitempty"`
	DBInstanceDiskUsed    *string `json:"DBInstanceDiskUsed,omitempty" xml:"DBInstanceDiskUsed,omitempty"`
	// The instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The memory capacity of the instance. Unit: MB.
	DBInstanceMemory *int64 `json:"DBInstanceMemory,omitempty" xml:"DBInstanceMemory,omitempty"`
	// The type of the network over which the instance is connected. Valid values:
	//
	// *   **Internet**: Internet
	// *   **Intranet**: internal network
	DBInstanceNetType *string `json:"DBInstanceNetType,omitempty" xml:"DBInstanceNetType,omitempty"`
	// The status of the instance. For more information, see [Instance states](~~26315~~).
	DBInstanceStatus *string `json:"DBInstanceStatus,omitempty" xml:"DBInstanceStatus,omitempty"`
	// The storage capacity of the instance. Unit: GB.
	DBInstanceStorage *int32 `json:"DBInstanceStorage,omitempty" xml:"DBInstanceStorage,omitempty"`
	// The storage type of the instance. Valid values:
	//
	// *   **local_ssd** and **ephemeral_ssd**: local SSD
	// *   **cloud_ssd**: standard SSD
	// *   **cloud_essd**: enhanced SSD (ESSD)
	DBInstanceStorageType *string `json:"DBInstanceStorageType,omitempty" xml:"DBInstanceStorageType,omitempty"`
	// The type of the instance. Valid values:
	//
	// *   **Primary**: primary instance
	// *   **Readonly**: read-only instance
	// *   **Guard**: disaster recovery instance
	// *   **Temp**: temporary instance
	DBInstanceType *string `json:"DBInstanceType,omitempty" xml:"DBInstanceType,omitempty"`
	// The maximum number of databases that can be created on the instance.
	DBMaxQuantity *int32 `json:"DBMaxQuantity,omitempty" xml:"DBMaxQuantity,omitempty"`
	// The ID of the dedicated cluster.
	DedicatedHostGroupId *string `json:"DedicatedHostGroupId,omitempty" xml:"DedicatedHostGroupId,omitempty"`
	// Indicates whether the release protection feature is enabled. Valid values:
	//
	// *   **true**
	// *   **false**
	DeletionProtection *bool `json:"DeletionProtection,omitempty" xml:"DeletionProtection,omitempty"`
	// The database engine of the instance. Valid values:
	//
	// *   **MySQL**
	// *   **PostgreSQL**
	// *   **SQLServer**
	// *   **MariaDB**
	Engine *string `json:"Engine,omitempty" xml:"Engine,omitempty"`
	// The database engine version.
	EngineVersion *string `json:"EngineVersion,omitempty" xml:"EngineVersion,omitempty"`
	// The expiration time. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// >  Pay-as-you-go instances never expire.
	ExpireTime *string `json:"ExpireTime,omitempty" xml:"ExpireTime,omitempty"`
	// The extended information of the instance.
	Extra *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeExtra `json:"Extra,omitempty" xml:"Extra,omitempty" type:"Struct"`
	// The name of the dedicated cluster to which the instance belongs. This parameter is returned only when the instance is created in an ApsaraDB MyBase cluster that runs MySQL on Standard Edition.
	GeneralGroupName *string `json:"GeneralGroupName,omitempty" xml:"GeneralGroupName,omitempty"`
	// The ID of the disaster recovery instance that is attached to the instance.
	GuardDBInstanceId *string `json:"GuardDBInstanceId,omitempty" xml:"GuardDBInstanceId,omitempty"`
	// The type of the IP address. Only **IPv4** addresses are supported.
	IPType *string `json:"IPType,omitempty" xml:"IPType,omitempty"`
	// The ID of the instance from which incremental data comes. The incremental data of a disaster recovery instance or read-only instance comes from its primary instance. If this parameter is not returned, the instance is a primary instance.
	IncrementSourceDBInstanceId *string `json:"IncrementSourceDBInstanceId,omitempty" xml:"IncrementSourceDBInstanceId,omitempty"`
	// The network type of the instance. Valid values:
	//
	// *   **Classic**
	// *   **VPC**
	InstanceNetworkType *string `json:"InstanceNetworkType,omitempty" xml:"InstanceNetworkType,omitempty"`
	// The architecture type of the instance. Valid values:
	//
	// *   **x86**
	// *   **arm**
	InstructionSetArch *string `json:"InstructionSetArch,omitempty" xml:"InstructionSetArch,omitempty"`
	// The latest minor engine version that is supported by the instance.
	LatestKernelVersion *string `json:"LatestKernelVersion,omitempty" xml:"LatestKernelVersion,omitempty"`
	// The lock mode of the instance. Valid values:
	//
	// *   **Unlock**: The instance is not locked.
	// *   **ManualLock**: The instance is manually locked.
	// *   **LockByExpiration**: The instance is automatically locked due to instance expiration.
	// *   **LockByRestoration**: The instance is automatically locked due to instance restoration.
	// *   **LockByDiskQuota**: The instance is automatically locked due to exhausted storage space.
	// *   **LockReadInstanceByDiskQuota**: The instance is a read-only instance and is automatically locked due to exhausted storage.
	LockMode *string `json:"LockMode,omitempty" xml:"LockMode,omitempty"`
	// The reason why the instance was locked.
	LockReason *string `json:"LockReason,omitempty" xml:"LockReason,omitempty"`
	// The maintenance window of the instance. The time is displayed in UTC. Take note that the maintenance window displayed in the ApsaraDB RDS console is equal to the value of this parameter plus 8 hours.
	MaintainTime *string `json:"MaintainTime,omitempty" xml:"MaintainTime,omitempty"`
	// The ID of the primary instance.
	//
	// >  If this parameter is not returned, the instance is the primary instance.
	MasterInstanceId *string `json:"MasterInstanceId,omitempty" xml:"MasterInstanceId,omitempty"`
	// The zone ID of the primary instance.
	MasterZone *string `json:"MasterZone,omitempty" xml:"MasterZone,omitempty"`
	// The maximum number of concurrent connections.
	MaxConnections *int32 `json:"MaxConnections,omitempty" xml:"MaxConnections,omitempty"`
	// The maximum I/O throughput. Unit: MB/s.
	MaxIOMBPS *int32 `json:"MaxIOMBPS,omitempty" xml:"MaxIOMBPS,omitempty"`
	// The maximum number of I/O requests per second.
	MaxIOPS *int32 `json:"MaxIOPS,omitempty" xml:"MaxIOPS,omitempty"`
	// Indicates whether PgBouncer is enabled.
	//
	// >  This parameter is returned only for RDS instances that run PostgreSQL. If PgBouncer is enabled, the return value is **true**.
	PGBouncerEnabled *string `json:"PGBouncerEnabled,omitempty" xml:"PGBouncerEnabled,omitempty"`
	// The billing method of the instance. Valid values:
	//
	// *   **Postpaid**: pay-as-you-go
	// *   **Prepaid**: subscription
	PayType *string `json:"PayType,omitempty" xml:"PayType,omitempty"`
	// The port that is used to connect to the instance over an internal network.
	Port *string `json:"Port,omitempty" xml:"Port,omitempty"`
	// The type of the proxy that is supported by the instance. Valid values:
	//
	// *   **0**: The instance does not support database proxies.
	// *   **1**: The instance supports shared proxies, with which the instance runs in multi-tenant mode.
	// *   **2**: The instance supports dedicated proxies, with which the instance runs in single-tenant mode.
	ProxyType *int32 `json:"ProxyType,omitempty" xml:"ProxyType,omitempty"`
	// The IDs of the read-only instances that are attached to the primary instance.
	ReadOnlyDBInstanceIds *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeReadOnlyDBInstanceIds `json:"ReadOnlyDBInstanceIds,omitempty" xml:"ReadOnlyDBInstanceIds,omitempty" type:"Struct"`
	// The latency at which the system replicates data to read-only instances. The system replicates data from the primary instance to the read-only instances at the latency that is specified by the **ReadonlyInstanceSQLDelayedTime** parameter. Unit: seconds.
	ReadonlyInstanceSQLDelayedTime *string `json:"ReadonlyInstanceSQLDelayedTime,omitempty" xml:"ReadonlyInstanceSQLDelayedTime,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The resource group ID.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The IP addresses in the IP address whitelist.
	SecurityIPList *string `json:"SecurityIPList,omitempty" xml:"SecurityIPList,omitempty"`
	// The whitelist mode of the instance. Valid values:
	//
	// *   **normal**: standard whitelist mode
	// *   **safety**: enhanced whitelist mode
	SecurityIPMode *string `json:"SecurityIPMode,omitempty" xml:"SecurityIPMode,omitempty"`
	// The settings of the serverless instance.
	ServerlessConfig *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeServerlessConfig `json:"ServerlessConfig,omitempty" xml:"ServerlessConfig,omitempty" type:"Struct"`
	// The information about the zone of the secondary instance.
	SlaveZones *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeSlaveZones `json:"SlaveZones,omitempty" xml:"SlaveZones,omitempty" type:"Struct"`
	// Indicates whether the instance supports superuser accounts, such as the system administrator (SA) account, the Active Directory (AD) account, and the host account.
	//
	// *   **Enable**
	// *   **Disabled**
	SuperPermissionMode *string `json:"SuperPermissionMode,omitempty" xml:"SuperPermissionMode,omitempty"`
	// The ID of the temporary instance that is attached to the instance.
	TempDBInstanceId *string `json:"TempDBInstanceId,omitempty" xml:"TempDBInstanceId,omitempty"`
	// The time zone of the instance.
	TimeZone *string `json:"TimeZone,omitempty" xml:"TimeZone,omitempty"`
	// The information about the exception that is detected on the instance. This parameter is returned only when the instance is created in an ApsaraDB MyBase cluster that runs MySQL on Standard Edition.
	Tips *string `json:"Tips,omitempty" xml:"Tips,omitempty"`
	// The severity level of the exception that is detected on the instance. This parameter is returned only when the instance is created in an ApsaraDB MyBase cluster that runs MySQL on Standard Edition. Valid values:
	//
	// *   **1**: The instance is normal.
	// *   **2**: The specifications of the read-only instances do not match the specifications of the primary instance. You must adjust the specifications of these instances based on your business requirements.
	TipsLevel *int32 `json:"TipsLevel,omitempty" xml:"TipsLevel,omitempty"`
	// The vSwitch ID.
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
	// The VPC ID.
	VpcCloudInstanceId *string `json:"VpcCloudInstanceId,omitempty" xml:"VpcCloudInstanceId,omitempty"`
	// The virtual private cloud (VPC) ID of the instance.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
	// The zone ID.
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
	// An internal parameter. You do not need to specify this parameter.
	KindCode *string `json:"kindCode,omitempty" xml:"kindCode,omitempty"`
}

func (s DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute) SetAccountMaxQuantity(v int32) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute {
	s.AccountMaxQuantity = &v
	return s
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute) SetAdvancedFeatures(v string) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute {
	s.AdvancedFeatures = &v
	return s
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute) SetAutoUpgradeMinorVersion(v string) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute {
	s.AutoUpgradeMinorVersion = &v
	return s
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute) SetAvailabilityValue(v string) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute {
	s.AvailabilityValue = &v
	return s
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute) SetBabelfishConfig(v *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeBabelfishConfig) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute {
	s.BabelfishConfig = v
	return s
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute) SetBpeEnabled(v string) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute {
	s.BpeEnabled = &v
	return s
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute) SetBurstingEnabled(v bool) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute {
	s.BurstingEnabled = &v
	return s
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute) SetCategory(v string) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute {
	s.Category = &v
	return s
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute) SetCollation(v string) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute {
	s.Collation = &v
	return s
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute) SetConnectionMode(v string) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute {
	s.ConnectionMode = &v
	return s
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute) SetConnectionString(v string) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute {
	s.ConnectionString = &v
	return s
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute) SetConsoleVersion(v string) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute {
	s.ConsoleVersion = &v
	return s
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute) SetCreationTime(v string) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute {
	s.CreationTime = &v
	return s
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute) SetCurrentKernelVersion(v string) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute {
	s.CurrentKernelVersion = &v
	return s
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute) SetDBClusterNodes(v *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeDBClusterNodes) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute {
	s.DBClusterNodes = v
	return s
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute) SetDBInstanceCPU(v string) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute {
	s.DBInstanceCPU = &v
	return s
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute) SetDBInstanceClass(v string) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute {
	s.DBInstanceClass = &v
	return s
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute) SetDBInstanceClassType(v string) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute {
	s.DBInstanceClassType = &v
	return s
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute) SetDBInstanceDescription(v string) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute {
	s.DBInstanceDescription = &v
	return s
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute) SetDBInstanceDiskUsed(v string) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute {
	s.DBInstanceDiskUsed = &v
	return s
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute) SetDBInstanceId(v string) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute) SetDBInstanceMemory(v int64) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute {
	s.DBInstanceMemory = &v
	return s
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute) SetDBInstanceNetType(v string) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute {
	s.DBInstanceNetType = &v
	return s
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute) SetDBInstanceStatus(v string) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute {
	s.DBInstanceStatus = &v
	return s
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute) SetDBInstanceStorage(v int32) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute {
	s.DBInstanceStorage = &v
	return s
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute) SetDBInstanceStorageType(v string) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute {
	s.DBInstanceStorageType = &v
	return s
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute) SetDBInstanceType(v string) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute {
	s.DBInstanceType = &v
	return s
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute) SetDBMaxQuantity(v int32) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute {
	s.DBMaxQuantity = &v
	return s
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute) SetDedicatedHostGroupId(v string) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute {
	s.DedicatedHostGroupId = &v
	return s
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute) SetDeletionProtection(v bool) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute {
	s.DeletionProtection = &v
	return s
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute) SetEngine(v string) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute {
	s.Engine = &v
	return s
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute) SetEngineVersion(v string) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute {
	s.EngineVersion = &v
	return s
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute) SetExpireTime(v string) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute {
	s.ExpireTime = &v
	return s
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute) SetExtra(v *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeExtra) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute {
	s.Extra = v
	return s
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute) SetGeneralGroupName(v string) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute {
	s.GeneralGroupName = &v
	return s
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute) SetGuardDBInstanceId(v string) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute {
	s.GuardDBInstanceId = &v
	return s
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute) SetIPType(v string) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute {
	s.IPType = &v
	return s
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute) SetIncrementSourceDBInstanceId(v string) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute {
	s.IncrementSourceDBInstanceId = &v
	return s
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute) SetInstanceNetworkType(v string) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute {
	s.InstanceNetworkType = &v
	return s
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute) SetInstructionSetArch(v string) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute {
	s.InstructionSetArch = &v
	return s
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute) SetLatestKernelVersion(v string) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute {
	s.LatestKernelVersion = &v
	return s
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute) SetLockMode(v string) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute {
	s.LockMode = &v
	return s
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute) SetLockReason(v string) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute {
	s.LockReason = &v
	return s
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute) SetMaintainTime(v string) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute {
	s.MaintainTime = &v
	return s
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute) SetMasterInstanceId(v string) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute {
	s.MasterInstanceId = &v
	return s
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute) SetMasterZone(v string) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute {
	s.MasterZone = &v
	return s
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute) SetMaxConnections(v int32) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute {
	s.MaxConnections = &v
	return s
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute) SetMaxIOMBPS(v int32) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute {
	s.MaxIOMBPS = &v
	return s
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute) SetMaxIOPS(v int32) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute {
	s.MaxIOPS = &v
	return s
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute) SetPGBouncerEnabled(v string) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute {
	s.PGBouncerEnabled = &v
	return s
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute) SetPayType(v string) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute {
	s.PayType = &v
	return s
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute) SetPort(v string) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute {
	s.Port = &v
	return s
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute) SetProxyType(v int32) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute {
	s.ProxyType = &v
	return s
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute) SetReadOnlyDBInstanceIds(v *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeReadOnlyDBInstanceIds) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute {
	s.ReadOnlyDBInstanceIds = v
	return s
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute) SetReadonlyInstanceSQLDelayedTime(v string) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute {
	s.ReadonlyInstanceSQLDelayedTime = &v
	return s
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute) SetRegionId(v string) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute {
	s.RegionId = &v
	return s
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute) SetResourceGroupId(v string) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute) SetSecurityIPList(v string) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute {
	s.SecurityIPList = &v
	return s
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute) SetSecurityIPMode(v string) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute {
	s.SecurityIPMode = &v
	return s
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute) SetServerlessConfig(v *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeServerlessConfig) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute {
	s.ServerlessConfig = v
	return s
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute) SetSlaveZones(v *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeSlaveZones) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute {
	s.SlaveZones = v
	return s
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute) SetSuperPermissionMode(v string) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute {
	s.SuperPermissionMode = &v
	return s
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute) SetTempDBInstanceId(v string) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute {
	s.TempDBInstanceId = &v
	return s
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute) SetTimeZone(v string) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute {
	s.TimeZone = &v
	return s
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute) SetTips(v string) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute {
	s.Tips = &v
	return s
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute) SetTipsLevel(v int32) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute {
	s.TipsLevel = &v
	return s
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute) SetVSwitchId(v string) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute {
	s.VSwitchId = &v
	return s
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute) SetVpcCloudInstanceId(v string) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute {
	s.VpcCloudInstanceId = &v
	return s
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute) SetVpcId(v string) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute {
	s.VpcId = &v
	return s
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute) SetZoneId(v string) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute {
	s.ZoneId = &v
	return s
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute) SetKindCode(v string) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute {
	s.KindCode = &v
	return s
}

type DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeBabelfishConfig struct {
	// Indicates whether Babelfish is enabled.
	//
	// >  If Babelfish is enabled when you purchase an ApsaraDB RDS for PostgreSQL instance, this parameter is fixed as **true**.
	BabelfishEnabled *string `json:"BabelfishEnabled,omitempty" xml:"BabelfishEnabled,omitempty"`
	// The migration mode for Babelfish. Valid values:
	//
	// *   **single-db**
	// *   **multi-db**
	//
	// >  For more information about migration modes for Babelfish, see [Migration modes](~~428613~~).
	MigrationMode *string `json:"MigrationMode,omitempty" xml:"MigrationMode,omitempty"`
}

func (s DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeBabelfishConfig) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeBabelfishConfig) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeBabelfishConfig) SetBabelfishEnabled(v string) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeBabelfishConfig {
	s.BabelfishEnabled = &v
	return s
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeBabelfishConfig) SetMigrationMode(v string) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeBabelfishConfig {
	s.MigrationMode = &v
	return s
}

type DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeDBClusterNodes struct {
	DBClusterNode []*DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeDBClusterNodesDBClusterNode `json:"DBClusterNode,omitempty" xml:"DBClusterNode,omitempty" type:"Repeated"`
}

func (s DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeDBClusterNodes) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeDBClusterNodes) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeDBClusterNodes) SetDBClusterNode(v []*DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeDBClusterNodesDBClusterNode) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeDBClusterNodes {
	s.DBClusterNode = v
	return s
}

type DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeDBClusterNodesDBClusterNode struct {
	// The specification of the node.
	ClassCode *string `json:"ClassCode,omitempty" xml:"ClassCode,omitempty"`
	// Node specification type. Value range:
	//
	// - d: Exclusive specifications
	// - x: General specifications
	ClassType *string `json:"ClassType,omitempty" xml:"ClassType,omitempty"`
	// The number of vCPUs that you want to allocate to the elastic container instance. Unit: cores.
	Cpu *string `json:"Cpu,omitempty" xml:"Cpu,omitempty"`
	// The memory size that you applied for each instance. Unit: MB.
	Memory *string `json:"Memory,omitempty" xml:"Memory,omitempty"`
	// The node ID.
	NodeId *string `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	// The region ID.
	NodeRegionId *string `json:"NodeRegionId,omitempty" xml:"NodeRegionId,omitempty"`
	// The role of the node. Valid values:
	//
	// *   **primary**: primary node
	// *   **secondary**: secondary node
	NodeRole *string `json:"NodeRole,omitempty" xml:"NodeRole,omitempty"`
	// The zone ID.
	NodeZoneId *string `json:"NodeZoneId,omitempty" xml:"NodeZoneId,omitempty"`
	// The status of the migration task. Valid values:
	// - active
	// - creating
	// - deleting
	// - classchanging
	// - restarting
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeDBClusterNodesDBClusterNode) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeDBClusterNodesDBClusterNode) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeDBClusterNodesDBClusterNode) SetClassCode(v string) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeDBClusterNodesDBClusterNode {
	s.ClassCode = &v
	return s
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeDBClusterNodesDBClusterNode) SetClassType(v string) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeDBClusterNodesDBClusterNode {
	s.ClassType = &v
	return s
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeDBClusterNodesDBClusterNode) SetCpu(v string) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeDBClusterNodesDBClusterNode {
	s.Cpu = &v
	return s
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeDBClusterNodesDBClusterNode) SetMemory(v string) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeDBClusterNodesDBClusterNode {
	s.Memory = &v
	return s
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeDBClusterNodesDBClusterNode) SetNodeId(v string) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeDBClusterNodesDBClusterNode {
	s.NodeId = &v
	return s
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeDBClusterNodesDBClusterNode) SetNodeRegionId(v string) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeDBClusterNodesDBClusterNode {
	s.NodeRegionId = &v
	return s
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeDBClusterNodesDBClusterNode) SetNodeRole(v string) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeDBClusterNodesDBClusterNode {
	s.NodeRole = &v
	return s
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeDBClusterNodesDBClusterNode) SetNodeZoneId(v string) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeDBClusterNodesDBClusterNode {
	s.NodeZoneId = &v
	return s
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeDBClusterNodesDBClusterNode) SetStatus(v string) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeDBClusterNodesDBClusterNode {
	s.Status = &v
	return s
}

type DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeExtra struct {
	// The IDs of the instances.
	DBInstanceIds *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeExtraDBInstanceIds `json:"DBInstanceIds,omitempty" xml:"DBInstanceIds,omitempty" type:"Struct"`
}

func (s DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeExtra) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeExtra) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeExtra) SetDBInstanceIds(v *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeExtraDBInstanceIds) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeExtra {
	s.DBInstanceIds = v
	return s
}

type DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeExtraDBInstanceIds struct {
	DBInstanceId []*string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty" type:"Repeated"`
}

func (s DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeExtraDBInstanceIds) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeExtraDBInstanceIds) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeExtraDBInstanceIds) SetDBInstanceId(v []*string) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeExtraDBInstanceIds {
	s.DBInstanceId = v
	return s
}

type DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeReadOnlyDBInstanceIds struct {
	ReadOnlyDBInstanceId []*DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeReadOnlyDBInstanceIdsReadOnlyDBInstanceId `json:"ReadOnlyDBInstanceId,omitempty" xml:"ReadOnlyDBInstanceId,omitempty" type:"Repeated"`
}

func (s DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeReadOnlyDBInstanceIds) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeReadOnlyDBInstanceIds) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeReadOnlyDBInstanceIds) SetReadOnlyDBInstanceId(v []*DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeReadOnlyDBInstanceIdsReadOnlyDBInstanceId) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeReadOnlyDBInstanceIds {
	s.ReadOnlyDBInstanceId = v
	return s
}

type DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeReadOnlyDBInstanceIdsReadOnlyDBInstanceId struct {
	// The ID of the read-only instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
}

func (s DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeReadOnlyDBInstanceIdsReadOnlyDBInstanceId) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeReadOnlyDBInstanceIdsReadOnlyDBInstanceId) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeReadOnlyDBInstanceIdsReadOnlyDBInstanceId) SetDBInstanceId(v string) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeReadOnlyDBInstanceIdsReadOnlyDBInstanceId {
	s.DBInstanceId = &v
	return s
}

type DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeServerlessConfig struct {
	// Indicates whether the automatic start and stop feature is enabled for the serverless instance. Valid values:
	//
	// *   **true**
	// *   **false** (default)
	//
	// >  After the automatic start and stop feature is enabled, if no connections to the instance are established within 10 minutes, the instance is suspended. After a connection to the instance is established, the instance is automatically resumed.
	AutoPause *bool `json:"AutoPause,omitempty" xml:"AutoPause,omitempty"`
	// The maximum number of RCUs.
	ScaleMax *float64 `json:"ScaleMax,omitempty" xml:"ScaleMax,omitempty"`
	// The minimum number of RDS Capacity Units (RCUs).
	ScaleMin *float64 `json:"ScaleMin,omitempty" xml:"ScaleMin,omitempty"`
	// Indicates whether the forced scaling feature is enabled for the serverless instance.
	//
	// *   **true**
	// *   **false** (default)
	//
	// >  In most cases, ApsaraDB RDS automatically scales in or out the RCUs of a serverless instance based on business requirements in real time. In rare cases, the scaling does not take effect in real time. You can enable the forced scaling feature to forcefully scales in or out the RCUs of the instance.
	SwitchForce *bool `json:"SwitchForce,omitempty" xml:"SwitchForce,omitempty"`
}

func (s DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeServerlessConfig) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeServerlessConfig) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeServerlessConfig) SetAutoPause(v bool) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeServerlessConfig {
	s.AutoPause = &v
	return s
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeServerlessConfig) SetScaleMax(v float64) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeServerlessConfig {
	s.ScaleMax = &v
	return s
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeServerlessConfig) SetScaleMin(v float64) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeServerlessConfig {
	s.ScaleMin = &v
	return s
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeServerlessConfig) SetSwitchForce(v bool) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeServerlessConfig {
	s.SwitchForce = &v
	return s
}

type DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeSlaveZones struct {
	SlaveZone []*DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeSlaveZonesSlaveZone `json:"SlaveZone,omitempty" xml:"SlaveZone,omitempty" type:"Repeated"`
}

func (s DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeSlaveZones) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeSlaveZones) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeSlaveZones) SetSlaveZone(v []*DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeSlaveZonesSlaveZone) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeSlaveZones {
	s.SlaveZone = v
	return s
}

type DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeSlaveZonesSlaveZone struct {
	// The zone ID.
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
}

func (s DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeSlaveZonesSlaveZone) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeSlaveZonesSlaveZone) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeSlaveZonesSlaveZone) SetZoneId(v string) *DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeSlaveZonesSlaveZone {
	s.ZoneId = &v
	return s
}

type DescribeDBInstanceAttributeResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDBInstanceAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDBInstanceAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceAttributeResponse) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceAttributeResponse) SetHeaders(v map[string]*string) *DescribeDBInstanceAttributeResponse {
	s.Headers = v
	return s
}

func (s *DescribeDBInstanceAttributeResponse) SetStatusCode(v int32) *DescribeDBInstanceAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDBInstanceAttributeResponse) SetBody(v *DescribeDBInstanceAttributeResponseBody) *DescribeDBInstanceAttributeResponse {
	s.Body = v
	return s
}

type DescribeDBInstanceByTagsRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The instance ID. You can call the [DescribeDBInstances](~~26232~~) operation to query the instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The page number. Pages start from page 1.
	//
	// Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries per page. Valid values: **30 to 100**. Default value: **30**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the region. You can call the [DescribeRegions](~~26243~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// A deprecated parameter.
	ProxyId *string `json:"proxyId,omitempty" xml:"proxyId,omitempty"`
}

func (s DescribeDBInstanceByTagsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceByTagsRequest) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceByTagsRequest) SetClientToken(v string) *DescribeDBInstanceByTagsRequest {
	s.ClientToken = &v
	return s
}

func (s *DescribeDBInstanceByTagsRequest) SetDBInstanceId(v string) *DescribeDBInstanceByTagsRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeDBInstanceByTagsRequest) SetOwnerAccount(v string) *DescribeDBInstanceByTagsRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeDBInstanceByTagsRequest) SetOwnerId(v int64) *DescribeDBInstanceByTagsRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeDBInstanceByTagsRequest) SetPageNumber(v int32) *DescribeDBInstanceByTagsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeDBInstanceByTagsRequest) SetPageSize(v int32) *DescribeDBInstanceByTagsRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeDBInstanceByTagsRequest) SetRegionId(v string) *DescribeDBInstanceByTagsRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeDBInstanceByTagsRequest) SetResourceOwnerAccount(v string) *DescribeDBInstanceByTagsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeDBInstanceByTagsRequest) SetResourceOwnerId(v int64) *DescribeDBInstanceByTagsRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeDBInstanceByTagsRequest) SetProxyId(v string) *DescribeDBInstanceByTagsRequest {
	s.ProxyId = &v
	return s
}

type DescribeDBInstanceByTagsResponseBody struct {
	// The details about the instance.
	Items *DescribeDBInstanceByTagsResponseBodyItems `json:"Items,omitempty" xml:"Items,omitempty" type:"Struct"`
	// The page number.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries per page.
	PageRecordCount *int32 `json:"PageRecordCount,omitempty" xml:"PageRecordCount,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalRecordCount *int32 `json:"TotalRecordCount,omitempty" xml:"TotalRecordCount,omitempty"`
}

func (s DescribeDBInstanceByTagsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceByTagsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceByTagsResponseBody) SetItems(v *DescribeDBInstanceByTagsResponseBodyItems) *DescribeDBInstanceByTagsResponseBody {
	s.Items = v
	return s
}

func (s *DescribeDBInstanceByTagsResponseBody) SetPageNumber(v int32) *DescribeDBInstanceByTagsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeDBInstanceByTagsResponseBody) SetPageRecordCount(v int32) *DescribeDBInstanceByTagsResponseBody {
	s.PageRecordCount = &v
	return s
}

func (s *DescribeDBInstanceByTagsResponseBody) SetRequestId(v string) *DescribeDBInstanceByTagsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDBInstanceByTagsResponseBody) SetTotalRecordCount(v int32) *DescribeDBInstanceByTagsResponseBody {
	s.TotalRecordCount = &v
	return s
}

type DescribeDBInstanceByTagsResponseBodyItems struct {
	DBInstanceTag []*DescribeDBInstanceByTagsResponseBodyItemsDBInstanceTag `json:"DBInstanceTag,omitempty" xml:"DBInstanceTag,omitempty" type:"Repeated"`
}

func (s DescribeDBInstanceByTagsResponseBodyItems) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceByTagsResponseBodyItems) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceByTagsResponseBodyItems) SetDBInstanceTag(v []*DescribeDBInstanceByTagsResponseBodyItemsDBInstanceTag) *DescribeDBInstanceByTagsResponseBodyItems {
	s.DBInstanceTag = v
	return s
}

type DescribeDBInstanceByTagsResponseBodyItemsDBInstanceTag struct {
	// The instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The details about the tag.
	Tags *DescribeDBInstanceByTagsResponseBodyItemsDBInstanceTagTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Struct"`
}

func (s DescribeDBInstanceByTagsResponseBodyItemsDBInstanceTag) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceByTagsResponseBodyItemsDBInstanceTag) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceByTagsResponseBodyItemsDBInstanceTag) SetDBInstanceId(v string) *DescribeDBInstanceByTagsResponseBodyItemsDBInstanceTag {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeDBInstanceByTagsResponseBodyItemsDBInstanceTag) SetTags(v *DescribeDBInstanceByTagsResponseBodyItemsDBInstanceTagTags) *DescribeDBInstanceByTagsResponseBodyItemsDBInstanceTag {
	s.Tags = v
	return s
}

type DescribeDBInstanceByTagsResponseBodyItemsDBInstanceTagTags struct {
	Tag []*DescribeDBInstanceByTagsResponseBodyItemsDBInstanceTagTagsTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s DescribeDBInstanceByTagsResponseBodyItemsDBInstanceTagTags) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceByTagsResponseBodyItemsDBInstanceTagTags) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceByTagsResponseBodyItemsDBInstanceTagTags) SetTag(v []*DescribeDBInstanceByTagsResponseBodyItemsDBInstanceTagTagsTag) *DescribeDBInstanceByTagsResponseBodyItemsDBInstanceTagTags {
	s.Tag = v
	return s
}

type DescribeDBInstanceByTagsResponseBodyItemsDBInstanceTagTagsTag struct {
	// The tag key.
	TagKey *string `json:"TagKey,omitempty" xml:"TagKey,omitempty"`
	// The tag value.
	TagValue *string `json:"TagValue,omitempty" xml:"TagValue,omitempty"`
}

func (s DescribeDBInstanceByTagsResponseBodyItemsDBInstanceTagTagsTag) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceByTagsResponseBodyItemsDBInstanceTagTagsTag) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceByTagsResponseBodyItemsDBInstanceTagTagsTag) SetTagKey(v string) *DescribeDBInstanceByTagsResponseBodyItemsDBInstanceTagTagsTag {
	s.TagKey = &v
	return s
}

func (s *DescribeDBInstanceByTagsResponseBodyItemsDBInstanceTagTagsTag) SetTagValue(v string) *DescribeDBInstanceByTagsResponseBodyItemsDBInstanceTagTagsTag {
	s.TagValue = &v
	return s
}

type DescribeDBInstanceByTagsResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDBInstanceByTagsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDBInstanceByTagsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceByTagsResponse) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceByTagsResponse) SetHeaders(v map[string]*string) *DescribeDBInstanceByTagsResponse {
	s.Headers = v
	return s
}

func (s *DescribeDBInstanceByTagsResponse) SetStatusCode(v int32) *DescribeDBInstanceByTagsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDBInstanceByTagsResponse) SetBody(v *DescribeDBInstanceByTagsResponseBody) *DescribeDBInstanceByTagsResponse {
	s.Body = v
	return s
}

type DescribeDBInstanceConnectivityRequest struct {
	// The instance ID.
	DbInstanceName *string `json:"DbInstanceName,omitempty" xml:"DbInstanceName,omitempty"`
	OwnerAccount   *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId        *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The resource group ID.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	SecurityToken        *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
	// The source IP address.
	SourceIpAddress *string `json:"SourceIpAddress,omitempty" xml:"SourceIpAddress,omitempty"`
}

func (s DescribeDBInstanceConnectivityRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceConnectivityRequest) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceConnectivityRequest) SetDbInstanceName(v string) *DescribeDBInstanceConnectivityRequest {
	s.DbInstanceName = &v
	return s
}

func (s *DescribeDBInstanceConnectivityRequest) SetOwnerAccount(v string) *DescribeDBInstanceConnectivityRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeDBInstanceConnectivityRequest) SetOwnerId(v int64) *DescribeDBInstanceConnectivityRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeDBInstanceConnectivityRequest) SetResourceGroupId(v string) *DescribeDBInstanceConnectivityRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeDBInstanceConnectivityRequest) SetResourceOwnerAccount(v string) *DescribeDBInstanceConnectivityRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeDBInstanceConnectivityRequest) SetResourceOwnerId(v int64) *DescribeDBInstanceConnectivityRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeDBInstanceConnectivityRequest) SetSecurityToken(v string) *DescribeDBInstanceConnectivityRequest {
	s.SecurityToken = &v
	return s
}

func (s *DescribeDBInstanceConnectivityRequest) SetSourceIpAddress(v string) *DescribeDBInstanceConnectivityRequest {
	s.SourceIpAddress = &v
	return s
}

type DescribeDBInstanceConnectivityResponseBody struct {
	// The error code for connection diagnosis. Valid values:
	//
	// *   **SRC_IP_NOT_IN_USER_WHITELIST**: The source IP address is not added to the whitelist.
	// *   **CONNECTION_ABNORMAL**: The connection to the cluster is normal.
	ConnCheckErrorCode *string `json:"ConnCheckErrorCode,omitempty" xml:"ConnCheckErrorCode,omitempty"`
	// The error message for connection diagnosis.
	ConnCheckErrorMessage *string `json:"ConnCheckErrorMessage,omitempty" xml:"ConnCheckErrorMessage,omitempty"`
	// The connection diagnosis result. Valid values:
	//
	// *   **Success**
	// *   **Failed**
	ConnCheckResult *string `json:"ConnCheckResult,omitempty" xml:"ConnCheckResult,omitempty"`
	// The instance ID.
	DbInstanceName *string `json:"DbInstanceName,omitempty" xml:"DbInstanceName,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDBInstanceConnectivityResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceConnectivityResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceConnectivityResponseBody) SetConnCheckErrorCode(v string) *DescribeDBInstanceConnectivityResponseBody {
	s.ConnCheckErrorCode = &v
	return s
}

func (s *DescribeDBInstanceConnectivityResponseBody) SetConnCheckErrorMessage(v string) *DescribeDBInstanceConnectivityResponseBody {
	s.ConnCheckErrorMessage = &v
	return s
}

func (s *DescribeDBInstanceConnectivityResponseBody) SetConnCheckResult(v string) *DescribeDBInstanceConnectivityResponseBody {
	s.ConnCheckResult = &v
	return s
}

func (s *DescribeDBInstanceConnectivityResponseBody) SetDbInstanceName(v string) *DescribeDBInstanceConnectivityResponseBody {
	s.DbInstanceName = &v
	return s
}

func (s *DescribeDBInstanceConnectivityResponseBody) SetRequestId(v string) *DescribeDBInstanceConnectivityResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDBInstanceConnectivityResponse struct {
	Headers    map[string]*string                          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDBInstanceConnectivityResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDBInstanceConnectivityResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceConnectivityResponse) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceConnectivityResponse) SetHeaders(v map[string]*string) *DescribeDBInstanceConnectivityResponse {
	s.Headers = v
	return s
}

func (s *DescribeDBInstanceConnectivityResponse) SetStatusCode(v int32) *DescribeDBInstanceConnectivityResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDBInstanceConnectivityResponse) SetBody(v *DescribeDBInstanceConnectivityResponseBody) *DescribeDBInstanceConnectivityResponse {
	s.Body = v
	return s
}

type DescribeDBInstanceDetailRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// > You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the instance. You can call the [DescribeDBInstances](~~26232~~) operation to query the ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeDBInstanceDetailRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceDetailRequest) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceDetailRequest) SetClientToken(v string) *DescribeDBInstanceDetailRequest {
	s.ClientToken = &v
	return s
}

func (s *DescribeDBInstanceDetailRequest) SetDBInstanceId(v string) *DescribeDBInstanceDetailRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeDBInstanceDetailRequest) SetOwnerId(v int64) *DescribeDBInstanceDetailRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeDBInstanceDetailRequest) SetResourceGroupId(v string) *DescribeDBInstanceDetailRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeDBInstanceDetailRequest) SetResourceOwnerAccount(v string) *DescribeDBInstanceDetailRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeDBInstanceDetailRequest) SetResourceOwnerId(v int64) *DescribeDBInstanceDetailRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeDBInstanceDetailResponseBody struct {
	// Indicates whether the instance is in the active state.
	ActivationState *string `json:"ActivationState,omitempty" xml:"ActivationState,omitempty"`
	// The ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The type of the license.
	LicenseType *string `json:"LicenseType,omitempty" xml:"LicenseType,omitempty"`
	// The region ID of the instance.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDBInstanceDetailResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceDetailResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceDetailResponseBody) SetActivationState(v string) *DescribeDBInstanceDetailResponseBody {
	s.ActivationState = &v
	return s
}

func (s *DescribeDBInstanceDetailResponseBody) SetDBInstanceId(v string) *DescribeDBInstanceDetailResponseBody {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeDBInstanceDetailResponseBody) SetLicenseType(v string) *DescribeDBInstanceDetailResponseBody {
	s.LicenseType = &v
	return s
}

func (s *DescribeDBInstanceDetailResponseBody) SetRegionId(v string) *DescribeDBInstanceDetailResponseBody {
	s.RegionId = &v
	return s
}

func (s *DescribeDBInstanceDetailResponseBody) SetRequestId(v string) *DescribeDBInstanceDetailResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDBInstanceDetailResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDBInstanceDetailResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDBInstanceDetailResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceDetailResponse) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceDetailResponse) SetHeaders(v map[string]*string) *DescribeDBInstanceDetailResponse {
	s.Headers = v
	return s
}

func (s *DescribeDBInstanceDetailResponse) SetStatusCode(v int32) *DescribeDBInstanceDetailResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDBInstanceDetailResponse) SetBody(v *DescribeDBInstanceDetailResponseBody) *DescribeDBInstanceDetailResponse {
	s.Body = v
	return s
}

type DescribeDBInstanceEncryptionKeyRequest struct {
	// The ID of the instance You can call the [DescribeDBInstances](~~26232~~) operation to query the IDs of instances.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The ID of the custom key.
	EncryptionKey *string `json:"EncryptionKey,omitempty" xml:"EncryptionKey,omitempty"`
	OwnerAccount  *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the instance. You can call the [DescribeRegions](~~26243~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	SecurityToken        *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
	// The ID of the destination region. You can call the [DescribeRegions](~~26243~~) operation to query the most recent region list.
	TargetRegionId *string `json:"TargetRegionId,omitempty" xml:"TargetRegionId,omitempty"`
}

func (s DescribeDBInstanceEncryptionKeyRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceEncryptionKeyRequest) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceEncryptionKeyRequest) SetDBInstanceId(v string) *DescribeDBInstanceEncryptionKeyRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeDBInstanceEncryptionKeyRequest) SetEncryptionKey(v string) *DescribeDBInstanceEncryptionKeyRequest {
	s.EncryptionKey = &v
	return s
}

func (s *DescribeDBInstanceEncryptionKeyRequest) SetOwnerAccount(v string) *DescribeDBInstanceEncryptionKeyRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeDBInstanceEncryptionKeyRequest) SetOwnerId(v int64) *DescribeDBInstanceEncryptionKeyRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeDBInstanceEncryptionKeyRequest) SetRegionId(v string) *DescribeDBInstanceEncryptionKeyRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeDBInstanceEncryptionKeyRequest) SetResourceOwnerAccount(v string) *DescribeDBInstanceEncryptionKeyRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeDBInstanceEncryptionKeyRequest) SetResourceOwnerId(v int64) *DescribeDBInstanceEncryptionKeyRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeDBInstanceEncryptionKeyRequest) SetSecurityToken(v string) *DescribeDBInstanceEncryptionKeyRequest {
	s.SecurityToken = &v
	return s
}

func (s *DescribeDBInstanceEncryptionKeyRequest) SetTargetRegionId(v string) *DescribeDBInstanceEncryptionKeyRequest {
	s.TargetRegionId = &v
	return s
}

type DescribeDBInstanceEncryptionKeyResponseBody struct {
	// The user who created the key.
	Creator *string `json:"Creator,omitempty" xml:"Creator,omitempty"`
	// The scheduled time at which the key is deleted. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
	DeleteDate *string `json:"DeleteDate,omitempty" xml:"DeleteDate,omitempty"`
	// The description of the key.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the key.
	EncryptionKey *string `json:"EncryptionKey,omitempty" xml:"EncryptionKey,omitempty"`
	// The details about the key.
	EncryptionKeyList []*DescribeDBInstanceEncryptionKeyResponseBodyEncryptionKeyList `json:"EncryptionKeyList,omitempty" xml:"EncryptionKeyList,omitempty" type:"Repeated"`
	// The status of the key. Valid values:
	//
	// *   **Enabled**
	// *   **Disabled**
	EncryptionKeyStatus *string `json:"EncryptionKeyStatus,omitempty" xml:"EncryptionKeyStatus,omitempty"`
	// The purpose of the key.
	KeyUsage *string `json:"KeyUsage,omitempty" xml:"KeyUsage,omitempty"`
	// The time at which the key expires. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
	MaterialExpireTime *string `json:"MaterialExpireTime,omitempty" xml:"MaterialExpireTime,omitempty"`
	// The source of the key.
	Origin *string `json:"Origin,omitempty" xml:"Origin,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDBInstanceEncryptionKeyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceEncryptionKeyResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceEncryptionKeyResponseBody) SetCreator(v string) *DescribeDBInstanceEncryptionKeyResponseBody {
	s.Creator = &v
	return s
}

func (s *DescribeDBInstanceEncryptionKeyResponseBody) SetDeleteDate(v string) *DescribeDBInstanceEncryptionKeyResponseBody {
	s.DeleteDate = &v
	return s
}

func (s *DescribeDBInstanceEncryptionKeyResponseBody) SetDescription(v string) *DescribeDBInstanceEncryptionKeyResponseBody {
	s.Description = &v
	return s
}

func (s *DescribeDBInstanceEncryptionKeyResponseBody) SetEncryptionKey(v string) *DescribeDBInstanceEncryptionKeyResponseBody {
	s.EncryptionKey = &v
	return s
}

func (s *DescribeDBInstanceEncryptionKeyResponseBody) SetEncryptionKeyList(v []*DescribeDBInstanceEncryptionKeyResponseBodyEncryptionKeyList) *DescribeDBInstanceEncryptionKeyResponseBody {
	s.EncryptionKeyList = v
	return s
}

func (s *DescribeDBInstanceEncryptionKeyResponseBody) SetEncryptionKeyStatus(v string) *DescribeDBInstanceEncryptionKeyResponseBody {
	s.EncryptionKeyStatus = &v
	return s
}

func (s *DescribeDBInstanceEncryptionKeyResponseBody) SetKeyUsage(v string) *DescribeDBInstanceEncryptionKeyResponseBody {
	s.KeyUsage = &v
	return s
}

func (s *DescribeDBInstanceEncryptionKeyResponseBody) SetMaterialExpireTime(v string) *DescribeDBInstanceEncryptionKeyResponseBody {
	s.MaterialExpireTime = &v
	return s
}

func (s *DescribeDBInstanceEncryptionKeyResponseBody) SetOrigin(v string) *DescribeDBInstanceEncryptionKeyResponseBody {
	s.Origin = &v
	return s
}

func (s *DescribeDBInstanceEncryptionKeyResponseBody) SetRequestId(v string) *DescribeDBInstanceEncryptionKeyResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDBInstanceEncryptionKeyResponseBodyEncryptionKeyList struct {
	// The alias of the key.
	AliasName *string `json:"AliasName,omitempty" xml:"AliasName,omitempty"`
	// The user who created the key.
	Creator *string `json:"Creator,omitempty" xml:"Creator,omitempty"`
	// The scheduled time at which the key is deleted. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
	DeleteDate *string `json:"DeleteDate,omitempty" xml:"DeleteDate,omitempty"`
	// The description of the key.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the key.
	EncryptionKey *string `json:"EncryptionKey,omitempty" xml:"EncryptionKey,omitempty"`
	// The status of the key. Valid values:
	//
	// *   **Enabled**
	// *   **Disabled**
	EncryptionKeyStatus *string `json:"EncryptionKeyStatus,omitempty" xml:"EncryptionKeyStatus,omitempty"`
	// The type of the key. Valid values:
	//
	// *   **CMK**
	// *   **ServiceKey**
	KeyType *string `json:"KeyType,omitempty" xml:"KeyType,omitempty"`
	// The purpose of the key.
	KeyUsage *string `json:"KeyUsage,omitempty" xml:"KeyUsage,omitempty"`
	// The time at which the key expires. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
	MaterialExpireTime *string `json:"MaterialExpireTime,omitempty" xml:"MaterialExpireTime,omitempty"`
	// The source of the key.
	Origin *string `json:"Origin,omitempty" xml:"Origin,omitempty"`
	// The role of the instance. Valid values:
	//
	// *   **Master**: primary instance
	// *   **slave**: read-only instance
	UsedBy *string `json:"UsedBy,omitempty" xml:"UsedBy,omitempty"`
}

func (s DescribeDBInstanceEncryptionKeyResponseBodyEncryptionKeyList) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceEncryptionKeyResponseBodyEncryptionKeyList) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceEncryptionKeyResponseBodyEncryptionKeyList) SetAliasName(v string) *DescribeDBInstanceEncryptionKeyResponseBodyEncryptionKeyList {
	s.AliasName = &v
	return s
}

func (s *DescribeDBInstanceEncryptionKeyResponseBodyEncryptionKeyList) SetCreator(v string) *DescribeDBInstanceEncryptionKeyResponseBodyEncryptionKeyList {
	s.Creator = &v
	return s
}

func (s *DescribeDBInstanceEncryptionKeyResponseBodyEncryptionKeyList) SetDeleteDate(v string) *DescribeDBInstanceEncryptionKeyResponseBodyEncryptionKeyList {
	s.DeleteDate = &v
	return s
}

func (s *DescribeDBInstanceEncryptionKeyResponseBodyEncryptionKeyList) SetDescription(v string) *DescribeDBInstanceEncryptionKeyResponseBodyEncryptionKeyList {
	s.Description = &v
	return s
}

func (s *DescribeDBInstanceEncryptionKeyResponseBodyEncryptionKeyList) SetEncryptionKey(v string) *DescribeDBInstanceEncryptionKeyResponseBodyEncryptionKeyList {
	s.EncryptionKey = &v
	return s
}

func (s *DescribeDBInstanceEncryptionKeyResponseBodyEncryptionKeyList) SetEncryptionKeyStatus(v string) *DescribeDBInstanceEncryptionKeyResponseBodyEncryptionKeyList {
	s.EncryptionKeyStatus = &v
	return s
}

func (s *DescribeDBInstanceEncryptionKeyResponseBodyEncryptionKeyList) SetKeyType(v string) *DescribeDBInstanceEncryptionKeyResponseBodyEncryptionKeyList {
	s.KeyType = &v
	return s
}

func (s *DescribeDBInstanceEncryptionKeyResponseBodyEncryptionKeyList) SetKeyUsage(v string) *DescribeDBInstanceEncryptionKeyResponseBodyEncryptionKeyList {
	s.KeyUsage = &v
	return s
}

func (s *DescribeDBInstanceEncryptionKeyResponseBodyEncryptionKeyList) SetMaterialExpireTime(v string) *DescribeDBInstanceEncryptionKeyResponseBodyEncryptionKeyList {
	s.MaterialExpireTime = &v
	return s
}

func (s *DescribeDBInstanceEncryptionKeyResponseBodyEncryptionKeyList) SetOrigin(v string) *DescribeDBInstanceEncryptionKeyResponseBodyEncryptionKeyList {
	s.Origin = &v
	return s
}

func (s *DescribeDBInstanceEncryptionKeyResponseBodyEncryptionKeyList) SetUsedBy(v string) *DescribeDBInstanceEncryptionKeyResponseBodyEncryptionKeyList {
	s.UsedBy = &v
	return s
}

type DescribeDBInstanceEncryptionKeyResponse struct {
	Headers    map[string]*string                           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDBInstanceEncryptionKeyResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDBInstanceEncryptionKeyResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceEncryptionKeyResponse) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceEncryptionKeyResponse) SetHeaders(v map[string]*string) *DescribeDBInstanceEncryptionKeyResponse {
	s.Headers = v
	return s
}

func (s *DescribeDBInstanceEncryptionKeyResponse) SetStatusCode(v int32) *DescribeDBInstanceEncryptionKeyResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDBInstanceEncryptionKeyResponse) SetBody(v *DescribeDBInstanceEncryptionKeyResponseBody) *DescribeDBInstanceEncryptionKeyResponse {
	s.Body = v
	return s
}

type DescribeDBInstanceEndpointsRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests.
	//
	// The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The endpoint ID of the instance.
	//
	// >  If this parameter is not specified, the information about all endpoints is returned.
	DBInstanceEndpointId *string `json:"DBInstanceEndpointId,omitempty" xml:"DBInstanceEndpointId,omitempty"`
	// The instance ID. You can call the [DescribeDBInstances](~~610396~~) operation to query the ID of the instance.
	DBInstanceId    *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	ResourceOwnerId *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeDBInstanceEndpointsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceEndpointsRequest) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceEndpointsRequest) SetClientToken(v string) *DescribeDBInstanceEndpointsRequest {
	s.ClientToken = &v
	return s
}

func (s *DescribeDBInstanceEndpointsRequest) SetDBInstanceEndpointId(v string) *DescribeDBInstanceEndpointsRequest {
	s.DBInstanceEndpointId = &v
	return s
}

func (s *DescribeDBInstanceEndpointsRequest) SetDBInstanceId(v string) *DescribeDBInstanceEndpointsRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeDBInstanceEndpointsRequest) SetResourceOwnerId(v int64) *DescribeDBInstanceEndpointsRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeDBInstanceEndpointsResponseBody struct {
	// The data returned.
	Data *DescribeDBInstanceEndpointsResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDBInstanceEndpointsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceEndpointsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceEndpointsResponseBody) SetData(v *DescribeDBInstanceEndpointsResponseBodyData) *DescribeDBInstanceEndpointsResponseBody {
	s.Data = v
	return s
}

func (s *DescribeDBInstanceEndpointsResponseBody) SetRequestId(v string) *DescribeDBInstanceEndpointsResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDBInstanceEndpointsResponseBodyData struct {
	// The information of the endpoints of the instance.
	DBInstanceEndpoints *DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpoints `json:"DBInstanceEndpoints,omitempty" xml:"DBInstanceEndpoints,omitempty" type:"Struct"`
	// The name of the instance.
	DBInstanceName *string `json:"DBInstanceName,omitempty" xml:"DBInstanceName,omitempty"`
	// The version of the IP protocol. Valid values:
	//
	// *   **ipv4**
	// *   **ipv6**
	IpVersion *string `json:"IpVersion,omitempty" xml:"IpVersion,omitempty"`
}

func (s DescribeDBInstanceEndpointsResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceEndpointsResponseBodyData) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceEndpointsResponseBodyData) SetDBInstanceEndpoints(v *DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpoints) *DescribeDBInstanceEndpointsResponseBodyData {
	s.DBInstanceEndpoints = v
	return s
}

func (s *DescribeDBInstanceEndpointsResponseBodyData) SetDBInstanceName(v string) *DescribeDBInstanceEndpointsResponseBodyData {
	s.DBInstanceName = &v
	return s
}

func (s *DescribeDBInstanceEndpointsResponseBodyData) SetIpVersion(v string) *DescribeDBInstanceEndpointsResponseBodyData {
	s.IpVersion = &v
	return s
}

type DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpoints struct {
	DBInstanceEndpoint []*DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpointsDBInstanceEndpoint `json:"DBInstanceEndpoint,omitempty" xml:"DBInstanceEndpoint,omitempty" type:"Repeated"`
}

func (s DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpoints) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpoints) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpoints) SetDBInstanceEndpoint(v []*DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpointsDBInstanceEndpoint) *DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpoints {
	s.DBInstanceEndpoint = v
	return s
}

type DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpointsDBInstanceEndpoint struct {
	// The information about the endpoint.
	AddressItems *DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpointsDBInstanceEndpointAddressItems `json:"AddressItems,omitempty" xml:"AddressItems,omitempty" type:"Struct"`
	// The user-defined description of the endpoint.
	EndpointDescription *string `json:"EndpointDescription,omitempty" xml:"EndpointDescription,omitempty"`
	// The endpoint ID of the instance.
	EndpointId *string `json:"EndpointId,omitempty" xml:"EndpointId,omitempty"`
	// The type of the endpoint. Valid values:
	//
	// *   **Primary**: the read/write endpoint of the instance
	// *   **Readonly**: the read-only endpoint of the instance
	EndpointType *string `json:"EndpointType,omitempty" xml:"EndpointType,omitempty"`
	// The information about the node that is configured for the endpoint.
	NodeItems *DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpointsDBInstanceEndpointNodeItems `json:"NodeItems,omitempty" xml:"NodeItems,omitempty" type:"Struct"`
}

func (s DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpointsDBInstanceEndpoint) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpointsDBInstanceEndpoint) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpointsDBInstanceEndpoint) SetAddressItems(v *DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpointsDBInstanceEndpointAddressItems) *DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpointsDBInstanceEndpoint {
	s.AddressItems = v
	return s
}

func (s *DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpointsDBInstanceEndpoint) SetEndpointDescription(v string) *DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpointsDBInstanceEndpoint {
	s.EndpointDescription = &v
	return s
}

func (s *DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpointsDBInstanceEndpoint) SetEndpointId(v string) *DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpointsDBInstanceEndpoint {
	s.EndpointId = &v
	return s
}

func (s *DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpointsDBInstanceEndpoint) SetEndpointType(v string) *DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpointsDBInstanceEndpoint {
	s.EndpointType = &v
	return s
}

func (s *DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpointsDBInstanceEndpoint) SetNodeItems(v *DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpointsDBInstanceEndpointNodeItems) *DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpointsDBInstanceEndpoint {
	s.NodeItems = v
	return s
}

type DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpointsDBInstanceEndpointAddressItems struct {
	AddressItem []*DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpointsDBInstanceEndpointAddressItemsAddressItem `json:"AddressItem,omitempty" xml:"AddressItem,omitempty" type:"Repeated"`
}

func (s DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpointsDBInstanceEndpointAddressItems) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpointsDBInstanceEndpointAddressItems) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpointsDBInstanceEndpointAddressItems) SetAddressItem(v []*DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpointsDBInstanceEndpointAddressItemsAddressItem) *DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpointsDBInstanceEndpointAddressItems {
	s.AddressItem = v
	return s
}

type DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpointsDBInstanceEndpointAddressItemsAddressItem struct {
	// The endpoints of the instance.
	ConnectionString *string `json:"ConnectionString,omitempty" xml:"ConnectionString,omitempty"`
	// The IP address.
	IpAddress *string `json:"IpAddress,omitempty" xml:"IpAddress,omitempty"`
	// The type of the IP address. Valid values:
	//
	// *   **Public**: Internet
	// *   **Private**: internal network
	IpType *string `json:"IpType,omitempty" xml:"IpType,omitempty"`
	// The port number of the endpoint.
	Port *string `json:"Port,omitempty" xml:"Port,omitempty"`
	// The vSwitch ID.
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
	// The VPC ID.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpointsDBInstanceEndpointAddressItemsAddressItem) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpointsDBInstanceEndpointAddressItemsAddressItem) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpointsDBInstanceEndpointAddressItemsAddressItem) SetConnectionString(v string) *DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpointsDBInstanceEndpointAddressItemsAddressItem {
	s.ConnectionString = &v
	return s
}

func (s *DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpointsDBInstanceEndpointAddressItemsAddressItem) SetIpAddress(v string) *DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpointsDBInstanceEndpointAddressItemsAddressItem {
	s.IpAddress = &v
	return s
}

func (s *DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpointsDBInstanceEndpointAddressItemsAddressItem) SetIpType(v string) *DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpointsDBInstanceEndpointAddressItemsAddressItem {
	s.IpType = &v
	return s
}

func (s *DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpointsDBInstanceEndpointAddressItemsAddressItem) SetPort(v string) *DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpointsDBInstanceEndpointAddressItemsAddressItem {
	s.Port = &v
	return s
}

func (s *DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpointsDBInstanceEndpointAddressItemsAddressItem) SetVSwitchId(v string) *DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpointsDBInstanceEndpointAddressItemsAddressItem {
	s.VSwitchId = &v
	return s
}

func (s *DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpointsDBInstanceEndpointAddressItemsAddressItem) SetVpcId(v string) *DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpointsDBInstanceEndpointAddressItemsAddressItem {
	s.VpcId = &v
	return s
}

type DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpointsDBInstanceEndpointNodeItems struct {
	NodeItem []*DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpointsDBInstanceEndpointNodeItemsNodeItem `json:"NodeItem,omitempty" xml:"NodeItem,omitempty" type:"Repeated"`
}

func (s DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpointsDBInstanceEndpointNodeItems) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpointsDBInstanceEndpointNodeItems) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpointsDBInstanceEndpointNodeItems) SetNodeItem(v []*DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpointsDBInstanceEndpointNodeItemsNodeItem) *DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpointsDBInstanceEndpointNodeItems {
	s.NodeItem = v
	return s
}

type DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpointsDBInstanceEndpointNodeItemsNodeItem struct {
	// The instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The node ID.
	NodeId *string `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	// The weight of the node. Read requests are distributed based on the weight.
	//
	// Valid values: 0 to 100.
	Weight *int32 `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpointsDBInstanceEndpointNodeItemsNodeItem) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpointsDBInstanceEndpointNodeItemsNodeItem) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpointsDBInstanceEndpointNodeItemsNodeItem) SetDBInstanceId(v string) *DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpointsDBInstanceEndpointNodeItemsNodeItem {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpointsDBInstanceEndpointNodeItemsNodeItem) SetNodeId(v string) *DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpointsDBInstanceEndpointNodeItemsNodeItem {
	s.NodeId = &v
	return s
}

func (s *DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpointsDBInstanceEndpointNodeItemsNodeItem) SetWeight(v int32) *DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpointsDBInstanceEndpointNodeItemsNodeItem {
	s.Weight = &v
	return s
}

type DescribeDBInstanceEndpointsResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDBInstanceEndpointsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDBInstanceEndpointsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceEndpointsResponse) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceEndpointsResponse) SetHeaders(v map[string]*string) *DescribeDBInstanceEndpointsResponse {
	s.Headers = v
	return s
}

func (s *DescribeDBInstanceEndpointsResponse) SetStatusCode(v int32) *DescribeDBInstanceEndpointsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDBInstanceEndpointsResponse) SetBody(v *DescribeDBInstanceEndpointsResponseBody) *DescribeDBInstanceEndpointsResponse {
	s.Body = v
	return s
}

type DescribeDBInstanceHAConfigRequest struct {
	// The instance ID. You can call the [DescribeDBInstances](~~610396~~) operation to query the ID of the instance.
	DBInstanceId         *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeDBInstanceHAConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceHAConfigRequest) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceHAConfigRequest) SetDBInstanceId(v string) *DescribeDBInstanceHAConfigRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeDBInstanceHAConfigRequest) SetOwnerAccount(v string) *DescribeDBInstanceHAConfigRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeDBInstanceHAConfigRequest) SetOwnerId(v int64) *DescribeDBInstanceHAConfigRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeDBInstanceHAConfigRequest) SetResourceOwnerAccount(v string) *DescribeDBInstanceHAConfigRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeDBInstanceHAConfigRequest) SetResourceOwnerId(v int64) *DescribeDBInstanceHAConfigRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeDBInstanceHAConfigResponseBody struct {
	// The instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The high availability mode of the instance. Valid values:
	//
	// *   **RPO**: Data consistency is preferred. The instance ensures data reliability to minimize data losses. If you have high requirements on data consistency, select this mode.
	// *   **RTO**: Service availability is preferred. The instance restores the database service at the earliest opportunity to ensure service availability. If you have high requirements on instance availability, select this mode.
	//
	// > This parameter is returned only for instances that run MySQL.
	HAMode *string `json:"HAMode,omitempty" xml:"HAMode,omitempty"`
	// An array that consists of the information of the primary and secondary instances.
	HostInstanceInfos *DescribeDBInstanceHAConfigResponseBodyHostInstanceInfos `json:"HostInstanceInfos,omitempty" xml:"HostInstanceInfos,omitempty" type:"Struct"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The data replication mode of the instance. Valid values:
	//
	// *   **Sync**: the synchronous mode
	// *   **Semi-sync**: the semi-synchronous replication mode
	// *   **Async**: the asynchronous mode
	//
	// > This parameter is returned only for instances that run MySQL.
	SyncMode *string `json:"SyncMode,omitempty" xml:"SyncMode,omitempty"`
}

func (s DescribeDBInstanceHAConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceHAConfigResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceHAConfigResponseBody) SetDBInstanceId(v string) *DescribeDBInstanceHAConfigResponseBody {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeDBInstanceHAConfigResponseBody) SetHAMode(v string) *DescribeDBInstanceHAConfigResponseBody {
	s.HAMode = &v
	return s
}

func (s *DescribeDBInstanceHAConfigResponseBody) SetHostInstanceInfos(v *DescribeDBInstanceHAConfigResponseBodyHostInstanceInfos) *DescribeDBInstanceHAConfigResponseBody {
	s.HostInstanceInfos = v
	return s
}

func (s *DescribeDBInstanceHAConfigResponseBody) SetRequestId(v string) *DescribeDBInstanceHAConfigResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDBInstanceHAConfigResponseBody) SetSyncMode(v string) *DescribeDBInstanceHAConfigResponseBody {
	s.SyncMode = &v
	return s
}

type DescribeDBInstanceHAConfigResponseBodyHostInstanceInfos struct {
	NodeInfo []*DescribeDBInstanceHAConfigResponseBodyHostInstanceInfosNodeInfo `json:"NodeInfo,omitempty" xml:"NodeInfo,omitempty" type:"Repeated"`
}

func (s DescribeDBInstanceHAConfigResponseBodyHostInstanceInfos) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceHAConfigResponseBodyHostInstanceInfos) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceHAConfigResponseBodyHostInstanceInfos) SetNodeInfo(v []*DescribeDBInstanceHAConfigResponseBodyHostInstanceInfosNodeInfo) *DescribeDBInstanceHAConfigResponseBodyHostInstanceInfos {
	s.NodeInfo = v
	return s
}

type DescribeDBInstanceHAConfigResponseBodyHostInstanceInfosNodeInfo struct {
	// The time when the secondary instance completed the synchronization of data from the primary instance. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	DataSyncTime *string `json:"DataSyncTime,omitempty" xml:"DataSyncTime,omitempty"`
	// The time when the secondary instance received logs from the primary instance. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	LogSyncTime *string `json:"LogSyncTime,omitempty" xml:"LogSyncTime,omitempty"`
	// The ID of the instance.
	NodeId *string `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	// The type of the node. Valid values:
	//
	// *   **Master**: the primary node
	// *   **Slave**: the secondary node
	NodeType *string `json:"NodeType,omitempty" xml:"NodeType,omitempty"`
	// The region ID of the instance.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The synchronization status. Valid values:
	//
	// *   **NotAvailable**: The synchronization fails. This means that faults occur.
	// *   **Syncing**: The synchronization is in process. In this case, a primary/secondary switchover may cause data losses.
	// *   **Synchronized**: The synchronization is completed.
	// *   **NotSupport**: The database engine or database engine version does not involve the synchronization between the primary and secondary instances.
	SyncStatus *string `json:"SyncStatus,omitempty" xml:"SyncStatus,omitempty"`
	// The ID of the zone.
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
}

func (s DescribeDBInstanceHAConfigResponseBodyHostInstanceInfosNodeInfo) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceHAConfigResponseBodyHostInstanceInfosNodeInfo) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceHAConfigResponseBodyHostInstanceInfosNodeInfo) SetDataSyncTime(v string) *DescribeDBInstanceHAConfigResponseBodyHostInstanceInfosNodeInfo {
	s.DataSyncTime = &v
	return s
}

func (s *DescribeDBInstanceHAConfigResponseBodyHostInstanceInfosNodeInfo) SetLogSyncTime(v string) *DescribeDBInstanceHAConfigResponseBodyHostInstanceInfosNodeInfo {
	s.LogSyncTime = &v
	return s
}

func (s *DescribeDBInstanceHAConfigResponseBodyHostInstanceInfosNodeInfo) SetNodeId(v string) *DescribeDBInstanceHAConfigResponseBodyHostInstanceInfosNodeInfo {
	s.NodeId = &v
	return s
}

func (s *DescribeDBInstanceHAConfigResponseBodyHostInstanceInfosNodeInfo) SetNodeType(v string) *DescribeDBInstanceHAConfigResponseBodyHostInstanceInfosNodeInfo {
	s.NodeType = &v
	return s
}

func (s *DescribeDBInstanceHAConfigResponseBodyHostInstanceInfosNodeInfo) SetRegionId(v string) *DescribeDBInstanceHAConfigResponseBodyHostInstanceInfosNodeInfo {
	s.RegionId = &v
	return s
}

func (s *DescribeDBInstanceHAConfigResponseBodyHostInstanceInfosNodeInfo) SetSyncStatus(v string) *DescribeDBInstanceHAConfigResponseBodyHostInstanceInfosNodeInfo {
	s.SyncStatus = &v
	return s
}

func (s *DescribeDBInstanceHAConfigResponseBodyHostInstanceInfosNodeInfo) SetZoneId(v string) *DescribeDBInstanceHAConfigResponseBodyHostInstanceInfosNodeInfo {
	s.ZoneId = &v
	return s
}

type DescribeDBInstanceHAConfigResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDBInstanceHAConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDBInstanceHAConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceHAConfigResponse) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceHAConfigResponse) SetHeaders(v map[string]*string) *DescribeDBInstanceHAConfigResponse {
	s.Headers = v
	return s
}

func (s *DescribeDBInstanceHAConfigResponse) SetStatusCode(v int32) *DescribeDBInstanceHAConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDBInstanceHAConfigResponse) SetBody(v *DescribeDBInstanceHAConfigResponseBody) *DescribeDBInstanceHAConfigResponse {
	s.Body = v
	return s
}

type DescribeDBInstanceIPArrayListRequest struct {
	// The instance ID. You can call the [DescribeDBInstances](~~610396~~) operation to query the ID of the instance.
	DBInstanceId    *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerAccount    *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	ResourceOwnerId *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The network type of the IP address whitelist. Valid values:
	//
	// *   **Classic**: classic network in enhanced whitelist mode
	// *   **VPC**: virtual private cloud (VPC) in enhanced whitelist mode
	// *   **MIX**: standard whitelist mode
	//
	// By default, this operation returns IP address whitelists of all network types.
	WhitelistNetworkType *string `json:"WhitelistNetworkType,omitempty" xml:"WhitelistNetworkType,omitempty"`
}

func (s DescribeDBInstanceIPArrayListRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceIPArrayListRequest) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceIPArrayListRequest) SetDBInstanceId(v string) *DescribeDBInstanceIPArrayListRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeDBInstanceIPArrayListRequest) SetOwnerAccount(v string) *DescribeDBInstanceIPArrayListRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeDBInstanceIPArrayListRequest) SetResourceOwnerId(v int64) *DescribeDBInstanceIPArrayListRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeDBInstanceIPArrayListRequest) SetWhitelistNetworkType(v string) *DescribeDBInstanceIPArrayListRequest {
	s.WhitelistNetworkType = &v
	return s
}

type DescribeDBInstanceIPArrayListResponseBody struct {
	// An array that consists of the details about the IP address whitelists.
	Items *DescribeDBInstanceIPArrayListResponseBodyItems `json:"Items,omitempty" xml:"Items,omitempty" type:"Struct"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDBInstanceIPArrayListResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceIPArrayListResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceIPArrayListResponseBody) SetItems(v *DescribeDBInstanceIPArrayListResponseBodyItems) *DescribeDBInstanceIPArrayListResponseBody {
	s.Items = v
	return s
}

func (s *DescribeDBInstanceIPArrayListResponseBody) SetRequestId(v string) *DescribeDBInstanceIPArrayListResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDBInstanceIPArrayListResponseBodyItems struct {
	DBInstanceIPArray []*DescribeDBInstanceIPArrayListResponseBodyItemsDBInstanceIPArray `json:"DBInstanceIPArray,omitempty" xml:"DBInstanceIPArray,omitempty" type:"Repeated"`
}

func (s DescribeDBInstanceIPArrayListResponseBodyItems) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceIPArrayListResponseBodyItems) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceIPArrayListResponseBodyItems) SetDBInstanceIPArray(v []*DescribeDBInstanceIPArrayListResponseBodyItemsDBInstanceIPArray) *DescribeDBInstanceIPArrayListResponseBodyItems {
	s.DBInstanceIPArray = v
	return s
}

type DescribeDBInstanceIPArrayListResponseBodyItemsDBInstanceIPArray struct {
	// The attribute of the IP address whitelist. By default, this parameter is empty.
	//
	// >  A whitelist with the hidden attribute does not appear in the console. Such IP address whitelists are used to access Alibaba Cloud services, such as Data Transmission Service (DTS).
	DBInstanceIPArrayAttribute *string `json:"DBInstanceIPArrayAttribute,omitempty" xml:"DBInstanceIPArrayAttribute,omitempty"`
	// The name of the IP address whitelist.
	DBInstanceIPArrayName *string `json:"DBInstanceIPArrayName,omitempty" xml:"DBInstanceIPArrayName,omitempty"`
	// The IP addresses in the IP address whitelist.
	SecurityIPList *string `json:"SecurityIPList,omitempty" xml:"SecurityIPList,omitempty"`
	// The type of the IP address.
	SecurityIPType *string `json:"SecurityIPType,omitempty" xml:"SecurityIPType,omitempty"`
}

func (s DescribeDBInstanceIPArrayListResponseBodyItemsDBInstanceIPArray) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceIPArrayListResponseBodyItemsDBInstanceIPArray) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceIPArrayListResponseBodyItemsDBInstanceIPArray) SetDBInstanceIPArrayAttribute(v string) *DescribeDBInstanceIPArrayListResponseBodyItemsDBInstanceIPArray {
	s.DBInstanceIPArrayAttribute = &v
	return s
}

func (s *DescribeDBInstanceIPArrayListResponseBodyItemsDBInstanceIPArray) SetDBInstanceIPArrayName(v string) *DescribeDBInstanceIPArrayListResponseBodyItemsDBInstanceIPArray {
	s.DBInstanceIPArrayName = &v
	return s
}

func (s *DescribeDBInstanceIPArrayListResponseBodyItemsDBInstanceIPArray) SetSecurityIPList(v string) *DescribeDBInstanceIPArrayListResponseBodyItemsDBInstanceIPArray {
	s.SecurityIPList = &v
	return s
}

func (s *DescribeDBInstanceIPArrayListResponseBodyItemsDBInstanceIPArray) SetSecurityIPType(v string) *DescribeDBInstanceIPArrayListResponseBodyItemsDBInstanceIPArray {
	s.SecurityIPType = &v
	return s
}

type DescribeDBInstanceIPArrayListResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDBInstanceIPArrayListResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDBInstanceIPArrayListResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceIPArrayListResponse) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceIPArrayListResponse) SetHeaders(v map[string]*string) *DescribeDBInstanceIPArrayListResponse {
	s.Headers = v
	return s
}

func (s *DescribeDBInstanceIPArrayListResponse) SetStatusCode(v int32) *DescribeDBInstanceIPArrayListResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDBInstanceIPArrayListResponse) SetBody(v *DescribeDBInstanceIPArrayListResponseBody) *DescribeDBInstanceIPArrayListResponse {
	s.Body = v
	return s
}

type DescribeDBInstanceIpHostnameRequest struct {
	// The instance ID. You can call the [DescribeDBInstances](~~610396~~) operation to query the ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region. You can call the [DescribeDBInstanceAttribute](~~610394~~) operation to obtain the ID of the resource group.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	SecurityToken        *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s DescribeDBInstanceIpHostnameRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceIpHostnameRequest) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceIpHostnameRequest) SetDBInstanceId(v string) *DescribeDBInstanceIpHostnameRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeDBInstanceIpHostnameRequest) SetOwnerAccount(v string) *DescribeDBInstanceIpHostnameRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeDBInstanceIpHostnameRequest) SetOwnerId(v int64) *DescribeDBInstanceIpHostnameRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeDBInstanceIpHostnameRequest) SetRegionId(v string) *DescribeDBInstanceIpHostnameRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeDBInstanceIpHostnameRequest) SetResourceOwnerAccount(v string) *DescribeDBInstanceIpHostnameRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeDBInstanceIpHostnameRequest) SetResourceOwnerId(v int64) *DescribeDBInstanceIpHostnameRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeDBInstanceIpHostnameRequest) SetSecurityToken(v string) *DescribeDBInstanceIpHostnameRequest {
	s.SecurityToken = &v
	return s
}

type DescribeDBInstanceIpHostnameResponseBody struct {
	// The instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The internal IP addresses and hostnames of the ECS instances on which the primary and secondary instances reside. Format: `IP address 1,Hostname 1;IP address 2,Hostname 2`.
	IpHostnameInfos *string `json:"IpHostnameInfos,omitempty" xml:"IpHostnameInfos,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDBInstanceIpHostnameResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceIpHostnameResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceIpHostnameResponseBody) SetDBInstanceId(v string) *DescribeDBInstanceIpHostnameResponseBody {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeDBInstanceIpHostnameResponseBody) SetIpHostnameInfos(v string) *DescribeDBInstanceIpHostnameResponseBody {
	s.IpHostnameInfos = &v
	return s
}

func (s *DescribeDBInstanceIpHostnameResponseBody) SetRequestId(v string) *DescribeDBInstanceIpHostnameResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDBInstanceIpHostnameResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDBInstanceIpHostnameResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDBInstanceIpHostnameResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceIpHostnameResponse) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceIpHostnameResponse) SetHeaders(v map[string]*string) *DescribeDBInstanceIpHostnameResponse {
	s.Headers = v
	return s
}

func (s *DescribeDBInstanceIpHostnameResponse) SetStatusCode(v int32) *DescribeDBInstanceIpHostnameResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDBInstanceIpHostnameResponse) SetBody(v *DescribeDBInstanceIpHostnameResponseBody) *DescribeDBInstanceIpHostnameResponse {
	s.Body = v
	return s
}

type DescribeDBInstanceMetricsRequest struct {
	// The ID of the instance. You can call the [DescribeDBInstances](~~26232~~) operation to query the ID of the instance.
	DBInstanceName *string `json:"DBInstanceName,omitempty" xml:"DBInstanceName,omitempty"`
	// The resource group ID.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerId *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeDBInstanceMetricsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceMetricsRequest) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceMetricsRequest) SetDBInstanceName(v string) *DescribeDBInstanceMetricsRequest {
	s.DBInstanceName = &v
	return s
}

func (s *DescribeDBInstanceMetricsRequest) SetResourceGroupId(v string) *DescribeDBInstanceMetricsRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeDBInstanceMetricsRequest) SetResourceOwnerId(v int64) *DescribeDBInstanceMetricsRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeDBInstanceMetricsResponseBody struct {
	// The instance ID.
	DBInstanceName *string `json:"DBInstanceName,omitempty" xml:"DBInstanceName,omitempty"`
	// An array consisting of the Enhanced Monitoring metrics that are enabled for the instance.
	Items []*DescribeDBInstanceMetricsResponseBodyItems `json:"Items,omitempty" xml:"Items,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of enhanced monitoring metrics that are enabled for the instance.
	TotalRecordCount *int32 `json:"TotalRecordCount,omitempty" xml:"TotalRecordCount,omitempty"`
}

func (s DescribeDBInstanceMetricsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceMetricsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceMetricsResponseBody) SetDBInstanceName(v string) *DescribeDBInstanceMetricsResponseBody {
	s.DBInstanceName = &v
	return s
}

func (s *DescribeDBInstanceMetricsResponseBody) SetItems(v []*DescribeDBInstanceMetricsResponseBodyItems) *DescribeDBInstanceMetricsResponseBody {
	s.Items = v
	return s
}

func (s *DescribeDBInstanceMetricsResponseBody) SetRequestId(v string) *DescribeDBInstanceMetricsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDBInstanceMetricsResponseBody) SetTotalRecordCount(v int32) *DescribeDBInstanceMetricsResponseBody {
	s.TotalRecordCount = &v
	return s
}

type DescribeDBInstanceMetricsResponseBodyItems struct {
	// The description of the enhanced monitoring metric.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The category of the enhanced monitoring metric. Valid values:
	//
	// *   **os**: OS metric
	// *   **db**: database metric
	Dimension *string `json:"Dimension,omitempty" xml:"Dimension,omitempty"`
	// The key of the group to which the enhanced monitoring metric belongs.
	GroupKey *string `json:"GroupKey,omitempty" xml:"GroupKey,omitempty"`
	// The name of the group to which the enhanced monitoring metric belongs.
	GroupKeyType *string `json:"GroupKeyType,omitempty" xml:"GroupKeyType,omitempty"`
	// The method that is used to aggregate the monitoring data of the enhanced monitoring metric. Valid values:
	//
	// *   **avg**: The system calculates the average value of the enhanced monitoring metric.
	// *   **min**: The system calculates the minimum value of the enhanced monitoring metric.
	// *   **max**: The system calculates the maximum value of the enhanced monitoring metric.
	Method *string `json:"Method,omitempty" xml:"Method,omitempty"`
	// The key of the enhanced monitoring metric.
	MetricsKey *string `json:"MetricsKey,omitempty" xml:"MetricsKey,omitempty"`
	// The alias of the enhanced monitoring metric.
	MetricsKeyAlias *string `json:"MetricsKeyAlias,omitempty" xml:"MetricsKeyAlias,omitempty"`
	// The serial number of the enhanced monitoring metric.
	SortRule *int32 `json:"SortRule,omitempty" xml:"SortRule,omitempty"`
	// The unit of the enhanced monitoring metric.
	Unit *string `json:"Unit,omitempty" xml:"Unit,omitempty"`
}

func (s DescribeDBInstanceMetricsResponseBodyItems) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceMetricsResponseBodyItems) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceMetricsResponseBodyItems) SetDescription(v string) *DescribeDBInstanceMetricsResponseBodyItems {
	s.Description = &v
	return s
}

func (s *DescribeDBInstanceMetricsResponseBodyItems) SetDimension(v string) *DescribeDBInstanceMetricsResponseBodyItems {
	s.Dimension = &v
	return s
}

func (s *DescribeDBInstanceMetricsResponseBodyItems) SetGroupKey(v string) *DescribeDBInstanceMetricsResponseBodyItems {
	s.GroupKey = &v
	return s
}

func (s *DescribeDBInstanceMetricsResponseBodyItems) SetGroupKeyType(v string) *DescribeDBInstanceMetricsResponseBodyItems {
	s.GroupKeyType = &v
	return s
}

func (s *DescribeDBInstanceMetricsResponseBodyItems) SetMethod(v string) *DescribeDBInstanceMetricsResponseBodyItems {
	s.Method = &v
	return s
}

func (s *DescribeDBInstanceMetricsResponseBodyItems) SetMetricsKey(v string) *DescribeDBInstanceMetricsResponseBodyItems {
	s.MetricsKey = &v
	return s
}

func (s *DescribeDBInstanceMetricsResponseBodyItems) SetMetricsKeyAlias(v string) *DescribeDBInstanceMetricsResponseBodyItems {
	s.MetricsKeyAlias = &v
	return s
}

func (s *DescribeDBInstanceMetricsResponseBodyItems) SetSortRule(v int32) *DescribeDBInstanceMetricsResponseBodyItems {
	s.SortRule = &v
	return s
}

func (s *DescribeDBInstanceMetricsResponseBodyItems) SetUnit(v string) *DescribeDBInstanceMetricsResponseBodyItems {
	s.Unit = &v
	return s
}

type DescribeDBInstanceMetricsResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDBInstanceMetricsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDBInstanceMetricsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceMetricsResponse) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceMetricsResponse) SetHeaders(v map[string]*string) *DescribeDBInstanceMetricsResponse {
	s.Headers = v
	return s
}

func (s *DescribeDBInstanceMetricsResponse) SetStatusCode(v int32) *DescribeDBInstanceMetricsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDBInstanceMetricsResponse) SetBody(v *DescribeDBInstanceMetricsResponseBody) *DescribeDBInstanceMetricsResponse {
	s.Body = v
	return s
}

type DescribeDBInstanceMonitorRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The instance ID. You can call the [DescribeDBInstances](~~26232~~) operation to query the instance ID.
	DBInstanceId         *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeDBInstanceMonitorRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceMonitorRequest) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceMonitorRequest) SetClientToken(v string) *DescribeDBInstanceMonitorRequest {
	s.ClientToken = &v
	return s
}

func (s *DescribeDBInstanceMonitorRequest) SetDBInstanceId(v string) *DescribeDBInstanceMonitorRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeDBInstanceMonitorRequest) SetOwnerAccount(v string) *DescribeDBInstanceMonitorRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeDBInstanceMonitorRequest) SetOwnerId(v int64) *DescribeDBInstanceMonitorRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeDBInstanceMonitorRequest) SetResourceOwnerAccount(v string) *DescribeDBInstanceMonitorRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeDBInstanceMonitorRequest) SetResourceOwnerId(v int64) *DescribeDBInstanceMonitorRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeDBInstanceMonitorResponseBody struct {
	// The monitoring frequency. Unit: seconds.
	Period *string `json:"Period,omitempty" xml:"Period,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDBInstanceMonitorResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceMonitorResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceMonitorResponseBody) SetPeriod(v string) *DescribeDBInstanceMonitorResponseBody {
	s.Period = &v
	return s
}

func (s *DescribeDBInstanceMonitorResponseBody) SetRequestId(v string) *DescribeDBInstanceMonitorResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDBInstanceMonitorResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDBInstanceMonitorResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDBInstanceMonitorResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceMonitorResponse) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceMonitorResponse) SetHeaders(v map[string]*string) *DescribeDBInstanceMonitorResponse {
	s.Headers = v
	return s
}

func (s *DescribeDBInstanceMonitorResponse) SetStatusCode(v int32) *DescribeDBInstanceMonitorResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDBInstanceMonitorResponse) SetBody(v *DescribeDBInstanceMonitorResponseBody) *DescribeDBInstanceMonitorResponse {
	s.Body = v
	return s
}

type DescribeDBInstanceNetInfoRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The instance ID. You can call the [DescribeDBInstances](~~610396~~) operation to query the ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The type of the endpoint. Valid values:
	//
	// *   **Normal**: regular endpoint
	// *   **ReadWriteSplitting**: read/write splitting endpoint
	//
	// > By default, the system returns both types of endpoints.
	DBInstanceNetRWSplitType *string `json:"DBInstanceNetRWSplitType,omitempty" xml:"DBInstanceNetRWSplitType,omitempty"`
	// A reserved parameter. You do not need to specify this parameter.
	Flag *int32 `json:"Flag,omitempty" xml:"Flag,omitempty"`
	// The name of the dedicated cluster to which the instance belongs. This parameter takes effect only when the instance runs MySQL on RDS Standard Edition and is created in a dedicated cluster.
	GeneralGroupName     *string `json:"GeneralGroupName,omitempty" xml:"GeneralGroupName,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeDBInstanceNetInfoRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceNetInfoRequest) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceNetInfoRequest) SetClientToken(v string) *DescribeDBInstanceNetInfoRequest {
	s.ClientToken = &v
	return s
}

func (s *DescribeDBInstanceNetInfoRequest) SetDBInstanceId(v string) *DescribeDBInstanceNetInfoRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeDBInstanceNetInfoRequest) SetDBInstanceNetRWSplitType(v string) *DescribeDBInstanceNetInfoRequest {
	s.DBInstanceNetRWSplitType = &v
	return s
}

func (s *DescribeDBInstanceNetInfoRequest) SetFlag(v int32) *DescribeDBInstanceNetInfoRequest {
	s.Flag = &v
	return s
}

func (s *DescribeDBInstanceNetInfoRequest) SetGeneralGroupName(v string) *DescribeDBInstanceNetInfoRequest {
	s.GeneralGroupName = &v
	return s
}

func (s *DescribeDBInstanceNetInfoRequest) SetOwnerAccount(v string) *DescribeDBInstanceNetInfoRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeDBInstanceNetInfoRequest) SetOwnerId(v int64) *DescribeDBInstanceNetInfoRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeDBInstanceNetInfoRequest) SetResourceOwnerAccount(v string) *DescribeDBInstanceNetInfoRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeDBInstanceNetInfoRequest) SetResourceOwnerId(v int64) *DescribeDBInstanceNetInfoRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeDBInstanceNetInfoResponseBody struct {
	// The information about the endpoints of the instance.
	DBInstanceNetInfos *DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfos `json:"DBInstanceNetInfos,omitempty" xml:"DBInstanceNetInfos,omitempty" type:"Struct"`
	// The network type of the instance. Valid values:
	//
	// *   **Classic**: classic network
	// *   **VPC**: virtual private cloud (VPC)
	InstanceNetworkType *string `json:"InstanceNetworkType,omitempty" xml:"InstanceNetworkType,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The whitelist mode of the instance. Valid values:
	//
	// *   **normal**: standard whitelist mode
	// *   **safety**: enhanced whitelist mode
	SecurityIPMode *string `json:"SecurityIPMode,omitempty" xml:"SecurityIPMode,omitempty"`
}

func (s DescribeDBInstanceNetInfoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceNetInfoResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceNetInfoResponseBody) SetDBInstanceNetInfos(v *DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfos) *DescribeDBInstanceNetInfoResponseBody {
	s.DBInstanceNetInfos = v
	return s
}

func (s *DescribeDBInstanceNetInfoResponseBody) SetInstanceNetworkType(v string) *DescribeDBInstanceNetInfoResponseBody {
	s.InstanceNetworkType = &v
	return s
}

func (s *DescribeDBInstanceNetInfoResponseBody) SetRequestId(v string) *DescribeDBInstanceNetInfoResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDBInstanceNetInfoResponseBody) SetSecurityIPMode(v string) *DescribeDBInstanceNetInfoResponseBody {
	s.SecurityIPMode = &v
	return s
}

type DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfos struct {
	DBInstanceNetInfo []*DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfo `json:"DBInstanceNetInfo,omitempty" xml:"DBInstanceNetInfo,omitempty" type:"Repeated"`
}

func (s DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfos) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfos) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfos) SetDBInstanceNetInfo(v []*DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfo) *DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfos {
	s.DBInstanceNetInfo = v
	return s
}

type DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfo struct {
	// The Tabular Data Stream (TDS) port of the instance for which Babelfish is enabled.
	//
	// > This parameter applies only to ApsaraDB RDS for PostgreSQL instances. For more information about Babelfish for ApsaraDB RDS for PostgreSQL, see [Introduction to Babelfish](~~428613~~).
	BabelfishPort *string `json:"BabelfishPort,omitempty" xml:"BabelfishPort,omitempty"`
	// The endpoints of the instance.
	ConnectionString *string `json:"ConnectionString,omitempty" xml:"ConnectionString,omitempty"`
	// The types of the endpoints. Valid values:
	//
	// *   **Normal**: regular endpoints
	// *   **ReadWriteSplitting**: read/write splitting endpoints
	ConnectionStringType *string `json:"ConnectionStringType,omitempty" xml:"ConnectionStringType,omitempty"`
	// The information about the instance weight.
	//
	// > This parameter is returned only for instances that have read/write splitting endpoints.
	DBInstanceWeights *DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfoDBInstanceWeights `json:"DBInstanceWeights,omitempty" xml:"DBInstanceWeights,omitempty" type:"Struct"`
	// The policy that is used to assign read weights. This parameter is returned only for a read/write splitting endpoint. Valid values:
	//
	// *   **Standard**: The system automatically assigns read weights to the instance and its read-only instances based on the specifications of these instances.
	// *   **Custom**: You must manually assign read weights to the instance and its read-only instances.
	DistributionType *string `json:"DistributionType,omitempty" xml:"DistributionType,omitempty"`
	// The remaining validity period of the instance in the classic network in hybrid access mode. Unit: seconds.
	ExpiredTime *string `json:"ExpiredTime,omitempty" xml:"ExpiredTime,omitempty"`
	// The IP address.
	IPAddress *string `json:"IPAddress,omitempty" xml:"IPAddress,omitempty"`
	// The network type.
	//
	// *   Valid values when the instance resides in the classic network:
	//
	//     *   **Inner:**: internal network
	//     *   **Public**: Internet
	//
	// *   Valid values when the instance resides in a virtual private cloud (VPC):
	//
	//     *   **Private**: internal network
	//     *   **Public**: Internet
	IPType *string `json:"IPType,omitempty" xml:"IPType,omitempty"`
	// The latency threshold. This parameter is returned only for a read/write splitting endpoint. Unit: seconds.
	//
	// > If the latency on a read-only instance exceeds the specified threshold, the system no longer forwards read requests to the read-only instance.
	MaxDelayTime *string `json:"MaxDelayTime,omitempty" xml:"MaxDelayTime,omitempty"`
	// The PgBouncer port.
	//
	// > This parameter is returned only when PgBouncer is enabled for the instance that runs PostgreSQL.
	PGBouncerPort *string `json:"PGBouncerPort,omitempty" xml:"PGBouncerPort,omitempty"`
	// The port that is used to connect to the instance.
	Port *string `json:"Port,omitempty" xml:"Port,omitempty"`
	// The details of the IP address whitelist.
	SecurityIPGroups *DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfoSecurityIPGroups `json:"SecurityIPGroups,omitempty" xml:"SecurityIPGroups,omitempty" type:"Struct"`
	// Indicates whether the IP version can be updated. Valid values:
	//
	// *   **Enable**: The IP version can be updated.
	// *   **Disabled**: The IP version cannot be updated.
	//
	// > The IP version can be updated from IPv4 to IPv6.
	Upgradeable *string `json:"Upgradeable,omitempty" xml:"Upgradeable,omitempty"`
	// The VPC ID.
	VPCId *string `json:"VPCId,omitempty" xml:"VPCId,omitempty"`
	// The vSwitch ID.
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
}

func (s DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfo) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfo) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfo) SetBabelfishPort(v string) *DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfo {
	s.BabelfishPort = &v
	return s
}

func (s *DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfo) SetConnectionString(v string) *DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfo {
	s.ConnectionString = &v
	return s
}

func (s *DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfo) SetConnectionStringType(v string) *DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfo {
	s.ConnectionStringType = &v
	return s
}

func (s *DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfo) SetDBInstanceWeights(v *DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfoDBInstanceWeights) *DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfo {
	s.DBInstanceWeights = v
	return s
}

func (s *DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfo) SetDistributionType(v string) *DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfo {
	s.DistributionType = &v
	return s
}

func (s *DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfo) SetExpiredTime(v string) *DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfo {
	s.ExpiredTime = &v
	return s
}

func (s *DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfo) SetIPAddress(v string) *DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfo {
	s.IPAddress = &v
	return s
}

func (s *DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfo) SetIPType(v string) *DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfo {
	s.IPType = &v
	return s
}

func (s *DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfo) SetMaxDelayTime(v string) *DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfo {
	s.MaxDelayTime = &v
	return s
}

func (s *DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfo) SetPGBouncerPort(v string) *DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfo {
	s.PGBouncerPort = &v
	return s
}

func (s *DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfo) SetPort(v string) *DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfo {
	s.Port = &v
	return s
}

func (s *DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfo) SetSecurityIPGroups(v *DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfoSecurityIPGroups) *DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfo {
	s.SecurityIPGroups = v
	return s
}

func (s *DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfo) SetUpgradeable(v string) *DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfo {
	s.Upgradeable = &v
	return s
}

func (s *DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfo) SetVPCId(v string) *DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfo {
	s.VPCId = &v
	return s
}

func (s *DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfo) SetVSwitchId(v string) *DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfo {
	s.VSwitchId = &v
	return s
}

type DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfoDBInstanceWeights struct {
	DBInstanceWeight []*DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfoDBInstanceWeightsDBInstanceWeight `json:"DBInstanceWeight,omitempty" xml:"DBInstanceWeight,omitempty" type:"Repeated"`
}

func (s DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfoDBInstanceWeights) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfoDBInstanceWeights) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfoDBInstanceWeights) SetDBInstanceWeight(v []*DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfoDBInstanceWeightsDBInstanceWeight) *DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfoDBInstanceWeights {
	s.DBInstanceWeight = v
	return s
}

type DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfoDBInstanceWeightsDBInstanceWeight struct {
	// The availability of the instance. Valid values:
	//
	// *   **Unavailable**
	// *   **Available**
	Availability *string `json:"Availability,omitempty" xml:"Availability,omitempty"`
	// The instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The role of the instance. Valid values:
	//
	// *   **Master**: primary instance
	// *   **Readonly**: read-only instance
	DBInstanceType *string `json:"DBInstanceType,omitempty" xml:"DBInstanceType,omitempty"`
	// A deprecated parameter.
	Role *string `json:"Role,omitempty" xml:"Role,omitempty"`
	// The weight of the instance.
	Weight *string `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfoDBInstanceWeightsDBInstanceWeight) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfoDBInstanceWeightsDBInstanceWeight) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfoDBInstanceWeightsDBInstanceWeight) SetAvailability(v string) *DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfoDBInstanceWeightsDBInstanceWeight {
	s.Availability = &v
	return s
}

func (s *DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfoDBInstanceWeightsDBInstanceWeight) SetDBInstanceId(v string) *DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfoDBInstanceWeightsDBInstanceWeight {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfoDBInstanceWeightsDBInstanceWeight) SetDBInstanceType(v string) *DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfoDBInstanceWeightsDBInstanceWeight {
	s.DBInstanceType = &v
	return s
}

func (s *DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfoDBInstanceWeightsDBInstanceWeight) SetRole(v string) *DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfoDBInstanceWeightsDBInstanceWeight {
	s.Role = &v
	return s
}

func (s *DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfoDBInstanceWeightsDBInstanceWeight) SetWeight(v string) *DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfoDBInstanceWeightsDBInstanceWeight {
	s.Weight = &v
	return s
}

type DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfoSecurityIPGroups struct {
	SecurityIPGroup []*DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfoSecurityIPGroupsSecurityIPGroup `json:"securityIPGroup,omitempty" xml:"securityIPGroup,omitempty" type:"Repeated"`
}

func (s DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfoSecurityIPGroups) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfoSecurityIPGroups) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfoSecurityIPGroups) SetSecurityIPGroup(v []*DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfoSecurityIPGroupsSecurityIPGroup) *DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfoSecurityIPGroups {
	s.SecurityIPGroup = v
	return s
}

type DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfoSecurityIPGroupsSecurityIPGroup struct {
	// The name of the IP address whitelist.
	SecurityIPGroupName *string `json:"SecurityIPGroupName,omitempty" xml:"SecurityIPGroupName,omitempty"`
	// The IP addresses that is contained in the IP address whitelist.
	SecurityIPs *string `json:"SecurityIPs,omitempty" xml:"SecurityIPs,omitempty"`
}

func (s DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfoSecurityIPGroupsSecurityIPGroup) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfoSecurityIPGroupsSecurityIPGroup) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfoSecurityIPGroupsSecurityIPGroup) SetSecurityIPGroupName(v string) *DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfoSecurityIPGroupsSecurityIPGroup {
	s.SecurityIPGroupName = &v
	return s
}

func (s *DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfoSecurityIPGroupsSecurityIPGroup) SetSecurityIPs(v string) *DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfoSecurityIPGroupsSecurityIPGroup {
	s.SecurityIPs = &v
	return s
}

type DescribeDBInstanceNetInfoResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDBInstanceNetInfoResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDBInstanceNetInfoResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceNetInfoResponse) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceNetInfoResponse) SetHeaders(v map[string]*string) *DescribeDBInstanceNetInfoResponse {
	s.Headers = v
	return s
}

func (s *DescribeDBInstanceNetInfoResponse) SetStatusCode(v int32) *DescribeDBInstanceNetInfoResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDBInstanceNetInfoResponse) SetBody(v *DescribeDBInstanceNetInfoResponseBody) *DescribeDBInstanceNetInfoResponse {
	s.Body = v
	return s
}

type DescribeDBInstanceNetInfoForChannelRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the instance. You can call the [DescribeDBInstances](~~26232~~) operation to query the instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The type of the endpoint to query. Valid values:
	//
	// *   **0**: a regular endpoint. This is the default value.
	// *   **1**: a read/write splitting endpoint that is assigned after the shared proxy feature is enabled.
	DBInstanceNetRWSplitType *string `json:"DBInstanceNetRWSplitType,omitempty" xml:"DBInstanceNetRWSplitType,omitempty"`
	// An internal parameter. You do not need to specify this parameter.
	Flag                 *string `json:"Flag,omitempty" xml:"Flag,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeDBInstanceNetInfoForChannelRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceNetInfoForChannelRequest) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceNetInfoForChannelRequest) SetClientToken(v string) *DescribeDBInstanceNetInfoForChannelRequest {
	s.ClientToken = &v
	return s
}

func (s *DescribeDBInstanceNetInfoForChannelRequest) SetDBInstanceId(v string) *DescribeDBInstanceNetInfoForChannelRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeDBInstanceNetInfoForChannelRequest) SetDBInstanceNetRWSplitType(v string) *DescribeDBInstanceNetInfoForChannelRequest {
	s.DBInstanceNetRWSplitType = &v
	return s
}

func (s *DescribeDBInstanceNetInfoForChannelRequest) SetFlag(v string) *DescribeDBInstanceNetInfoForChannelRequest {
	s.Flag = &v
	return s
}

func (s *DescribeDBInstanceNetInfoForChannelRequest) SetOwnerAccount(v string) *DescribeDBInstanceNetInfoForChannelRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeDBInstanceNetInfoForChannelRequest) SetOwnerId(v int64) *DescribeDBInstanceNetInfoForChannelRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeDBInstanceNetInfoForChannelRequest) SetResourceOwnerAccount(v string) *DescribeDBInstanceNetInfoForChannelRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeDBInstanceNetInfoForChannelRequest) SetResourceOwnerId(v int64) *DescribeDBInstanceNetInfoForChannelRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeDBInstanceNetInfoForChannelResponseBody struct {
	// The network information about the instance.
	DBInstanceNetInfos *DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfos `json:"DBInstanceNetInfos,omitempty" xml:"DBInstanceNetInfos,omitempty" type:"Struct"`
	// The network type of the instance. Valid values:
	//
	// *   **VPC**: a virtual private cloud (VPC)
	// *   **Classic**: classic network
	InstanceNetworkType *string `json:"InstanceNetworkType,omitempty" xml:"InstanceNetworkType,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDBInstanceNetInfoForChannelResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceNetInfoForChannelResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceNetInfoForChannelResponseBody) SetDBInstanceNetInfos(v *DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfos) *DescribeDBInstanceNetInfoForChannelResponseBody {
	s.DBInstanceNetInfos = v
	return s
}

func (s *DescribeDBInstanceNetInfoForChannelResponseBody) SetInstanceNetworkType(v string) *DescribeDBInstanceNetInfoForChannelResponseBody {
	s.InstanceNetworkType = &v
	return s
}

func (s *DescribeDBInstanceNetInfoForChannelResponseBody) SetRequestId(v string) *DescribeDBInstanceNetInfoForChannelResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfos struct {
	DBInstanceNetInfo []*DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfo `json:"DBInstanceNetInfo,omitempty" xml:"DBInstanceNetInfo,omitempty" type:"Repeated"`
}

func (s DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfos) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfos) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfos) SetDBInstanceNetInfo(v []*DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfo) *DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfos {
	s.DBInstanceNetInfo = v
	return s
}

type DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfo struct {
	// The availability of the instance. Valid values:
	//
	// *   **Unavailable**
	// *   **Available**
	Availability *string `json:"Availability,omitempty" xml:"Availability,omitempty"`
	// The endpoint of the instance.
	ConnectionString *string `json:"ConnectionString,omitempty" xml:"ConnectionString,omitempty"`
	// The type of the endpoint. Valid values:
	//
	// *   **Normal**: a regular endpoint
	// *   **ReadWriteSplitting**: a read/write splitting endpoint that is assigned after the shared proxy feature is enabled.
	ConnectionStringType *string `json:"ConnectionStringType,omitempty" xml:"ConnectionStringType,omitempty"`
	// An array that consists of the information about read weights to implement read/write splitting after the shared proxy feature is enabled.
	DBInstanceWeights *DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfoDBInstanceWeights `json:"DBInstanceWeights,omitempty" xml:"DBInstanceWeights,omitempty" type:"Struct"`
	// The policy that is used to assign read weights. This parameter is returned only for a read/write splitting endpoint that is assigned after the shared proxy feature is enabled. Valid values:
	//
	// *   **Standard**: The system automatically allocates read weights to the instance and its read-only instances based on the specifications of the instances.
	// *   **Custom**: You must manually assign read weights to the instance and its read-only instances.
	DistributionType *string `json:"DistributionType,omitempty" xml:"DistributionType,omitempty"`
	// The IP address.
	IPAddress *string `json:"IPAddress,omitempty" xml:"IPAddress,omitempty"`
	// The network type of the IP address. Valid values:
	//
	// *   **Public**: the Internet
	// *   **Inner**: the classic network
	// *   **Private**: a VPC
	IPType *string `json:"IPType,omitempty" xml:"IPType,omitempty"`
	// The latency threshold that is allowed for read/write splitting of the shared proxy feature. Unit: seconds
	//
	// > This parameter is returned only when the **ConnectionStringType** parameter is set to **ReadWriteSplitting**.
	MaxDelayTime *string `json:"MaxDelayTime,omitempty" xml:"MaxDelayTime,omitempty"`
	// The service port number.
	Port *string `json:"Port,omitempty" xml:"Port,omitempty"`
	// An array that consists of the details about the IP address whitelist.
	SecurityIPGroups *DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfoSecurityIPGroups `json:"SecurityIPGroups,omitempty" xml:"SecurityIPGroups,omitempty" type:"Struct"`
	// An internal parameter. This operation does not return a value for this parameter.
	Upgradeable *string `json:"Upgradeable,omitempty" xml:"Upgradeable,omitempty"`
	// The ID of the VPC in which the instance is deployed.
	VPCId *string `json:"VPCId,omitempty" xml:"VPCId,omitempty"`
	// The ID of the vSwitch to which the instance belongs.
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
	// The expiration time of the endpoint of the classic network type. Unit: seconds.
	ExpiredTime *string `json:"expiredTime,omitempty" xml:"expiredTime,omitempty"`
}

func (s DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfo) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfo) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfo) SetAvailability(v string) *DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfo {
	s.Availability = &v
	return s
}

func (s *DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfo) SetConnectionString(v string) *DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfo {
	s.ConnectionString = &v
	return s
}

func (s *DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfo) SetConnectionStringType(v string) *DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfo {
	s.ConnectionStringType = &v
	return s
}

func (s *DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfo) SetDBInstanceWeights(v *DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfoDBInstanceWeights) *DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfo {
	s.DBInstanceWeights = v
	return s
}

func (s *DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfo) SetDistributionType(v string) *DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfo {
	s.DistributionType = &v
	return s
}

func (s *DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfo) SetIPAddress(v string) *DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfo {
	s.IPAddress = &v
	return s
}

func (s *DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfo) SetIPType(v string) *DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfo {
	s.IPType = &v
	return s
}

func (s *DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfo) SetMaxDelayTime(v string) *DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfo {
	s.MaxDelayTime = &v
	return s
}

func (s *DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfo) SetPort(v string) *DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfo {
	s.Port = &v
	return s
}

func (s *DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfo) SetSecurityIPGroups(v *DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfoSecurityIPGroups) *DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfo {
	s.SecurityIPGroups = v
	return s
}

func (s *DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfo) SetUpgradeable(v string) *DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfo {
	s.Upgradeable = &v
	return s
}

func (s *DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfo) SetVPCId(v string) *DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfo {
	s.VPCId = &v
	return s
}

func (s *DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfo) SetVSwitchId(v string) *DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfo {
	s.VSwitchId = &v
	return s
}

func (s *DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfo) SetExpiredTime(v string) *DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfo {
	s.ExpiredTime = &v
	return s
}

type DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfoDBInstanceWeights struct {
	DBInstanceWeight []*DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfoDBInstanceWeightsDBInstanceWeight `json:"DBInstanceWeight,omitempty" xml:"DBInstanceWeight,omitempty" type:"Repeated"`
}

func (s DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfoDBInstanceWeights) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfoDBInstanceWeights) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfoDBInstanceWeights) SetDBInstanceWeight(v []*DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfoDBInstanceWeightsDBInstanceWeight) *DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfoDBInstanceWeights {
	s.DBInstanceWeight = v
	return s
}

type DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfoDBInstanceWeightsDBInstanceWeight struct {
	// The availability of the instance. Valid values:
	//
	// *   **Unavailable**
	// *   **Available**
	Availability *string `json:"Availability,omitempty" xml:"Availability,omitempty"`
	// The ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The type of the instance. Valid values:
	//
	// *   **Master**: primary instance
	// *   **Readonly**: read-only instance
	DBInstanceType *string `json:"DBInstanceType,omitempty" xml:"DBInstanceType,omitempty"`
	// The weight of the instance.
	Weight *string `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfoDBInstanceWeightsDBInstanceWeight) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfoDBInstanceWeightsDBInstanceWeight) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfoDBInstanceWeightsDBInstanceWeight) SetAvailability(v string) *DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfoDBInstanceWeightsDBInstanceWeight {
	s.Availability = &v
	return s
}

func (s *DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfoDBInstanceWeightsDBInstanceWeight) SetDBInstanceId(v string) *DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfoDBInstanceWeightsDBInstanceWeight {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfoDBInstanceWeightsDBInstanceWeight) SetDBInstanceType(v string) *DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfoDBInstanceWeightsDBInstanceWeight {
	s.DBInstanceType = &v
	return s
}

func (s *DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfoDBInstanceWeightsDBInstanceWeight) SetWeight(v string) *DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfoDBInstanceWeightsDBInstanceWeight {
	s.Weight = &v
	return s
}

type DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfoSecurityIPGroups struct {
	SecurityIPGroup []*DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfoSecurityIPGroupsSecurityIPGroup `json:"securityIPGroup,omitempty" xml:"securityIPGroup,omitempty" type:"Repeated"`
}

func (s DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfoSecurityIPGroups) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfoSecurityIPGroups) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfoSecurityIPGroups) SetSecurityIPGroup(v []*DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfoSecurityIPGroupsSecurityIPGroup) *DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfoSecurityIPGroups {
	s.SecurityIPGroup = v
	return s
}

type DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfoSecurityIPGroupsSecurityIPGroup struct {
	// The name of the IP address whitelist.
	SecurityIPGroupName *string `json:"SecurityIPGroupName,omitempty" xml:"SecurityIPGroupName,omitempty"`
	// The IP addresses contained in the IP address whitelist.
	SecurityIPs *string `json:"SecurityIPs,omitempty" xml:"SecurityIPs,omitempty"`
}

func (s DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfoSecurityIPGroupsSecurityIPGroup) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfoSecurityIPGroupsSecurityIPGroup) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfoSecurityIPGroupsSecurityIPGroup) SetSecurityIPGroupName(v string) *DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfoSecurityIPGroupsSecurityIPGroup {
	s.SecurityIPGroupName = &v
	return s
}

func (s *DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfoSecurityIPGroupsSecurityIPGroup) SetSecurityIPs(v string) *DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfoSecurityIPGroupsSecurityIPGroup {
	s.SecurityIPs = &v
	return s
}

type DescribeDBInstanceNetInfoForChannelResponse struct {
	Headers    map[string]*string                               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDBInstanceNetInfoForChannelResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDBInstanceNetInfoForChannelResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceNetInfoForChannelResponse) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceNetInfoForChannelResponse) SetHeaders(v map[string]*string) *DescribeDBInstanceNetInfoForChannelResponse {
	s.Headers = v
	return s
}

func (s *DescribeDBInstanceNetInfoForChannelResponse) SetStatusCode(v int32) *DescribeDBInstanceNetInfoForChannelResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDBInstanceNetInfoForChannelResponse) SetBody(v *DescribeDBInstanceNetInfoForChannelResponseBody) *DescribeDBInstanceNetInfoForChannelResponse {
	s.Body = v
	return s
}

type DescribeDBInstancePerformanceRequest struct {
	// The instance ID. You can call the DescribeDBInstances operation to query the instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The end of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm*Z format. The time must be in UTC.
	//
	// >  The time span between the beginning time and the end time must be longer than the monitoring frequency. Otherwise, this operation may return an empty array.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The performance metrics that you want to query. Separate multiple values with commas (,). You can specify up to 30 values. For more information, see [Performance parameters](~~26316~~).
	//
	// >  If you set **Key** to **MySQL_SpaceUsage** or **SQLServer_SpaceUsage**, you can only query the monitoring data within one day.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The ID of the instance.
	NodeId          *string `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	ResourceOwnerId *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm*Z format. The time must be in UTC.
	//
	// >  The time span between the beginning time and the end time must be longer than the monitoring frequency. Otherwise, this operation may return an empty array.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDBInstancePerformanceRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstancePerformanceRequest) GoString() string {
	return s.String()
}

func (s *DescribeDBInstancePerformanceRequest) SetDBInstanceId(v string) *DescribeDBInstancePerformanceRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeDBInstancePerformanceRequest) SetEndTime(v string) *DescribeDBInstancePerformanceRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDBInstancePerformanceRequest) SetKey(v string) *DescribeDBInstancePerformanceRequest {
	s.Key = &v
	return s
}

func (s *DescribeDBInstancePerformanceRequest) SetNodeId(v string) *DescribeDBInstancePerformanceRequest {
	s.NodeId = &v
	return s
}

func (s *DescribeDBInstancePerformanceRequest) SetResourceOwnerId(v int64) *DescribeDBInstancePerformanceRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeDBInstancePerformanceRequest) SetStartTime(v string) *DescribeDBInstancePerformanceRequest {
	s.StartTime = &v
	return s
}

type DescribeDBInstancePerformanceResponseBody struct {
	// The instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The end time of the query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm*Z format. The time must be in UTC.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The database engine of the instance.
	Engine *string `json:"Engine,omitempty" xml:"Engine,omitempty"`
	// An array that consists of performance metrics.
	PerformanceKeys *DescribeDBInstancePerformanceResponseBodyPerformanceKeys `json:"PerformanceKeys,omitempty" xml:"PerformanceKeys,omitempty" type:"Struct"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The start time of the query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm*Z format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDBInstancePerformanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstancePerformanceResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDBInstancePerformanceResponseBody) SetDBInstanceId(v string) *DescribeDBInstancePerformanceResponseBody {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeDBInstancePerformanceResponseBody) SetEndTime(v string) *DescribeDBInstancePerformanceResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeDBInstancePerformanceResponseBody) SetEngine(v string) *DescribeDBInstancePerformanceResponseBody {
	s.Engine = &v
	return s
}

func (s *DescribeDBInstancePerformanceResponseBody) SetPerformanceKeys(v *DescribeDBInstancePerformanceResponseBodyPerformanceKeys) *DescribeDBInstancePerformanceResponseBody {
	s.PerformanceKeys = v
	return s
}

func (s *DescribeDBInstancePerformanceResponseBody) SetRequestId(v string) *DescribeDBInstancePerformanceResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDBInstancePerformanceResponseBody) SetStartTime(v string) *DescribeDBInstancePerformanceResponseBody {
	s.StartTime = &v
	return s
}

type DescribeDBInstancePerformanceResponseBodyPerformanceKeys struct {
	PerformanceKey []*DescribeDBInstancePerformanceResponseBodyPerformanceKeysPerformanceKey `json:"PerformanceKey,omitempty" xml:"PerformanceKey,omitempty" type:"Repeated"`
}

func (s DescribeDBInstancePerformanceResponseBodyPerformanceKeys) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstancePerformanceResponseBodyPerformanceKeys) GoString() string {
	return s.String()
}

func (s *DescribeDBInstancePerformanceResponseBodyPerformanceKeys) SetPerformanceKey(v []*DescribeDBInstancePerformanceResponseBodyPerformanceKeysPerformanceKey) *DescribeDBInstancePerformanceResponseBodyPerformanceKeys {
	s.PerformanceKey = v
	return s
}

type DescribeDBInstancePerformanceResponseBodyPerformanceKeysPerformanceKey struct {
	// The name of the performance metric.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The unit of the performance metrics.
	Unit *string `json:"Unit,omitempty" xml:"Unit,omitempty"`
	// The format in which the value of the performance metric is returned.
	//
	// >  If a performance metric value consists of multiple fields, the values are separated with ampersands (&). Example: com_delete\&com_insert\&com_insert_select\&com_replace.
	ValueFormat *string `json:"ValueFormat,omitempty" xml:"ValueFormat,omitempty"`
	// The performance metric values.
	Values *DescribeDBInstancePerformanceResponseBodyPerformanceKeysPerformanceKeyValues `json:"Values,omitempty" xml:"Values,omitempty" type:"Struct"`
}

func (s DescribeDBInstancePerformanceResponseBodyPerformanceKeysPerformanceKey) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstancePerformanceResponseBodyPerformanceKeysPerformanceKey) GoString() string {
	return s.String()
}

func (s *DescribeDBInstancePerformanceResponseBodyPerformanceKeysPerformanceKey) SetKey(v string) *DescribeDBInstancePerformanceResponseBodyPerformanceKeysPerformanceKey {
	s.Key = &v
	return s
}

func (s *DescribeDBInstancePerformanceResponseBodyPerformanceKeysPerformanceKey) SetUnit(v string) *DescribeDBInstancePerformanceResponseBodyPerformanceKeysPerformanceKey {
	s.Unit = &v
	return s
}

func (s *DescribeDBInstancePerformanceResponseBodyPerformanceKeysPerformanceKey) SetValueFormat(v string) *DescribeDBInstancePerformanceResponseBodyPerformanceKeysPerformanceKey {
	s.ValueFormat = &v
	return s
}

func (s *DescribeDBInstancePerformanceResponseBodyPerformanceKeysPerformanceKey) SetValues(v *DescribeDBInstancePerformanceResponseBodyPerformanceKeysPerformanceKeyValues) *DescribeDBInstancePerformanceResponseBodyPerformanceKeysPerformanceKey {
	s.Values = v
	return s
}

type DescribeDBInstancePerformanceResponseBodyPerformanceKeysPerformanceKeyValues struct {
	PerformanceValue []*DescribeDBInstancePerformanceResponseBodyPerformanceKeysPerformanceKeyValuesPerformanceValue `json:"PerformanceValue,omitempty" xml:"PerformanceValue,omitempty" type:"Repeated"`
}

func (s DescribeDBInstancePerformanceResponseBodyPerformanceKeysPerformanceKeyValues) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstancePerformanceResponseBodyPerformanceKeysPerformanceKeyValues) GoString() string {
	return s.String()
}

func (s *DescribeDBInstancePerformanceResponseBodyPerformanceKeysPerformanceKeyValues) SetPerformanceValue(v []*DescribeDBInstancePerformanceResponseBodyPerformanceKeysPerformanceKeyValuesPerformanceValue) *DescribeDBInstancePerformanceResponseBodyPerformanceKeysPerformanceKeyValues {
	s.PerformanceValue = v
	return s
}

type DescribeDBInstancePerformanceResponseBodyPerformanceKeysPerformanceKeyValuesPerformanceValue struct {
	// The date and time when the value of the performance metric was recorded. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	Date *string `json:"Date,omitempty" xml:"Date,omitempty"`
	// The value of the performance metric.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeDBInstancePerformanceResponseBodyPerformanceKeysPerformanceKeyValuesPerformanceValue) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstancePerformanceResponseBodyPerformanceKeysPerformanceKeyValuesPerformanceValue) GoString() string {
	return s.String()
}

func (s *DescribeDBInstancePerformanceResponseBodyPerformanceKeysPerformanceKeyValuesPerformanceValue) SetDate(v string) *DescribeDBInstancePerformanceResponseBodyPerformanceKeysPerformanceKeyValuesPerformanceValue {
	s.Date = &v
	return s
}

func (s *DescribeDBInstancePerformanceResponseBodyPerformanceKeysPerformanceKeyValuesPerformanceValue) SetValue(v string) *DescribeDBInstancePerformanceResponseBodyPerformanceKeysPerformanceKeyValuesPerformanceValue {
	s.Value = &v
	return s
}

type DescribeDBInstancePerformanceResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDBInstancePerformanceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDBInstancePerformanceResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstancePerformanceResponse) GoString() string {
	return s.String()
}

func (s *DescribeDBInstancePerformanceResponse) SetHeaders(v map[string]*string) *DescribeDBInstancePerformanceResponse {
	s.Headers = v
	return s
}

func (s *DescribeDBInstancePerformanceResponse) SetStatusCode(v int32) *DescribeDBInstancePerformanceResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDBInstancePerformanceResponse) SetBody(v *DescribeDBInstancePerformanceResponseBody) *DescribeDBInstancePerformanceResponse {
	s.Body = v
	return s
}

type DescribeDBInstancePromoteActivityRequest struct {
	// The ID of the Alibaba Cloud account.
	AliUid *string `json:"AliUid,omitempty" xml:"AliUid,omitempty"`
	// The instance ID.
	DbInstanceName *string `json:"DbInstanceName,omitempty" xml:"DbInstanceName,omitempty"`
	OwnerId        *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeDBInstancePromoteActivityRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstancePromoteActivityRequest) GoString() string {
	return s.String()
}

func (s *DescribeDBInstancePromoteActivityRequest) SetAliUid(v string) *DescribeDBInstancePromoteActivityRequest {
	s.AliUid = &v
	return s
}

func (s *DescribeDBInstancePromoteActivityRequest) SetDbInstanceName(v string) *DescribeDBInstancePromoteActivityRequest {
	s.DbInstanceName = &v
	return s
}

func (s *DescribeDBInstancePromoteActivityRequest) SetOwnerId(v int64) *DescribeDBInstancePromoteActivityRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeDBInstancePromoteActivityRequest) SetResourceGroupId(v string) *DescribeDBInstancePromoteActivityRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeDBInstancePromoteActivityRequest) SetResourceOwnerAccount(v string) *DescribeDBInstancePromoteActivityRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeDBInstancePromoteActivityRequest) SetResourceOwnerId(v int64) *DescribeDBInstancePromoteActivityRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeDBInstancePromoteActivityResponseBody struct {
	// The ID of the Alibaba Cloud account.
	AliUid *string `json:"AliUid,omitempty" xml:"AliUid,omitempty"`
	// China site: 26842 International site: 26888
	Bid *string `json:"Bid,omitempty" xml:"Bid,omitempty"`
	// The instance ID. You can call the [DescribeDBInstances](~~26232~~) operation to query the ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The instance name.
	DBInstanceName *string `json:"DBInstanceName,omitempty" xml:"DBInstanceName,omitempty"`
	// The type of the database engine. Valid values:
	//
	// *   **MySQL**
	// *   **PostgreSQL**
	// *   **Oracle**
	DBType *string `json:"DBType,omitempty" xml:"DBType,omitempty"`
	// The activity information about the instance. For more information, see [Instance activities](~~26312~~).
	IsActivity *string `json:"IsActivity,omitempty" xml:"IsActivity,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDBInstancePromoteActivityResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstancePromoteActivityResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDBInstancePromoteActivityResponseBody) SetAliUid(v string) *DescribeDBInstancePromoteActivityResponseBody {
	s.AliUid = &v
	return s
}

func (s *DescribeDBInstancePromoteActivityResponseBody) SetBid(v string) *DescribeDBInstancePromoteActivityResponseBody {
	s.Bid = &v
	return s
}

func (s *DescribeDBInstancePromoteActivityResponseBody) SetDBInstanceId(v string) *DescribeDBInstancePromoteActivityResponseBody {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeDBInstancePromoteActivityResponseBody) SetDBInstanceName(v string) *DescribeDBInstancePromoteActivityResponseBody {
	s.DBInstanceName = &v
	return s
}

func (s *DescribeDBInstancePromoteActivityResponseBody) SetDBType(v string) *DescribeDBInstancePromoteActivityResponseBody {
	s.DBType = &v
	return s
}

func (s *DescribeDBInstancePromoteActivityResponseBody) SetIsActivity(v string) *DescribeDBInstancePromoteActivityResponseBody {
	s.IsActivity = &v
	return s
}

func (s *DescribeDBInstancePromoteActivityResponseBody) SetRequestId(v string) *DescribeDBInstancePromoteActivityResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDBInstancePromoteActivityResponse struct {
	Headers    map[string]*string                             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDBInstancePromoteActivityResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDBInstancePromoteActivityResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstancePromoteActivityResponse) GoString() string {
	return s.String()
}

func (s *DescribeDBInstancePromoteActivityResponse) SetHeaders(v map[string]*string) *DescribeDBInstancePromoteActivityResponse {
	s.Headers = v
	return s
}

func (s *DescribeDBInstancePromoteActivityResponse) SetStatusCode(v int32) *DescribeDBInstancePromoteActivityResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDBInstancePromoteActivityResponse) SetBody(v *DescribeDBInstancePromoteActivityResponseBody) *DescribeDBInstancePromoteActivityResponse {
	s.Body = v
	return s
}

type DescribeDBInstanceProxyConfigurationRequest struct {
	// The ID of the instance.
	DBInstanceId         *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeDBInstanceProxyConfigurationRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceProxyConfigurationRequest) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceProxyConfigurationRequest) SetDBInstanceId(v string) *DescribeDBInstanceProxyConfigurationRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeDBInstanceProxyConfigurationRequest) SetOwnerId(v int64) *DescribeDBInstanceProxyConfigurationRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeDBInstanceProxyConfigurationRequest) SetResourceOwnerAccount(v string) *DescribeDBInstanceProxyConfigurationRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeDBInstanceProxyConfigurationRequest) SetResourceOwnerId(v int64) *DescribeDBInstanceProxyConfigurationRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeDBInstanceProxyConfigurationResponseBody struct {
	// Indicates whether the mechanism that is used to mitigate brute-force attacks is enabled:
	//
	// *   **Enable**
	// *   **Disable**
	//
	// The return value is a JSON string. Examples:
	//
	// {"status":"Disable", "check_interval_seconds": 60,
	//
	// "max_failed_login_attempts": 60, "blocking_seconds": 600}
	//
	// Description:
	//
	// *   Each client allows {max_failed_login_attempts} logon attempts that fail due to incorrect passwords within {check_interval_seconds} seconds. If one more such attempt is conducted, the client must wait for {blocking_seconds} seconds before you can try again.
	//
	// *   Valid values:
	//
	//     *   check_interval_seconds: **30 to 600**. Unit: seconds.
	//     *   max_failed_login_attempts: **10 to 5000**. Unit: times.
	//     *   blocking_seconds: **30 to 3600**. Unit: seconds.
	AttacksProtectionConfiguration *string `json:"AttacksProtectionConfiguration,omitempty" xml:"AttacksProtectionConfiguration,omitempty"`
	// Indicates whether the short-lived connection optimization feature is enabled.
	//
	// *   **Enable**
	// *   **Disable**
	//
	// The return value is a JSON string. Example:
	//
	// {"status":"Disable"}.
	PersistentConnectionsConfiguration *string `json:"PersistentConnectionsConfiguration,omitempty" xml:"PersistentConnectionsConfiguration,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the transparent switchover feature is enabled.
	//
	// *   **Enable**
	// *   **Disable**
	//
	// The return value is a JSON string. Example:
	//
	// {"status":"Enable"}.
	TransparentSwitchConfiguration *string `json:"TransparentSwitchConfiguration,omitempty" xml:"TransparentSwitchConfiguration,omitempty"`
}

func (s DescribeDBInstanceProxyConfigurationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceProxyConfigurationResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceProxyConfigurationResponseBody) SetAttacksProtectionConfiguration(v string) *DescribeDBInstanceProxyConfigurationResponseBody {
	s.AttacksProtectionConfiguration = &v
	return s
}

func (s *DescribeDBInstanceProxyConfigurationResponseBody) SetPersistentConnectionsConfiguration(v string) *DescribeDBInstanceProxyConfigurationResponseBody {
	s.PersistentConnectionsConfiguration = &v
	return s
}

func (s *DescribeDBInstanceProxyConfigurationResponseBody) SetRequestId(v string) *DescribeDBInstanceProxyConfigurationResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDBInstanceProxyConfigurationResponseBody) SetTransparentSwitchConfiguration(v string) *DescribeDBInstanceProxyConfigurationResponseBody {
	s.TransparentSwitchConfiguration = &v
	return s
}

type DescribeDBInstanceProxyConfigurationResponse struct {
	Headers    map[string]*string                                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDBInstanceProxyConfigurationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDBInstanceProxyConfigurationResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceProxyConfigurationResponse) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceProxyConfigurationResponse) SetHeaders(v map[string]*string) *DescribeDBInstanceProxyConfigurationResponse {
	s.Headers = v
	return s
}

func (s *DescribeDBInstanceProxyConfigurationResponse) SetStatusCode(v int32) *DescribeDBInstanceProxyConfigurationResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDBInstanceProxyConfigurationResponse) SetBody(v *DescribeDBInstanceProxyConfigurationResponseBody) *DescribeDBInstanceProxyConfigurationResponse {
	s.Body = v
	return s
}

type DescribeDBInstanceSSLRequest struct {
	// The instance ID. You can call the [DescribeDBInstances](~~610396~~) operation to query the ID of the instance.
	DBInstanceId         *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeDBInstanceSSLRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceSSLRequest) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceSSLRequest) SetDBInstanceId(v string) *DescribeDBInstanceSSLRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeDBInstanceSSLRequest) SetOwnerAccount(v string) *DescribeDBInstanceSSLRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeDBInstanceSSLRequest) SetOwnerId(v int64) *DescribeDBInstanceSSLRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeDBInstanceSSLRequest) SetResourceOwnerAccount(v string) *DescribeDBInstanceSSLRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeDBInstanceSSLRequest) SetResourceOwnerId(v int64) *DescribeDBInstanceSSLRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeDBInstanceSSLResponseBody struct {
	// The method that is used to verify the identities of clients. This parameter is supported only when the instance runs PostgreSQL with cloud disks. Valid values:
	//
	// *   **cert**
	// *   **perfer**
	// *   **verify-ca**
	// *   **verify-full** (supported only when the instance runs PostgreSQL 12 or later)
	ACL *string `json:"ACL,omitempty" xml:"ACL,omitempty"`
	// The type of the server certificate. This parameter is supported only when the instance runs PostgreSQL with cloud disks. Valid values:
	//
	// *   **aliyun**: a cloud certificate
	// *   **custom**: a custom certificate
	CAType *string `json:"CAType,omitempty" xml:"CAType,omitempty"`
	// The public key of the CA that issues client certificates. This parameter is supported only when the instance runs PostgreSQL with cloud disks.
	ClientCACert *string `json:"ClientCACert,omitempty" xml:"ClientCACert,omitempty"`
	// The time when the public key of the CA that issues client certificates expires. This parameter is supported only when the instance runs PostgreSQL with cloud disks. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC. This parameter is not supported now.
	ClientCACertExpireTime *string `json:"ClientCACertExpireTime,omitempty" xml:"ClientCACertExpireTime,omitempty"`
	// The certificate revocation list (CRL) that contains revoked client certificates. This parameter is supported only when the instance runs PostgreSQL with cloud disks.
	ClientCertRevocationList *string `json:"ClientCertRevocationList,omitempty" xml:"ClientCertRevocationList,omitempty"`
	// The endpoint that is protected by SSL encryption.
	ConnectionString *string `json:"ConnectionString,omitempty" xml:"ConnectionString,omitempty"`
	// The status of the SSL link. This parameter is supported only when the instance runs PostgreSQL with cloud disks. Valid values:
	//
	// *   **success**
	// *   **setting**
	// *   **failed**
	LastModifyStatus *string `json:"LastModifyStatus,omitempty" xml:"LastModifyStatus,omitempty"`
	// The reason why the SSL link stays in the current state. This parameter is supported only when the instance runs PostgreSQL with cloud disks.
	ModifyStatusReason *string `json:"ModifyStatusReason,omitempty" xml:"ModifyStatusReason,omitempty"`
	// The method that is used to verify the replication permission. This parameter is supported only when the instance runs PostgreSQL with cloud disks. Valid values:
	//
	// *   **cert**
	// *   **perfer**
	// *   **verify-ca**
	// *   **verify-full** (supported only when the instance runs PostgreSQL 12 or later)
	ReplicationACL *string `json:"ReplicationACL,omitempty" xml:"ReplicationACL,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the server certificate needs to be updated.
	//
	// *   Valid values for ApsaraDB RDS for MySQL instances and ApsaraDB RDS for SQL Server instances:
	//
	//     *   **No**
	//     *   **Yes**
	//
	// *   Valid values for ApsaraDB RDS for PostgreSQL instances:
	//
	//     *   **0**: no
	//     *   **1**: yes
	RequireUpdate *string `json:"RequireUpdate,omitempty" xml:"RequireUpdate,omitempty"`
	// The server certificate that needs to be updated. This parameter is supported only when the instance runs PostgreSQL with cloud disk.
	RequireUpdateItem *string `json:"RequireUpdateItem,omitempty" xml:"RequireUpdateItem,omitempty"`
	// The reason why the server certificate needs to be updated. This parameter is supported only when the instance runs PostgreSQL with cloud disks.
	RequireUpdateReason *string `json:"RequireUpdateReason,omitempty" xml:"RequireUpdateReason,omitempty"`
	// The time when the server certificate was created. This parameter is supported only when the instance runs PostgreSQL with cloud disks. In addition, this parameter is valid only when the CAType parameter value is aliyun.
	SSLCreateTime *string `json:"SSLCreateTime,omitempty" xml:"SSLCreateTime,omitempty"`
	// Indicates whether SSL encryption is enabled.
	//
	// *   Valid values for ApsaraDB RDS for MySQL instances and ApsaraDB RDS for SQL Server instances:
	//
	//     *   **Yes**
	//     *   **No**
	//
	// *   Valid values for ApsaraDB RDS for PostgreSQL instances:
	//
	//     *   **on**: enabled
	//     *   **off**: disabled
	SSLEnabled *string `json:"SSLEnabled,omitempty" xml:"SSLEnabled,omitempty"`
	// The time when the server certificate expires. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
	SSLExpireTime *string `json:"SSLExpireTime,omitempty" xml:"SSLExpireTime,omitempty"`
	// The URL of the certificate that is used to issue the server certificate. This parameter is supported only when the instance runs PostgreSQL with cloud disk.
	ServerCAUrl *string `json:"ServerCAUrl,omitempty" xml:"ServerCAUrl,omitempty"`
	// The content of the server certificate. This parameter is supported only when the instance runs PostgreSQL with cloud disks.
	ServerCert *string `json:"ServerCert,omitempty" xml:"ServerCert,omitempty"`
	// The private key of the server certificate. This parameter is supported only when the instance runs PostgreSQL with cloud disks.
	ServerKey *string `json:"ServerKey,omitempty" xml:"ServerKey,omitempty"`
}

func (s DescribeDBInstanceSSLResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceSSLResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceSSLResponseBody) SetACL(v string) *DescribeDBInstanceSSLResponseBody {
	s.ACL = &v
	return s
}

func (s *DescribeDBInstanceSSLResponseBody) SetCAType(v string) *DescribeDBInstanceSSLResponseBody {
	s.CAType = &v
	return s
}

func (s *DescribeDBInstanceSSLResponseBody) SetClientCACert(v string) *DescribeDBInstanceSSLResponseBody {
	s.ClientCACert = &v
	return s
}

func (s *DescribeDBInstanceSSLResponseBody) SetClientCACertExpireTime(v string) *DescribeDBInstanceSSLResponseBody {
	s.ClientCACertExpireTime = &v
	return s
}

func (s *DescribeDBInstanceSSLResponseBody) SetClientCertRevocationList(v string) *DescribeDBInstanceSSLResponseBody {
	s.ClientCertRevocationList = &v
	return s
}

func (s *DescribeDBInstanceSSLResponseBody) SetConnectionString(v string) *DescribeDBInstanceSSLResponseBody {
	s.ConnectionString = &v
	return s
}

func (s *DescribeDBInstanceSSLResponseBody) SetLastModifyStatus(v string) *DescribeDBInstanceSSLResponseBody {
	s.LastModifyStatus = &v
	return s
}

func (s *DescribeDBInstanceSSLResponseBody) SetModifyStatusReason(v string) *DescribeDBInstanceSSLResponseBody {
	s.ModifyStatusReason = &v
	return s
}

func (s *DescribeDBInstanceSSLResponseBody) SetReplicationACL(v string) *DescribeDBInstanceSSLResponseBody {
	s.ReplicationACL = &v
	return s
}

func (s *DescribeDBInstanceSSLResponseBody) SetRequestId(v string) *DescribeDBInstanceSSLResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDBInstanceSSLResponseBody) SetRequireUpdate(v string) *DescribeDBInstanceSSLResponseBody {
	s.RequireUpdate = &v
	return s
}

func (s *DescribeDBInstanceSSLResponseBody) SetRequireUpdateItem(v string) *DescribeDBInstanceSSLResponseBody {
	s.RequireUpdateItem = &v
	return s
}

func (s *DescribeDBInstanceSSLResponseBody) SetRequireUpdateReason(v string) *DescribeDBInstanceSSLResponseBody {
	s.RequireUpdateReason = &v
	return s
}

func (s *DescribeDBInstanceSSLResponseBody) SetSSLCreateTime(v string) *DescribeDBInstanceSSLResponseBody {
	s.SSLCreateTime = &v
	return s
}

func (s *DescribeDBInstanceSSLResponseBody) SetSSLEnabled(v string) *DescribeDBInstanceSSLResponseBody {
	s.SSLEnabled = &v
	return s
}

func (s *DescribeDBInstanceSSLResponseBody) SetSSLExpireTime(v string) *DescribeDBInstanceSSLResponseBody {
	s.SSLExpireTime = &v
	return s
}

func (s *DescribeDBInstanceSSLResponseBody) SetServerCAUrl(v string) *DescribeDBInstanceSSLResponseBody {
	s.ServerCAUrl = &v
	return s
}

func (s *DescribeDBInstanceSSLResponseBody) SetServerCert(v string) *DescribeDBInstanceSSLResponseBody {
	s.ServerCert = &v
	return s
}

func (s *DescribeDBInstanceSSLResponseBody) SetServerKey(v string) *DescribeDBInstanceSSLResponseBody {
	s.ServerKey = &v
	return s
}

type DescribeDBInstanceSSLResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDBInstanceSSLResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDBInstanceSSLResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceSSLResponse) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceSSLResponse) SetHeaders(v map[string]*string) *DescribeDBInstanceSSLResponse {
	s.Headers = v
	return s
}

func (s *DescribeDBInstanceSSLResponse) SetStatusCode(v int32) *DescribeDBInstanceSSLResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDBInstanceSSLResponse) SetBody(v *DescribeDBInstanceSSLResponseBody) *DescribeDBInstanceSSLResponse {
	s.Body = v
	return s
}

type DescribeDBInstanceTDERequest struct {
	// The instance ID. You can call the [DescribeDBInstances](~~610396~~) operation to query the instance ID.
	DBInstanceId         *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeDBInstanceTDERequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceTDERequest) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceTDERequest) SetDBInstanceId(v string) *DescribeDBInstanceTDERequest {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeDBInstanceTDERequest) SetOwnerAccount(v string) *DescribeDBInstanceTDERequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeDBInstanceTDERequest) SetOwnerId(v int64) *DescribeDBInstanceTDERequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeDBInstanceTDERequest) SetResourceOwnerAccount(v string) *DescribeDBInstanceTDERequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeDBInstanceTDERequest) SetResourceOwnerId(v int64) *DescribeDBInstanceTDERequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeDBInstanceTDEResponseBody struct {
	// The TDE status at the database level.
	//
	// >  If your instance runs SQL Server 2019 SE or SQL Server EE, you can specify whether to enable TDE at the database level when you enable TDE at the instance level.
	Databases *DescribeDBInstanceTDEResponseBodyDatabases `json:"Databases,omitempty" xml:"Databases,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The method that is used to generate the key for TDE at the instance level. Valid values:
	//
	// *   **Aliyun_Generate_Key**
	// *   **Customer_Provided_Key**
	// *   **Unknown**
	TDEMode *string `json:"TDEMode,omitempty" xml:"TDEMode,omitempty"`
	// The TDE status of the instance. Valid values:
	//
	// *   **Enabled**
	// *   **Disabled**
	TDEStatus *string `json:"TDEStatus,omitempty" xml:"TDEStatus,omitempty"`
}

func (s DescribeDBInstanceTDEResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceTDEResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceTDEResponseBody) SetDatabases(v *DescribeDBInstanceTDEResponseBodyDatabases) *DescribeDBInstanceTDEResponseBody {
	s.Databases = v
	return s
}

func (s *DescribeDBInstanceTDEResponseBody) SetRequestId(v string) *DescribeDBInstanceTDEResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDBInstanceTDEResponseBody) SetTDEMode(v string) *DescribeDBInstanceTDEResponseBody {
	s.TDEMode = &v
	return s
}

func (s *DescribeDBInstanceTDEResponseBody) SetTDEStatus(v string) *DescribeDBInstanceTDEResponseBody {
	s.TDEStatus = &v
	return s
}

type DescribeDBInstanceTDEResponseBodyDatabases struct {
	Database []*DescribeDBInstanceTDEResponseBodyDatabasesDatabase `json:"Database,omitempty" xml:"Database,omitempty" type:"Repeated"`
}

func (s DescribeDBInstanceTDEResponseBodyDatabases) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceTDEResponseBodyDatabases) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceTDEResponseBodyDatabases) SetDatabase(v []*DescribeDBInstanceTDEResponseBodyDatabasesDatabase) *DescribeDBInstanceTDEResponseBodyDatabases {
	s.Database = v
	return s
}

type DescribeDBInstanceTDEResponseBodyDatabasesDatabase struct {
	// The name of the database.
	DBName *string `json:"DBName,omitempty" xml:"DBName,omitempty"`
	// The TDE status at the database level. Valid values:
	//
	// *   **Enabled**
	// *   **Disabled**
	TDEStatus *string `json:"TDEStatus,omitempty" xml:"TDEStatus,omitempty"`
}

func (s DescribeDBInstanceTDEResponseBodyDatabasesDatabase) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceTDEResponseBodyDatabasesDatabase) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceTDEResponseBodyDatabasesDatabase) SetDBName(v string) *DescribeDBInstanceTDEResponseBodyDatabasesDatabase {
	s.DBName = &v
	return s
}

func (s *DescribeDBInstanceTDEResponseBodyDatabasesDatabase) SetTDEStatus(v string) *DescribeDBInstanceTDEResponseBodyDatabasesDatabase {
	s.TDEStatus = &v
	return s
}

type DescribeDBInstanceTDEResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDBInstanceTDEResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDBInstanceTDEResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstanceTDEResponse) GoString() string {
	return s.String()
}

func (s *DescribeDBInstanceTDEResponse) SetHeaders(v map[string]*string) *DescribeDBInstanceTDEResponse {
	s.Headers = v
	return s
}

func (s *DescribeDBInstanceTDEResponse) SetStatusCode(v int32) *DescribeDBInstanceTDEResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDBInstanceTDEResponse) SetBody(v *DescribeDBInstanceTDEResponseBody) *DescribeDBInstanceTDEResponse {
	s.Body = v
	return s
}

type DescribeDBInstancesRequest struct {
	// The RDS edition of the instance. Valid values:
	//
	// *   **Basic**: RDS Basic Edition
	// *   **HighAvailability**: RDS High-availability Edition
	// *   **cluster**: RDS Cluster Edition
	// *   **serverless_basic**: RDS Serverless Basic Edition
	Category *string `json:"Category,omitempty" xml:"Category,omitempty"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The connection mode of the instance. Valid values:
	//
	// *   **Standard**: standard mode
	// *   **Safe**: database proxy mode
	//
	// By default, this operation queries the instances that use any of the supported connection modes.
	ConnectionMode *string `json:"ConnectionMode,omitempty" xml:"ConnectionMode,omitempty"`
	// The endpoint of the instance. You must specify this parameter only when you want to query a single instance.
	ConnectionString *string `json:"ConnectionString,omitempty" xml:"ConnectionString,omitempty"`
	// The instance type of the instance. For information, see [Primary ApsaraDB RDS instance types](~~26312~~).
	DBInstanceClass *string `json:"DBInstanceClass,omitempty" xml:"DBInstanceClass,omitempty"`
	// The instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The status of the instance. For more information, see [Instance states](~~26315~~).
	DBInstanceStatus *string `json:"DBInstanceStatus,omitempty" xml:"DBInstanceStatus,omitempty"`
	// The role of the instance. Valid values:
	//
	// *   **Primary**: primary instance
	// *   **Readonly**: read-only instance
	// *   **Guard**: disaster recovery instance
	// *   **Temp**: temporary instance
	//
	// By default, this operation returns the instances that assume any of the supported roles.
	DBInstanceType *string `json:"DBInstanceType,omitempty" xml:"DBInstanceType,omitempty"`
	// The dedicated cluster ID.
	DedicatedHostGroupId *string `json:"DedicatedHostGroupId,omitempty" xml:"DedicatedHostGroupId,omitempty"`
	// The host ID of the instance in the dedicated cluster.
	DedicatedHostId *string `json:"DedicatedHostId,omitempty" xml:"DedicatedHostId,omitempty"`
	// The database engine of the instance. Valid values:
	//
	// *   **MySQL**
	// *   **SQLServer**
	// *   **PostgreSQL**
	// *   **MariaDB**
	//
	// By default, this operation returns the instances that run any of the supported database engines.
	Engine *string `json:"Engine,omitempty" xml:"Engine,omitempty"`
	// The database engine version.
	EngineVersion *string `json:"EngineVersion,omitempty" xml:"EngineVersion,omitempty"`
	// Specifies whether to query instances that have expired. Valid values:
	//
	// *   **True**: queries instances that have expired.
	// *   **False**: does not query instances that have expired.
	Expired *string `json:"Expired,omitempty" xml:"Expired,omitempty"`
	// The JSON string that consists of filter condition parameters and their values.
	Filter *string `json:"Filter,omitempty" xml:"Filter,omitempty"`
	// Specifies whether to return the RDS edition of the instance by using the Category parameter. Valid values:
	//
	// *   **0**: returns the RDS edition of the instance.
	// *   **1**: does not return the RDS edition of the instance.
	InstanceLevel *int32 `json:"InstanceLevel,omitempty" xml:"InstanceLevel,omitempty"`
	// The network type of the instance. Valid values:
	//
	// *   **VPC**
	// *   **Classic**
	//
	// By default, this operation returns the instances that reside in any of the supported network types.
	InstanceNetworkType *string `json:"InstanceNetworkType,omitempty" xml:"InstanceNetworkType,omitempty"`
	// The number of entries to return per page. Valid values: **1 to 100**.
	//
	// Default value: **30**.
	//
	// > If you specify this parameter, **PageSize** and **PageNumber** are unavailable.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The token that is used to display the next page. You must set this parameter to the value that is returned from the most recent call of the **DescribeDBInstances** operation for **NextToken**. If the returned entries are displayed on multiple pages, the next page can be displayed when you call this operation again with this parameter specified.
	NextToken    *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The page number. Valid values: any non-zero positive integer.
	//
	// Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Valid values: **1** to **100**.
	//
	// Default value: **30**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The billing method of the instance. Valid values:
	//
	// *   **Postpaid**: pay-as-you-go
	// *   **Prepaid**: subscription
	PayType *string `json:"PayType,omitempty" xml:"PayType,omitempty"`
	// The region ID. You can call the DescribeRegions operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The keyword that is used for fuzzy search. The keyword can be part of an instance ID or an instance description.
	SearchKey *string `json:"SearchKey,omitempty" xml:"SearchKey,omitempty"`
	// The tag that is added to the instance. Each tag is a key-value pair that consists of two fields: TagKey and TagValue. You can specify a maximum of five tags in the following format for each request: {"key1":"value1","key2":"value2"...}.
	Tags *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
	// The vSwitch ID.
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
	// The VPC ID.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
	// The zone ID of the instance.
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
	// A deprecated parameter. You do not need to configure this parameter.
	ProxyId *string `json:"proxyId,omitempty" xml:"proxyId,omitempty"`
}

func (s DescribeDBInstancesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstancesRequest) GoString() string {
	return s.String()
}

func (s *DescribeDBInstancesRequest) SetCategory(v string) *DescribeDBInstancesRequest {
	s.Category = &v
	return s
}

func (s *DescribeDBInstancesRequest) SetClientToken(v string) *DescribeDBInstancesRequest {
	s.ClientToken = &v
	return s
}

func (s *DescribeDBInstancesRequest) SetConnectionMode(v string) *DescribeDBInstancesRequest {
	s.ConnectionMode = &v
	return s
}

func (s *DescribeDBInstancesRequest) SetConnectionString(v string) *DescribeDBInstancesRequest {
	s.ConnectionString = &v
	return s
}

func (s *DescribeDBInstancesRequest) SetDBInstanceClass(v string) *DescribeDBInstancesRequest {
	s.DBInstanceClass = &v
	return s
}

func (s *DescribeDBInstancesRequest) SetDBInstanceId(v string) *DescribeDBInstancesRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeDBInstancesRequest) SetDBInstanceStatus(v string) *DescribeDBInstancesRequest {
	s.DBInstanceStatus = &v
	return s
}

func (s *DescribeDBInstancesRequest) SetDBInstanceType(v string) *DescribeDBInstancesRequest {
	s.DBInstanceType = &v
	return s
}

func (s *DescribeDBInstancesRequest) SetDedicatedHostGroupId(v string) *DescribeDBInstancesRequest {
	s.DedicatedHostGroupId = &v
	return s
}

func (s *DescribeDBInstancesRequest) SetDedicatedHostId(v string) *DescribeDBInstancesRequest {
	s.DedicatedHostId = &v
	return s
}

func (s *DescribeDBInstancesRequest) SetEngine(v string) *DescribeDBInstancesRequest {
	s.Engine = &v
	return s
}

func (s *DescribeDBInstancesRequest) SetEngineVersion(v string) *DescribeDBInstancesRequest {
	s.EngineVersion = &v
	return s
}

func (s *DescribeDBInstancesRequest) SetExpired(v string) *DescribeDBInstancesRequest {
	s.Expired = &v
	return s
}

func (s *DescribeDBInstancesRequest) SetFilter(v string) *DescribeDBInstancesRequest {
	s.Filter = &v
	return s
}

func (s *DescribeDBInstancesRequest) SetInstanceLevel(v int32) *DescribeDBInstancesRequest {
	s.InstanceLevel = &v
	return s
}

func (s *DescribeDBInstancesRequest) SetInstanceNetworkType(v string) *DescribeDBInstancesRequest {
	s.InstanceNetworkType = &v
	return s
}

func (s *DescribeDBInstancesRequest) SetMaxResults(v int32) *DescribeDBInstancesRequest {
	s.MaxResults = &v
	return s
}

func (s *DescribeDBInstancesRequest) SetNextToken(v string) *DescribeDBInstancesRequest {
	s.NextToken = &v
	return s
}

func (s *DescribeDBInstancesRequest) SetOwnerAccount(v string) *DescribeDBInstancesRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeDBInstancesRequest) SetOwnerId(v int64) *DescribeDBInstancesRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeDBInstancesRequest) SetPageNumber(v int32) *DescribeDBInstancesRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeDBInstancesRequest) SetPageSize(v int32) *DescribeDBInstancesRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeDBInstancesRequest) SetPayType(v string) *DescribeDBInstancesRequest {
	s.PayType = &v
	return s
}

func (s *DescribeDBInstancesRequest) SetRegionId(v string) *DescribeDBInstancesRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeDBInstancesRequest) SetResourceGroupId(v string) *DescribeDBInstancesRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeDBInstancesRequest) SetResourceOwnerAccount(v string) *DescribeDBInstancesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeDBInstancesRequest) SetResourceOwnerId(v int64) *DescribeDBInstancesRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeDBInstancesRequest) SetSearchKey(v string) *DescribeDBInstancesRequest {
	s.SearchKey = &v
	return s
}

func (s *DescribeDBInstancesRequest) SetTags(v string) *DescribeDBInstancesRequest {
	s.Tags = &v
	return s
}

func (s *DescribeDBInstancesRequest) SetVSwitchId(v string) *DescribeDBInstancesRequest {
	s.VSwitchId = &v
	return s
}

func (s *DescribeDBInstancesRequest) SetVpcId(v string) *DescribeDBInstancesRequest {
	s.VpcId = &v
	return s
}

func (s *DescribeDBInstancesRequest) SetZoneId(v string) *DescribeDBInstancesRequest {
	s.ZoneId = &v
	return s
}

func (s *DescribeDBInstancesRequest) SetProxyId(v string) *DescribeDBInstancesRequest {
	s.ProxyId = &v
	return s
}

type DescribeDBInstancesResponseBody struct {
	// The details of the instance.
	Items *DescribeDBInstancesResponseBodyItems `json:"Items,omitempty" xml:"Items,omitempty" type:"Struct"`
	// The token that is used to display the next page. If the returned entries are displayed on multiple pages, the next page can be displayed when you call this operation again with **NextToken** specified.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The page number of the returned page.
	//
	// > If you specify **MaxResults** or **NextToken**, only the value **1** is returned. You can ignore the value 1.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned on the current page.
	PageRecordCount *int32 `json:"PageRecordCount,omitempty" xml:"PageRecordCount,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	//
	// > If you specify **MaxResults** or **NextToken**, only the number of entries on the current page is returned. You can ignore the number.
	TotalRecordCount *int32 `json:"TotalRecordCount,omitempty" xml:"TotalRecordCount,omitempty"`
}

func (s DescribeDBInstancesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstancesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDBInstancesResponseBody) SetItems(v *DescribeDBInstancesResponseBodyItems) *DescribeDBInstancesResponseBody {
	s.Items = v
	return s
}

func (s *DescribeDBInstancesResponseBody) SetNextToken(v string) *DescribeDBInstancesResponseBody {
	s.NextToken = &v
	return s
}

func (s *DescribeDBInstancesResponseBody) SetPageNumber(v int32) *DescribeDBInstancesResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeDBInstancesResponseBody) SetPageRecordCount(v int32) *DescribeDBInstancesResponseBody {
	s.PageRecordCount = &v
	return s
}

func (s *DescribeDBInstancesResponseBody) SetRequestId(v string) *DescribeDBInstancesResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDBInstancesResponseBody) SetTotalRecordCount(v int32) *DescribeDBInstancesResponseBody {
	s.TotalRecordCount = &v
	return s
}

type DescribeDBInstancesResponseBodyItems struct {
	DBInstance []*DescribeDBInstancesResponseBodyItemsDBInstance `json:"DBInstance,omitempty" xml:"DBInstance,omitempty" type:"Repeated"`
}

func (s DescribeDBInstancesResponseBodyItems) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstancesResponseBodyItems) GoString() string {
	return s.String()
}

func (s *DescribeDBInstancesResponseBodyItems) SetDBInstance(v []*DescribeDBInstancesResponseBodyItemsDBInstance) *DescribeDBInstancesResponseBodyItems {
	s.DBInstance = v
	return s
}

type DescribeDBInstancesResponseBodyItemsDBInstance struct {
	// Indicates whether the buffer pool extension (BPE) feature is enabled. Valid values:
	//
	// *   **1**
	// *   **0**
	BpeEnabled *string `json:"BpeEnabled,omitempty" xml:"BpeEnabled,omitempty"`
	// Indicates whether the I/O burst feature is enabled. Valid values:
	//
	// *   **true**
	// *   **false**
	BurstingEnabled *bool `json:"BurstingEnabled,omitempty" xml:"BurstingEnabled,omitempty"`
	// The RDS edition of the instance. Valid values:
	//
	// *   **Basic**: RDS Basic Edition
	// *   **HighAvailability**: RDS High-availability Edition
	// *   **Finance**: RDS Enterprise Edition
	//
	// >  This parameter is returned only when the **InstanceLevel** parameter is set to **1**.
	Category *string `json:"Category,omitempty" xml:"Category,omitempty"`
	// The connection mode of the instance. Valid values:
	//
	// *   **Standard**: standard mode
	// *   **Safe**: database proxy mode
	ConnectionMode *string `json:"ConnectionMode,omitempty" xml:"ConnectionMode,omitempty"`
	// The endpoint of the instance.
	ConnectionString *string `json:"ConnectionString,omitempty" xml:"ConnectionString,omitempty"`
	// The creation time of the instance. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The instance type of the instance. For information, see [Primary ApsaraDB RDS instance types](~~26312~~).
	DBInstanceClass *string `json:"DBInstanceClass,omitempty" xml:"DBInstanceClass,omitempty"`
	// The instance description.
	DBInstanceDescription *string `json:"DBInstanceDescription,omitempty" xml:"DBInstanceDescription,omitempty"`
	// The instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The type of the network connection to the instance. Valid values:
	//
	// *   **Internet**
	// *   **Intranet**
	DBInstanceNetType *string `json:"DBInstanceNetType,omitempty" xml:"DBInstanceNetType,omitempty"`
	// The status of the instance. For more information, see [Instance states](~~26315~~).
	DBInstanceStatus *string `json:"DBInstanceStatus,omitempty" xml:"DBInstanceStatus,omitempty"`
	// The storage type of the instance.
	DBInstanceStorageType *string `json:"DBInstanceStorageType,omitempty" xml:"DBInstanceStorageType,omitempty"`
	// The role of the instance. Valid values:
	//
	// *   **Primary**: primary instance
	// *   **Readonly**: read-only instance
	// *   **Guard**: disaster recovery instance
	// *   **Temp**: temporary instance
	DBInstanceType *string `json:"DBInstanceType,omitempty" xml:"DBInstanceType,omitempty"`
	// The ID of the dedicated cluster.
	DedicatedHostGroupId *string `json:"DedicatedHostGroupId,omitempty" xml:"DedicatedHostGroupId,omitempty"`
	// The name of the dedicated cluster to which the instance belongs.
	DedicatedHostGroupName *string `json:"DedicatedHostGroupName,omitempty" xml:"DedicatedHostGroupName,omitempty"`
	// The ID of the host on which the logger instance resides.
	DedicatedHostIdForLog *string `json:"DedicatedHostIdForLog,omitempty" xml:"DedicatedHostIdForLog,omitempty"`
	// The ID of the host on which the primary instance resides.
	DedicatedHostIdForMaster *string `json:"DedicatedHostIdForMaster,omitempty" xml:"DedicatedHostIdForMaster,omitempty"`
	// The ID of the host on which the secondary instance resides.
	DedicatedHostIdForSlave *string `json:"DedicatedHostIdForSlave,omitempty" xml:"DedicatedHostIdForSlave,omitempty"`
	// The name of the host on which the logger instance resides.
	DedicatedHostNameForLog *string `json:"DedicatedHostNameForLog,omitempty" xml:"DedicatedHostNameForLog,omitempty"`
	// The name of the host on which the primary instance resides.
	DedicatedHostNameForMaster *string `json:"DedicatedHostNameForMaster,omitempty" xml:"DedicatedHostNameForMaster,omitempty"`
	// The name of the host on which the secondary instance resides.
	DedicatedHostNameForSlave *string `json:"DedicatedHostNameForSlave,omitempty" xml:"DedicatedHostNameForSlave,omitempty"`
	// The zone ID of the host on which the logger instance resides.
	DedicatedHostZoneIdForLog *string `json:"DedicatedHostZoneIdForLog,omitempty" xml:"DedicatedHostZoneIdForLog,omitempty"`
	// The zone ID of the host on which the primary instance resides.
	DedicatedHostZoneIdForMaster *string `json:"DedicatedHostZoneIdForMaster,omitempty" xml:"DedicatedHostZoneIdForMaster,omitempty"`
	// The zone ID of the host on which the secondary instance resides.
	DedicatedHostZoneIdForSlave *string `json:"DedicatedHostZoneIdForSlave,omitempty" xml:"DedicatedHostZoneIdForSlave,omitempty"`
	// Indicates whether the release protection feature is enabled for the instance. Valid values:
	//
	// *   **true**
	// *   **false**
	DeletionProtection *bool `json:"DeletionProtection,omitempty" xml:"DeletionProtection,omitempty"`
	// The time when the instance was destroyed. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	DestroyTime *string `json:"DestroyTime,omitempty" xml:"DestroyTime,omitempty"`
	// The database engine of the instance.
	Engine *string `json:"Engine,omitempty" xml:"Engine,omitempty"`
	// The database engine version.
	EngineVersion *string `json:"EngineVersion,omitempty" xml:"EngineVersion,omitempty"`
	// The expiration time of the instance. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// >  Pay-as-you-go instances never expire.
	ExpireTime *string `json:"ExpireTime,omitempty" xml:"ExpireTime,omitempty"`
	// The name of the dedicated cluster to which the instance belongs. This parameter is returned only when the instance is created in an ApsaraDB MyBase cluster that runs MySQL on Standard Edition.
	GeneralGroupName *string `json:"GeneralGroupName,omitempty" xml:"GeneralGroupName,omitempty"`
	// The ID of the disaster recovery instance. This parameter is returned only when the instance is a primary instance and has a disaster recovery instance.
	GuardDBInstanceId *string `json:"GuardDBInstanceId,omitempty" xml:"GuardDBInstanceId,omitempty"`
	// The network type of the instance. Valid values:
	//
	// *   **Classic**
	// *   **VPC**
	InstanceNetworkType *string `json:"InstanceNetworkType,omitempty" xml:"InstanceNetworkType,omitempty"`
	// The lock mode of the instance. Valid values:
	//
	// *   **Unlock**: The instance is not locked.
	// *   **ManualLock**: The instance is manually locked.
	// *   **LockByExpiration**: The instance is automatically locked due to instance expiration.
	// *   **LockByRestoration**: The instance is automatically locked before the instance is rolled back.
	// *   **LockByDiskQuota**: The instance is automatically locked due to exhausted storage capacity.
	// *   **Released**: The instance is released. After an instance is released, the instance cannot be unlocked. You can only restore the backup data of the instance to a new instance. This process requires a long period of time.
	LockMode *string `json:"LockMode,omitempty" xml:"LockMode,omitempty"`
	// The reason why the instance was locked.
	LockReason *string `json:"LockReason,omitempty" xml:"LockReason,omitempty"`
	// The ID of the primary instance. If the value of this parameter is null, the instance is a primary instance.
	MasterInstanceId *string `json:"MasterInstanceId,omitempty" xml:"MasterInstanceId,omitempty"`
	// Indicates whether the multi-zone deployment method is used for the instance. Valid values:
	//
	// *   **true**
	// *   **false**
	//
	// >  If the multi-zone deployment method is used for the instance, the zone ID of the instance contains MAZ. Example: `cn-hangzhou-MAZ10(h,i)`.
	MutriORsignle *bool `json:"MutriORsignle,omitempty" xml:"MutriORsignle,omitempty"`
	// The billing method of the instance. Valid values:
	//
	// *   **Postpaid**: pay-as-you-go
	// *   **Prepaid**: subscription
	PayType *string `json:"PayType,omitempty" xml:"PayType,omitempty"`
	// An array that consists of the IDs of the read-only instances that are attached to the instance. This parameter is returned only when the instance is a primary instance and has read-only instances.
	ReadOnlyDBInstanceIds *DescribeDBInstancesResponseBodyItemsDBInstanceReadOnlyDBInstanceIds `json:"ReadOnlyDBInstanceIds,omitempty" xml:"ReadOnlyDBInstanceIds,omitempty" type:"Struct"`
	// The region ID of the instance.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The resource group ID.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// Indicates whether the instance supports weight-based switchovers for high availability. This parameter is returned only when the instance is created in an ApsaraDB MyBase cluster that runs MySQL on Standard Edition. Valid values:
	//
	// *   **100**: The instance supports weight-based switchovers for high availability.
	// *   **0**: The instance does not support weight-based switchovers for high availability.
	SwitchWeight *int32 `json:"SwitchWeight,omitempty" xml:"SwitchWeight,omitempty"`
	// The ID of the temporary instance. This parameter is returned only when the instance is a primary instance and has a temporary instance.
	TempDBInstanceId *string `json:"TempDBInstanceId,omitempty" xml:"TempDBInstanceId,omitempty"`
	// The information about the exception that is detected on the instance. This parameter is returned only when the instance is created in an ApsaraDB MyBase cluster that runs MySQL on Standard Edition.
	Tips *string `json:"Tips,omitempty" xml:"Tips,omitempty"`
	// The severity level of the exception that is detected on the instance. This parameter is returned only when the instance is created in an ApsaraDB MyBase cluster that runs MySQL on Standard Edition. Valid values:
	//
	// *   **1**: The instance is normal.
	// *   **2**: The specifications of the read-only instances do not match the specifications of the primary instance, and instance performance may be affected. You must adjust the specifications of these instances based on your business requirements.
	TipsLevel *int32 `json:"TipsLevel,omitempty" xml:"TipsLevel,omitempty"`
	// The vSwitch ID.
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
	// The VPC ID.
	VpcCloudInstanceId *string `json:"VpcCloudInstanceId,omitempty" xml:"VpcCloudInstanceId,omitempty"`
	// The virtual private cloud (VPC) ID of the instance.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
	// The VPC name.
	VpcName *string `json:"VpcName,omitempty" xml:"VpcName,omitempty"`
	// The zone ID.
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
}

func (s DescribeDBInstancesResponseBodyItemsDBInstance) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstancesResponseBodyItemsDBInstance) GoString() string {
	return s.String()
}

func (s *DescribeDBInstancesResponseBodyItemsDBInstance) SetBpeEnabled(v string) *DescribeDBInstancesResponseBodyItemsDBInstance {
	s.BpeEnabled = &v
	return s
}

func (s *DescribeDBInstancesResponseBodyItemsDBInstance) SetBurstingEnabled(v bool) *DescribeDBInstancesResponseBodyItemsDBInstance {
	s.BurstingEnabled = &v
	return s
}

func (s *DescribeDBInstancesResponseBodyItemsDBInstance) SetCategory(v string) *DescribeDBInstancesResponseBodyItemsDBInstance {
	s.Category = &v
	return s
}

func (s *DescribeDBInstancesResponseBodyItemsDBInstance) SetConnectionMode(v string) *DescribeDBInstancesResponseBodyItemsDBInstance {
	s.ConnectionMode = &v
	return s
}

func (s *DescribeDBInstancesResponseBodyItemsDBInstance) SetConnectionString(v string) *DescribeDBInstancesResponseBodyItemsDBInstance {
	s.ConnectionString = &v
	return s
}

func (s *DescribeDBInstancesResponseBodyItemsDBInstance) SetCreateTime(v string) *DescribeDBInstancesResponseBodyItemsDBInstance {
	s.CreateTime = &v
	return s
}

func (s *DescribeDBInstancesResponseBodyItemsDBInstance) SetDBInstanceClass(v string) *DescribeDBInstancesResponseBodyItemsDBInstance {
	s.DBInstanceClass = &v
	return s
}

func (s *DescribeDBInstancesResponseBodyItemsDBInstance) SetDBInstanceDescription(v string) *DescribeDBInstancesResponseBodyItemsDBInstance {
	s.DBInstanceDescription = &v
	return s
}

func (s *DescribeDBInstancesResponseBodyItemsDBInstance) SetDBInstanceId(v string) *DescribeDBInstancesResponseBodyItemsDBInstance {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeDBInstancesResponseBodyItemsDBInstance) SetDBInstanceNetType(v string) *DescribeDBInstancesResponseBodyItemsDBInstance {
	s.DBInstanceNetType = &v
	return s
}

func (s *DescribeDBInstancesResponseBodyItemsDBInstance) SetDBInstanceStatus(v string) *DescribeDBInstancesResponseBodyItemsDBInstance {
	s.DBInstanceStatus = &v
	return s
}

func (s *DescribeDBInstancesResponseBodyItemsDBInstance) SetDBInstanceStorageType(v string) *DescribeDBInstancesResponseBodyItemsDBInstance {
	s.DBInstanceStorageType = &v
	return s
}

func (s *DescribeDBInstancesResponseBodyItemsDBInstance) SetDBInstanceType(v string) *DescribeDBInstancesResponseBodyItemsDBInstance {
	s.DBInstanceType = &v
	return s
}

func (s *DescribeDBInstancesResponseBodyItemsDBInstance) SetDedicatedHostGroupId(v string) *DescribeDBInstancesResponseBodyItemsDBInstance {
	s.DedicatedHostGroupId = &v
	return s
}

func (s *DescribeDBInstancesResponseBodyItemsDBInstance) SetDedicatedHostGroupName(v string) *DescribeDBInstancesResponseBodyItemsDBInstance {
	s.DedicatedHostGroupName = &v
	return s
}

func (s *DescribeDBInstancesResponseBodyItemsDBInstance) SetDedicatedHostIdForLog(v string) *DescribeDBInstancesResponseBodyItemsDBInstance {
	s.DedicatedHostIdForLog = &v
	return s
}

func (s *DescribeDBInstancesResponseBodyItemsDBInstance) SetDedicatedHostIdForMaster(v string) *DescribeDBInstancesResponseBodyItemsDBInstance {
	s.DedicatedHostIdForMaster = &v
	return s
}

func (s *DescribeDBInstancesResponseBodyItemsDBInstance) SetDedicatedHostIdForSlave(v string) *DescribeDBInstancesResponseBodyItemsDBInstance {
	s.DedicatedHostIdForSlave = &v
	return s
}

func (s *DescribeDBInstancesResponseBodyItemsDBInstance) SetDedicatedHostNameForLog(v string) *DescribeDBInstancesResponseBodyItemsDBInstance {
	s.DedicatedHostNameForLog = &v
	return s
}

func (s *DescribeDBInstancesResponseBodyItemsDBInstance) SetDedicatedHostNameForMaster(v string) *DescribeDBInstancesResponseBodyItemsDBInstance {
	s.DedicatedHostNameForMaster = &v
	return s
}

func (s *DescribeDBInstancesResponseBodyItemsDBInstance) SetDedicatedHostNameForSlave(v string) *DescribeDBInstancesResponseBodyItemsDBInstance {
	s.DedicatedHostNameForSlave = &v
	return s
}

func (s *DescribeDBInstancesResponseBodyItemsDBInstance) SetDedicatedHostZoneIdForLog(v string) *DescribeDBInstancesResponseBodyItemsDBInstance {
	s.DedicatedHostZoneIdForLog = &v
	return s
}

func (s *DescribeDBInstancesResponseBodyItemsDBInstance) SetDedicatedHostZoneIdForMaster(v string) *DescribeDBInstancesResponseBodyItemsDBInstance {
	s.DedicatedHostZoneIdForMaster = &v
	return s
}

func (s *DescribeDBInstancesResponseBodyItemsDBInstance) SetDedicatedHostZoneIdForSlave(v string) *DescribeDBInstancesResponseBodyItemsDBInstance {
	s.DedicatedHostZoneIdForSlave = &v
	return s
}

func (s *DescribeDBInstancesResponseBodyItemsDBInstance) SetDeletionProtection(v bool) *DescribeDBInstancesResponseBodyItemsDBInstance {
	s.DeletionProtection = &v
	return s
}

func (s *DescribeDBInstancesResponseBodyItemsDBInstance) SetDestroyTime(v string) *DescribeDBInstancesResponseBodyItemsDBInstance {
	s.DestroyTime = &v
	return s
}

func (s *DescribeDBInstancesResponseBodyItemsDBInstance) SetEngine(v string) *DescribeDBInstancesResponseBodyItemsDBInstance {
	s.Engine = &v
	return s
}

func (s *DescribeDBInstancesResponseBodyItemsDBInstance) SetEngineVersion(v string) *DescribeDBInstancesResponseBodyItemsDBInstance {
	s.EngineVersion = &v
	return s
}

func (s *DescribeDBInstancesResponseBodyItemsDBInstance) SetExpireTime(v string) *DescribeDBInstancesResponseBodyItemsDBInstance {
	s.ExpireTime = &v
	return s
}

func (s *DescribeDBInstancesResponseBodyItemsDBInstance) SetGeneralGroupName(v string) *DescribeDBInstancesResponseBodyItemsDBInstance {
	s.GeneralGroupName = &v
	return s
}

func (s *DescribeDBInstancesResponseBodyItemsDBInstance) SetGuardDBInstanceId(v string) *DescribeDBInstancesResponseBodyItemsDBInstance {
	s.GuardDBInstanceId = &v
	return s
}

func (s *DescribeDBInstancesResponseBodyItemsDBInstance) SetInstanceNetworkType(v string) *DescribeDBInstancesResponseBodyItemsDBInstance {
	s.InstanceNetworkType = &v
	return s
}

func (s *DescribeDBInstancesResponseBodyItemsDBInstance) SetLockMode(v string) *DescribeDBInstancesResponseBodyItemsDBInstance {
	s.LockMode = &v
	return s
}

func (s *DescribeDBInstancesResponseBodyItemsDBInstance) SetLockReason(v string) *DescribeDBInstancesResponseBodyItemsDBInstance {
	s.LockReason = &v
	return s
}

func (s *DescribeDBInstancesResponseBodyItemsDBInstance) SetMasterInstanceId(v string) *DescribeDBInstancesResponseBodyItemsDBInstance {
	s.MasterInstanceId = &v
	return s
}

func (s *DescribeDBInstancesResponseBodyItemsDBInstance) SetMutriORsignle(v bool) *DescribeDBInstancesResponseBodyItemsDBInstance {
	s.MutriORsignle = &v
	return s
}

func (s *DescribeDBInstancesResponseBodyItemsDBInstance) SetPayType(v string) *DescribeDBInstancesResponseBodyItemsDBInstance {
	s.PayType = &v
	return s
}

func (s *DescribeDBInstancesResponseBodyItemsDBInstance) SetReadOnlyDBInstanceIds(v *DescribeDBInstancesResponseBodyItemsDBInstanceReadOnlyDBInstanceIds) *DescribeDBInstancesResponseBodyItemsDBInstance {
	s.ReadOnlyDBInstanceIds = v
	return s
}

func (s *DescribeDBInstancesResponseBodyItemsDBInstance) SetRegionId(v string) *DescribeDBInstancesResponseBodyItemsDBInstance {
	s.RegionId = &v
	return s
}

func (s *DescribeDBInstancesResponseBodyItemsDBInstance) SetResourceGroupId(v string) *DescribeDBInstancesResponseBodyItemsDBInstance {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeDBInstancesResponseBodyItemsDBInstance) SetSwitchWeight(v int32) *DescribeDBInstancesResponseBodyItemsDBInstance {
	s.SwitchWeight = &v
	return s
}

func (s *DescribeDBInstancesResponseBodyItemsDBInstance) SetTempDBInstanceId(v string) *DescribeDBInstancesResponseBodyItemsDBInstance {
	s.TempDBInstanceId = &v
	return s
}

func (s *DescribeDBInstancesResponseBodyItemsDBInstance) SetTips(v string) *DescribeDBInstancesResponseBodyItemsDBInstance {
	s.Tips = &v
	return s
}

func (s *DescribeDBInstancesResponseBodyItemsDBInstance) SetTipsLevel(v int32) *DescribeDBInstancesResponseBodyItemsDBInstance {
	s.TipsLevel = &v
	return s
}

func (s *DescribeDBInstancesResponseBodyItemsDBInstance) SetVSwitchId(v string) *DescribeDBInstancesResponseBodyItemsDBInstance {
	s.VSwitchId = &v
	return s
}

func (s *DescribeDBInstancesResponseBodyItemsDBInstance) SetVpcCloudInstanceId(v string) *DescribeDBInstancesResponseBodyItemsDBInstance {
	s.VpcCloudInstanceId = &v
	return s
}

func (s *DescribeDBInstancesResponseBodyItemsDBInstance) SetVpcId(v string) *DescribeDBInstancesResponseBodyItemsDBInstance {
	s.VpcId = &v
	return s
}

func (s *DescribeDBInstancesResponseBodyItemsDBInstance) SetVpcName(v string) *DescribeDBInstancesResponseBodyItemsDBInstance {
	s.VpcName = &v
	return s
}

func (s *DescribeDBInstancesResponseBodyItemsDBInstance) SetZoneId(v string) *DescribeDBInstancesResponseBodyItemsDBInstance {
	s.ZoneId = &v
	return s
}

type DescribeDBInstancesResponseBodyItemsDBInstanceReadOnlyDBInstanceIds struct {
	ReadOnlyDBInstanceId []*DescribeDBInstancesResponseBodyItemsDBInstanceReadOnlyDBInstanceIdsReadOnlyDBInstanceId `json:"ReadOnlyDBInstanceId,omitempty" xml:"ReadOnlyDBInstanceId,omitempty" type:"Repeated"`
}

func (s DescribeDBInstancesResponseBodyItemsDBInstanceReadOnlyDBInstanceIds) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstancesResponseBodyItemsDBInstanceReadOnlyDBInstanceIds) GoString() string {
	return s.String()
}

func (s *DescribeDBInstancesResponseBodyItemsDBInstanceReadOnlyDBInstanceIds) SetReadOnlyDBInstanceId(v []*DescribeDBInstancesResponseBodyItemsDBInstanceReadOnlyDBInstanceIdsReadOnlyDBInstanceId) *DescribeDBInstancesResponseBodyItemsDBInstanceReadOnlyDBInstanceIds {
	s.ReadOnlyDBInstanceId = v
	return s
}

type DescribeDBInstancesResponseBodyItemsDBInstanceReadOnlyDBInstanceIdsReadOnlyDBInstanceId struct {
	// The ID of the read-only instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
}

func (s DescribeDBInstancesResponseBodyItemsDBInstanceReadOnlyDBInstanceIdsReadOnlyDBInstanceId) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstancesResponseBodyItemsDBInstanceReadOnlyDBInstanceIdsReadOnlyDBInstanceId) GoString() string {
	return s.String()
}

func (s *DescribeDBInstancesResponseBodyItemsDBInstanceReadOnlyDBInstanceIdsReadOnlyDBInstanceId) SetDBInstanceId(v string) *DescribeDBInstancesResponseBodyItemsDBInstanceReadOnlyDBInstanceIdsReadOnlyDBInstanceId {
	s.DBInstanceId = &v
	return s
}

type DescribeDBInstancesResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDBInstancesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDBInstancesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstancesResponse) GoString() string {
	return s.String()
}

func (s *DescribeDBInstancesResponse) SetHeaders(v map[string]*string) *DescribeDBInstancesResponse {
	s.Headers = v
	return s
}

func (s *DescribeDBInstancesResponse) SetStatusCode(v int32) *DescribeDBInstancesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDBInstancesResponse) SetBody(v *DescribeDBInstancesResponseBody) *DescribeDBInstancesResponse {
	s.Body = v
	return s
}

type DescribeDBInstancesAsCsvRequest struct {
	// A deprecated parameter. You do not need to configure this parameter.
	CachedAsync *bool `json:"CachedAsync,omitempty" xml:"CachedAsync,omitempty"`
	// The instance ID. You can call the [DescribeDBInstances](~~610396~~) operation to query the ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// A deprecated parameter. You do not need to configure this parameter.
	ExportKey *string `json:"ExportKey,omitempty" xml:"ExportKey,omitempty"`
	OwnerId   *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID. You can call the [DescribeRegions](~~610399~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeDBInstancesAsCsvRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstancesAsCsvRequest) GoString() string {
	return s.String()
}

func (s *DescribeDBInstancesAsCsvRequest) SetCachedAsync(v bool) *DescribeDBInstancesAsCsvRequest {
	s.CachedAsync = &v
	return s
}

func (s *DescribeDBInstancesAsCsvRequest) SetDBInstanceId(v string) *DescribeDBInstancesAsCsvRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeDBInstancesAsCsvRequest) SetExportKey(v string) *DescribeDBInstancesAsCsvRequest {
	s.ExportKey = &v
	return s
}

func (s *DescribeDBInstancesAsCsvRequest) SetOwnerId(v int64) *DescribeDBInstancesAsCsvRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeDBInstancesAsCsvRequest) SetRegionId(v string) *DescribeDBInstancesAsCsvRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeDBInstancesAsCsvRequest) SetResourceGroupId(v string) *DescribeDBInstancesAsCsvRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeDBInstancesAsCsvRequest) SetResourceOwnerAccount(v string) *DescribeDBInstancesAsCsvRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeDBInstancesAsCsvRequest) SetResourceOwnerId(v int64) *DescribeDBInstancesAsCsvRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeDBInstancesAsCsvResponseBody struct {
	// An array that consists of the fields in **DBInstanceAttribute**.
	Items *DescribeDBInstancesAsCsvResponseBodyItems `json:"Items,omitempty" xml:"Items,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDBInstancesAsCsvResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstancesAsCsvResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDBInstancesAsCsvResponseBody) SetItems(v *DescribeDBInstancesAsCsvResponseBodyItems) *DescribeDBInstancesAsCsvResponseBody {
	s.Items = v
	return s
}

func (s *DescribeDBInstancesAsCsvResponseBody) SetRequestId(v string) *DescribeDBInstancesAsCsvResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDBInstancesAsCsvResponseBodyItems struct {
	DBInstanceAttribute []*DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute `json:"DBInstanceAttribute,omitempty" xml:"DBInstanceAttribute,omitempty" type:"Repeated"`
}

func (s DescribeDBInstancesAsCsvResponseBodyItems) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstancesAsCsvResponseBodyItems) GoString() string {
	return s.String()
}

func (s *DescribeDBInstancesAsCsvResponseBodyItems) SetDBInstanceAttribute(v []*DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute) *DescribeDBInstancesAsCsvResponseBodyItems {
	s.DBInstanceAttribute = v
	return s
}

type DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute struct {
	// The maximum number of accounts.
	AccountMaxQuantity *int32 `json:"AccountMaxQuantity,omitempty" xml:"AccountMaxQuantity,omitempty"`
	// The type of the account.
	AccountType *string `json:"AccountType,omitempty" xml:"AccountType,omitempty"`
	// The service availability of the instance in percentage.
	AvailabilityValue *string `json:"AvailabilityValue,omitempty" xml:"AvailabilityValue,omitempty"`
	// The category of the instance.
	Category *string `json:"Category,omitempty" xml:"Category,omitempty"`
	// The connection mode of the instance. Valid values:
	//
	// *   **Performance**: standard mode.
	// *   **Safety**: safe mode.
	ConnectionMode *string `json:"ConnectionMode,omitempty" xml:"ConnectionMode,omitempty"`
	// The internal endpoint of the instance.
	ConnectionString *string `json:"ConnectionString,omitempty" xml:"ConnectionString,omitempty"`
	// The creation time.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The number of CPU cores.
	DBInstanceCPU *string `json:"DBInstanceCPU,omitempty" xml:"DBInstanceCPU,omitempty"`
	// The instance type of the instance.
	DBInstanceClass *string `json:"DBInstanceClass,omitempty" xml:"DBInstanceClass,omitempty"`
	// The instance family.
	DBInstanceClassType *string `json:"DBInstanceClassType,omitempty" xml:"DBInstanceClassType,omitempty"`
	// The description of the instance.
	DBInstanceDescription *string `json:"DBInstanceDescription,omitempty" xml:"DBInstanceDescription,omitempty"`
	// The instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The memory capacity of the instance. Unit: MB.
	DBInstanceMemory *int64 `json:"DBInstanceMemory,omitempty" xml:"DBInstanceMemory,omitempty"`
	// The network type of the instance. Valid values:
	//
	// *   **Internet**: Internet
	// *   **Intranet**: internal network
	DBInstanceNetType *string `json:"DBInstanceNetType,omitempty" xml:"DBInstanceNetType,omitempty"`
	// The status of the instance.
	DBInstanceStatus *string `json:"DBInstanceStatus,omitempty" xml:"DBInstanceStatus,omitempty"`
	// The storage capacity of the instance. Unit: GB.
	DBInstanceStorage *int32 `json:"DBInstanceStorage,omitempty" xml:"DBInstanceStorage,omitempty"`
	// The type of the instance. Valid values:
	//
	// *   **Primary**: primary instance
	// *   **Readonly**: read-only instance
	// *   **Guard**: disaster recovery instance
	// *   **Temp**: temporary instance
	DBInstanceType *string `json:"DBInstanceType,omitempty" xml:"DBInstanceType,omitempty"`
	// The maximum number of databases that can be created on the instance.
	DBMaxQuantity *int32 `json:"DBMaxQuantity,omitempty" xml:"DBMaxQuantity,omitempty"`
	// The database engine of the instance.
	Engine *string `json:"Engine,omitempty" xml:"Engine,omitempty"`
	// The engine version of the instance.
	EngineVersion *string `json:"EngineVersion,omitempty" xml:"EngineVersion,omitempty"`
	// The expiration time.
	ExpireTime *string `json:"ExpireTime,omitempty" xml:"ExpireTime,omitempty"`
	// A deprecated parameter. You do not need to configure this parameter.
	ExportKey *string `json:"ExportKey,omitempty" xml:"ExportKey,omitempty"`
	// The ID of the disaster recovery instance that is attached to the instance.
	GuardDBInstanceId *string `json:"GuardDBInstanceId,omitempty" xml:"GuardDBInstanceId,omitempty"`
	// The ID of the instance from which incremental data comes. The incremental data of a disaster recovery instance or read-only instance comes from its primary instance. If this parameter is not returned, the instance is a primary instance.
	IncrementSourceDBInstanceId *string `json:"IncrementSourceDBInstanceId,omitempty" xml:"IncrementSourceDBInstanceId,omitempty"`
	// The network type.
	InstanceNetworkType *string `json:"InstanceNetworkType,omitempty" xml:"InstanceNetworkType,omitempty"`
	// The lock mode of the instance.
	LockMode *string `json:"LockMode,omitempty" xml:"LockMode,omitempty"`
	// The reason why the instance was locked.
	LockReason *string `json:"LockReason,omitempty" xml:"LockReason,omitempty"`
	// The maintenance window of the instance. The time is displayed in UTC. Take note that the maintenance window that is displayed in the ApsaraDB RDS console is equal to the value of this parameter plus 8 hours.
	MaintainTime *string `json:"MaintainTime,omitempty" xml:"MaintainTime,omitempty"`
	// The ID of the primary instance.
	MasterInstanceId *string `json:"MasterInstanceId,omitempty" xml:"MasterInstanceId,omitempty"`
	// The maximum number of concurrent connections.
	MaxConnections *int32 `json:"MaxConnections,omitempty" xml:"MaxConnections,omitempty"`
	// The maximum number of I/O requests per second.
	MaxIOPS *int32 `json:"MaxIOPS,omitempty" xml:"MaxIOPS,omitempty"`
	// The billing method of the instance.
	PayType *string `json:"PayType,omitempty" xml:"PayType,omitempty"`
	// The port that is used to connect to the instance over an internal network.
	Port *string `json:"Port,omitempty" xml:"Port,omitempty"`
	// The latency of data replication from the primary instance to the read-only instance. This parameter is valid for read-only instances.
	ReadDelayTime *string `json:"ReadDelayTime,omitempty" xml:"ReadDelayTime,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The IP address whitelist.
	SecurityIPList *string `json:"SecurityIPList,omitempty" xml:"SecurityIPList,omitempty"`
	// A deprecated parameter. You do not need to configure this parameter.
	SlaveZones *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttributeSlaveZones `json:"SlaveZones,omitempty" xml:"SlaveZones,omitempty" type:"Struct"`
	// N/A.
	SupportUpgradeAccountType *string `json:"SupportUpgradeAccountType,omitempty" xml:"SupportUpgradeAccountType,omitempty"`
	// The tags.
	Tags *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
	// The ID of the temporary instance that is attached to the instance.
	TempDBInstanceId *string `json:"TempDBInstanceId,omitempty" xml:"TempDBInstanceId,omitempty"`
	// The vSwitch ID.
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
	// The ID of the virtual private cloud (VPC).
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
	// The zone ID.
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
}

func (s DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute) GoString() string {
	return s.String()
}

func (s *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute) SetAccountMaxQuantity(v int32) *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute {
	s.AccountMaxQuantity = &v
	return s
}

func (s *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute) SetAccountType(v string) *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute {
	s.AccountType = &v
	return s
}

func (s *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute) SetAvailabilityValue(v string) *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute {
	s.AvailabilityValue = &v
	return s
}

func (s *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute) SetCategory(v string) *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute {
	s.Category = &v
	return s
}

func (s *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute) SetConnectionMode(v string) *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute {
	s.ConnectionMode = &v
	return s
}

func (s *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute) SetConnectionString(v string) *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute {
	s.ConnectionString = &v
	return s
}

func (s *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute) SetCreationTime(v string) *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute {
	s.CreationTime = &v
	return s
}

func (s *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute) SetDBInstanceCPU(v string) *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute {
	s.DBInstanceCPU = &v
	return s
}

func (s *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute) SetDBInstanceClass(v string) *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute {
	s.DBInstanceClass = &v
	return s
}

func (s *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute) SetDBInstanceClassType(v string) *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute {
	s.DBInstanceClassType = &v
	return s
}

func (s *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute) SetDBInstanceDescription(v string) *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute {
	s.DBInstanceDescription = &v
	return s
}

func (s *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute) SetDBInstanceId(v string) *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute) SetDBInstanceMemory(v int64) *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute {
	s.DBInstanceMemory = &v
	return s
}

func (s *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute) SetDBInstanceNetType(v string) *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute {
	s.DBInstanceNetType = &v
	return s
}

func (s *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute) SetDBInstanceStatus(v string) *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute {
	s.DBInstanceStatus = &v
	return s
}

func (s *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute) SetDBInstanceStorage(v int32) *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute {
	s.DBInstanceStorage = &v
	return s
}

func (s *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute) SetDBInstanceType(v string) *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute {
	s.DBInstanceType = &v
	return s
}

func (s *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute) SetDBMaxQuantity(v int32) *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute {
	s.DBMaxQuantity = &v
	return s
}

func (s *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute) SetEngine(v string) *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute {
	s.Engine = &v
	return s
}

func (s *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute) SetEngineVersion(v string) *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute {
	s.EngineVersion = &v
	return s
}

func (s *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute) SetExpireTime(v string) *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute {
	s.ExpireTime = &v
	return s
}

func (s *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute) SetExportKey(v string) *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute {
	s.ExportKey = &v
	return s
}

func (s *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute) SetGuardDBInstanceId(v string) *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute {
	s.GuardDBInstanceId = &v
	return s
}

func (s *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute) SetIncrementSourceDBInstanceId(v string) *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute {
	s.IncrementSourceDBInstanceId = &v
	return s
}

func (s *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute) SetInstanceNetworkType(v string) *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute {
	s.InstanceNetworkType = &v
	return s
}

func (s *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute) SetLockMode(v string) *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute {
	s.LockMode = &v
	return s
}

func (s *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute) SetLockReason(v string) *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute {
	s.LockReason = &v
	return s
}

func (s *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute) SetMaintainTime(v string) *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute {
	s.MaintainTime = &v
	return s
}

func (s *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute) SetMasterInstanceId(v string) *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute {
	s.MasterInstanceId = &v
	return s
}

func (s *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute) SetMaxConnections(v int32) *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute {
	s.MaxConnections = &v
	return s
}

func (s *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute) SetMaxIOPS(v int32) *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute {
	s.MaxIOPS = &v
	return s
}

func (s *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute) SetPayType(v string) *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute {
	s.PayType = &v
	return s
}

func (s *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute) SetPort(v string) *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute {
	s.Port = &v
	return s
}

func (s *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute) SetReadDelayTime(v string) *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute {
	s.ReadDelayTime = &v
	return s
}

func (s *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute) SetRegionId(v string) *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute {
	s.RegionId = &v
	return s
}

func (s *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute) SetSecurityIPList(v string) *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute {
	s.SecurityIPList = &v
	return s
}

func (s *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute) SetSlaveZones(v *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttributeSlaveZones) *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute {
	s.SlaveZones = v
	return s
}

func (s *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute) SetSupportUpgradeAccountType(v string) *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute {
	s.SupportUpgradeAccountType = &v
	return s
}

func (s *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute) SetTags(v string) *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute {
	s.Tags = &v
	return s
}

func (s *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute) SetTempDBInstanceId(v string) *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute {
	s.TempDBInstanceId = &v
	return s
}

func (s *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute) SetVSwitchId(v string) *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute {
	s.VSwitchId = &v
	return s
}

func (s *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute) SetVpcId(v string) *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute {
	s.VpcId = &v
	return s
}

func (s *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute) SetZoneId(v string) *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute {
	s.ZoneId = &v
	return s
}

type DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttributeSlaveZones struct {
	SlaveRegion []*string `json:"slaveRegion,omitempty" xml:"slaveRegion,omitempty" type:"Repeated"`
}

func (s DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttributeSlaveZones) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttributeSlaveZones) GoString() string {
	return s.String()
}

func (s *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttributeSlaveZones) SetSlaveRegion(v []*string) *DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttributeSlaveZones {
	s.SlaveRegion = v
	return s
}

type DescribeDBInstancesAsCsvResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDBInstancesAsCsvResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDBInstancesAsCsvResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstancesAsCsvResponse) GoString() string {
	return s.String()
}

func (s *DescribeDBInstancesAsCsvResponse) SetHeaders(v map[string]*string) *DescribeDBInstancesAsCsvResponse {
	s.Headers = v
	return s
}

func (s *DescribeDBInstancesAsCsvResponse) SetStatusCode(v int32) *DescribeDBInstancesAsCsvResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDBInstancesAsCsvResponse) SetBody(v *DescribeDBInstancesAsCsvResponseBody) *DescribeDBInstancesAsCsvResponse {
	s.Body = v
	return s
}

type DescribeDBInstancesByExpireTimeRequest struct {
	// The number of remaining days for which the instances are available. Valid values: **0 to 180**.
	ExpirePeriod *int32 `json:"ExpirePeriod,omitempty" xml:"ExpirePeriod,omitempty"`
	// Specifies whether to query instances that have expired. Valid values:
	//
	// *   **True**: queries instances that have expired.
	// *   **False**: does not query instances that have expired.
	Expired      *bool   `json:"Expired,omitempty" xml:"Expired,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of the page to return. Valid values: any **non-zero** positive integer.
	//
	// Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Valid values: **1 to 100**.
	//
	// Default value: **30**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The region ID. You can call the DescribeRegions operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The resource group ID. You can call the DescribeDBInstanceAttribute operation to obtain the resource group ID.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The tag that is added to the instance. Each tag is a key-value pair that consists of two parts: TagKey and TagValue. You can specify a maximum of five tags in the following format for each request: `{"key1":"value1","key2":"value2"...}`.
	Tags *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
	// A deprecated parameter. You do not need to configure this parameter.
	ProxyId *string `json:"proxyId,omitempty" xml:"proxyId,omitempty"`
}

func (s DescribeDBInstancesByExpireTimeRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstancesByExpireTimeRequest) GoString() string {
	return s.String()
}

func (s *DescribeDBInstancesByExpireTimeRequest) SetExpirePeriod(v int32) *DescribeDBInstancesByExpireTimeRequest {
	s.ExpirePeriod = &v
	return s
}

func (s *DescribeDBInstancesByExpireTimeRequest) SetExpired(v bool) *DescribeDBInstancesByExpireTimeRequest {
	s.Expired = &v
	return s
}

func (s *DescribeDBInstancesByExpireTimeRequest) SetOwnerAccount(v string) *DescribeDBInstancesByExpireTimeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeDBInstancesByExpireTimeRequest) SetOwnerId(v int64) *DescribeDBInstancesByExpireTimeRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeDBInstancesByExpireTimeRequest) SetPageNumber(v int32) *DescribeDBInstancesByExpireTimeRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeDBInstancesByExpireTimeRequest) SetPageSize(v int32) *DescribeDBInstancesByExpireTimeRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeDBInstancesByExpireTimeRequest) SetRegionId(v string) *DescribeDBInstancesByExpireTimeRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeDBInstancesByExpireTimeRequest) SetResourceGroupId(v string) *DescribeDBInstancesByExpireTimeRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeDBInstancesByExpireTimeRequest) SetResourceOwnerAccount(v string) *DescribeDBInstancesByExpireTimeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeDBInstancesByExpireTimeRequest) SetResourceOwnerId(v int64) *DescribeDBInstancesByExpireTimeRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeDBInstancesByExpireTimeRequest) SetTags(v string) *DescribeDBInstancesByExpireTimeRequest {
	s.Tags = &v
	return s
}

func (s *DescribeDBInstancesByExpireTimeRequest) SetProxyId(v string) *DescribeDBInstancesByExpireTimeRequest {
	s.ProxyId = &v
	return s
}

type DescribeDBInstancesByExpireTimeResponseBody struct {
	// The details of the instances.
	Items *DescribeDBInstancesByExpireTimeResponseBodyItems `json:"Items,omitempty" xml:"Items,omitempty" type:"Struct"`
	// The page number of the returned page. Valid values: any **non-zero** positive integer.
	//
	// Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of instances returned on the current page.
	PageRecordCount *int32 `json:"PageRecordCount,omitempty" xml:"PageRecordCount,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of returned entries.
	TotalRecordCount *int32 `json:"TotalRecordCount,omitempty" xml:"TotalRecordCount,omitempty"`
}

func (s DescribeDBInstancesByExpireTimeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstancesByExpireTimeResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDBInstancesByExpireTimeResponseBody) SetItems(v *DescribeDBInstancesByExpireTimeResponseBodyItems) *DescribeDBInstancesByExpireTimeResponseBody {
	s.Items = v
	return s
}

func (s *DescribeDBInstancesByExpireTimeResponseBody) SetPageNumber(v int32) *DescribeDBInstancesByExpireTimeResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeDBInstancesByExpireTimeResponseBody) SetPageRecordCount(v int32) *DescribeDBInstancesByExpireTimeResponseBody {
	s.PageRecordCount = &v
	return s
}

func (s *DescribeDBInstancesByExpireTimeResponseBody) SetRequestId(v string) *DescribeDBInstancesByExpireTimeResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDBInstancesByExpireTimeResponseBody) SetTotalRecordCount(v int32) *DescribeDBInstancesByExpireTimeResponseBody {
	s.TotalRecordCount = &v
	return s
}

type DescribeDBInstancesByExpireTimeResponseBodyItems struct {
	DBInstanceExpireTime []*DescribeDBInstancesByExpireTimeResponseBodyItemsDBInstanceExpireTime `json:"DBInstanceExpireTime,omitempty" xml:"DBInstanceExpireTime,omitempty" type:"Repeated"`
}

func (s DescribeDBInstancesByExpireTimeResponseBodyItems) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstancesByExpireTimeResponseBodyItems) GoString() string {
	return s.String()
}

func (s *DescribeDBInstancesByExpireTimeResponseBodyItems) SetDBInstanceExpireTime(v []*DescribeDBInstancesByExpireTimeResponseBodyItemsDBInstanceExpireTime) *DescribeDBInstancesByExpireTimeResponseBodyItems {
	s.DBInstanceExpireTime = v
	return s
}

type DescribeDBInstancesByExpireTimeResponseBodyItemsDBInstanceExpireTime struct {
	// The description of the instance.
	DBInstanceDescription *string `json:"DBInstanceDescription,omitempty" xml:"DBInstanceDescription,omitempty"`
	// The instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The status of the instance. For more information, see [Instance state table](~~26315~~).
	DBInstanceStatus *string `json:"DBInstanceStatus,omitempty" xml:"DBInstanceStatus,omitempty"`
	// The expiration time of the instance. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// > : Pay-as-you-go instances never expire.
	ExpireTime *string `json:"ExpireTime,omitempty" xml:"ExpireTime,omitempty"`
	// The lock mode of the instance. Valid values:
	//
	// *   **Unlock**: The instance is not locked.
	// *   **ManualLock**: The instance is manually locked.
	// *   **LockByExpiration**: The instance is automatically locked after it expires.
	// *   **LockByRestoration**: The instance is automatically locked before it is rolled back.
	// *   **LockByDiskQuota**: The instance is automatically locked after its storage capacity is exhausted.
	// *   **LockReadInstanceByDiskQuota**: The instance is a read-only instance and is automatically locked after its storage capacity is exhausted.
	LockMode *string `json:"LockMode,omitempty" xml:"LockMode,omitempty"`
	// The billing method of the instance. Valid values:
	//
	// *   **Postpaid**: pay-as-you-go.
	// *   **Prepaid**: subscription.
	PayType *string `json:"PayType,omitempty" xml:"PayType,omitempty"`
}

func (s DescribeDBInstancesByExpireTimeResponseBodyItemsDBInstanceExpireTime) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstancesByExpireTimeResponseBodyItemsDBInstanceExpireTime) GoString() string {
	return s.String()
}

func (s *DescribeDBInstancesByExpireTimeResponseBodyItemsDBInstanceExpireTime) SetDBInstanceDescription(v string) *DescribeDBInstancesByExpireTimeResponseBodyItemsDBInstanceExpireTime {
	s.DBInstanceDescription = &v
	return s
}

func (s *DescribeDBInstancesByExpireTimeResponseBodyItemsDBInstanceExpireTime) SetDBInstanceId(v string) *DescribeDBInstancesByExpireTimeResponseBodyItemsDBInstanceExpireTime {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeDBInstancesByExpireTimeResponseBodyItemsDBInstanceExpireTime) SetDBInstanceStatus(v string) *DescribeDBInstancesByExpireTimeResponseBodyItemsDBInstanceExpireTime {
	s.DBInstanceStatus = &v
	return s
}

func (s *DescribeDBInstancesByExpireTimeResponseBodyItemsDBInstanceExpireTime) SetExpireTime(v string) *DescribeDBInstancesByExpireTimeResponseBodyItemsDBInstanceExpireTime {
	s.ExpireTime = &v
	return s
}

func (s *DescribeDBInstancesByExpireTimeResponseBodyItemsDBInstanceExpireTime) SetLockMode(v string) *DescribeDBInstancesByExpireTimeResponseBodyItemsDBInstanceExpireTime {
	s.LockMode = &v
	return s
}

func (s *DescribeDBInstancesByExpireTimeResponseBodyItemsDBInstanceExpireTime) SetPayType(v string) *DescribeDBInstancesByExpireTimeResponseBodyItemsDBInstanceExpireTime {
	s.PayType = &v
	return s
}

type DescribeDBInstancesByExpireTimeResponse struct {
	Headers    map[string]*string                           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDBInstancesByExpireTimeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDBInstancesByExpireTimeResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstancesByExpireTimeResponse) GoString() string {
	return s.String()
}

func (s *DescribeDBInstancesByExpireTimeResponse) SetHeaders(v map[string]*string) *DescribeDBInstancesByExpireTimeResponse {
	s.Headers = v
	return s
}

func (s *DescribeDBInstancesByExpireTimeResponse) SetStatusCode(v int32) *DescribeDBInstancesByExpireTimeResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDBInstancesByExpireTimeResponse) SetBody(v *DescribeDBInstancesByExpireTimeResponseBody) *DescribeDBInstancesByExpireTimeResponse {
	s.Body = v
	return s
}

type DescribeDBInstancesByPerformanceRequest struct {
	Tag []*DescribeDBInstancesByPerformanceRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of the page to return. Valid values: any non-zero positive integer.
	//
	// Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Valid values: **5** to **100**.
	//
	// Default value: **30**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The region ID of the instance. You can call the [DescribeRegions](~~26243~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The sorting basis.
	SortKey *string `json:"SortKey,omitempty" xml:"SortKey,omitempty"`
	// The sorting method.
	SortMethod *string `json:"SortMethod,omitempty" xml:"SortMethod,omitempty"`
	// The tags that are added to the instances. Each tag is a key-value pair that consists of two parts: TagKey and TagValue. Format: `{"key1":"value1"}`.
	Tags *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
	// The ID of the proxy mode.
	ProxyId *string `json:"proxyId,omitempty" xml:"proxyId,omitempty"`
}

func (s DescribeDBInstancesByPerformanceRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstancesByPerformanceRequest) GoString() string {
	return s.String()
}

func (s *DescribeDBInstancesByPerformanceRequest) SetTag(v []*DescribeDBInstancesByPerformanceRequestTag) *DescribeDBInstancesByPerformanceRequest {
	s.Tag = v
	return s
}

func (s *DescribeDBInstancesByPerformanceRequest) SetClientToken(v string) *DescribeDBInstancesByPerformanceRequest {
	s.ClientToken = &v
	return s
}

func (s *DescribeDBInstancesByPerformanceRequest) SetDBInstanceId(v string) *DescribeDBInstancesByPerformanceRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeDBInstancesByPerformanceRequest) SetOwnerAccount(v string) *DescribeDBInstancesByPerformanceRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeDBInstancesByPerformanceRequest) SetOwnerId(v int64) *DescribeDBInstancesByPerformanceRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeDBInstancesByPerformanceRequest) SetPageNumber(v int32) *DescribeDBInstancesByPerformanceRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeDBInstancesByPerformanceRequest) SetPageSize(v int32) *DescribeDBInstancesByPerformanceRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeDBInstancesByPerformanceRequest) SetRegionId(v string) *DescribeDBInstancesByPerformanceRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeDBInstancesByPerformanceRequest) SetResourceGroupId(v string) *DescribeDBInstancesByPerformanceRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeDBInstancesByPerformanceRequest) SetResourceOwnerAccount(v string) *DescribeDBInstancesByPerformanceRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeDBInstancesByPerformanceRequest) SetResourceOwnerId(v int64) *DescribeDBInstancesByPerformanceRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeDBInstancesByPerformanceRequest) SetSortKey(v string) *DescribeDBInstancesByPerformanceRequest {
	s.SortKey = &v
	return s
}

func (s *DescribeDBInstancesByPerformanceRequest) SetSortMethod(v string) *DescribeDBInstancesByPerformanceRequest {
	s.SortMethod = &v
	return s
}

func (s *DescribeDBInstancesByPerformanceRequest) SetTags(v string) *DescribeDBInstancesByPerformanceRequest {
	s.Tags = &v
	return s
}

func (s *DescribeDBInstancesByPerformanceRequest) SetProxyId(v string) *DescribeDBInstancesByPerformanceRequest {
	s.ProxyId = &v
	return s
}

type DescribeDBInstancesByPerformanceRequestTag struct {
	// The key of tag 1 that is added to the instances.
	Key *string `json:"key,omitempty" xml:"key,omitempty"`
	// The value of tag 1 that is added to the instances.
	Value *string `json:"value,omitempty" xml:"value,omitempty"`
}

func (s DescribeDBInstancesByPerformanceRequestTag) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstancesByPerformanceRequestTag) GoString() string {
	return s.String()
}

func (s *DescribeDBInstancesByPerformanceRequestTag) SetKey(v string) *DescribeDBInstancesByPerformanceRequestTag {
	s.Key = &v
	return s
}

func (s *DescribeDBInstancesByPerformanceRequestTag) SetValue(v string) *DescribeDBInstancesByPerformanceRequestTag {
	s.Value = &v
	return s
}

type DescribeDBInstancesByPerformanceResponseBody struct {
	// The details about the instance.
	Items *DescribeDBInstancesByPerformanceResponseBodyItems `json:"Items,omitempty" xml:"Items,omitempty" type:"Struct"`
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned on the current page.
	PageRecordCount *int32 `json:"PageRecordCount,omitempty" xml:"PageRecordCount,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalRecordCount *int32 `json:"TotalRecordCount,omitempty" xml:"TotalRecordCount,omitempty"`
}

func (s DescribeDBInstancesByPerformanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstancesByPerformanceResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDBInstancesByPerformanceResponseBody) SetItems(v *DescribeDBInstancesByPerformanceResponseBodyItems) *DescribeDBInstancesByPerformanceResponseBody {
	s.Items = v
	return s
}

func (s *DescribeDBInstancesByPerformanceResponseBody) SetPageNumber(v int32) *DescribeDBInstancesByPerformanceResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeDBInstancesByPerformanceResponseBody) SetPageRecordCount(v int32) *DescribeDBInstancesByPerformanceResponseBody {
	s.PageRecordCount = &v
	return s
}

func (s *DescribeDBInstancesByPerformanceResponseBody) SetRequestId(v string) *DescribeDBInstancesByPerformanceResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDBInstancesByPerformanceResponseBody) SetTotalRecordCount(v int32) *DescribeDBInstancesByPerformanceResponseBody {
	s.TotalRecordCount = &v
	return s
}

type DescribeDBInstancesByPerformanceResponseBodyItems struct {
	DBInstancePerformance []*DescribeDBInstancesByPerformanceResponseBodyItemsDBInstancePerformance `json:"DBInstancePerformance,omitempty" xml:"DBInstancePerformance,omitempty" type:"Repeated"`
}

func (s DescribeDBInstancesByPerformanceResponseBodyItems) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstancesByPerformanceResponseBodyItems) GoString() string {
	return s.String()
}

func (s *DescribeDBInstancesByPerformanceResponseBodyItems) SetDBInstancePerformance(v []*DescribeDBInstancesByPerformanceResponseBodyItemsDBInstancePerformance) *DescribeDBInstancesByPerformanceResponseBodyItems {
	s.DBInstancePerformance = v
	return s
}

type DescribeDBInstancesByPerformanceResponseBodyItemsDBInstancePerformance struct {
	// The CPU utilization of the instance in percentage.
	CPUUsage *string `json:"CPUUsage,omitempty" xml:"CPUUsage,omitempty"`
	// The name of the instance.
	DBInstanceDescription *string `json:"DBInstanceDescription,omitempty" xml:"DBInstanceDescription,omitempty"`
	// The ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The disk usage of the instance in percentage.
	DiskUsage *string `json:"DiskUsage,omitempty" xml:"DiskUsage,omitempty"`
	// The IOPS usage of the instance in percentage.
	IOPSUsage *string `json:"IOPSUsage,omitempty" xml:"IOPSUsage,omitempty"`
	// The number of sessions.
	SessionUsage *string `json:"SessionUsage,omitempty" xml:"SessionUsage,omitempty"`
}

func (s DescribeDBInstancesByPerformanceResponseBodyItemsDBInstancePerformance) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstancesByPerformanceResponseBodyItemsDBInstancePerformance) GoString() string {
	return s.String()
}

func (s *DescribeDBInstancesByPerformanceResponseBodyItemsDBInstancePerformance) SetCPUUsage(v string) *DescribeDBInstancesByPerformanceResponseBodyItemsDBInstancePerformance {
	s.CPUUsage = &v
	return s
}

func (s *DescribeDBInstancesByPerformanceResponseBodyItemsDBInstancePerformance) SetDBInstanceDescription(v string) *DescribeDBInstancesByPerformanceResponseBodyItemsDBInstancePerformance {
	s.DBInstanceDescription = &v
	return s
}

func (s *DescribeDBInstancesByPerformanceResponseBodyItemsDBInstancePerformance) SetDBInstanceId(v string) *DescribeDBInstancesByPerformanceResponseBodyItemsDBInstancePerformance {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeDBInstancesByPerformanceResponseBodyItemsDBInstancePerformance) SetDiskUsage(v string) *DescribeDBInstancesByPerformanceResponseBodyItemsDBInstancePerformance {
	s.DiskUsage = &v
	return s
}

func (s *DescribeDBInstancesByPerformanceResponseBodyItemsDBInstancePerformance) SetIOPSUsage(v string) *DescribeDBInstancesByPerformanceResponseBodyItemsDBInstancePerformance {
	s.IOPSUsage = &v
	return s
}

func (s *DescribeDBInstancesByPerformanceResponseBodyItemsDBInstancePerformance) SetSessionUsage(v string) *DescribeDBInstancesByPerformanceResponseBodyItemsDBInstancePerformance {
	s.SessionUsage = &v
	return s
}

type DescribeDBInstancesByPerformanceResponse struct {
	Headers    map[string]*string                            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDBInstancesByPerformanceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDBInstancesByPerformanceResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstancesByPerformanceResponse) GoString() string {
	return s.String()
}

func (s *DescribeDBInstancesByPerformanceResponse) SetHeaders(v map[string]*string) *DescribeDBInstancesByPerformanceResponse {
	s.Headers = v
	return s
}

func (s *DescribeDBInstancesByPerformanceResponse) SetStatusCode(v int32) *DescribeDBInstancesByPerformanceResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDBInstancesByPerformanceResponse) SetBody(v *DescribeDBInstancesByPerformanceResponseBody) *DescribeDBInstancesByPerformanceResponse {
	s.Body = v
	return s
}

type DescribeDBInstancesForCloneRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The connection mode of the instance. Valid values:
	//
	// *   **Standard**: standard mode
	// *   **Safe**: database proxy mode
	//
	// By default, this operation queries the instances that use any of the supported connection modes.
	ConnectionMode *string `json:"ConnectionMode,omitempty" xml:"ConnectionMode,omitempty"`
	// The ID of the current instance.
	CurrentInstanceId *string `json:"CurrentInstanceId,omitempty" xml:"CurrentInstanceId,omitempty"`
	// The instance type of the instance. For more information, see [Instance types](~~26312~~).
	DBInstanceClass *string `json:"DBInstanceClass,omitempty" xml:"DBInstanceClass,omitempty"`
	// The ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The status of the instance. For more information, see [Instance state table](~~26315~~).
	DBInstanceStatus *string `json:"DBInstanceStatus,omitempty" xml:"DBInstanceStatus,omitempty"`
	// The role of the instance that you want to query. Valid values:
	//
	// *   **Primary**: primary instance
	// *   **Readonly**: read-only instance
	// *   **Guard**: disaster recovery instance
	// *   **Temp**: temporary instance
	//
	// By default, this operation queries the instances of all roles.
	DBInstanceType *string `json:"DBInstanceType,omitempty" xml:"DBInstanceType,omitempty"`
	// The database engine of the instance. Valid values:
	//
	// *   MySQL
	// *   SQLServer
	// *   PostgreSQL
	// *   PPAS
	// *   MariaDB
	//
	// By default, this operation queries the instances that run any of the supported database engine types.
	Engine *string `json:"Engine,omitempty" xml:"Engine,omitempty"`
	// The version of the database engine.
	EngineVersion *string `json:"EngineVersion,omitempty" xml:"EngineVersion,omitempty"`
	// Specifies whether the instance expires. Valid values:
	//
	// *   **True**: queries the instances that have expired.
	// *   **False**: does not query instances that have expired.
	Expired *string `json:"Expired,omitempty" xml:"Expired,omitempty"`
	// The network type of the instance. Valid values:
	//
	// *   **Classic**
	// *   **VPC**
	InstanceNetworkType *string `json:"InstanceNetworkType,omitempty" xml:"InstanceNetworkType,omitempty"`
	// The type of the database node. Valid values:
	//
	// *   **Master**: the primary node
	// *   **Slave**: the secondary node
	NodeType     *string `json:"NodeType,omitempty" xml:"NodeType,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of the page to return.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Valid values: **1 to 100**.
	//
	// Default value: **30**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The billing method of the instance. Valid values:
	//
	// *   **Postpaid**: pay-as-you-go
	// *   **Prepaid**: subscription
	//
	// By default, this operation queries the instances that use any of the supported billing methods.
	PayType *string `json:"PayType,omitempty" xml:"PayType,omitempty"`
	// The region ID of the instance.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The keyword that is used for the search. The keyword can be part of an instance ID or an instance description.
	SearchKey *string `json:"SearchKey,omitempty" xml:"SearchKey,omitempty"`
	// The ID of the vSwitch.
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
	// The ID of the virtual private cloud (VPC).
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
	// The zone ID of the instance.
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
	// The ID of the proxy mode.
	ProxyId *string `json:"proxyId,omitempty" xml:"proxyId,omitempty"`
}

func (s DescribeDBInstancesForCloneRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstancesForCloneRequest) GoString() string {
	return s.String()
}

func (s *DescribeDBInstancesForCloneRequest) SetClientToken(v string) *DescribeDBInstancesForCloneRequest {
	s.ClientToken = &v
	return s
}

func (s *DescribeDBInstancesForCloneRequest) SetConnectionMode(v string) *DescribeDBInstancesForCloneRequest {
	s.ConnectionMode = &v
	return s
}

func (s *DescribeDBInstancesForCloneRequest) SetCurrentInstanceId(v string) *DescribeDBInstancesForCloneRequest {
	s.CurrentInstanceId = &v
	return s
}

func (s *DescribeDBInstancesForCloneRequest) SetDBInstanceClass(v string) *DescribeDBInstancesForCloneRequest {
	s.DBInstanceClass = &v
	return s
}

func (s *DescribeDBInstancesForCloneRequest) SetDBInstanceId(v string) *DescribeDBInstancesForCloneRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeDBInstancesForCloneRequest) SetDBInstanceStatus(v string) *DescribeDBInstancesForCloneRequest {
	s.DBInstanceStatus = &v
	return s
}

func (s *DescribeDBInstancesForCloneRequest) SetDBInstanceType(v string) *DescribeDBInstancesForCloneRequest {
	s.DBInstanceType = &v
	return s
}

func (s *DescribeDBInstancesForCloneRequest) SetEngine(v string) *DescribeDBInstancesForCloneRequest {
	s.Engine = &v
	return s
}

func (s *DescribeDBInstancesForCloneRequest) SetEngineVersion(v string) *DescribeDBInstancesForCloneRequest {
	s.EngineVersion = &v
	return s
}

func (s *DescribeDBInstancesForCloneRequest) SetExpired(v string) *DescribeDBInstancesForCloneRequest {
	s.Expired = &v
	return s
}

func (s *DescribeDBInstancesForCloneRequest) SetInstanceNetworkType(v string) *DescribeDBInstancesForCloneRequest {
	s.InstanceNetworkType = &v
	return s
}

func (s *DescribeDBInstancesForCloneRequest) SetNodeType(v string) *DescribeDBInstancesForCloneRequest {
	s.NodeType = &v
	return s
}

func (s *DescribeDBInstancesForCloneRequest) SetOwnerAccount(v string) *DescribeDBInstancesForCloneRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeDBInstancesForCloneRequest) SetOwnerId(v int64) *DescribeDBInstancesForCloneRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeDBInstancesForCloneRequest) SetPageNumber(v int32) *DescribeDBInstancesForCloneRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeDBInstancesForCloneRequest) SetPageSize(v int32) *DescribeDBInstancesForCloneRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeDBInstancesForCloneRequest) SetPayType(v string) *DescribeDBInstancesForCloneRequest {
	s.PayType = &v
	return s
}

func (s *DescribeDBInstancesForCloneRequest) SetRegionId(v string) *DescribeDBInstancesForCloneRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeDBInstancesForCloneRequest) SetResourceGroupId(v string) *DescribeDBInstancesForCloneRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeDBInstancesForCloneRequest) SetResourceOwnerAccount(v string) *DescribeDBInstancesForCloneRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeDBInstancesForCloneRequest) SetResourceOwnerId(v int64) *DescribeDBInstancesForCloneRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeDBInstancesForCloneRequest) SetSearchKey(v string) *DescribeDBInstancesForCloneRequest {
	s.SearchKey = &v
	return s
}

func (s *DescribeDBInstancesForCloneRequest) SetVSwitchId(v string) *DescribeDBInstancesForCloneRequest {
	s.VSwitchId = &v
	return s
}

func (s *DescribeDBInstancesForCloneRequest) SetVpcId(v string) *DescribeDBInstancesForCloneRequest {
	s.VpcId = &v
	return s
}

func (s *DescribeDBInstancesForCloneRequest) SetZoneId(v string) *DescribeDBInstancesForCloneRequest {
	s.ZoneId = &v
	return s
}

func (s *DescribeDBInstancesForCloneRequest) SetProxyId(v string) *DescribeDBInstancesForCloneRequest {
	s.ProxyId = &v
	return s
}

type DescribeDBInstancesForCloneResponseBody struct {
	// An array that consists of the details about the instances.
	Items *DescribeDBInstancesForCloneResponseBodyItems `json:"Items,omitempty" xml:"Items,omitempty" type:"Struct"`
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned on the current page.
	PageRecordCount *int32 `json:"PageRecordCount,omitempty" xml:"PageRecordCount,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalRecordCount *int32 `json:"TotalRecordCount,omitempty" xml:"TotalRecordCount,omitempty"`
}

func (s DescribeDBInstancesForCloneResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstancesForCloneResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDBInstancesForCloneResponseBody) SetItems(v *DescribeDBInstancesForCloneResponseBodyItems) *DescribeDBInstancesForCloneResponseBody {
	s.Items = v
	return s
}

func (s *DescribeDBInstancesForCloneResponseBody) SetPageNumber(v int32) *DescribeDBInstancesForCloneResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeDBInstancesForCloneResponseBody) SetPageRecordCount(v int32) *DescribeDBInstancesForCloneResponseBody {
	s.PageRecordCount = &v
	return s
}

func (s *DescribeDBInstancesForCloneResponseBody) SetRequestId(v string) *DescribeDBInstancesForCloneResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDBInstancesForCloneResponseBody) SetTotalRecordCount(v int32) *DescribeDBInstancesForCloneResponseBody {
	s.TotalRecordCount = &v
	return s
}

type DescribeDBInstancesForCloneResponseBodyItems struct {
	DBInstance []*DescribeDBInstancesForCloneResponseBodyItemsDBInstance `json:"DBInstance,omitempty" xml:"DBInstance,omitempty" type:"Repeated"`
}

func (s DescribeDBInstancesForCloneResponseBodyItems) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstancesForCloneResponseBodyItems) GoString() string {
	return s.String()
}

func (s *DescribeDBInstancesForCloneResponseBodyItems) SetDBInstance(v []*DescribeDBInstancesForCloneResponseBodyItemsDBInstance) *DescribeDBInstancesForCloneResponseBodyItems {
	s.DBInstance = v
	return s
}

type DescribeDBInstancesForCloneResponseBodyItemsDBInstance struct {
	// The RDS edition of the instance. Valid values:
	//
	// *   **Basic**: RDS Basic Edition
	// *   **HighAvailability**: RDS High-availability Edition
	// *   **Finance**: RDS Enterprise Edition
	Category *string `json:"Category,omitempty" xml:"Category,omitempty"`
	// The connection mode of the instance. Valid values:
	//
	// *   **Standard**: standard mode
	// *   **Safe**: database proxy mode
	ConnectionMode *string `json:"ConnectionMode,omitempty" xml:"ConnectionMode,omitempty"`
	// The time when the instance was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The instance type of the instance. For more information, see [Instance types](~~26312~~).
	DBInstanceClass *string `json:"DBInstanceClass,omitempty" xml:"DBInstanceClass,omitempty"`
	// The name of the instance. It must be 2 to 256 characters in length. The value can contain letters, digits, underscores (\_), and hyphens (-). The value must start with a letter.
	//
	// > The value cannot start with http:// or https://.
	DBInstanceDescription *string `json:"DBInstanceDescription,omitempty" xml:"DBInstanceDescription,omitempty"`
	// The ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The network connection type of the instance. Valid values:
	//
	// *   **Internet**
	// *   **Intranet**
	DBInstanceNetType *string `json:"DBInstanceNetType,omitempty" xml:"DBInstanceNetType,omitempty"`
	// The status of the instance. For more information, see [Instance state table](~~26315~~).
	DBInstanceStatus *string `json:"DBInstanceStatus,omitempty" xml:"DBInstanceStatus,omitempty"`
	// The storage type of the instance. Valid values:
	//
	// *   **local_ssd/ephemeral_ssd**: local SSD
	// *   **cloud_ssd**: standard SSD.
	// *   **cloud_essd**: enhanced SSD (ESSD)
	DBInstanceStorageType *string `json:"DBInstanceStorageType,omitempty" xml:"DBInstanceStorageType,omitempty"`
	// The role of the instance. Valid values:
	//
	// *   **Primary**: primary instance
	// *   **Readonly**: read-only instance
	// *   **Guard**: disaster recovery instance
	// *   **Temp**: temporary instance
	DBInstanceType *string `json:"DBInstanceType,omitempty" xml:"DBInstanceType,omitempty"`
	// The time when the instance was destroyed. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	DestroyTime *string `json:"DestroyTime,omitempty" xml:"DestroyTime,omitempty"`
	// The database engine of the instance. Valid values:
	//
	// *   MySQL
	// *   SQLServer
	// *   PostgreSQL
	// *   PPAS
	// *   MariaDB
	Engine *string `json:"Engine,omitempty" xml:"Engine,omitempty"`
	// The version of the database engine.
	EngineVersion *string `json:"EngineVersion,omitempty" xml:"EngineVersion,omitempty"`
	// The time when the instance expired. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	ExpireTime *string `json:"ExpireTime,omitempty" xml:"ExpireTime,omitempty"`
	// The ID of the disaster recovery instance. This parameter is returned only when the instance is a primary instance and has a disaster recovery instance.
	GuardDBInstanceId *string `json:"GuardDBInstanceId,omitempty" xml:"GuardDBInstanceId,omitempty"`
	// The ID of the instance role.
	InsId *int32 `json:"InsId,omitempty" xml:"InsId,omitempty"`
	// The network type of the instance. Valid values:
	//
	// *   **Classic**
	// *   **VPC**
	InstanceNetworkType *string `json:"InstanceNetworkType,omitempty" xml:"InstanceNetworkType,omitempty"`
	// The lock method of the instance. Valid values:
	//
	// *   **Unlock**: The instance is not locked.
	// *   **ManualLock**: The instance is manually locked.
	// *   **LockByExpiration**: The instance is automatically locked after it expires.
	// *   **LockByRestoration**: The instance is automatically locked before a rollback.
	// *   **LockByDiskQuota**: The instance is automatically locked because its storage capacity is exhausted and the instance is inaccessible.
	LockMode *string `json:"LockMode,omitempty" xml:"LockMode,omitempty"`
	// The reason why the instance was locked.
	LockReason *string `json:"LockReason,omitempty" xml:"LockReason,omitempty"`
	// The ID of the primary instance. If the value of this parameter is null, the instance is a primary instance.
	MasterInstanceId *string `json:"MasterInstanceId,omitempty" xml:"MasterInstanceId,omitempty"`
	// Indicates whether multi-region deployment is used. Valid values:
	//
	// *   **true**: Multi-region deployment is used.
	// *   **false**: Multi-region deployment is not used.
	MutriORsignle *bool `json:"MutriORsignle,omitempty" xml:"MutriORsignle,omitempty"`
	// The billing method of the instance. Valid values:
	//
	// *   **Postpaid**: pay-as-you-go
	// *   **Prepaid**: subscription
	PayType *string `json:"PayType,omitempty" xml:"PayType,omitempty"`
	// An array consisting of the IDs of the read-only instances that are attached to the primary instance.
	ReadOnlyDBInstanceIds *DescribeDBInstancesForCloneResponseBodyItemsDBInstanceReadOnlyDBInstanceIds `json:"ReadOnlyDBInstanceIds,omitempty" xml:"ReadOnlyDBInstanceIds,omitempty" type:"Struct"`
	// The region ID of the instance.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// None.
	ReplicateId *string `json:"ReplicateId,omitempty" xml:"ReplicateId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The ID of the temporary instance.
	TempDBInstanceId *string `json:"TempDBInstanceId,omitempty" xml:"TempDBInstanceId,omitempty"`
	// The ID of the vSwitch.
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
	// The ID of the instance in the VPC.
	VpcCloudInstanceId *string `json:"VpcCloudInstanceId,omitempty" xml:"VpcCloudInstanceId,omitempty"`
	// The ID of the virtual private cloud (VPC).
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
	// The zone ID of the instance.
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
}

func (s DescribeDBInstancesForCloneResponseBodyItemsDBInstance) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstancesForCloneResponseBodyItemsDBInstance) GoString() string {
	return s.String()
}

func (s *DescribeDBInstancesForCloneResponseBodyItemsDBInstance) SetCategory(v string) *DescribeDBInstancesForCloneResponseBodyItemsDBInstance {
	s.Category = &v
	return s
}

func (s *DescribeDBInstancesForCloneResponseBodyItemsDBInstance) SetConnectionMode(v string) *DescribeDBInstancesForCloneResponseBodyItemsDBInstance {
	s.ConnectionMode = &v
	return s
}

func (s *DescribeDBInstancesForCloneResponseBodyItemsDBInstance) SetCreateTime(v string) *DescribeDBInstancesForCloneResponseBodyItemsDBInstance {
	s.CreateTime = &v
	return s
}

func (s *DescribeDBInstancesForCloneResponseBodyItemsDBInstance) SetDBInstanceClass(v string) *DescribeDBInstancesForCloneResponseBodyItemsDBInstance {
	s.DBInstanceClass = &v
	return s
}

func (s *DescribeDBInstancesForCloneResponseBodyItemsDBInstance) SetDBInstanceDescription(v string) *DescribeDBInstancesForCloneResponseBodyItemsDBInstance {
	s.DBInstanceDescription = &v
	return s
}

func (s *DescribeDBInstancesForCloneResponseBodyItemsDBInstance) SetDBInstanceId(v string) *DescribeDBInstancesForCloneResponseBodyItemsDBInstance {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeDBInstancesForCloneResponseBodyItemsDBInstance) SetDBInstanceNetType(v string) *DescribeDBInstancesForCloneResponseBodyItemsDBInstance {
	s.DBInstanceNetType = &v
	return s
}

func (s *DescribeDBInstancesForCloneResponseBodyItemsDBInstance) SetDBInstanceStatus(v string) *DescribeDBInstancesForCloneResponseBodyItemsDBInstance {
	s.DBInstanceStatus = &v
	return s
}

func (s *DescribeDBInstancesForCloneResponseBodyItemsDBInstance) SetDBInstanceStorageType(v string) *DescribeDBInstancesForCloneResponseBodyItemsDBInstance {
	s.DBInstanceStorageType = &v
	return s
}

func (s *DescribeDBInstancesForCloneResponseBodyItemsDBInstance) SetDBInstanceType(v string) *DescribeDBInstancesForCloneResponseBodyItemsDBInstance {
	s.DBInstanceType = &v
	return s
}

func (s *DescribeDBInstancesForCloneResponseBodyItemsDBInstance) SetDestroyTime(v string) *DescribeDBInstancesForCloneResponseBodyItemsDBInstance {
	s.DestroyTime = &v
	return s
}

func (s *DescribeDBInstancesForCloneResponseBodyItemsDBInstance) SetEngine(v string) *DescribeDBInstancesForCloneResponseBodyItemsDBInstance {
	s.Engine = &v
	return s
}

func (s *DescribeDBInstancesForCloneResponseBodyItemsDBInstance) SetEngineVersion(v string) *DescribeDBInstancesForCloneResponseBodyItemsDBInstance {
	s.EngineVersion = &v
	return s
}

func (s *DescribeDBInstancesForCloneResponseBodyItemsDBInstance) SetExpireTime(v string) *DescribeDBInstancesForCloneResponseBodyItemsDBInstance {
	s.ExpireTime = &v
	return s
}

func (s *DescribeDBInstancesForCloneResponseBodyItemsDBInstance) SetGuardDBInstanceId(v string) *DescribeDBInstancesForCloneResponseBodyItemsDBInstance {
	s.GuardDBInstanceId = &v
	return s
}

func (s *DescribeDBInstancesForCloneResponseBodyItemsDBInstance) SetInsId(v int32) *DescribeDBInstancesForCloneResponseBodyItemsDBInstance {
	s.InsId = &v
	return s
}

func (s *DescribeDBInstancesForCloneResponseBodyItemsDBInstance) SetInstanceNetworkType(v string) *DescribeDBInstancesForCloneResponseBodyItemsDBInstance {
	s.InstanceNetworkType = &v
	return s
}

func (s *DescribeDBInstancesForCloneResponseBodyItemsDBInstance) SetLockMode(v string) *DescribeDBInstancesForCloneResponseBodyItemsDBInstance {
	s.LockMode = &v
	return s
}

func (s *DescribeDBInstancesForCloneResponseBodyItemsDBInstance) SetLockReason(v string) *DescribeDBInstancesForCloneResponseBodyItemsDBInstance {
	s.LockReason = &v
	return s
}

func (s *DescribeDBInstancesForCloneResponseBodyItemsDBInstance) SetMasterInstanceId(v string) *DescribeDBInstancesForCloneResponseBodyItemsDBInstance {
	s.MasterInstanceId = &v
	return s
}

func (s *DescribeDBInstancesForCloneResponseBodyItemsDBInstance) SetMutriORsignle(v bool) *DescribeDBInstancesForCloneResponseBodyItemsDBInstance {
	s.MutriORsignle = &v
	return s
}

func (s *DescribeDBInstancesForCloneResponseBodyItemsDBInstance) SetPayType(v string) *DescribeDBInstancesForCloneResponseBodyItemsDBInstance {
	s.PayType = &v
	return s
}

func (s *DescribeDBInstancesForCloneResponseBodyItemsDBInstance) SetReadOnlyDBInstanceIds(v *DescribeDBInstancesForCloneResponseBodyItemsDBInstanceReadOnlyDBInstanceIds) *DescribeDBInstancesForCloneResponseBodyItemsDBInstance {
	s.ReadOnlyDBInstanceIds = v
	return s
}

func (s *DescribeDBInstancesForCloneResponseBodyItemsDBInstance) SetRegionId(v string) *DescribeDBInstancesForCloneResponseBodyItemsDBInstance {
	s.RegionId = &v
	return s
}

func (s *DescribeDBInstancesForCloneResponseBodyItemsDBInstance) SetReplicateId(v string) *DescribeDBInstancesForCloneResponseBodyItemsDBInstance {
	s.ReplicateId = &v
	return s
}

func (s *DescribeDBInstancesForCloneResponseBodyItemsDBInstance) SetResourceGroupId(v string) *DescribeDBInstancesForCloneResponseBodyItemsDBInstance {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeDBInstancesForCloneResponseBodyItemsDBInstance) SetTempDBInstanceId(v string) *DescribeDBInstancesForCloneResponseBodyItemsDBInstance {
	s.TempDBInstanceId = &v
	return s
}

func (s *DescribeDBInstancesForCloneResponseBodyItemsDBInstance) SetVSwitchId(v string) *DescribeDBInstancesForCloneResponseBodyItemsDBInstance {
	s.VSwitchId = &v
	return s
}

func (s *DescribeDBInstancesForCloneResponseBodyItemsDBInstance) SetVpcCloudInstanceId(v string) *DescribeDBInstancesForCloneResponseBodyItemsDBInstance {
	s.VpcCloudInstanceId = &v
	return s
}

func (s *DescribeDBInstancesForCloneResponseBodyItemsDBInstance) SetVpcId(v string) *DescribeDBInstancesForCloneResponseBodyItemsDBInstance {
	s.VpcId = &v
	return s
}

func (s *DescribeDBInstancesForCloneResponseBodyItemsDBInstance) SetZoneId(v string) *DescribeDBInstancesForCloneResponseBodyItemsDBInstance {
	s.ZoneId = &v
	return s
}

type DescribeDBInstancesForCloneResponseBodyItemsDBInstanceReadOnlyDBInstanceIds struct {
	ReadOnlyDBInstanceId []*DescribeDBInstancesForCloneResponseBodyItemsDBInstanceReadOnlyDBInstanceIdsReadOnlyDBInstanceId `json:"ReadOnlyDBInstanceId,omitempty" xml:"ReadOnlyDBInstanceId,omitempty" type:"Repeated"`
}

func (s DescribeDBInstancesForCloneResponseBodyItemsDBInstanceReadOnlyDBInstanceIds) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstancesForCloneResponseBodyItemsDBInstanceReadOnlyDBInstanceIds) GoString() string {
	return s.String()
}

func (s *DescribeDBInstancesForCloneResponseBodyItemsDBInstanceReadOnlyDBInstanceIds) SetReadOnlyDBInstanceId(v []*DescribeDBInstancesForCloneResponseBodyItemsDBInstanceReadOnlyDBInstanceIdsReadOnlyDBInstanceId) *DescribeDBInstancesForCloneResponseBodyItemsDBInstanceReadOnlyDBInstanceIds {
	s.ReadOnlyDBInstanceId = v
	return s
}

type DescribeDBInstancesForCloneResponseBodyItemsDBInstanceReadOnlyDBInstanceIdsReadOnlyDBInstanceId struct {
	// The ID of the read-only instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
}

func (s DescribeDBInstancesForCloneResponseBodyItemsDBInstanceReadOnlyDBInstanceIdsReadOnlyDBInstanceId) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstancesForCloneResponseBodyItemsDBInstanceReadOnlyDBInstanceIdsReadOnlyDBInstanceId) GoString() string {
	return s.String()
}

func (s *DescribeDBInstancesForCloneResponseBodyItemsDBInstanceReadOnlyDBInstanceIdsReadOnlyDBInstanceId) SetDBInstanceId(v string) *DescribeDBInstancesForCloneResponseBodyItemsDBInstanceReadOnlyDBInstanceIdsReadOnlyDBInstanceId {
	s.DBInstanceId = &v
	return s
}

type DescribeDBInstancesForCloneResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDBInstancesForCloneResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDBInstancesForCloneResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBInstancesForCloneResponse) GoString() string {
	return s.String()
}

func (s *DescribeDBInstancesForCloneResponse) SetHeaders(v map[string]*string) *DescribeDBInstancesForCloneResponse {
	s.Headers = v
	return s
}

func (s *DescribeDBInstancesForCloneResponse) SetStatusCode(v int32) *DescribeDBInstancesForCloneResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDBInstancesForCloneResponse) SetBody(v *DescribeDBInstancesForCloneResponseBody) *DescribeDBInstancesForCloneResponse {
	s.Body = v
	return s
}

type DescribeDBMiniEngineVersionsRequest struct {
	// The ID of the instance. You can call the [DescribeDBInstances](~~26232~~) operation to query the ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The dedicated cluster ID. You can call the [DescribeDedicatedHostGroups](~~141946~~) operation to query the ID of the dedicated cluster.
	DedicatedHostGroupId *string `json:"DedicatedHostGroupId,omitempty" xml:"DedicatedHostGroupId,omitempty"`
	// The database engine of the instance. Valid values: **MySQL** and **PostgreSQL**.
	Engine *string `json:"Engine,omitempty" xml:"Engine,omitempty"`
	// The database engine version of the instance. Valid values:
	//
	// *   Valid values when you set the Engine parameter to MySQL: **8.0**, **5.7**, **5.6**, and **5.5**
	// *   Valid values when you set the Engine parameter to PostgreSQL: **15.0**, **14.0**, **13.0**, **12.0**, **11.0**, and **10.0**
	EngineVersion *string `json:"EngineVersion,omitempty" xml:"EngineVersion,omitempty"`
	// The minor engine version of the instance. You can specify this parameter to query the minor engine version of the instance.
	MinorVersionTag *string `json:"MinorVersionTag,omitempty" xml:"MinorVersionTag,omitempty"`
	// The RDS edition of the instance. Valid values:
	//
	// *   **Basic**: RDS Basic Edition
	// *   **HighAvailability**: RDS High-availability Edition
	// *   **Finance**: RDS Enterprise Edition
	NodeType *string `json:"NodeType,omitempty" xml:"NodeType,omitempty"`
	// The region ID. You can call the [DescribeRegions](~~26243~~) operation to query the most recent region list.
	RegionId        *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerId *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The storage type of the instance. Valid values:
	//
	// *   **local_ssd**: local SSD
	// *   **cloud_ssd**: standard SSD
	// *   **cloud_essd**: enhanced SSD (ESSD) of performance level 1 (PL1)
	// *   **cloud_essd2**: ESSD of PL2
	// *   **cloud_essd3**: ESSD of PL3
	StorageType *string `json:"StorageType,omitempty" xml:"StorageType,omitempty"`
}

func (s DescribeDBMiniEngineVersionsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBMiniEngineVersionsRequest) GoString() string {
	return s.String()
}

func (s *DescribeDBMiniEngineVersionsRequest) SetDBInstanceId(v string) *DescribeDBMiniEngineVersionsRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeDBMiniEngineVersionsRequest) SetDedicatedHostGroupId(v string) *DescribeDBMiniEngineVersionsRequest {
	s.DedicatedHostGroupId = &v
	return s
}

func (s *DescribeDBMiniEngineVersionsRequest) SetEngine(v string) *DescribeDBMiniEngineVersionsRequest {
	s.Engine = &v
	return s
}

func (s *DescribeDBMiniEngineVersionsRequest) SetEngineVersion(v string) *DescribeDBMiniEngineVersionsRequest {
	s.EngineVersion = &v
	return s
}

func (s *DescribeDBMiniEngineVersionsRequest) SetMinorVersionTag(v string) *DescribeDBMiniEngineVersionsRequest {
	s.MinorVersionTag = &v
	return s
}

func (s *DescribeDBMiniEngineVersionsRequest) SetNodeType(v string) *DescribeDBMiniEngineVersionsRequest {
	s.NodeType = &v
	return s
}

func (s *DescribeDBMiniEngineVersionsRequest) SetRegionId(v string) *DescribeDBMiniEngineVersionsRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeDBMiniEngineVersionsRequest) SetResourceOwnerId(v int64) *DescribeDBMiniEngineVersionsRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeDBMiniEngineVersionsRequest) SetStorageType(v string) *DescribeDBMiniEngineVersionsRequest {
	s.StorageType = &v
	return s
}

type DescribeDBMiniEngineVersionsResponseBody struct {
	// The instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The number of entries returned per page.
	MaxRecordsPerPage *int32 `json:"MaxRecordsPerPage,omitempty" xml:"MaxRecordsPerPage,omitempty"`
	// The details of the minor engine version.
	MinorVersionItems []*DescribeDBMiniEngineVersionsResponseBodyMinorVersionItems `json:"MinorVersionItems,omitempty" xml:"MinorVersionItems,omitempty" type:"Repeated"`
	// The page number returned.
	PageNumbers *int32 `json:"PageNumbers,omitempty" xml:"PageNumbers,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeDBMiniEngineVersionsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBMiniEngineVersionsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDBMiniEngineVersionsResponseBody) SetDBInstanceId(v string) *DescribeDBMiniEngineVersionsResponseBody {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeDBMiniEngineVersionsResponseBody) SetMaxRecordsPerPage(v int32) *DescribeDBMiniEngineVersionsResponseBody {
	s.MaxRecordsPerPage = &v
	return s
}

func (s *DescribeDBMiniEngineVersionsResponseBody) SetMinorVersionItems(v []*DescribeDBMiniEngineVersionsResponseBodyMinorVersionItems) *DescribeDBMiniEngineVersionsResponseBody {
	s.MinorVersionItems = v
	return s
}

func (s *DescribeDBMiniEngineVersionsResponseBody) SetPageNumbers(v int32) *DescribeDBMiniEngineVersionsResponseBody {
	s.PageNumbers = &v
	return s
}

func (s *DescribeDBMiniEngineVersionsResponseBody) SetRequestId(v string) *DescribeDBMiniEngineVersionsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDBMiniEngineVersionsResponseBody) SetTotalCount(v int32) *DescribeDBMiniEngineVersionsResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeDBMiniEngineVersionsResponseBodyMinorVersionItems struct {
	// The PostgreSQL version to which the minor engine version corresponds. For more information, see [Release notes for AliPG](~~126002~~).
	//
	// >  This parameter is available only for instances that run **PostgreSQL**.
	CommunityMinorVersion *string `json:"CommunityMinorVersion,omitempty" xml:"CommunityMinorVersion,omitempty"`
	// The database engine that corresponds to the minor engine version.
	Engine *string `json:"Engine,omitempty" xml:"Engine,omitempty"`
	// The database engine version that corresponds to the minor engine version.
	EngineVersion *string `json:"EngineVersion,omitempty" xml:"EngineVersion,omitempty"`
	// The expiration status of the minor engine version. Valid values:
	//
	// *   **vaild**
	// *   **expired**
	//
	// >  If the minor engine version is in the Offline state, the minor engine version is discontinued. In this case, ignore the expiration status. If the minor engine version is in the Online state and the expiration state is expired, the minor engine version expires. If the expiration state is vaild, the minor engine version is still in its lifecycle.
	ExpireStatus *string `json:"ExpireStatus,omitempty" xml:"ExpireStatus,omitempty"`
	// An internal parameter. You do not need to specify this parameter.
	IsHotfixVersion *bool `json:"IsHotfixVersion,omitempty" xml:"IsHotfixVersion,omitempty"`
	// The minor engine version.
	MinorVersion *string `json:"MinorVersion,omitempty" xml:"MinorVersion,omitempty"`
	// The RDS edition of the instance that runs the minor engine version. Valid values:
	//
	// *   **Basic**: RDS Basic Edition
	// *   **HighAvailability**: RDS High-availability Edition
	// *   **Finance**: RDS Enterprise Edition
	NodeType *string `json:"NodeType,omitempty" xml:"NodeType,omitempty"`
	// The URL of the release notes for the minor engine version.
	ReleaseNote *string `json:"ReleaseNote,omitempty" xml:"ReleaseNote,omitempty"`
	// The release type. Valid values:
	//
	// *   **LTS**: a long-term version
	// *   **BETA**: a preview version
	ReleaseType *string `json:"ReleaseType,omitempty" xml:"ReleaseType,omitempty"`
	// The status of the minor engine version. Valid values:
	//
	// *   **Offline**: Discontinued
	// *   **online**: Available
	//
	// >  If the minor engine version is in the Offline state, the minor engine version is discontinued. In this case, ignore the expiration status. If the minor engine version is in the Online state and the expiration state is expired, the minor engine version expires. If the expiration state is vaild, the minor engine version is still in its lifecycle.
	StatusDesc *string `json:"StatusDesc,omitempty" xml:"StatusDesc,omitempty"`
	// The tag that corresponds to the minor engine version. Valid values:
	//
	// *   **pgsql_docker_image**: tag of the common instance
	// *   **pgsql_babelfish_image**: tag of the instance for which Babelfish is enabled
	//
	// >  This parameter is available only for instances that run **PostgreSQL**.
	Tag *string `json:"Tag,omitempty" xml:"Tag,omitempty"`
}

func (s DescribeDBMiniEngineVersionsResponseBodyMinorVersionItems) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBMiniEngineVersionsResponseBodyMinorVersionItems) GoString() string {
	return s.String()
}

func (s *DescribeDBMiniEngineVersionsResponseBodyMinorVersionItems) SetCommunityMinorVersion(v string) *DescribeDBMiniEngineVersionsResponseBodyMinorVersionItems {
	s.CommunityMinorVersion = &v
	return s
}

func (s *DescribeDBMiniEngineVersionsResponseBodyMinorVersionItems) SetEngine(v string) *DescribeDBMiniEngineVersionsResponseBodyMinorVersionItems {
	s.Engine = &v
	return s
}

func (s *DescribeDBMiniEngineVersionsResponseBodyMinorVersionItems) SetEngineVersion(v string) *DescribeDBMiniEngineVersionsResponseBodyMinorVersionItems {
	s.EngineVersion = &v
	return s
}

func (s *DescribeDBMiniEngineVersionsResponseBodyMinorVersionItems) SetExpireStatus(v string) *DescribeDBMiniEngineVersionsResponseBodyMinorVersionItems {
	s.ExpireStatus = &v
	return s
}

func (s *DescribeDBMiniEngineVersionsResponseBodyMinorVersionItems) SetIsHotfixVersion(v bool) *DescribeDBMiniEngineVersionsResponseBodyMinorVersionItems {
	s.IsHotfixVersion = &v
	return s
}

func (s *DescribeDBMiniEngineVersionsResponseBodyMinorVersionItems) SetMinorVersion(v string) *DescribeDBMiniEngineVersionsResponseBodyMinorVersionItems {
	s.MinorVersion = &v
	return s
}

func (s *DescribeDBMiniEngineVersionsResponseBodyMinorVersionItems) SetNodeType(v string) *DescribeDBMiniEngineVersionsResponseBodyMinorVersionItems {
	s.NodeType = &v
	return s
}

func (s *DescribeDBMiniEngineVersionsResponseBodyMinorVersionItems) SetReleaseNote(v string) *DescribeDBMiniEngineVersionsResponseBodyMinorVersionItems {
	s.ReleaseNote = &v
	return s
}

func (s *DescribeDBMiniEngineVersionsResponseBodyMinorVersionItems) SetReleaseType(v string) *DescribeDBMiniEngineVersionsResponseBodyMinorVersionItems {
	s.ReleaseType = &v
	return s
}

func (s *DescribeDBMiniEngineVersionsResponseBodyMinorVersionItems) SetStatusDesc(v string) *DescribeDBMiniEngineVersionsResponseBodyMinorVersionItems {
	s.StatusDesc = &v
	return s
}

func (s *DescribeDBMiniEngineVersionsResponseBodyMinorVersionItems) SetTag(v string) *DescribeDBMiniEngineVersionsResponseBodyMinorVersionItems {
	s.Tag = &v
	return s
}

type DescribeDBMiniEngineVersionsResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDBMiniEngineVersionsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDBMiniEngineVersionsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBMiniEngineVersionsResponse) GoString() string {
	return s.String()
}

func (s *DescribeDBMiniEngineVersionsResponse) SetHeaders(v map[string]*string) *DescribeDBMiniEngineVersionsResponse {
	s.Headers = v
	return s
}

func (s *DescribeDBMiniEngineVersionsResponse) SetStatusCode(v int32) *DescribeDBMiniEngineVersionsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDBMiniEngineVersionsResponse) SetBody(v *DescribeDBMiniEngineVersionsResponseBody) *DescribeDBMiniEngineVersionsResponse {
	s.Body = v
	return s
}

type DescribeDBProxyRequest struct {
	// The instance ID. You can call the DescribeDBInstances operation to query the instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// A reserved parameter. You do not need to specify this parameter.
	DBProxyEngineType *string `json:"DBProxyEngineType,omitempty" xml:"DBProxyEngineType,omitempty"`
	OwnerId           *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID. You can call the DescribeRegions operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeDBProxyRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBProxyRequest) GoString() string {
	return s.String()
}

func (s *DescribeDBProxyRequest) SetDBInstanceId(v string) *DescribeDBProxyRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeDBProxyRequest) SetDBProxyEngineType(v string) *DescribeDBProxyRequest {
	s.DBProxyEngineType = &v
	return s
}

func (s *DescribeDBProxyRequest) SetOwnerId(v int64) *DescribeDBProxyRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeDBProxyRequest) SetRegionId(v string) *DescribeDBProxyRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeDBProxyRequest) SetResourceGroupId(v string) *DescribeDBProxyRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeDBProxyRequest) SetResourceOwnerAccount(v string) *DescribeDBProxyRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeDBProxyRequest) SetResourceOwnerId(v int64) *DescribeDBProxyRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeDBProxyResponseBody struct {
	// The list of zones that are available for the database proxy.
	DBProxyAVZones *DescribeDBProxyResponseBodyDBProxyAVZones `json:"DBProxyAVZones,omitempty" xml:"DBProxyAVZones,omitempty" type:"Struct"`
	// An array consisting of the information about the database proxy endpoint that is created for the instance.
	DBProxyConnectStringItems *DescribeDBProxyResponseBodyDBProxyConnectStringItems `json:"DBProxyConnectStringItems,omitempty" xml:"DBProxyConnectStringItems,omitempty" type:"Struct"`
	// An internal parameter. You can ignore this parameter.
	DBProxyEngineType *string `json:"DBProxyEngineType,omitempty" xml:"DBProxyEngineType,omitempty"`
	// The version of the proxy instance.
	DBProxyInstanceCurrentMinorVersion *string `json:"DBProxyInstanceCurrentMinorVersion,omitempty" xml:"DBProxyInstanceCurrentMinorVersion,omitempty"`
	// The latest version that is available for the proxy instance.
	DBProxyInstanceLatestMinorVersion *string `json:"DBProxyInstanceLatestMinorVersion,omitempty" xml:"DBProxyInstanceLatestMinorVersion,omitempty"`
	// The name of the proxy instance.
	DBProxyInstanceName *string `json:"DBProxyInstanceName,omitempty" xml:"DBProxyInstanceName,omitempty"`
	// The number of proxies that are enabled on the instance.
	DBProxyInstanceNum *int32 `json:"DBProxyInstanceNum,omitempty" xml:"DBProxyInstanceNum,omitempty"`
	// This parameter is available only for ApsaraDB RDS for PostgreSQL instances. The specifications of the proxy instance that is enabled.
	//
	// Format: `Number of cores/Memory capacity`.
	//
	// For example, a value of 4/8 indicates that the proxy instance has 4 cores and 8 GB of memory.
	DBProxyInstanceSize *string `json:"DBProxyInstanceSize,omitempty" xml:"DBProxyInstanceSize,omitempty"`
	// The status of the proxy instance.
	//
	// *   DBInstanceClassChanging: The specifications of the proxy instance are being changed.
	// *   Creating: The proxy instance is being created.
	// *   Running: The proxy instance is running.
	// *   Deleting: The proxy instance is being deleted.
	DBProxyInstanceStatus *string `json:"DBProxyInstanceStatus,omitempty" xml:"DBProxyInstanceStatus,omitempty"`
	// The type of the database proxy that is enabled on the instance.
	//
	// *   1: shared proxy
	// *   2: dedicated proxy
	//
	// >  ApsaraDB RDS for PostgreSQL instances support only dedicated proxies.
	DBProxyInstanceType *string `json:"DBProxyInstanceType,omitempty" xml:"DBProxyInstanceType,omitempty"`
	// The status of the database proxy.
	//
	// *   Shutdown: disabled
	// *   Startup: enabled
	DBProxyServiceStatus *string `json:"DBProxyServiceStatus,omitempty" xml:"DBProxyServiceStatus,omitempty"`
	// The proxy terminals of the instance.
	DbProxyEndpointItems *DescribeDBProxyResponseBodyDbProxyEndpointItems `json:"DbProxyEndpointItems,omitempty" xml:"DbProxyEndpointItems,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
}

func (s DescribeDBProxyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBProxyResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDBProxyResponseBody) SetDBProxyAVZones(v *DescribeDBProxyResponseBodyDBProxyAVZones) *DescribeDBProxyResponseBody {
	s.DBProxyAVZones = v
	return s
}

func (s *DescribeDBProxyResponseBody) SetDBProxyConnectStringItems(v *DescribeDBProxyResponseBodyDBProxyConnectStringItems) *DescribeDBProxyResponseBody {
	s.DBProxyConnectStringItems = v
	return s
}

func (s *DescribeDBProxyResponseBody) SetDBProxyEngineType(v string) *DescribeDBProxyResponseBody {
	s.DBProxyEngineType = &v
	return s
}

func (s *DescribeDBProxyResponseBody) SetDBProxyInstanceCurrentMinorVersion(v string) *DescribeDBProxyResponseBody {
	s.DBProxyInstanceCurrentMinorVersion = &v
	return s
}

func (s *DescribeDBProxyResponseBody) SetDBProxyInstanceLatestMinorVersion(v string) *DescribeDBProxyResponseBody {
	s.DBProxyInstanceLatestMinorVersion = &v
	return s
}

func (s *DescribeDBProxyResponseBody) SetDBProxyInstanceName(v string) *DescribeDBProxyResponseBody {
	s.DBProxyInstanceName = &v
	return s
}

func (s *DescribeDBProxyResponseBody) SetDBProxyInstanceNum(v int32) *DescribeDBProxyResponseBody {
	s.DBProxyInstanceNum = &v
	return s
}

func (s *DescribeDBProxyResponseBody) SetDBProxyInstanceSize(v string) *DescribeDBProxyResponseBody {
	s.DBProxyInstanceSize = &v
	return s
}

func (s *DescribeDBProxyResponseBody) SetDBProxyInstanceStatus(v string) *DescribeDBProxyResponseBody {
	s.DBProxyInstanceStatus = &v
	return s
}

func (s *DescribeDBProxyResponseBody) SetDBProxyInstanceType(v string) *DescribeDBProxyResponseBody {
	s.DBProxyInstanceType = &v
	return s
}

func (s *DescribeDBProxyResponseBody) SetDBProxyServiceStatus(v string) *DescribeDBProxyResponseBody {
	s.DBProxyServiceStatus = &v
	return s
}

func (s *DescribeDBProxyResponseBody) SetDbProxyEndpointItems(v *DescribeDBProxyResponseBodyDbProxyEndpointItems) *DescribeDBProxyResponseBody {
	s.DbProxyEndpointItems = v
	return s
}

func (s *DescribeDBProxyResponseBody) SetRequestId(v string) *DescribeDBProxyResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDBProxyResponseBody) SetResourceGroupId(v string) *DescribeDBProxyResponseBody {
	s.ResourceGroupId = &v
	return s
}

type DescribeDBProxyResponseBodyDBProxyAVZones struct {
	DBProxyAVZones []*string `json:"DBProxyAVZones,omitempty" xml:"DBProxyAVZones,omitempty" type:"Repeated"`
}

func (s DescribeDBProxyResponseBodyDBProxyAVZones) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBProxyResponseBodyDBProxyAVZones) GoString() string {
	return s.String()
}

func (s *DescribeDBProxyResponseBodyDBProxyAVZones) SetDBProxyAVZones(v []*string) *DescribeDBProxyResponseBodyDBProxyAVZones {
	s.DBProxyAVZones = v
	return s
}

type DescribeDBProxyResponseBodyDBProxyConnectStringItems struct {
	DBProxyConnectStringItems []*DescribeDBProxyResponseBodyDBProxyConnectStringItemsDBProxyConnectStringItems `json:"DBProxyConnectStringItems,omitempty" xml:"DBProxyConnectStringItems,omitempty" type:"Repeated"`
}

func (s DescribeDBProxyResponseBodyDBProxyConnectStringItems) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBProxyResponseBodyDBProxyConnectStringItems) GoString() string {
	return s.String()
}

func (s *DescribeDBProxyResponseBodyDBProxyConnectStringItems) SetDBProxyConnectStringItems(v []*DescribeDBProxyResponseBodyDBProxyConnectStringItemsDBProxyConnectStringItems) *DescribeDBProxyResponseBodyDBProxyConnectStringItems {
	s.DBProxyConnectStringItems = v
	return s
}

type DescribeDBProxyResponseBodyDBProxyConnectStringItemsDBProxyConnectStringItems struct {
	// The endpoint of the proxy terminal.
	DBProxyConnectString *string `json:"DBProxyConnectString,omitempty" xml:"DBProxyConnectString,omitempty"`
	// The network type of the proxy endpoint.
	//
	// *   OuterString: Internet
	// *   InnerString: internal network
	DBProxyConnectStringNetType *string `json:"DBProxyConnectStringNetType,omitempty" xml:"DBProxyConnectStringNetType,omitempty"`
	// The network type of the database proxy.
	//
	// *   0: Internet
	// *   1: classic network
	// *   2: virtual private cloud (VPC)
	DBProxyConnectStringNetWorkType *string `json:"DBProxyConnectStringNetWorkType,omitempty" xml:"DBProxyConnectStringNetWorkType,omitempty"`
	// The port number that is associated with the proxy endpoint.
	DBProxyConnectStringPort *string `json:"DBProxyConnectStringPort,omitempty" xml:"DBProxyConnectStringPort,omitempty"`
	// The ID of the proxy terminal to which the proxy endpoint belongs.
	DBProxyEndpointId *string `json:"DBProxyEndpointId,omitempty" xml:"DBProxyEndpointId,omitempty"`
	// The name of the proxy terminal to which the proxy endpoint belongs.
	DBProxyEndpointName *string `json:"DBProxyEndpointName,omitempty" xml:"DBProxyEndpointName,omitempty"`
	// The VPC that is associated with the proxy endpoint.
	DBProxyVpcId *string `json:"DBProxyVpcId,omitempty" xml:"DBProxyVpcId,omitempty"`
	// The ID of the proxy instance.
	DBProxyVpcInstanceId *string `json:"DBProxyVpcInstanceId,omitempty" xml:"DBProxyVpcInstanceId,omitempty"`
	// The vSwitch of the proxy service.
	DBProxyVswitchId *string `json:"DBProxyVswitchId,omitempty" xml:"DBProxyVswitchId,omitempty"`
}

func (s DescribeDBProxyResponseBodyDBProxyConnectStringItemsDBProxyConnectStringItems) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBProxyResponseBodyDBProxyConnectStringItemsDBProxyConnectStringItems) GoString() string {
	return s.String()
}

func (s *DescribeDBProxyResponseBodyDBProxyConnectStringItemsDBProxyConnectStringItems) SetDBProxyConnectString(v string) *DescribeDBProxyResponseBodyDBProxyConnectStringItemsDBProxyConnectStringItems {
	s.DBProxyConnectString = &v
	return s
}

func (s *DescribeDBProxyResponseBodyDBProxyConnectStringItemsDBProxyConnectStringItems) SetDBProxyConnectStringNetType(v string) *DescribeDBProxyResponseBodyDBProxyConnectStringItemsDBProxyConnectStringItems {
	s.DBProxyConnectStringNetType = &v
	return s
}

func (s *DescribeDBProxyResponseBodyDBProxyConnectStringItemsDBProxyConnectStringItems) SetDBProxyConnectStringNetWorkType(v string) *DescribeDBProxyResponseBodyDBProxyConnectStringItemsDBProxyConnectStringItems {
	s.DBProxyConnectStringNetWorkType = &v
	return s
}

func (s *DescribeDBProxyResponseBodyDBProxyConnectStringItemsDBProxyConnectStringItems) SetDBProxyConnectStringPort(v string) *DescribeDBProxyResponseBodyDBProxyConnectStringItemsDBProxyConnectStringItems {
	s.DBProxyConnectStringPort = &v
	return s
}

func (s *DescribeDBProxyResponseBodyDBProxyConnectStringItemsDBProxyConnectStringItems) SetDBProxyEndpointId(v string) *DescribeDBProxyResponseBodyDBProxyConnectStringItemsDBProxyConnectStringItems {
	s.DBProxyEndpointId = &v
	return s
}

func (s *DescribeDBProxyResponseBodyDBProxyConnectStringItemsDBProxyConnectStringItems) SetDBProxyEndpointName(v string) *DescribeDBProxyResponseBodyDBProxyConnectStringItemsDBProxyConnectStringItems {
	s.DBProxyEndpointName = &v
	return s
}

func (s *DescribeDBProxyResponseBodyDBProxyConnectStringItemsDBProxyConnectStringItems) SetDBProxyVpcId(v string) *DescribeDBProxyResponseBodyDBProxyConnectStringItemsDBProxyConnectStringItems {
	s.DBProxyVpcId = &v
	return s
}

func (s *DescribeDBProxyResponseBodyDBProxyConnectStringItemsDBProxyConnectStringItems) SetDBProxyVpcInstanceId(v string) *DescribeDBProxyResponseBodyDBProxyConnectStringItemsDBProxyConnectStringItems {
	s.DBProxyVpcInstanceId = &v
	return s
}

func (s *DescribeDBProxyResponseBodyDBProxyConnectStringItemsDBProxyConnectStringItems) SetDBProxyVswitchId(v string) *DescribeDBProxyResponseBodyDBProxyConnectStringItemsDBProxyConnectStringItems {
	s.DBProxyVswitchId = &v
	return s
}

type DescribeDBProxyResponseBodyDbProxyEndpointItems struct {
	DbProxyEndpointItems []*DescribeDBProxyResponseBodyDbProxyEndpointItemsDbProxyEndpointItems `json:"DbProxyEndpointItems,omitempty" xml:"DbProxyEndpointItems,omitempty" type:"Repeated"`
}

func (s DescribeDBProxyResponseBodyDbProxyEndpointItems) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBProxyResponseBodyDbProxyEndpointItems) GoString() string {
	return s.String()
}

func (s *DescribeDBProxyResponseBodyDbProxyEndpointItems) SetDbProxyEndpointItems(v []*DescribeDBProxyResponseBodyDbProxyEndpointItemsDbProxyEndpointItems) *DescribeDBProxyResponseBodyDbProxyEndpointItems {
	s.DbProxyEndpointItems = v
	return s
}

type DescribeDBProxyResponseBodyDbProxyEndpointItemsDbProxyEndpointItems struct {
	// The description of the proxy terminal.
	DbProxyEndpointAliases *string `json:"DbProxyEndpointAliases,omitempty" xml:"DbProxyEndpointAliases,omitempty"`
	// The ID of the proxy terminal.
	DbProxyEndpointName *string `json:"DbProxyEndpointName,omitempty" xml:"DbProxyEndpointName,omitempty"`
	// The type of the proxy terminal.
	//
	// *   Custom: custom proxy terminal
	// *   RWSplit: default proxy terminal
	DbProxyEndpointType *string `json:"DbProxyEndpointType,omitempty" xml:"DbProxyEndpointType,omitempty"`
	// The read and write attributes of the proxy terminal.
	//
	// *   ReadOnly: The proxy terminal supports only read requests.
	// *   ReadWrite: The proxy terminal supports read and write requests.
	DbProxyReadWriteMode *string `json:"DbProxyReadWriteMode,omitempty" xml:"DbProxyReadWriteMode,omitempty"`
}

func (s DescribeDBProxyResponseBodyDbProxyEndpointItemsDbProxyEndpointItems) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBProxyResponseBodyDbProxyEndpointItemsDbProxyEndpointItems) GoString() string {
	return s.String()
}

func (s *DescribeDBProxyResponseBodyDbProxyEndpointItemsDbProxyEndpointItems) SetDbProxyEndpointAliases(v string) *DescribeDBProxyResponseBodyDbProxyEndpointItemsDbProxyEndpointItems {
	s.DbProxyEndpointAliases = &v
	return s
}

func (s *DescribeDBProxyResponseBodyDbProxyEndpointItemsDbProxyEndpointItems) SetDbProxyEndpointName(v string) *DescribeDBProxyResponseBodyDbProxyEndpointItemsDbProxyEndpointItems {
	s.DbProxyEndpointName = &v
	return s
}

func (s *DescribeDBProxyResponseBodyDbProxyEndpointItemsDbProxyEndpointItems) SetDbProxyEndpointType(v string) *DescribeDBProxyResponseBodyDbProxyEndpointItemsDbProxyEndpointItems {
	s.DbProxyEndpointType = &v
	return s
}

func (s *DescribeDBProxyResponseBodyDbProxyEndpointItemsDbProxyEndpointItems) SetDbProxyReadWriteMode(v string) *DescribeDBProxyResponseBodyDbProxyEndpointItemsDbProxyEndpointItems {
	s.DbProxyReadWriteMode = &v
	return s
}

type DescribeDBProxyResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDBProxyResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDBProxyResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBProxyResponse) GoString() string {
	return s.String()
}

func (s *DescribeDBProxyResponse) SetHeaders(v map[string]*string) *DescribeDBProxyResponse {
	s.Headers = v
	return s
}

func (s *DescribeDBProxyResponse) SetStatusCode(v int32) *DescribeDBProxyResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDBProxyResponse) SetBody(v *DescribeDBProxyResponseBody) *DescribeDBProxyResponse {
	s.Body = v
	return s
}

type DescribeDBProxyEndpointRequest struct {
	// The instance ID. You can call the [DescribeDBInstances](~~610396~~) operation to query the ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The proxy endpoint that you want to query. You can call the [DescribeDBProxy](~~610506~~) operation to query the proxy endpoint.
	DBProxyConnectString *string `json:"DBProxyConnectString,omitempty" xml:"DBProxyConnectString,omitempty"`
	// The name of the proxy terminal to which the proxy endpoint belongs. You can call the [DescribeDBProxy](~~610506~~) operation to query the name of the proxy terminal.
	DBProxyEndpointId *string `json:"DBProxyEndpointId,omitempty" xml:"DBProxyEndpointId,omitempty"`
	// A reserved parameter. You do not need to specify this parameter.
	DBProxyEngineType *string `json:"DBProxyEngineType,omitempty" xml:"DBProxyEngineType,omitempty"`
	OwnerId           *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID. You can call the [DescribeRegions](~~610399~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeDBProxyEndpointRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBProxyEndpointRequest) GoString() string {
	return s.String()
}

func (s *DescribeDBProxyEndpointRequest) SetDBInstanceId(v string) *DescribeDBProxyEndpointRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeDBProxyEndpointRequest) SetDBProxyConnectString(v string) *DescribeDBProxyEndpointRequest {
	s.DBProxyConnectString = &v
	return s
}

func (s *DescribeDBProxyEndpointRequest) SetDBProxyEndpointId(v string) *DescribeDBProxyEndpointRequest {
	s.DBProxyEndpointId = &v
	return s
}

func (s *DescribeDBProxyEndpointRequest) SetDBProxyEngineType(v string) *DescribeDBProxyEndpointRequest {
	s.DBProxyEngineType = &v
	return s
}

func (s *DescribeDBProxyEndpointRequest) SetOwnerId(v int64) *DescribeDBProxyEndpointRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeDBProxyEndpointRequest) SetRegionId(v string) *DescribeDBProxyEndpointRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeDBProxyEndpointRequest) SetResourceOwnerAccount(v string) *DescribeDBProxyEndpointRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeDBProxyEndpointRequest) SetResourceOwnerId(v int64) *DescribeDBProxyEndpointRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeDBProxyEndpointResponseBody struct {
	// The proxy endpoint queried.
	DBProxyConnectString *string `json:"DBProxyConnectString,omitempty" xml:"DBProxyConnectString,omitempty"`
	// The network type of the proxy endpoint. Valid values:
	//
	// *   **InnerString**: internal network
	// *   **OuterString**: Internet
	DBProxyConnectStringNetType *string `json:"DBProxyConnectStringNetType,omitempty" xml:"DBProxyConnectStringNetType,omitempty"`
	// The port number that is associated with the proxy endpoint.
	DBProxyConnectStringPort *string `json:"DBProxyConnectStringPort,omitempty" xml:"DBProxyConnectStringPort,omitempty"`
	// The ID of the proxy endpoint.
	DBProxyEndpointId *string `json:"DBProxyEndpointId,omitempty" xml:"DBProxyEndpointId,omitempty"`
	// An internal parameter. You can ignore this parameter.
	DBProxyEngineType *string `json:"DBProxyEngineType,omitempty" xml:"DBProxyEngineType,omitempty"`
	// The configuration of the proxy terminal. The value of this parameter is a JSON string that consists of the following fields:
	//
	// *   **TransactionReadSqlRouteOptimizeStatus**: the status of the transaction splitting feature. Valid values: **0** and **1**. The value 0 indicates that the feature is disabled. The value 1 indicates that the feature is enabled.
	// *   **ConnectionPersist**: the status of the connection pooling feature. Valid values: **0**, **1**, and **2**. The value 0 indicates that the connection pooling feature is disabled. The value 1 indicates that the session connection pooling feature is enabled. The value 2 indicates that the transaction connection pooling feature is enabled.
	// *   **ReadWriteSpliting**: the status of the read/write splitting feature. Valid values: **0** and **1**. The value 0 indicates that the feature is disabled. The value 1 indicates that the feature is enabled.
	// *   **PinPreparedStmt**: an internal field that is available only for ApsaraDB RDS for PostgrSQL instances.
	//
	// >  If the instance runs PostgreSQL, you can change only the value of the **ReadWriteSpliting** field. The **TransactionReadSqlRouteOptimizeStatus** and **PinPreparedStmt** fields are set to their default values 1.
	DBProxyFeatures *string `json:"DBProxyFeatures,omitempty" xml:"DBProxyFeatures,omitempty"`
	// The description of the proxy terminal.
	DbProxyEndpointAliases *string `json:"DbProxyEndpointAliases,omitempty" xml:"DbProxyEndpointAliases,omitempty"`
	// The read and write attributes of the proxy terminal. Valid values:
	//
	// *   **ReadWrite**: The proxy terminal supports read and write requests.
	// *   **ReadOnly**: The proxy terminal supports only read requests.
	DbProxyEndpointReadWriteMode *string `json:"DbProxyEndpointReadWriteMode,omitempty" xml:"DbProxyEndpointReadWriteMode,omitempty"`
	// An array that consists of the information about the proxy endpoint.
	EndpointConnectItems *DescribeDBProxyEndpointResponseBodyEndpointConnectItems `json:"EndpointConnectItems,omitempty" xml:"EndpointConnectItems,omitempty" type:"Struct"`
	// The method that is used to assign read weights. For more information, see [Modify the latency threshold and read weights of ApsaraDB RDS for MySQL instances](~~96076~~). Valid values:
	//
	// *   **Standard**: The system automatically assigns read weights to the instance and its read-only instances based on the specifications of these instances.
	// *   **Custom**: You must manually assign read weights to the instance and its read-only instances.
	ReadOnlyInstanceDistributionType *string `json:"ReadOnlyInstanceDistributionType,omitempty" xml:"ReadOnlyInstanceDistributionType,omitempty"`
	// The latency threshold that is allowed for read/write splitting. If the latency on a read-only instance exceeds the specified threshold, ApsaraDB RDS no longer forwards read requests to the read-only instance.
	ReadOnlyInstanceMaxDelayTime *string `json:"ReadOnlyInstanceMaxDelayTime,omitempty" xml:"ReadOnlyInstanceMaxDelayTime,omitempty"`
	// The read weights of the instance and its read-only instances. The value of this parameter is a JSON string that consists of the following parameters:
	//
	// *   **DBInstanceId**: the ID of the instance.
	// *   **DBInstanceType**: the role of the instance. Valid values: **Master** and **ReadOnly**.
	// *   **NodeID**: The IDs of the primary and secondary nodes of the cluster. An instance that runs RDS Cluster Edition refers to a cluster.
	// *   **NodeType**: The node type. Valid values: **Primary** and **Secondary**.
	// *   **Weight**: the read weight of the instance. The read weight increases in increments of **100** and cannot exceed **10000**.
	ReadOnlyInstanceWeight *string `json:"ReadOnlyInstanceWeight,omitempty" xml:"ReadOnlyInstanceWeight,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDBProxyEndpointResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBProxyEndpointResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDBProxyEndpointResponseBody) SetDBProxyConnectString(v string) *DescribeDBProxyEndpointResponseBody {
	s.DBProxyConnectString = &v
	return s
}

func (s *DescribeDBProxyEndpointResponseBody) SetDBProxyConnectStringNetType(v string) *DescribeDBProxyEndpointResponseBody {
	s.DBProxyConnectStringNetType = &v
	return s
}

func (s *DescribeDBProxyEndpointResponseBody) SetDBProxyConnectStringPort(v string) *DescribeDBProxyEndpointResponseBody {
	s.DBProxyConnectStringPort = &v
	return s
}

func (s *DescribeDBProxyEndpointResponseBody) SetDBProxyEndpointId(v string) *DescribeDBProxyEndpointResponseBody {
	s.DBProxyEndpointId = &v
	return s
}

func (s *DescribeDBProxyEndpointResponseBody) SetDBProxyEngineType(v string) *DescribeDBProxyEndpointResponseBody {
	s.DBProxyEngineType = &v
	return s
}

func (s *DescribeDBProxyEndpointResponseBody) SetDBProxyFeatures(v string) *DescribeDBProxyEndpointResponseBody {
	s.DBProxyFeatures = &v
	return s
}

func (s *DescribeDBProxyEndpointResponseBody) SetDbProxyEndpointAliases(v string) *DescribeDBProxyEndpointResponseBody {
	s.DbProxyEndpointAliases = &v
	return s
}

func (s *DescribeDBProxyEndpointResponseBody) SetDbProxyEndpointReadWriteMode(v string) *DescribeDBProxyEndpointResponseBody {
	s.DbProxyEndpointReadWriteMode = &v
	return s
}

func (s *DescribeDBProxyEndpointResponseBody) SetEndpointConnectItems(v *DescribeDBProxyEndpointResponseBodyEndpointConnectItems) *DescribeDBProxyEndpointResponseBody {
	s.EndpointConnectItems = v
	return s
}

func (s *DescribeDBProxyEndpointResponseBody) SetReadOnlyInstanceDistributionType(v string) *DescribeDBProxyEndpointResponseBody {
	s.ReadOnlyInstanceDistributionType = &v
	return s
}

func (s *DescribeDBProxyEndpointResponseBody) SetReadOnlyInstanceMaxDelayTime(v string) *DescribeDBProxyEndpointResponseBody {
	s.ReadOnlyInstanceMaxDelayTime = &v
	return s
}

func (s *DescribeDBProxyEndpointResponseBody) SetReadOnlyInstanceWeight(v string) *DescribeDBProxyEndpointResponseBody {
	s.ReadOnlyInstanceWeight = &v
	return s
}

func (s *DescribeDBProxyEndpointResponseBody) SetRequestId(v string) *DescribeDBProxyEndpointResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDBProxyEndpointResponseBodyEndpointConnectItems struct {
	EndpointConnectItems []*DescribeDBProxyEndpointResponseBodyEndpointConnectItemsEndpointConnectItems `json:"EndpointConnectItems,omitempty" xml:"EndpointConnectItems,omitempty" type:"Repeated"`
}

func (s DescribeDBProxyEndpointResponseBodyEndpointConnectItems) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBProxyEndpointResponseBodyEndpointConnectItems) GoString() string {
	return s.String()
}

func (s *DescribeDBProxyEndpointResponseBodyEndpointConnectItems) SetEndpointConnectItems(v []*DescribeDBProxyEndpointResponseBodyEndpointConnectItemsEndpointConnectItems) *DescribeDBProxyEndpointResponseBodyEndpointConnectItems {
	s.EndpointConnectItems = v
	return s
}

type DescribeDBProxyEndpointResponseBodyEndpointConnectItemsEndpointConnectItems struct {
	// The proxy endpoint queried.
	DbProxyEndpointConnectString *string `json:"DbProxyEndpointConnectString,omitempty" xml:"DbProxyEndpointConnectString,omitempty"`
	// The network type of the instance. Valid values:
	//
	// *   **0**: Internet
	// *   **1**: classic network
	// *   **2**: virtual private cloud (VPC)
	DbProxyEndpointNetType *string `json:"DbProxyEndpointNetType,omitempty" xml:"DbProxyEndpointNetType,omitempty"`
	// The port number that is associated with the proxy endpoint. Default value: **3306**.
	DbProxyEndpointPort *string `json:"DbProxyEndpointPort,omitempty" xml:"DbProxyEndpointPort,omitempty"`
}

func (s DescribeDBProxyEndpointResponseBodyEndpointConnectItemsEndpointConnectItems) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBProxyEndpointResponseBodyEndpointConnectItemsEndpointConnectItems) GoString() string {
	return s.String()
}

func (s *DescribeDBProxyEndpointResponseBodyEndpointConnectItemsEndpointConnectItems) SetDbProxyEndpointConnectString(v string) *DescribeDBProxyEndpointResponseBodyEndpointConnectItemsEndpointConnectItems {
	s.DbProxyEndpointConnectString = &v
	return s
}

func (s *DescribeDBProxyEndpointResponseBodyEndpointConnectItemsEndpointConnectItems) SetDbProxyEndpointNetType(v string) *DescribeDBProxyEndpointResponseBodyEndpointConnectItemsEndpointConnectItems {
	s.DbProxyEndpointNetType = &v
	return s
}

func (s *DescribeDBProxyEndpointResponseBodyEndpointConnectItemsEndpointConnectItems) SetDbProxyEndpointPort(v string) *DescribeDBProxyEndpointResponseBodyEndpointConnectItemsEndpointConnectItems {
	s.DbProxyEndpointPort = &v
	return s
}

type DescribeDBProxyEndpointResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDBProxyEndpointResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDBProxyEndpointResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBProxyEndpointResponse) GoString() string {
	return s.String()
}

func (s *DescribeDBProxyEndpointResponse) SetHeaders(v map[string]*string) *DescribeDBProxyEndpointResponse {
	s.Headers = v
	return s
}

func (s *DescribeDBProxyEndpointResponse) SetStatusCode(v int32) *DescribeDBProxyEndpointResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDBProxyEndpointResponse) SetBody(v *DescribeDBProxyEndpointResponseBody) *DescribeDBProxyEndpointResponse {
	s.Body = v
	return s
}

type DescribeDBProxyPerformanceRequest struct {
	// The instance ID. You can call the DescribeDBInstances operation to query the instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// A reserved parameter. You do not need to specify this parameter.
	DBProxyEngineType *string `json:"DBProxyEngineType,omitempty" xml:"DBProxyEngineType,omitempty"`
	// The type of proxy that is enabled on the instance. Set the value to **DedicatedProxy**.
	DBProxyInstanceType *string `json:"DBProxyInstanceType,omitempty" xml:"DBProxyInstanceType,omitempty"`
	// The end of the time range to query. The end time must be later than the start time. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The performance metrics that you want to query.
	//
	// If the instance runs MySQL, you can query only the **Maxscale_CpuUsage** performance metric, which indicates the CPU utilization of the instance.
	//
	// If the instance runs PostgreSQL, you can query the following performance metrics:
	//
	// *   **Maxscale_TotalConns**: the number of connections per second
	// *   **Maxscale_CurrentConns**: the number of connections that are established
	// *   **Maxscale_DownFlows**: outbound traffic
	// *   **Maxscale_UpFlows**: inbound traffic
	// *   **Maxscale_QPS**: QPS
	// *   **Maxscale_MemUsage**: memory usage
	// *   **Maxscale_CpuUsage**: CPU utilization
	//
	// If you want to query more than one performance metric, separate the performance metrics with commas (,). You can specify up to six performance metrics in a single request.
	MetricsName *string `json:"MetricsName,omitempty" xml:"MetricsName,omitempty"`
	OwnerId     *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID. You can call the DescribeRegions operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDBProxyPerformanceRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBProxyPerformanceRequest) GoString() string {
	return s.String()
}

func (s *DescribeDBProxyPerformanceRequest) SetDBInstanceId(v string) *DescribeDBProxyPerformanceRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeDBProxyPerformanceRequest) SetDBProxyEngineType(v string) *DescribeDBProxyPerformanceRequest {
	s.DBProxyEngineType = &v
	return s
}

func (s *DescribeDBProxyPerformanceRequest) SetDBProxyInstanceType(v string) *DescribeDBProxyPerformanceRequest {
	s.DBProxyInstanceType = &v
	return s
}

func (s *DescribeDBProxyPerformanceRequest) SetEndTime(v string) *DescribeDBProxyPerformanceRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDBProxyPerformanceRequest) SetMetricsName(v string) *DescribeDBProxyPerformanceRequest {
	s.MetricsName = &v
	return s
}

func (s *DescribeDBProxyPerformanceRequest) SetOwnerId(v int64) *DescribeDBProxyPerformanceRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeDBProxyPerformanceRequest) SetRegionId(v string) *DescribeDBProxyPerformanceRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeDBProxyPerformanceRequest) SetResourceOwnerAccount(v string) *DescribeDBProxyPerformanceRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeDBProxyPerformanceRequest) SetResourceOwnerId(v int64) *DescribeDBProxyPerformanceRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeDBProxyPerformanceRequest) SetStartTime(v string) *DescribeDBProxyPerformanceRequest {
	s.StartTime = &v
	return s
}

type DescribeDBProxyPerformanceResponseBody struct {
	// The instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// An internal parameter. You do not need to specify this parameter.
	DBProxyEngineType *string `json:"DBProxyEngineType,omitempty" xml:"DBProxyEngineType,omitempty"`
	// The end time of the query.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The performance list.
	PerformanceKeys *DescribeDBProxyPerformanceResponseBodyPerformanceKeys `json:"PerformanceKeys,omitempty" xml:"PerformanceKeys,omitempty" type:"Struct"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The start time of the query.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDBProxyPerformanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBProxyPerformanceResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDBProxyPerformanceResponseBody) SetDBInstanceId(v string) *DescribeDBProxyPerformanceResponseBody {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeDBProxyPerformanceResponseBody) SetDBProxyEngineType(v string) *DescribeDBProxyPerformanceResponseBody {
	s.DBProxyEngineType = &v
	return s
}

func (s *DescribeDBProxyPerformanceResponseBody) SetEndTime(v string) *DescribeDBProxyPerformanceResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeDBProxyPerformanceResponseBody) SetPerformanceKeys(v *DescribeDBProxyPerformanceResponseBodyPerformanceKeys) *DescribeDBProxyPerformanceResponseBody {
	s.PerformanceKeys = v
	return s
}

func (s *DescribeDBProxyPerformanceResponseBody) SetRequestId(v string) *DescribeDBProxyPerformanceResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDBProxyPerformanceResponseBody) SetStartTime(v string) *DescribeDBProxyPerformanceResponseBody {
	s.StartTime = &v
	return s
}

type DescribeDBProxyPerformanceResponseBodyPerformanceKeys struct {
	PerformanceKey []*DescribeDBProxyPerformanceResponseBodyPerformanceKeysPerformanceKey `json:"PerformanceKey,omitempty" xml:"PerformanceKey,omitempty" type:"Repeated"`
}

func (s DescribeDBProxyPerformanceResponseBodyPerformanceKeys) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBProxyPerformanceResponseBodyPerformanceKeys) GoString() string {
	return s.String()
}

func (s *DescribeDBProxyPerformanceResponseBodyPerformanceKeys) SetPerformanceKey(v []*DescribeDBProxyPerformanceResponseBodyPerformanceKeysPerformanceKey) *DescribeDBProxyPerformanceResponseBodyPerformanceKeys {
	s.PerformanceKey = v
	return s
}

type DescribeDBProxyPerformanceResponseBodyPerformanceKeysPerformanceKey struct {
	// The performance parameter.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The format in which the value of the performance metric is returned.
	ValueFormat *string `json:"ValueFormat,omitempty" xml:"ValueFormat,omitempty"`
	// The performance metrics.
	Values *DescribeDBProxyPerformanceResponseBodyPerformanceKeysPerformanceKeyValues `json:"Values,omitempty" xml:"Values,omitempty" type:"Struct"`
}

func (s DescribeDBProxyPerformanceResponseBodyPerformanceKeysPerformanceKey) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBProxyPerformanceResponseBodyPerformanceKeysPerformanceKey) GoString() string {
	return s.String()
}

func (s *DescribeDBProxyPerformanceResponseBodyPerformanceKeysPerformanceKey) SetKey(v string) *DescribeDBProxyPerformanceResponseBodyPerformanceKeysPerformanceKey {
	s.Key = &v
	return s
}

func (s *DescribeDBProxyPerformanceResponseBodyPerformanceKeysPerformanceKey) SetValueFormat(v string) *DescribeDBProxyPerformanceResponseBodyPerformanceKeysPerformanceKey {
	s.ValueFormat = &v
	return s
}

func (s *DescribeDBProxyPerformanceResponseBodyPerformanceKeysPerformanceKey) SetValues(v *DescribeDBProxyPerformanceResponseBodyPerformanceKeysPerformanceKeyValues) *DescribeDBProxyPerformanceResponseBodyPerformanceKeysPerformanceKey {
	s.Values = v
	return s
}

type DescribeDBProxyPerformanceResponseBodyPerformanceKeysPerformanceKeyValues struct {
	PerformanceValue []*DescribeDBProxyPerformanceResponseBodyPerformanceKeysPerformanceKeyValuesPerformanceValue `json:"PerformanceValue,omitempty" xml:"PerformanceValue,omitempty" type:"Repeated"`
}

func (s DescribeDBProxyPerformanceResponseBodyPerformanceKeysPerformanceKeyValues) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBProxyPerformanceResponseBodyPerformanceKeysPerformanceKeyValues) GoString() string {
	return s.String()
}

func (s *DescribeDBProxyPerformanceResponseBodyPerformanceKeysPerformanceKeyValues) SetPerformanceValue(v []*DescribeDBProxyPerformanceResponseBodyPerformanceKeysPerformanceKeyValuesPerformanceValue) *DescribeDBProxyPerformanceResponseBodyPerformanceKeysPerformanceKeyValues {
	s.PerformanceValue = v
	return s
}

type DescribeDBProxyPerformanceResponseBodyPerformanceKeysPerformanceKeyValuesPerformanceValue struct {
	// The date and time when the value of the performance metric was recorded. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	Date *string `json:"Date,omitempty" xml:"Date,omitempty"`
	// The value of the performance metric.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeDBProxyPerformanceResponseBodyPerformanceKeysPerformanceKeyValuesPerformanceValue) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBProxyPerformanceResponseBodyPerformanceKeysPerformanceKeyValuesPerformanceValue) GoString() string {
	return s.String()
}

func (s *DescribeDBProxyPerformanceResponseBodyPerformanceKeysPerformanceKeyValuesPerformanceValue) SetDate(v string) *DescribeDBProxyPerformanceResponseBodyPerformanceKeysPerformanceKeyValuesPerformanceValue {
	s.Date = &v
	return s
}

func (s *DescribeDBProxyPerformanceResponseBodyPerformanceKeysPerformanceKeyValuesPerformanceValue) SetValue(v string) *DescribeDBProxyPerformanceResponseBodyPerformanceKeysPerformanceKeyValuesPerformanceValue {
	s.Value = &v
	return s
}

type DescribeDBProxyPerformanceResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDBProxyPerformanceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDBProxyPerformanceResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDBProxyPerformanceResponse) GoString() string {
	return s.String()
}

func (s *DescribeDBProxyPerformanceResponse) SetHeaders(v map[string]*string) *DescribeDBProxyPerformanceResponse {
	s.Headers = v
	return s
}

func (s *DescribeDBProxyPerformanceResponse) SetStatusCode(v int32) *DescribeDBProxyPerformanceResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDBProxyPerformanceResponse) SetBody(v *DescribeDBProxyPerformanceResponseBody) *DescribeDBProxyPerformanceResponse {
	s.Body = v
	return s
}

type DescribeDTCSecurityIpHostsForSQLServerRequest struct {
	// The instance ID. You can call the [DescribeDBInstances](~~610396~~) operation to query the instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID. You can call the [DescribeDBInstanceAttribute](~~610394~~) operation to obtain the region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group. You can call the [DescribeDBInstanceAttribute](~~610394~~) to obtain the ID of the resource group.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	SecurityToken        *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s DescribeDTCSecurityIpHostsForSQLServerRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDTCSecurityIpHostsForSQLServerRequest) GoString() string {
	return s.String()
}

func (s *DescribeDTCSecurityIpHostsForSQLServerRequest) SetDBInstanceId(v string) *DescribeDTCSecurityIpHostsForSQLServerRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeDTCSecurityIpHostsForSQLServerRequest) SetOwnerAccount(v string) *DescribeDTCSecurityIpHostsForSQLServerRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeDTCSecurityIpHostsForSQLServerRequest) SetOwnerId(v int64) *DescribeDTCSecurityIpHostsForSQLServerRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeDTCSecurityIpHostsForSQLServerRequest) SetRegionId(v string) *DescribeDTCSecurityIpHostsForSQLServerRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeDTCSecurityIpHostsForSQLServerRequest) SetResourceGroupId(v string) *DescribeDTCSecurityIpHostsForSQLServerRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeDTCSecurityIpHostsForSQLServerRequest) SetResourceOwnerAccount(v string) *DescribeDTCSecurityIpHostsForSQLServerRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeDTCSecurityIpHostsForSQLServerRequest) SetResourceOwnerId(v int64) *DescribeDTCSecurityIpHostsForSQLServerRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeDTCSecurityIpHostsForSQLServerRequest) SetSecurityToken(v string) *DescribeDTCSecurityIpHostsForSQLServerRequest {
	s.SecurityToken = &v
	return s
}

type DescribeDTCSecurityIpHostsForSQLServerResponseBody struct {
	// The instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The number of distributed transaction whitelists.
	IpHostPairNum *string `json:"IpHostPairNum,omitempty" xml:"IpHostPairNum,omitempty"`
	// Details of distributed transaction whitelists.
	Items *DescribeDTCSecurityIpHostsForSQLServerResponseBodyItems `json:"Items,omitempty" xml:"Items,omitempty" type:"Struct"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDTCSecurityIpHostsForSQLServerResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDTCSecurityIpHostsForSQLServerResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDTCSecurityIpHostsForSQLServerResponseBody) SetDBInstanceId(v string) *DescribeDTCSecurityIpHostsForSQLServerResponseBody {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeDTCSecurityIpHostsForSQLServerResponseBody) SetIpHostPairNum(v string) *DescribeDTCSecurityIpHostsForSQLServerResponseBody {
	s.IpHostPairNum = &v
	return s
}

func (s *DescribeDTCSecurityIpHostsForSQLServerResponseBody) SetItems(v *DescribeDTCSecurityIpHostsForSQLServerResponseBodyItems) *DescribeDTCSecurityIpHostsForSQLServerResponseBody {
	s.Items = v
	return s
}

func (s *DescribeDTCSecurityIpHostsForSQLServerResponseBody) SetRequestId(v string) *DescribeDTCSecurityIpHostsForSQLServerResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDTCSecurityIpHostsForSQLServerResponseBodyItems struct {
	WhiteListGroups []*DescribeDTCSecurityIpHostsForSQLServerResponseBodyItemsWhiteListGroups `json:"WhiteListGroups,omitempty" xml:"WhiteListGroups,omitempty" type:"Repeated"`
}

func (s DescribeDTCSecurityIpHostsForSQLServerResponseBodyItems) String() string {
	return tea.Prettify(s)
}

func (s DescribeDTCSecurityIpHostsForSQLServerResponseBodyItems) GoString() string {
	return s.String()
}

func (s *DescribeDTCSecurityIpHostsForSQLServerResponseBodyItems) SetWhiteListGroups(v []*DescribeDTCSecurityIpHostsForSQLServerResponseBodyItemsWhiteListGroups) *DescribeDTCSecurityIpHostsForSQLServerResponseBodyItems {
	s.WhiteListGroups = v
	return s
}

type DescribeDTCSecurityIpHostsForSQLServerResponseBodyItemsWhiteListGroups struct {
	// The IP address of the ECS instance and the hostname of the Windows computer. Format: `IP address,Hostname`. Multiple values are separated with semicolons (;).
	SecurityIpHosts *string `json:"SecurityIpHosts,omitempty" xml:"SecurityIpHosts,omitempty"`
	// The name of the distributed transaction whitelist.
	WhitelistGroupName *string `json:"WhitelistGroupName,omitempty" xml:"WhitelistGroupName,omitempty"`
}

func (s DescribeDTCSecurityIpHostsForSQLServerResponseBodyItemsWhiteListGroups) String() string {
	return tea.Prettify(s)
}

func (s DescribeDTCSecurityIpHostsForSQLServerResponseBodyItemsWhiteListGroups) GoString() string {
	return s.String()
}

func (s *DescribeDTCSecurityIpHostsForSQLServerResponseBodyItemsWhiteListGroups) SetSecurityIpHosts(v string) *DescribeDTCSecurityIpHostsForSQLServerResponseBodyItemsWhiteListGroups {
	s.SecurityIpHosts = &v
	return s
}

func (s *DescribeDTCSecurityIpHostsForSQLServerResponseBodyItemsWhiteListGroups) SetWhitelistGroupName(v string) *DescribeDTCSecurityIpHostsForSQLServerResponseBodyItemsWhiteListGroups {
	s.WhitelistGroupName = &v
	return s
}

type DescribeDTCSecurityIpHostsForSQLServerResponse struct {
	Headers    map[string]*string                                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDTCSecurityIpHostsForSQLServerResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDTCSecurityIpHostsForSQLServerResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDTCSecurityIpHostsForSQLServerResponse) GoString() string {
	return s.String()
}

func (s *DescribeDTCSecurityIpHostsForSQLServerResponse) SetHeaders(v map[string]*string) *DescribeDTCSecurityIpHostsForSQLServerResponse {
	s.Headers = v
	return s
}

func (s *DescribeDTCSecurityIpHostsForSQLServerResponse) SetStatusCode(v int32) *DescribeDTCSecurityIpHostsForSQLServerResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDTCSecurityIpHostsForSQLServerResponse) SetBody(v *DescribeDTCSecurityIpHostsForSQLServerResponseBody) *DescribeDTCSecurityIpHostsForSQLServerResponse {
	s.Body = v
	return s
}

type DescribeDatabasesRequest struct {
	// The instance ID. You can call the [DescribeDBInstances](~~610396~~) operation to query the ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The name of the database.
	DBName *string `json:"DBName,omitempty" xml:"DBName,omitempty"`
	// The status of the database. Valid values:
	//
	// *   **Creating**
	// *   **Running**
	// *   **Deleting**
	DBStatus     *string `json:"DBStatus,omitempty" xml:"DBStatus,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The page number. Valid values: any non-zero positive integer.
	//
	// Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Valid values:
	//
	// *   **30**
	// *   **50**
	// *   **100**
	//
	// Default value: 30.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the resource group.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeDatabasesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDatabasesRequest) GoString() string {
	return s.String()
}

func (s *DescribeDatabasesRequest) SetDBInstanceId(v string) *DescribeDatabasesRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeDatabasesRequest) SetDBName(v string) *DescribeDatabasesRequest {
	s.DBName = &v
	return s
}

func (s *DescribeDatabasesRequest) SetDBStatus(v string) *DescribeDatabasesRequest {
	s.DBStatus = &v
	return s
}

func (s *DescribeDatabasesRequest) SetOwnerAccount(v string) *DescribeDatabasesRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeDatabasesRequest) SetOwnerId(v int64) *DescribeDatabasesRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeDatabasesRequest) SetPageNumber(v int32) *DescribeDatabasesRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeDatabasesRequest) SetPageSize(v int32) *DescribeDatabasesRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeDatabasesRequest) SetResourceGroupId(v string) *DescribeDatabasesRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeDatabasesRequest) SetResourceOwnerAccount(v string) *DescribeDatabasesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeDatabasesRequest) SetResourceOwnerId(v int64) *DescribeDatabasesRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeDatabasesResponseBody struct {
	// The information about databases.
	Databases *DescribeDatabasesResponseBodyDatabases `json:"Databases,omitempty" xml:"Databases,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDatabasesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDatabasesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDatabasesResponseBody) SetDatabases(v *DescribeDatabasesResponseBodyDatabases) *DescribeDatabasesResponseBody {
	s.Databases = v
	return s
}

func (s *DescribeDatabasesResponseBody) SetRequestId(v string) *DescribeDatabasesResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDatabasesResponseBodyDatabases struct {
	Database []*DescribeDatabasesResponseBodyDatabasesDatabase `json:"Database,omitempty" xml:"Database,omitempty" type:"Repeated"`
}

func (s DescribeDatabasesResponseBodyDatabases) String() string {
	return tea.Prettify(s)
}

func (s DescribeDatabasesResponseBodyDatabases) GoString() string {
	return s.String()
}

func (s *DescribeDatabasesResponseBodyDatabases) SetDatabase(v []*DescribeDatabasesResponseBodyDatabasesDatabase) *DescribeDatabasesResponseBodyDatabases {
	s.Database = v
	return s
}

type DescribeDatabasesResponseBodyDatabasesDatabase struct {
	// An array that consists of the details of the accounts. Each account has specific permissions on the database.
	Accounts *DescribeDatabasesResponseBodyDatabasesDatabaseAccounts `json:"Accounts,omitempty" xml:"Accounts,omitempty" type:"Struct"`
	// The advanced information about the database.
	//
	// > This parameter is returned only for instances that run SQL Server.
	AdvancedInfo *DescribeDatabasesResponseBodyDatabasesDatabaseAdvancedInfo `json:"AdvancedInfo,omitempty" xml:"AdvancedInfo,omitempty" type:"Struct"`
	// The basic information of the database.
	//
	// > This parameter is returned only for instances that run SQL Server.
	BasicInfo *DescribeDatabasesResponseBodyDatabasesDatabaseBasicInfo `json:"BasicInfo,omitempty" xml:"BasicInfo,omitempty" type:"Struct"`
	// The name of the character set.
	CharacterSetName *string `json:"CharacterSetName,omitempty" xml:"CharacterSetName,omitempty"`
	// The collation of the character set. The example value C stands for localization.
	//
	// > This parameter is returned only for instances that run PostgreSQL.
	Collate *string `json:"Collate,omitempty" xml:"Collate,omitempty"`
	// The limit on the number of concurrent requests. The value -1 indicates that the number of concurrent requests is unlimited.
	//
	// > This parameter is returned only for instances that run PostgreSQL.
	ConnLimit *string `json:"ConnLimit,omitempty" xml:"ConnLimit,omitempty"`
	// The type of the character set.
	//
	// > This parameter is returned only for instances that run PostgreSQL.
	Ctype *string `json:"Ctype,omitempty" xml:"Ctype,omitempty"`
	// The description of the database.
	DBDescription *string `json:"DBDescription,omitempty" xml:"DBDescription,omitempty"`
	// The ID of the instance to which the database belongs.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The name of the database.
	DBName *string `json:"DBName,omitempty" xml:"DBName,omitempty"`
	// The status of the database. Valid values:
	//
	// *   **Creating**
	// *   **Running**
	// *   **Deleting**
	DBStatus *string `json:"DBStatus,omitempty" xml:"DBStatus,omitempty"`
	// The database engine of the instance.
	Engine *string `json:"Engine,omitempty" xml:"Engine,omitempty"`
	// A reserved parameter.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// A reserved parameter.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The running of the database.
	//
	// > This parameter is returned only for instances that run SQL Server.
	RuntimeInfo *DescribeDatabasesResponseBodyDatabasesDatabaseRuntimeInfo `json:"RuntimeInfo,omitempty" xml:"RuntimeInfo,omitempty" type:"Struct"`
	// The tablespace of the database.
	//
	// > This parameter is returned only for instances that run PostgreSQL.
	Tablespace *string `json:"Tablespace,omitempty" xml:"Tablespace,omitempty"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeDatabasesResponseBodyDatabasesDatabase) String() string {
	return tea.Prettify(s)
}

func (s DescribeDatabasesResponseBodyDatabasesDatabase) GoString() string {
	return s.String()
}

func (s *DescribeDatabasesResponseBodyDatabasesDatabase) SetAccounts(v *DescribeDatabasesResponseBodyDatabasesDatabaseAccounts) *DescribeDatabasesResponseBodyDatabasesDatabase {
	s.Accounts = v
	return s
}

func (s *DescribeDatabasesResponseBodyDatabasesDatabase) SetAdvancedInfo(v *DescribeDatabasesResponseBodyDatabasesDatabaseAdvancedInfo) *DescribeDatabasesResponseBodyDatabasesDatabase {
	s.AdvancedInfo = v
	return s
}

func (s *DescribeDatabasesResponseBodyDatabasesDatabase) SetBasicInfo(v *DescribeDatabasesResponseBodyDatabasesDatabaseBasicInfo) *DescribeDatabasesResponseBodyDatabasesDatabase {
	s.BasicInfo = v
	return s
}

func (s *DescribeDatabasesResponseBodyDatabasesDatabase) SetCharacterSetName(v string) *DescribeDatabasesResponseBodyDatabasesDatabase {
	s.CharacterSetName = &v
	return s
}

func (s *DescribeDatabasesResponseBodyDatabasesDatabase) SetCollate(v string) *DescribeDatabasesResponseBodyDatabasesDatabase {
	s.Collate = &v
	return s
}

func (s *DescribeDatabasesResponseBodyDatabasesDatabase) SetConnLimit(v string) *DescribeDatabasesResponseBodyDatabasesDatabase {
	s.ConnLimit = &v
	return s
}

func (s *DescribeDatabasesResponseBodyDatabasesDatabase) SetCtype(v string) *DescribeDatabasesResponseBodyDatabasesDatabase {
	s.Ctype = &v
	return s
}

func (s *DescribeDatabasesResponseBodyDatabasesDatabase) SetDBDescription(v string) *DescribeDatabasesResponseBodyDatabasesDatabase {
	s.DBDescription = &v
	return s
}

func (s *DescribeDatabasesResponseBodyDatabasesDatabase) SetDBInstanceId(v string) *DescribeDatabasesResponseBodyDatabasesDatabase {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeDatabasesResponseBodyDatabasesDatabase) SetDBName(v string) *DescribeDatabasesResponseBodyDatabasesDatabase {
	s.DBName = &v
	return s
}

func (s *DescribeDatabasesResponseBodyDatabasesDatabase) SetDBStatus(v string) *DescribeDatabasesResponseBodyDatabasesDatabase {
	s.DBStatus = &v
	return s
}

func (s *DescribeDatabasesResponseBodyDatabasesDatabase) SetEngine(v string) *DescribeDatabasesResponseBodyDatabasesDatabase {
	s.Engine = &v
	return s
}

func (s *DescribeDatabasesResponseBodyDatabasesDatabase) SetPageNumber(v int32) *DescribeDatabasesResponseBodyDatabasesDatabase {
	s.PageNumber = &v
	return s
}

func (s *DescribeDatabasesResponseBodyDatabasesDatabase) SetPageSize(v int32) *DescribeDatabasesResponseBodyDatabasesDatabase {
	s.PageSize = &v
	return s
}

func (s *DescribeDatabasesResponseBodyDatabasesDatabase) SetResourceGroupId(v string) *DescribeDatabasesResponseBodyDatabasesDatabase {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeDatabasesResponseBodyDatabasesDatabase) SetRuntimeInfo(v *DescribeDatabasesResponseBodyDatabasesDatabaseRuntimeInfo) *DescribeDatabasesResponseBodyDatabasesDatabase {
	s.RuntimeInfo = v
	return s
}

func (s *DescribeDatabasesResponseBodyDatabasesDatabase) SetTablespace(v string) *DescribeDatabasesResponseBodyDatabasesDatabase {
	s.Tablespace = &v
	return s
}

func (s *DescribeDatabasesResponseBodyDatabasesDatabase) SetTotalCount(v int32) *DescribeDatabasesResponseBodyDatabasesDatabase {
	s.TotalCount = &v
	return s
}

type DescribeDatabasesResponseBodyDatabasesDatabaseAccounts struct {
	AccountPrivilegeInfo []*DescribeDatabasesResponseBodyDatabasesDatabaseAccountsAccountPrivilegeInfo `json:"AccountPrivilegeInfo,omitempty" xml:"AccountPrivilegeInfo,omitempty" type:"Repeated"`
}

func (s DescribeDatabasesResponseBodyDatabasesDatabaseAccounts) String() string {
	return tea.Prettify(s)
}

func (s DescribeDatabasesResponseBodyDatabasesDatabaseAccounts) GoString() string {
	return s.String()
}

func (s *DescribeDatabasesResponseBodyDatabasesDatabaseAccounts) SetAccountPrivilegeInfo(v []*DescribeDatabasesResponseBodyDatabasesDatabaseAccountsAccountPrivilegeInfo) *DescribeDatabasesResponseBodyDatabasesDatabaseAccounts {
	s.AccountPrivilegeInfo = v
	return s
}

type DescribeDatabasesResponseBodyDatabasesDatabaseAccountsAccountPrivilegeInfo struct {
	// The username of the account.
	Account *string `json:"Account,omitempty" xml:"Account,omitempty"`
	// The permissions that the account has on the database. Valid values:
	//
	// *   **ReadWrite**: read and write permissions
	// *   **ReadOnly**: read-only permissions
	// *   **DMLOnly**: DML-only permissions
	// *   **DDLOnly**: DDL-only permissions
	AccountPrivilege *string `json:"AccountPrivilege,omitempty" xml:"AccountPrivilege,omitempty"`
	// The details of the permissions that the account has on the database.
	AccountPrivilegeDetail *string `json:"AccountPrivilegeDetail,omitempty" xml:"AccountPrivilegeDetail,omitempty"`
}

func (s DescribeDatabasesResponseBodyDatabasesDatabaseAccountsAccountPrivilegeInfo) String() string {
	return tea.Prettify(s)
}

func (s DescribeDatabasesResponseBodyDatabasesDatabaseAccountsAccountPrivilegeInfo) GoString() string {
	return s.String()
}

func (s *DescribeDatabasesResponseBodyDatabasesDatabaseAccountsAccountPrivilegeInfo) SetAccount(v string) *DescribeDatabasesResponseBodyDatabasesDatabaseAccountsAccountPrivilegeInfo {
	s.Account = &v
	return s
}

func (s *DescribeDatabasesResponseBodyDatabasesDatabaseAccountsAccountPrivilegeInfo) SetAccountPrivilege(v string) *DescribeDatabasesResponseBodyDatabasesDatabaseAccountsAccountPrivilegeInfo {
	s.AccountPrivilege = &v
	return s
}

func (s *DescribeDatabasesResponseBodyDatabasesDatabaseAccountsAccountPrivilegeInfo) SetAccountPrivilegeDetail(v string) *DescribeDatabasesResponseBodyDatabasesDatabaseAccountsAccountPrivilegeInfo {
	s.AccountPrivilegeDetail = &v
	return s
}

type DescribeDatabasesResponseBodyDatabasesDatabaseAdvancedInfo struct {
	AdvancedDbProperty []map[string]interface{} `json:"AdvancedDbProperty,omitempty" xml:"AdvancedDbProperty,omitempty" type:"Repeated"`
}

func (s DescribeDatabasesResponseBodyDatabasesDatabaseAdvancedInfo) String() string {
	return tea.Prettify(s)
}

func (s DescribeDatabasesResponseBodyDatabasesDatabaseAdvancedInfo) GoString() string {
	return s.String()
}

func (s *DescribeDatabasesResponseBodyDatabasesDatabaseAdvancedInfo) SetAdvancedDbProperty(v []map[string]interface{}) *DescribeDatabasesResponseBodyDatabasesDatabaseAdvancedInfo {
	s.AdvancedDbProperty = v
	return s
}

type DescribeDatabasesResponseBodyDatabasesDatabaseBasicInfo struct {
	BasicDbProperty []map[string]interface{} `json:"BasicDbProperty,omitempty" xml:"BasicDbProperty,omitempty" type:"Repeated"`
}

func (s DescribeDatabasesResponseBodyDatabasesDatabaseBasicInfo) String() string {
	return tea.Prettify(s)
}

func (s DescribeDatabasesResponseBodyDatabasesDatabaseBasicInfo) GoString() string {
	return s.String()
}

func (s *DescribeDatabasesResponseBodyDatabasesDatabaseBasicInfo) SetBasicDbProperty(v []map[string]interface{}) *DescribeDatabasesResponseBodyDatabasesDatabaseBasicInfo {
	s.BasicDbProperty = v
	return s
}

type DescribeDatabasesResponseBodyDatabasesDatabaseRuntimeInfo struct {
	RuntimeDbProperty []map[string]interface{} `json:"RuntimeDbProperty,omitempty" xml:"RuntimeDbProperty,omitempty" type:"Repeated"`
}

func (s DescribeDatabasesResponseBodyDatabasesDatabaseRuntimeInfo) String() string {
	return tea.Prettify(s)
}

func (s DescribeDatabasesResponseBodyDatabasesDatabaseRuntimeInfo) GoString() string {
	return s.String()
}

func (s *DescribeDatabasesResponseBodyDatabasesDatabaseRuntimeInfo) SetRuntimeDbProperty(v []map[string]interface{}) *DescribeDatabasesResponseBodyDatabasesDatabaseRuntimeInfo {
	s.RuntimeDbProperty = v
	return s
}

type DescribeDatabasesResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDatabasesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDatabasesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDatabasesResponse) GoString() string {
	return s.String()
}

func (s *DescribeDatabasesResponse) SetHeaders(v map[string]*string) *DescribeDatabasesResponse {
	s.Headers = v
	return s
}

func (s *DescribeDatabasesResponse) SetStatusCode(v int32) *DescribeDatabasesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDatabasesResponse) SetBody(v *DescribeDatabasesResponseBody) *DescribeDatabasesResponse {
	s.Body = v
	return s
}

type DescribeDedicatedHostGroupsRequest struct {
	// The dedicated cluster ID.
	DedicatedHostGroupId *string `json:"DedicatedHostGroupId,omitempty" xml:"DedicatedHostGroupId,omitempty"`
	// The image based on which the hosts in the dedicated clusters are created. Valid values:
	//
	// *   **WindowsWithMssqlStdLicense**: a Windows image that contains the licenses of SQL Server Standard Edition
	// *   **WindowsWithMssqlEntLisence**: a Windows image that contains the licenses of SQL Server Enterprise Edition
	// *   **WindowsWithMssqlWebLisence**: a Windows image that contains the licenses of SQL Server Web Edition
	// *   **AliLinux**: a Linux image
	ImageCategory *string `json:"ImageCategory,omitempty" xml:"ImageCategory,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID. You can call the [DescribeRegions](~~26243~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeDedicatedHostGroupsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDedicatedHostGroupsRequest) GoString() string {
	return s.String()
}

func (s *DescribeDedicatedHostGroupsRequest) SetDedicatedHostGroupId(v string) *DescribeDedicatedHostGroupsRequest {
	s.DedicatedHostGroupId = &v
	return s
}

func (s *DescribeDedicatedHostGroupsRequest) SetImageCategory(v string) *DescribeDedicatedHostGroupsRequest {
	s.ImageCategory = &v
	return s
}

func (s *DescribeDedicatedHostGroupsRequest) SetOwnerId(v int64) *DescribeDedicatedHostGroupsRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeDedicatedHostGroupsRequest) SetRegionId(v string) *DescribeDedicatedHostGroupsRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeDedicatedHostGroupsRequest) SetResourceOwnerAccount(v string) *DescribeDedicatedHostGroupsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeDedicatedHostGroupsRequest) SetResourceOwnerId(v int64) *DescribeDedicatedHostGroupsRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeDedicatedHostGroupsResponseBody struct {
	// The information about dedicated clusters returned.
	DedicatedHostGroups *DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroups `json:"DedicatedHostGroups,omitempty" xml:"DedicatedHostGroups,omitempty" type:"Struct"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDedicatedHostGroupsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDedicatedHostGroupsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDedicatedHostGroupsResponseBody) SetDedicatedHostGroups(v *DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroups) *DescribeDedicatedHostGroupsResponseBody {
	s.DedicatedHostGroups = v
	return s
}

func (s *DescribeDedicatedHostGroupsResponseBody) SetRequestId(v string) *DescribeDedicatedHostGroupsResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroups struct {
	DedicatedHostGroups []*DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroups `json:"DedicatedHostGroups,omitempty" xml:"DedicatedHostGroups,omitempty" type:"Repeated"`
}

func (s DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroups) String() string {
	return tea.Prettify(s)
}

func (s DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroups) GoString() string {
	return s.String()
}

func (s *DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroups) SetDedicatedHostGroups(v []*DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroups) *DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroups {
	s.DedicatedHostGroups = v
	return s
}

type DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroups struct {
	// The policy based on which the system allocates resources in the dedicated cluster. Valid values:
	//
	// *   **Evenly**: The system evenly allocates the resources to all the hosts in the dedicated cluster.
	// *   **Intensively**: The system preferentially allocates the resources to the heavily loaded hosts in the dedicated cluster.
	AllocationPolicy *string `json:"AllocationPolicy,omitempty" xml:"AllocationPolicy,omitempty"`
	// The ID of the bastion host.
	BastionInstanceId *string `json:"BastionInstanceId,omitempty" xml:"BastionInstanceId,omitempty"`
	// The percentage of allocated cores in the dedicated cluster. Unit: %.
	CpuAllocateRation *float32 `json:"CpuAllocateRation,omitempty" xml:"CpuAllocateRation,omitempty"`
	// The number of allocated cores in the dedicated cluster.
	CpuAllocatedAmount *float32 `json:"CpuAllocatedAmount,omitempty" xml:"CpuAllocatedAmount,omitempty"`
	// The core overcommitment ratio of the dedicated cluster. Unit: %. For more information about the core overcommitment ratio, see [Manage a dedicated cluster](~~182328~~).
	CpuAllocationRatio *int32 `json:"CpuAllocationRatio,omitempty" xml:"CpuAllocationRatio,omitempty"`
	// The timestamp when the dedicated cluster was created.
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The type of storage media that is used for the hosts in the dedicated cluster. Valid values:
	//
	// *   **dhg_cloud_ssd**: cloud disks
	// *   **dhg_local_ssd**: local disks
	DedicatedHostCountGroupByHostType map[string]interface{} `json:"DedicatedHostCountGroupByHostType,omitempty" xml:"DedicatedHostCountGroupByHostType,omitempty"`
	// The name of the dedicated cluster.
	DedicatedHostGroupDesc *string `json:"DedicatedHostGroupDesc,omitempty" xml:"DedicatedHostGroupDesc,omitempty"`
	// The ID of the dedicated cluster.
	DedicatedHostGroupId *string `json:"DedicatedHostGroupId,omitempty" xml:"DedicatedHostGroupId,omitempty"`
	// The percentage of allocated disk space in the dedicated cluster. Unit: %.
	DiskAllocateRation *float32 `json:"DiskAllocateRation,omitempty" xml:"DiskAllocateRation,omitempty"`
	// The amount of allocated disk space in the dedicated cluster. Unit: GB.
	DiskAllocatedAmount *float32 `json:"DiskAllocatedAmount,omitempty" xml:"DiskAllocatedAmount,omitempty"`
	// The disk overcommitment ratio of the dedicated cluster. Unit: %. For more information about the core overcommitment ratio, see [Manage a dedicated cluster](~~182328~~).
	DiskAllocationRatio *int32 `json:"DiskAllocationRatio,omitempty" xml:"DiskAllocationRatio,omitempty"`
	// The amount of used disk space in the dedicated cluster. Unit: GB.
	DiskUsedAmount *float32 `json:"DiskUsedAmount,omitempty" xml:"DiskUsedAmount,omitempty"`
	// The disk usage of the dedicated cluster. Unit: %.
	DiskUtility *float32 `json:"DiskUtility,omitempty" xml:"DiskUtility,omitempty"`
	// The database engine of the instances in the dedicated cluster.
	Engine *string `json:"Engine,omitempty" xml:"Engine,omitempty"`
	// The total number of hosts in the dedicated cluster.
	HostNumber *int32 `json:"HostNumber,omitempty" xml:"HostNumber,omitempty"`
	// The policy that is used to handle host failures. Valid values:
	//
	// *   **Auto**: The system automatically replaces faulty hosts.
	// *   **Manual**: You must manually replace faulty hosts.
	HostReplacePolicy *string `json:"HostReplacePolicy,omitempty" xml:"HostReplacePolicy,omitempty"`
	// The total number of instances in the dedicated cluster.
	InstanceNumber *int32 `json:"InstanceNumber,omitempty" xml:"InstanceNumber,omitempty"`
	// The percentage of allocated memory space in the dedicated cluster. Unit: %.
	MemAllocateRation *float32 `json:"MemAllocateRation,omitempty" xml:"MemAllocateRation,omitempty"`
	// The amount of allocated memory space in the dedicated cluster.
	MemAllocatedAmount *float32 `json:"MemAllocatedAmount,omitempty" xml:"MemAllocatedAmount,omitempty"`
	// The memory overcommitment ratio of the dedicated cluster. Unit: %. For more information about the core overcommitment ratio, see [Manage a dedicated cluster](~~182328~~).
	MemAllocationRatio *int32 `json:"MemAllocationRatio,omitempty" xml:"MemAllocationRatio,omitempty"`
	// The amount of used memory space in the dedicated cluster. Unit: MB.
	MemUsedAmount *float32 `json:"MemUsedAmount,omitempty" xml:"MemUsedAmount,omitempty"`
	// The memory usage of the dedicated cluster. Unit: %.
	MemUtility *float32 `json:"MemUtility,omitempty" xml:"MemUtility,omitempty"`
	// Indicates whether the feature that allows you to have the OS permissions on the host is enabled. Valid values:
	//
	// *   **0** or **null**: The permissions cannot be granted.
	// *   **1**: The permissions can be granted.
	// *   **3**: The permissions have been granted.
	OpenPermission *string `json:"OpenPermission,omitempty" xml:"OpenPermission,omitempty"`
	// The name and ID of the dedicated cluster. The value consists of **DedicatedHostGroupDesc** and **DedicatedHostGroupId**. Format: DedicatedHostGroupDesc/DedicatedHostGroupId.
	Text *string `json:"Text,omitempty" xml:"Text,omitempty"`
	// The ID of the virtual private cloud (VPC) to which the dedicated cluster belongs.
	VPCId *string `json:"VPCId,omitempty" xml:"VPCId,omitempty"`
	// The zones to which the hosts of the dedicated cluster belong.
	ZoneIDList *DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroupsZoneIDList `json:"ZoneIDList,omitempty" xml:"ZoneIDList,omitempty" type:"Struct"`
}

func (s DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroups) String() string {
	return tea.Prettify(s)
}

func (s DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroups) GoString() string {
	return s.String()
}

func (s *DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroups) SetAllocationPolicy(v string) *DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroups {
	s.AllocationPolicy = &v
	return s
}

func (s *DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroups) SetBastionInstanceId(v string) *DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroups {
	s.BastionInstanceId = &v
	return s
}

func (s *DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroups) SetCpuAllocateRation(v float32) *DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroups {
	s.CpuAllocateRation = &v
	return s
}

func (s *DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroups) SetCpuAllocatedAmount(v float32) *DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroups {
	s.CpuAllocatedAmount = &v
	return s
}

func (s *DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroups) SetCpuAllocationRatio(v int32) *DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroups {
	s.CpuAllocationRatio = &v
	return s
}

func (s *DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroups) SetCreateTime(v string) *DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroups {
	s.CreateTime = &v
	return s
}

func (s *DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroups) SetDedicatedHostCountGroupByHostType(v map[string]interface{}) *DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroups {
	s.DedicatedHostCountGroupByHostType = v
	return s
}

func (s *DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroups) SetDedicatedHostGroupDesc(v string) *DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroups {
	s.DedicatedHostGroupDesc = &v
	return s
}

func (s *DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroups) SetDedicatedHostGroupId(v string) *DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroups {
	s.DedicatedHostGroupId = &v
	return s
}

func (s *DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroups) SetDiskAllocateRation(v float32) *DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroups {
	s.DiskAllocateRation = &v
	return s
}

func (s *DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroups) SetDiskAllocatedAmount(v float32) *DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroups {
	s.DiskAllocatedAmount = &v
	return s
}

func (s *DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroups) SetDiskAllocationRatio(v int32) *DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroups {
	s.DiskAllocationRatio = &v
	return s
}

func (s *DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroups) SetDiskUsedAmount(v float32) *DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroups {
	s.DiskUsedAmount = &v
	return s
}

func (s *DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroups) SetDiskUtility(v float32) *DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroups {
	s.DiskUtility = &v
	return s
}

func (s *DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroups) SetEngine(v string) *DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroups {
	s.Engine = &v
	return s
}

func (s *DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroups) SetHostNumber(v int32) *DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroups {
	s.HostNumber = &v
	return s
}

func (s *DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroups) SetHostReplacePolicy(v string) *DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroups {
	s.HostReplacePolicy = &v
	return s
}

func (s *DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroups) SetInstanceNumber(v int32) *DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroups {
	s.InstanceNumber = &v
	return s
}

func (s *DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroups) SetMemAllocateRation(v float32) *DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroups {
	s.MemAllocateRation = &v
	return s
}

func (s *DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroups) SetMemAllocatedAmount(v float32) *DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroups {
	s.MemAllocatedAmount = &v
	return s
}

func (s *DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroups) SetMemAllocationRatio(v int32) *DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroups {
	s.MemAllocationRatio = &v
	return s
}

func (s *DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroups) SetMemUsedAmount(v float32) *DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroups {
	s.MemUsedAmount = &v
	return s
}

func (s *DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroups) SetMemUtility(v float32) *DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroups {
	s.MemUtility = &v
	return s
}

func (s *DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroups) SetOpenPermission(v string) *DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroups {
	s.OpenPermission = &v
	return s
}

func (s *DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroups) SetText(v string) *DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroups {
	s.Text = &v
	return s
}

func (s *DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroups) SetVPCId(v string) *DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroups {
	s.VPCId = &v
	return s
}

func (s *DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroups) SetZoneIDList(v *DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroupsZoneIDList) *DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroups {
	s.ZoneIDList = v
	return s
}

type DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroupsZoneIDList struct {
	ZoneIDList []*string `json:"ZoneIDList,omitempty" xml:"ZoneIDList,omitempty" type:"Repeated"`
}

func (s DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroupsZoneIDList) String() string {
	return tea.Prettify(s)
}

func (s DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroupsZoneIDList) GoString() string {
	return s.String()
}

func (s *DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroupsZoneIDList) SetZoneIDList(v []*string) *DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroupsZoneIDList {
	s.ZoneIDList = v
	return s
}

type DescribeDedicatedHostGroupsResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDedicatedHostGroupsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDedicatedHostGroupsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDedicatedHostGroupsResponse) GoString() string {
	return s.String()
}

func (s *DescribeDedicatedHostGroupsResponse) SetHeaders(v map[string]*string) *DescribeDedicatedHostGroupsResponse {
	s.Headers = v
	return s
}

func (s *DescribeDedicatedHostGroupsResponse) SetStatusCode(v int32) *DescribeDedicatedHostGroupsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDedicatedHostGroupsResponse) SetBody(v *DescribeDedicatedHostGroupsResponseBody) *DescribeDedicatedHostGroupsResponse {
	s.Body = v
	return s
}

type DescribeDedicatedHostsRequest struct {
	// Specifies whether to query the hosts on which you can create instances or those on which you cannot create instances. Valid values:
	//
	// *   **0**: queries the hosts on which you cannot create instances
	// *   **1**: queries the hosts on which you can create instances
	AllocationStatus *string `json:"AllocationStatus,omitempty" xml:"AllocationStatus,omitempty"`
	// The ID of the dedicated cluster. You can call the [DescribeDedicatedHostGroups](~~141946~~) operation to query the IDs of dedicated clusters.
	DedicatedHostGroupId *string `json:"DedicatedHostGroupId,omitempty" xml:"DedicatedHostGroupId,omitempty"`
	// The ID of the host.
	DedicatedHostId *string `json:"DedicatedHostId,omitempty" xml:"DedicatedHostId,omitempty"`
	// The status of the hosts. Valid values:
	//
	// *   **0**: queries the hosts that are being created
	// *   **1**: queries the hosts that are running
	// *   **2**: queries the hosts that are faulty
	// *   **3**: queries the hosts that are being replaced
	// *   **4**: queries the hosts that are deprecated
	// *   **5**: queries the hosts that are being deleted
	// *   **6**: queries the hosts that are restarting
	HostStatus *string `json:"HostStatus,omitempty" xml:"HostStatus,omitempty"`
	// The type of storage media that is used for the hosts. Valid values:
	//
	// *   **dhg_cloud_ssd**: enhanced solid-state drive (SSD)
	// *   **dhg_local_ssd**: local SSD
	HostType *string `json:"HostType,omitempty" xml:"HostType,omitempty"`
	// The ID of the order.
	OrderId *int64 `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	OwnerId *int64 `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the hosts. You can call the [DescribeRegions](~~26243~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The zone ID of the hosts.
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
}

func (s DescribeDedicatedHostsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDedicatedHostsRequest) GoString() string {
	return s.String()
}

func (s *DescribeDedicatedHostsRequest) SetAllocationStatus(v string) *DescribeDedicatedHostsRequest {
	s.AllocationStatus = &v
	return s
}

func (s *DescribeDedicatedHostsRequest) SetDedicatedHostGroupId(v string) *DescribeDedicatedHostsRequest {
	s.DedicatedHostGroupId = &v
	return s
}

func (s *DescribeDedicatedHostsRequest) SetDedicatedHostId(v string) *DescribeDedicatedHostsRequest {
	s.DedicatedHostId = &v
	return s
}

func (s *DescribeDedicatedHostsRequest) SetHostStatus(v string) *DescribeDedicatedHostsRequest {
	s.HostStatus = &v
	return s
}

func (s *DescribeDedicatedHostsRequest) SetHostType(v string) *DescribeDedicatedHostsRequest {
	s.HostType = &v
	return s
}

func (s *DescribeDedicatedHostsRequest) SetOrderId(v int64) *DescribeDedicatedHostsRequest {
	s.OrderId = &v
	return s
}

func (s *DescribeDedicatedHostsRequest) SetOwnerId(v int64) *DescribeDedicatedHostsRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeDedicatedHostsRequest) SetRegionId(v string) *DescribeDedicatedHostsRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeDedicatedHostsRequest) SetResourceOwnerAccount(v string) *DescribeDedicatedHostsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeDedicatedHostsRequest) SetResourceOwnerId(v int64) *DescribeDedicatedHostsRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeDedicatedHostsRequest) SetZoneId(v string) *DescribeDedicatedHostsRequest {
	s.ZoneId = &v
	return s
}

type DescribeDedicatedHostsResponseBody struct {
	// The ID of the dedicated cluster.
	DedicatedHostGroupId *string `json:"DedicatedHostGroupId,omitempty" xml:"DedicatedHostGroupId,omitempty"`
	// An array that consists of hosts returned.
	DedicatedHosts *DescribeDedicatedHostsResponseBodyDedicatedHosts `json:"DedicatedHosts,omitempty" xml:"DedicatedHosts,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDedicatedHostsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDedicatedHostsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDedicatedHostsResponseBody) SetDedicatedHostGroupId(v string) *DescribeDedicatedHostsResponseBody {
	s.DedicatedHostGroupId = &v
	return s
}

func (s *DescribeDedicatedHostsResponseBody) SetDedicatedHosts(v *DescribeDedicatedHostsResponseBodyDedicatedHosts) *DescribeDedicatedHostsResponseBody {
	s.DedicatedHosts = v
	return s
}

func (s *DescribeDedicatedHostsResponseBody) SetRequestId(v string) *DescribeDedicatedHostsResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDedicatedHostsResponseBodyDedicatedHosts struct {
	DedicatedHosts []*DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHosts `json:"DedicatedHosts,omitempty" xml:"DedicatedHosts,omitempty" type:"Repeated"`
}

func (s DescribeDedicatedHostsResponseBodyDedicatedHosts) String() string {
	return tea.Prettify(s)
}

func (s DescribeDedicatedHostsResponseBodyDedicatedHosts) GoString() string {
	return s.String()
}

func (s *DescribeDedicatedHostsResponseBodyDedicatedHosts) SetDedicatedHosts(v []*DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHosts) *DescribeDedicatedHostsResponseBodyDedicatedHosts {
	s.DedicatedHosts = v
	return s
}

type DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHosts struct {
	// The account of the host. You can call the [CreateDedicatedHostAccount](~~196877~~) operation to create a host account.
	AccountName *string `json:"AccountName,omitempty" xml:"AccountName,omitempty"`
	// Indicates whether the system allows you to create instances on the host. Valid values:
	//
	// *   **0**: The system does not allow you to create instances on the host.
	// *   **1**: The system allows you to create instances on the host.
	AllocationStatus *string `json:"AllocationStatus,omitempty" xml:"AllocationStatus,omitempty"`
	// The ID of the bastion host.
	BastionInstanceId *string `json:"BastionInstanceId,omitempty" xml:"BastionInstanceId,omitempty"`
	// The core overcommitment ratio of the dedicated cluster. Unit: %. For more information about the core overcommitment ratio, see [Manage a dedicated cluster](~~182328~~).
	CPUAllocationRatio *string `json:"CPUAllocationRatio,omitempty" xml:"CPUAllocationRatio,omitempty"`
	// The number of used cores on the host.
	CpuUsed *string `json:"CpuUsed,omitempty" xml:"CpuUsed,omitempty"`
	// The time when the host was created.
	CreatedTime *string `json:"CreatedTime,omitempty" xml:"CreatedTime,omitempty"`
	// The ID of the dedicated cluster.
	DedicatedHostGroupId *string `json:"DedicatedHostGroupId,omitempty" xml:"DedicatedHostGroupId,omitempty"`
	// The ID of the host.
	DedicatedHostId *string `json:"DedicatedHostId,omitempty" xml:"DedicatedHostId,omitempty"`
	// The disk overcommitment ratio of the dedicated cluster. Unit: %. For more information about the disk overcommitment ratio, see [Manage a dedicated cluster](~~182328~~).
	DiskAllocationRatio *string `json:"DiskAllocationRatio,omitempty" xml:"DiskAllocationRatio,omitempty"`
	// The time when the host expires.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The database engine of instances that are created on the host.
	Engine *string `json:"Engine,omitempty" xml:"Engine,omitempty"`
	// The total number of cores that are configured for the host.
	HostCPU *string `json:"HostCPU,omitempty" xml:"HostCPU,omitempty"`
	// The specifications of the host.
	HostClass *string `json:"HostClass,omitempty" xml:"HostClass,omitempty"`
	// The total memory space of the host. Unit: MB.
	HostMem *string `json:"HostMem,omitempty" xml:"HostMem,omitempty"`
	// The name of the host.
	HostName *string `json:"HostName,omitempty" xml:"HostName,omitempty"`
	// The status of the host. Valid values:
	//
	// *   **0**: The host is being created.
	// *   **1**: The host is running.
	// *   **2**: The host is faulty.
	// *   **3**: The host is being replaced.
	// *   **4**: The host is deprecated.
	// *   **5**: The host is being deleted.
	// *   **6**: The host is restarting.
	HostStatus *string `json:"HostStatus,omitempty" xml:"HostStatus,omitempty"`
	// The storage capacity of the host. Unit: MB.
	HostStorage *string `json:"HostStorage,omitempty" xml:"HostStorage,omitempty"`
	// The type of storage media that is used for the host. Valid values:
	//
	// *   **dhg_cloud_ssd**: enhanced SSD
	// *   **dhg_local_ssd**: local SSD
	HostType *string `json:"HostType,omitempty" xml:"HostType,omitempty"`
	// The internal IP address of the host.
	IPAddress *string `json:"IPAddress,omitempty" xml:"IPAddress,omitempty"`
	// The image of the host. This parameter is returned only when the **Engine** parameter is set to **mssql**. Valid values:
	//
	// *   **WindowsWithMssqlStdLicense**: a Windows image, which contains the licenses of the SQL Server Standard Edition
	// *   **WindowsWithMssqlEntLisence**: a Windows image, which contains the licenses of the SQL Server Enterprise Edition
	// *   **WindowsWithMssqlWebLisence**: a Windows image, which contains the licenses of the SQL Server Web Edition
	ImageCategory *string `json:"ImageCategory,omitempty" xml:"ImageCategory,omitempty"`
	// The total number of instances that are created on the host.
	InstanceNumber *string `json:"InstanceNumber,omitempty" xml:"InstanceNumber,omitempty"`
	// The maximum memory usage per host in the dedicated cluster.
	MemAllocationRatio *string `json:"MemAllocationRatio,omitempty" xml:"MemAllocationRatio,omitempty"`
	// The amount of used memory space on the host. Unit: MB.
	MemoryUsed *string `json:"MemoryUsed,omitempty" xml:"MemoryUsed,omitempty"`
	// Indicates whether the operating system permissions of the host can be granted. Valid values:
	//
	// *   **0** or **null**: The permissions cannot be granted.
	// *   **1**: The permissions can be granted.
	// *   **3**: The permissions have been granted.
	OpenPermission *string `json:"OpenPermission,omitempty" xml:"OpenPermission,omitempty"`
	// The amount of used storage space on the host.
	StorageUsed *string `json:"StorageUsed,omitempty" xml:"StorageUsed,omitempty"`
	// The ID of the virtual private cloud (VPC) to which the host belongs.
	VPCId *string `json:"VPCId,omitempty" xml:"VPCId,omitempty"`
	// The ID of the vSwitch associated with the specified VPC.
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
	// The zone ID of the host.
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
}

func (s DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHosts) String() string {
	return tea.Prettify(s)
}

func (s DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHosts) GoString() string {
	return s.String()
}

func (s *DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHosts) SetAccountName(v string) *DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHosts {
	s.AccountName = &v
	return s
}

func (s *DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHosts) SetAllocationStatus(v string) *DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHosts {
	s.AllocationStatus = &v
	return s
}

func (s *DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHosts) SetBastionInstanceId(v string) *DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHosts {
	s.BastionInstanceId = &v
	return s
}

func (s *DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHosts) SetCPUAllocationRatio(v string) *DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHosts {
	s.CPUAllocationRatio = &v
	return s
}

func (s *DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHosts) SetCpuUsed(v string) *DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHosts {
	s.CpuUsed = &v
	return s
}

func (s *DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHosts) SetCreatedTime(v string) *DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHosts {
	s.CreatedTime = &v
	return s
}

func (s *DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHosts) SetDedicatedHostGroupId(v string) *DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHosts {
	s.DedicatedHostGroupId = &v
	return s
}

func (s *DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHosts) SetDedicatedHostId(v string) *DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHosts {
	s.DedicatedHostId = &v
	return s
}

func (s *DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHosts) SetDiskAllocationRatio(v string) *DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHosts {
	s.DiskAllocationRatio = &v
	return s
}

func (s *DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHosts) SetEndTime(v string) *DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHosts {
	s.EndTime = &v
	return s
}

func (s *DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHosts) SetEngine(v string) *DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHosts {
	s.Engine = &v
	return s
}

func (s *DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHosts) SetHostCPU(v string) *DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHosts {
	s.HostCPU = &v
	return s
}

func (s *DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHosts) SetHostClass(v string) *DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHosts {
	s.HostClass = &v
	return s
}

func (s *DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHosts) SetHostMem(v string) *DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHosts {
	s.HostMem = &v
	return s
}

func (s *DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHosts) SetHostName(v string) *DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHosts {
	s.HostName = &v
	return s
}

func (s *DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHosts) SetHostStatus(v string) *DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHosts {
	s.HostStatus = &v
	return s
}

func (s *DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHosts) SetHostStorage(v string) *DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHosts {
	s.HostStorage = &v
	return s
}

func (s *DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHosts) SetHostType(v string) *DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHosts {
	s.HostType = &v
	return s
}

func (s *DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHosts) SetIPAddress(v string) *DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHosts {
	s.IPAddress = &v
	return s
}

func (s *DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHosts) SetImageCategory(v string) *DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHosts {
	s.ImageCategory = &v
	return s
}

func (s *DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHosts) SetInstanceNumber(v string) *DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHosts {
	s.InstanceNumber = &v
	return s
}

func (s *DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHosts) SetMemAllocationRatio(v string) *DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHosts {
	s.MemAllocationRatio = &v
	return s
}

func (s *DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHosts) SetMemoryUsed(v string) *DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHosts {
	s.MemoryUsed = &v
	return s
}

func (s *DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHosts) SetOpenPermission(v string) *DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHosts {
	s.OpenPermission = &v
	return s
}

func (s *DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHosts) SetStorageUsed(v string) *DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHosts {
	s.StorageUsed = &v
	return s
}

func (s *DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHosts) SetVPCId(v string) *DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHosts {
	s.VPCId = &v
	return s
}

func (s *DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHosts) SetVSwitchId(v string) *DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHosts {
	s.VSwitchId = &v
	return s
}

func (s *DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHosts) SetZoneId(v string) *DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHosts {
	s.ZoneId = &v
	return s
}

type DescribeDedicatedHostsResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDedicatedHostsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDedicatedHostsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDedicatedHostsResponse) GoString() string {
	return s.String()
}

func (s *DescribeDedicatedHostsResponse) SetHeaders(v map[string]*string) *DescribeDedicatedHostsResponse {
	s.Headers = v
	return s
}

func (s *DescribeDedicatedHostsResponse) SetStatusCode(v int32) *DescribeDedicatedHostsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDedicatedHostsResponse) SetBody(v *DescribeDedicatedHostsResponseBody) *DescribeDedicatedHostsResponse {
	s.Body = v
	return s
}

type DescribeDetachedBackupsRequest struct {
	// The ID of the backup set.
	BackupId *string `json:"BackupId,omitempty" xml:"BackupId,omitempty"`
	// The backup method. Valid values:
	//
	// *   **Automated**
	// *   **Manual**
	BackupMode *string `json:"BackupMode,omitempty" xml:"BackupMode,omitempty"`
	// The status of the backup set. Valid values:
	//
	// *   **Success**
	// *   **Failed**
	BackupStatus *string `json:"BackupStatus,omitempty" xml:"BackupStatus,omitempty"`
	// The instance ID. You can call the DescribeDBInstances operation to query the instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The end of the time range to query. The end time must be later than the start time.
	//
	// Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm*Z format. The time must be in UTC.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The page number. Pages start from page 1.
	//
	// > The default value is 1.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries per page. Valid values:
	//
	// *   **30**
	// *   **50**
	// *   **100**
	//
	// > The default value is **30**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The region ID of the instance.
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerId *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The beginning of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm*Z format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDetachedBackupsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDetachedBackupsRequest) GoString() string {
	return s.String()
}

func (s *DescribeDetachedBackupsRequest) SetBackupId(v string) *DescribeDetachedBackupsRequest {
	s.BackupId = &v
	return s
}

func (s *DescribeDetachedBackupsRequest) SetBackupMode(v string) *DescribeDetachedBackupsRequest {
	s.BackupMode = &v
	return s
}

func (s *DescribeDetachedBackupsRequest) SetBackupStatus(v string) *DescribeDetachedBackupsRequest {
	s.BackupStatus = &v
	return s
}

func (s *DescribeDetachedBackupsRequest) SetDBInstanceId(v string) *DescribeDetachedBackupsRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeDetachedBackupsRequest) SetEndTime(v string) *DescribeDetachedBackupsRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDetachedBackupsRequest) SetPageNumber(v int32) *DescribeDetachedBackupsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeDetachedBackupsRequest) SetPageSize(v int32) *DescribeDetachedBackupsRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeDetachedBackupsRequest) SetRegion(v string) *DescribeDetachedBackupsRequest {
	s.Region = &v
	return s
}

func (s *DescribeDetachedBackupsRequest) SetResourceGroupId(v string) *DescribeDetachedBackupsRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeDetachedBackupsRequest) SetResourceOwnerId(v int64) *DescribeDetachedBackupsRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeDetachedBackupsRequest) SetStartTime(v string) *DescribeDetachedBackupsRequest {
	s.StartTime = &v
	return s
}

type DescribeDetachedBackupsResponseBody struct {
	// The queried backup sets.
	Items *DescribeDetachedBackupsResponseBodyItems `json:"Items,omitempty" xml:"Items,omitempty" type:"Struct"`
	// The page number.
	PageNumber *string `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries per page.
	PageRecordCount *string `json:"PageRecordCount,omitempty" xml:"PageRecordCount,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalRecordCount *string `json:"TotalRecordCount,omitempty" xml:"TotalRecordCount,omitempty"`
}

func (s DescribeDetachedBackupsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDetachedBackupsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDetachedBackupsResponseBody) SetItems(v *DescribeDetachedBackupsResponseBodyItems) *DescribeDetachedBackupsResponseBody {
	s.Items = v
	return s
}

func (s *DescribeDetachedBackupsResponseBody) SetPageNumber(v string) *DescribeDetachedBackupsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeDetachedBackupsResponseBody) SetPageRecordCount(v string) *DescribeDetachedBackupsResponseBody {
	s.PageRecordCount = &v
	return s
}

func (s *DescribeDetachedBackupsResponseBody) SetRequestId(v string) *DescribeDetachedBackupsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDetachedBackupsResponseBody) SetTotalRecordCount(v string) *DescribeDetachedBackupsResponseBody {
	s.TotalRecordCount = &v
	return s
}

type DescribeDetachedBackupsResponseBodyItems struct {
	Backup []*DescribeDetachedBackupsResponseBodyItemsBackup `json:"Backup,omitempty" xml:"Backup,omitempty" type:"Repeated"`
}

func (s DescribeDetachedBackupsResponseBodyItems) String() string {
	return tea.Prettify(s)
}

func (s DescribeDetachedBackupsResponseBodyItems) GoString() string {
	return s.String()
}

func (s *DescribeDetachedBackupsResponseBodyItems) SetBackup(v []*DescribeDetachedBackupsResponseBodyItemsBackup) *DescribeDetachedBackupsResponseBodyItems {
	s.Backup = v
	return s
}

type DescribeDetachedBackupsResponseBodyItemsBackup struct {
	// The URL that is used to download the diagnostic report over the Internet. If the diagnostic report cannot be downloaded, an empty string is returned.
	BackupDownloadURL *string `json:"BackupDownloadURL,omitempty" xml:"BackupDownloadURL,omitempty"`
	// The end time of the backup task.
	//
	// The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm*Z format. The time is displayed in UTC.
	BackupEndTime *string `json:"BackupEndTime,omitempty" xml:"BackupEndTime,omitempty"`
	// The ID of the backup set.
	BackupId *string `json:"BackupId,omitempty" xml:"BackupId,omitempty"`
	// The URL that is used to download the log file over an internal network. If the log file cannot be downloaded, an empty string is returned.
	BackupIntranetDownloadURL *string `json:"BackupIntranetDownloadURL,omitempty" xml:"BackupIntranetDownloadURL,omitempty"`
	// The method that is used to generate the data backup file. Valid values:
	//
	// *   **Logical**: logical backup
	// *   **Physical**: physical backup
	BackupMethod *string `json:"BackupMethod,omitempty" xml:"BackupMethod,omitempty"`
	// The backup method. Valid values:
	//
	// *   **Automated**
	// *   **Manual**
	BackupMode *string `json:"BackupMode,omitempty" xml:"BackupMode,omitempty"`
	// The backup size. Unit: bytes.
	BackupSize *int64 `json:"BackupSize,omitempty" xml:"BackupSize,omitempty"`
	// The start time of the backup task.
	//
	// The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm*Z format. The time is displayed in UTC.
	BackupStartTime *string `json:"BackupStartTime,omitempty" xml:"BackupStartTime,omitempty"`
	// The status of the backup set. Valid values:
	//
	// *   **Success**
	// *   **Failed**
	BackupStatus *string `json:"BackupStatus,omitempty" xml:"BackupStatus,omitempty"`
	// The backup type of the backup file. Valid values:
	//
	// *   **FullBackup**
	// *   **IncrementalBackup**
	BackupType *string `json:"BackupType,omitempty" xml:"BackupType,omitempty"`
	// The point in time at which the data in the backup set is consistent. The return value of this parameter is a timestamp.
	//
	// >  If the instance runs MySQL 5.6, a timestamp is returned. Otherwise, the value 0 is returned.
	ConsistentTime *int64 `json:"ConsistentTime,omitempty" xml:"ConsistentTime,omitempty"`
	// The description of the instance.
	DBInstanceComment *string `json:"DBInstanceComment,omitempty" xml:"DBInstanceComment,omitempty"`
	// The instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The ID of the instance that generates the backup set. This parameter is used to indicate whether the instance that generates the backup set is a primary instance or a secondary instance.
	HostInstanceID *string `json:"HostInstanceID,omitempty" xml:"HostInstanceID,omitempty"`
	// Indicates whether the backup set is available. Valid values:
	//
	// *   **0**: The backup set is unavailable.
	// *   **1**: The backup set is available.
	IsAvail *int32 `json:"IsAvail,omitempty" xml:"IsAvail,omitempty"`
	// The status of the backup set that is used to restore individual databases or tables. Valid values:
	//
	// *   **OK**: The backup set is normal.
	// *   **LARGE**: The backup set contains an abnormally large number of tables. It cannot be used to restore individual databases or tables.
	// *   **EMPTY**: The backup set is generated from a failed backup task.
	MetaStatus *string `json:"MetaStatus,omitempty" xml:"MetaStatus,omitempty"`
	// Indicates whether the data backup file can be deleted. Valid values:
	//
	// *   **Enabled**
	// *   **Disabled**
	StoreStatus *string `json:"StoreStatus,omitempty" xml:"StoreStatus,omitempty"`
}

func (s DescribeDetachedBackupsResponseBodyItemsBackup) String() string {
	return tea.Prettify(s)
}

func (s DescribeDetachedBackupsResponseBodyItemsBackup) GoString() string {
	return s.String()
}

func (s *DescribeDetachedBackupsResponseBodyItemsBackup) SetBackupDownloadURL(v string) *DescribeDetachedBackupsResponseBodyItemsBackup {
	s.BackupDownloadURL = &v
	return s
}

func (s *DescribeDetachedBackupsResponseBodyItemsBackup) SetBackupEndTime(v string) *DescribeDetachedBackupsResponseBodyItemsBackup {
	s.BackupEndTime = &v
	return s
}

func (s *DescribeDetachedBackupsResponseBodyItemsBackup) SetBackupId(v string) *DescribeDetachedBackupsResponseBodyItemsBackup {
	s.BackupId = &v
	return s
}

func (s *DescribeDetachedBackupsResponseBodyItemsBackup) SetBackupIntranetDownloadURL(v string) *DescribeDetachedBackupsResponseBodyItemsBackup {
	s.BackupIntranetDownloadURL = &v
	return s
}

func (s *DescribeDetachedBackupsResponseBodyItemsBackup) SetBackupMethod(v string) *DescribeDetachedBackupsResponseBodyItemsBackup {
	s.BackupMethod = &v
	return s
}

func (s *DescribeDetachedBackupsResponseBodyItemsBackup) SetBackupMode(v string) *DescribeDetachedBackupsResponseBodyItemsBackup {
	s.BackupMode = &v
	return s
}

func (s *DescribeDetachedBackupsResponseBodyItemsBackup) SetBackupSize(v int64) *DescribeDetachedBackupsResponseBodyItemsBackup {
	s.BackupSize = &v
	return s
}

func (s *DescribeDetachedBackupsResponseBodyItemsBackup) SetBackupStartTime(v string) *DescribeDetachedBackupsResponseBodyItemsBackup {
	s.BackupStartTime = &v
	return s
}

func (s *DescribeDetachedBackupsResponseBodyItemsBackup) SetBackupStatus(v string) *DescribeDetachedBackupsResponseBodyItemsBackup {
	s.BackupStatus = &v
	return s
}

func (s *DescribeDetachedBackupsResponseBodyItemsBackup) SetBackupType(v string) *DescribeDetachedBackupsResponseBodyItemsBackup {
	s.BackupType = &v
	return s
}

func (s *DescribeDetachedBackupsResponseBodyItemsBackup) SetConsistentTime(v int64) *DescribeDetachedBackupsResponseBodyItemsBackup {
	s.ConsistentTime = &v
	return s
}

func (s *DescribeDetachedBackupsResponseBodyItemsBackup) SetDBInstanceComment(v string) *DescribeDetachedBackupsResponseBodyItemsBackup {
	s.DBInstanceComment = &v
	return s
}

func (s *DescribeDetachedBackupsResponseBodyItemsBackup) SetDBInstanceId(v string) *DescribeDetachedBackupsResponseBodyItemsBackup {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeDetachedBackupsResponseBodyItemsBackup) SetHostInstanceID(v string) *DescribeDetachedBackupsResponseBodyItemsBackup {
	s.HostInstanceID = &v
	return s
}

func (s *DescribeDetachedBackupsResponseBodyItemsBackup) SetIsAvail(v int32) *DescribeDetachedBackupsResponseBodyItemsBackup {
	s.IsAvail = &v
	return s
}

func (s *DescribeDetachedBackupsResponseBodyItemsBackup) SetMetaStatus(v string) *DescribeDetachedBackupsResponseBodyItemsBackup {
	s.MetaStatus = &v
	return s
}

func (s *DescribeDetachedBackupsResponseBodyItemsBackup) SetStoreStatus(v string) *DescribeDetachedBackupsResponseBodyItemsBackup {
	s.StoreStatus = &v
	return s
}

type DescribeDetachedBackupsResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDetachedBackupsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDetachedBackupsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDetachedBackupsResponse) GoString() string {
	return s.String()
}

func (s *DescribeDetachedBackupsResponse) SetHeaders(v map[string]*string) *DescribeDetachedBackupsResponse {
	s.Headers = v
	return s
}

func (s *DescribeDetachedBackupsResponse) SetStatusCode(v int32) *DescribeDetachedBackupsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDetachedBackupsResponse) SetBody(v *DescribeDetachedBackupsResponseBody) *DescribeDetachedBackupsResponse {
	s.Body = v
	return s
}

type DescribeDiagnosticReportListRequest struct {
	// The ID of the instance. You can call the [DescribeDBInstances](~~610396~~) operation to query the ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The resource group ID.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
}

func (s DescribeDiagnosticReportListRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDiagnosticReportListRequest) GoString() string {
	return s.String()
}

func (s *DescribeDiagnosticReportListRequest) SetDBInstanceId(v string) *DescribeDiagnosticReportListRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeDiagnosticReportListRequest) SetResourceGroupId(v string) *DescribeDiagnosticReportListRequest {
	s.ResourceGroupId = &v
	return s
}

type DescribeDiagnosticReportListResponseBody struct {
	// The ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The details of a diagnostic report.
	ReportList []*DescribeDiagnosticReportListResponseBodyReportList `json:"ReportList,omitempty" xml:"ReportList,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDiagnosticReportListResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDiagnosticReportListResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDiagnosticReportListResponseBody) SetDBInstanceId(v string) *DescribeDiagnosticReportListResponseBody {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeDiagnosticReportListResponseBody) SetReportList(v []*DescribeDiagnosticReportListResponseBodyReportList) *DescribeDiagnosticReportListResponseBody {
	s.ReportList = v
	return s
}

func (s *DescribeDiagnosticReportListResponseBody) SetRequestId(v string) *DescribeDiagnosticReportListResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDiagnosticReportListResponseBodyReportList struct {
	// The time when the diagnosis was performed.
	DiagnosticTime *string `json:"DiagnosticTime,omitempty" xml:"DiagnosticTime,omitempty"`
	// The URL that is used to download the backup set over the Internet. If the backup set cannot be downloaded, an empty string is returned.
	DownloadURL *string `json:"DownloadURL,omitempty" xml:"DownloadURL,omitempty"`
	// The end time of the monitoring data.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The diagnostic score.
	Score *int32 `json:"Score,omitempty" xml:"Score,omitempty"`
	// The start time of the monitoring data.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDiagnosticReportListResponseBodyReportList) String() string {
	return tea.Prettify(s)
}

func (s DescribeDiagnosticReportListResponseBodyReportList) GoString() string {
	return s.String()
}

func (s *DescribeDiagnosticReportListResponseBodyReportList) SetDiagnosticTime(v string) *DescribeDiagnosticReportListResponseBodyReportList {
	s.DiagnosticTime = &v
	return s
}

func (s *DescribeDiagnosticReportListResponseBodyReportList) SetDownloadURL(v string) *DescribeDiagnosticReportListResponseBodyReportList {
	s.DownloadURL = &v
	return s
}

func (s *DescribeDiagnosticReportListResponseBodyReportList) SetEndTime(v string) *DescribeDiagnosticReportListResponseBodyReportList {
	s.EndTime = &v
	return s
}

func (s *DescribeDiagnosticReportListResponseBodyReportList) SetScore(v int32) *DescribeDiagnosticReportListResponseBodyReportList {
	s.Score = &v
	return s
}

func (s *DescribeDiagnosticReportListResponseBodyReportList) SetStartTime(v string) *DescribeDiagnosticReportListResponseBodyReportList {
	s.StartTime = &v
	return s
}

type DescribeDiagnosticReportListResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDiagnosticReportListResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDiagnosticReportListResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDiagnosticReportListResponse) GoString() string {
	return s.String()
}

func (s *DescribeDiagnosticReportListResponse) SetHeaders(v map[string]*string) *DescribeDiagnosticReportListResponse {
	s.Headers = v
	return s
}

func (s *DescribeDiagnosticReportListResponse) SetStatusCode(v int32) *DescribeDiagnosticReportListResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDiagnosticReportListResponse) SetBody(v *DescribeDiagnosticReportListResponseBody) *DescribeDiagnosticReportListResponse {
	s.Body = v
	return s
}

type DescribeErrorLogsRequest struct {
	// The ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The end of the time range to query. The end time must be later than the start time. The time span between the start time and the end time must be less than 31 days. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm*Z format. The time must be in UTC.
	EndTime      *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of the page to return. Valid values: a non-zero positive integer.
	//
	// Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Valid values: **30** to **100**. Default value: **30**.
	PageSize             *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The start of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm*Z format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeErrorLogsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeErrorLogsRequest) GoString() string {
	return s.String()
}

func (s *DescribeErrorLogsRequest) SetDBInstanceId(v string) *DescribeErrorLogsRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeErrorLogsRequest) SetEndTime(v string) *DescribeErrorLogsRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeErrorLogsRequest) SetOwnerAccount(v string) *DescribeErrorLogsRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeErrorLogsRequest) SetOwnerId(v int64) *DescribeErrorLogsRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeErrorLogsRequest) SetPageNumber(v int32) *DescribeErrorLogsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeErrorLogsRequest) SetPageSize(v int32) *DescribeErrorLogsRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeErrorLogsRequest) SetResourceOwnerAccount(v string) *DescribeErrorLogsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeErrorLogsRequest) SetResourceOwnerId(v int64) *DescribeErrorLogsRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeErrorLogsRequest) SetStartTime(v string) *DescribeErrorLogsRequest {
	s.StartTime = &v
	return s
}

type DescribeErrorLogsResponseBody struct {
	// The list of items in an error log.
	Items *DescribeErrorLogsResponseBodyItems `json:"Items,omitempty" xml:"Items,omitempty" type:"Struct"`
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of error logs on the current page.
	PageRecordCount *int32 `json:"PageRecordCount,omitempty" xml:"PageRecordCount,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of error logs.
	TotalRecordCount *int32 `json:"TotalRecordCount,omitempty" xml:"TotalRecordCount,omitempty"`
}

func (s DescribeErrorLogsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeErrorLogsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeErrorLogsResponseBody) SetItems(v *DescribeErrorLogsResponseBodyItems) *DescribeErrorLogsResponseBody {
	s.Items = v
	return s
}

func (s *DescribeErrorLogsResponseBody) SetPageNumber(v int32) *DescribeErrorLogsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeErrorLogsResponseBody) SetPageRecordCount(v int32) *DescribeErrorLogsResponseBody {
	s.PageRecordCount = &v
	return s
}

func (s *DescribeErrorLogsResponseBody) SetRequestId(v string) *DescribeErrorLogsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeErrorLogsResponseBody) SetTotalRecordCount(v int32) *DescribeErrorLogsResponseBody {
	s.TotalRecordCount = &v
	return s
}

type DescribeErrorLogsResponseBodyItems struct {
	ErrorLog []*DescribeErrorLogsResponseBodyItemsErrorLog `json:"ErrorLog,omitempty" xml:"ErrorLog,omitempty" type:"Repeated"`
}

func (s DescribeErrorLogsResponseBodyItems) String() string {
	return tea.Prettify(s)
}

func (s DescribeErrorLogsResponseBodyItems) GoString() string {
	return s.String()
}

func (s *DescribeErrorLogsResponseBodyItems) SetErrorLog(v []*DescribeErrorLogsResponseBodyItemsErrorLog) *DescribeErrorLogsResponseBodyItems {
	s.ErrorLog = v
	return s
}

type DescribeErrorLogsResponseBodyItemsErrorLog struct {
	// The time when the error log was generated. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The error log information.
	ErrorInfo *string `json:"ErrorInfo,omitempty" xml:"ErrorInfo,omitempty"`
}

func (s DescribeErrorLogsResponseBodyItemsErrorLog) String() string {
	return tea.Prettify(s)
}

func (s DescribeErrorLogsResponseBodyItemsErrorLog) GoString() string {
	return s.String()
}

func (s *DescribeErrorLogsResponseBodyItemsErrorLog) SetCreateTime(v string) *DescribeErrorLogsResponseBodyItemsErrorLog {
	s.CreateTime = &v
	return s
}

func (s *DescribeErrorLogsResponseBodyItemsErrorLog) SetErrorInfo(v string) *DescribeErrorLogsResponseBodyItemsErrorLog {
	s.ErrorInfo = &v
	return s
}

type DescribeErrorLogsResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeErrorLogsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeErrorLogsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeErrorLogsResponse) GoString() string {
	return s.String()
}

func (s *DescribeErrorLogsResponse) SetHeaders(v map[string]*string) *DescribeErrorLogsResponse {
	s.Headers = v
	return s
}

func (s *DescribeErrorLogsResponse) SetStatusCode(v int32) *DescribeErrorLogsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeErrorLogsResponse) SetBody(v *DescribeErrorLogsResponseBody) *DescribeErrorLogsResponse {
	s.Body = v
	return s
}

type DescribeEventsRequest struct {
	// The end of the time range to query. The end time must be later than the start time. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	OwnerId *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of the page to return. Valid values: any non-zero positive integer.
	//
	// Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Valid values:
	//
	// *   **30**
	// *   **50**
	// *   **100**
	//
	// Default value: **30**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The region ID of the instance. You can call the [DescribeRegions](~~26243~~) operation to query the IDs of regions.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeEventsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeEventsRequest) GoString() string {
	return s.String()
}

func (s *DescribeEventsRequest) SetEndTime(v string) *DescribeEventsRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeEventsRequest) SetOwnerId(v int64) *DescribeEventsRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeEventsRequest) SetPageNumber(v int32) *DescribeEventsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeEventsRequest) SetPageSize(v int32) *DescribeEventsRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeEventsRequest) SetRegionId(v string) *DescribeEventsRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeEventsRequest) SetResourceOwnerAccount(v string) *DescribeEventsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeEventsRequest) SetResourceOwnerId(v int64) *DescribeEventsRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeEventsRequest) SetStartTime(v string) *DescribeEventsRequest {
	s.StartTime = &v
	return s
}

type DescribeEventsResponseBody struct {
	// The details of the events.
	EventItems *DescribeEventsResponseBodyEventItems `json:"EventItems,omitempty" xml:"EventItems,omitempty" type:"Struct"`
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalRecordCount *int32 `json:"TotalRecordCount,omitempty" xml:"TotalRecordCount,omitempty"`
}

func (s DescribeEventsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeEventsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeEventsResponseBody) SetEventItems(v *DescribeEventsResponseBodyEventItems) *DescribeEventsResponseBody {
	s.EventItems = v
	return s
}

func (s *DescribeEventsResponseBody) SetPageNumber(v int32) *DescribeEventsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeEventsResponseBody) SetPageSize(v int32) *DescribeEventsResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeEventsResponseBody) SetRequestId(v string) *DescribeEventsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeEventsResponseBody) SetTotalRecordCount(v int32) *DescribeEventsResponseBody {
	s.TotalRecordCount = &v
	return s
}

type DescribeEventsResponseBodyEventItems struct {
	EventItems []*DescribeEventsResponseBodyEventItemsEventItems `json:"EventItems,omitempty" xml:"EventItems,omitempty" type:"Repeated"`
}

func (s DescribeEventsResponseBodyEventItems) String() string {
	return tea.Prettify(s)
}

func (s DescribeEventsResponseBodyEventItems) GoString() string {
	return s.String()
}

func (s *DescribeEventsResponseBodyEventItems) SetEventItems(v []*DescribeEventsResponseBodyEventItemsEventItems) *DescribeEventsResponseBodyEventItems {
	s.EventItems = v
	return s
}

type DescribeEventsResponseBodyEventItemsEventItems struct {
	// The ID of the user who executed the event.
	CallerUid *int64 `json:"CallerUid,omitempty" xml:"CallerUid,omitempty"`
	// The ID of the event.
	EventId *int32 `json:"EventId,omitempty" xml:"EventId,omitempty"`
	// The name of the event. For more information, see [View the event history of an ApsaraDB RDS instance](~~129759~~).
	EventName *string `json:"EventName,omitempty" xml:"EventName,omitempty"`
	// The request or context parameters of the event.
	EventPayload *string `json:"EventPayload,omitempty" xml:"EventPayload,omitempty"`
	// The source of the event. For more information, see [View the event history of an ApsaraDB RDS instance](~~129759~~).
	EventReason *string `json:"EventReason,omitempty" xml:"EventReason,omitempty"`
	// The time when the event was recorded. The time is slightly later than the time the event occurred.
	EventRecordTime *string `json:"EventRecordTime,omitempty" xml:"EventRecordTime,omitempty"`
	// The time when the event occurred.
	EventTime *string `json:"EventTime,omitempty" xml:"EventTime,omitempty"`
	// The type of the event. For more information, see [View the event history of an ApsaraDB RDS instance](~~129759~~).
	EventType *string `json:"EventType,omitempty" xml:"EventType,omitempty"`
	// The type of the user who executed the event.
	EventUserType *string `json:"EventUserType,omitempty" xml:"EventUserType,omitempty"`
	// The region ID of the instance.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The name of the resource associated with the event. Only instance IDs are supported for this parameter.
	ResourceName *string `json:"ResourceName,omitempty" xml:"ResourceName,omitempty"`
	// The type of the resource associated with the event. Only instances are supported for this parameter.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
}

func (s DescribeEventsResponseBodyEventItemsEventItems) String() string {
	return tea.Prettify(s)
}

func (s DescribeEventsResponseBodyEventItemsEventItems) GoString() string {
	return s.String()
}

func (s *DescribeEventsResponseBodyEventItemsEventItems) SetCallerUid(v int64) *DescribeEventsResponseBodyEventItemsEventItems {
	s.CallerUid = &v
	return s
}

func (s *DescribeEventsResponseBodyEventItemsEventItems) SetEventId(v int32) *DescribeEventsResponseBodyEventItemsEventItems {
	s.EventId = &v
	return s
}

func (s *DescribeEventsResponseBodyEventItemsEventItems) SetEventName(v string) *DescribeEventsResponseBodyEventItemsEventItems {
	s.EventName = &v
	return s
}

func (s *DescribeEventsResponseBodyEventItemsEventItems) SetEventPayload(v string) *DescribeEventsResponseBodyEventItemsEventItems {
	s.EventPayload = &v
	return s
}

func (s *DescribeEventsResponseBodyEventItemsEventItems) SetEventReason(v string) *DescribeEventsResponseBodyEventItemsEventItems {
	s.EventReason = &v
	return s
}

func (s *DescribeEventsResponseBodyEventItemsEventItems) SetEventRecordTime(v string) *DescribeEventsResponseBodyEventItemsEventItems {
	s.EventRecordTime = &v
	return s
}

func (s *DescribeEventsResponseBodyEventItemsEventItems) SetEventTime(v string) *DescribeEventsResponseBodyEventItemsEventItems {
	s.EventTime = &v
	return s
}

func (s *DescribeEventsResponseBodyEventItemsEventItems) SetEventType(v string) *DescribeEventsResponseBodyEventItemsEventItems {
	s.EventType = &v
	return s
}

func (s *DescribeEventsResponseBodyEventItemsEventItems) SetEventUserType(v string) *DescribeEventsResponseBodyEventItemsEventItems {
	s.EventUserType = &v
	return s
}

func (s *DescribeEventsResponseBodyEventItemsEventItems) SetRegionId(v string) *DescribeEventsResponseBodyEventItemsEventItems {
	s.RegionId = &v
	return s
}

func (s *DescribeEventsResponseBodyEventItemsEventItems) SetResourceName(v string) *DescribeEventsResponseBodyEventItemsEventItems {
	s.ResourceName = &v
	return s
}

func (s *DescribeEventsResponseBodyEventItemsEventItems) SetResourceType(v string) *DescribeEventsResponseBodyEventItemsEventItems {
	s.ResourceType = &v
	return s
}

type DescribeEventsResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeEventsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeEventsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeEventsResponse) GoString() string {
	return s.String()
}

func (s *DescribeEventsResponse) SetHeaders(v map[string]*string) *DescribeEventsResponse {
	s.Headers = v
	return s
}

func (s *DescribeEventsResponse) SetStatusCode(v int32) *DescribeEventsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeEventsResponse) SetBody(v *DescribeEventsResponseBody) *DescribeEventsResponse {
	s.Body = v
	return s
}

type DescribeGadInstancesRequest struct {
	// The ID of the global active database cluster.
	//
	// *   If you leave this parameter empty, this operation returns the details about all global active database clusters that are created within your Alibaba Cloud account.
	// *   If you specify this parameter, this operation returns the details about the global active database cluster that you specify.
	//
	// >  If you do not specify this parameter when you call this operation for the first time, the IDs of all clusters that are created by using the current account are returned. Then, you can specify the cluster ID to view the cluster details.
	GadInstanceName *string `json:"GadInstanceName,omitempty" xml:"GadInstanceName,omitempty"`
	// The region ID. You can call the [DescribeRegions](~~26243~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
}

func (s DescribeGadInstancesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeGadInstancesRequest) GoString() string {
	return s.String()
}

func (s *DescribeGadInstancesRequest) SetGadInstanceName(v string) *DescribeGadInstancesRequest {
	s.GadInstanceName = &v
	return s
}

func (s *DescribeGadInstancesRequest) SetRegionId(v string) *DescribeGadInstancesRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeGadInstancesRequest) SetResourceGroupId(v string) *DescribeGadInstancesRequest {
	s.ResourceGroupId = &v
	return s
}

type DescribeGadInstancesResponseBody struct {
	// The details about the global active database cluster.
	GadInstances []*DescribeGadInstancesResponseBodyGadInstances `json:"GadInstances,omitempty" xml:"GadInstances,omitempty" type:"Repeated"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeGadInstancesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeGadInstancesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeGadInstancesResponseBody) SetGadInstances(v []*DescribeGadInstancesResponseBodyGadInstances) *DescribeGadInstancesResponseBody {
	s.GadInstances = v
	return s
}

func (s *DescribeGadInstancesResponseBody) SetRequestId(v string) *DescribeGadInstancesResponseBody {
	s.RequestId = &v
	return s
}

type DescribeGadInstancesResponseBodyGadInstances struct {
	// The time when the global active database cluster was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The cluster name.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The information about each node in the cluster.
	GadInstanceMembers []*DescribeGadInstancesResponseBodyGadInstancesGadInstanceMembers `json:"GadInstanceMembers,omitempty" xml:"GadInstanceMembers,omitempty" type:"Repeated"`
	// The ID of the global active database cluster.
	GadInstanceName *string `json:"GadInstanceName,omitempty" xml:"GadInstanceName,omitempty"`
	// The time when the most recent modification was made to the global active database cluster. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	ModificationTime *string `json:"ModificationTime,omitempty" xml:"ModificationTime,omitempty"`
	// The database engine that is run by the global active database cluster.
	//
	// >  The value of this parameter is fixed as **mysql**.
	Service *string `json:"Service,omitempty" xml:"Service,omitempty"`
	// The cluster status. Valid values:
	//
	// *   **activation**: The cluster is running.
	// *   **creating**: The cluster is being created.
	// *   **replica_adding**: Nodes are being added to the cluster.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeGadInstancesResponseBodyGadInstances) String() string {
	return tea.Prettify(s)
}

func (s DescribeGadInstancesResponseBodyGadInstances) GoString() string {
	return s.String()
}

func (s *DescribeGadInstancesResponseBodyGadInstances) SetCreationTime(v string) *DescribeGadInstancesResponseBodyGadInstances {
	s.CreationTime = &v
	return s
}

func (s *DescribeGadInstancesResponseBodyGadInstances) SetDescription(v string) *DescribeGadInstancesResponseBodyGadInstances {
	s.Description = &v
	return s
}

func (s *DescribeGadInstancesResponseBodyGadInstances) SetGadInstanceMembers(v []*DescribeGadInstancesResponseBodyGadInstancesGadInstanceMembers) *DescribeGadInstancesResponseBodyGadInstances {
	s.GadInstanceMembers = v
	return s
}

func (s *DescribeGadInstancesResponseBodyGadInstances) SetGadInstanceName(v string) *DescribeGadInstancesResponseBodyGadInstances {
	s.GadInstanceName = &v
	return s
}

func (s *DescribeGadInstancesResponseBodyGadInstances) SetModificationTime(v string) *DescribeGadInstancesResponseBodyGadInstances {
	s.ModificationTime = &v
	return s
}

func (s *DescribeGadInstancesResponseBodyGadInstances) SetService(v string) *DescribeGadInstancesResponseBodyGadInstances {
	s.Service = &v
	return s
}

func (s *DescribeGadInstancesResponseBodyGadInstances) SetStatus(v string) *DescribeGadInstancesResponseBodyGadInstances {
	s.Status = &v
	return s
}

type DescribeGadInstancesResponseBodyGadInstancesGadInstanceMembers struct {
	// The node ID.
	DBInstanceID *string `json:"DBInstanceID,omitempty" xml:"DBInstanceID,omitempty"`
	// A JSON array that consists of the details about the Data Transmission Service (DTS) synchronization task.
	//
	// >  Each unit node (secondary node) synchronizes data from the central node (primary node) by using DTS. This parameter contains the synchronization link ID and request ID of DTS.
	DtsInstance *string `json:"DtsInstance,omitempty" xml:"DtsInstance,omitempty"`
	// The database engine that is run by the node.
	//
	// >  The value of this parameter is fixed as **mysql**.
	Engine *string `json:"Engine,omitempty" xml:"Engine,omitempty"`
	// The database engine version that is run by the node.
	EngineVersion *string `json:"EngineVersion,omitempty" xml:"EngineVersion,omitempty"`
	// The ID of the region in which the node resides.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The node type. Valid values:
	//
	// *   **CENTRAL**: The node is the central node. Each global active database cluster has only one central node. All unit nodes synchronize data from the central node.
	// *   **UNIT**: The node is a unit node. Each global active database cluster can have up to 10 unit nodes. All unit nodes synchronize data from the central node.
	Role *string `json:"Role,omitempty" xml:"Role,omitempty"`
	// The node status. Valid values:
	//
	// *   **activation**: The node is running.
	// *   **creating**: The node is being created.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeGadInstancesResponseBodyGadInstancesGadInstanceMembers) String() string {
	return tea.Prettify(s)
}

func (s DescribeGadInstancesResponseBodyGadInstancesGadInstanceMembers) GoString() string {
	return s.String()
}

func (s *DescribeGadInstancesResponseBodyGadInstancesGadInstanceMembers) SetDBInstanceID(v string) *DescribeGadInstancesResponseBodyGadInstancesGadInstanceMembers {
	s.DBInstanceID = &v
	return s
}

func (s *DescribeGadInstancesResponseBodyGadInstancesGadInstanceMembers) SetDtsInstance(v string) *DescribeGadInstancesResponseBodyGadInstancesGadInstanceMembers {
	s.DtsInstance = &v
	return s
}

func (s *DescribeGadInstancesResponseBodyGadInstancesGadInstanceMembers) SetEngine(v string) *DescribeGadInstancesResponseBodyGadInstancesGadInstanceMembers {
	s.Engine = &v
	return s
}

func (s *DescribeGadInstancesResponseBodyGadInstancesGadInstanceMembers) SetEngineVersion(v string) *DescribeGadInstancesResponseBodyGadInstancesGadInstanceMembers {
	s.EngineVersion = &v
	return s
}

func (s *DescribeGadInstancesResponseBodyGadInstancesGadInstanceMembers) SetRegionId(v string) *DescribeGadInstancesResponseBodyGadInstancesGadInstanceMembers {
	s.RegionId = &v
	return s
}

func (s *DescribeGadInstancesResponseBodyGadInstancesGadInstanceMembers) SetResourceGroupId(v string) *DescribeGadInstancesResponseBodyGadInstancesGadInstanceMembers {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeGadInstancesResponseBodyGadInstancesGadInstanceMembers) SetRole(v string) *DescribeGadInstancesResponseBodyGadInstancesGadInstanceMembers {
	s.Role = &v
	return s
}

func (s *DescribeGadInstancesResponseBodyGadInstancesGadInstanceMembers) SetStatus(v string) *DescribeGadInstancesResponseBodyGadInstancesGadInstanceMembers {
	s.Status = &v
	return s
}

type DescribeGadInstancesResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeGadInstancesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeGadInstancesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeGadInstancesResponse) GoString() string {
	return s.String()
}

func (s *DescribeGadInstancesResponse) SetHeaders(v map[string]*string) *DescribeGadInstancesResponse {
	s.Headers = v
	return s
}

func (s *DescribeGadInstancesResponse) SetStatusCode(v int32) *DescribeGadInstancesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeGadInstancesResponse) SetBody(v *DescribeGadInstancesResponseBody) *DescribeGadInstancesResponse {
	s.Body = v
	return s
}

type DescribeHADiagnoseConfigRequest struct {
	// The ID of the instance. You can call the [DescribeDBInstances](~~26232~~) operation to query the ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the instance. You can call the [DescribeRegions](~~26243~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeHADiagnoseConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeHADiagnoseConfigRequest) GoString() string {
	return s.String()
}

func (s *DescribeHADiagnoseConfigRequest) SetDBInstanceId(v string) *DescribeHADiagnoseConfigRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeHADiagnoseConfigRequest) SetOwnerId(v int64) *DescribeHADiagnoseConfigRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeHADiagnoseConfigRequest) SetRegionId(v string) *DescribeHADiagnoseConfigRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeHADiagnoseConfigRequest) SetResourceOwnerAccount(v string) *DescribeHADiagnoseConfigRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeHADiagnoseConfigRequest) SetResourceOwnerId(v int64) *DescribeHADiagnoseConfigRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeHADiagnoseConfigResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The availability check method of the instance. Valid values:
	//
	// *   **LONG**: Alibaba Cloud uses persistent connections to check the availability of the instance.
	// *   **SHORT**: Alibaba Cloud uses short-lived connections to check the availability of the instance.
	TcpConnectionType *string `json:"TcpConnectionType,omitempty" xml:"TcpConnectionType,omitempty"`
}

func (s DescribeHADiagnoseConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeHADiagnoseConfigResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeHADiagnoseConfigResponseBody) SetRequestId(v string) *DescribeHADiagnoseConfigResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeHADiagnoseConfigResponseBody) SetTcpConnectionType(v string) *DescribeHADiagnoseConfigResponseBody {
	s.TcpConnectionType = &v
	return s
}

type DescribeHADiagnoseConfigResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeHADiagnoseConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeHADiagnoseConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeHADiagnoseConfigResponse) GoString() string {
	return s.String()
}

func (s *DescribeHADiagnoseConfigResponse) SetHeaders(v map[string]*string) *DescribeHADiagnoseConfigResponse {
	s.Headers = v
	return s
}

func (s *DescribeHADiagnoseConfigResponse) SetStatusCode(v int32) *DescribeHADiagnoseConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeHADiagnoseConfigResponse) SetBody(v *DescribeHADiagnoseConfigResponseBody) *DescribeHADiagnoseConfigResponse {
	s.Body = v
	return s
}

type DescribeHASwitchConfigRequest struct {
	// The ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the instance. You can call the [DescribeRegions](~~26243~~) operation to query most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeHASwitchConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeHASwitchConfigRequest) GoString() string {
	return s.String()
}

func (s *DescribeHASwitchConfigRequest) SetDBInstanceId(v string) *DescribeHASwitchConfigRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeHASwitchConfigRequest) SetOwnerId(v int64) *DescribeHASwitchConfigRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeHASwitchConfigRequest) SetRegionId(v string) *DescribeHASwitchConfigRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeHASwitchConfigRequest) SetResourceOwnerAccount(v string) *DescribeHASwitchConfigRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeHASwitchConfigRequest) SetResourceOwnerId(v int64) *DescribeHASwitchConfigRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeHASwitchConfigResponseBody struct {
	// The status of the automatic primary/secondary switchover feature. Valid values:
	//
	// *   **Auto:** The automatic primary/secondary switchover feature is enabled. The system automatically switches your workloads over from the instance to its secondary instance in the event of a fault.
	// *   **Manual:** The automatic primary/secondary switchover feature is temporarily disabled.
	HAConfig *string `json:"HAConfig,omitempty" xml:"HAConfig,omitempty"`
	// The time when the automatic primary/secondary switchover feature is enabled again. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	ManualHATime *string `json:"ManualHATime,omitempty" xml:"ManualHATime,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeHASwitchConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeHASwitchConfigResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeHASwitchConfigResponseBody) SetHAConfig(v string) *DescribeHASwitchConfigResponseBody {
	s.HAConfig = &v
	return s
}

func (s *DescribeHASwitchConfigResponseBody) SetManualHATime(v string) *DescribeHASwitchConfigResponseBody {
	s.ManualHATime = &v
	return s
}

func (s *DescribeHASwitchConfigResponseBody) SetRequestId(v string) *DescribeHASwitchConfigResponseBody {
	s.RequestId = &v
	return s
}

type DescribeHASwitchConfigResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeHASwitchConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeHASwitchConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeHASwitchConfigResponse) GoString() string {
	return s.String()
}

func (s *DescribeHASwitchConfigResponse) SetHeaders(v map[string]*string) *DescribeHASwitchConfigResponse {
	s.Headers = v
	return s
}

func (s *DescribeHASwitchConfigResponse) SetStatusCode(v int32) *DescribeHASwitchConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeHASwitchConfigResponse) SetBody(v *DescribeHASwitchConfigResponseBody) *DescribeHASwitchConfigResponse {
	s.Body = v
	return s
}

type DescribeHistoryTasksRequest struct {
	// The minimum execution duration of the task. This parameter is used to filter tasks whose execution duration is longer than the minimum execution duration. Unit: seconds. The default value is 0, which indicates that no limit is imposed.
	FromExecTime *int32 `json:"FromExecTime,omitempty" xml:"FromExecTime,omitempty"`
	// The beginning of the time range to query. Only tasks that have a start time later than or equal to the time specified by this parameter are queried. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC. The start time can be up to 30 days earlier than the current time. If you set this parameter to a time more than 30 days earlier than the current time, the specified time is automatically converted to a time that is exactly 30 days earlier than the current time.
	FromStartTime *string `json:"FromStartTime,omitempty" xml:"FromStartTime,omitempty"`
	// The instance ID. Separate multiple instance IDs with commas (,). You can specify up to 30 instance IDs. This parameter is empty by default, which indicates that you can specify an unlimited number of instance IDs.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// Only Instance is supported.
	InstanceType *string `json:"InstanceType,omitempty" xml:"InstanceType,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The page number. Pages start from page 1. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries per page. Valid values: **10 to 100**. Default value: **10**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The region ID of the pending event. You can call the [DescribeRegions](~~610399~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *int64  `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	SecurityToken        *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
	// The status of the task. Valid values:
	//
	// *   Scheduled
	// *   Running
	// *   Succeed
	// *   Failed
	// *   Cancelling
	// *   Canceled
	// *   Waiting
	//
	// Separate multiple states with commas (,). This parameter is empty by default, which indicates that tasks in all states are queried.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The task ID. Separate multiple task IDs with commas (,). You can specify up to 30 task IDs. This parameter is empty by default, which indicates that you can specify an unlimited number of task IDs.
	TaskId *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
	// The task type. Separate multiple task types with commas (,). You can specify up to 30 task types. This parameter is empty by default, which indicates that you can specify an unlimited number of task types.
	TaskType *string `json:"TaskType,omitempty" xml:"TaskType,omitempty"`
	// The maximum execution duration of a task. This parameter is used to filter tasks whose execution duration is shorter than or equal to the maximum execution duration. Unit: seconds. The default value is 0, which indicates that no limit is imposed.
	ToExecTime *int32 `json:"ToExecTime,omitempty" xml:"ToExecTime,omitempty"`
	// The end of the time range to query. Only tasks that have a start time earlier than or equal to the time specified by this parameter are queried. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	ToStartTime *string `json:"ToStartTime,omitempty" xml:"ToStartTime,omitempty"`
}

func (s DescribeHistoryTasksRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeHistoryTasksRequest) GoString() string {
	return s.String()
}

func (s *DescribeHistoryTasksRequest) SetFromExecTime(v int32) *DescribeHistoryTasksRequest {
	s.FromExecTime = &v
	return s
}

func (s *DescribeHistoryTasksRequest) SetFromStartTime(v string) *DescribeHistoryTasksRequest {
	s.FromStartTime = &v
	return s
}

func (s *DescribeHistoryTasksRequest) SetInstanceId(v string) *DescribeHistoryTasksRequest {
	s.InstanceId = &v
	return s
}

func (s *DescribeHistoryTasksRequest) SetInstanceType(v string) *DescribeHistoryTasksRequest {
	s.InstanceType = &v
	return s
}

func (s *DescribeHistoryTasksRequest) SetOwnerId(v int64) *DescribeHistoryTasksRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeHistoryTasksRequest) SetPageNumber(v int32) *DescribeHistoryTasksRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeHistoryTasksRequest) SetPageSize(v int32) *DescribeHistoryTasksRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeHistoryTasksRequest) SetRegionId(v string) *DescribeHistoryTasksRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeHistoryTasksRequest) SetResourceGroupId(v string) *DescribeHistoryTasksRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeHistoryTasksRequest) SetResourceOwnerAccount(v int64) *DescribeHistoryTasksRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeHistoryTasksRequest) SetResourceOwnerId(v int64) *DescribeHistoryTasksRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeHistoryTasksRequest) SetSecurityToken(v string) *DescribeHistoryTasksRequest {
	s.SecurityToken = &v
	return s
}

func (s *DescribeHistoryTasksRequest) SetStatus(v string) *DescribeHistoryTasksRequest {
	s.Status = &v
	return s
}

func (s *DescribeHistoryTasksRequest) SetTaskId(v string) *DescribeHistoryTasksRequest {
	s.TaskId = &v
	return s
}

func (s *DescribeHistoryTasksRequest) SetTaskType(v string) *DescribeHistoryTasksRequest {
	s.TaskType = &v
	return s
}

func (s *DescribeHistoryTasksRequest) SetToExecTime(v int32) *DescribeHistoryTasksRequest {
	s.ToExecTime = &v
	return s
}

func (s *DescribeHistoryTasksRequest) SetToStartTime(v string) *DescribeHistoryTasksRequest {
	s.ToStartTime = &v
	return s
}

type DescribeHistoryTasksResponseBody struct {
	// The tasks.
	Items []*DescribeHistoryTasksResponseBodyItems `json:"Items,omitempty" xml:"Items,omitempty" type:"Repeated"`
	// The page number. Pages start from page 1. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries per page. Valid values: **10 to 100**. Default value: **10**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The unique ID of the request. If the request fails, provide this ID for technical support to troubleshoot the failure.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of tasks that meet these constraints without taking pagination into account.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeHistoryTasksResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeHistoryTasksResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeHistoryTasksResponseBody) SetItems(v []*DescribeHistoryTasksResponseBodyItems) *DescribeHistoryTasksResponseBody {
	s.Items = v
	return s
}

func (s *DescribeHistoryTasksResponseBody) SetPageNumber(v int32) *DescribeHistoryTasksResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeHistoryTasksResponseBody) SetPageSize(v int32) *DescribeHistoryTasksResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeHistoryTasksResponseBody) SetRequestId(v string) *DescribeHistoryTasksResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeHistoryTasksResponseBody) SetTotalCount(v int32) *DescribeHistoryTasksResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeHistoryTasksResponseBodyItems struct {
	// A set of allowed actions that can be taken on the task. The system matches the current step name and status of the task to the available actions specified by ActionInfo. If no matching action is found, the current status of the task does not support any action. Example:
	//
	//       "steps": [
	//         {
	//           "step_name": "exec_task", // The name of the step, which matches CurrentStepName.
	//           "action_info": {    // The actions supported for this step.
	//             "Waiting": [      // The status, which matches Status.
	//               "modifySwitchTime" // The action. Multiple actions are supported.
	//             ]
	//           }
	//         },
	//         {
	//           "step_name": "init_task", // The name of the step.
	//           "action_info": {    // The actions supported for this step.
	//             "Running": [      // The status.
	//               "cancel",       // The action.
	//               "pause"
	//             ]
	//           }
	//         }
	//       ]
	//     }
	//
	// The system may support the following actions: retry cancel modifySwitchTime: changes the switching or restoration time.
	ActionInfo *string `json:"ActionInfo,omitempty" xml:"ActionInfo,omitempty"`
	// The ID of the user who made the request. If CallerSource is set to User, CallerUid indicates the unique ID (UID) of the user.
	CallerSource *string `json:"CallerSource,omitempty" xml:"CallerSource,omitempty"`
	// The request source. Valid values: System User
	CallerUid *string `json:"CallerUid,omitempty" xml:"CallerUid,omitempty"`
	// The name of the current step. If this parameter is left empty, the task is not started.
	CurrentStepName *string `json:"CurrentStepName,omitempty" xml:"CurrentStepName,omitempty"`
	// The database type.
	DbType *string `json:"DbType,omitempty" xml:"DbType,omitempty"`
	// The end time of the task. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ss format. The time is displayed in UTC.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The instance ID. Example: rm-xxx.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The instance name, which is a user-defined alias.
	InstanceName *string `json:"InstanceName,omitempty" xml:"InstanceName,omitempty"`
	// The type of the instance. Example: user instance.
	InstanceType *string `json:"InstanceType,omitempty" xml:"InstanceType,omitempty"`
	// The product. Example: rds.
	Product *string `json:"Product,omitempty" xml:"Product,omitempty"`
	// The task progress. Valid values: 0 to 100.
	Progress *float32 `json:"Progress,omitempty" xml:"Progress,omitempty"`
	// The reason why the current task was initiated.
	ReasonCode *string `json:"ReasonCode,omitempty" xml:"ReasonCode,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The estimated amount of time remaining to complete the task. Unit: seconds.
	RemainTime *int32 `json:"RemainTime,omitempty" xml:"RemainTime,omitempty"`
	// The start time of the task. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ss format. The time is displayed in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The status of the task.
	//
	// *   Scheduled
	// *   Running
	// *   Succeed
	// *   Failed
	// *   Cancelling
	// *   Canceled
	// *   Waiting
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
	// The task details provided in the form of a JSON string. The JSON string can be customized and extended to include additional information about the task. The details vary based on the task type.
	TaskDetail *string `json:"TaskDetail,omitempty" xml:"TaskDetail,omitempty"`
	// The task ID in the t-\*\*\* format.
	TaskId *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
	// The task type or name.
	TaskType *string `json:"TaskType,omitempty" xml:"TaskType,omitempty"`
	// The ID of the user to which the resources belong.
	Uid *string `json:"Uid,omitempty" xml:"Uid,omitempty"`
}

func (s DescribeHistoryTasksResponseBodyItems) String() string {
	return tea.Prettify(s)
}

func (s DescribeHistoryTasksResponseBodyItems) GoString() string {
	return s.String()
}

func (s *DescribeHistoryTasksResponseBodyItems) SetActionInfo(v string) *DescribeHistoryTasksResponseBodyItems {
	s.ActionInfo = &v
	return s
}

func (s *DescribeHistoryTasksResponseBodyItems) SetCallerSource(v string) *DescribeHistoryTasksResponseBodyItems {
	s.CallerSource = &v
	return s
}

func (s *DescribeHistoryTasksResponseBodyItems) SetCallerUid(v string) *DescribeHistoryTasksResponseBodyItems {
	s.CallerUid = &v
	return s
}

func (s *DescribeHistoryTasksResponseBodyItems) SetCurrentStepName(v string) *DescribeHistoryTasksResponseBodyItems {
	s.CurrentStepName = &v
	return s
}

func (s *DescribeHistoryTasksResponseBodyItems) SetDbType(v string) *DescribeHistoryTasksResponseBodyItems {
	s.DbType = &v
	return s
}

func (s *DescribeHistoryTasksResponseBodyItems) SetEndTime(v string) *DescribeHistoryTasksResponseBodyItems {
	s.EndTime = &v
	return s
}

func (s *DescribeHistoryTasksResponseBodyItems) SetInstanceId(v string) *DescribeHistoryTasksResponseBodyItems {
	s.InstanceId = &v
	return s
}

func (s *DescribeHistoryTasksResponseBodyItems) SetInstanceName(v string) *DescribeHistoryTasksResponseBodyItems {
	s.InstanceName = &v
	return s
}

func (s *DescribeHistoryTasksResponseBodyItems) SetInstanceType(v string) *DescribeHistoryTasksResponseBodyItems {
	s.InstanceType = &v
	return s
}

func (s *DescribeHistoryTasksResponseBodyItems) SetProduct(v string) *DescribeHistoryTasksResponseBodyItems {
	s.Product = &v
	return s
}

func (s *DescribeHistoryTasksResponseBodyItems) SetProgress(v float32) *DescribeHistoryTasksResponseBodyItems {
	s.Progress = &v
	return s
}

func (s *DescribeHistoryTasksResponseBodyItems) SetReasonCode(v string) *DescribeHistoryTasksResponseBodyItems {
	s.ReasonCode = &v
	return s
}

func (s *DescribeHistoryTasksResponseBodyItems) SetRegionId(v string) *DescribeHistoryTasksResponseBodyItems {
	s.RegionId = &v
	return s
}

func (s *DescribeHistoryTasksResponseBodyItems) SetRemainTime(v int32) *DescribeHistoryTasksResponseBodyItems {
	s.RemainTime = &v
	return s
}

func (s *DescribeHistoryTasksResponseBodyItems) SetStartTime(v string) *DescribeHistoryTasksResponseBodyItems {
	s.StartTime = &v
	return s
}

func (s *DescribeHistoryTasksResponseBodyItems) SetStatus(v int32) *DescribeHistoryTasksResponseBodyItems {
	s.Status = &v
	return s
}

func (s *DescribeHistoryTasksResponseBodyItems) SetTaskDetail(v string) *DescribeHistoryTasksResponseBodyItems {
	s.TaskDetail = &v
	return s
}

func (s *DescribeHistoryTasksResponseBodyItems) SetTaskId(v string) *DescribeHistoryTasksResponseBodyItems {
	s.TaskId = &v
	return s
}

func (s *DescribeHistoryTasksResponseBodyItems) SetTaskType(v string) *DescribeHistoryTasksResponseBodyItems {
	s.TaskType = &v
	return s
}

func (s *DescribeHistoryTasksResponseBodyItems) SetUid(v string) *DescribeHistoryTasksResponseBodyItems {
	s.Uid = &v
	return s
}

type DescribeHistoryTasksResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeHistoryTasksResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeHistoryTasksResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeHistoryTasksResponse) GoString() string {
	return s.String()
}

func (s *DescribeHistoryTasksResponse) SetHeaders(v map[string]*string) *DescribeHistoryTasksResponse {
	s.Headers = v
	return s
}

func (s *DescribeHistoryTasksResponse) SetStatusCode(v int32) *DescribeHistoryTasksResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeHistoryTasksResponse) SetBody(v *DescribeHistoryTasksResponseBody) *DescribeHistoryTasksResponse {
	s.Body = v
	return s
}

type DescribeHostGroupElasticStrategyParametersRequest struct {
	// The name of the dedicated cluster.
	DedicatedHostGroupName *string `json:"DedicatedHostGroupName,omitempty" xml:"DedicatedHostGroupName,omitempty"`
	// The region ID. You can call the [DescribeRegions](~~26243~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The resource group ID.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerId *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeHostGroupElasticStrategyParametersRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeHostGroupElasticStrategyParametersRequest) GoString() string {
	return s.String()
}

func (s *DescribeHostGroupElasticStrategyParametersRequest) SetDedicatedHostGroupName(v string) *DescribeHostGroupElasticStrategyParametersRequest {
	s.DedicatedHostGroupName = &v
	return s
}

func (s *DescribeHostGroupElasticStrategyParametersRequest) SetRegionId(v string) *DescribeHostGroupElasticStrategyParametersRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeHostGroupElasticStrategyParametersRequest) SetResourceGroupId(v string) *DescribeHostGroupElasticStrategyParametersRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeHostGroupElasticStrategyParametersRequest) SetResourceOwnerId(v int64) *DescribeHostGroupElasticStrategyParametersRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeHostGroupElasticStrategyParametersResponseBody struct {
	// The CPU utilization of the instance. Unit: percentage.
	CpuShar *int32 `json:"CpuShar,omitempty" xml:"CpuShar,omitempty"`
	// The number of CPU cores used by the instance. Unit: cores.
	CpuZoom *int32 `json:"CpuZoom,omitempty" xml:"CpuZoom,omitempty"`
	// The number of I/O requests.
	IopsZoom *int32 `json:"IopsZoom,omitempty" xml:"IopsZoom,omitempty"`
	// The maximum number of concurrent connections supported by the instance type.
	MaxConnZoom *int32 `json:"MaxConnZoom,omitempty" xml:"MaxConnZoom,omitempty"`
	// The total memory size of the instance in the dedicated cluster. Unit: MB.
	MemoryZoom *int32 `json:"MemoryZoom,omitempty" xml:"MemoryZoom,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeHostGroupElasticStrategyParametersResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeHostGroupElasticStrategyParametersResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeHostGroupElasticStrategyParametersResponseBody) SetCpuShar(v int32) *DescribeHostGroupElasticStrategyParametersResponseBody {
	s.CpuShar = &v
	return s
}

func (s *DescribeHostGroupElasticStrategyParametersResponseBody) SetCpuZoom(v int32) *DescribeHostGroupElasticStrategyParametersResponseBody {
	s.CpuZoom = &v
	return s
}

func (s *DescribeHostGroupElasticStrategyParametersResponseBody) SetIopsZoom(v int32) *DescribeHostGroupElasticStrategyParametersResponseBody {
	s.IopsZoom = &v
	return s
}

func (s *DescribeHostGroupElasticStrategyParametersResponseBody) SetMaxConnZoom(v int32) *DescribeHostGroupElasticStrategyParametersResponseBody {
	s.MaxConnZoom = &v
	return s
}

func (s *DescribeHostGroupElasticStrategyParametersResponseBody) SetMemoryZoom(v int32) *DescribeHostGroupElasticStrategyParametersResponseBody {
	s.MemoryZoom = &v
	return s
}

func (s *DescribeHostGroupElasticStrategyParametersResponseBody) SetRequestId(v string) *DescribeHostGroupElasticStrategyParametersResponseBody {
	s.RequestId = &v
	return s
}

type DescribeHostGroupElasticStrategyParametersResponse struct {
	Headers    map[string]*string                                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeHostGroupElasticStrategyParametersResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeHostGroupElasticStrategyParametersResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeHostGroupElasticStrategyParametersResponse) GoString() string {
	return s.String()
}

func (s *DescribeHostGroupElasticStrategyParametersResponse) SetHeaders(v map[string]*string) *DescribeHostGroupElasticStrategyParametersResponse {
	s.Headers = v
	return s
}

func (s *DescribeHostGroupElasticStrategyParametersResponse) SetStatusCode(v int32) *DescribeHostGroupElasticStrategyParametersResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeHostGroupElasticStrategyParametersResponse) SetBody(v *DescribeHostGroupElasticStrategyParametersResponseBody) *DescribeHostGroupElasticStrategyParametersResponse {
	s.Body = v
	return s
}

type DescribeHostWebShellRequest struct {
	// The username of the account that is used to log on to the host of the instance.
	AccountName *string `json:"AccountName,omitempty" xml:"AccountName,omitempty"`
	// The password of the account.
	AccountPassword *string `json:"AccountPassword,omitempty" xml:"AccountPassword,omitempty"`
	// The ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The hostname of the instance. You can call the [DescribeDBInstanceIpHostname](~~610525~~) operation to query the hostname.
	HostName *string `json:"HostName,omitempty" xml:"HostName,omitempty"`
	OwnerId  *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the instance. You can call the [DescribeDBInstanceAttribute](~~610394~~) operation to query the most recent region list.
	RegionID             *string `json:"RegionID,omitempty" xml:"RegionID,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeHostWebShellRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeHostWebShellRequest) GoString() string {
	return s.String()
}

func (s *DescribeHostWebShellRequest) SetAccountName(v string) *DescribeHostWebShellRequest {
	s.AccountName = &v
	return s
}

func (s *DescribeHostWebShellRequest) SetAccountPassword(v string) *DescribeHostWebShellRequest {
	s.AccountPassword = &v
	return s
}

func (s *DescribeHostWebShellRequest) SetDBInstanceId(v string) *DescribeHostWebShellRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeHostWebShellRequest) SetHostName(v string) *DescribeHostWebShellRequest {
	s.HostName = &v
	return s
}

func (s *DescribeHostWebShellRequest) SetOwnerId(v int64) *DescribeHostWebShellRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeHostWebShellRequest) SetRegionID(v string) *DescribeHostWebShellRequest {
	s.RegionID = &v
	return s
}

func (s *DescribeHostWebShellRequest) SetResourceOwnerAccount(v string) *DescribeHostWebShellRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeHostWebShellRequest) SetResourceOwnerId(v int64) *DescribeHostWebShellRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeHostWebShellResponseBody struct {
	// The URL of the webshell.
	LoginUrl *string `json:"LoginUrl,omitempty" xml:"LoginUrl,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeHostWebShellResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeHostWebShellResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeHostWebShellResponseBody) SetLoginUrl(v string) *DescribeHostWebShellResponseBody {
	s.LoginUrl = &v
	return s
}

func (s *DescribeHostWebShellResponseBody) SetRequestId(v string) *DescribeHostWebShellResponseBody {
	s.RequestId = &v
	return s
}

type DescribeHostWebShellResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeHostWebShellResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeHostWebShellResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeHostWebShellResponse) GoString() string {
	return s.String()
}

func (s *DescribeHostWebShellResponse) SetHeaders(v map[string]*string) *DescribeHostWebShellResponse {
	s.Headers = v
	return s
}

func (s *DescribeHostWebShellResponse) SetStatusCode(v int32) *DescribeHostWebShellResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeHostWebShellResponse) SetBody(v *DescribeHostWebShellResponseBody) *DescribeHostWebShellResponse {
	s.Body = v
	return s
}

type DescribeInstanceAutoRenewalAttributeRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of the page to return.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Valid values:
	//
	// *   **30**(Default)
	// *   **50**
	// *   **100**
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The region ID of the instance. You can call the [DescribeRegions](~~26243~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the proxy mode.
	ProxyId *string `json:"proxyId,omitempty" xml:"proxyId,omitempty"`
}

func (s DescribeInstanceAutoRenewalAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeInstanceAutoRenewalAttributeRequest) GoString() string {
	return s.String()
}

func (s *DescribeInstanceAutoRenewalAttributeRequest) SetClientToken(v string) *DescribeInstanceAutoRenewalAttributeRequest {
	s.ClientToken = &v
	return s
}

func (s *DescribeInstanceAutoRenewalAttributeRequest) SetDBInstanceId(v string) *DescribeInstanceAutoRenewalAttributeRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeInstanceAutoRenewalAttributeRequest) SetOwnerAccount(v string) *DescribeInstanceAutoRenewalAttributeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeInstanceAutoRenewalAttributeRequest) SetOwnerId(v int64) *DescribeInstanceAutoRenewalAttributeRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeInstanceAutoRenewalAttributeRequest) SetPageNumber(v int32) *DescribeInstanceAutoRenewalAttributeRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeInstanceAutoRenewalAttributeRequest) SetPageSize(v int32) *DescribeInstanceAutoRenewalAttributeRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeInstanceAutoRenewalAttributeRequest) SetRegionId(v string) *DescribeInstanceAutoRenewalAttributeRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeInstanceAutoRenewalAttributeRequest) SetResourceOwnerAccount(v string) *DescribeInstanceAutoRenewalAttributeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeInstanceAutoRenewalAttributeRequest) SetResourceOwnerId(v int64) *DescribeInstanceAutoRenewalAttributeRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeInstanceAutoRenewalAttributeRequest) SetProxyId(v string) *DescribeInstanceAutoRenewalAttributeRequest {
	s.ProxyId = &v
	return s
}

type DescribeInstanceAutoRenewalAttributeResponseBody struct {
	// The renewal information of the instance.
	Items *DescribeInstanceAutoRenewalAttributeResponseBodyItems `json:"Items,omitempty" xml:"Items,omitempty" type:"Struct"`
	// The number of the page to return.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned on the current page.
	PageRecordCount *int32 `json:"PageRecordCount,omitempty" xml:"PageRecordCount,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalRecordCount *int32 `json:"TotalRecordCount,omitempty" xml:"TotalRecordCount,omitempty"`
}

func (s DescribeInstanceAutoRenewalAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeInstanceAutoRenewalAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeInstanceAutoRenewalAttributeResponseBody) SetItems(v *DescribeInstanceAutoRenewalAttributeResponseBodyItems) *DescribeInstanceAutoRenewalAttributeResponseBody {
	s.Items = v
	return s
}

func (s *DescribeInstanceAutoRenewalAttributeResponseBody) SetPageNumber(v int32) *DescribeInstanceAutoRenewalAttributeResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeInstanceAutoRenewalAttributeResponseBody) SetPageRecordCount(v int32) *DescribeInstanceAutoRenewalAttributeResponseBody {
	s.PageRecordCount = &v
	return s
}

func (s *DescribeInstanceAutoRenewalAttributeResponseBody) SetRequestId(v string) *DescribeInstanceAutoRenewalAttributeResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeInstanceAutoRenewalAttributeResponseBody) SetTotalRecordCount(v int32) *DescribeInstanceAutoRenewalAttributeResponseBody {
	s.TotalRecordCount = &v
	return s
}

type DescribeInstanceAutoRenewalAttributeResponseBodyItems struct {
	Item []*DescribeInstanceAutoRenewalAttributeResponseBodyItemsItem `json:"Item,omitempty" xml:"Item,omitempty" type:"Repeated"`
}

func (s DescribeInstanceAutoRenewalAttributeResponseBodyItems) String() string {
	return tea.Prettify(s)
}

func (s DescribeInstanceAutoRenewalAttributeResponseBodyItems) GoString() string {
	return s.String()
}

func (s *DescribeInstanceAutoRenewalAttributeResponseBodyItems) SetItem(v []*DescribeInstanceAutoRenewalAttributeResponseBodyItemsItem) *DescribeInstanceAutoRenewalAttributeResponseBodyItems {
	s.Item = v
	return s
}

type DescribeInstanceAutoRenewalAttributeResponseBodyItemsItem struct {
	// Indicates whether auto-renewal is enabled.
	AutoRenew *string `json:"AutoRenew,omitempty" xml:"AutoRenew,omitempty"`
	// The ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The billing cycle of renewal.
	Duration *int32 `json:"Duration,omitempty" xml:"Duration,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The status of the instance.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeInstanceAutoRenewalAttributeResponseBodyItemsItem) String() string {
	return tea.Prettify(s)
}

func (s DescribeInstanceAutoRenewalAttributeResponseBodyItemsItem) GoString() string {
	return s.String()
}

func (s *DescribeInstanceAutoRenewalAttributeResponseBodyItemsItem) SetAutoRenew(v string) *DescribeInstanceAutoRenewalAttributeResponseBodyItemsItem {
	s.AutoRenew = &v
	return s
}

func (s *DescribeInstanceAutoRenewalAttributeResponseBodyItemsItem) SetDBInstanceId(v string) *DescribeInstanceAutoRenewalAttributeResponseBodyItemsItem {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeInstanceAutoRenewalAttributeResponseBodyItemsItem) SetDuration(v int32) *DescribeInstanceAutoRenewalAttributeResponseBodyItemsItem {
	s.Duration = &v
	return s
}

func (s *DescribeInstanceAutoRenewalAttributeResponseBodyItemsItem) SetRegionId(v string) *DescribeInstanceAutoRenewalAttributeResponseBodyItemsItem {
	s.RegionId = &v
	return s
}

func (s *DescribeInstanceAutoRenewalAttributeResponseBodyItemsItem) SetStatus(v string) *DescribeInstanceAutoRenewalAttributeResponseBodyItemsItem {
	s.Status = &v
	return s
}

type DescribeInstanceAutoRenewalAttributeResponse struct {
	Headers    map[string]*string                                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeInstanceAutoRenewalAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeInstanceAutoRenewalAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeInstanceAutoRenewalAttributeResponse) GoString() string {
	return s.String()
}

func (s *DescribeInstanceAutoRenewalAttributeResponse) SetHeaders(v map[string]*string) *DescribeInstanceAutoRenewalAttributeResponse {
	s.Headers = v
	return s
}

func (s *DescribeInstanceAutoRenewalAttributeResponse) SetStatusCode(v int32) *DescribeInstanceAutoRenewalAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeInstanceAutoRenewalAttributeResponse) SetBody(v *DescribeInstanceAutoRenewalAttributeResponseBody) *DescribeInstanceAutoRenewalAttributeResponse {
	s.Body = v
	return s
}

type DescribeInstanceCrossBackupPolicyRequest struct {
	// The ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the instance. You can call the [DescribeRegions](~~26243~~) operation to query the IDs of regions.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeInstanceCrossBackupPolicyRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeInstanceCrossBackupPolicyRequest) GoString() string {
	return s.String()
}

func (s *DescribeInstanceCrossBackupPolicyRequest) SetDBInstanceId(v string) *DescribeInstanceCrossBackupPolicyRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeInstanceCrossBackupPolicyRequest) SetOwnerId(v int64) *DescribeInstanceCrossBackupPolicyRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeInstanceCrossBackupPolicyRequest) SetRegionId(v string) *DescribeInstanceCrossBackupPolicyRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeInstanceCrossBackupPolicyRequest) SetResourceOwnerAccount(v string) *DescribeInstanceCrossBackupPolicyRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeInstanceCrossBackupPolicyRequest) SetResourceOwnerId(v int64) *DescribeInstanceCrossBackupPolicyRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeInstanceCrossBackupPolicyResponseBody struct {
	// The status of the cross-region backup feature on the instance. Valid values:
	//
	// *   **Disable**
	// *   **Enable**
	BackupEnabled *string `json:"BackupEnabled,omitempty" xml:"BackupEnabled,omitempty"`
	// The point in time at which the cross-region backup feature is enabled. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	BackupEnabledTime *string `json:"BackupEnabledTime,omitempty" xml:"BackupEnabledTime,omitempty"`
	// The ID of the destination region where the cross-region backup files of the instance are stored.
	CrossBackupRegion *string `json:"CrossBackupRegion,omitempty" xml:"CrossBackupRegion,omitempty"`
	// The policy that is used to save the cross-region backup files of the instance. Default value: **1**. The value 1 indicates that all cross-region backup files are saved.
	CrossBackupType *string `json:"CrossBackupType,omitempty" xml:"CrossBackupType,omitempty"`
	// The name of the instance. It must be 2 to 256 characters in length. The value can contain letters, digits, underscores (\_), and hyphens (-), and must start with a letter.
	//
	// >  The value cannot start with http:// or https://.
	DBInstanceDescription *string `json:"DBInstanceDescription,omitempty" xml:"DBInstanceDescription,omitempty"`
	// The instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The status of the instance. For more information, see [Instance state table](~~26315~~).
	DBInstanceStatus *string `json:"DBInstanceStatus,omitempty" xml:"DBInstanceStatus,omitempty"`
	// The database engine of the instance.
	Engine *string `json:"Engine,omitempty" xml:"Engine,omitempty"`
	// The database engine version.
	EngineVersion *string `json:"EngineVersion,omitempty" xml:"EngineVersion,omitempty"`
	// The lock status of the instance. Valid values:
	//
	// *   **Unlock**: The instance is not locked.
	// *   **ManualLock**: The instance is manually locked.
	// *   **LockByExpiration**: The instance is automatically locked due to instance expiration.
	// *   **LockByRestoration**: The instance is automatically locked before a rollback.
	// *   **LockByDiskQuota**: The instance is automatically locked because its storage capacity is exhausted and the instance is inaccessible.
	LockMode *string `json:"LockMode,omitempty" xml:"LockMode,omitempty"`
	// The status of the cross-region log backup feature on the instance. Valid values:
	//
	// *   **Disable**
	// *   **Enable**
	LogBackupEnabled *string `json:"LogBackupEnabled,omitempty" xml:"LogBackupEnabled,omitempty"`
	// The time when cross-region log backup was enabled on the instance. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	LogBackupEnabledTime *string `json:"LogBackupEnabledTime,omitempty" xml:"LogBackupEnabledTime,omitempty"`
	// The region ID of the instance.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The policy that is used to retain the cross-region backup files of the instance. Default value: **1**. The value 1 indicates that the cross-region backup files of the instance are retained based on the specified retention period.
	RetentType *int32 `json:"RetentType,omitempty" xml:"RetentType,omitempty"`
	// The number of days for which the cross-region backup files of the instance are retained. Valid values: **7 to 1825**.
	Retention *int32 `json:"Retention,omitempty" xml:"Retention,omitempty"`
}

func (s DescribeInstanceCrossBackupPolicyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeInstanceCrossBackupPolicyResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeInstanceCrossBackupPolicyResponseBody) SetBackupEnabled(v string) *DescribeInstanceCrossBackupPolicyResponseBody {
	s.BackupEnabled = &v
	return s
}

func (s *DescribeInstanceCrossBackupPolicyResponseBody) SetBackupEnabledTime(v string) *DescribeInstanceCrossBackupPolicyResponseBody {
	s.BackupEnabledTime = &v
	return s
}

func (s *DescribeInstanceCrossBackupPolicyResponseBody) SetCrossBackupRegion(v string) *DescribeInstanceCrossBackupPolicyResponseBody {
	s.CrossBackupRegion = &v
	return s
}

func (s *DescribeInstanceCrossBackupPolicyResponseBody) SetCrossBackupType(v string) *DescribeInstanceCrossBackupPolicyResponseBody {
	s.CrossBackupType = &v
	return s
}

func (s *DescribeInstanceCrossBackupPolicyResponseBody) SetDBInstanceDescription(v string) *DescribeInstanceCrossBackupPolicyResponseBody {
	s.DBInstanceDescription = &v
	return s
}

func (s *DescribeInstanceCrossBackupPolicyResponseBody) SetDBInstanceId(v string) *DescribeInstanceCrossBackupPolicyResponseBody {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeInstanceCrossBackupPolicyResponseBody) SetDBInstanceStatus(v string) *DescribeInstanceCrossBackupPolicyResponseBody {
	s.DBInstanceStatus = &v
	return s
}

func (s *DescribeInstanceCrossBackupPolicyResponseBody) SetEngine(v string) *DescribeInstanceCrossBackupPolicyResponseBody {
	s.Engine = &v
	return s
}

func (s *DescribeInstanceCrossBackupPolicyResponseBody) SetEngineVersion(v string) *DescribeInstanceCrossBackupPolicyResponseBody {
	s.EngineVersion = &v
	return s
}

func (s *DescribeInstanceCrossBackupPolicyResponseBody) SetLockMode(v string) *DescribeInstanceCrossBackupPolicyResponseBody {
	s.LockMode = &v
	return s
}

func (s *DescribeInstanceCrossBackupPolicyResponseBody) SetLogBackupEnabled(v string) *DescribeInstanceCrossBackupPolicyResponseBody {
	s.LogBackupEnabled = &v
	return s
}

func (s *DescribeInstanceCrossBackupPolicyResponseBody) SetLogBackupEnabledTime(v string) *DescribeInstanceCrossBackupPolicyResponseBody {
	s.LogBackupEnabledTime = &v
	return s
}

func (s *DescribeInstanceCrossBackupPolicyResponseBody) SetRegionId(v string) *DescribeInstanceCrossBackupPolicyResponseBody {
	s.RegionId = &v
	return s
}

func (s *DescribeInstanceCrossBackupPolicyResponseBody) SetRequestId(v string) *DescribeInstanceCrossBackupPolicyResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeInstanceCrossBackupPolicyResponseBody) SetRetentType(v int32) *DescribeInstanceCrossBackupPolicyResponseBody {
	s.RetentType = &v
	return s
}

func (s *DescribeInstanceCrossBackupPolicyResponseBody) SetRetention(v int32) *DescribeInstanceCrossBackupPolicyResponseBody {
	s.Retention = &v
	return s
}

type DescribeInstanceCrossBackupPolicyResponse struct {
	Headers    map[string]*string                             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeInstanceCrossBackupPolicyResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeInstanceCrossBackupPolicyResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeInstanceCrossBackupPolicyResponse) GoString() string {
	return s.String()
}

func (s *DescribeInstanceCrossBackupPolicyResponse) SetHeaders(v map[string]*string) *DescribeInstanceCrossBackupPolicyResponse {
	s.Headers = v
	return s
}

func (s *DescribeInstanceCrossBackupPolicyResponse) SetStatusCode(v int32) *DescribeInstanceCrossBackupPolicyResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeInstanceCrossBackupPolicyResponse) SetBody(v *DescribeInstanceCrossBackupPolicyResponseBody) *DescribeInstanceCrossBackupPolicyResponse {
	s.Body = v
	return s
}

type DescribeInstanceKeywordsRequest struct {
	// The type of reserved keyword to query. Valid values:
	//
	// *   **account**
	// *   **database**
	Key                  *string `json:"Key,omitempty" xml:"Key,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeInstanceKeywordsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeInstanceKeywordsRequest) GoString() string {
	return s.String()
}

func (s *DescribeInstanceKeywordsRequest) SetKey(v string) *DescribeInstanceKeywordsRequest {
	s.Key = &v
	return s
}

func (s *DescribeInstanceKeywordsRequest) SetOwnerAccount(v string) *DescribeInstanceKeywordsRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeInstanceKeywordsRequest) SetOwnerId(v int64) *DescribeInstanceKeywordsRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeInstanceKeywordsRequest) SetResourceOwnerAccount(v string) *DescribeInstanceKeywordsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeInstanceKeywordsRequest) SetResourceOwnerId(v int64) *DescribeInstanceKeywordsRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeInstanceKeywordsResponseBody struct {
	// The type of reserved keyword returned.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// An array that consists of reserved keywords.
	Words *DescribeInstanceKeywordsResponseBodyWords `json:"Words,omitempty" xml:"Words,omitempty" type:"Struct"`
}

func (s DescribeInstanceKeywordsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeInstanceKeywordsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeInstanceKeywordsResponseBody) SetKey(v string) *DescribeInstanceKeywordsResponseBody {
	s.Key = &v
	return s
}

func (s *DescribeInstanceKeywordsResponseBody) SetRequestId(v string) *DescribeInstanceKeywordsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeInstanceKeywordsResponseBody) SetWords(v *DescribeInstanceKeywordsResponseBodyWords) *DescribeInstanceKeywordsResponseBody {
	s.Words = v
	return s
}

type DescribeInstanceKeywordsResponseBodyWords struct {
	Word []*string `json:"word,omitempty" xml:"word,omitempty" type:"Repeated"`
}

func (s DescribeInstanceKeywordsResponseBodyWords) String() string {
	return tea.Prettify(s)
}

func (s DescribeInstanceKeywordsResponseBodyWords) GoString() string {
	return s.String()
}

func (s *DescribeInstanceKeywordsResponseBodyWords) SetWord(v []*string) *DescribeInstanceKeywordsResponseBodyWords {
	s.Word = v
	return s
}

type DescribeInstanceKeywordsResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeInstanceKeywordsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeInstanceKeywordsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeInstanceKeywordsResponse) GoString() string {
	return s.String()
}

func (s *DescribeInstanceKeywordsResponse) SetHeaders(v map[string]*string) *DescribeInstanceKeywordsResponse {
	s.Headers = v
	return s
}

func (s *DescribeInstanceKeywordsResponse) SetStatusCode(v int32) *DescribeInstanceKeywordsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeInstanceKeywordsResponse) SetBody(v *DescribeInstanceKeywordsResponseBody) *DescribeInstanceKeywordsResponse {
	s.Body = v
	return s
}

type DescribeInstanceLinkedWhitelistTemplateRequest struct {
	// The instance name.
	InsName *string `json:"InsName,omitempty" xml:"InsName,omitempty"`
	// The resource group ID. You can leave this parameter empty.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeInstanceLinkedWhitelistTemplateRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeInstanceLinkedWhitelistTemplateRequest) GoString() string {
	return s.String()
}

func (s *DescribeInstanceLinkedWhitelistTemplateRequest) SetInsName(v string) *DescribeInstanceLinkedWhitelistTemplateRequest {
	s.InsName = &v
	return s
}

func (s *DescribeInstanceLinkedWhitelistTemplateRequest) SetResourceGroupId(v string) *DescribeInstanceLinkedWhitelistTemplateRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeInstanceLinkedWhitelistTemplateRequest) SetResourceOwnerAccount(v string) *DescribeInstanceLinkedWhitelistTemplateRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeInstanceLinkedWhitelistTemplateRequest) SetResourceOwnerId(v int64) *DescribeInstanceLinkedWhitelistTemplateRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeInstanceLinkedWhitelistTemplateResponseBody struct {
	// The response code returned. Valid values:
	//
	// *   **200**: success
	// *   **400**: client error
	// *   **401**: identity authentication failed
	// *   **404**: request page not found
	// *   **500**: server error
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data returned.
	Data *DescribeInstanceLinkedWhitelistTemplateResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The HTTP status code returned. Valid values:
	//
	// *   **200**: success
	// *   **400**: client error
	// *   **500**: server error
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The returned message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful. Valid values:
	//
	// *   **true**
	// *   **false**
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DescribeInstanceLinkedWhitelistTemplateResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeInstanceLinkedWhitelistTemplateResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeInstanceLinkedWhitelistTemplateResponseBody) SetCode(v string) *DescribeInstanceLinkedWhitelistTemplateResponseBody {
	s.Code = &v
	return s
}

func (s *DescribeInstanceLinkedWhitelistTemplateResponseBody) SetData(v *DescribeInstanceLinkedWhitelistTemplateResponseBodyData) *DescribeInstanceLinkedWhitelistTemplateResponseBody {
	s.Data = v
	return s
}

func (s *DescribeInstanceLinkedWhitelistTemplateResponseBody) SetHttpStatusCode(v int32) *DescribeInstanceLinkedWhitelistTemplateResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *DescribeInstanceLinkedWhitelistTemplateResponseBody) SetMessage(v string) *DescribeInstanceLinkedWhitelistTemplateResponseBody {
	s.Message = &v
	return s
}

func (s *DescribeInstanceLinkedWhitelistTemplateResponseBody) SetRequestId(v string) *DescribeInstanceLinkedWhitelistTemplateResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeInstanceLinkedWhitelistTemplateResponseBody) SetSuccess(v bool) *DescribeInstanceLinkedWhitelistTemplateResponseBody {
	s.Success = &v
	return s
}

type DescribeInstanceLinkedWhitelistTemplateResponseBodyData struct {
	// The instance name.
	InsName *string `json:"InsName,omitempty" xml:"InsName,omitempty"`
	// The information about whitelists that are returned by page.
	Templates []*DescribeInstanceLinkedWhitelistTemplateResponseBodyDataTemplates `json:"Templates,omitempty" xml:"Templates,omitempty" type:"Repeated"`
}

func (s DescribeInstanceLinkedWhitelistTemplateResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s DescribeInstanceLinkedWhitelistTemplateResponseBodyData) GoString() string {
	return s.String()
}

func (s *DescribeInstanceLinkedWhitelistTemplateResponseBodyData) SetInsName(v string) *DescribeInstanceLinkedWhitelistTemplateResponseBodyData {
	s.InsName = &v
	return s
}

func (s *DescribeInstanceLinkedWhitelistTemplateResponseBodyData) SetTemplates(v []*DescribeInstanceLinkedWhitelistTemplateResponseBodyDataTemplates) *DescribeInstanceLinkedWhitelistTemplateResponseBodyData {
	s.Templates = v
	return s
}

type DescribeInstanceLinkedWhitelistTemplateResponseBodyDataTemplates struct {
	// The primary key of the data table.
	Id *int32 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The IP addresses.
	Ips *string `json:"Ips,omitempty" xml:"Ips,omitempty"`
	// The whitelist template ID.
	TemplateId *int32 `json:"TemplateId,omitempty" xml:"TemplateId,omitempty"`
	// The whitelist template name.
	TemplateName *string `json:"TemplateName,omitempty" xml:"TemplateName,omitempty"`
	// The user ID.
	UserId *int32 `json:"UserId,omitempty" xml:"UserId,omitempty"`
}

func (s DescribeInstanceLinkedWhitelistTemplateResponseBodyDataTemplates) String() string {
	return tea.Prettify(s)
}

func (s DescribeInstanceLinkedWhitelistTemplateResponseBodyDataTemplates) GoString() string {
	return s.String()
}

func (s *DescribeInstanceLinkedWhitelistTemplateResponseBodyDataTemplates) SetId(v int32) *DescribeInstanceLinkedWhitelistTemplateResponseBodyDataTemplates {
	s.Id = &v
	return s
}

func (s *DescribeInstanceLinkedWhitelistTemplateResponseBodyDataTemplates) SetIps(v string) *DescribeInstanceLinkedWhitelistTemplateResponseBodyDataTemplates {
	s.Ips = &v
	return s
}

func (s *DescribeInstanceLinkedWhitelistTemplateResponseBodyDataTemplates) SetTemplateId(v int32) *DescribeInstanceLinkedWhitelistTemplateResponseBodyDataTemplates {
	s.TemplateId = &v
	return s
}

func (s *DescribeInstanceLinkedWhitelistTemplateResponseBodyDataTemplates) SetTemplateName(v string) *DescribeInstanceLinkedWhitelistTemplateResponseBodyDataTemplates {
	s.TemplateName = &v
	return s
}

func (s *DescribeInstanceLinkedWhitelistTemplateResponseBodyDataTemplates) SetUserId(v int32) *DescribeInstanceLinkedWhitelistTemplateResponseBodyDataTemplates {
	s.UserId = &v
	return s
}

type DescribeInstanceLinkedWhitelistTemplateResponse struct {
	Headers    map[string]*string                                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeInstanceLinkedWhitelistTemplateResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeInstanceLinkedWhitelistTemplateResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeInstanceLinkedWhitelistTemplateResponse) GoString() string {
	return s.String()
}

func (s *DescribeInstanceLinkedWhitelistTemplateResponse) SetHeaders(v map[string]*string) *DescribeInstanceLinkedWhitelistTemplateResponse {
	s.Headers = v
	return s
}

func (s *DescribeInstanceLinkedWhitelistTemplateResponse) SetStatusCode(v int32) *DescribeInstanceLinkedWhitelistTemplateResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeInstanceLinkedWhitelistTemplateResponse) SetBody(v *DescribeInstanceLinkedWhitelistTemplateResponseBody) *DescribeInstanceLinkedWhitelistTemplateResponse {
	s.Body = v
	return s
}

type DescribeLocalAvailableRecoveryTimeRequest struct {
	// The instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID. You can call the DescribeRegions operation to query the most recent region list.
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The resource group ID.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeLocalAvailableRecoveryTimeRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeLocalAvailableRecoveryTimeRequest) GoString() string {
	return s.String()
}

func (s *DescribeLocalAvailableRecoveryTimeRequest) SetDBInstanceId(v string) *DescribeLocalAvailableRecoveryTimeRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeLocalAvailableRecoveryTimeRequest) SetOwnerId(v int64) *DescribeLocalAvailableRecoveryTimeRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeLocalAvailableRecoveryTimeRequest) SetRegion(v string) *DescribeLocalAvailableRecoveryTimeRequest {
	s.Region = &v
	return s
}

func (s *DescribeLocalAvailableRecoveryTimeRequest) SetResourceGroupId(v string) *DescribeLocalAvailableRecoveryTimeRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeLocalAvailableRecoveryTimeRequest) SetResourceOwnerAccount(v string) *DescribeLocalAvailableRecoveryTimeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeLocalAvailableRecoveryTimeRequest) SetResourceOwnerId(v int64) *DescribeLocalAvailableRecoveryTimeRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeLocalAvailableRecoveryTimeResponseBody struct {
	// The instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The start of the time range to which the instance can be restored.
	RecoveryBeginTime *string `json:"RecoveryBeginTime,omitempty" xml:"RecoveryBeginTime,omitempty"`
	// The end of the time range to which the instance can be restored.
	RecoveryEndTime *string `json:"RecoveryEndTime,omitempty" xml:"RecoveryEndTime,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeLocalAvailableRecoveryTimeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeLocalAvailableRecoveryTimeResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeLocalAvailableRecoveryTimeResponseBody) SetDBInstanceId(v string) *DescribeLocalAvailableRecoveryTimeResponseBody {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeLocalAvailableRecoveryTimeResponseBody) SetRecoveryBeginTime(v string) *DescribeLocalAvailableRecoveryTimeResponseBody {
	s.RecoveryBeginTime = &v
	return s
}

func (s *DescribeLocalAvailableRecoveryTimeResponseBody) SetRecoveryEndTime(v string) *DescribeLocalAvailableRecoveryTimeResponseBody {
	s.RecoveryEndTime = &v
	return s
}

func (s *DescribeLocalAvailableRecoveryTimeResponseBody) SetRequestId(v string) *DescribeLocalAvailableRecoveryTimeResponseBody {
	s.RequestId = &v
	return s
}

type DescribeLocalAvailableRecoveryTimeResponse struct {
	Headers    map[string]*string                              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeLocalAvailableRecoveryTimeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeLocalAvailableRecoveryTimeResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeLocalAvailableRecoveryTimeResponse) GoString() string {
	return s.String()
}

func (s *DescribeLocalAvailableRecoveryTimeResponse) SetHeaders(v map[string]*string) *DescribeLocalAvailableRecoveryTimeResponse {
	s.Headers = v
	return s
}

func (s *DescribeLocalAvailableRecoveryTimeResponse) SetStatusCode(v int32) *DescribeLocalAvailableRecoveryTimeResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeLocalAvailableRecoveryTimeResponse) SetBody(v *DescribeLocalAvailableRecoveryTimeResponseBody) *DescribeLocalAvailableRecoveryTimeResponse {
	s.Body = v
	return s
}

type DescribeLogBackupFilesRequest struct {
	// The instance ID. You can call the [DescribeDBInstances](~~610396~~) operation to query the ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The end of the time range to query. The end time must be later than the start time. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm*Z format. The time must be in UTC.
	EndTime      *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The page number. Pages start from page 1.
	//
	// Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries per page. Valid values: **30** to **1000**. Default value: **30**.
	PageSize             *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm*Z format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeLogBackupFilesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeLogBackupFilesRequest) GoString() string {
	return s.String()
}

func (s *DescribeLogBackupFilesRequest) SetDBInstanceId(v string) *DescribeLogBackupFilesRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeLogBackupFilesRequest) SetEndTime(v string) *DescribeLogBackupFilesRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeLogBackupFilesRequest) SetOwnerAccount(v string) *DescribeLogBackupFilesRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeLogBackupFilesRequest) SetOwnerId(v int64) *DescribeLogBackupFilesRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeLogBackupFilesRequest) SetPageNumber(v int32) *DescribeLogBackupFilesRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeLogBackupFilesRequest) SetPageSize(v int32) *DescribeLogBackupFilesRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeLogBackupFilesRequest) SetResourceOwnerAccount(v string) *DescribeLogBackupFilesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeLogBackupFilesRequest) SetResourceOwnerId(v int64) *DescribeLogBackupFilesRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeLogBackupFilesRequest) SetStartTime(v string) *DescribeLogBackupFilesRequest {
	s.StartTime = &v
	return s
}

type DescribeLogBackupFilesResponseBody struct {
	// The details of log files.
	Items *DescribeLogBackupFilesResponseBodyItems `json:"Items,omitempty" xml:"Items,omitempty" type:"Struct"`
	// The page number of the page returned.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of log files on the current page.
	PageRecordCount *int32 `json:"PageRecordCount,omitempty" xml:"PageRecordCount,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total size of log files. Unit: bytes.
	TotalFileSize *int64 `json:"TotalFileSize,omitempty" xml:"TotalFileSize,omitempty"`
	// The total number of log files.
	TotalRecordCount *int32 `json:"TotalRecordCount,omitempty" xml:"TotalRecordCount,omitempty"`
}

func (s DescribeLogBackupFilesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeLogBackupFilesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeLogBackupFilesResponseBody) SetItems(v *DescribeLogBackupFilesResponseBodyItems) *DescribeLogBackupFilesResponseBody {
	s.Items = v
	return s
}

func (s *DescribeLogBackupFilesResponseBody) SetPageNumber(v int32) *DescribeLogBackupFilesResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeLogBackupFilesResponseBody) SetPageRecordCount(v int32) *DescribeLogBackupFilesResponseBody {
	s.PageRecordCount = &v
	return s
}

func (s *DescribeLogBackupFilesResponseBody) SetRequestId(v string) *DescribeLogBackupFilesResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeLogBackupFilesResponseBody) SetTotalFileSize(v int64) *DescribeLogBackupFilesResponseBody {
	s.TotalFileSize = &v
	return s
}

func (s *DescribeLogBackupFilesResponseBody) SetTotalRecordCount(v int32) *DescribeLogBackupFilesResponseBody {
	s.TotalRecordCount = &v
	return s
}

type DescribeLogBackupFilesResponseBodyItems struct {
	BinLogFile []*DescribeLogBackupFilesResponseBodyItemsBinLogFile `json:"BinLogFile,omitempty" xml:"BinLogFile,omitempty" type:"Repeated"`
}

func (s DescribeLogBackupFilesResponseBodyItems) String() string {
	return tea.Prettify(s)
}

func (s DescribeLogBackupFilesResponseBodyItems) GoString() string {
	return s.String()
}

func (s *DescribeLogBackupFilesResponseBodyItems) SetBinLogFile(v []*DescribeLogBackupFilesResponseBodyItemsBinLogFile) *DescribeLogBackupFilesResponseBodyItems {
	s.BinLogFile = v
	return s
}

type DescribeLogBackupFilesResponseBodyItemsBinLogFile struct {
	// The HTTP-based download URL of the log file. If the log file cannot be downloaded, an empty string is returned.
	DownloadLink *string `json:"DownloadLink,omitempty" xml:"DownloadLink,omitempty"`
	// The size of the log file. Unit: bytes.
	FileSize *int64 `json:"FileSize,omitempty" xml:"FileSize,omitempty"`
	// The URL that is used to download the log file over an internal network. If the log file cannot be downloaded, an empty string is returned. This URL is valid for one hour.
	IntranetDownloadLink *string `json:"IntranetDownloadLink,omitempty" xml:"IntranetDownloadLink,omitempty"`
	// The expiration time of the URL. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	LinkExpiredTime *string `json:"LinkExpiredTime,omitempty" xml:"LinkExpiredTime,omitempty"`
	// The start time of the log file. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm*Z format. The time is displayed in UTC.
	LogBeginTime *string `json:"LogBeginTime,omitempty" xml:"LogBeginTime,omitempty"`
	// The end time of the log file. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm*Z format. The time is displayed in UTC.
	LogEndTime *string `json:"LogEndTime,omitempty" xml:"LogEndTime,omitempty"`
}

func (s DescribeLogBackupFilesResponseBodyItemsBinLogFile) String() string {
	return tea.Prettify(s)
}

func (s DescribeLogBackupFilesResponseBodyItemsBinLogFile) GoString() string {
	return s.String()
}

func (s *DescribeLogBackupFilesResponseBodyItemsBinLogFile) SetDownloadLink(v string) *DescribeLogBackupFilesResponseBodyItemsBinLogFile {
	s.DownloadLink = &v
	return s
}

func (s *DescribeLogBackupFilesResponseBodyItemsBinLogFile) SetFileSize(v int64) *DescribeLogBackupFilesResponseBodyItemsBinLogFile {
	s.FileSize = &v
	return s
}

func (s *DescribeLogBackupFilesResponseBodyItemsBinLogFile) SetIntranetDownloadLink(v string) *DescribeLogBackupFilesResponseBodyItemsBinLogFile {
	s.IntranetDownloadLink = &v
	return s
}

func (s *DescribeLogBackupFilesResponseBodyItemsBinLogFile) SetLinkExpiredTime(v string) *DescribeLogBackupFilesResponseBodyItemsBinLogFile {
	s.LinkExpiredTime = &v
	return s
}

func (s *DescribeLogBackupFilesResponseBodyItemsBinLogFile) SetLogBeginTime(v string) *DescribeLogBackupFilesResponseBodyItemsBinLogFile {
	s.LogBeginTime = &v
	return s
}

func (s *DescribeLogBackupFilesResponseBodyItemsBinLogFile) SetLogEndTime(v string) *DescribeLogBackupFilesResponseBodyItemsBinLogFile {
	s.LogEndTime = &v
	return s
}

type DescribeLogBackupFilesResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeLogBackupFilesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeLogBackupFilesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeLogBackupFilesResponse) GoString() string {
	return s.String()
}

func (s *DescribeLogBackupFilesResponse) SetHeaders(v map[string]*string) *DescribeLogBackupFilesResponse {
	s.Headers = v
	return s
}

func (s *DescribeLogBackupFilesResponse) SetStatusCode(v int32) *DescribeLogBackupFilesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeLogBackupFilesResponse) SetBody(v *DescribeLogBackupFilesResponseBody) *DescribeLogBackupFilesResponse {
	s.Body = v
	return s
}

type DescribeMarketingActivityRequest struct {
	// The unique ID (UID) of the Alibaba Cloud account.
	AliUid *int64 `json:"AliUid,omitempty" xml:"AliUid,omitempty"`
	// The BID of the account to which the Anycast EIP belongs.
	Bid *string `json:"Bid,omitempty" xml:"Bid,omitempty"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	OwnerId     *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the instance. You can call the [DescribeDBInstanceAttribute](~~26231~~) operation to query region ID of the instance.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// Upgrade Code
	UpgradeCode *string `json:"UpgradeCode,omitempty" xml:"UpgradeCode,omitempty"`
}

func (s DescribeMarketingActivityRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeMarketingActivityRequest) GoString() string {
	return s.String()
}

func (s *DescribeMarketingActivityRequest) SetAliUid(v int64) *DescribeMarketingActivityRequest {
	s.AliUid = &v
	return s
}

func (s *DescribeMarketingActivityRequest) SetBid(v string) *DescribeMarketingActivityRequest {
	s.Bid = &v
	return s
}

func (s *DescribeMarketingActivityRequest) SetClientToken(v string) *DescribeMarketingActivityRequest {
	s.ClientToken = &v
	return s
}

func (s *DescribeMarketingActivityRequest) SetOwnerId(v int64) *DescribeMarketingActivityRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeMarketingActivityRequest) SetRegionId(v string) *DescribeMarketingActivityRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeMarketingActivityRequest) SetResourceGroupId(v string) *DescribeMarketingActivityRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeMarketingActivityRequest) SetResourceOwnerAccount(v string) *DescribeMarketingActivityRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeMarketingActivityRequest) SetResourceOwnerId(v int64) *DescribeMarketingActivityRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeMarketingActivityRequest) SetUpgradeCode(v string) *DescribeMarketingActivityRequest {
	s.UpgradeCode = &v
	return s
}

type DescribeMarketingActivityResponseBody struct {
	// The unique ID (UID) of the Alibaba Cloud account.
	AliUid *int64 `json:"AliUid,omitempty" xml:"AliUid,omitempty"`
	// The BID of the account to which the Anycast EIP belongs.
	Bid *string `json:"Bid,omitempty" xml:"Bid,omitempty"`
	// The details of the instance.
	Items []*DescribeMarketingActivityResponseBodyItems `json:"Items,omitempty" xml:"Items,omitempty" type:"Repeated"`
	// The region ID. You can call the [DescribeRegions](~~26243~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// Id of the request
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeMarketingActivityResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeMarketingActivityResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeMarketingActivityResponseBody) SetAliUid(v int64) *DescribeMarketingActivityResponseBody {
	s.AliUid = &v
	return s
}

func (s *DescribeMarketingActivityResponseBody) SetBid(v string) *DescribeMarketingActivityResponseBody {
	s.Bid = &v
	return s
}

func (s *DescribeMarketingActivityResponseBody) SetItems(v []*DescribeMarketingActivityResponseBodyItems) *DescribeMarketingActivityResponseBody {
	s.Items = v
	return s
}

func (s *DescribeMarketingActivityResponseBody) SetRegionId(v string) *DescribeMarketingActivityResponseBody {
	s.RegionId = &v
	return s
}

func (s *DescribeMarketingActivityResponseBody) SetRequestId(v string) *DescribeMarketingActivityResponseBody {
	s.RequestId = &v
	return s
}

type DescribeMarketingActivityResponseBodyItems struct {
	// The RDS edition of the instance. Valid values:
	//
	// *   **Basic**: RDS Basic Edition
	// *   **HighAvailability**: High-availability Edition
	// *   **Finance**: RDS Enterprise Edition
	//
	// > This parameter is returned only when **InstanceLevel** is set to **1**.
	Category *string `json:"Category,omitempty" xml:"Category,omitempty"`
	// The billing method of the instance. Valid values:
	//
	// *   **PostPaid** (default): pay-as-you-go
	// *   **PrePaid**: subscription
	//
	// > **Period** is required if you set the value of this parameter to **PrePaid**.
	ChargeType *string `json:"ChargeType,omitempty" xml:"ChargeType,omitempty"`
	// The code of the instance type. For more information, see [Primary ApsaraDB RDS instance types](~~26312~~) and [Read-only ApsaraDB RDS instance types](~~145759~~).
	ClassCode *string `json:"ClassCode,omitempty" xml:"ClassCode,omitempty"`
	// The instance family. For more information, see [Overview of instance families](~~57184~~).
	ClassGroup *string `json:"ClassGroup,omitempty" xml:"ClassGroup,omitempty"`
	// The number of vCPU cores. Unit: cores.
	Cpu *string `json:"Cpu,omitempty" xml:"Cpu,omitempty"`
	// The disk size. Unit: GB.
	//
	// *   The disk size that you specify must be greater than or equal to the current disk size of the instance.
	// *   For more information about the valid values, see [Billing](~~84737~~).
	DiskSize *int32 `json:"DiskSize,omitempty" xml:"DiskSize,omitempty"`
	// The database engine of the instance. Valid values:
	//
	// *   **MySQL**
	// *   **PostgreSQL**
	// *   **SQLServer**
	// *   **MariaDB**
	Engine *string `json:"Engine,omitempty" xml:"Engine,omitempty"`
	// The database engine version.
	EngineVersion *string `json:"EngineVersion,omitempty" xml:"EngineVersion,omitempty"`
	// The instance ID.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The instance name.
	InstanceName *string `json:"InstanceName,omitempty" xml:"InstanceName,omitempty"`
	// The maximum number of concurrent connections.
	MaxConnections *int32 `json:"MaxConnections,omitempty" xml:"MaxConnections,omitempty"`
	// MaxIombps
	MaxIombps *int32 `json:"MaxIombps,omitempty" xml:"MaxIombps,omitempty"`
	// MaxIops
	MaxIops *int32 `json:"MaxIops,omitempty" xml:"MaxIops,omitempty"`
	// The memory size that you applied for each instance. Unit: MB.
	Memory *int64 `json:"Memory,omitempty" xml:"Memory,omitempty"`
	// The storage type of the instance. Valid values:
	//
	// *   **local_ssd**: local SSD
	// *   **cloud_ssd**: standard SSD
	// *   **cloud_essd**: enhanced SSD (ESSD) of performance level 1 (PL1)
	// *   **cloud_essd2**: ESSD of PL2
	// *   **cloud_essd3**: ESSD of PL3
	StorageType *string `json:"StorageType,omitempty" xml:"StorageType,omitempty"`
	// UpgradeCategory
	UpgradeCategory *string `json:"UpgradeCategory,omitempty" xml:"UpgradeCategory,omitempty"`
	// UpgradeClassCode
	UpgradeClassCode *string `json:"UpgradeClassCode,omitempty" xml:"UpgradeClassCode,omitempty"`
	// UpgradeClassGroup
	UpgradeClassGroup *string `json:"UpgradeClassGroup,omitempty" xml:"UpgradeClassGroup,omitempty"`
	// UpgradeCpu
	UpgradeCpu *string `json:"UpgradeCpu,omitempty" xml:"UpgradeCpu,omitempty"`
	// UpgradeDescContent
	UpgradeDescContent *string `json:"UpgradeDescContent,omitempty" xml:"UpgradeDescContent,omitempty"`
	// UpgradeDiskSize
	UpgradeDiskSize *int32 `json:"UpgradeDiskSize,omitempty" xml:"UpgradeDiskSize,omitempty"`
	// UpgradeMaxConnections
	UpgradeMaxConnections *int32 `json:"UpgradeMaxConnections,omitempty" xml:"UpgradeMaxConnections,omitempty"`
	// UpgradeMaxIombps
	UpgradeMaxIombps *int32 `json:"UpgradeMaxIombps,omitempty" xml:"UpgradeMaxIombps,omitempty"`
	// UpgradeMaxIops
	UpgradeMaxIops *int32 `json:"UpgradeMaxIops,omitempty" xml:"UpgradeMaxIops,omitempty"`
	// UpgradeMemory
	UpgradeMemory *int64 `json:"UpgradeMemory,omitempty" xml:"UpgradeMemory,omitempty"`
	// UpgradeReferencePrice
	UpgradeReferencePrice *string `json:"UpgradeReferencePrice,omitempty" xml:"UpgradeReferencePrice,omitempty"`
	// UpgradeStorageType
	UpgradeStorageType *string `json:"UpgradeStorageType,omitempty" xml:"UpgradeStorageType,omitempty"`
}

func (s DescribeMarketingActivityResponseBodyItems) String() string {
	return tea.Prettify(s)
}

func (s DescribeMarketingActivityResponseBodyItems) GoString() string {
	return s.String()
}

func (s *DescribeMarketingActivityResponseBodyItems) SetCategory(v string) *DescribeMarketingActivityResponseBodyItems {
	s.Category = &v
	return s
}

func (s *DescribeMarketingActivityResponseBodyItems) SetChargeType(v string) *DescribeMarketingActivityResponseBodyItems {
	s.ChargeType = &v
	return s
}

func (s *DescribeMarketingActivityResponseBodyItems) SetClassCode(v string) *DescribeMarketingActivityResponseBodyItems {
	s.ClassCode = &v
	return s
}

func (s *DescribeMarketingActivityResponseBodyItems) SetClassGroup(v string) *DescribeMarketingActivityResponseBodyItems {
	s.ClassGroup = &v
	return s
}

func (s *DescribeMarketingActivityResponseBodyItems) SetCpu(v string) *DescribeMarketingActivityResponseBodyItems {
	s.Cpu = &v
	return s
}

func (s *DescribeMarketingActivityResponseBodyItems) SetDiskSize(v int32) *DescribeMarketingActivityResponseBodyItems {
	s.DiskSize = &v
	return s
}

func (s *DescribeMarketingActivityResponseBodyItems) SetEngine(v string) *DescribeMarketingActivityResponseBodyItems {
	s.Engine = &v
	return s
}

func (s *DescribeMarketingActivityResponseBodyItems) SetEngineVersion(v string) *DescribeMarketingActivityResponseBodyItems {
	s.EngineVersion = &v
	return s
}

func (s *DescribeMarketingActivityResponseBodyItems) SetInstanceId(v string) *DescribeMarketingActivityResponseBodyItems {
	s.InstanceId = &v
	return s
}

func (s *DescribeMarketingActivityResponseBodyItems) SetInstanceName(v string) *DescribeMarketingActivityResponseBodyItems {
	s.InstanceName = &v
	return s
}

func (s *DescribeMarketingActivityResponseBodyItems) SetMaxConnections(v int32) *DescribeMarketingActivityResponseBodyItems {
	s.MaxConnections = &v
	return s
}

func (s *DescribeMarketingActivityResponseBodyItems) SetMaxIombps(v int32) *DescribeMarketingActivityResponseBodyItems {
	s.MaxIombps = &v
	return s
}

func (s *DescribeMarketingActivityResponseBodyItems) SetMaxIops(v int32) *DescribeMarketingActivityResponseBodyItems {
	s.MaxIops = &v
	return s
}

func (s *DescribeMarketingActivityResponseBodyItems) SetMemory(v int64) *DescribeMarketingActivityResponseBodyItems {
	s.Memory = &v
	return s
}

func (s *DescribeMarketingActivityResponseBodyItems) SetStorageType(v string) *DescribeMarketingActivityResponseBodyItems {
	s.StorageType = &v
	return s
}

func (s *DescribeMarketingActivityResponseBodyItems) SetUpgradeCategory(v string) *DescribeMarketingActivityResponseBodyItems {
	s.UpgradeCategory = &v
	return s
}

func (s *DescribeMarketingActivityResponseBodyItems) SetUpgradeClassCode(v string) *DescribeMarketingActivityResponseBodyItems {
	s.UpgradeClassCode = &v
	return s
}

func (s *DescribeMarketingActivityResponseBodyItems) SetUpgradeClassGroup(v string) *DescribeMarketingActivityResponseBodyItems {
	s.UpgradeClassGroup = &v
	return s
}

func (s *DescribeMarketingActivityResponseBodyItems) SetUpgradeCpu(v string) *DescribeMarketingActivityResponseBodyItems {
	s.UpgradeCpu = &v
	return s
}

func (s *DescribeMarketingActivityResponseBodyItems) SetUpgradeDescContent(v string) *DescribeMarketingActivityResponseBodyItems {
	s.UpgradeDescContent = &v
	return s
}

func (s *DescribeMarketingActivityResponseBodyItems) SetUpgradeDiskSize(v int32) *DescribeMarketingActivityResponseBodyItems {
	s.UpgradeDiskSize = &v
	return s
}

func (s *DescribeMarketingActivityResponseBodyItems) SetUpgradeMaxConnections(v int32) *DescribeMarketingActivityResponseBodyItems {
	s.UpgradeMaxConnections = &v
	return s
}

func (s *DescribeMarketingActivityResponseBodyItems) SetUpgradeMaxIombps(v int32) *DescribeMarketingActivityResponseBodyItems {
	s.UpgradeMaxIombps = &v
	return s
}

func (s *DescribeMarketingActivityResponseBodyItems) SetUpgradeMaxIops(v int32) *DescribeMarketingActivityResponseBodyItems {
	s.UpgradeMaxIops = &v
	return s
}

func (s *DescribeMarketingActivityResponseBodyItems) SetUpgradeMemory(v int64) *DescribeMarketingActivityResponseBodyItems {
	s.UpgradeMemory = &v
	return s
}

func (s *DescribeMarketingActivityResponseBodyItems) SetUpgradeReferencePrice(v string) *DescribeMarketingActivityResponseBodyItems {
	s.UpgradeReferencePrice = &v
	return s
}

func (s *DescribeMarketingActivityResponseBodyItems) SetUpgradeStorageType(v string) *DescribeMarketingActivityResponseBodyItems {
	s.UpgradeStorageType = &v
	return s
}

type DescribeMarketingActivityResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeMarketingActivityResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeMarketingActivityResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeMarketingActivityResponse) GoString() string {
	return s.String()
}

func (s *DescribeMarketingActivityResponse) SetHeaders(v map[string]*string) *DescribeMarketingActivityResponse {
	s.Headers = v
	return s
}

func (s *DescribeMarketingActivityResponse) SetStatusCode(v int32) *DescribeMarketingActivityResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeMarketingActivityResponse) SetBody(v *DescribeMarketingActivityResponseBody) *DescribeMarketingActivityResponse {
	s.Body = v
	return s
}

type DescribeMetaListRequest struct {
	// The ID of the backup set from which you want to restore data. You can call the [DescribeBackups](~~26273~~) operation to query the IDs of backup sets.
	//
	// > If you set the **RestoreType** parameter to **BackupSetID**, you must also specify this parameter.
	BackupSetID *int32 `json:"BackupSetID,omitempty" xml:"BackupSetID,omitempty"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the instance. You can call the [DescribeDBInstances](~~26232~~) operation to query the ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The name of the database to query. The system implements exact match based on the value of this parameter and returns the name of the matched database and the names of all tables contained in the database.
	//
	// > If you leave this parameter empty, the system returns all databases that are created on the instance.
	GetDbName *string `json:"GetDbName,omitempty" xml:"GetDbName,omitempty"`
	OwnerId   *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of the page to return. Valid values: any non-zero positive integer.**** Default value: **1**.
	//
	// > This parameter only takes effect when you specify the **PageSize** parameter.
	PageIndex *int32 `json:"PageIndex,omitempty" xml:"PageIndex,omitempty"`
	// The number of entries to return on each page. Default value: **1**.
	//
	// > This parameter only takes effect when you specify the **PageIndex** parameter.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The name of the database to query. The system implements fuzzy match based on the value of this parameter and returns only the name of the matched database.
	//
	// > For example, if you set the value to `test`, the system returns `testdb1` and `testdb2`. Then, you can specify the **GetDbName** parameter to query tables in the required database.
	Pattern *string `json:"Pattern,omitempty" xml:"Pattern,omitempty"`
	// The ID of the resource group.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The point in time to which you want to restore data. The specified point in time must be earlier than the current time. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC. You can call the [DescribeBackups](~~26273~~) operation to query the restorable time range.
	//
	// > If you set the **RestoreType** parameter to **RestoreTime**, you must also specify this parameter.
	RestoreTime *string `json:"RestoreTime,omitempty" xml:"RestoreTime,omitempty"`
	// The method that is used to restore data. Valid values:
	//
	// *   **BackupSetID**: Data is restored from a backup set. If you use this value, you must also specify the **BackupSetID** parameter.
	// *   **RestoreTime**: Data is restored to a specific point in time. If you use this value, you must also specify the **RestoreTime** parameter.
	//
	// Default value: **BackupSetID**.
	RestoreType *string `json:"RestoreType,omitempty" xml:"RestoreType,omitempty"`
}

func (s DescribeMetaListRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeMetaListRequest) GoString() string {
	return s.String()
}

func (s *DescribeMetaListRequest) SetBackupSetID(v int32) *DescribeMetaListRequest {
	s.BackupSetID = &v
	return s
}

func (s *DescribeMetaListRequest) SetClientToken(v string) *DescribeMetaListRequest {
	s.ClientToken = &v
	return s
}

func (s *DescribeMetaListRequest) SetDBInstanceId(v string) *DescribeMetaListRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeMetaListRequest) SetGetDbName(v string) *DescribeMetaListRequest {
	s.GetDbName = &v
	return s
}

func (s *DescribeMetaListRequest) SetOwnerId(v int64) *DescribeMetaListRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeMetaListRequest) SetPageIndex(v int32) *DescribeMetaListRequest {
	s.PageIndex = &v
	return s
}

func (s *DescribeMetaListRequest) SetPageSize(v int32) *DescribeMetaListRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeMetaListRequest) SetPattern(v string) *DescribeMetaListRequest {
	s.Pattern = &v
	return s
}

func (s *DescribeMetaListRequest) SetResourceGroupId(v string) *DescribeMetaListRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeMetaListRequest) SetResourceOwnerAccount(v string) *DescribeMetaListRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeMetaListRequest) SetResourceOwnerId(v int64) *DescribeMetaListRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeMetaListRequest) SetRestoreTime(v string) *DescribeMetaListRequest {
	s.RestoreTime = &v
	return s
}

func (s *DescribeMetaListRequest) SetRestoreType(v string) *DescribeMetaListRequest {
	s.RestoreType = &v
	return s
}

type DescribeMetaListResponseBody struct {
	// The name of the instance.
	DBInstanceName *string `json:"DBInstanceName,omitempty" xml:"DBInstanceName,omitempty"`
	// An array consisting of the information about the databases and tables whose data is included in the backup set.
	Items *DescribeMetaListResponseBodyItems `json:"Items,omitempty" xml:"Items,omitempty" type:"Struct"`
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageRecordCount *int32 `json:"PageRecordCount,omitempty" xml:"PageRecordCount,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of pages returned.
	TotalPageCount *int32 `json:"TotalPageCount,omitempty" xml:"TotalPageCount,omitempty"`
	// The total number of returned entries.
	TotalRecordCount *int32 `json:"TotalRecordCount,omitempty" xml:"TotalRecordCount,omitempty"`
}

func (s DescribeMetaListResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeMetaListResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeMetaListResponseBody) SetDBInstanceName(v string) *DescribeMetaListResponseBody {
	s.DBInstanceName = &v
	return s
}

func (s *DescribeMetaListResponseBody) SetItems(v *DescribeMetaListResponseBodyItems) *DescribeMetaListResponseBody {
	s.Items = v
	return s
}

func (s *DescribeMetaListResponseBody) SetPageNumber(v int32) *DescribeMetaListResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeMetaListResponseBody) SetPageRecordCount(v int32) *DescribeMetaListResponseBody {
	s.PageRecordCount = &v
	return s
}

func (s *DescribeMetaListResponseBody) SetRequestId(v string) *DescribeMetaListResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeMetaListResponseBody) SetTotalPageCount(v int32) *DescribeMetaListResponseBody {
	s.TotalPageCount = &v
	return s
}

func (s *DescribeMetaListResponseBody) SetTotalRecordCount(v int32) *DescribeMetaListResponseBody {
	s.TotalRecordCount = &v
	return s
}

type DescribeMetaListResponseBodyItems struct {
	Meta []*DescribeMetaListResponseBodyItemsMeta `json:"Meta,omitempty" xml:"Meta,omitempty" type:"Repeated"`
}

func (s DescribeMetaListResponseBodyItems) String() string {
	return tea.Prettify(s)
}

func (s DescribeMetaListResponseBodyItems) GoString() string {
	return s.String()
}

func (s *DescribeMetaListResponseBodyItems) SetMeta(v []*DescribeMetaListResponseBodyItemsMeta) *DescribeMetaListResponseBodyItems {
	s.Meta = v
	return s
}

type DescribeMetaListResponseBodyItemsMeta struct {
	// The name of the database.
	Database *string `json:"Database,omitempty" xml:"Database,omitempty"`
	// The size of the table. Unit: KB.
	Size *string `json:"Size,omitempty" xml:"Size,omitempty"`
	// The name of the table.
	Tables *string `json:"Tables,omitempty" xml:"Tables,omitempty"`
}

func (s DescribeMetaListResponseBodyItemsMeta) String() string {
	return tea.Prettify(s)
}

func (s DescribeMetaListResponseBodyItemsMeta) GoString() string {
	return s.String()
}

func (s *DescribeMetaListResponseBodyItemsMeta) SetDatabase(v string) *DescribeMetaListResponseBodyItemsMeta {
	s.Database = &v
	return s
}

func (s *DescribeMetaListResponseBodyItemsMeta) SetSize(v string) *DescribeMetaListResponseBodyItemsMeta {
	s.Size = &v
	return s
}

func (s *DescribeMetaListResponseBodyItemsMeta) SetTables(v string) *DescribeMetaListResponseBodyItemsMeta {
	s.Tables = &v
	return s
}

type DescribeMetaListResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeMetaListResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeMetaListResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeMetaListResponse) GoString() string {
	return s.String()
}

func (s *DescribeMetaListResponse) SetHeaders(v map[string]*string) *DescribeMetaListResponse {
	s.Headers = v
	return s
}

func (s *DescribeMetaListResponse) SetStatusCode(v int32) *DescribeMetaListResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeMetaListResponse) SetBody(v *DescribeMetaListResponseBody) *DescribeMetaListResponse {
	s.Body = v
	return s
}

type DescribeMigrateTaskByIdRequest struct {
	// The instance ID. You can call the [DescribeDBInstances](~~610396~~) operation to query the instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The ID of the migration task. You can call the [DescribeMigrateTasks](~~64563~~) operation to query the ID of the migration task.
	MigrateTaskId *string `json:"MigrateTaskId,omitempty" xml:"MigrateTaskId,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeMigrateTaskByIdRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeMigrateTaskByIdRequest) GoString() string {
	return s.String()
}

func (s *DescribeMigrateTaskByIdRequest) SetDBInstanceId(v string) *DescribeMigrateTaskByIdRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeMigrateTaskByIdRequest) SetMigrateTaskId(v string) *DescribeMigrateTaskByIdRequest {
	s.MigrateTaskId = &v
	return s
}

func (s *DescribeMigrateTaskByIdRequest) SetOwnerId(v int64) *DescribeMigrateTaskByIdRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeMigrateTaskByIdRequest) SetResourceGroupId(v string) *DescribeMigrateTaskByIdRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeMigrateTaskByIdRequest) SetResourceOwnerAccount(v string) *DescribeMigrateTaskByIdRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeMigrateTaskByIdRequest) SetResourceOwnerId(v int64) *DescribeMigrateTaskByIdRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeMigrateTaskByIdResponseBody struct {
	// The type of the migration task. Valid values:
	//
	// *   **FULL**: The migration task migrates full backup files that can be used to restore the full data of the instance.
	// *   **UPDF**: The migration task migrates incremental or log backup files that can be used to restore the incremental data of the instance.
	BackupMode *string `json:"BackupMode,omitempty" xml:"BackupMode,omitempty"`
	// The time when the migration task was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The instance ID.
	DBInstanceName *string `json:"DBInstanceName,omitempty" xml:"DBInstanceName,omitempty"`
	// The name of the database.
	DBName *string `json:"DBName,omitempty" xml:"DBName,omitempty"`
	// The description of the migration task.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The time when the migration task was completed. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// Indicates whether the imported data overwrites the existing data. Valid values:
	//
	// *   **False**: The imported data does not overwrite the existing data.
	// *   **True**: The imported data overwrites the existing data.
	IsDBReplaced *string `json:"IsDBReplaced,omitempty" xml:"IsDBReplaced,omitempty"`
	// The ID of the migration task.
	MigrateTaskId *string `json:"MigrateTaskId,omitempty" xml:"MigrateTaskId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The status of the migration task. Valid values:
	//
	// *   **NoStart**: The task has not started.
	// *   **Running**:The task is in progress.
	// *   **Success**: The task is successful.
	// *   **Failed**: The task failed.
	// *   **Waiting**: The task is waiting for an incremental backup file to be imported.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeMigrateTaskByIdResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeMigrateTaskByIdResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeMigrateTaskByIdResponseBody) SetBackupMode(v string) *DescribeMigrateTaskByIdResponseBody {
	s.BackupMode = &v
	return s
}

func (s *DescribeMigrateTaskByIdResponseBody) SetCreateTime(v string) *DescribeMigrateTaskByIdResponseBody {
	s.CreateTime = &v
	return s
}

func (s *DescribeMigrateTaskByIdResponseBody) SetDBInstanceName(v string) *DescribeMigrateTaskByIdResponseBody {
	s.DBInstanceName = &v
	return s
}

func (s *DescribeMigrateTaskByIdResponseBody) SetDBName(v string) *DescribeMigrateTaskByIdResponseBody {
	s.DBName = &v
	return s
}

func (s *DescribeMigrateTaskByIdResponseBody) SetDescription(v string) *DescribeMigrateTaskByIdResponseBody {
	s.Description = &v
	return s
}

func (s *DescribeMigrateTaskByIdResponseBody) SetEndTime(v string) *DescribeMigrateTaskByIdResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeMigrateTaskByIdResponseBody) SetIsDBReplaced(v string) *DescribeMigrateTaskByIdResponseBody {
	s.IsDBReplaced = &v
	return s
}

func (s *DescribeMigrateTaskByIdResponseBody) SetMigrateTaskId(v string) *DescribeMigrateTaskByIdResponseBody {
	s.MigrateTaskId = &v
	return s
}

func (s *DescribeMigrateTaskByIdResponseBody) SetRequestId(v string) *DescribeMigrateTaskByIdResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeMigrateTaskByIdResponseBody) SetStatus(v string) *DescribeMigrateTaskByIdResponseBody {
	s.Status = &v
	return s
}

type DescribeMigrateTaskByIdResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeMigrateTaskByIdResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeMigrateTaskByIdResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeMigrateTaskByIdResponse) GoString() string {
	return s.String()
}

func (s *DescribeMigrateTaskByIdResponse) SetHeaders(v map[string]*string) *DescribeMigrateTaskByIdResponse {
	s.Headers = v
	return s
}

func (s *DescribeMigrateTaskByIdResponse) SetStatusCode(v int32) *DescribeMigrateTaskByIdResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeMigrateTaskByIdResponse) SetBody(v *DescribeMigrateTaskByIdResponseBody) *DescribeMigrateTaskByIdResponse {
	s.Body = v
	return s
}

type DescribeMigrateTasksRequest struct {
	// The ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The end of the time range to query. The end time must be later than the start time. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm*Z format. The time must be in UTC.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	OwnerId *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The page number. Valid values: any non-zero positive integer.
	//
	// Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Valid values: **30** to **100**. Default value: **30**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the resource group.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm*Z format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeMigrateTasksRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeMigrateTasksRequest) GoString() string {
	return s.String()
}

func (s *DescribeMigrateTasksRequest) SetDBInstanceId(v string) *DescribeMigrateTasksRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeMigrateTasksRequest) SetEndTime(v string) *DescribeMigrateTasksRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeMigrateTasksRequest) SetOwnerId(v int64) *DescribeMigrateTasksRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeMigrateTasksRequest) SetPageNumber(v int32) *DescribeMigrateTasksRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeMigrateTasksRequest) SetPageSize(v int32) *DescribeMigrateTasksRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeMigrateTasksRequest) SetResourceGroupId(v string) *DescribeMigrateTasksRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeMigrateTasksRequest) SetResourceOwnerAccount(v string) *DescribeMigrateTasksRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeMigrateTasksRequest) SetResourceOwnerId(v int64) *DescribeMigrateTasksRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeMigrateTasksRequest) SetStartTime(v string) *DescribeMigrateTasksRequest {
	s.StartTime = &v
	return s
}

type DescribeMigrateTasksResponseBody struct {
	// The ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The details of the migration task.
	Items *DescribeMigrateTasksResponseBodyItems `json:"Items,omitempty" xml:"Items,omitempty" type:"Struct"`
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageRecordCount *int32 `json:"PageRecordCount,omitempty" xml:"PageRecordCount,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalRecordCount *int32 `json:"TotalRecordCount,omitempty" xml:"TotalRecordCount,omitempty"`
}

func (s DescribeMigrateTasksResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeMigrateTasksResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeMigrateTasksResponseBody) SetDBInstanceId(v string) *DescribeMigrateTasksResponseBody {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeMigrateTasksResponseBody) SetItems(v *DescribeMigrateTasksResponseBodyItems) *DescribeMigrateTasksResponseBody {
	s.Items = v
	return s
}

func (s *DescribeMigrateTasksResponseBody) SetPageNumber(v int32) *DescribeMigrateTasksResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeMigrateTasksResponseBody) SetPageRecordCount(v int32) *DescribeMigrateTasksResponseBody {
	s.PageRecordCount = &v
	return s
}

func (s *DescribeMigrateTasksResponseBody) SetRequestId(v string) *DescribeMigrateTasksResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeMigrateTasksResponseBody) SetTotalRecordCount(v int32) *DescribeMigrateTasksResponseBody {
	s.TotalRecordCount = &v
	return s
}

type DescribeMigrateTasksResponseBodyItems struct {
	MigrateTask []*DescribeMigrateTasksResponseBodyItemsMigrateTask `json:"MigrateTask,omitempty" xml:"MigrateTask,omitempty" type:"Repeated"`
}

func (s DescribeMigrateTasksResponseBodyItems) String() string {
	return tea.Prettify(s)
}

func (s DescribeMigrateTasksResponseBodyItems) GoString() string {
	return s.String()
}

func (s *DescribeMigrateTasksResponseBodyItems) SetMigrateTask(v []*DescribeMigrateTasksResponseBodyItemsMigrateTask) *DescribeMigrateTasksResponseBodyItems {
	s.MigrateTask = v
	return s
}

type DescribeMigrateTasksResponseBodyItemsMigrateTask struct {
	// The type of the migration task. Valid values:
	//
	// *   **FULL**: The migration task migrates full backup files that can be used to restore the full data of the instance.
	// *   **UPDF**: The migration task migrates incremental or log backup files that can be used to restore the incremental data of the instance.
	BackupMode *string `json:"BackupMode,omitempty" xml:"BackupMode,omitempty"`
	// The time when the migration task was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The name of the database.
	DBName *string `json:"DBName,omitempty" xml:"DBName,omitempty"`
	// The description of the migration task.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The time when the migration task was completed. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// Indicates whether the imported data overwrites the existing data.
	IsDBReplaced *string `json:"IsDBReplaced,omitempty" xml:"IsDBReplaced,omitempty"`
	// The ID of the migration task.
	MigrateTaskId *string `json:"MigrateTaskId,omitempty" xml:"MigrateTaskId,omitempty"`
	// The status of the migration task. Valid values:
	//
	// *   **NoStart**: The task is not started.
	// *   **Running**:The task is in progress.
	// *   **Success**: The task is successful.
	// *   **Failed**: The task failed.
	// *   **Waiting**: The task is waiting for an incremental backup file to be imported.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeMigrateTasksResponseBodyItemsMigrateTask) String() string {
	return tea.Prettify(s)
}

func (s DescribeMigrateTasksResponseBodyItemsMigrateTask) GoString() string {
	return s.String()
}

func (s *DescribeMigrateTasksResponseBodyItemsMigrateTask) SetBackupMode(v string) *DescribeMigrateTasksResponseBodyItemsMigrateTask {
	s.BackupMode = &v
	return s
}

func (s *DescribeMigrateTasksResponseBodyItemsMigrateTask) SetCreateTime(v string) *DescribeMigrateTasksResponseBodyItemsMigrateTask {
	s.CreateTime = &v
	return s
}

func (s *DescribeMigrateTasksResponseBodyItemsMigrateTask) SetDBName(v string) *DescribeMigrateTasksResponseBodyItemsMigrateTask {
	s.DBName = &v
	return s
}

func (s *DescribeMigrateTasksResponseBodyItemsMigrateTask) SetDescription(v string) *DescribeMigrateTasksResponseBodyItemsMigrateTask {
	s.Description = &v
	return s
}

func (s *DescribeMigrateTasksResponseBodyItemsMigrateTask) SetEndTime(v string) *DescribeMigrateTasksResponseBodyItemsMigrateTask {
	s.EndTime = &v
	return s
}

func (s *DescribeMigrateTasksResponseBodyItemsMigrateTask) SetIsDBReplaced(v string) *DescribeMigrateTasksResponseBodyItemsMigrateTask {
	s.IsDBReplaced = &v
	return s
}

func (s *DescribeMigrateTasksResponseBodyItemsMigrateTask) SetMigrateTaskId(v string) *DescribeMigrateTasksResponseBodyItemsMigrateTask {
	s.MigrateTaskId = &v
	return s
}

func (s *DescribeMigrateTasksResponseBodyItemsMigrateTask) SetStatus(v string) *DescribeMigrateTasksResponseBodyItemsMigrateTask {
	s.Status = &v
	return s
}

type DescribeMigrateTasksResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeMigrateTasksResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeMigrateTasksResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeMigrateTasksResponse) GoString() string {
	return s.String()
}

func (s *DescribeMigrateTasksResponse) SetHeaders(v map[string]*string) *DescribeMigrateTasksResponse {
	s.Headers = v
	return s
}

func (s *DescribeMigrateTasksResponse) SetStatusCode(v int32) *DescribeMigrateTasksResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeMigrateTasksResponse) SetBody(v *DescribeMigrateTasksResponseBody) *DescribeMigrateTasksResponse {
	s.Body = v
	return s
}

type DescribeModifyPGHbaConfigLogRequest struct {
	// A reserved parameter. You do not need to specify this parameter.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The instance ID. You can call the [DescribeDBInstances](~~610396~~) operation to query the ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mmZ format. The time must be in UTC.
	EndTime      *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mmZ format. The time must be in Coordinated Universal Time (UTC).
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeModifyPGHbaConfigLogRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeModifyPGHbaConfigLogRequest) GoString() string {
	return s.String()
}

func (s *DescribeModifyPGHbaConfigLogRequest) SetClientToken(v string) *DescribeModifyPGHbaConfigLogRequest {
	s.ClientToken = &v
	return s
}

func (s *DescribeModifyPGHbaConfigLogRequest) SetDBInstanceId(v string) *DescribeModifyPGHbaConfigLogRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeModifyPGHbaConfigLogRequest) SetEndTime(v string) *DescribeModifyPGHbaConfigLogRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeModifyPGHbaConfigLogRequest) SetOwnerAccount(v string) *DescribeModifyPGHbaConfigLogRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeModifyPGHbaConfigLogRequest) SetOwnerId(v int64) *DescribeModifyPGHbaConfigLogRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeModifyPGHbaConfigLogRequest) SetResourceGroupId(v string) *DescribeModifyPGHbaConfigLogRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeModifyPGHbaConfigLogRequest) SetResourceOwnerAccount(v string) *DescribeModifyPGHbaConfigLogRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeModifyPGHbaConfigLogRequest) SetResourceOwnerId(v int64) *DescribeModifyPGHbaConfigLogRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeModifyPGHbaConfigLogRequest) SetStartTime(v string) *DescribeModifyPGHbaConfigLogRequest {
	s.StartTime = &v
	return s
}

type DescribeModifyPGHbaConfigLogResponseBody struct {
	// The instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// An array that consists of the modifications to the pg_hba.conf file.
	HbaLogItems *DescribeModifyPGHbaConfigLogResponseBodyHbaLogItems `json:"HbaLogItems,omitempty" xml:"HbaLogItems,omitempty" type:"Struct"`
	// The number of modification records.
	LogItemCount *int32 `json:"LogItemCount,omitempty" xml:"LogItemCount,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeModifyPGHbaConfigLogResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeModifyPGHbaConfigLogResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeModifyPGHbaConfigLogResponseBody) SetDBInstanceId(v string) *DescribeModifyPGHbaConfigLogResponseBody {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeModifyPGHbaConfigLogResponseBody) SetHbaLogItems(v *DescribeModifyPGHbaConfigLogResponseBodyHbaLogItems) *DescribeModifyPGHbaConfigLogResponseBody {
	s.HbaLogItems = v
	return s
}

func (s *DescribeModifyPGHbaConfigLogResponseBody) SetLogItemCount(v int32) *DescribeModifyPGHbaConfigLogResponseBody {
	s.LogItemCount = &v
	return s
}

func (s *DescribeModifyPGHbaConfigLogResponseBody) SetRequestId(v string) *DescribeModifyPGHbaConfigLogResponseBody {
	s.RequestId = &v
	return s
}

type DescribeModifyPGHbaConfigLogResponseBodyHbaLogItems struct {
	HbaLogItem []*DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItem `json:"HbaLogItem,omitempty" xml:"HbaLogItem,omitempty" type:"Repeated"`
}

func (s DescribeModifyPGHbaConfigLogResponseBodyHbaLogItems) String() string {
	return tea.Prettify(s)
}

func (s DescribeModifyPGHbaConfigLogResponseBodyHbaLogItems) GoString() string {
	return s.String()
}

func (s *DescribeModifyPGHbaConfigLogResponseBodyHbaLogItems) SetHbaLogItem(v []*DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItem) *DescribeModifyPGHbaConfigLogResponseBodyHbaLogItems {
	s.HbaLogItem = v
	return s
}

type DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItem struct {
	// The configurations of the pg_hba.conf file after modification.
	AfterHbaItems *DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItemAfterHbaItems `json:"AfterHbaItems,omitempty" xml:"AfterHbaItems,omitempty" type:"Struct"`
	// The configurations of the pg_hba.conf file before modification.
	BeforeHbaItems *DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItemBeforeHbaItems `json:"BeforeHbaItems,omitempty" xml:"BeforeHbaItems,omitempty" type:"Struct"`
	// The status of the modification.
	//
	// *   **success**: The modification is successful.
	// *   **failed**: The modification failed.
	// *   **setting**: The modification is being applied.
	ModifyStatus *string `json:"ModifyStatus,omitempty" xml:"ModifyStatus,omitempty"`
	// The time when the pg_hba.conf file was modified. The time is displayed in UTC.
	ModifyTime *string `json:"ModifyTime,omitempty" xml:"ModifyTime,omitempty"`
	// The reason why the modification failed.
	StatusReason *string `json:"StatusReason,omitempty" xml:"StatusReason,omitempty"`
}

func (s DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItem) String() string {
	return tea.Prettify(s)
}

func (s DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItem) GoString() string {
	return s.String()
}

func (s *DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItem) SetAfterHbaItems(v *DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItemAfterHbaItems) *DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItem {
	s.AfterHbaItems = v
	return s
}

func (s *DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItem) SetBeforeHbaItems(v *DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItemBeforeHbaItems) *DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItem {
	s.BeforeHbaItems = v
	return s
}

func (s *DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItem) SetModifyStatus(v string) *DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItem {
	s.ModifyStatus = &v
	return s
}

func (s *DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItem) SetModifyTime(v string) *DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItem {
	s.ModifyTime = &v
	return s
}

func (s *DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItem) SetStatusReason(v string) *DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItem {
	s.StatusReason = &v
	return s
}

type DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItemAfterHbaItems struct {
	HbaItem []*DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItemAfterHbaItemsHbaItem `json:"HbaItem,omitempty" xml:"HbaItem,omitempty" type:"Repeated"`
}

func (s DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItemAfterHbaItems) String() string {
	return tea.Prettify(s)
}

func (s DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItemAfterHbaItems) GoString() string {
	return s.String()
}

func (s *DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItemAfterHbaItems) SetHbaItem(v []*DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItemAfterHbaItemsHbaItem) *DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItemAfterHbaItems {
	s.HbaItem = v
	return s
}

type DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItemAfterHbaItemsHbaItem struct {
	// The IP address.
	Address *string `json:"Address,omitempty" xml:"Address,omitempty"`
	// The name of the database.
	Database *string `json:"Database,omitempty" xml:"Database,omitempty"`
	// The mask of the IP address.
	Mask *string `json:"Mask,omitempty" xml:"Mask,omitempty"`
	// The authentication method.
	Method *string `json:"Method,omitempty" xml:"Method,omitempty"`
	// The value of this parameter was set based on the value of the Method parameter.
	Option *string `json:"Option,omitempty" xml:"Option,omitempty"`
	// The priority.
	PriorityId *int32 `json:"PriorityId,omitempty" xml:"PriorityId,omitempty"`
	// The connection type.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The username of the account.
	User *string `json:"User,omitempty" xml:"User,omitempty"`
}

func (s DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItemAfterHbaItemsHbaItem) String() string {
	return tea.Prettify(s)
}

func (s DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItemAfterHbaItemsHbaItem) GoString() string {
	return s.String()
}

func (s *DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItemAfterHbaItemsHbaItem) SetAddress(v string) *DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItemAfterHbaItemsHbaItem {
	s.Address = &v
	return s
}

func (s *DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItemAfterHbaItemsHbaItem) SetDatabase(v string) *DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItemAfterHbaItemsHbaItem {
	s.Database = &v
	return s
}

func (s *DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItemAfterHbaItemsHbaItem) SetMask(v string) *DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItemAfterHbaItemsHbaItem {
	s.Mask = &v
	return s
}

func (s *DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItemAfterHbaItemsHbaItem) SetMethod(v string) *DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItemAfterHbaItemsHbaItem {
	s.Method = &v
	return s
}

func (s *DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItemAfterHbaItemsHbaItem) SetOption(v string) *DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItemAfterHbaItemsHbaItem {
	s.Option = &v
	return s
}

func (s *DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItemAfterHbaItemsHbaItem) SetPriorityId(v int32) *DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItemAfterHbaItemsHbaItem {
	s.PriorityId = &v
	return s
}

func (s *DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItemAfterHbaItemsHbaItem) SetType(v string) *DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItemAfterHbaItemsHbaItem {
	s.Type = &v
	return s
}

func (s *DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItemAfterHbaItemsHbaItem) SetUser(v string) *DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItemAfterHbaItemsHbaItem {
	s.User = &v
	return s
}

type DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItemBeforeHbaItems struct {
	HbaItem []*DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItemBeforeHbaItemsHbaItem `json:"HbaItem,omitempty" xml:"HbaItem,omitempty" type:"Repeated"`
}

func (s DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItemBeforeHbaItems) String() string {
	return tea.Prettify(s)
}

func (s DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItemBeforeHbaItems) GoString() string {
	return s.String()
}

func (s *DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItemBeforeHbaItems) SetHbaItem(v []*DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItemBeforeHbaItemsHbaItem) *DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItemBeforeHbaItems {
	s.HbaItem = v
	return s
}

type DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItemBeforeHbaItemsHbaItem struct {
	// The IP address.
	Address *string `json:"Address,omitempty" xml:"Address,omitempty"`
	// The name of the database.
	Database *string `json:"Database,omitempty" xml:"Database,omitempty"`
	// The mask of the IP address.
	Mask *string `json:"Mask,omitempty" xml:"Mask,omitempty"`
	// The authentication method.
	Method *string `json:"Method,omitempty" xml:"Method,omitempty"`
	// The value of this parameter varies based on the value of the Method parameter.
	Option *string `json:"Option,omitempty" xml:"Option,omitempty"`
	// The priority.
	PriorityId *int32 `json:"PriorityId,omitempty" xml:"PriorityId,omitempty"`
	// The connection type.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The username of the account.
	User *string `json:"User,omitempty" xml:"User,omitempty"`
}

func (s DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItemBeforeHbaItemsHbaItem) String() string {
	return tea.Prettify(s)
}

func (s DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItemBeforeHbaItemsHbaItem) GoString() string {
	return s.String()
}

func (s *DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItemBeforeHbaItemsHbaItem) SetAddress(v string) *DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItemBeforeHbaItemsHbaItem {
	s.Address = &v
	return s
}

func (s *DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItemBeforeHbaItemsHbaItem) SetDatabase(v string) *DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItemBeforeHbaItemsHbaItem {
	s.Database = &v
	return s
}

func (s *DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItemBeforeHbaItemsHbaItem) SetMask(v string) *DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItemBeforeHbaItemsHbaItem {
	s.Mask = &v
	return s
}

func (s *DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItemBeforeHbaItemsHbaItem) SetMethod(v string) *DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItemBeforeHbaItemsHbaItem {
	s.Method = &v
	return s
}

func (s *DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItemBeforeHbaItemsHbaItem) SetOption(v string) *DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItemBeforeHbaItemsHbaItem {
	s.Option = &v
	return s
}

func (s *DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItemBeforeHbaItemsHbaItem) SetPriorityId(v int32) *DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItemBeforeHbaItemsHbaItem {
	s.PriorityId = &v
	return s
}

func (s *DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItemBeforeHbaItemsHbaItem) SetType(v string) *DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItemBeforeHbaItemsHbaItem {
	s.Type = &v
	return s
}

func (s *DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItemBeforeHbaItemsHbaItem) SetUser(v string) *DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItemBeforeHbaItemsHbaItem {
	s.User = &v
	return s
}

type DescribeModifyPGHbaConfigLogResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeModifyPGHbaConfigLogResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeModifyPGHbaConfigLogResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeModifyPGHbaConfigLogResponse) GoString() string {
	return s.String()
}

func (s *DescribeModifyPGHbaConfigLogResponse) SetHeaders(v map[string]*string) *DescribeModifyPGHbaConfigLogResponse {
	s.Headers = v
	return s
}

func (s *DescribeModifyPGHbaConfigLogResponse) SetStatusCode(v int32) *DescribeModifyPGHbaConfigLogResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeModifyPGHbaConfigLogResponse) SetBody(v *DescribeModifyPGHbaConfigLogResponseBody) *DescribeModifyPGHbaConfigLogResponse {
	s.Body = v
	return s
}

type DescribeModifyParameterLogRequest struct {
	// The instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The end of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm*Z format. The time must be in UTC.
	EndTime      *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The page number. Pages start from page 1.
	//
	// Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries per page. Valid values:
	//
	// *   **30**
	// *   **50**
	// *   **100**
	//
	// Default value: **30**.
	PageSize             *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm*Z format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeModifyParameterLogRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeModifyParameterLogRequest) GoString() string {
	return s.String()
}

func (s *DescribeModifyParameterLogRequest) SetDBInstanceId(v string) *DescribeModifyParameterLogRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeModifyParameterLogRequest) SetEndTime(v string) *DescribeModifyParameterLogRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeModifyParameterLogRequest) SetOwnerAccount(v string) *DescribeModifyParameterLogRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeModifyParameterLogRequest) SetOwnerId(v int64) *DescribeModifyParameterLogRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeModifyParameterLogRequest) SetPageNumber(v int32) *DescribeModifyParameterLogRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeModifyParameterLogRequest) SetPageSize(v int32) *DescribeModifyParameterLogRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeModifyParameterLogRequest) SetResourceOwnerAccount(v string) *DescribeModifyParameterLogRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeModifyParameterLogRequest) SetResourceOwnerId(v int64) *DescribeModifyParameterLogRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeModifyParameterLogRequest) SetStartTime(v string) *DescribeModifyParameterLogRequest {
	s.StartTime = &v
	return s
}

type DescribeModifyParameterLogResponseBody struct {
	// The instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The database engine of the instance.
	Engine *string `json:"Engine,omitempty" xml:"Engine,omitempty"`
	// The database engine version of the instance.
	EngineVersion *string `json:"EngineVersion,omitempty" xml:"EngineVersion,omitempty"`
	// An array that consists of parameter modification log entries.
	Items *DescribeModifyParameterLogResponseBodyItems `json:"Items,omitempty" xml:"Items,omitempty" type:"Struct"`
	// The page number.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries per page.
	PageRecordCount *int32 `json:"PageRecordCount,omitempty" xml:"PageRecordCount,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalRecordCount *int32 `json:"TotalRecordCount,omitempty" xml:"TotalRecordCount,omitempty"`
}

func (s DescribeModifyParameterLogResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeModifyParameterLogResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeModifyParameterLogResponseBody) SetDBInstanceId(v string) *DescribeModifyParameterLogResponseBody {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeModifyParameterLogResponseBody) SetEngine(v string) *DescribeModifyParameterLogResponseBody {
	s.Engine = &v
	return s
}

func (s *DescribeModifyParameterLogResponseBody) SetEngineVersion(v string) *DescribeModifyParameterLogResponseBody {
	s.EngineVersion = &v
	return s
}

func (s *DescribeModifyParameterLogResponseBody) SetItems(v *DescribeModifyParameterLogResponseBodyItems) *DescribeModifyParameterLogResponseBody {
	s.Items = v
	return s
}

func (s *DescribeModifyParameterLogResponseBody) SetPageNumber(v int32) *DescribeModifyParameterLogResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeModifyParameterLogResponseBody) SetPageRecordCount(v int32) *DescribeModifyParameterLogResponseBody {
	s.PageRecordCount = &v
	return s
}

func (s *DescribeModifyParameterLogResponseBody) SetRequestId(v string) *DescribeModifyParameterLogResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeModifyParameterLogResponseBody) SetTotalRecordCount(v int32) *DescribeModifyParameterLogResponseBody {
	s.TotalRecordCount = &v
	return s
}

type DescribeModifyParameterLogResponseBodyItems struct {
	ParameterChangeLog []*DescribeModifyParameterLogResponseBodyItemsParameterChangeLog `json:"ParameterChangeLog,omitempty" xml:"ParameterChangeLog,omitempty" type:"Repeated"`
}

func (s DescribeModifyParameterLogResponseBodyItems) String() string {
	return tea.Prettify(s)
}

func (s DescribeModifyParameterLogResponseBodyItems) GoString() string {
	return s.String()
}

func (s *DescribeModifyParameterLogResponseBodyItems) SetParameterChangeLog(v []*DescribeModifyParameterLogResponseBodyItemsParameterChangeLog) *DescribeModifyParameterLogResponseBodyItems {
	s.ParameterChangeLog = v
	return s
}

type DescribeModifyParameterLogResponseBodyItemsParameterChangeLog struct {
	// The time when the parameter was modified. This value is a UNIX timestamp. Unit: milliseconds.
	ModifyTime *string `json:"ModifyTime,omitempty" xml:"ModifyTime,omitempty"`
	// The new value of the parameter.
	NewParameterValue *string `json:"NewParameterValue,omitempty" xml:"NewParameterValue,omitempty"`
	// The original value of the parameter.
	OldParameterValue *string `json:"OldParameterValue,omitempty" xml:"OldParameterValue,omitempty"`
	// The name of the parameter.
	ParameterName *string `json:"ParameterName,omitempty" xml:"ParameterName,omitempty"`
	// The status of the new value specified for the parameter. Valid values:
	//
	// *   **Applied:** The new value has taken effect.
	// *   **Syncing:** The new value is being applied and has not taken effect.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeModifyParameterLogResponseBodyItemsParameterChangeLog) String() string {
	return tea.Prettify(s)
}

func (s DescribeModifyParameterLogResponseBodyItemsParameterChangeLog) GoString() string {
	return s.String()
}

func (s *DescribeModifyParameterLogResponseBodyItemsParameterChangeLog) SetModifyTime(v string) *DescribeModifyParameterLogResponseBodyItemsParameterChangeLog {
	s.ModifyTime = &v
	return s
}

func (s *DescribeModifyParameterLogResponseBodyItemsParameterChangeLog) SetNewParameterValue(v string) *DescribeModifyParameterLogResponseBodyItemsParameterChangeLog {
	s.NewParameterValue = &v
	return s
}

func (s *DescribeModifyParameterLogResponseBodyItemsParameterChangeLog) SetOldParameterValue(v string) *DescribeModifyParameterLogResponseBodyItemsParameterChangeLog {
	s.OldParameterValue = &v
	return s
}

func (s *DescribeModifyParameterLogResponseBodyItemsParameterChangeLog) SetParameterName(v string) *DescribeModifyParameterLogResponseBodyItemsParameterChangeLog {
	s.ParameterName = &v
	return s
}

func (s *DescribeModifyParameterLogResponseBodyItemsParameterChangeLog) SetStatus(v string) *DescribeModifyParameterLogResponseBodyItemsParameterChangeLog {
	s.Status = &v
	return s
}

type DescribeModifyParameterLogResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeModifyParameterLogResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeModifyParameterLogResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeModifyParameterLogResponse) GoString() string {
	return s.String()
}

func (s *DescribeModifyParameterLogResponse) SetHeaders(v map[string]*string) *DescribeModifyParameterLogResponse {
	s.Headers = v
	return s
}

func (s *DescribeModifyParameterLogResponse) SetStatusCode(v int32) *DescribeModifyParameterLogResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeModifyParameterLogResponse) SetBody(v *DescribeModifyParameterLogResponseBody) *DescribeModifyParameterLogResponse {
	s.Body = v
	return s
}

type DescribeOssDownloadsRequest struct {
	// The instance ID. You can call the [DescribeDBInstances](~~26232~~) operation to query the instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The ID of the migration task. You can call the [DescribeMigrateTasks](~~64563~~) operation to query the ID of the migration task.
	MigrateTaskId *string `json:"MigrateTaskId,omitempty" xml:"MigrateTaskId,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeOssDownloadsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeOssDownloadsRequest) GoString() string {
	return s.String()
}

func (s *DescribeOssDownloadsRequest) SetDBInstanceId(v string) *DescribeOssDownloadsRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeOssDownloadsRequest) SetMigrateTaskId(v string) *DescribeOssDownloadsRequest {
	s.MigrateTaskId = &v
	return s
}

func (s *DescribeOssDownloadsRequest) SetOwnerId(v int64) *DescribeOssDownloadsRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeOssDownloadsRequest) SetResourceGroupId(v string) *DescribeOssDownloadsRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeOssDownloadsRequest) SetResourceOwnerAccount(v string) *DescribeOssDownloadsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeOssDownloadsRequest) SetResourceOwnerId(v int64) *DescribeOssDownloadsRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeOssDownloadsResponseBody struct {
	// The instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// Details of the backup file.
	Items *DescribeOssDownloadsResponseBodyItems `json:"Items,omitempty" xml:"Items,omitempty" type:"Struct"`
	// The ID of the migration task.
	MigrateTaskId *string `json:"MigrateTaskId,omitempty" xml:"MigrateTaskId,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeOssDownloadsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeOssDownloadsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeOssDownloadsResponseBody) SetDBInstanceId(v string) *DescribeOssDownloadsResponseBody {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeOssDownloadsResponseBody) SetItems(v *DescribeOssDownloadsResponseBodyItems) *DescribeOssDownloadsResponseBody {
	s.Items = v
	return s
}

func (s *DescribeOssDownloadsResponseBody) SetMigrateTaskId(v string) *DescribeOssDownloadsResponseBody {
	s.MigrateTaskId = &v
	return s
}

func (s *DescribeOssDownloadsResponseBody) SetRequestId(v string) *DescribeOssDownloadsResponseBody {
	s.RequestId = &v
	return s
}

type DescribeOssDownloadsResponseBodyItems struct {
	OssDownload []*DescribeOssDownloadsResponseBodyItemsOssDownload `json:"OssDownload,omitempty" xml:"OssDownload,omitempty" type:"Repeated"`
}

func (s DescribeOssDownloadsResponseBodyItems) String() string {
	return tea.Prettify(s)
}

func (s DescribeOssDownloadsResponseBodyItems) GoString() string {
	return s.String()
}

func (s *DescribeOssDownloadsResponseBodyItems) SetOssDownload(v []*DescribeOssDownloadsResponseBodyItemsOssDownload) *DescribeOssDownloadsResponseBodyItems {
	s.OssDownload = v
	return s
}

type DescribeOssDownloadsResponseBodyItemsOssDownload struct {
	// The backup type. Valid values:
	//
	// *   **Database**: full backup file
	// *   **Differential_Database**: incremental backup file
	// *   **Transaction_Log**: log backup file
	BackupMode *string `json:"BackupMode,omitempty" xml:"BackupMode,omitempty"`
	// The time when the backup file was created in the download list. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The description of the backup file.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The end of the time range during which data was queried. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The name of the backup file stored in the Object Storage Service (OSS) bucket.
	FileName *string `json:"FileName,omitempty" xml:"FileName,omitempty"`
	// The size of the backup file. Unit: MB
	FileSize *string `json:"FileSize,omitempty" xml:"FileSize,omitempty"`
	// Indicates whether the backup file is available. Valid values: **True and False**.
	IsAvailable *string `json:"IsAvailable,omitempty" xml:"IsAvailable,omitempty"`
	// The state of the backup file. Valid values:
	//
	// *   **NoStart**
	// *   **Downloading**
	// *   **Finished**
	// *   **DownloadFailed**
	// *   **VerifyFailed**
	// *   **Deleted**
	// *   **DeleteFailed**
	// *   **CheckSuccess**
	// *   **CheckFailed**
	// *   **Restoring**
	// *   **Restored**
	// *   **RestoreFailed**
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeOssDownloadsResponseBodyItemsOssDownload) String() string {
	return tea.Prettify(s)
}

func (s DescribeOssDownloadsResponseBodyItemsOssDownload) GoString() string {
	return s.String()
}

func (s *DescribeOssDownloadsResponseBodyItemsOssDownload) SetBackupMode(v string) *DescribeOssDownloadsResponseBodyItemsOssDownload {
	s.BackupMode = &v
	return s
}

func (s *DescribeOssDownloadsResponseBodyItemsOssDownload) SetCreateTime(v string) *DescribeOssDownloadsResponseBodyItemsOssDownload {
	s.CreateTime = &v
	return s
}

func (s *DescribeOssDownloadsResponseBodyItemsOssDownload) SetDescription(v string) *DescribeOssDownloadsResponseBodyItemsOssDownload {
	s.Description = &v
	return s
}

func (s *DescribeOssDownloadsResponseBodyItemsOssDownload) SetEndTime(v string) *DescribeOssDownloadsResponseBodyItemsOssDownload {
	s.EndTime = &v
	return s
}

func (s *DescribeOssDownloadsResponseBodyItemsOssDownload) SetFileName(v string) *DescribeOssDownloadsResponseBodyItemsOssDownload {
	s.FileName = &v
	return s
}

func (s *DescribeOssDownloadsResponseBodyItemsOssDownload) SetFileSize(v string) *DescribeOssDownloadsResponseBodyItemsOssDownload {
	s.FileSize = &v
	return s
}

func (s *DescribeOssDownloadsResponseBodyItemsOssDownload) SetIsAvailable(v string) *DescribeOssDownloadsResponseBodyItemsOssDownload {
	s.IsAvailable = &v
	return s
}

func (s *DescribeOssDownloadsResponseBodyItemsOssDownload) SetStatus(v string) *DescribeOssDownloadsResponseBodyItemsOssDownload {
	s.Status = &v
	return s
}

type DescribeOssDownloadsResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeOssDownloadsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeOssDownloadsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeOssDownloadsResponse) GoString() string {
	return s.String()
}

func (s *DescribeOssDownloadsResponse) SetHeaders(v map[string]*string) *DescribeOssDownloadsResponse {
	s.Headers = v
	return s
}

func (s *DescribeOssDownloadsResponse) SetStatusCode(v int32) *DescribeOssDownloadsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeOssDownloadsResponse) SetBody(v *DescribeOssDownloadsResponseBody) *DescribeOssDownloadsResponse {
	s.Body = v
	return s
}

type DescribePGHbaConfigRequest struct {
	// A reserved parameter. You do not need to specify this parameter.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The instance ID. You can call the [DescribeDBInstances](~~610396~~) operation to query the ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribePGHbaConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribePGHbaConfigRequest) GoString() string {
	return s.String()
}

func (s *DescribePGHbaConfigRequest) SetClientToken(v string) *DescribePGHbaConfigRequest {
	s.ClientToken = &v
	return s
}

func (s *DescribePGHbaConfigRequest) SetDBInstanceId(v string) *DescribePGHbaConfigRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DescribePGHbaConfigRequest) SetOwnerAccount(v string) *DescribePGHbaConfigRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribePGHbaConfigRequest) SetOwnerId(v int64) *DescribePGHbaConfigRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribePGHbaConfigRequest) SetResourceGroupId(v string) *DescribePGHbaConfigRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribePGHbaConfigRequest) SetResourceOwnerAccount(v string) *DescribePGHbaConfigRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribePGHbaConfigRequest) SetResourceOwnerId(v int64) *DescribePGHbaConfigRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribePGHbaConfigResponseBody struct {
	// The instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The default configuration items of the pg_hba.conf file.
	DefaultHbaItems *DescribePGHbaConfigResponseBodyDefaultHbaItems `json:"DefaultHbaItems,omitempty" xml:"DefaultHbaItems,omitempty" type:"Struct"`
	// The time when the previous modification was made to the pg_hba.conf file.
	HbaModifyTime *string `json:"HbaModifyTime,omitempty" xml:"HbaModifyTime,omitempty"`
	// The status of the previous modification to the pg_hba.conf file. Valid values:
	//
	// *   **success**
	// *   **setting**
	// *   **failed**
	LastModifyStatus *string `json:"LastModifyStatus,omitempty" xml:"LastModifyStatus,omitempty"`
	// The reason why the previous modification was made to the pg_hba.conf file.
	ModifyStatusReason *string `json:"ModifyStatusReason,omitempty" xml:"ModifyStatusReason,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The current configuration items of the pg_hba.conf file.
	RunningHbaItems *DescribePGHbaConfigResponseBodyRunningHbaItems `json:"RunningHbaItems,omitempty" xml:"RunningHbaItems,omitempty" type:"Struct"`
}

func (s DescribePGHbaConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribePGHbaConfigResponseBody) GoString() string {
	return s.String()
}

func (s *DescribePGHbaConfigResponseBody) SetDBInstanceId(v string) *DescribePGHbaConfigResponseBody {
	s.DBInstanceId = &v
	return s
}

func (s *DescribePGHbaConfigResponseBody) SetDefaultHbaItems(v *DescribePGHbaConfigResponseBodyDefaultHbaItems) *DescribePGHbaConfigResponseBody {
	s.DefaultHbaItems = v
	return s
}

func (s *DescribePGHbaConfigResponseBody) SetHbaModifyTime(v string) *DescribePGHbaConfigResponseBody {
	s.HbaModifyTime = &v
	return s
}

func (s *DescribePGHbaConfigResponseBody) SetLastModifyStatus(v string) *DescribePGHbaConfigResponseBody {
	s.LastModifyStatus = &v
	return s
}

func (s *DescribePGHbaConfigResponseBody) SetModifyStatusReason(v string) *DescribePGHbaConfigResponseBody {
	s.ModifyStatusReason = &v
	return s
}

func (s *DescribePGHbaConfigResponseBody) SetRequestId(v string) *DescribePGHbaConfigResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribePGHbaConfigResponseBody) SetRunningHbaItems(v *DescribePGHbaConfigResponseBodyRunningHbaItems) *DescribePGHbaConfigResponseBody {
	s.RunningHbaItems = v
	return s
}

type DescribePGHbaConfigResponseBodyDefaultHbaItems struct {
	HbaItem []*DescribePGHbaConfigResponseBodyDefaultHbaItemsHbaItem `json:"HbaItem,omitempty" xml:"HbaItem,omitempty" type:"Repeated"`
}

func (s DescribePGHbaConfigResponseBodyDefaultHbaItems) String() string {
	return tea.Prettify(s)
}

func (s DescribePGHbaConfigResponseBodyDefaultHbaItems) GoString() string {
	return s.String()
}

func (s *DescribePGHbaConfigResponseBodyDefaultHbaItems) SetHbaItem(v []*DescribePGHbaConfigResponseBodyDefaultHbaItemsHbaItem) *DescribePGHbaConfigResponseBodyDefaultHbaItems {
	s.HbaItem = v
	return s
}

type DescribePGHbaConfigResponseBodyDefaultHbaItemsHbaItem struct {
	// The IP addresses from which the specified users can access the specified databases. The value is fixed as 0.0.0.0/0.
	Address *string `json:"Address,omitempty" xml:"Address,omitempty"`
	// The names of the databases that the specified users are allowed to access. The value is fixed as all or replication.
	Database *string `json:"Database,omitempty" xml:"Database,omitempty"`
	// The mask of the instance. The value is fixed as null.
	Mask *string `json:"Mask,omitempty" xml:"Mask,omitempty"`
	// The authentication method. The value is fixed as md5.
	Method *string `json:"Method,omitempty" xml:"Method,omitempty"`
	// The value of this parameter is based on the value of the Method parameter. The value is fixed as null.
	Option *string `json:"Option,omitempty" xml:"Option,omitempty"`
	// The priority of the configuration items in the pg_hba.conf file. This value is automatically generated.
	PriorityId *int32 `json:"PriorityId,omitempty" xml:"PriorityId,omitempty"`
	// The type of connection to the instance. The value is fixed as host.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The user that is allowed to access the instance. The value is fixed as all.
	User *string `json:"User,omitempty" xml:"User,omitempty"`
}

func (s DescribePGHbaConfigResponseBodyDefaultHbaItemsHbaItem) String() string {
	return tea.Prettify(s)
}

func (s DescribePGHbaConfigResponseBodyDefaultHbaItemsHbaItem) GoString() string {
	return s.String()
}

func (s *DescribePGHbaConfigResponseBodyDefaultHbaItemsHbaItem) SetAddress(v string) *DescribePGHbaConfigResponseBodyDefaultHbaItemsHbaItem {
	s.Address = &v
	return s
}

func (s *DescribePGHbaConfigResponseBodyDefaultHbaItemsHbaItem) SetDatabase(v string) *DescribePGHbaConfigResponseBodyDefaultHbaItemsHbaItem {
	s.Database = &v
	return s
}

func (s *DescribePGHbaConfigResponseBodyDefaultHbaItemsHbaItem) SetMask(v string) *DescribePGHbaConfigResponseBodyDefaultHbaItemsHbaItem {
	s.Mask = &v
	return s
}

func (s *DescribePGHbaConfigResponseBodyDefaultHbaItemsHbaItem) SetMethod(v string) *DescribePGHbaConfigResponseBodyDefaultHbaItemsHbaItem {
	s.Method = &v
	return s
}

func (s *DescribePGHbaConfigResponseBodyDefaultHbaItemsHbaItem) SetOption(v string) *DescribePGHbaConfigResponseBodyDefaultHbaItemsHbaItem {
	s.Option = &v
	return s
}

func (s *DescribePGHbaConfigResponseBodyDefaultHbaItemsHbaItem) SetPriorityId(v int32) *DescribePGHbaConfigResponseBodyDefaultHbaItemsHbaItem {
	s.PriorityId = &v
	return s
}

func (s *DescribePGHbaConfigResponseBodyDefaultHbaItemsHbaItem) SetType(v string) *DescribePGHbaConfigResponseBodyDefaultHbaItemsHbaItem {
	s.Type = &v
	return s
}

func (s *DescribePGHbaConfigResponseBodyDefaultHbaItemsHbaItem) SetUser(v string) *DescribePGHbaConfigResponseBodyDefaultHbaItemsHbaItem {
	s.User = &v
	return s
}

type DescribePGHbaConfigResponseBodyRunningHbaItems struct {
	HbaItem []*DescribePGHbaConfigResponseBodyRunningHbaItemsHbaItem `json:"HbaItem,omitempty" xml:"HbaItem,omitempty" type:"Repeated"`
}

func (s DescribePGHbaConfigResponseBodyRunningHbaItems) String() string {
	return tea.Prettify(s)
}

func (s DescribePGHbaConfigResponseBodyRunningHbaItems) GoString() string {
	return s.String()
}

func (s *DescribePGHbaConfigResponseBodyRunningHbaItems) SetHbaItem(v []*DescribePGHbaConfigResponseBodyRunningHbaItemsHbaItem) *DescribePGHbaConfigResponseBodyRunningHbaItems {
	s.HbaItem = v
	return s
}

type DescribePGHbaConfigResponseBodyRunningHbaItemsHbaItem struct {
	// The IP address of the client.
	Address *string `json:"Address,omitempty" xml:"Address,omitempty"`
	// The name of the database.
	Database *string `json:"Database,omitempty" xml:"Database,omitempty"`
	// The mask of the IP address.
	Mask *string `json:"Mask,omitempty" xml:"Mask,omitempty"`
	// The authentication method.
	Method *string `json:"Method,omitempty" xml:"Method,omitempty"`
	// The value of this parameter varies based on the value of the Method parameter. The value is fixed as null.
	Option *string `json:"Option,omitempty" xml:"Option,omitempty"`
	// The priority.
	PriorityId *int32 `json:"PriorityId,omitempty" xml:"PriorityId,omitempty"`
	// The connection type. Valor:
	//
	// *   **host**: The record matches TCP/IP connections, including SSL connections and non-SSL connections.
	// *   **hostssl**: The record matches only TCP/IP connections that are established over SSL.
	// *   **hostnossl**: The record matches only TCP/IP connections that are not established over SSL connections.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The username of the account.
	User *string `json:"User,omitempty" xml:"User,omitempty"`
}

func (s DescribePGHbaConfigResponseBodyRunningHbaItemsHbaItem) String() string {
	return tea.Prettify(s)
}

func (s DescribePGHbaConfigResponseBodyRunningHbaItemsHbaItem) GoString() string {
	return s.String()
}

func (s *DescribePGHbaConfigResponseBodyRunningHbaItemsHbaItem) SetAddress(v string) *DescribePGHbaConfigResponseBodyRunningHbaItemsHbaItem {
	s.Address = &v
	return s
}

func (s *DescribePGHbaConfigResponseBodyRunningHbaItemsHbaItem) SetDatabase(v string) *DescribePGHbaConfigResponseBodyRunningHbaItemsHbaItem {
	s.Database = &v
	return s
}

func (s *DescribePGHbaConfigResponseBodyRunningHbaItemsHbaItem) SetMask(v string) *DescribePGHbaConfigResponseBodyRunningHbaItemsHbaItem {
	s.Mask = &v
	return s
}

func (s *DescribePGHbaConfigResponseBodyRunningHbaItemsHbaItem) SetMethod(v string) *DescribePGHbaConfigResponseBodyRunningHbaItemsHbaItem {
	s.Method = &v
	return s
}

func (s *DescribePGHbaConfigResponseBodyRunningHbaItemsHbaItem) SetOption(v string) *DescribePGHbaConfigResponseBodyRunningHbaItemsHbaItem {
	s.Option = &v
	return s
}

func (s *DescribePGHbaConfigResponseBodyRunningHbaItemsHbaItem) SetPriorityId(v int32) *DescribePGHbaConfigResponseBodyRunningHbaItemsHbaItem {
	s.PriorityId = &v
	return s
}

func (s *DescribePGHbaConfigResponseBodyRunningHbaItemsHbaItem) SetType(v string) *DescribePGHbaConfigResponseBodyRunningHbaItemsHbaItem {
	s.Type = &v
	return s
}

func (s *DescribePGHbaConfigResponseBodyRunningHbaItemsHbaItem) SetUser(v string) *DescribePGHbaConfigResponseBodyRunningHbaItemsHbaItem {
	s.User = &v
	return s
}

type DescribePGHbaConfigResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribePGHbaConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribePGHbaConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribePGHbaConfigResponse) GoString() string {
	return s.String()
}

func (s *DescribePGHbaConfigResponse) SetHeaders(v map[string]*string) *DescribePGHbaConfigResponse {
	s.Headers = v
	return s
}

func (s *DescribePGHbaConfigResponse) SetStatusCode(v int32) *DescribePGHbaConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribePGHbaConfigResponse) SetBody(v *DescribePGHbaConfigResponseBody) *DescribePGHbaConfigResponse {
	s.Body = v
	return s
}

type DescribeParameterGroupRequest struct {
	OwnerId *int64 `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the parameter template. You can call the [DescribeParameterGroups](~~144491~~) operation to query the parameter template ID.
	ParameterGroupId *string `json:"ParameterGroupId,omitempty" xml:"ParameterGroupId,omitempty"`
	// The region ID. You can call the [DescribeRegions](~~26243~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeParameterGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeParameterGroupRequest) GoString() string {
	return s.String()
}

func (s *DescribeParameterGroupRequest) SetOwnerId(v int64) *DescribeParameterGroupRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeParameterGroupRequest) SetParameterGroupId(v string) *DescribeParameterGroupRequest {
	s.ParameterGroupId = &v
	return s
}

func (s *DescribeParameterGroupRequest) SetRegionId(v string) *DescribeParameterGroupRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeParameterGroupRequest) SetResourceOwnerAccount(v string) *DescribeParameterGroupRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeParameterGroupRequest) SetResourceOwnerId(v int64) *DescribeParameterGroupRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeParameterGroupResponseBody struct {
	// The information about the parameter template.
	ParamGroup *DescribeParameterGroupResponseBodyParamGroup `json:"ParamGroup,omitempty" xml:"ParamGroup,omitempty" type:"Struct"`
	// The information about the instance to which the parameter template is applied.
	//
	// >  This parameter is available only for ApsaraDB RDS for PostgreSQL instances.
	RelatedCustinsInfo *DescribeParameterGroupResponseBodyRelatedCustinsInfo `json:"RelatedCustinsInfo,omitempty" xml:"RelatedCustinsInfo,omitempty" type:"Struct"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeParameterGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeParameterGroupResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeParameterGroupResponseBody) SetParamGroup(v *DescribeParameterGroupResponseBodyParamGroup) *DescribeParameterGroupResponseBody {
	s.ParamGroup = v
	return s
}

func (s *DescribeParameterGroupResponseBody) SetRelatedCustinsInfo(v *DescribeParameterGroupResponseBodyRelatedCustinsInfo) *DescribeParameterGroupResponseBody {
	s.RelatedCustinsInfo = v
	return s
}

func (s *DescribeParameterGroupResponseBody) SetRequestId(v string) *DescribeParameterGroupResponseBody {
	s.RequestId = &v
	return s
}

type DescribeParameterGroupResponseBodyParamGroup struct {
	ParameterGroup []*DescribeParameterGroupResponseBodyParamGroupParameterGroup `json:"ParameterGroup,omitempty" xml:"ParameterGroup,omitempty" type:"Repeated"`
}

func (s DescribeParameterGroupResponseBodyParamGroup) String() string {
	return tea.Prettify(s)
}

func (s DescribeParameterGroupResponseBodyParamGroup) GoString() string {
	return s.String()
}

func (s *DescribeParameterGroupResponseBodyParamGroup) SetParameterGroup(v []*DescribeParameterGroupResponseBodyParamGroupParameterGroup) *DescribeParameterGroupResponseBodyParamGroup {
	s.ParameterGroup = v
	return s
}

type DescribeParameterGroupResponseBodyParamGroupParameterGroup struct {
	// The time when the parameter template was created.
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The database engine of the instance.
	Engine *string `json:"Engine,omitempty" xml:"Engine,omitempty"`
	// The database engine version of the instance.
	EngineVersion *string `json:"EngineVersion,omitempty" xml:"EngineVersion,omitempty"`
	// Indicates whether the restart of an instance is required for the parameter template to take effect. Valid values:
	//
	// *   **0**: A restart is not required.
	// *   **1**: A restart is required.
	ForceRestart *int32 `json:"ForceRestart,omitempty" xml:"ForceRestart,omitempty"`
	// The number of parameters in the parameter template.
	ParamCounts *int32 `json:"ParamCounts,omitempty" xml:"ParamCounts,omitempty"`
	// The details of the parameters.
	ParamDetail *DescribeParameterGroupResponseBodyParamGroupParameterGroupParamDetail `json:"ParamDetail,omitempty" xml:"ParamDetail,omitempty" type:"Struct"`
	// The description of the parameter template.
	ParameterGroupDesc *string `json:"ParameterGroupDesc,omitempty" xml:"ParameterGroupDesc,omitempty"`
	// The ID of the parameter template.
	ParameterGroupId *string `json:"ParameterGroupId,omitempty" xml:"ParameterGroupId,omitempty"`
	// The name of the parameter template.
	ParameterGroupName *string `json:"ParameterGroupName,omitempty" xml:"ParameterGroupName,omitempty"`
	// The type of the parameter template. Valid values:
	//
	// *   **0**: the default parameter template.
	// *   **1**: a custom parameter template.
	// *   **2**: an automatic backup parameter template. After you apply this type of template, the system automatically backs up the original parameter settings and saves the backup as a template.
	ParameterGroupType *int32 `json:"ParameterGroupType,omitempty" xml:"ParameterGroupType,omitempty"`
	// The time when the parameter template was last updated. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	UpdateTime *string `json:"UpdateTime,omitempty" xml:"UpdateTime,omitempty"`
}

func (s DescribeParameterGroupResponseBodyParamGroupParameterGroup) String() string {
	return tea.Prettify(s)
}

func (s DescribeParameterGroupResponseBodyParamGroupParameterGroup) GoString() string {
	return s.String()
}

func (s *DescribeParameterGroupResponseBodyParamGroupParameterGroup) SetCreateTime(v string) *DescribeParameterGroupResponseBodyParamGroupParameterGroup {
	s.CreateTime = &v
	return s
}

func (s *DescribeParameterGroupResponseBodyParamGroupParameterGroup) SetEngine(v string) *DescribeParameterGroupResponseBodyParamGroupParameterGroup {
	s.Engine = &v
	return s
}

func (s *DescribeParameterGroupResponseBodyParamGroupParameterGroup) SetEngineVersion(v string) *DescribeParameterGroupResponseBodyParamGroupParameterGroup {
	s.EngineVersion = &v
	return s
}

func (s *DescribeParameterGroupResponseBodyParamGroupParameterGroup) SetForceRestart(v int32) *DescribeParameterGroupResponseBodyParamGroupParameterGroup {
	s.ForceRestart = &v
	return s
}

func (s *DescribeParameterGroupResponseBodyParamGroupParameterGroup) SetParamCounts(v int32) *DescribeParameterGroupResponseBodyParamGroupParameterGroup {
	s.ParamCounts = &v
	return s
}

func (s *DescribeParameterGroupResponseBodyParamGroupParameterGroup) SetParamDetail(v *DescribeParameterGroupResponseBodyParamGroupParameterGroupParamDetail) *DescribeParameterGroupResponseBodyParamGroupParameterGroup {
	s.ParamDetail = v
	return s
}

func (s *DescribeParameterGroupResponseBodyParamGroupParameterGroup) SetParameterGroupDesc(v string) *DescribeParameterGroupResponseBodyParamGroupParameterGroup {
	s.ParameterGroupDesc = &v
	return s
}

func (s *DescribeParameterGroupResponseBodyParamGroupParameterGroup) SetParameterGroupId(v string) *DescribeParameterGroupResponseBodyParamGroupParameterGroup {
	s.ParameterGroupId = &v
	return s
}

func (s *DescribeParameterGroupResponseBodyParamGroupParameterGroup) SetParameterGroupName(v string) *DescribeParameterGroupResponseBodyParamGroupParameterGroup {
	s.ParameterGroupName = &v
	return s
}

func (s *DescribeParameterGroupResponseBodyParamGroupParameterGroup) SetParameterGroupType(v int32) *DescribeParameterGroupResponseBodyParamGroupParameterGroup {
	s.ParameterGroupType = &v
	return s
}

func (s *DescribeParameterGroupResponseBodyParamGroupParameterGroup) SetUpdateTime(v string) *DescribeParameterGroupResponseBodyParamGroupParameterGroup {
	s.UpdateTime = &v
	return s
}

type DescribeParameterGroupResponseBodyParamGroupParameterGroupParamDetail struct {
	ParameterDetail []*DescribeParameterGroupResponseBodyParamGroupParameterGroupParamDetailParameterDetail `json:"ParameterDetail,omitempty" xml:"ParameterDetail,omitempty" type:"Repeated"`
}

func (s DescribeParameterGroupResponseBodyParamGroupParameterGroupParamDetail) String() string {
	return tea.Prettify(s)
}

func (s DescribeParameterGroupResponseBodyParamGroupParameterGroupParamDetail) GoString() string {
	return s.String()
}

func (s *DescribeParameterGroupResponseBodyParamGroupParameterGroupParamDetail) SetParameterDetail(v []*DescribeParameterGroupResponseBodyParamGroupParameterGroupParamDetailParameterDetail) *DescribeParameterGroupResponseBodyParamGroupParameterGroupParamDetail {
	s.ParameterDetail = v
	return s
}

type DescribeParameterGroupResponseBodyParamGroupParameterGroupParamDetailParameterDetail struct {
	// The name of the parameter.
	ParamName *string `json:"ParamName,omitempty" xml:"ParamName,omitempty"`
	// The value of the parameter.
	ParamValue *string `json:"ParamValue,omitempty" xml:"ParamValue,omitempty"`
}

func (s DescribeParameterGroupResponseBodyParamGroupParameterGroupParamDetailParameterDetail) String() string {
	return tea.Prettify(s)
}

func (s DescribeParameterGroupResponseBodyParamGroupParameterGroupParamDetailParameterDetail) GoString() string {
	return s.String()
}

func (s *DescribeParameterGroupResponseBodyParamGroupParameterGroupParamDetailParameterDetail) SetParamName(v string) *DescribeParameterGroupResponseBodyParamGroupParameterGroupParamDetailParameterDetail {
	s.ParamName = &v
	return s
}

func (s *DescribeParameterGroupResponseBodyParamGroupParameterGroupParamDetailParameterDetail) SetParamValue(v string) *DescribeParameterGroupResponseBodyParamGroupParameterGroupParamDetailParameterDetail {
	s.ParamValue = &v
	return s
}

type DescribeParameterGroupResponseBodyRelatedCustinsInfo struct {
	RelatedCustinsInfo []*DescribeParameterGroupResponseBodyRelatedCustinsInfoRelatedCustinsInfo `json:"RelatedCustinsInfo,omitempty" xml:"RelatedCustinsInfo,omitempty" type:"Repeated"`
}

func (s DescribeParameterGroupResponseBodyRelatedCustinsInfo) String() string {
	return tea.Prettify(s)
}

func (s DescribeParameterGroupResponseBodyRelatedCustinsInfo) GoString() string {
	return s.String()
}

func (s *DescribeParameterGroupResponseBodyRelatedCustinsInfo) SetRelatedCustinsInfo(v []*DescribeParameterGroupResponseBodyRelatedCustinsInfoRelatedCustinsInfo) *DescribeParameterGroupResponseBodyRelatedCustinsInfo {
	s.RelatedCustinsInfo = v
	return s
}

type DescribeParameterGroupResponseBodyRelatedCustinsInfoRelatedCustinsInfo struct {
	// The time when the parameter template was applied.
	AppliedTime *string `json:"AppliedTime,omitempty" xml:"AppliedTime,omitempty"`
	// The instance ID.
	DBInstanceName *string `json:"DBInstanceName,omitempty" xml:"DBInstanceName,omitempty"`
}

func (s DescribeParameterGroupResponseBodyRelatedCustinsInfoRelatedCustinsInfo) String() string {
	return tea.Prettify(s)
}

func (s DescribeParameterGroupResponseBodyRelatedCustinsInfoRelatedCustinsInfo) GoString() string {
	return s.String()
}

func (s *DescribeParameterGroupResponseBodyRelatedCustinsInfoRelatedCustinsInfo) SetAppliedTime(v string) *DescribeParameterGroupResponseBodyRelatedCustinsInfoRelatedCustinsInfo {
	s.AppliedTime = &v
	return s
}

func (s *DescribeParameterGroupResponseBodyRelatedCustinsInfoRelatedCustinsInfo) SetDBInstanceName(v string) *DescribeParameterGroupResponseBodyRelatedCustinsInfoRelatedCustinsInfo {
	s.DBInstanceName = &v
	return s
}

type DescribeParameterGroupResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeParameterGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeParameterGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeParameterGroupResponse) GoString() string {
	return s.String()
}

func (s *DescribeParameterGroupResponse) SetHeaders(v map[string]*string) *DescribeParameterGroupResponse {
	s.Headers = v
	return s
}

func (s *DescribeParameterGroupResponse) SetStatusCode(v int32) *DescribeParameterGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeParameterGroupResponse) SetBody(v *DescribeParameterGroupResponseBody) *DescribeParameterGroupResponse {
	s.Body = v
	return s
}

type DescribeParameterGroupsRequest struct {
	OwnerId *int64 `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the instance. You can call the [DescribeRegions](~~26243~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeParameterGroupsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeParameterGroupsRequest) GoString() string {
	return s.String()
}

func (s *DescribeParameterGroupsRequest) SetOwnerId(v int64) *DescribeParameterGroupsRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeParameterGroupsRequest) SetRegionId(v string) *DescribeParameterGroupsRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeParameterGroupsRequest) SetResourceGroupId(v string) *DescribeParameterGroupsRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeParameterGroupsRequest) SetResourceOwnerAccount(v string) *DescribeParameterGroupsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeParameterGroupsRequest) SetResourceOwnerId(v int64) *DescribeParameterGroupsRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeParameterGroupsResponseBody struct {
	// The details of the parameter templates.
	ParameterGroups *DescribeParameterGroupsResponseBodyParameterGroups `json:"ParameterGroups,omitempty" xml:"ParameterGroups,omitempty" type:"Struct"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether parameter templates exist in the specified region. Valid values:
	// *   true
	// *   false
	// ><notice>This parameter is deprecated.></notice>
	SignalForOptimizeParams *bool `json:"SignalForOptimizeParams,omitempty" xml:"SignalForOptimizeParams,omitempty"`
}

func (s DescribeParameterGroupsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeParameterGroupsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeParameterGroupsResponseBody) SetParameterGroups(v *DescribeParameterGroupsResponseBodyParameterGroups) *DescribeParameterGroupsResponseBody {
	s.ParameterGroups = v
	return s
}

func (s *DescribeParameterGroupsResponseBody) SetRequestId(v string) *DescribeParameterGroupsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeParameterGroupsResponseBody) SetSignalForOptimizeParams(v bool) *DescribeParameterGroupsResponseBody {
	s.SignalForOptimizeParams = &v
	return s
}

type DescribeParameterGroupsResponseBodyParameterGroups struct {
	ParameterGroup []*DescribeParameterGroupsResponseBodyParameterGroupsParameterGroup `json:"ParameterGroup,omitempty" xml:"ParameterGroup,omitempty" type:"Repeated"`
}

func (s DescribeParameterGroupsResponseBodyParameterGroups) String() string {
	return tea.Prettify(s)
}

func (s DescribeParameterGroupsResponseBodyParameterGroups) GoString() string {
	return s.String()
}

func (s *DescribeParameterGroupsResponseBodyParameterGroups) SetParameterGroup(v []*DescribeParameterGroupsResponseBodyParameterGroupsParameterGroup) *DescribeParameterGroupsResponseBodyParameterGroups {
	s.ParameterGroup = v
	return s
}

type DescribeParameterGroupsResponseBodyParameterGroupsParameterGroup struct {
	// The time when the parameter template was created. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The database engine of the instance.
	Engine *string `json:"Engine,omitempty" xml:"Engine,omitempty"`
	// The database engine version.
	EngineVersion *string `json:"EngineVersion,omitempty" xml:"EngineVersion,omitempty"`
	// Indicates whether the restart of an instance is required for the parameter template to take effect. Valid values:
	//
	// *   0: A restart is not required.
	// *   1: A restart is required.
	ForceRestart *int32 `json:"ForceRestart,omitempty" xml:"ForceRestart,omitempty"`
	// The number of parameters in the parameter template.
	ParamCounts *int32 `json:"ParamCounts,omitempty" xml:"ParamCounts,omitempty"`
	// The type of the parameter template. Valid values:
	//
	// *   0: the default parameter template.
	// *   1: a custom parameter template.
	// *   2: an automatic backup parameter template. After you apply this type of template, the system automatically backs up the original parameter settings and saves the backup as a template.
	ParameterGroupDesc *string `json:"ParameterGroupDesc,omitempty" xml:"ParameterGroupDesc,omitempty"`
	// The ID of the parameter template.
	ParameterGroupId *string `json:"ParameterGroupId,omitempty" xml:"ParameterGroupId,omitempty"`
	// The name of the parameter template.
	ParameterGroupName *string `json:"ParameterGroupName,omitempty" xml:"ParameterGroupName,omitempty"`
	// The type of the parameter template. Valid values:
	//
	// *   0: the default parameter template.
	// *   1: a custom parameter template.
	// *   2: an automatic backup parameter template. After you apply this type of template, the system automatically backs up the original parameter settings and saves the backup as a template.
	ParameterGroupType *int32 `json:"ParameterGroupType,omitempty" xml:"ParameterGroupType,omitempty"`
	// The time when the parameter template was last updated. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
	UpdateTime *string `json:"UpdateTime,omitempty" xml:"UpdateTime,omitempty"`
}

func (s DescribeParameterGroupsResponseBodyParameterGroupsParameterGroup) String() string {
	return tea.Prettify(s)
}

func (s DescribeParameterGroupsResponseBodyParameterGroupsParameterGroup) GoString() string {
	return s.String()
}

func (s *DescribeParameterGroupsResponseBodyParameterGroupsParameterGroup) SetCreateTime(v string) *DescribeParameterGroupsResponseBodyParameterGroupsParameterGroup {
	s.CreateTime = &v
	return s
}

func (s *DescribeParameterGroupsResponseBodyParameterGroupsParameterGroup) SetEngine(v string) *DescribeParameterGroupsResponseBodyParameterGroupsParameterGroup {
	s.Engine = &v
	return s
}

func (s *DescribeParameterGroupsResponseBodyParameterGroupsParameterGroup) SetEngineVersion(v string) *DescribeParameterGroupsResponseBodyParameterGroupsParameterGroup {
	s.EngineVersion = &v
	return s
}

func (s *DescribeParameterGroupsResponseBodyParameterGroupsParameterGroup) SetForceRestart(v int32) *DescribeParameterGroupsResponseBodyParameterGroupsParameterGroup {
	s.ForceRestart = &v
	return s
}

func (s *DescribeParameterGroupsResponseBodyParameterGroupsParameterGroup) SetParamCounts(v int32) *DescribeParameterGroupsResponseBodyParameterGroupsParameterGroup {
	s.ParamCounts = &v
	return s
}

func (s *DescribeParameterGroupsResponseBodyParameterGroupsParameterGroup) SetParameterGroupDesc(v string) *DescribeParameterGroupsResponseBodyParameterGroupsParameterGroup {
	s.ParameterGroupDesc = &v
	return s
}

func (s *DescribeParameterGroupsResponseBodyParameterGroupsParameterGroup) SetParameterGroupId(v string) *DescribeParameterGroupsResponseBodyParameterGroupsParameterGroup {
	s.ParameterGroupId = &v
	return s
}

func (s *DescribeParameterGroupsResponseBodyParameterGroupsParameterGroup) SetParameterGroupName(v string) *DescribeParameterGroupsResponseBodyParameterGroupsParameterGroup {
	s.ParameterGroupName = &v
	return s
}

func (s *DescribeParameterGroupsResponseBodyParameterGroupsParameterGroup) SetParameterGroupType(v int32) *DescribeParameterGroupsResponseBodyParameterGroupsParameterGroup {
	s.ParameterGroupType = &v
	return s
}

func (s *DescribeParameterGroupsResponseBodyParameterGroupsParameterGroup) SetUpdateTime(v string) *DescribeParameterGroupsResponseBodyParameterGroupsParameterGroup {
	s.UpdateTime = &v
	return s
}

type DescribeParameterGroupsResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeParameterGroupsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeParameterGroupsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeParameterGroupsResponse) GoString() string {
	return s.String()
}

func (s *DescribeParameterGroupsResponse) SetHeaders(v map[string]*string) *DescribeParameterGroupsResponse {
	s.Headers = v
	return s
}

func (s *DescribeParameterGroupsResponse) SetStatusCode(v int32) *DescribeParameterGroupsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeParameterGroupsResponse) SetBody(v *DescribeParameterGroupsResponseBody) *DescribeParameterGroupsResponse {
	s.Body = v
	return s
}

type DescribeParameterTemplatesRequest struct {
	// The RDS edition of the instance. Valid values:
	//
	// *   **Basic**: RDS Basic Edition
	// *   **HighAvailability**: RDS High-availability Edition
	// *   **Finance**: RDS Enterprise Edition
	Category *string `json:"Category,omitempty" xml:"Category,omitempty"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The database engine of the instance. Valid values:
	//
	// *   **mysql**: MySQL
	// *   **mssql**: SQL Server
	// *   **PostgreSQL**: PostgreSQL
	// *   **MariaDB**: MariaDB
	Engine *string `json:"Engine,omitempty" xml:"Engine,omitempty"`
	// The version of the database engine. Valid values:
	//
	// *   Valid values when you set the Engine parameter to mysql: **5.5, 5.6, 5.7, and 8.0**.
	// *   Valid values when you set the Engine parameter to mssql: **2008r2**.
	// *   Valid values when you set the Engine parameter to PostgreSQL: **10.0, 11.0, 12.0, 13.0, 14.0, and 15.0**.
	// *   Valid values when you set the Engine parameter to MariaDB: **10.3**.
	EngineVersion *string `json:"EngineVersion,omitempty" xml:"EngineVersion,omitempty"`
	OwnerAccount  *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID. You can call the [DescribeRegions](~~26243~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeParameterTemplatesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeParameterTemplatesRequest) GoString() string {
	return s.String()
}

func (s *DescribeParameterTemplatesRequest) SetCategory(v string) *DescribeParameterTemplatesRequest {
	s.Category = &v
	return s
}

func (s *DescribeParameterTemplatesRequest) SetClientToken(v string) *DescribeParameterTemplatesRequest {
	s.ClientToken = &v
	return s
}

func (s *DescribeParameterTemplatesRequest) SetDBInstanceId(v string) *DescribeParameterTemplatesRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeParameterTemplatesRequest) SetEngine(v string) *DescribeParameterTemplatesRequest {
	s.Engine = &v
	return s
}

func (s *DescribeParameterTemplatesRequest) SetEngineVersion(v string) *DescribeParameterTemplatesRequest {
	s.EngineVersion = &v
	return s
}

func (s *DescribeParameterTemplatesRequest) SetOwnerAccount(v string) *DescribeParameterTemplatesRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeParameterTemplatesRequest) SetOwnerId(v int64) *DescribeParameterTemplatesRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeParameterTemplatesRequest) SetRegionId(v string) *DescribeParameterTemplatesRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeParameterTemplatesRequest) SetResourceOwnerAccount(v string) *DescribeParameterTemplatesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeParameterTemplatesRequest) SetResourceOwnerId(v int64) *DescribeParameterTemplatesRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeParameterTemplatesResponseBody struct {
	// The database engine of the instance.
	Engine *string `json:"Engine,omitempty" xml:"Engine,omitempty"`
	// The version of the database engine.
	EngineVersion *string `json:"EngineVersion,omitempty" xml:"EngineVersion,omitempty"`
	// The number of parameters.
	ParameterCount *string `json:"ParameterCount,omitempty" xml:"ParameterCount,omitempty"`
	// The details of the parameters.
	Parameters *DescribeParameterTemplatesResponseBodyParameters `json:"Parameters,omitempty" xml:"Parameters,omitempty" type:"Struct"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeParameterTemplatesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeParameterTemplatesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeParameterTemplatesResponseBody) SetEngine(v string) *DescribeParameterTemplatesResponseBody {
	s.Engine = &v
	return s
}

func (s *DescribeParameterTemplatesResponseBody) SetEngineVersion(v string) *DescribeParameterTemplatesResponseBody {
	s.EngineVersion = &v
	return s
}

func (s *DescribeParameterTemplatesResponseBody) SetParameterCount(v string) *DescribeParameterTemplatesResponseBody {
	s.ParameterCount = &v
	return s
}

func (s *DescribeParameterTemplatesResponseBody) SetParameters(v *DescribeParameterTemplatesResponseBodyParameters) *DescribeParameterTemplatesResponseBody {
	s.Parameters = v
	return s
}

func (s *DescribeParameterTemplatesResponseBody) SetRequestId(v string) *DescribeParameterTemplatesResponseBody {
	s.RequestId = &v
	return s
}

type DescribeParameterTemplatesResponseBodyParameters struct {
	TemplateRecord []*DescribeParameterTemplatesResponseBodyParametersTemplateRecord `json:"TemplateRecord,omitempty" xml:"TemplateRecord,omitempty" type:"Repeated"`
}

func (s DescribeParameterTemplatesResponseBodyParameters) String() string {
	return tea.Prettify(s)
}

func (s DescribeParameterTemplatesResponseBodyParameters) GoString() string {
	return s.String()
}

func (s *DescribeParameterTemplatesResponseBodyParameters) SetTemplateRecord(v []*DescribeParameterTemplatesResponseBodyParametersTemplateRecord) *DescribeParameterTemplatesResponseBodyParameters {
	s.TemplateRecord = v
	return s
}

type DescribeParameterTemplatesResponseBodyParametersTemplateRecord struct {
	// The valid values of the parameter.
	CheckingCode *string `json:"CheckingCode,omitempty" xml:"CheckingCode,omitempty"`
	// Indicates whether the parameter can be modified. Valid values:
	//
	// *   **true**
	// *   **false**
	ForceModify *string `json:"ForceModify,omitempty" xml:"ForceModify,omitempty"`
	// Indicates whether you must restart the instance for the modifications to take effect. Valid values:
	//
	// *   **true**
	// *   **false**
	ForceRestart *string `json:"ForceRestart,omitempty" xml:"ForceRestart,omitempty"`
	// The description of the parameter.
	ParameterDescription *string `json:"ParameterDescription,omitempty" xml:"ParameterDescription,omitempty"`
	// The name of the parameter.
	ParameterName *string `json:"ParameterName,omitempty" xml:"ParameterName,omitempty"`
	// The default value of the parameter.
	ParameterValue *string `json:"ParameterValue,omitempty" xml:"ParameterValue,omitempty"`
}

func (s DescribeParameterTemplatesResponseBodyParametersTemplateRecord) String() string {
	return tea.Prettify(s)
}

func (s DescribeParameterTemplatesResponseBodyParametersTemplateRecord) GoString() string {
	return s.String()
}

func (s *DescribeParameterTemplatesResponseBodyParametersTemplateRecord) SetCheckingCode(v string) *DescribeParameterTemplatesResponseBodyParametersTemplateRecord {
	s.CheckingCode = &v
	return s
}

func (s *DescribeParameterTemplatesResponseBodyParametersTemplateRecord) SetForceModify(v string) *DescribeParameterTemplatesResponseBodyParametersTemplateRecord {
	s.ForceModify = &v
	return s
}

func (s *DescribeParameterTemplatesResponseBodyParametersTemplateRecord) SetForceRestart(v string) *DescribeParameterTemplatesResponseBodyParametersTemplateRecord {
	s.ForceRestart = &v
	return s
}

func (s *DescribeParameterTemplatesResponseBodyParametersTemplateRecord) SetParameterDescription(v string) *DescribeParameterTemplatesResponseBodyParametersTemplateRecord {
	s.ParameterDescription = &v
	return s
}

func (s *DescribeParameterTemplatesResponseBodyParametersTemplateRecord) SetParameterName(v string) *DescribeParameterTemplatesResponseBodyParametersTemplateRecord {
	s.ParameterName = &v
	return s
}

func (s *DescribeParameterTemplatesResponseBodyParametersTemplateRecord) SetParameterValue(v string) *DescribeParameterTemplatesResponseBodyParametersTemplateRecord {
	s.ParameterValue = &v
	return s
}

type DescribeParameterTemplatesResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeParameterTemplatesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeParameterTemplatesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeParameterTemplatesResponse) GoString() string {
	return s.String()
}

func (s *DescribeParameterTemplatesResponse) SetHeaders(v map[string]*string) *DescribeParameterTemplatesResponse {
	s.Headers = v
	return s
}

func (s *DescribeParameterTemplatesResponse) SetStatusCode(v int32) *DescribeParameterTemplatesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeParameterTemplatesResponse) SetBody(v *DescribeParameterTemplatesResponseBody) *DescribeParameterTemplatesResponse {
	s.Body = v
	return s
}

type DescribeParametersRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the instance. You can call the [DescribeDBInstances](~~610396~~) operation to query the ID of the instance.
	DBInstanceId         *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeParametersRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeParametersRequest) GoString() string {
	return s.String()
}

func (s *DescribeParametersRequest) SetClientToken(v string) *DescribeParametersRequest {
	s.ClientToken = &v
	return s
}

func (s *DescribeParametersRequest) SetDBInstanceId(v string) *DescribeParametersRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeParametersRequest) SetOwnerAccount(v string) *DescribeParametersRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeParametersRequest) SetOwnerId(v int64) *DescribeParametersRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeParametersRequest) SetResourceOwnerAccount(v string) *DescribeParametersRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeParametersRequest) SetResourceOwnerId(v int64) *DescribeParametersRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeParametersResponseBody struct {
	// The list of parameters that are being synchronized.
	//
	// > After you modify and submit the parameters, you must wait for the parameters to be synchronized to the instance. After the synchronization, you can delete the parameters from the list.
	ConfigParameters *DescribeParametersResponseBodyConfigParameters `json:"ConfigParameters,omitempty" xml:"ConfigParameters,omitempty" type:"Struct"`
	// The type of the database engine.
	Engine *string `json:"Engine,omitempty" xml:"Engine,omitempty"`
	// The version of the database engine.
	EngineVersion *string `json:"EngineVersion,omitempty" xml:"EngineVersion,omitempty"`
	// The information about the parameter template.
	ParamGroupInfo *DescribeParametersResponseBodyParamGroupInfo `json:"ParamGroupInfo,omitempty" xml:"ParamGroupInfo,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The list of parameters that are in use.
	RunningParameters *DescribeParametersResponseBodyRunningParameters `json:"RunningParameters,omitempty" xml:"RunningParameters,omitempty" type:"Struct"`
}

func (s DescribeParametersResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeParametersResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeParametersResponseBody) SetConfigParameters(v *DescribeParametersResponseBodyConfigParameters) *DescribeParametersResponseBody {
	s.ConfigParameters = v
	return s
}

func (s *DescribeParametersResponseBody) SetEngine(v string) *DescribeParametersResponseBody {
	s.Engine = &v
	return s
}

func (s *DescribeParametersResponseBody) SetEngineVersion(v string) *DescribeParametersResponseBody {
	s.EngineVersion = &v
	return s
}

func (s *DescribeParametersResponseBody) SetParamGroupInfo(v *DescribeParametersResponseBodyParamGroupInfo) *DescribeParametersResponseBody {
	s.ParamGroupInfo = v
	return s
}

func (s *DescribeParametersResponseBody) SetRequestId(v string) *DescribeParametersResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeParametersResponseBody) SetRunningParameters(v *DescribeParametersResponseBodyRunningParameters) *DescribeParametersResponseBody {
	s.RunningParameters = v
	return s
}

type DescribeParametersResponseBodyConfigParameters struct {
	DBInstanceParameter []*DescribeParametersResponseBodyConfigParametersDBInstanceParameter `json:"DBInstanceParameter,omitempty" xml:"DBInstanceParameter,omitempty" type:"Repeated"`
}

func (s DescribeParametersResponseBodyConfigParameters) String() string {
	return tea.Prettify(s)
}

func (s DescribeParametersResponseBodyConfigParameters) GoString() string {
	return s.String()
}

func (s *DescribeParametersResponseBodyConfigParameters) SetDBInstanceParameter(v []*DescribeParametersResponseBodyConfigParametersDBInstanceParameter) *DescribeParametersResponseBodyConfigParameters {
	s.DBInstanceParameter = v
	return s
}

type DescribeParametersResponseBodyConfigParametersDBInstanceParameter struct {
	// The description of the parameter.
	ParameterDescription *string `json:"ParameterDescription,omitempty" xml:"ParameterDescription,omitempty"`
	// The name of the parameter.
	ParameterName *string `json:"ParameterName,omitempty" xml:"ParameterName,omitempty"`
	// The value of the parameter.
	ParameterValue *string `json:"ParameterValue,omitempty" xml:"ParameterValue,omitempty"`
}

func (s DescribeParametersResponseBodyConfigParametersDBInstanceParameter) String() string {
	return tea.Prettify(s)
}

func (s DescribeParametersResponseBodyConfigParametersDBInstanceParameter) GoString() string {
	return s.String()
}

func (s *DescribeParametersResponseBodyConfigParametersDBInstanceParameter) SetParameterDescription(v string) *DescribeParametersResponseBodyConfigParametersDBInstanceParameter {
	s.ParameterDescription = &v
	return s
}

func (s *DescribeParametersResponseBodyConfigParametersDBInstanceParameter) SetParameterName(v string) *DescribeParametersResponseBodyConfigParametersDBInstanceParameter {
	s.ParameterName = &v
	return s
}

func (s *DescribeParametersResponseBodyConfigParametersDBInstanceParameter) SetParameterValue(v string) *DescribeParametersResponseBodyConfigParametersDBInstanceParameter {
	s.ParameterValue = &v
	return s
}

type DescribeParametersResponseBodyParamGroupInfo struct {
	// The ID of the parameter template.
	ParamGroupId *string `json:"ParamGroupId,omitempty" xml:"ParamGroupId,omitempty"`
	// The description of the parameter template.
	ParameterGroupDesc *string `json:"ParameterGroupDesc,omitempty" xml:"ParameterGroupDesc,omitempty"`
	// The name of the parameter template.
	ParameterGroupName *string `json:"ParameterGroupName,omitempty" xml:"ParameterGroupName,omitempty"`
	// The type of the parameter template.
	ParameterGroupType *string `json:"ParameterGroupType,omitempty" xml:"ParameterGroupType,omitempty"`
}

func (s DescribeParametersResponseBodyParamGroupInfo) String() string {
	return tea.Prettify(s)
}

func (s DescribeParametersResponseBodyParamGroupInfo) GoString() string {
	return s.String()
}

func (s *DescribeParametersResponseBodyParamGroupInfo) SetParamGroupId(v string) *DescribeParametersResponseBodyParamGroupInfo {
	s.ParamGroupId = &v
	return s
}

func (s *DescribeParametersResponseBodyParamGroupInfo) SetParameterGroupDesc(v string) *DescribeParametersResponseBodyParamGroupInfo {
	s.ParameterGroupDesc = &v
	return s
}

func (s *DescribeParametersResponseBodyParamGroupInfo) SetParameterGroupName(v string) *DescribeParametersResponseBodyParamGroupInfo {
	s.ParameterGroupName = &v
	return s
}

func (s *DescribeParametersResponseBodyParamGroupInfo) SetParameterGroupType(v string) *DescribeParametersResponseBodyParamGroupInfo {
	s.ParameterGroupType = &v
	return s
}

type DescribeParametersResponseBodyRunningParameters struct {
	DBInstanceParameter []*DescribeParametersResponseBodyRunningParametersDBInstanceParameter `json:"DBInstanceParameter,omitempty" xml:"DBInstanceParameter,omitempty" type:"Repeated"`
}

func (s DescribeParametersResponseBodyRunningParameters) String() string {
	return tea.Prettify(s)
}

func (s DescribeParametersResponseBodyRunningParameters) GoString() string {
	return s.String()
}

func (s *DescribeParametersResponseBodyRunningParameters) SetDBInstanceParameter(v []*DescribeParametersResponseBodyRunningParametersDBInstanceParameter) *DescribeParametersResponseBodyRunningParameters {
	s.DBInstanceParameter = v
	return s
}

type DescribeParametersResponseBodyRunningParametersDBInstanceParameter struct {
	// The description of the parameter.
	ParameterDescription *string `json:"ParameterDescription,omitempty" xml:"ParameterDescription,omitempty"`
	// The name of the parameter.
	ParameterName *string `json:"ParameterName,omitempty" xml:"ParameterName,omitempty"`
	// The value of the parameter.
	ParameterValue *string `json:"ParameterValue,omitempty" xml:"ParameterValue,omitempty"`
}

func (s DescribeParametersResponseBodyRunningParametersDBInstanceParameter) String() string {
	return tea.Prettify(s)
}

func (s DescribeParametersResponseBodyRunningParametersDBInstanceParameter) GoString() string {
	return s.String()
}

func (s *DescribeParametersResponseBodyRunningParametersDBInstanceParameter) SetParameterDescription(v string) *DescribeParametersResponseBodyRunningParametersDBInstanceParameter {
	s.ParameterDescription = &v
	return s
}

func (s *DescribeParametersResponseBodyRunningParametersDBInstanceParameter) SetParameterName(v string) *DescribeParametersResponseBodyRunningParametersDBInstanceParameter {
	s.ParameterName = &v
	return s
}

func (s *DescribeParametersResponseBodyRunningParametersDBInstanceParameter) SetParameterValue(v string) *DescribeParametersResponseBodyRunningParametersDBInstanceParameter {
	s.ParameterValue = &v
	return s
}

type DescribeParametersResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeParametersResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeParametersResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeParametersResponse) GoString() string {
	return s.String()
}

func (s *DescribeParametersResponse) SetHeaders(v map[string]*string) *DescribeParametersResponse {
	s.Headers = v
	return s
}

func (s *DescribeParametersResponse) SetStatusCode(v int32) *DescribeParametersResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeParametersResponse) SetBody(v *DescribeParametersResponseBody) *DescribeParametersResponse {
	s.Body = v
	return s
}

type DescribePostgresExtensionsRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The instance ID. You can call the [DescribeDBInstances](~~610396~~) operation to query the ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The name of the database. You can call the [DescribeDatabases](~~610471~~) operation to obtain the name of the database.
	DBName       *string `json:"DBName,omitempty" xml:"DBName,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribePostgresExtensionsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribePostgresExtensionsRequest) GoString() string {
	return s.String()
}

func (s *DescribePostgresExtensionsRequest) SetClientToken(v string) *DescribePostgresExtensionsRequest {
	s.ClientToken = &v
	return s
}

func (s *DescribePostgresExtensionsRequest) SetDBInstanceId(v string) *DescribePostgresExtensionsRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DescribePostgresExtensionsRequest) SetDBName(v string) *DescribePostgresExtensionsRequest {
	s.DBName = &v
	return s
}

func (s *DescribePostgresExtensionsRequest) SetOwnerAccount(v string) *DescribePostgresExtensionsRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribePostgresExtensionsRequest) SetOwnerId(v int64) *DescribePostgresExtensionsRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribePostgresExtensionsRequest) SetResourceGroupId(v string) *DescribePostgresExtensionsRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribePostgresExtensionsRequest) SetResourceOwnerAccount(v string) *DescribePostgresExtensionsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribePostgresExtensionsRequest) SetResourceOwnerId(v int64) *DescribePostgresExtensionsRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribePostgresExtensionsResponseBody struct {
	// The list of extensions that are installed on the specified database.
	InstalledExtensions []*DescribePostgresExtensionsResponseBodyInstalledExtensions `json:"InstalledExtensions,omitempty" xml:"InstalledExtensions,omitempty" type:"Repeated"`
	// The overview of the extension.
	Overview map[string]interface{} `json:"Overview,omitempty" xml:"Overview,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The list of extensions that are not installed on the specified database.
	UninstalledExtensions []*DescribePostgresExtensionsResponseBodyUninstalledExtensions `json:"UninstalledExtensions,omitempty" xml:"UninstalledExtensions,omitempty" type:"Repeated"`
}

func (s DescribePostgresExtensionsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribePostgresExtensionsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribePostgresExtensionsResponseBody) SetInstalledExtensions(v []*DescribePostgresExtensionsResponseBodyInstalledExtensions) *DescribePostgresExtensionsResponseBody {
	s.InstalledExtensions = v
	return s
}

func (s *DescribePostgresExtensionsResponseBody) SetOverview(v map[string]interface{}) *DescribePostgresExtensionsResponseBody {
	s.Overview = v
	return s
}

func (s *DescribePostgresExtensionsResponseBody) SetRequestId(v string) *DescribePostgresExtensionsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribePostgresExtensionsResponseBody) SetUninstalledExtensions(v []*DescribePostgresExtensionsResponseBodyUninstalledExtensions) *DescribePostgresExtensionsResponseBody {
	s.UninstalledExtensions = v
	return s
}

type DescribePostgresExtensionsResponseBodyInstalledExtensions struct {
	// The category of the extension.
	//
	// *   **external_access**
	// *   **index_support**
	// *   **information_stat**
	// *   **geography_space**
	// *   **vector_engine**
	// *   **timing_engine**
	// *   **data_type**
	// *   **encrypt_secure**
	// *   **text_process**
	// *   **operation_maintenance**
	// *   **self_develop**
	Category *string `json:"Category,omitempty" xml:"Category,omitempty"`
	// The purpose of the extension.
	Comment *string `json:"Comment,omitempty" xml:"Comment,omitempty"`
	// The default version of the extension.
	DefaultVersion *string `json:"DefaultVersion,omitempty" xml:"DefaultVersion,omitempty"`
	// The current version of the extension.
	InstalledVersion *string `json:"InstalledVersion,omitempty" xml:"InstalledVersion,omitempty"`
	// The name of the extension.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The user of the extension.
	Owner *string `json:"Owner,omitempty" xml:"Owner,omitempty"`
	// The priority of the extension.
	//
	// *   **0**: The extension is displayed by default.
	// *   **1**: The extension is preferentially displayed.
	Priority *string `json:"Priority,omitempty" xml:"Priority,omitempty"`
	// The extensions on which the current extension depends when it is installed.
	Requires *string `json:"Requires,omitempty" xml:"Requires,omitempty"`
}

func (s DescribePostgresExtensionsResponseBodyInstalledExtensions) String() string {
	return tea.Prettify(s)
}

func (s DescribePostgresExtensionsResponseBodyInstalledExtensions) GoString() string {
	return s.String()
}

func (s *DescribePostgresExtensionsResponseBodyInstalledExtensions) SetCategory(v string) *DescribePostgresExtensionsResponseBodyInstalledExtensions {
	s.Category = &v
	return s
}

func (s *DescribePostgresExtensionsResponseBodyInstalledExtensions) SetComment(v string) *DescribePostgresExtensionsResponseBodyInstalledExtensions {
	s.Comment = &v
	return s
}

func (s *DescribePostgresExtensionsResponseBodyInstalledExtensions) SetDefaultVersion(v string) *DescribePostgresExtensionsResponseBodyInstalledExtensions {
	s.DefaultVersion = &v
	return s
}

func (s *DescribePostgresExtensionsResponseBodyInstalledExtensions) SetInstalledVersion(v string) *DescribePostgresExtensionsResponseBodyInstalledExtensions {
	s.InstalledVersion = &v
	return s
}

func (s *DescribePostgresExtensionsResponseBodyInstalledExtensions) SetName(v string) *DescribePostgresExtensionsResponseBodyInstalledExtensions {
	s.Name = &v
	return s
}

func (s *DescribePostgresExtensionsResponseBodyInstalledExtensions) SetOwner(v string) *DescribePostgresExtensionsResponseBodyInstalledExtensions {
	s.Owner = &v
	return s
}

func (s *DescribePostgresExtensionsResponseBodyInstalledExtensions) SetPriority(v string) *DescribePostgresExtensionsResponseBodyInstalledExtensions {
	s.Priority = &v
	return s
}

func (s *DescribePostgresExtensionsResponseBodyInstalledExtensions) SetRequires(v string) *DescribePostgresExtensionsResponseBodyInstalledExtensions {
	s.Requires = &v
	return s
}

type DescribePostgresExtensionsResponseBodyUninstalledExtensions struct {
	// The category of the extension.
	Category *string `json:"Category,omitempty" xml:"Category,omitempty"`
	// The purpose of the extension.
	Comment *string `json:"Comment,omitempty" xml:"Comment,omitempty"`
	// The default version of the extension.
	DefaultVersion *string `json:"DefaultVersion,omitempty" xml:"DefaultVersion,omitempty"`
	// The current version of the extension.
	InstalledVersion *string `json:"InstalledVersion,omitempty" xml:"InstalledVersion,omitempty"`
	// The name of the extension.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The user of the extension.
	Owner *string `json:"Owner,omitempty" xml:"Owner,omitempty"`
	// The priority of the extension.
	Priority *string `json:"Priority,omitempty" xml:"Priority,omitempty"`
	// The extensions on which the current extension depends when it is installed.
	Requires *string `json:"Requires,omitempty" xml:"Requires,omitempty"`
}

func (s DescribePostgresExtensionsResponseBodyUninstalledExtensions) String() string {
	return tea.Prettify(s)
}

func (s DescribePostgresExtensionsResponseBodyUninstalledExtensions) GoString() string {
	return s.String()
}

func (s *DescribePostgresExtensionsResponseBodyUninstalledExtensions) SetCategory(v string) *DescribePostgresExtensionsResponseBodyUninstalledExtensions {
	s.Category = &v
	return s
}

func (s *DescribePostgresExtensionsResponseBodyUninstalledExtensions) SetComment(v string) *DescribePostgresExtensionsResponseBodyUninstalledExtensions {
	s.Comment = &v
	return s
}

func (s *DescribePostgresExtensionsResponseBodyUninstalledExtensions) SetDefaultVersion(v string) *DescribePostgresExtensionsResponseBodyUninstalledExtensions {
	s.DefaultVersion = &v
	return s
}

func (s *DescribePostgresExtensionsResponseBodyUninstalledExtensions) SetInstalledVersion(v string) *DescribePostgresExtensionsResponseBodyUninstalledExtensions {
	s.InstalledVersion = &v
	return s
}

func (s *DescribePostgresExtensionsResponseBodyUninstalledExtensions) SetName(v string) *DescribePostgresExtensionsResponseBodyUninstalledExtensions {
	s.Name = &v
	return s
}

func (s *DescribePostgresExtensionsResponseBodyUninstalledExtensions) SetOwner(v string) *DescribePostgresExtensionsResponseBodyUninstalledExtensions {
	s.Owner = &v
	return s
}

func (s *DescribePostgresExtensionsResponseBodyUninstalledExtensions) SetPriority(v string) *DescribePostgresExtensionsResponseBodyUninstalledExtensions {
	s.Priority = &v
	return s
}

func (s *DescribePostgresExtensionsResponseBodyUninstalledExtensions) SetRequires(v string) *DescribePostgresExtensionsResponseBodyUninstalledExtensions {
	s.Requires = &v
	return s
}

type DescribePostgresExtensionsResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribePostgresExtensionsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribePostgresExtensionsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribePostgresExtensionsResponse) GoString() string {
	return s.String()
}

func (s *DescribePostgresExtensionsResponse) SetHeaders(v map[string]*string) *DescribePostgresExtensionsResponse {
	s.Headers = v
	return s
}

func (s *DescribePostgresExtensionsResponse) SetStatusCode(v int32) *DescribePostgresExtensionsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribePostgresExtensionsResponse) SetBody(v *DescribePostgresExtensionsResponseBody) *DescribePostgresExtensionsResponse {
	s.Body = v
	return s
}

type DescribePriceRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The commodity code of the instance. Valid values:
	//
	// *   **bards**: The instance is a pay-as-you-go primary instance. This value is available at the China site (aliyun.com).
	// *   **rds**: The instance is a subscription primary instance. This is the default value. This value is available at the China site (aliyun.com).
	// *   **rords**: The instance is a pay-as-you-go read-only instance. This value is available at the China site (aliyun.com).
	// *   **rds_rordspre_public_cn**: The instance is a subscription read-only instance. This value is available at the China site (aliyun.com).
	// *   **bards_intl**: The instance is a pay-as-you-go primary instance. This value is available at the International site (alibabacloud.com).
	// *   **rds_intl**: The instance is a subscription primary instance. This value is available at the International site (alibabacloud.com).
	// *   **rords_intl**: The instance is a pay-as-you-go read-only instance. This value is available at the International site (alibabacloud.com).
	// *   **rds_rordspre_public_intl**: The instance is a subscription read-only instance. This value is available on the International site (alibabacloud.com).
	//
	// > If you want to query the price of a read-only instance, you must specify this parameter.
	CommodityCode *string `json:"CommodityCode,omitempty" xml:"CommodityCode,omitempty"`
	// The instance type of the instance. For more information, see [Primary ApsaraDB RDS instance types](~~26312~~).
	DBInstanceClass *string `json:"DBInstanceClass,omitempty" xml:"DBInstanceClass,omitempty"`
	// The ID of the instance for which you want to change the specifications or the instance that you want to renew.
	//
	// > *   If you want to query the price of an specification change order or a renewal order, you must specify this parameter.
	// > *   If the instance is a read-only instance, you must set this parameter to the ID of its primary instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The storage capacity of the instance. Unit: GB. You can increase the storage capacity at a step size of 5 GB. For more information, see [Primary ApsaraDB RDS instance types](~~26312~~).
	DBInstanceStorage *int32 `json:"DBInstanceStorage,omitempty" xml:"DBInstanceStorage,omitempty"`
	// The storage type of the instance. Valid values:
	//
	// *   **local_ssd**: local SSD
	// *   **cloud_ssd**: standard SSD
	// *   **cloud_essd**: enhanced SSD (ESSD) of performance level 1 (PL1)
	// *   **cloud_essd2**: ESSD of PL2
	// *   **cloud_essd3**: ESSD of PL3
	DBInstanceStorageType *string `json:"DBInstanceStorageType,omitempty" xml:"DBInstanceStorageType,omitempty"`
	// The information about the node.
	//
	// > This parameter is suitable for RDS instances that run MySQL on RDS Cluster Edition.
	DBNode []*DescribePriceRequestDBNode `json:"DBNode,omitempty" xml:"DBNode,omitempty" type:"Repeated"`
	// The database engine of the instance. Valid values:
	//
	// *   **MySQL**
	// *   **SQLServer**
	// *   **PostgreSQL**
	// *   **MariaDB**
	Engine *string `json:"Engine,omitempty" xml:"Engine,omitempty"`
	// The database engine version of the instance.
	//
	// *   Valid values if you set Engine to **MySQL**: **5.5**, **5.6**, **5.7**, and **8.0**
	// *   Valid values if you set Engine to **SQLServer**: **08r2\_ent_ha** (cloud disks, discontinued), **2008r2**(local disks, discontinued), **2012** (SQL Server EE Basic), **2012\_ent_ha**, **2012\_std_ha**, **2012\_web**, **2016\_ent_ha**, **2016\_std_ha**, **2016\_web**, **2017\_ent**, **2017\_std_ha**, **2017\_web**, **2019\_ent**, **2019\_std_ha**, **2019\_web**, **2022\_ent**, **2022\_std_ha**, and **2022\_web**
	// *   Valid values if you set Engine to **PostgreSQL**: **10.0**, **11.0**, **12.0**, **13.0**, **14.0**, and **15.0**
	// *   Valid value if you set Engine to **MariaDB**: **10.3**
	//
	// >  The following information describes the valid values when you set Engine to SQLServer: `_ent` specifies SQL Server EE on RDS Cluster Edition, `_ent_ha` specifies SQL Server EE, `_std_ha` specifies SQL Server SE, and `_web` specifies SQL Server Web.
	EngineVersion *string `json:"EngineVersion,omitempty" xml:"EngineVersion,omitempty"`
	// The role of the instance. Valid values:
	//
	// *   **0**: primary instance
	// *   **3**: read-only instance
	InstanceUsedType *int32 `json:"InstanceUsedType,omitempty" xml:"InstanceUsedType,omitempty"`
	// The order type. Valid values:
	//
	// *   **BUY**: purchase order
	// *   **UPGRADE**: specification change order
	// *   **RENEW**: renewal order
	OrderType    *string `json:"OrderType,omitempty" xml:"OrderType,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The billing method of the instance. Valid values:
	//
	// *   **Prepaid**: subscription
	// *   **Postpaid**: pay-as-you-go
	PayType *string `json:"PayType,omitempty" xml:"PayType,omitempty"`
	// The number of instances that you want to purchase. Valid values: **0 to 30**.
	Quantity *int32 `json:"Quantity,omitempty" xml:"Quantity,omitempty"`
	// The region ID. You can call the [DescribeRegions](~~610399~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The settings of the serverless instance.
	//
	// > ApsaraDB RDS for MariaDB does not support serverless instances.
	ServerlessConfig *DescribePriceRequestServerlessConfig `json:"ServerlessConfig,omitempty" xml:"ServerlessConfig,omitempty" type:"Struct"`
	// The billing cycle of the subscription instance. This parameter is required when **CommodityCode** is set to **rds**, **rds_rordspre_public_cn**, **rds_intl**, or **rds_rordspre_public_intl**. Valid values:
	//
	// *   **Year**
	// *   **Month**
	TimeType *string `json:"TimeType,omitempty" xml:"TimeType,omitempty"`
	// The subscription duration of the instance.
	//
	// *   If you set the **TimeType** parameter to **Year**, the value of the UsedTime parameter ranges from **1 to 100**.
	// *   If you set the **TimeType** parameter to **Month**, the value of the UsedTime parameter ranges from **1 to 999**.
	//
	// Default value: **1**.
	UsedTime *int32 `json:"UsedTime,omitempty" xml:"UsedTime,omitempty"`
	// The zone ID of the primary instance. You can call the [DescribeRegions](~~610399~~) operation to query the most recent zone list.
	//
	// > If you specify a virtual private cloud (VPC) and a vSwitch, you must specify this parameter to identify the zone for the vSwitch.
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
}

func (s DescribePriceRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribePriceRequest) GoString() string {
	return s.String()
}

func (s *DescribePriceRequest) SetClientToken(v string) *DescribePriceRequest {
	s.ClientToken = &v
	return s
}

func (s *DescribePriceRequest) SetCommodityCode(v string) *DescribePriceRequest {
	s.CommodityCode = &v
	return s
}

func (s *DescribePriceRequest) SetDBInstanceClass(v string) *DescribePriceRequest {
	s.DBInstanceClass = &v
	return s
}

func (s *DescribePriceRequest) SetDBInstanceId(v string) *DescribePriceRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DescribePriceRequest) SetDBInstanceStorage(v int32) *DescribePriceRequest {
	s.DBInstanceStorage = &v
	return s
}

func (s *DescribePriceRequest) SetDBInstanceStorageType(v string) *DescribePriceRequest {
	s.DBInstanceStorageType = &v
	return s
}

func (s *DescribePriceRequest) SetDBNode(v []*DescribePriceRequestDBNode) *DescribePriceRequest {
	s.DBNode = v
	return s
}

func (s *DescribePriceRequest) SetEngine(v string) *DescribePriceRequest {
	s.Engine = &v
	return s
}

func (s *DescribePriceRequest) SetEngineVersion(v string) *DescribePriceRequest {
	s.EngineVersion = &v
	return s
}

func (s *DescribePriceRequest) SetInstanceUsedType(v int32) *DescribePriceRequest {
	s.InstanceUsedType = &v
	return s
}

func (s *DescribePriceRequest) SetOrderType(v string) *DescribePriceRequest {
	s.OrderType = &v
	return s
}

func (s *DescribePriceRequest) SetOwnerAccount(v string) *DescribePriceRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribePriceRequest) SetOwnerId(v int64) *DescribePriceRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribePriceRequest) SetPayType(v string) *DescribePriceRequest {
	s.PayType = &v
	return s
}

func (s *DescribePriceRequest) SetQuantity(v int32) *DescribePriceRequest {
	s.Quantity = &v
	return s
}

func (s *DescribePriceRequest) SetRegionId(v string) *DescribePriceRequest {
	s.RegionId = &v
	return s
}

func (s *DescribePriceRequest) SetResourceOwnerAccount(v string) *DescribePriceRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribePriceRequest) SetResourceOwnerId(v int64) *DescribePriceRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribePriceRequest) SetServerlessConfig(v *DescribePriceRequestServerlessConfig) *DescribePriceRequest {
	s.ServerlessConfig = v
	return s
}

func (s *DescribePriceRequest) SetTimeType(v string) *DescribePriceRequest {
	s.TimeType = &v
	return s
}

func (s *DescribePriceRequest) SetUsedTime(v int32) *DescribePriceRequest {
	s.UsedTime = &v
	return s
}

func (s *DescribePriceRequest) SetZoneId(v string) *DescribePriceRequest {
	s.ZoneId = &v
	return s
}

type DescribePriceRequestDBNode struct {
	// The specification of the node.
	ClassCode *string `json:"ClassCode,omitempty" xml:"ClassCode,omitempty"`
	// The zone ID of the node.
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
}

func (s DescribePriceRequestDBNode) String() string {
	return tea.Prettify(s)
}

func (s DescribePriceRequestDBNode) GoString() string {
	return s.String()
}

func (s *DescribePriceRequestDBNode) SetClassCode(v string) *DescribePriceRequestDBNode {
	s.ClassCode = &v
	return s
}

func (s *DescribePriceRequestDBNode) SetZoneId(v string) *DescribePriceRequestDBNode {
	s.ZoneId = &v
	return s
}

type DescribePriceRequestServerlessConfig struct {
	// The maximum number of RDS Capacity Units (RCUs).
	MaxCapacity *float64 `json:"MaxCapacity,omitempty" xml:"MaxCapacity,omitempty"`
	// The minimum number of RCUs.
	MinCapacity *float64 `json:"MinCapacity,omitempty" xml:"MinCapacity,omitempty"`
}

func (s DescribePriceRequestServerlessConfig) String() string {
	return tea.Prettify(s)
}

func (s DescribePriceRequestServerlessConfig) GoString() string {
	return s.String()
}

func (s *DescribePriceRequestServerlessConfig) SetMaxCapacity(v float64) *DescribePriceRequestServerlessConfig {
	s.MaxCapacity = &v
	return s
}

func (s *DescribePriceRequestServerlessConfig) SetMinCapacity(v float64) *DescribePriceRequestServerlessConfig {
	s.MinCapacity = &v
	return s
}

type DescribePriceShrinkRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The commodity code of the instance. Valid values:
	//
	// *   **bards**: The instance is a pay-as-you-go primary instance. This value is available at the China site (aliyun.com).
	// *   **rds**: The instance is a subscription primary instance. This is the default value. This value is available at the China site (aliyun.com).
	// *   **rords**: The instance is a pay-as-you-go read-only instance. This value is available at the China site (aliyun.com).
	// *   **rds_rordspre_public_cn**: The instance is a subscription read-only instance. This value is available at the China site (aliyun.com).
	// *   **bards_intl**: The instance is a pay-as-you-go primary instance. This value is available at the International site (alibabacloud.com).
	// *   **rds_intl**: The instance is a subscription primary instance. This value is available at the International site (alibabacloud.com).
	// *   **rords_intl**: The instance is a pay-as-you-go read-only instance. This value is available at the International site (alibabacloud.com).
	// *   **rds_rordspre_public_intl**: The instance is a subscription read-only instance. This value is available on the International site (alibabacloud.com).
	//
	// > If you want to query the price of a read-only instance, you must specify this parameter.
	CommodityCode *string `json:"CommodityCode,omitempty" xml:"CommodityCode,omitempty"`
	// The instance type of the instance. For more information, see [Primary ApsaraDB RDS instance types](~~26312~~).
	DBInstanceClass *string `json:"DBInstanceClass,omitempty" xml:"DBInstanceClass,omitempty"`
	// The ID of the instance for which you want to change the specifications or the instance that you want to renew.
	//
	// > *   If you want to query the price of an specification change order or a renewal order, you must specify this parameter.
	// > *   If the instance is a read-only instance, you must set this parameter to the ID of its primary instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The storage capacity of the instance. Unit: GB. You can increase the storage capacity at a step size of 5 GB. For more information, see [Primary ApsaraDB RDS instance types](~~26312~~).
	DBInstanceStorage *int32 `json:"DBInstanceStorage,omitempty" xml:"DBInstanceStorage,omitempty"`
	// The storage type of the instance. Valid values:
	//
	// *   **local_ssd**: local SSD
	// *   **cloud_ssd**: standard SSD
	// *   **cloud_essd**: enhanced SSD (ESSD) of performance level 1 (PL1)
	// *   **cloud_essd2**: ESSD of PL2
	// *   **cloud_essd3**: ESSD of PL3
	DBInstanceStorageType *string `json:"DBInstanceStorageType,omitempty" xml:"DBInstanceStorageType,omitempty"`
	// The information about the node.
	//
	// > This parameter is suitable for RDS instances that run MySQL on RDS Cluster Edition.
	DBNodeShrink *string `json:"DBNode,omitempty" xml:"DBNode,omitempty"`
	// The database engine of the instance. Valid values:
	//
	// *   **MySQL**
	// *   **SQLServer**
	// *   **PostgreSQL**
	// *   **MariaDB**
	Engine *string `json:"Engine,omitempty" xml:"Engine,omitempty"`
	// The database engine version of the instance.
	//
	// *   Valid values if you set Engine to **MySQL**: **5.5**, **5.6**, **5.7**, and **8.0**
	// *   Valid values if you set Engine to **SQLServer**: **08r2\_ent_ha** (cloud disks, discontinued), **2008r2**(local disks, discontinued), **2012** (SQL Server EE Basic), **2012\_ent_ha**, **2012\_std_ha**, **2012\_web**, **2016\_ent_ha**, **2016\_std_ha**, **2016\_web**, **2017\_ent**, **2017\_std_ha**, **2017\_web**, **2019\_ent**, **2019\_std_ha**, **2019\_web**, **2022\_ent**, **2022\_std_ha**, and **2022\_web**
	// *   Valid values if you set Engine to **PostgreSQL**: **10.0**, **11.0**, **12.0**, **13.0**, **14.0**, and **15.0**
	// *   Valid value if you set Engine to **MariaDB**: **10.3**
	//
	// >  The following information describes the valid values when you set Engine to SQLServer: `_ent` specifies SQL Server EE on RDS Cluster Edition, `_ent_ha` specifies SQL Server EE, `_std_ha` specifies SQL Server SE, and `_web` specifies SQL Server Web.
	EngineVersion *string `json:"EngineVersion,omitempty" xml:"EngineVersion,omitempty"`
	// The role of the instance. Valid values:
	//
	// *   **0**: primary instance
	// *   **3**: read-only instance
	InstanceUsedType *int32 `json:"InstanceUsedType,omitempty" xml:"InstanceUsedType,omitempty"`
	// The order type. Valid values:
	//
	// *   **BUY**: purchase order
	// *   **UPGRADE**: specification change order
	// *   **RENEW**: renewal order
	OrderType    *string `json:"OrderType,omitempty" xml:"OrderType,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The billing method of the instance. Valid values:
	//
	// *   **Prepaid**: subscription
	// *   **Postpaid**: pay-as-you-go
	PayType *string `json:"PayType,omitempty" xml:"PayType,omitempty"`
	// The number of instances that you want to purchase. Valid values: **0 to 30**.
	Quantity *int32 `json:"Quantity,omitempty" xml:"Quantity,omitempty"`
	// The region ID. You can call the [DescribeRegions](~~610399~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The settings of the serverless instance.
	//
	// > ApsaraDB RDS for MariaDB does not support serverless instances.
	ServerlessConfigShrink *string `json:"ServerlessConfig,omitempty" xml:"ServerlessConfig,omitempty"`
	// The billing cycle of the subscription instance. This parameter is required when **CommodityCode** is set to **rds**, **rds_rordspre_public_cn**, **rds_intl**, or **rds_rordspre_public_intl**. Valid values:
	//
	// *   **Year**
	// *   **Month**
	TimeType *string `json:"TimeType,omitempty" xml:"TimeType,omitempty"`
	// The subscription duration of the instance.
	//
	// *   If you set the **TimeType** parameter to **Year**, the value of the UsedTime parameter ranges from **1 to 100**.
	// *   If you set the **TimeType** parameter to **Month**, the value of the UsedTime parameter ranges from **1 to 999**.
	//
	// Default value: **1**.
	UsedTime *int32 `json:"UsedTime,omitempty" xml:"UsedTime,omitempty"`
	// The zone ID of the primary instance. You can call the [DescribeRegions](~~610399~~) operation to query the most recent zone list.
	//
	// > If you specify a virtual private cloud (VPC) and a vSwitch, you must specify this parameter to identify the zone for the vSwitch.
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
}

func (s DescribePriceShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribePriceShrinkRequest) GoString() string {
	return s.String()
}

func (s *DescribePriceShrinkRequest) SetClientToken(v string) *DescribePriceShrinkRequest {
	s.ClientToken = &v
	return s
}

func (s *DescribePriceShrinkRequest) SetCommodityCode(v string) *DescribePriceShrinkRequest {
	s.CommodityCode = &v
	return s
}

func (s *DescribePriceShrinkRequest) SetDBInstanceClass(v string) *DescribePriceShrinkRequest {
	s.DBInstanceClass = &v
	return s
}

func (s *DescribePriceShrinkRequest) SetDBInstanceId(v string) *DescribePriceShrinkRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DescribePriceShrinkRequest) SetDBInstanceStorage(v int32) *DescribePriceShrinkRequest {
	s.DBInstanceStorage = &v
	return s
}

func (s *DescribePriceShrinkRequest) SetDBInstanceStorageType(v string) *DescribePriceShrinkRequest {
	s.DBInstanceStorageType = &v
	return s
}

func (s *DescribePriceShrinkRequest) SetDBNodeShrink(v string) *DescribePriceShrinkRequest {
	s.DBNodeShrink = &v
	return s
}

func (s *DescribePriceShrinkRequest) SetEngine(v string) *DescribePriceShrinkRequest {
	s.Engine = &v
	return s
}

func (s *DescribePriceShrinkRequest) SetEngineVersion(v string) *DescribePriceShrinkRequest {
	s.EngineVersion = &v
	return s
}

func (s *DescribePriceShrinkRequest) SetInstanceUsedType(v int32) *DescribePriceShrinkRequest {
	s.InstanceUsedType = &v
	return s
}

func (s *DescribePriceShrinkRequest) SetOrderType(v string) *DescribePriceShrinkRequest {
	s.OrderType = &v
	return s
}

func (s *DescribePriceShrinkRequest) SetOwnerAccount(v string) *DescribePriceShrinkRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribePriceShrinkRequest) SetOwnerId(v int64) *DescribePriceShrinkRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribePriceShrinkRequest) SetPayType(v string) *DescribePriceShrinkRequest {
	s.PayType = &v
	return s
}

func (s *DescribePriceShrinkRequest) SetQuantity(v int32) *DescribePriceShrinkRequest {
	s.Quantity = &v
	return s
}

func (s *DescribePriceShrinkRequest) SetRegionId(v string) *DescribePriceShrinkRequest {
	s.RegionId = &v
	return s
}

func (s *DescribePriceShrinkRequest) SetResourceOwnerAccount(v string) *DescribePriceShrinkRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribePriceShrinkRequest) SetResourceOwnerId(v int64) *DescribePriceShrinkRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribePriceShrinkRequest) SetServerlessConfigShrink(v string) *DescribePriceShrinkRequest {
	s.ServerlessConfigShrink = &v
	return s
}

func (s *DescribePriceShrinkRequest) SetTimeType(v string) *DescribePriceShrinkRequest {
	s.TimeType = &v
	return s
}

func (s *DescribePriceShrinkRequest) SetUsedTime(v int32) *DescribePriceShrinkRequest {
	s.UsedTime = &v
	return s
}

func (s *DescribePriceShrinkRequest) SetZoneId(v string) *DescribePriceShrinkRequest {
	s.ZoneId = &v
	return s
}

type DescribePriceResponseBody struct {
	// The price information.
	PriceInfo *DescribePriceResponseBodyPriceInfo `json:"PriceInfo,omitempty" xml:"PriceInfo,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The details of the promotion rule.
	Rules *DescribePriceResponseBodyRules `json:"Rules,omitempty" xml:"Rules,omitempty" type:"Struct"`
	// Indicates whether discounts can be used.
	ShowDiscount *bool `json:"ShowDiscount,omitempty" xml:"ShowDiscount,omitempty"`
	// The estimated hourly fee that is calculated based on the maximum number of RCUs.
	TradeMaxRCUAmount *float32 `json:"TradeMaxRCUAmount,omitempty" xml:"TradeMaxRCUAmount,omitempty"`
	// The estimated hourly fee that is calculated based on the minimum number of RCUs.
	TradeMinRCUAmount *float32 `json:"TradeMinRCUAmount,omitempty" xml:"TradeMinRCUAmount,omitempty"`
}

func (s DescribePriceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribePriceResponseBody) GoString() string {
	return s.String()
}

func (s *DescribePriceResponseBody) SetPriceInfo(v *DescribePriceResponseBodyPriceInfo) *DescribePriceResponseBody {
	s.PriceInfo = v
	return s
}

func (s *DescribePriceResponseBody) SetRequestId(v string) *DescribePriceResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribePriceResponseBody) SetRules(v *DescribePriceResponseBodyRules) *DescribePriceResponseBody {
	s.Rules = v
	return s
}

func (s *DescribePriceResponseBody) SetShowDiscount(v bool) *DescribePriceResponseBody {
	s.ShowDiscount = &v
	return s
}

func (s *DescribePriceResponseBody) SetTradeMaxRCUAmount(v float32) *DescribePriceResponseBody {
	s.TradeMaxRCUAmount = &v
	return s
}

func (s *DescribePriceResponseBody) SetTradeMinRCUAmount(v float32) *DescribePriceResponseBody {
	s.TradeMinRCUAmount = &v
	return s
}

type DescribePriceResponseBodyPriceInfo struct {
	// The information about the promotion.
	ActivityInfo *DescribePriceResponseBodyPriceInfoActivityInfo `json:"ActivityInfo,omitempty" xml:"ActivityInfo,omitempty" type:"Struct"`
	// The information about the coupon.
	Coupons *DescribePriceResponseBodyPriceInfoCoupons `json:"Coupons,omitempty" xml:"Coupons,omitempty" type:"Struct"`
	// The currency unit.
	Currency *string `json:"Currency,omitempty" xml:"Currency,omitempty"`
	// The discount.
	DiscountPrice *float32 `json:"DiscountPrice,omitempty" xml:"DiscountPrice,omitempty"`
	// The original price.
	OriginalPrice *float32 `json:"OriginalPrice,omitempty" xml:"OriginalPrice,omitempty"`
	// An array that consists of the ID of the promotion rule.
	RuleIds *DescribePriceResponseBodyPriceInfoRuleIds `json:"RuleIds,omitempty" xml:"RuleIds,omitempty" type:"Struct"`
	// The transaction price, which is equal to the original price minus the discount.
	TradePrice *float32 `json:"TradePrice,omitempty" xml:"TradePrice,omitempty"`
}

func (s DescribePriceResponseBodyPriceInfo) String() string {
	return tea.Prettify(s)
}

func (s DescribePriceResponseBodyPriceInfo) GoString() string {
	return s.String()
}

func (s *DescribePriceResponseBodyPriceInfo) SetActivityInfo(v *DescribePriceResponseBodyPriceInfoActivityInfo) *DescribePriceResponseBodyPriceInfo {
	s.ActivityInfo = v
	return s
}

func (s *DescribePriceResponseBodyPriceInfo) SetCoupons(v *DescribePriceResponseBodyPriceInfoCoupons) *DescribePriceResponseBodyPriceInfo {
	s.Coupons = v
	return s
}

func (s *DescribePriceResponseBodyPriceInfo) SetCurrency(v string) *DescribePriceResponseBodyPriceInfo {
	s.Currency = &v
	return s
}

func (s *DescribePriceResponseBodyPriceInfo) SetDiscountPrice(v float32) *DescribePriceResponseBodyPriceInfo {
	s.DiscountPrice = &v
	return s
}

func (s *DescribePriceResponseBodyPriceInfo) SetOriginalPrice(v float32) *DescribePriceResponseBodyPriceInfo {
	s.OriginalPrice = &v
	return s
}

func (s *DescribePriceResponseBodyPriceInfo) SetRuleIds(v *DescribePriceResponseBodyPriceInfoRuleIds) *DescribePriceResponseBodyPriceInfo {
	s.RuleIds = v
	return s
}

func (s *DescribePriceResponseBodyPriceInfo) SetTradePrice(v float32) *DescribePriceResponseBodyPriceInfo {
	s.TradePrice = &v
	return s
}

type DescribePriceResponseBodyPriceInfoActivityInfo struct {
	// The returned message.
	CheckErrMsg *string `json:"CheckErrMsg,omitempty" xml:"CheckErrMsg,omitempty"`
	// The error code that is returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// Indicates whether the request was successful.
	Success *string `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DescribePriceResponseBodyPriceInfoActivityInfo) String() string {
	return tea.Prettify(s)
}

func (s DescribePriceResponseBodyPriceInfoActivityInfo) GoString() string {
	return s.String()
}

func (s *DescribePriceResponseBodyPriceInfoActivityInfo) SetCheckErrMsg(v string) *DescribePriceResponseBodyPriceInfoActivityInfo {
	s.CheckErrMsg = &v
	return s
}

func (s *DescribePriceResponseBodyPriceInfoActivityInfo) SetErrorCode(v string) *DescribePriceResponseBodyPriceInfoActivityInfo {
	s.ErrorCode = &v
	return s
}

func (s *DescribePriceResponseBodyPriceInfoActivityInfo) SetSuccess(v string) *DescribePriceResponseBodyPriceInfoActivityInfo {
	s.Success = &v
	return s
}

type DescribePriceResponseBodyPriceInfoCoupons struct {
	Coupon []*DescribePriceResponseBodyPriceInfoCouponsCoupon `json:"Coupon,omitempty" xml:"Coupon,omitempty" type:"Repeated"`
}

func (s DescribePriceResponseBodyPriceInfoCoupons) String() string {
	return tea.Prettify(s)
}

func (s DescribePriceResponseBodyPriceInfoCoupons) GoString() string {
	return s.String()
}

func (s *DescribePriceResponseBodyPriceInfoCoupons) SetCoupon(v []*DescribePriceResponseBodyPriceInfoCouponsCoupon) *DescribePriceResponseBodyPriceInfoCoupons {
	s.Coupon = v
	return s
}

type DescribePriceResponseBodyPriceInfoCouponsCoupon struct {
	// The coupon ID.
	CouponNo *string `json:"CouponNo,omitempty" xml:"CouponNo,omitempty"`
	// The description of the coupon.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// Indicates whether the coupon is selected.
	IsSelected *string `json:"IsSelected,omitempty" xml:"IsSelected,omitempty"`
	// The name of the coupon.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
}

func (s DescribePriceResponseBodyPriceInfoCouponsCoupon) String() string {
	return tea.Prettify(s)
}

func (s DescribePriceResponseBodyPriceInfoCouponsCoupon) GoString() string {
	return s.String()
}

func (s *DescribePriceResponseBodyPriceInfoCouponsCoupon) SetCouponNo(v string) *DescribePriceResponseBodyPriceInfoCouponsCoupon {
	s.CouponNo = &v
	return s
}

func (s *DescribePriceResponseBodyPriceInfoCouponsCoupon) SetDescription(v string) *DescribePriceResponseBodyPriceInfoCouponsCoupon {
	s.Description = &v
	return s
}

func (s *DescribePriceResponseBodyPriceInfoCouponsCoupon) SetIsSelected(v string) *DescribePriceResponseBodyPriceInfoCouponsCoupon {
	s.IsSelected = &v
	return s
}

func (s *DescribePriceResponseBodyPriceInfoCouponsCoupon) SetName(v string) *DescribePriceResponseBodyPriceInfoCouponsCoupon {
	s.Name = &v
	return s
}

type DescribePriceResponseBodyPriceInfoRuleIds struct {
	RuleId []*string `json:"RuleId,omitempty" xml:"RuleId,omitempty" type:"Repeated"`
}

func (s DescribePriceResponseBodyPriceInfoRuleIds) String() string {
	return tea.Prettify(s)
}

func (s DescribePriceResponseBodyPriceInfoRuleIds) GoString() string {
	return s.String()
}

func (s *DescribePriceResponseBodyPriceInfoRuleIds) SetRuleId(v []*string) *DescribePriceResponseBodyPriceInfoRuleIds {
	s.RuleId = v
	return s
}

type DescribePriceResponseBodyRules struct {
	Rule []*DescribePriceResponseBodyRulesRule `json:"Rule,omitempty" xml:"Rule,omitempty" type:"Repeated"`
}

func (s DescribePriceResponseBodyRules) String() string {
	return tea.Prettify(s)
}

func (s DescribePriceResponseBodyRules) GoString() string {
	return s.String()
}

func (s *DescribePriceResponseBodyRules) SetRule(v []*DescribePriceResponseBodyRulesRule) *DescribePriceResponseBodyRules {
	s.Rule = v
	return s
}

type DescribePriceResponseBodyRulesRule struct {
	// The description of the promotion rule.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The name of the promotion rule.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the promotion rule.
	RuleId *int64 `json:"RuleId,omitempty" xml:"RuleId,omitempty"`
}

func (s DescribePriceResponseBodyRulesRule) String() string {
	return tea.Prettify(s)
}

func (s DescribePriceResponseBodyRulesRule) GoString() string {
	return s.String()
}

func (s *DescribePriceResponseBodyRulesRule) SetDescription(v string) *DescribePriceResponseBodyRulesRule {
	s.Description = &v
	return s
}

func (s *DescribePriceResponseBodyRulesRule) SetName(v string) *DescribePriceResponseBodyRulesRule {
	s.Name = &v
	return s
}

func (s *DescribePriceResponseBodyRulesRule) SetRuleId(v int64) *DescribePriceResponseBodyRulesRule {
	s.RuleId = &v
	return s
}

type DescribePriceResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribePriceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribePriceResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribePriceResponse) GoString() string {
	return s.String()
}

func (s *DescribePriceResponse) SetHeaders(v map[string]*string) *DescribePriceResponse {
	s.Headers = v
	return s
}

func (s *DescribePriceResponse) SetStatusCode(v int32) *DescribePriceResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribePriceResponse) SetBody(v *DescribePriceResponseBody) *DescribePriceResponse {
	s.Body = v
	return s
}

type DescribeQuickSaleConfigRequest struct {
	// The product code. Valid values:
	//
	// *   rds: The instance is a subscription instance.
	// *   bards: The instance is a pay-as-you-go instance.
	Commodity *string `json:"Commodity,omitempty" xml:"Commodity,omitempty"`
	// The database engine of the instance. Valid values:
	//
	// *   **MySQL**
	// *   **SQLServer**
	// *   **PostgreSQL**
	// *   **MariaDB**
	Engine *string `json:"Engine,omitempty" xml:"Engine,omitempty"`
	// The region ID. You can call the [DescribeRegions](~~26243~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DescribeQuickSaleConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeQuickSaleConfigRequest) GoString() string {
	return s.String()
}

func (s *DescribeQuickSaleConfigRequest) SetCommodity(v string) *DescribeQuickSaleConfigRequest {
	s.Commodity = &v
	return s
}

func (s *DescribeQuickSaleConfigRequest) SetEngine(v string) *DescribeQuickSaleConfigRequest {
	s.Engine = &v
	return s
}

func (s *DescribeQuickSaleConfigRequest) SetRegionId(v string) *DescribeQuickSaleConfigRequest {
	s.RegionId = &v
	return s
}

type DescribeQuickSaleConfigResponseBody struct {
	// The product code. Valid values:
	//
	// *   rds: The instance is a subscription instance.
	// *   bards: The instance is a pay-as-you-go instance.
	Commodity *string `json:"Commodity,omitempty" xml:"Commodity,omitempty"`
	// The configuration details of the product.
	Items map[string]interface{} `json:"Items,omitempty" xml:"Items,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeQuickSaleConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeQuickSaleConfigResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeQuickSaleConfigResponseBody) SetCommodity(v string) *DescribeQuickSaleConfigResponseBody {
	s.Commodity = &v
	return s
}

func (s *DescribeQuickSaleConfigResponseBody) SetItems(v map[string]interface{}) *DescribeQuickSaleConfigResponseBody {
	s.Items = v
	return s
}

func (s *DescribeQuickSaleConfigResponseBody) SetRequestId(v string) *DescribeQuickSaleConfigResponseBody {
	s.RequestId = &v
	return s
}

type DescribeQuickSaleConfigResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeQuickSaleConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeQuickSaleConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeQuickSaleConfigResponse) GoString() string {
	return s.String()
}

func (s *DescribeQuickSaleConfigResponse) SetHeaders(v map[string]*string) *DescribeQuickSaleConfigResponse {
	s.Headers = v
	return s
}

func (s *DescribeQuickSaleConfigResponse) SetStatusCode(v int32) *DescribeQuickSaleConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeQuickSaleConfigResponse) SetBody(v *DescribeQuickSaleConfigResponseBody) *DescribeQuickSaleConfigResponse {
	s.Body = v
	return s
}

type DescribeRdsResourceSettingsRequest struct {
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceNiche        *string `json:"ResourceNiche,omitempty" xml:"ResourceNiche,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeRdsResourceSettingsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeRdsResourceSettingsRequest) GoString() string {
	return s.String()
}

func (s *DescribeRdsResourceSettingsRequest) SetOwnerId(v int64) *DescribeRdsResourceSettingsRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeRdsResourceSettingsRequest) SetResourceNiche(v string) *DescribeRdsResourceSettingsRequest {
	s.ResourceNiche = &v
	return s
}

func (s *DescribeRdsResourceSettingsRequest) SetResourceOwnerAccount(v string) *DescribeRdsResourceSettingsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeRdsResourceSettingsRequest) SetResourceOwnerId(v int64) *DescribeRdsResourceSettingsRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeRdsResourceSettingsResponseBody struct {
	RdsInstanceResourceSettings *DescribeRdsResourceSettingsResponseBodyRdsInstanceResourceSettings `json:"RdsInstanceResourceSettings,omitempty" xml:"RdsInstanceResourceSettings,omitempty" type:"Struct"`
	RequestId                   *string                                                             `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeRdsResourceSettingsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeRdsResourceSettingsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeRdsResourceSettingsResponseBody) SetRdsInstanceResourceSettings(v *DescribeRdsResourceSettingsResponseBodyRdsInstanceResourceSettings) *DescribeRdsResourceSettingsResponseBody {
	s.RdsInstanceResourceSettings = v
	return s
}

func (s *DescribeRdsResourceSettingsResponseBody) SetRequestId(v string) *DescribeRdsResourceSettingsResponseBody {
	s.RequestId = &v
	return s
}

type DescribeRdsResourceSettingsResponseBodyRdsInstanceResourceSettings struct {
	RdsInstanceResourceSetting []*DescribeRdsResourceSettingsResponseBodyRdsInstanceResourceSettingsRdsInstanceResourceSetting `json:"RdsInstanceResourceSetting,omitempty" xml:"RdsInstanceResourceSetting,omitempty" type:"Repeated"`
}

func (s DescribeRdsResourceSettingsResponseBodyRdsInstanceResourceSettings) String() string {
	return tea.Prettify(s)
}

func (s DescribeRdsResourceSettingsResponseBodyRdsInstanceResourceSettings) GoString() string {
	return s.String()
}

func (s *DescribeRdsResourceSettingsResponseBodyRdsInstanceResourceSettings) SetRdsInstanceResourceSetting(v []*DescribeRdsResourceSettingsResponseBodyRdsInstanceResourceSettingsRdsInstanceResourceSetting) *DescribeRdsResourceSettingsResponseBodyRdsInstanceResourceSettings {
	s.RdsInstanceResourceSetting = v
	return s
}

type DescribeRdsResourceSettingsResponseBodyRdsInstanceResourceSettingsRdsInstanceResourceSetting struct {
	EndDate            *string `json:"EndDate,omitempty" xml:"EndDate,omitempty"`
	IsTop              *string `json:"IsTop,omitempty" xml:"IsTop,omitempty"`
	NoticeBarContent   *string `json:"NoticeBarContent,omitempty" xml:"NoticeBarContent,omitempty"`
	PoppedUpButtonText *string `json:"PoppedUpButtonText,omitempty" xml:"PoppedUpButtonText,omitempty"`
	PoppedUpButtonType *string `json:"PoppedUpButtonType,omitempty" xml:"PoppedUpButtonType,omitempty"`
	PoppedUpButtonUrl  *string `json:"PoppedUpButtonUrl,omitempty" xml:"PoppedUpButtonUrl,omitempty"`
	PoppedUpContent    *string `json:"PoppedUpContent,omitempty" xml:"PoppedUpContent,omitempty"`
	ResourceNiche      *string `json:"ResourceNiche,omitempty" xml:"ResourceNiche,omitempty"`
	StartDate          *string `json:"StartDate,omitempty" xml:"StartDate,omitempty"`
}

func (s DescribeRdsResourceSettingsResponseBodyRdsInstanceResourceSettingsRdsInstanceResourceSetting) String() string {
	return tea.Prettify(s)
}

func (s DescribeRdsResourceSettingsResponseBodyRdsInstanceResourceSettingsRdsInstanceResourceSetting) GoString() string {
	return s.String()
}

func (s *DescribeRdsResourceSettingsResponseBodyRdsInstanceResourceSettingsRdsInstanceResourceSetting) SetEndDate(v string) *DescribeRdsResourceSettingsResponseBodyRdsInstanceResourceSettingsRdsInstanceResourceSetting {
	s.EndDate = &v
	return s
}

func (s *DescribeRdsResourceSettingsResponseBodyRdsInstanceResourceSettingsRdsInstanceResourceSetting) SetIsTop(v string) *DescribeRdsResourceSettingsResponseBodyRdsInstanceResourceSettingsRdsInstanceResourceSetting {
	s.IsTop = &v
	return s
}

func (s *DescribeRdsResourceSettingsResponseBodyRdsInstanceResourceSettingsRdsInstanceResourceSetting) SetNoticeBarContent(v string) *DescribeRdsResourceSettingsResponseBodyRdsInstanceResourceSettingsRdsInstanceResourceSetting {
	s.NoticeBarContent = &v
	return s
}

func (s *DescribeRdsResourceSettingsResponseBodyRdsInstanceResourceSettingsRdsInstanceResourceSetting) SetPoppedUpButtonText(v string) *DescribeRdsResourceSettingsResponseBodyRdsInstanceResourceSettingsRdsInstanceResourceSetting {
	s.PoppedUpButtonText = &v
	return s
}

func (s *DescribeRdsResourceSettingsResponseBodyRdsInstanceResourceSettingsRdsInstanceResourceSetting) SetPoppedUpButtonType(v string) *DescribeRdsResourceSettingsResponseBodyRdsInstanceResourceSettingsRdsInstanceResourceSetting {
	s.PoppedUpButtonType = &v
	return s
}

func (s *DescribeRdsResourceSettingsResponseBodyRdsInstanceResourceSettingsRdsInstanceResourceSetting) SetPoppedUpButtonUrl(v string) *DescribeRdsResourceSettingsResponseBodyRdsInstanceResourceSettingsRdsInstanceResourceSetting {
	s.PoppedUpButtonUrl = &v
	return s
}

func (s *DescribeRdsResourceSettingsResponseBodyRdsInstanceResourceSettingsRdsInstanceResourceSetting) SetPoppedUpContent(v string) *DescribeRdsResourceSettingsResponseBodyRdsInstanceResourceSettingsRdsInstanceResourceSetting {
	s.PoppedUpContent = &v
	return s
}

func (s *DescribeRdsResourceSettingsResponseBodyRdsInstanceResourceSettingsRdsInstanceResourceSetting) SetResourceNiche(v string) *DescribeRdsResourceSettingsResponseBodyRdsInstanceResourceSettingsRdsInstanceResourceSetting {
	s.ResourceNiche = &v
	return s
}

func (s *DescribeRdsResourceSettingsResponseBodyRdsInstanceResourceSettingsRdsInstanceResourceSetting) SetStartDate(v string) *DescribeRdsResourceSettingsResponseBodyRdsInstanceResourceSettingsRdsInstanceResourceSetting {
	s.StartDate = &v
	return s
}

type DescribeRdsResourceSettingsResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeRdsResourceSettingsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeRdsResourceSettingsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeRdsResourceSettingsResponse) GoString() string {
	return s.String()
}

func (s *DescribeRdsResourceSettingsResponse) SetHeaders(v map[string]*string) *DescribeRdsResourceSettingsResponse {
	s.Headers = v
	return s
}

func (s *DescribeRdsResourceSettingsResponse) SetStatusCode(v int32) *DescribeRdsResourceSettingsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeRdsResourceSettingsResponse) SetBody(v *DescribeRdsResourceSettingsResponseBody) *DescribeRdsResourceSettingsResponse {
	s.Body = v
	return s
}

type DescribeReadDBInstanceDelayRequest struct {
	// The ID of the primary instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the read-only instance.
	ReadInstanceId *string `json:"ReadInstanceId,omitempty" xml:"ReadInstanceId,omitempty"`
	// The ID of the region where the global active database clusters that you want to query reside. You can call the [DescribeRegions](~~26243~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	SecurityToken        *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s DescribeReadDBInstanceDelayRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeReadDBInstanceDelayRequest) GoString() string {
	return s.String()
}

func (s *DescribeReadDBInstanceDelayRequest) SetDBInstanceId(v string) *DescribeReadDBInstanceDelayRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeReadDBInstanceDelayRequest) SetOwnerAccount(v string) *DescribeReadDBInstanceDelayRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeReadDBInstanceDelayRequest) SetOwnerId(v int64) *DescribeReadDBInstanceDelayRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeReadDBInstanceDelayRequest) SetReadInstanceId(v string) *DescribeReadDBInstanceDelayRequest {
	s.ReadInstanceId = &v
	return s
}

func (s *DescribeReadDBInstanceDelayRequest) SetRegionId(v string) *DescribeReadDBInstanceDelayRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeReadDBInstanceDelayRequest) SetResourceOwnerAccount(v string) *DescribeReadDBInstanceDelayRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeReadDBInstanceDelayRequest) SetResourceOwnerId(v int64) *DescribeReadDBInstanceDelayRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeReadDBInstanceDelayRequest) SetSecurityToken(v string) *DescribeReadDBInstanceDelayRequest {
	s.SecurityToken = &v
	return s
}

type DescribeReadDBInstanceDelayResponseBody struct {
	// The ID of the primary instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The latency of data replication between the primary instance and the read-only instance.
	DelayTime *int32 `json:"DelayTime,omitempty" xml:"DelayTime,omitempty"`
	// An array that consists of latency information.
	Items *DescribeReadDBInstanceDelayResponseBodyItems `json:"Items,omitempty" xml:"Items,omitempty" type:"Struct"`
	// The ID of the read-only instance.
	ReadDBInstanceId *string `json:"ReadDBInstanceId,omitempty" xml:"ReadDBInstanceId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeReadDBInstanceDelayResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeReadDBInstanceDelayResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeReadDBInstanceDelayResponseBody) SetDBInstanceId(v string) *DescribeReadDBInstanceDelayResponseBody {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeReadDBInstanceDelayResponseBody) SetDelayTime(v int32) *DescribeReadDBInstanceDelayResponseBody {
	s.DelayTime = &v
	return s
}

func (s *DescribeReadDBInstanceDelayResponseBody) SetItems(v *DescribeReadDBInstanceDelayResponseBodyItems) *DescribeReadDBInstanceDelayResponseBody {
	s.Items = v
	return s
}

func (s *DescribeReadDBInstanceDelayResponseBody) SetReadDBInstanceId(v string) *DescribeReadDBInstanceDelayResponseBody {
	s.ReadDBInstanceId = &v
	return s
}

func (s *DescribeReadDBInstanceDelayResponseBody) SetRequestId(v string) *DescribeReadDBInstanceDelayResponseBody {
	s.RequestId = &v
	return s
}

type DescribeReadDBInstanceDelayResponseBodyItems struct {
	Items []*DescribeReadDBInstanceDelayResponseBodyItemsItems `json:"Items,omitempty" xml:"Items,omitempty" type:"Repeated"`
}

func (s DescribeReadDBInstanceDelayResponseBodyItems) String() string {
	return tea.Prettify(s)
}

func (s DescribeReadDBInstanceDelayResponseBodyItems) GoString() string {
	return s.String()
}

func (s *DescribeReadDBInstanceDelayResponseBodyItems) SetItems(v []*DescribeReadDBInstanceDelayResponseBodyItemsItems) *DescribeReadDBInstanceDelayResponseBodyItems {
	s.Items = v
	return s
}

type DescribeReadDBInstanceDelayResponseBodyItemsItems struct {
	// The ID of the primary instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// An array that consists of information about the read-only instance.
	//
	// >  This parameter is returned only when the primary instance runs the MySQL database engine.
	ReadDBInstanceNames *DescribeReadDBInstanceDelayResponseBodyItemsItemsReadDBInstanceNames `json:"ReadDBInstanceNames,omitempty" xml:"ReadDBInstanceNames,omitempty" type:"Struct"`
	// An array that consists of latencies.
	//
	// >  This parameter is returned only when the primary instance runs the MySQL database engine.
	ReadDelayTimes *DescribeReadDBInstanceDelayResponseBodyItemsItemsReadDelayTimes `json:"ReadDelayTimes,omitempty" xml:"ReadDelayTimes,omitempty" type:"Struct"`
	// An array that consists of information about the write-ahead log (WAL) latency.
	//
	// >  This parameter is returned only when the primary instance runs the PostgreSQL database engine.
	ReadonlyInstanceDelay *DescribeReadDBInstanceDelayResponseBodyItemsItemsReadonlyInstanceDelay `json:"ReadonlyInstanceDelay,omitempty" xml:"ReadonlyInstanceDelay,omitempty" type:"Struct"`
}

func (s DescribeReadDBInstanceDelayResponseBodyItemsItems) String() string {
	return tea.Prettify(s)
}

func (s DescribeReadDBInstanceDelayResponseBodyItemsItems) GoString() string {
	return s.String()
}

func (s *DescribeReadDBInstanceDelayResponseBodyItemsItems) SetDBInstanceId(v string) *DescribeReadDBInstanceDelayResponseBodyItemsItems {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeReadDBInstanceDelayResponseBodyItemsItems) SetReadDBInstanceNames(v *DescribeReadDBInstanceDelayResponseBodyItemsItemsReadDBInstanceNames) *DescribeReadDBInstanceDelayResponseBodyItemsItems {
	s.ReadDBInstanceNames = v
	return s
}

func (s *DescribeReadDBInstanceDelayResponseBodyItemsItems) SetReadDelayTimes(v *DescribeReadDBInstanceDelayResponseBodyItemsItemsReadDelayTimes) *DescribeReadDBInstanceDelayResponseBodyItemsItems {
	s.ReadDelayTimes = v
	return s
}

func (s *DescribeReadDBInstanceDelayResponseBodyItemsItems) SetReadonlyInstanceDelay(v *DescribeReadDBInstanceDelayResponseBodyItemsItemsReadonlyInstanceDelay) *DescribeReadDBInstanceDelayResponseBodyItemsItems {
	s.ReadonlyInstanceDelay = v
	return s
}

type DescribeReadDBInstanceDelayResponseBodyItemsItemsReadDBInstanceNames struct {
	ReadDBInstanceName []*string `json:"ReadDBInstanceName,omitempty" xml:"ReadDBInstanceName,omitempty" type:"Repeated"`
}

func (s DescribeReadDBInstanceDelayResponseBodyItemsItemsReadDBInstanceNames) String() string {
	return tea.Prettify(s)
}

func (s DescribeReadDBInstanceDelayResponseBodyItemsItemsReadDBInstanceNames) GoString() string {
	return s.String()
}

func (s *DescribeReadDBInstanceDelayResponseBodyItemsItemsReadDBInstanceNames) SetReadDBInstanceName(v []*string) *DescribeReadDBInstanceDelayResponseBodyItemsItemsReadDBInstanceNames {
	s.ReadDBInstanceName = v
	return s
}

type DescribeReadDBInstanceDelayResponseBodyItemsItemsReadDelayTimes struct {
	ReadDelayTime []*string `json:"ReadDelayTime,omitempty" xml:"ReadDelayTime,omitempty" type:"Repeated"`
}

func (s DescribeReadDBInstanceDelayResponseBodyItemsItemsReadDelayTimes) String() string {
	return tea.Prettify(s)
}

func (s DescribeReadDBInstanceDelayResponseBodyItemsItemsReadDelayTimes) GoString() string {
	return s.String()
}

func (s *DescribeReadDBInstanceDelayResponseBodyItemsItemsReadDelayTimes) SetReadDelayTime(v []*string) *DescribeReadDBInstanceDelayResponseBodyItemsItemsReadDelayTimes {
	s.ReadDelayTime = v
	return s
}

type DescribeReadDBInstanceDelayResponseBodyItemsItemsReadonlyInstanceDelay struct {
	ReadonlyInstanceDelay []*DescribeReadDBInstanceDelayResponseBodyItemsItemsReadonlyInstanceDelayReadonlyInstanceDelay `json:"ReadonlyInstanceDelay,omitempty" xml:"ReadonlyInstanceDelay,omitempty" type:"Repeated"`
}

func (s DescribeReadDBInstanceDelayResponseBodyItemsItemsReadonlyInstanceDelay) String() string {
	return tea.Prettify(s)
}

func (s DescribeReadDBInstanceDelayResponseBodyItemsItemsReadonlyInstanceDelay) GoString() string {
	return s.String()
}

func (s *DescribeReadDBInstanceDelayResponseBodyItemsItemsReadonlyInstanceDelay) SetReadonlyInstanceDelay(v []*DescribeReadDBInstanceDelayResponseBodyItemsItemsReadonlyInstanceDelayReadonlyInstanceDelay) *DescribeReadDBInstanceDelayResponseBodyItemsItemsReadonlyInstanceDelay {
	s.ReadonlyInstanceDelay = v
	return s
}

type DescribeReadDBInstanceDelayResponseBodyItemsItemsReadonlyInstanceDelayReadonlyInstanceDelay struct {
	// The duration that is allowed for the latency in the persistence of WAL data. Unit: seconds.
	FlushLag *string `json:"FlushLag,omitempty" xml:"FlushLag,omitempty"`
	// The data size that is allowed for the latency in the persistence of WAL data. Unit: MB.
	FlushLatency *string `json:"FlushLatency,omitempty" xml:"FlushLatency,omitempty"`
	// The ID of the read-only instance.
	ReadDBInstanceName *string `json:"ReadDBInstanceName,omitempty" xml:"ReadDBInstanceName,omitempty"`
	// The duration that is allowed for the latency in the playback of WAL data. Unit: seconds.
	ReplayLag *string `json:"ReplayLag,omitempty" xml:"ReplayLag,omitempty"`
	// The data size that is allowed for the latency in the playback of WAL data. Unit: MB.
	ReplayLatency *string `json:"ReplayLatency,omitempty" xml:"ReplayLatency,omitempty"`
	// The data size that is allowed for the latency in the sending of WAL data. Unit: MB.
	SendLatency *string `json:"SendLatency,omitempty" xml:"SendLatency,omitempty"`
	// The duration that is allowed for the latency in the write-back of WAL data. Unit: seconds.
	WriteLag *string `json:"WriteLag,omitempty" xml:"WriteLag,omitempty"`
	// The data size that is allowed for the latency in the write-back of WAL data. Unit: MB.
	WriteLatency *string `json:"WriteLatency,omitempty" xml:"WriteLatency,omitempty"`
}

func (s DescribeReadDBInstanceDelayResponseBodyItemsItemsReadonlyInstanceDelayReadonlyInstanceDelay) String() string {
	return tea.Prettify(s)
}

func (s DescribeReadDBInstanceDelayResponseBodyItemsItemsReadonlyInstanceDelayReadonlyInstanceDelay) GoString() string {
	return s.String()
}

func (s *DescribeReadDBInstanceDelayResponseBodyItemsItemsReadonlyInstanceDelayReadonlyInstanceDelay) SetFlushLag(v string) *DescribeReadDBInstanceDelayResponseBodyItemsItemsReadonlyInstanceDelayReadonlyInstanceDelay {
	s.FlushLag = &v
	return s
}

func (s *DescribeReadDBInstanceDelayResponseBodyItemsItemsReadonlyInstanceDelayReadonlyInstanceDelay) SetFlushLatency(v string) *DescribeReadDBInstanceDelayResponseBodyItemsItemsReadonlyInstanceDelayReadonlyInstanceDelay {
	s.FlushLatency = &v
	return s
}

func (s *DescribeReadDBInstanceDelayResponseBodyItemsItemsReadonlyInstanceDelayReadonlyInstanceDelay) SetReadDBInstanceName(v string) *DescribeReadDBInstanceDelayResponseBodyItemsItemsReadonlyInstanceDelayReadonlyInstanceDelay {
	s.ReadDBInstanceName = &v
	return s
}

func (s *DescribeReadDBInstanceDelayResponseBodyItemsItemsReadonlyInstanceDelayReadonlyInstanceDelay) SetReplayLag(v string) *DescribeReadDBInstanceDelayResponseBodyItemsItemsReadonlyInstanceDelayReadonlyInstanceDelay {
	s.ReplayLag = &v
	return s
}

func (s *DescribeReadDBInstanceDelayResponseBodyItemsItemsReadonlyInstanceDelayReadonlyInstanceDelay) SetReplayLatency(v string) *DescribeReadDBInstanceDelayResponseBodyItemsItemsReadonlyInstanceDelayReadonlyInstanceDelay {
	s.ReplayLatency = &v
	return s
}

func (s *DescribeReadDBInstanceDelayResponseBodyItemsItemsReadonlyInstanceDelayReadonlyInstanceDelay) SetSendLatency(v string) *DescribeReadDBInstanceDelayResponseBodyItemsItemsReadonlyInstanceDelayReadonlyInstanceDelay {
	s.SendLatency = &v
	return s
}

func (s *DescribeReadDBInstanceDelayResponseBodyItemsItemsReadonlyInstanceDelayReadonlyInstanceDelay) SetWriteLag(v string) *DescribeReadDBInstanceDelayResponseBodyItemsItemsReadonlyInstanceDelayReadonlyInstanceDelay {
	s.WriteLag = &v
	return s
}

func (s *DescribeReadDBInstanceDelayResponseBodyItemsItemsReadonlyInstanceDelayReadonlyInstanceDelay) SetWriteLatency(v string) *DescribeReadDBInstanceDelayResponseBodyItemsItemsReadonlyInstanceDelayReadonlyInstanceDelay {
	s.WriteLatency = &v
	return s
}

type DescribeReadDBInstanceDelayResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeReadDBInstanceDelayResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeReadDBInstanceDelayResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeReadDBInstanceDelayResponse) GoString() string {
	return s.String()
}

func (s *DescribeReadDBInstanceDelayResponse) SetHeaders(v map[string]*string) *DescribeReadDBInstanceDelayResponse {
	s.Headers = v
	return s
}

func (s *DescribeReadDBInstanceDelayResponse) SetStatusCode(v int32) *DescribeReadDBInstanceDelayResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeReadDBInstanceDelayResponse) SetBody(v *DescribeReadDBInstanceDelayResponseBody) *DescribeReadDBInstanceDelayResponse {
	s.Body = v
	return s
}

type DescribeRegionInfosRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the generated token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	OwnerId     *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeRegionInfosRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeRegionInfosRequest) GoString() string {
	return s.String()
}

func (s *DescribeRegionInfosRequest) SetClientToken(v string) *DescribeRegionInfosRequest {
	s.ClientToken = &v
	return s
}

func (s *DescribeRegionInfosRequest) SetOwnerId(v int64) *DescribeRegionInfosRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeRegionInfosRequest) SetRegionId(v string) *DescribeRegionInfosRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeRegionInfosRequest) SetResourceOwnerAccount(v string) *DescribeRegionInfosRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeRegionInfosRequest) SetResourceOwnerId(v int64) *DescribeRegionInfosRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeRegionInfosResponseBody struct {
	// A list of regions.
	Regions *DescribeRegionInfosResponseBodyRegions `json:"Regions,omitempty" xml:"Regions,omitempty" type:"Struct"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeRegionInfosResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeRegionInfosResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeRegionInfosResponseBody) SetRegions(v *DescribeRegionInfosResponseBodyRegions) *DescribeRegionInfosResponseBody {
	s.Regions = v
	return s
}

func (s *DescribeRegionInfosResponseBody) SetRequestId(v string) *DescribeRegionInfosResponseBody {
	s.RequestId = &v
	return s
}

type DescribeRegionInfosResponseBodyRegions struct {
	RDSRegion []*DescribeRegionInfosResponseBodyRegionsRDSRegion `json:"RDSRegion,omitempty" xml:"RDSRegion,omitempty" type:"Repeated"`
}

func (s DescribeRegionInfosResponseBodyRegions) String() string {
	return tea.Prettify(s)
}

func (s DescribeRegionInfosResponseBodyRegions) GoString() string {
	return s.String()
}

func (s *DescribeRegionInfosResponseBodyRegions) SetRDSRegion(v []*DescribeRegionInfosResponseBodyRegionsRDSRegion) *DescribeRegionInfosResponseBodyRegions {
	s.RDSRegion = v
	return s
}

type DescribeRegionInfosResponseBodyRegionsRDSRegion struct {
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DescribeRegionInfosResponseBodyRegionsRDSRegion) String() string {
	return tea.Prettify(s)
}

func (s DescribeRegionInfosResponseBodyRegionsRDSRegion) GoString() string {
	return s.String()
}

func (s *DescribeRegionInfosResponseBodyRegionsRDSRegion) SetRegionId(v string) *DescribeRegionInfosResponseBodyRegionsRDSRegion {
	s.RegionId = &v
	return s
}

type DescribeRegionInfosResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeRegionInfosResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeRegionInfosResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeRegionInfosResponse) GoString() string {
	return s.String()
}

func (s *DescribeRegionInfosResponse) SetHeaders(v map[string]*string) *DescribeRegionInfosResponse {
	s.Headers = v
	return s
}

func (s *DescribeRegionInfosResponse) SetStatusCode(v int32) *DescribeRegionInfosResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeRegionInfosResponse) SetBody(v *DescribeRegionInfosResponseBody) *DescribeRegionInfosResponse {
	s.Body = v
	return s
}

type DescribeRegionsRequest struct {
	// The language that is used for the return value of the **LocalName** parameter. Valid values:
	//
	// *   **zh-CN**: Chinese
	// *   **en-US**: English
	//
	// Default value: **en-US**.
	AcceptLanguage  *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	ResourceOwnerId *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeRegionsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeRegionsRequest) GoString() string {
	return s.String()
}

func (s *DescribeRegionsRequest) SetAcceptLanguage(v string) *DescribeRegionsRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *DescribeRegionsRequest) SetResourceOwnerId(v int64) *DescribeRegionsRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeRegionsResponseBody struct {
	// An array that consists of the available regions and zones.
	Regions *DescribeRegionsResponseBodyRegions `json:"Regions,omitempty" xml:"Regions,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeRegionsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeRegionsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeRegionsResponseBody) SetRegions(v *DescribeRegionsResponseBodyRegions) *DescribeRegionsResponseBody {
	s.Regions = v
	return s
}

func (s *DescribeRegionsResponseBody) SetRequestId(v string) *DescribeRegionsResponseBody {
	s.RequestId = &v
	return s
}

type DescribeRegionsResponseBodyRegions struct {
	RDSRegion []*DescribeRegionsResponseBodyRegionsRDSRegion `json:"RDSRegion,omitempty" xml:"RDSRegion,omitempty" type:"Repeated"`
}

func (s DescribeRegionsResponseBodyRegions) String() string {
	return tea.Prettify(s)
}

func (s DescribeRegionsResponseBodyRegions) GoString() string {
	return s.String()
}

func (s *DescribeRegionsResponseBodyRegions) SetRDSRegion(v []*DescribeRegionsResponseBodyRegionsRDSRegion) *DescribeRegionsResponseBodyRegions {
	s.RDSRegion = v
	return s
}

type DescribeRegionsResponseBodyRegionsRDSRegion struct {
	// The name of the region. The return value of the LocalName parameter is in the language that is specified by the **AcceptLanguage** parameter. For example, if the value of the RegionId parameter in the response is cn-hangzhou, the following values are returned for the LocalName parameter:
	//
	// *   If the value of the **AcceptLanguage** parameter is **zh-CN**, the value 华东1（杭州） is returned for the LocalName parameter.
	// *   If the value of the **AcceptLanguage** parameter is **en-US**, the value China (Hangzhou) is returned for the LocalName parameter.
	LocalName *string `json:"LocalName,omitempty" xml:"LocalName,omitempty"`
	// The endpoint that is used to connect to Alibaba Cloud services in the region. For more information, see [Request structure](~~26223~~).
	RegionEndpoint *string `json:"RegionEndpoint,omitempty" xml:"RegionEndpoint,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the zone.
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
	// The name of the zone. The return value of the ZoneName parameter is in the language that is specified by the **AcceptLanguage** parameter. For example, if the value of the RegionId parameter in the response is cn-hangzhou-h, the following values are returned for the LocalName parameter:
	//
	// *   If the value of the **AcceptLanguage** parameter is **zh-CN**, the value 杭州 可用区H is returned for the LocalName parameter.
	// *   If the value of the **AcceptLanguage** parameter is **en-US**, the value Hangzhou Zone H is returned for the LocalName parameter.
	ZoneName *string `json:"ZoneName,omitempty" xml:"ZoneName,omitempty"`
}

func (s DescribeRegionsResponseBodyRegionsRDSRegion) String() string {
	return tea.Prettify(s)
}

func (s DescribeRegionsResponseBodyRegionsRDSRegion) GoString() string {
	return s.String()
}

func (s *DescribeRegionsResponseBodyRegionsRDSRegion) SetLocalName(v string) *DescribeRegionsResponseBodyRegionsRDSRegion {
	s.LocalName = &v
	return s
}

func (s *DescribeRegionsResponseBodyRegionsRDSRegion) SetRegionEndpoint(v string) *DescribeRegionsResponseBodyRegionsRDSRegion {
	s.RegionEndpoint = &v
	return s
}

func (s *DescribeRegionsResponseBodyRegionsRDSRegion) SetRegionId(v string) *DescribeRegionsResponseBodyRegionsRDSRegion {
	s.RegionId = &v
	return s
}

func (s *DescribeRegionsResponseBodyRegionsRDSRegion) SetZoneId(v string) *DescribeRegionsResponseBodyRegionsRDSRegion {
	s.ZoneId = &v
	return s
}

func (s *DescribeRegionsResponseBodyRegionsRDSRegion) SetZoneName(v string) *DescribeRegionsResponseBodyRegionsRDSRegion {
	s.ZoneName = &v
	return s
}

type DescribeRegionsResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeRegionsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeRegionsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeRegionsResponse) GoString() string {
	return s.String()
}

func (s *DescribeRegionsResponse) SetHeaders(v map[string]*string) *DescribeRegionsResponse {
	s.Headers = v
	return s
}

func (s *DescribeRegionsResponse) SetStatusCode(v int32) *DescribeRegionsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeRegionsResponse) SetBody(v *DescribeRegionsResponseBody) *DescribeRegionsResponse {
	s.Body = v
	return s
}

type DescribeRenewalPriceRequest struct {
	// The additional business information about the instance.
	BusinessInfo *string `json:"BusinessInfo,omitempty" xml:"BusinessInfo,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The instance type of the instance. For more information, see [Primary instance types](~~26312~~). By default, the current instance type applies.
	DBInstanceClass *string `json:"DBInstanceClass,omitempty" xml:"DBInstanceClass,omitempty"`
	// The instance ID. You can call the [DescribeDBInstances](~~610396~~) operation to query the instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The type of the order that you want to place. Set the value to **BUY**.
	OrderType    *string `json:"OrderType,omitempty" xml:"OrderType,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The billing method of the instance. Valid values:
	//
	// *   **Postpaid**: pay-as-you-go
	// *   **Prepaid**: subscription
	PayType *string `json:"PayType,omitempty" xml:"PayType,omitempty"`
	// The number of the instances. Default value: **1**.
	Quantity *int32 `json:"Quantity,omitempty" xml:"Quantity,omitempty"`
	// The region ID. You can call the [DescribeRegions](~~610399~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group. You can call the [DescribeDBInstanceAttribute](~~610394~~) operation to obtain the ID of the resource group.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The renewal cycle of the instance. Valid values:
	//
	// *   **Year**
	// *   **Month**
	TimeType *string `json:"TimeType,omitempty" xml:"TimeType,omitempty"`
	// The subscription duration of the instance. Valid values:
	//
	// *   If you set the **TimeType** parameter to **Year**, the value of the UsedTime parameter is within the range of **1 to 3**.
	// *   If you set the **TimeType** parameter to **Month**, the value of the UsedTime parameter is within the range of **1 to 9**.
	UsedTime *int32 `json:"UsedTime,omitempty" xml:"UsedTime,omitempty"`
}

func (s DescribeRenewalPriceRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeRenewalPriceRequest) GoString() string {
	return s.String()
}

func (s *DescribeRenewalPriceRequest) SetBusinessInfo(v string) *DescribeRenewalPriceRequest {
	s.BusinessInfo = &v
	return s
}

func (s *DescribeRenewalPriceRequest) SetClientToken(v string) *DescribeRenewalPriceRequest {
	s.ClientToken = &v
	return s
}

func (s *DescribeRenewalPriceRequest) SetDBInstanceClass(v string) *DescribeRenewalPriceRequest {
	s.DBInstanceClass = &v
	return s
}

func (s *DescribeRenewalPriceRequest) SetDBInstanceId(v string) *DescribeRenewalPriceRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeRenewalPriceRequest) SetOrderType(v string) *DescribeRenewalPriceRequest {
	s.OrderType = &v
	return s
}

func (s *DescribeRenewalPriceRequest) SetOwnerAccount(v string) *DescribeRenewalPriceRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeRenewalPriceRequest) SetOwnerId(v int64) *DescribeRenewalPriceRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeRenewalPriceRequest) SetPayType(v string) *DescribeRenewalPriceRequest {
	s.PayType = &v
	return s
}

func (s *DescribeRenewalPriceRequest) SetQuantity(v int32) *DescribeRenewalPriceRequest {
	s.Quantity = &v
	return s
}

func (s *DescribeRenewalPriceRequest) SetRegionId(v string) *DescribeRenewalPriceRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeRenewalPriceRequest) SetResourceGroupId(v string) *DescribeRenewalPriceRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeRenewalPriceRequest) SetResourceOwnerAccount(v string) *DescribeRenewalPriceRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeRenewalPriceRequest) SetResourceOwnerId(v int64) *DescribeRenewalPriceRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeRenewalPriceRequest) SetTimeType(v string) *DescribeRenewalPriceRequest {
	s.TimeType = &v
	return s
}

func (s *DescribeRenewalPriceRequest) SetUsedTime(v int32) *DescribeRenewalPriceRequest {
	s.UsedTime = &v
	return s
}

type DescribeRenewalPriceResponseBody struct {
	// Details of price information.
	PriceInfo *DescribeRenewalPriceResponseBodyPriceInfo `json:"PriceInfo,omitempty" xml:"PriceInfo,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// An array that consists of the details of the promotion rule.
	Rules *DescribeRenewalPriceResponseBodyRules `json:"Rules,omitempty" xml:"Rules,omitempty" type:"Struct"`
}

func (s DescribeRenewalPriceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeRenewalPriceResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeRenewalPriceResponseBody) SetPriceInfo(v *DescribeRenewalPriceResponseBodyPriceInfo) *DescribeRenewalPriceResponseBody {
	s.PriceInfo = v
	return s
}

func (s *DescribeRenewalPriceResponseBody) SetRequestId(v string) *DescribeRenewalPriceResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeRenewalPriceResponseBody) SetRules(v *DescribeRenewalPriceResponseBodyRules) *DescribeRenewalPriceResponseBody {
	s.Rules = v
	return s
}

type DescribeRenewalPriceResponseBodyPriceInfo struct {
	// The information about the promotion.
	ActivityInfo *DescribeRenewalPriceResponseBodyPriceInfoActivityInfo `json:"ActivityInfo,omitempty" xml:"ActivityInfo,omitempty" type:"Struct"`
	// An array that consists of information about the coupon.
	Coupons *DescribeRenewalPriceResponseBodyPriceInfoCoupons `json:"Coupons,omitempty" xml:"Coupons,omitempty" type:"Struct"`
	// The currency unit.
	Currency *string `json:"Currency,omitempty" xml:"Currency,omitempty"`
	// The discount.
	DiscountPrice *float32 `json:"DiscountPrice,omitempty" xml:"DiscountPrice,omitempty"`
	// The original price.
	OriginalPrice *float32 `json:"OriginalPrice,omitempty" xml:"OriginalPrice,omitempty"`
	// An array that consists of the ID of the promotion rule.
	RuleIds *DescribeRenewalPriceResponseBodyPriceInfoRuleIds `json:"RuleIds,omitempty" xml:"RuleIds,omitempty" type:"Struct"`
	// The transaction price, which is equal to the original price minus the discount.
	TradePrice *float32 `json:"TradePrice,omitempty" xml:"TradePrice,omitempty"`
}

func (s DescribeRenewalPriceResponseBodyPriceInfo) String() string {
	return tea.Prettify(s)
}

func (s DescribeRenewalPriceResponseBodyPriceInfo) GoString() string {
	return s.String()
}

func (s *DescribeRenewalPriceResponseBodyPriceInfo) SetActivityInfo(v *DescribeRenewalPriceResponseBodyPriceInfoActivityInfo) *DescribeRenewalPriceResponseBodyPriceInfo {
	s.ActivityInfo = v
	return s
}

func (s *DescribeRenewalPriceResponseBodyPriceInfo) SetCoupons(v *DescribeRenewalPriceResponseBodyPriceInfoCoupons) *DescribeRenewalPriceResponseBodyPriceInfo {
	s.Coupons = v
	return s
}

func (s *DescribeRenewalPriceResponseBodyPriceInfo) SetCurrency(v string) *DescribeRenewalPriceResponseBodyPriceInfo {
	s.Currency = &v
	return s
}

func (s *DescribeRenewalPriceResponseBodyPriceInfo) SetDiscountPrice(v float32) *DescribeRenewalPriceResponseBodyPriceInfo {
	s.DiscountPrice = &v
	return s
}

func (s *DescribeRenewalPriceResponseBodyPriceInfo) SetOriginalPrice(v float32) *DescribeRenewalPriceResponseBodyPriceInfo {
	s.OriginalPrice = &v
	return s
}

func (s *DescribeRenewalPriceResponseBodyPriceInfo) SetRuleIds(v *DescribeRenewalPriceResponseBodyPriceInfoRuleIds) *DescribeRenewalPriceResponseBodyPriceInfo {
	s.RuleIds = v
	return s
}

func (s *DescribeRenewalPriceResponseBodyPriceInfo) SetTradePrice(v float32) *DescribeRenewalPriceResponseBodyPriceInfo {
	s.TradePrice = &v
	return s
}

type DescribeRenewalPriceResponseBodyPriceInfoActivityInfo struct {
	// The returned message.
	CheckErrMsg *string `json:"CheckErrMsg,omitempty" xml:"CheckErrMsg,omitempty"`
	// The error code that is returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// Indicates whether the request was successful.
	Success *string `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DescribeRenewalPriceResponseBodyPriceInfoActivityInfo) String() string {
	return tea.Prettify(s)
}

func (s DescribeRenewalPriceResponseBodyPriceInfoActivityInfo) GoString() string {
	return s.String()
}

func (s *DescribeRenewalPriceResponseBodyPriceInfoActivityInfo) SetCheckErrMsg(v string) *DescribeRenewalPriceResponseBodyPriceInfoActivityInfo {
	s.CheckErrMsg = &v
	return s
}

func (s *DescribeRenewalPriceResponseBodyPriceInfoActivityInfo) SetErrorCode(v string) *DescribeRenewalPriceResponseBodyPriceInfoActivityInfo {
	s.ErrorCode = &v
	return s
}

func (s *DescribeRenewalPriceResponseBodyPriceInfoActivityInfo) SetSuccess(v string) *DescribeRenewalPriceResponseBodyPriceInfoActivityInfo {
	s.Success = &v
	return s
}

type DescribeRenewalPriceResponseBodyPriceInfoCoupons struct {
	Coupon []*DescribeRenewalPriceResponseBodyPriceInfoCouponsCoupon `json:"Coupon,omitempty" xml:"Coupon,omitempty" type:"Repeated"`
}

func (s DescribeRenewalPriceResponseBodyPriceInfoCoupons) String() string {
	return tea.Prettify(s)
}

func (s DescribeRenewalPriceResponseBodyPriceInfoCoupons) GoString() string {
	return s.String()
}

func (s *DescribeRenewalPriceResponseBodyPriceInfoCoupons) SetCoupon(v []*DescribeRenewalPriceResponseBodyPriceInfoCouponsCoupon) *DescribeRenewalPriceResponseBodyPriceInfoCoupons {
	s.Coupon = v
	return s
}

type DescribeRenewalPriceResponseBodyPriceInfoCouponsCoupon struct {
	// The coupon ID.
	CouponNo *string `json:"CouponNo,omitempty" xml:"CouponNo,omitempty"`
	// The description of the coupon.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// Indicates whether the coupon is selected.
	IsSelected *string `json:"IsSelected,omitempty" xml:"IsSelected,omitempty"`
	// The name of the coupon.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
}

func (s DescribeRenewalPriceResponseBodyPriceInfoCouponsCoupon) String() string {
	return tea.Prettify(s)
}

func (s DescribeRenewalPriceResponseBodyPriceInfoCouponsCoupon) GoString() string {
	return s.String()
}

func (s *DescribeRenewalPriceResponseBodyPriceInfoCouponsCoupon) SetCouponNo(v string) *DescribeRenewalPriceResponseBodyPriceInfoCouponsCoupon {
	s.CouponNo = &v
	return s
}

func (s *DescribeRenewalPriceResponseBodyPriceInfoCouponsCoupon) SetDescription(v string) *DescribeRenewalPriceResponseBodyPriceInfoCouponsCoupon {
	s.Description = &v
	return s
}

func (s *DescribeRenewalPriceResponseBodyPriceInfoCouponsCoupon) SetIsSelected(v string) *DescribeRenewalPriceResponseBodyPriceInfoCouponsCoupon {
	s.IsSelected = &v
	return s
}

func (s *DescribeRenewalPriceResponseBodyPriceInfoCouponsCoupon) SetName(v string) *DescribeRenewalPriceResponseBodyPriceInfoCouponsCoupon {
	s.Name = &v
	return s
}

type DescribeRenewalPriceResponseBodyPriceInfoRuleIds struct {
	RuleId []*string `json:"RuleId,omitempty" xml:"RuleId,omitempty" type:"Repeated"`
}

func (s DescribeRenewalPriceResponseBodyPriceInfoRuleIds) String() string {
	return tea.Prettify(s)
}

func (s DescribeRenewalPriceResponseBodyPriceInfoRuleIds) GoString() string {
	return s.String()
}

func (s *DescribeRenewalPriceResponseBodyPriceInfoRuleIds) SetRuleId(v []*string) *DescribeRenewalPriceResponseBodyPriceInfoRuleIds {
	s.RuleId = v
	return s
}

type DescribeRenewalPriceResponseBodyRules struct {
	Rule []*DescribeRenewalPriceResponseBodyRulesRule `json:"Rule,omitempty" xml:"Rule,omitempty" type:"Repeated"`
}

func (s DescribeRenewalPriceResponseBodyRules) String() string {
	return tea.Prettify(s)
}

func (s DescribeRenewalPriceResponseBodyRules) GoString() string {
	return s.String()
}

func (s *DescribeRenewalPriceResponseBodyRules) SetRule(v []*DescribeRenewalPriceResponseBodyRulesRule) *DescribeRenewalPriceResponseBodyRules {
	s.Rule = v
	return s
}

type DescribeRenewalPriceResponseBodyRulesRule struct {
	// The description of the activity.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The name of the rule.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the promotion rule.
	RuleId *int64 `json:"RuleId,omitempty" xml:"RuleId,omitempty"`
}

func (s DescribeRenewalPriceResponseBodyRulesRule) String() string {
	return tea.Prettify(s)
}

func (s DescribeRenewalPriceResponseBodyRulesRule) GoString() string {
	return s.String()
}

func (s *DescribeRenewalPriceResponseBodyRulesRule) SetDescription(v string) *DescribeRenewalPriceResponseBodyRulesRule {
	s.Description = &v
	return s
}

func (s *DescribeRenewalPriceResponseBodyRulesRule) SetName(v string) *DescribeRenewalPriceResponseBodyRulesRule {
	s.Name = &v
	return s
}

func (s *DescribeRenewalPriceResponseBodyRulesRule) SetRuleId(v int64) *DescribeRenewalPriceResponseBodyRulesRule {
	s.RuleId = &v
	return s
}

type DescribeRenewalPriceResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeRenewalPriceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeRenewalPriceResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeRenewalPriceResponse) GoString() string {
	return s.String()
}

func (s *DescribeRenewalPriceResponse) SetHeaders(v map[string]*string) *DescribeRenewalPriceResponse {
	s.Headers = v
	return s
}

func (s *DescribeRenewalPriceResponse) SetStatusCode(v int32) *DescribeRenewalPriceResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeRenewalPriceResponse) SetBody(v *DescribeRenewalPriceResponseBody) *DescribeRenewalPriceResponse {
	s.Body = v
	return s
}

type DescribeResourceDetailsRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the instance You can call the [DescribeDBInstances](~~26232~~) operation to query the IDs of instances.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID. You can call the [DescribeRegions](~~610399~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeResourceDetailsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeResourceDetailsRequest) GoString() string {
	return s.String()
}

func (s *DescribeResourceDetailsRequest) SetClientToken(v string) *DescribeResourceDetailsRequest {
	s.ClientToken = &v
	return s
}

func (s *DescribeResourceDetailsRequest) SetDBInstanceId(v string) *DescribeResourceDetailsRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeResourceDetailsRequest) SetOwnerId(v int64) *DescribeResourceDetailsRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeResourceDetailsRequest) SetRegionId(v string) *DescribeResourceDetailsRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeResourceDetailsRequest) SetResourceGroupId(v string) *DescribeResourceDetailsRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeResourceDetailsRequest) SetResourceOwnerAccount(v string) *DescribeResourceDetailsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeResourceDetailsRequest) SetResourceOwnerId(v int64) *DescribeResourceDetailsRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeResourceDetailsResponseBody struct {
	// The storage that is occupied by data backup files, excluding archived backup files, on the instance. Unit: bytes.
	BackupDataSize *int64 `json:"BackupDataSize,omitempty" xml:"BackupDataSize,omitempty"`
	// The storage that is occupied by log backup files, excluding archived backup files, on the instance. Unit: bytes.
	BackupLogSize *int64 `json:"BackupLogSize,omitempty" xml:"BackupLogSize,omitempty"`
	// The storage that is used to store backup files. Unit: bytes. The value -1 indicates that no backup files are stored.
	BackupSize *int64 `json:"BackupSize,omitempty" xml:"BackupSize,omitempty"`
	// Database Storage.
	DbInstanceStorage *int64 `json:"DbInstanceStorage,omitempty" xml:"DbInstanceStorage,omitempty"`
	// ProxyInstance name.
	DbProxyInstanceName *string `json:"DbProxyInstanceName,omitempty" xml:"DbProxyInstanceName,omitempty"`
	// The total storage that is occupied by data files and log files on the instance. Unit: bytes. The value -1 indicates that no data files or log files are stored on the instance.
	DiskUsed *int64 `json:"DiskUsed,omitempty" xml:"DiskUsed,omitempty"`
	// Instance StorageType
	InstanceStorageType *string `json:"InstanceStorageType,omitempty" xml:"InstanceStorageType,omitempty"`
	// Whitelist Rules.
	RdsEcsSecurityGroupRel []*DescribeResourceDetailsResponseBodyRdsEcsSecurityGroupRel `json:"RdsEcsSecurityGroupRel,omitempty" xml:"RdsEcsSecurityGroupRel,omitempty" type:"Repeated"`
	// The region ID of the instance.
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// Id of the request
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The IP address whitelist of the serverless instance. For more information, see [Use a database client or the CLI to connect to an ApsaraDB RDS for PostgreSQL instance](~~43185~~). If the IP address whitelist contains more than one entry, separate the entries with commas (,). Each entry must be unique. You can specify up to 1,000 entries. The entries in the IP address whitelist must be in one of the following formats:
	//
	// *   IP addresses, such as 10.10.XX.XX.
	// *   CIDR blocks, such as 10.10.XX.XX/24. In this example, 24 indicates that the prefix of each IP address in the IP address whitelist is 24 bits in length. You can replace 24 with a value within the range of 1 to 32.
	//
	// If this parameter is not specified, the default IP address whitelist is used.
	SecurityIPList *string `json:"SecurityIPList,omitempty" xml:"SecurityIPList,omitempty"`
	// The vSwitch ID.
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
	// VPC ID。
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s DescribeResourceDetailsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeResourceDetailsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeResourceDetailsResponseBody) SetBackupDataSize(v int64) *DescribeResourceDetailsResponseBody {
	s.BackupDataSize = &v
	return s
}

func (s *DescribeResourceDetailsResponseBody) SetBackupLogSize(v int64) *DescribeResourceDetailsResponseBody {
	s.BackupLogSize = &v
	return s
}

func (s *DescribeResourceDetailsResponseBody) SetBackupSize(v int64) *DescribeResourceDetailsResponseBody {
	s.BackupSize = &v
	return s
}

func (s *DescribeResourceDetailsResponseBody) SetDbInstanceStorage(v int64) *DescribeResourceDetailsResponseBody {
	s.DbInstanceStorage = &v
	return s
}

func (s *DescribeResourceDetailsResponseBody) SetDbProxyInstanceName(v string) *DescribeResourceDetailsResponseBody {
	s.DbProxyInstanceName = &v
	return s
}

func (s *DescribeResourceDetailsResponseBody) SetDiskUsed(v int64) *DescribeResourceDetailsResponseBody {
	s.DiskUsed = &v
	return s
}

func (s *DescribeResourceDetailsResponseBody) SetInstanceStorageType(v string) *DescribeResourceDetailsResponseBody {
	s.InstanceStorageType = &v
	return s
}

func (s *DescribeResourceDetailsResponseBody) SetRdsEcsSecurityGroupRel(v []*DescribeResourceDetailsResponseBodyRdsEcsSecurityGroupRel) *DescribeResourceDetailsResponseBody {
	s.RdsEcsSecurityGroupRel = v
	return s
}

func (s *DescribeResourceDetailsResponseBody) SetRegion(v string) *DescribeResourceDetailsResponseBody {
	s.Region = &v
	return s
}

func (s *DescribeResourceDetailsResponseBody) SetRequestId(v string) *DescribeResourceDetailsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeResourceDetailsResponseBody) SetResourceGroupId(v string) *DescribeResourceDetailsResponseBody {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeResourceDetailsResponseBody) SetSecurityIPList(v string) *DescribeResourceDetailsResponseBody {
	s.SecurityIPList = &v
	return s
}

func (s *DescribeResourceDetailsResponseBody) SetVSwitchId(v string) *DescribeResourceDetailsResponseBody {
	s.VSwitchId = &v
	return s
}

func (s *DescribeResourceDetailsResponseBody) SetVpcId(v string) *DescribeResourceDetailsResponseBody {
	s.VpcId = &v
	return s
}

type DescribeResourceDetailsResponseBodyRdsEcsSecurityGroupRel struct {
	// The name of the security group.
	SecurityGroupName *string `json:"SecurityGroupName,omitempty" xml:"SecurityGroupName,omitempty"`
}

func (s DescribeResourceDetailsResponseBodyRdsEcsSecurityGroupRel) String() string {
	return tea.Prettify(s)
}

func (s DescribeResourceDetailsResponseBodyRdsEcsSecurityGroupRel) GoString() string {
	return s.String()
}

func (s *DescribeResourceDetailsResponseBodyRdsEcsSecurityGroupRel) SetSecurityGroupName(v string) *DescribeResourceDetailsResponseBodyRdsEcsSecurityGroupRel {
	s.SecurityGroupName = &v
	return s
}

type DescribeResourceDetailsResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeResourceDetailsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeResourceDetailsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeResourceDetailsResponse) GoString() string {
	return s.String()
}

func (s *DescribeResourceDetailsResponse) SetHeaders(v map[string]*string) *DescribeResourceDetailsResponse {
	s.Headers = v
	return s
}

func (s *DescribeResourceDetailsResponse) SetStatusCode(v int32) *DescribeResourceDetailsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeResourceDetailsResponse) SetBody(v *DescribeResourceDetailsResponseBody) *DescribeResourceDetailsResponse {
	s.Body = v
	return s
}

type DescribeResourceUsageRequest struct {
	// The instance ID. You can call the [DescribeDBInstances](~~610396~~) operation to query the instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The resource group ID.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeResourceUsageRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeResourceUsageRequest) GoString() string {
	return s.String()
}

func (s *DescribeResourceUsageRequest) SetDBInstanceId(v string) *DescribeResourceUsageRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeResourceUsageRequest) SetOwnerAccount(v string) *DescribeResourceUsageRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeResourceUsageRequest) SetOwnerId(v int64) *DescribeResourceUsageRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeResourceUsageRequest) SetResourceGroupId(v string) *DescribeResourceUsageRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeResourceUsageRequest) SetResourceOwnerAccount(v string) *DescribeResourceUsageRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeResourceUsageRequest) SetResourceOwnerId(v int64) *DescribeResourceUsageRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeResourceUsageResponseBody struct {
	// The storage that is occupied by archived backup files on the instance. Unit: bytes.
	ArchiveBackupSize *int64 `json:"ArchiveBackupSize,omitempty" xml:"ArchiveBackupSize,omitempty"`
	// The storage that is occupied by data backup files, excluding archived backup files, on the instance. Unit: bytes.
	BackupDataSize *int64 `json:"BackupDataSize,omitempty" xml:"BackupDataSize,omitempty"`
	// The storage that is occupied by log backup files, excluding archived backup files, on the instance. Unit: bytes.
	BackupLogSize *int64 `json:"BackupLogSize,omitempty" xml:"BackupLogSize,omitempty"`
	// The size of data backup files that are stored in Object Storage Service (OSS) buckets. Unit: bytes. The value 0 indicates no data backup files are stored in OSS buckets.
	BackupOssDataSize *int64 `json:"BackupOssDataSize,omitempty" xml:"BackupOssDataSize,omitempty"`
	// The size of log backup files that are stored in OSS buckets. Unit: bytes. The value 0 indicates no log backup files are stored in OSS buckets.
	BackupOssLogSize *int64 `json:"BackupOssLogSize,omitempty" xml:"BackupOssLogSize,omitempty"`
	// The storage that is used to store backup files. Unit: bytes. The value -1 indicates that no backup files are stored.
	BackupSize *int64 `json:"BackupSize,omitempty" xml:"BackupSize,omitempty"`
	// The storage that is used to store cold backup files. Unit: bytes. The value -1 indicates that no cold backup files are stored.
	ColdBackupSize *int64 `json:"ColdBackupSize,omitempty" xml:"ColdBackupSize,omitempty"`
	// The instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The storage that is used to store data files. Unit: bytes. The value -1 indicates that no data files are stored.
	DataSize *int64 `json:"DataSize,omitempty" xml:"DataSize,omitempty"`
	// The total storage that is occupied by data files and log files on the instance. Unit: bytes. The value -1 indicates that no data files or log files are stored on the instance.
	DiskUsed *int64 `json:"DiskUsed,omitempty" xml:"DiskUsed,omitempty"`
	// The database engine of the instance.
	Engine *string `json:"Engine,omitempty" xml:"Engine,omitempty"`
	// The storage that is used to store log files. Unit: bytes. The value -1 indicates that no log files are stored.
	LogSize *int64 `json:"LogSize,omitempty" xml:"LogSize,omitempty"`
	// The backup storage for which you must pay. The system provides a free quota on backup storage. You must pay for the backup storage that exceeds the free quota. Unit: bytes.
	PaidBackupSize *int64 `json:"PaidBackupSize,omitempty" xml:"PaidBackupSize,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The storage that is occupied to execute SQL statements on the instance. Unit: bytes. The value -1 indicates that no SQL statements are executed.
	SQLSize *int64 `json:"SQLSize,omitempty" xml:"SQLSize,omitempty"`
}

func (s DescribeResourceUsageResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeResourceUsageResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeResourceUsageResponseBody) SetArchiveBackupSize(v int64) *DescribeResourceUsageResponseBody {
	s.ArchiveBackupSize = &v
	return s
}

func (s *DescribeResourceUsageResponseBody) SetBackupDataSize(v int64) *DescribeResourceUsageResponseBody {
	s.BackupDataSize = &v
	return s
}

func (s *DescribeResourceUsageResponseBody) SetBackupLogSize(v int64) *DescribeResourceUsageResponseBody {
	s.BackupLogSize = &v
	return s
}

func (s *DescribeResourceUsageResponseBody) SetBackupOssDataSize(v int64) *DescribeResourceUsageResponseBody {
	s.BackupOssDataSize = &v
	return s
}

func (s *DescribeResourceUsageResponseBody) SetBackupOssLogSize(v int64) *DescribeResourceUsageResponseBody {
	s.BackupOssLogSize = &v
	return s
}

func (s *DescribeResourceUsageResponseBody) SetBackupSize(v int64) *DescribeResourceUsageResponseBody {
	s.BackupSize = &v
	return s
}

func (s *DescribeResourceUsageResponseBody) SetColdBackupSize(v int64) *DescribeResourceUsageResponseBody {
	s.ColdBackupSize = &v
	return s
}

func (s *DescribeResourceUsageResponseBody) SetDBInstanceId(v string) *DescribeResourceUsageResponseBody {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeResourceUsageResponseBody) SetDataSize(v int64) *DescribeResourceUsageResponseBody {
	s.DataSize = &v
	return s
}

func (s *DescribeResourceUsageResponseBody) SetDiskUsed(v int64) *DescribeResourceUsageResponseBody {
	s.DiskUsed = &v
	return s
}

func (s *DescribeResourceUsageResponseBody) SetEngine(v string) *DescribeResourceUsageResponseBody {
	s.Engine = &v
	return s
}

func (s *DescribeResourceUsageResponseBody) SetLogSize(v int64) *DescribeResourceUsageResponseBody {
	s.LogSize = &v
	return s
}

func (s *DescribeResourceUsageResponseBody) SetPaidBackupSize(v int64) *DescribeResourceUsageResponseBody {
	s.PaidBackupSize = &v
	return s
}

func (s *DescribeResourceUsageResponseBody) SetRequestId(v string) *DescribeResourceUsageResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeResourceUsageResponseBody) SetSQLSize(v int64) *DescribeResourceUsageResponseBody {
	s.SQLSize = &v
	return s
}

type DescribeResourceUsageResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeResourceUsageResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeResourceUsageResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeResourceUsageResponse) GoString() string {
	return s.String()
}

func (s *DescribeResourceUsageResponse) SetHeaders(v map[string]*string) *DescribeResourceUsageResponse {
	s.Headers = v
	return s
}

func (s *DescribeResourceUsageResponse) SetStatusCode(v int32) *DescribeResourceUsageResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeResourceUsageResponse) SetBody(v *DescribeResourceUsageResponseBody) *DescribeResourceUsageResponse {
	s.Body = v
	return s
}

type DescribeSQLCollectorPolicyRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the resource group to which the instance belongs.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeSQLCollectorPolicyRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeSQLCollectorPolicyRequest) GoString() string {
	return s.String()
}

func (s *DescribeSQLCollectorPolicyRequest) SetClientToken(v string) *DescribeSQLCollectorPolicyRequest {
	s.ClientToken = &v
	return s
}

func (s *DescribeSQLCollectorPolicyRequest) SetDBInstanceId(v string) *DescribeSQLCollectorPolicyRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeSQLCollectorPolicyRequest) SetOwnerAccount(v string) *DescribeSQLCollectorPolicyRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeSQLCollectorPolicyRequest) SetOwnerId(v int64) *DescribeSQLCollectorPolicyRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeSQLCollectorPolicyRequest) SetResourceGroupId(v string) *DescribeSQLCollectorPolicyRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeSQLCollectorPolicyRequest) SetResourceOwnerAccount(v string) *DescribeSQLCollectorPolicyRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeSQLCollectorPolicyRequest) SetResourceOwnerId(v int64) *DescribeSQLCollectorPolicyRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeSQLCollectorPolicyResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The status of the SQL Explorer (SQL Audit) feature. Valid values:
	//
	// *   **Enable**
	// *   **Disabled**
	SQLCollectorStatus *string `json:"SQLCollectorStatus,omitempty" xml:"SQLCollectorStatus,omitempty"`
	// None
	StoragePeriod *int32 `json:"StoragePeriod,omitempty" xml:"StoragePeriod,omitempty"`
}

func (s DescribeSQLCollectorPolicyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeSQLCollectorPolicyResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeSQLCollectorPolicyResponseBody) SetRequestId(v string) *DescribeSQLCollectorPolicyResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeSQLCollectorPolicyResponseBody) SetSQLCollectorStatus(v string) *DescribeSQLCollectorPolicyResponseBody {
	s.SQLCollectorStatus = &v
	return s
}

func (s *DescribeSQLCollectorPolicyResponseBody) SetStoragePeriod(v int32) *DescribeSQLCollectorPolicyResponseBody {
	s.StoragePeriod = &v
	return s
}

type DescribeSQLCollectorPolicyResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeSQLCollectorPolicyResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeSQLCollectorPolicyResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeSQLCollectorPolicyResponse) GoString() string {
	return s.String()
}

func (s *DescribeSQLCollectorPolicyResponse) SetHeaders(v map[string]*string) *DescribeSQLCollectorPolicyResponse {
	s.Headers = v
	return s
}

func (s *DescribeSQLCollectorPolicyResponse) SetStatusCode(v int32) *DescribeSQLCollectorPolicyResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeSQLCollectorPolicyResponse) SetBody(v *DescribeSQLCollectorPolicyResponseBody) *DescribeSQLCollectorPolicyResponse {
	s.Body = v
	return s
}

type DescribeSQLCollectorRetentionRequest struct {
	// The ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the resource group to which the instance belongs.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	SecurityToken        *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s DescribeSQLCollectorRetentionRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeSQLCollectorRetentionRequest) GoString() string {
	return s.String()
}

func (s *DescribeSQLCollectorRetentionRequest) SetDBInstanceId(v string) *DescribeSQLCollectorRetentionRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeSQLCollectorRetentionRequest) SetOwnerAccount(v string) *DescribeSQLCollectorRetentionRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeSQLCollectorRetentionRequest) SetOwnerId(v int64) *DescribeSQLCollectorRetentionRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeSQLCollectorRetentionRequest) SetResourceGroupId(v string) *DescribeSQLCollectorRetentionRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeSQLCollectorRetentionRequest) SetResourceOwnerAccount(v string) *DescribeSQLCollectorRetentionRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeSQLCollectorRetentionRequest) SetResourceOwnerId(v int64) *DescribeSQLCollectorRetentionRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeSQLCollectorRetentionRequest) SetSecurityToken(v string) *DescribeSQLCollectorRetentionRequest {
	s.SecurityToken = &v
	return s
}

type DescribeSQLCollectorRetentionResponseBody struct {
	// The log backup retention duration that is allowed by the SQL explorer feature on the instance. Valid values:
	//
	// *   **30:** 30 days
	// *   **180:** 180 days
	// *   **365:** one year
	// *   **1095:** three years
	// *   **1825:** five years
	ConfigValue *string `json:"ConfigValue,omitempty" xml:"ConfigValue,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeSQLCollectorRetentionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeSQLCollectorRetentionResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeSQLCollectorRetentionResponseBody) SetConfigValue(v string) *DescribeSQLCollectorRetentionResponseBody {
	s.ConfigValue = &v
	return s
}

func (s *DescribeSQLCollectorRetentionResponseBody) SetRequestId(v string) *DescribeSQLCollectorRetentionResponseBody {
	s.RequestId = &v
	return s
}

type DescribeSQLCollectorRetentionResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeSQLCollectorRetentionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeSQLCollectorRetentionResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeSQLCollectorRetentionResponse) GoString() string {
	return s.String()
}

func (s *DescribeSQLCollectorRetentionResponse) SetHeaders(v map[string]*string) *DescribeSQLCollectorRetentionResponse {
	s.Headers = v
	return s
}

func (s *DescribeSQLCollectorRetentionResponse) SetStatusCode(v int32) *DescribeSQLCollectorRetentionResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeSQLCollectorRetentionResponse) SetBody(v *DescribeSQLCollectorRetentionResponseBody) *DescribeSQLCollectorRetentionResponse {
	s.Body = v
	return s
}

type DescribeSQLLogFilesRequest struct {
	// The ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The name of the audit log file.
	FileName     *string `json:"FileName,omitempty" xml:"FileName,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of the page to return. Valid values: **1 to 100000**. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Valid value: **30 to 200**. Default value: **30**.
	PageSize             *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeSQLLogFilesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeSQLLogFilesRequest) GoString() string {
	return s.String()
}

func (s *DescribeSQLLogFilesRequest) SetDBInstanceId(v string) *DescribeSQLLogFilesRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeSQLLogFilesRequest) SetFileName(v string) *DescribeSQLLogFilesRequest {
	s.FileName = &v
	return s
}

func (s *DescribeSQLLogFilesRequest) SetOwnerAccount(v string) *DescribeSQLLogFilesRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeSQLLogFilesRequest) SetOwnerId(v int64) *DescribeSQLLogFilesRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeSQLLogFilesRequest) SetPageNumber(v int32) *DescribeSQLLogFilesRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeSQLLogFilesRequest) SetPageSize(v int32) *DescribeSQLLogFilesRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeSQLLogFilesRequest) SetResourceOwnerAccount(v string) *DescribeSQLLogFilesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeSQLLogFilesRequest) SetResourceOwnerId(v int64) *DescribeSQLLogFilesRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeSQLLogFilesResponseBody struct {
	// An array that consists of the returned audit log files.
	Items *DescribeSQLLogFilesResponseBodyItems `json:"Items,omitempty" xml:"Items,omitempty" type:"Struct"`
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageRecordCount *int32 `json:"PageRecordCount,omitempty" xml:"PageRecordCount,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalRecordCount *int32 `json:"TotalRecordCount,omitempty" xml:"TotalRecordCount,omitempty"`
}

func (s DescribeSQLLogFilesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeSQLLogFilesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeSQLLogFilesResponseBody) SetItems(v *DescribeSQLLogFilesResponseBodyItems) *DescribeSQLLogFilesResponseBody {
	s.Items = v
	return s
}

func (s *DescribeSQLLogFilesResponseBody) SetPageNumber(v int32) *DescribeSQLLogFilesResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeSQLLogFilesResponseBody) SetPageRecordCount(v int32) *DescribeSQLLogFilesResponseBody {
	s.PageRecordCount = &v
	return s
}

func (s *DescribeSQLLogFilesResponseBody) SetRequestId(v string) *DescribeSQLLogFilesResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeSQLLogFilesResponseBody) SetTotalRecordCount(v int32) *DescribeSQLLogFilesResponseBody {
	s.TotalRecordCount = &v
	return s
}

type DescribeSQLLogFilesResponseBodyItems struct {
	LogFile []*DescribeSQLLogFilesResponseBodyItemsLogFile `json:"LogFile,omitempty" xml:"LogFile,omitempty" type:"Repeated"`
}

func (s DescribeSQLLogFilesResponseBodyItems) String() string {
	return tea.Prettify(s)
}

func (s DescribeSQLLogFilesResponseBodyItems) GoString() string {
	return s.String()
}

func (s *DescribeSQLLogFilesResponseBodyItems) SetLogFile(v []*DescribeSQLLogFilesResponseBodyItemsLogFile) *DescribeSQLLogFilesResponseBodyItems {
	s.LogFile = v
	return s
}

type DescribeSQLLogFilesResponseBodyItemsLogFile struct {
	// The name of the file.
	FileID *string `json:"FileID,omitempty" xml:"FileID,omitempty"`
	// The download URL of the file. If the audit log file cannot be downloaded, this parameter is null.
	LogDownloadURL *string `json:"LogDownloadURL,omitempty" xml:"LogDownloadURL,omitempty"`
	// The time at which the last SQL statement recorded in the audit log file was executed. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	LogEndTime *string `json:"LogEndTime,omitempty" xml:"LogEndTime,omitempty"`
	// The size of the audit log file. Unit: bytes.
	LogSize *string `json:"LogSize,omitempty" xml:"LogSize,omitempty"`
	// The time at which the first SQL statement recorded in the audit log file was executed. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	LogStartTime *string `json:"LogStartTime,omitempty" xml:"LogStartTime,omitempty"`
	// The status of the audit log file. Valid values:
	//
	// *   **Success**
	// *   **Failed**
	// *   **Generating**
	LogStatus *string `json:"LogStatus,omitempty" xml:"LogStatus,omitempty"`
}

func (s DescribeSQLLogFilesResponseBodyItemsLogFile) String() string {
	return tea.Prettify(s)
}

func (s DescribeSQLLogFilesResponseBodyItemsLogFile) GoString() string {
	return s.String()
}

func (s *DescribeSQLLogFilesResponseBodyItemsLogFile) SetFileID(v string) *DescribeSQLLogFilesResponseBodyItemsLogFile {
	s.FileID = &v
	return s
}

func (s *DescribeSQLLogFilesResponseBodyItemsLogFile) SetLogDownloadURL(v string) *DescribeSQLLogFilesResponseBodyItemsLogFile {
	s.LogDownloadURL = &v
	return s
}

func (s *DescribeSQLLogFilesResponseBodyItemsLogFile) SetLogEndTime(v string) *DescribeSQLLogFilesResponseBodyItemsLogFile {
	s.LogEndTime = &v
	return s
}

func (s *DescribeSQLLogFilesResponseBodyItemsLogFile) SetLogSize(v string) *DescribeSQLLogFilesResponseBodyItemsLogFile {
	s.LogSize = &v
	return s
}

func (s *DescribeSQLLogFilesResponseBodyItemsLogFile) SetLogStartTime(v string) *DescribeSQLLogFilesResponseBodyItemsLogFile {
	s.LogStartTime = &v
	return s
}

func (s *DescribeSQLLogFilesResponseBodyItemsLogFile) SetLogStatus(v string) *DescribeSQLLogFilesResponseBodyItemsLogFile {
	s.LogStatus = &v
	return s
}

type DescribeSQLLogFilesResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeSQLLogFilesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeSQLLogFilesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeSQLLogFilesResponse) GoString() string {
	return s.String()
}

func (s *DescribeSQLLogFilesResponse) SetHeaders(v map[string]*string) *DescribeSQLLogFilesResponse {
	s.Headers = v
	return s
}

func (s *DescribeSQLLogFilesResponse) SetStatusCode(v int32) *DescribeSQLLogFilesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeSQLLogFilesResponse) SetBody(v *DescribeSQLLogFilesResponseBody) *DescribeSQLLogFilesResponse {
	s.Body = v
	return s
}

type DescribeSQLLogRecordsRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The name of the database. You can enter only one database name. If you specify this parameter, this operation returns the logs that are generated only for the specified database. If you do not specify this parameter, this operation returns the logs that are generated for all databases on the instance.
	Database *string `json:"Database,omitempty" xml:"Database,omitempty"`
	// The end of the time range to query. The end time must be later than the start time. The time span between the start time and the end time must be less than 30 days. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// Specifies whether to generate an SQL audit log file or return SQL audit log entries. Valid values:
	//
	// *   **File**: If you set this parameter to File, this operation generates an SQL audit log file and returns only common response parameters. After you call this operation, you must call the [DescribeSQLLogFiles](~~26295~~) operation to obtain the download URL of the SQL audit log file.
	// *   **Stream** (default): If you set this parameter to Stream, this operation returns SQL audit log entries.
	//
	// > If you set this parameter to **File**, only ApsaraDB RDS for MySQL instances that use local disks and ApsaraDB RDS for SQL Server instances are supported, and a maximum of 1 million log entries are returned.
	Form         *string `json:"Form,omitempty" xml:"Form,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of the page to return. Valid values: any non-zero positive integer.
	//
	// Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Valid values: **30** to **100**. Default value: **30**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The keyword that is used for the query.
	//
	// *   When you call this operation and set the **Form** parameter to **File** to generate an audit file, you cannot filter log entries by keyword.
	// *   You can specify up to 10 keywords. The keywords are evaluated by using the **AND** operator. Separate multiple keywords with spaces.
	// *   If a field name in the specified SQL statement is enclosed in backquotes (\`) and you want to use the field name as a keyword, you must enter the backquotes (\`) as part of the field name. For example, if the field name is \*\*\`id\`**, enter **\`id\`** rather than **id\*\*.
	//
	// > After you enter a keyword, the system matches the keyword based on the **Database**, **User**, and **QueryKeywords** parameters. The parameters are evaluated by using the **OR** operator.
	QueryKeywords        *string `json:"QueryKeywords,omitempty" xml:"QueryKeywords,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The unique ID of the SQL statement.
	SQLId *int64 `json:"SQLId,omitempty" xml:"SQLId,omitempty"`
	// The beginning of the time range to query. You can query data in the last 15 days before the current date. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The username of the account. You can enter only one username. If you specify this parameter, this operation returns the logs that are generated only for the specified account. If you do not specify this parameter, this operation returns the logs that are generated for all accounts on the instance.
	User *string `json:"User,omitempty" xml:"User,omitempty"`
}

func (s DescribeSQLLogRecordsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeSQLLogRecordsRequest) GoString() string {
	return s.String()
}

func (s *DescribeSQLLogRecordsRequest) SetClientToken(v string) *DescribeSQLLogRecordsRequest {
	s.ClientToken = &v
	return s
}

func (s *DescribeSQLLogRecordsRequest) SetDBInstanceId(v string) *DescribeSQLLogRecordsRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeSQLLogRecordsRequest) SetDatabase(v string) *DescribeSQLLogRecordsRequest {
	s.Database = &v
	return s
}

func (s *DescribeSQLLogRecordsRequest) SetEndTime(v string) *DescribeSQLLogRecordsRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeSQLLogRecordsRequest) SetForm(v string) *DescribeSQLLogRecordsRequest {
	s.Form = &v
	return s
}

func (s *DescribeSQLLogRecordsRequest) SetOwnerAccount(v string) *DescribeSQLLogRecordsRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeSQLLogRecordsRequest) SetOwnerId(v int64) *DescribeSQLLogRecordsRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeSQLLogRecordsRequest) SetPageNumber(v int32) *DescribeSQLLogRecordsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeSQLLogRecordsRequest) SetPageSize(v int32) *DescribeSQLLogRecordsRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeSQLLogRecordsRequest) SetQueryKeywords(v string) *DescribeSQLLogRecordsRequest {
	s.QueryKeywords = &v
	return s
}

func (s *DescribeSQLLogRecordsRequest) SetResourceOwnerAccount(v string) *DescribeSQLLogRecordsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeSQLLogRecordsRequest) SetResourceOwnerId(v int64) *DescribeSQLLogRecordsRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeSQLLogRecordsRequest) SetSQLId(v int64) *DescribeSQLLogRecordsRequest {
	s.SQLId = &v
	return s
}

func (s *DescribeSQLLogRecordsRequest) SetStartTime(v string) *DescribeSQLLogRecordsRequest {
	s.StartTime = &v
	return s
}

func (s *DescribeSQLLogRecordsRequest) SetUser(v string) *DescribeSQLLogRecordsRequest {
	s.User = &v
	return s
}

type DescribeSQLLogRecordsResponseBody struct {
	// An array that consists of the details about each SQL audit log entry.
	Items *DescribeSQLLogRecordsResponseBodyItems `json:"Items,omitempty" xml:"Items,omitempty" type:"Struct"`
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of SQL audit log entries on the current page.
	PageRecordCount *int32 `json:"PageRecordCount,omitempty" xml:"PageRecordCount,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalRecordCount *int64 `json:"TotalRecordCount,omitempty" xml:"TotalRecordCount,omitempty"`
}

func (s DescribeSQLLogRecordsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeSQLLogRecordsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeSQLLogRecordsResponseBody) SetItems(v *DescribeSQLLogRecordsResponseBodyItems) *DescribeSQLLogRecordsResponseBody {
	s.Items = v
	return s
}

func (s *DescribeSQLLogRecordsResponseBody) SetPageNumber(v int32) *DescribeSQLLogRecordsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeSQLLogRecordsResponseBody) SetPageRecordCount(v int32) *DescribeSQLLogRecordsResponseBody {
	s.PageRecordCount = &v
	return s
}

func (s *DescribeSQLLogRecordsResponseBody) SetRequestId(v string) *DescribeSQLLogRecordsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeSQLLogRecordsResponseBody) SetTotalRecordCount(v int64) *DescribeSQLLogRecordsResponseBody {
	s.TotalRecordCount = &v
	return s
}

type DescribeSQLLogRecordsResponseBodyItems struct {
	SQLRecord []*DescribeSQLLogRecordsResponseBodyItemsSQLRecord `json:"SQLRecord,omitempty" xml:"SQLRecord,omitempty" type:"Repeated"`
}

func (s DescribeSQLLogRecordsResponseBodyItems) String() string {
	return tea.Prettify(s)
}

func (s DescribeSQLLogRecordsResponseBodyItems) GoString() string {
	return s.String()
}

func (s *DescribeSQLLogRecordsResponseBodyItems) SetSQLRecord(v []*DescribeSQLLogRecordsResponseBodyItemsSQLRecord) *DescribeSQLLogRecordsResponseBodyItems {
	s.SQLRecord = v
	return s
}

type DescribeSQLLogRecordsResponseBodyItemsSQLRecord struct {
	// The username of the account that is recorded in the SQL audit log entry.
	AccountName *string `json:"AccountName,omitempty" xml:"AccountName,omitempty"`
	// The name of the database.
	DBName *string `json:"DBName,omitempty" xml:"DBName,omitempty"`
	// The time at which the SQL statement was executed. The time follows the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	ExecuteTime *string `json:"ExecuteTime,omitempty" xml:"ExecuteTime,omitempty"`
	// The IP address of the client that is connected to the instance.
	HostAddress *string `json:"HostAddress,omitempty" xml:"HostAddress,omitempty"`
	// The number of SQL audit log entries that are returned.
	ReturnRowCounts *int64 `json:"ReturnRowCounts,omitempty" xml:"ReturnRowCounts,omitempty"`
	// The SQL statement that is executed in the query.
	SQLText *string `json:"SQLText,omitempty" xml:"SQLText,omitempty"`
	// The ID of the thread.
	ThreadID *string `json:"ThreadID,omitempty" xml:"ThreadID,omitempty"`
	// The execution duration of the SQL statement. Unit: microseconds.
	TotalExecutionTimes *int64 `json:"TotalExecutionTimes,omitempty" xml:"TotalExecutionTimes,omitempty"`
}

func (s DescribeSQLLogRecordsResponseBodyItemsSQLRecord) String() string {
	return tea.Prettify(s)
}

func (s DescribeSQLLogRecordsResponseBodyItemsSQLRecord) GoString() string {
	return s.String()
}

func (s *DescribeSQLLogRecordsResponseBodyItemsSQLRecord) SetAccountName(v string) *DescribeSQLLogRecordsResponseBodyItemsSQLRecord {
	s.AccountName = &v
	return s
}

func (s *DescribeSQLLogRecordsResponseBodyItemsSQLRecord) SetDBName(v string) *DescribeSQLLogRecordsResponseBodyItemsSQLRecord {
	s.DBName = &v
	return s
}

func (s *DescribeSQLLogRecordsResponseBodyItemsSQLRecord) SetExecuteTime(v string) *DescribeSQLLogRecordsResponseBodyItemsSQLRecord {
	s.ExecuteTime = &v
	return s
}

func (s *DescribeSQLLogRecordsResponseBodyItemsSQLRecord) SetHostAddress(v string) *DescribeSQLLogRecordsResponseBodyItemsSQLRecord {
	s.HostAddress = &v
	return s
}

func (s *DescribeSQLLogRecordsResponseBodyItemsSQLRecord) SetReturnRowCounts(v int64) *DescribeSQLLogRecordsResponseBodyItemsSQLRecord {
	s.ReturnRowCounts = &v
	return s
}

func (s *DescribeSQLLogRecordsResponseBodyItemsSQLRecord) SetSQLText(v string) *DescribeSQLLogRecordsResponseBodyItemsSQLRecord {
	s.SQLText = &v
	return s
}

func (s *DescribeSQLLogRecordsResponseBodyItemsSQLRecord) SetThreadID(v string) *DescribeSQLLogRecordsResponseBodyItemsSQLRecord {
	s.ThreadID = &v
	return s
}

func (s *DescribeSQLLogRecordsResponseBodyItemsSQLRecord) SetTotalExecutionTimes(v int64) *DescribeSQLLogRecordsResponseBodyItemsSQLRecord {
	s.TotalExecutionTimes = &v
	return s
}

type DescribeSQLLogRecordsResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeSQLLogRecordsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeSQLLogRecordsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeSQLLogRecordsResponse) GoString() string {
	return s.String()
}

func (s *DescribeSQLLogRecordsResponse) SetHeaders(v map[string]*string) *DescribeSQLLogRecordsResponse {
	s.Headers = v
	return s
}

func (s *DescribeSQLLogRecordsResponse) SetStatusCode(v int32) *DescribeSQLLogRecordsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeSQLLogRecordsResponse) SetBody(v *DescribeSQLLogRecordsResponseBody) *DescribeSQLLogRecordsResponse {
	s.Body = v
	return s
}

type DescribeSQLLogReportListRequest struct {
	// The ID of the instance. You can call the [DescribeDBInstances](~~26232~~) operation to query the IDs of instances.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The end of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
	//
	// >  The end time must be later than the start time.
	EndTime      *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of the page to return. Valid values: any **non-zero** positive integer.
	//
	// Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Valid values:
	//
	// *   **30**
	// *   **50**
	// *   **100**
	//
	// Default value: **30**.
	PageSize             *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeSQLLogReportListRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeSQLLogReportListRequest) GoString() string {
	return s.String()
}

func (s *DescribeSQLLogReportListRequest) SetDBInstanceId(v string) *DescribeSQLLogReportListRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeSQLLogReportListRequest) SetEndTime(v string) *DescribeSQLLogReportListRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeSQLLogReportListRequest) SetOwnerAccount(v string) *DescribeSQLLogReportListRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeSQLLogReportListRequest) SetOwnerId(v int64) *DescribeSQLLogReportListRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeSQLLogReportListRequest) SetPageNumber(v int32) *DescribeSQLLogReportListRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeSQLLogReportListRequest) SetPageSize(v int32) *DescribeSQLLogReportListRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeSQLLogReportListRequest) SetResourceOwnerAccount(v string) *DescribeSQLLogReportListRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeSQLLogReportListRequest) SetResourceOwnerId(v int64) *DescribeSQLLogReportListRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeSQLLogReportListRequest) SetStartTime(v string) *DescribeSQLLogReportListRequest {
	s.StartTime = &v
	return s
}

type DescribeSQLLogReportListResponseBody struct {
	// An array that consists of SQL log reports.
	Items *DescribeSQLLogReportListResponseBodyItems `json:"Items,omitempty" xml:"Items,omitempty" type:"Struct"`
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of reports on the current page.
	PageRecordCount *int32 `json:"PageRecordCount,omitempty" xml:"PageRecordCount,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of records returned.
	TotalRecordCount *int32 `json:"TotalRecordCount,omitempty" xml:"TotalRecordCount,omitempty"`
}

func (s DescribeSQLLogReportListResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeSQLLogReportListResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeSQLLogReportListResponseBody) SetItems(v *DescribeSQLLogReportListResponseBodyItems) *DescribeSQLLogReportListResponseBody {
	s.Items = v
	return s
}

func (s *DescribeSQLLogReportListResponseBody) SetPageNumber(v int32) *DescribeSQLLogReportListResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeSQLLogReportListResponseBody) SetPageRecordCount(v int32) *DescribeSQLLogReportListResponseBody {
	s.PageRecordCount = &v
	return s
}

func (s *DescribeSQLLogReportListResponseBody) SetRequestId(v string) *DescribeSQLLogReportListResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeSQLLogReportListResponseBody) SetTotalRecordCount(v int32) *DescribeSQLLogReportListResponseBody {
	s.TotalRecordCount = &v
	return s
}

type DescribeSQLLogReportListResponseBodyItems struct {
	Item []*DescribeSQLLogReportListResponseBodyItemsItem `json:"Item,omitempty" xml:"Item,omitempty" type:"Repeated"`
}

func (s DescribeSQLLogReportListResponseBodyItems) String() string {
	return tea.Prettify(s)
}

func (s DescribeSQLLogReportListResponseBodyItems) GoString() string {
	return s.String()
}

func (s *DescribeSQLLogReportListResponseBodyItems) SetItem(v []*DescribeSQLLogReportListResponseBodyItemsItem) *DescribeSQLLogReportListResponseBodyItems {
	s.Item = v
	return s
}

type DescribeSQLLogReportListResponseBodyItemsItem struct {
	// An array that consists of SQL statements executed with the highest latency.
	LatencyTopNItems *DescribeSQLLogReportListResponseBodyItemsItemLatencyTopNItems `json:"LatencyTopNItems,omitempty" xml:"LatencyTopNItems,omitempty" type:"Struct"`
	// An array that consists of SQL statements executed the most frequently.
	QPSTopNItems *DescribeSQLLogReportListResponseBodyItemsItemQPSTopNItems `json:"QPSTopNItems,omitempty" xml:"QPSTopNItems,omitempty" type:"Struct"`
	// The time when the report was generated. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	ReportTime *string `json:"ReportTime,omitempty" xml:"ReportTime,omitempty"`
}

func (s DescribeSQLLogReportListResponseBodyItemsItem) String() string {
	return tea.Prettify(s)
}

func (s DescribeSQLLogReportListResponseBodyItemsItem) GoString() string {
	return s.String()
}

func (s *DescribeSQLLogReportListResponseBodyItemsItem) SetLatencyTopNItems(v *DescribeSQLLogReportListResponseBodyItemsItemLatencyTopNItems) *DescribeSQLLogReportListResponseBodyItemsItem {
	s.LatencyTopNItems = v
	return s
}

func (s *DescribeSQLLogReportListResponseBodyItemsItem) SetQPSTopNItems(v *DescribeSQLLogReportListResponseBodyItemsItemQPSTopNItems) *DescribeSQLLogReportListResponseBodyItemsItem {
	s.QPSTopNItems = v
	return s
}

func (s *DescribeSQLLogReportListResponseBodyItemsItem) SetReportTime(v string) *DescribeSQLLogReportListResponseBodyItemsItem {
	s.ReportTime = &v
	return s
}

type DescribeSQLLogReportListResponseBodyItemsItemLatencyTopNItems struct {
	LatencyTopNItem []*DescribeSQLLogReportListResponseBodyItemsItemLatencyTopNItemsLatencyTopNItem `json:"LatencyTopNItem,omitempty" xml:"LatencyTopNItem,omitempty" type:"Repeated"`
}

func (s DescribeSQLLogReportListResponseBodyItemsItemLatencyTopNItems) String() string {
	return tea.Prettify(s)
}

func (s DescribeSQLLogReportListResponseBodyItemsItemLatencyTopNItems) GoString() string {
	return s.String()
}

func (s *DescribeSQLLogReportListResponseBodyItemsItemLatencyTopNItems) SetLatencyTopNItem(v []*DescribeSQLLogReportListResponseBodyItemsItemLatencyTopNItemsLatencyTopNItem) *DescribeSQLLogReportListResponseBodyItemsItemLatencyTopNItems {
	s.LatencyTopNItem = v
	return s
}

type DescribeSQLLogReportListResponseBodyItemsItemLatencyTopNItemsLatencyTopNItem struct {
	// The average time that is required to execute the SQL statement. Unit: milliseconds.
	AvgLatency *int64 `json:"AvgLatency,omitempty" xml:"AvgLatency,omitempty"`
	// The number of times that the SQL statement is executed.
	SQLExecuteTimes *int64 `json:"SQLExecuteTimes,omitempty" xml:"SQLExecuteTimes,omitempty"`
	// The SQL statement returned.
	//
	// >  Only the first 128 characters of the SQL statement are returned. In addition, only the SQL statements that take more than 100 ms to execute are returned.
	SQLText *string `json:"SQLText,omitempty" xml:"SQLText,omitempty"`
}

func (s DescribeSQLLogReportListResponseBodyItemsItemLatencyTopNItemsLatencyTopNItem) String() string {
	return tea.Prettify(s)
}

func (s DescribeSQLLogReportListResponseBodyItemsItemLatencyTopNItemsLatencyTopNItem) GoString() string {
	return s.String()
}

func (s *DescribeSQLLogReportListResponseBodyItemsItemLatencyTopNItemsLatencyTopNItem) SetAvgLatency(v int64) *DescribeSQLLogReportListResponseBodyItemsItemLatencyTopNItemsLatencyTopNItem {
	s.AvgLatency = &v
	return s
}

func (s *DescribeSQLLogReportListResponseBodyItemsItemLatencyTopNItemsLatencyTopNItem) SetSQLExecuteTimes(v int64) *DescribeSQLLogReportListResponseBodyItemsItemLatencyTopNItemsLatencyTopNItem {
	s.SQLExecuteTimes = &v
	return s
}

func (s *DescribeSQLLogReportListResponseBodyItemsItemLatencyTopNItemsLatencyTopNItem) SetSQLText(v string) *DescribeSQLLogReportListResponseBodyItemsItemLatencyTopNItemsLatencyTopNItem {
	s.SQLText = &v
	return s
}

type DescribeSQLLogReportListResponseBodyItemsItemQPSTopNItems struct {
	QPSTopNItem []*DescribeSQLLogReportListResponseBodyItemsItemQPSTopNItemsQPSTopNItem `json:"QPSTopNItem,omitempty" xml:"QPSTopNItem,omitempty" type:"Repeated"`
}

func (s DescribeSQLLogReportListResponseBodyItemsItemQPSTopNItems) String() string {
	return tea.Prettify(s)
}

func (s DescribeSQLLogReportListResponseBodyItemsItemQPSTopNItems) GoString() string {
	return s.String()
}

func (s *DescribeSQLLogReportListResponseBodyItemsItemQPSTopNItems) SetQPSTopNItem(v []*DescribeSQLLogReportListResponseBodyItemsItemQPSTopNItemsQPSTopNItem) *DescribeSQLLogReportListResponseBodyItemsItemQPSTopNItems {
	s.QPSTopNItem = v
	return s
}

type DescribeSQLLogReportListResponseBodyItemsItemQPSTopNItemsQPSTopNItem struct {
	// The number of times that the SQL statement is executed.
	SQLExecuteTimes *int64 `json:"SQLExecuteTimes,omitempty" xml:"SQLExecuteTimes,omitempty"`
	// The SQL statement returned.
	//
	// >  Only the first 128 characters of the SQL statement are returned. In addition, only the SQL statements that take more than 5 ms to execute are returned.
	SQLText *string `json:"SQLText,omitempty" xml:"SQLText,omitempty"`
}

func (s DescribeSQLLogReportListResponseBodyItemsItemQPSTopNItemsQPSTopNItem) String() string {
	return tea.Prettify(s)
}

func (s DescribeSQLLogReportListResponseBodyItemsItemQPSTopNItemsQPSTopNItem) GoString() string {
	return s.String()
}

func (s *DescribeSQLLogReportListResponseBodyItemsItemQPSTopNItemsQPSTopNItem) SetSQLExecuteTimes(v int64) *DescribeSQLLogReportListResponseBodyItemsItemQPSTopNItemsQPSTopNItem {
	s.SQLExecuteTimes = &v
	return s
}

func (s *DescribeSQLLogReportListResponseBodyItemsItemQPSTopNItemsQPSTopNItem) SetSQLText(v string) *DescribeSQLLogReportListResponseBodyItemsItemQPSTopNItemsQPSTopNItem {
	s.SQLText = &v
	return s
}

type DescribeSQLLogReportListResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeSQLLogReportListResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeSQLLogReportListResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeSQLLogReportListResponse) GoString() string {
	return s.String()
}

func (s *DescribeSQLLogReportListResponse) SetHeaders(v map[string]*string) *DescribeSQLLogReportListResponse {
	s.Headers = v
	return s
}

func (s *DescribeSQLLogReportListResponse) SetStatusCode(v int32) *DescribeSQLLogReportListResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeSQLLogReportListResponse) SetBody(v *DescribeSQLLogReportListResponseBody) *DescribeSQLLogReportListResponse {
	s.Body = v
	return s
}

type DescribeSecretsRequest struct {
	// The language of the text within the response. Valid values:
	//
	// *   **zh-CN**: Chinese
	// *   **en-US**: English
	//
	// > The default value is **en-US**.
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The instance ID. You can call the [DescribeDBInstances](~~26232~~) operation to query the instance ID.
	DbInstanceId *string `json:"DbInstanceId,omitempty" xml:"DbInstanceId,omitempty"`
	// The database engine of the database.
	//
	// > Only MySQL is supported.
	Engine       *string `json:"Engine,omitempty" xml:"Engine,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of the page to return. Valid values: any non-zero positive integer.
	//
	// > The default value is 1.
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries per page.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The region ID of the instance. You can call the [DescribeDBInstanceAttribute](~~26231~~) operation to query region ID of the instance.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeSecretsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeSecretsRequest) GoString() string {
	return s.String()
}

func (s *DescribeSecretsRequest) SetAcceptLanguage(v string) *DescribeSecretsRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *DescribeSecretsRequest) SetClientToken(v string) *DescribeSecretsRequest {
	s.ClientToken = &v
	return s
}

func (s *DescribeSecretsRequest) SetDbInstanceId(v string) *DescribeSecretsRequest {
	s.DbInstanceId = &v
	return s
}

func (s *DescribeSecretsRequest) SetEngine(v string) *DescribeSecretsRequest {
	s.Engine = &v
	return s
}

func (s *DescribeSecretsRequest) SetOwnerAccount(v string) *DescribeSecretsRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeSecretsRequest) SetOwnerId(v int64) *DescribeSecretsRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeSecretsRequest) SetPageNumber(v int64) *DescribeSecretsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeSecretsRequest) SetPageSize(v int64) *DescribeSecretsRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeSecretsRequest) SetRegionId(v string) *DescribeSecretsRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeSecretsRequest) SetResourceOwnerAccount(v string) *DescribeSecretsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeSecretsRequest) SetResourceOwnerId(v int64) *DescribeSecretsRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeSecretsResponseBody struct {
	// The page number.
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries per page.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The details of the credential.
	Secrets []*DescribeSecretsResponseBodySecrets `json:"Secrets,omitempty" xml:"Secrets,omitempty" type:"Repeated"`
}

func (s DescribeSecretsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeSecretsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeSecretsResponseBody) SetPageNumber(v int64) *DescribeSecretsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeSecretsResponseBody) SetPageSize(v int64) *DescribeSecretsResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeSecretsResponseBody) SetRequestId(v string) *DescribeSecretsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeSecretsResponseBody) SetSecrets(v []*DescribeSecretsResponseBodySecrets) *DescribeSecretsResponseBody {
	s.Secrets = v
	return s
}

type DescribeSecretsResponseBodySecrets struct {
	// The ID of the Alibaba Cloud account.
	AccountId *string `json:"AccountId,omitempty" xml:"AccountId,omitempty"`
	// The description of the credential.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The Alibaba Cloud Resource Name (ARN) of the credential for the created Data API account.
	SecretArn *string `json:"SecretArn,omitempty" xml:"SecretArn,omitempty"`
	// The name of the credential.
	SecretName *string `json:"SecretName,omitempty" xml:"SecretName,omitempty"`
	// The username that is used to access the database.
	Username *string `json:"Username,omitempty" xml:"Username,omitempty"`
}

func (s DescribeSecretsResponseBodySecrets) String() string {
	return tea.Prettify(s)
}

func (s DescribeSecretsResponseBodySecrets) GoString() string {
	return s.String()
}

func (s *DescribeSecretsResponseBodySecrets) SetAccountId(v string) *DescribeSecretsResponseBodySecrets {
	s.AccountId = &v
	return s
}

func (s *DescribeSecretsResponseBodySecrets) SetDescription(v string) *DescribeSecretsResponseBodySecrets {
	s.Description = &v
	return s
}

func (s *DescribeSecretsResponseBodySecrets) SetRegionId(v string) *DescribeSecretsResponseBodySecrets {
	s.RegionId = &v
	return s
}

func (s *DescribeSecretsResponseBodySecrets) SetSecretArn(v string) *DescribeSecretsResponseBodySecrets {
	s.SecretArn = &v
	return s
}

func (s *DescribeSecretsResponseBodySecrets) SetSecretName(v string) *DescribeSecretsResponseBodySecrets {
	s.SecretName = &v
	return s
}

func (s *DescribeSecretsResponseBodySecrets) SetUsername(v string) *DescribeSecretsResponseBodySecrets {
	s.Username = &v
	return s
}

type DescribeSecretsResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeSecretsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeSecretsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeSecretsResponse) GoString() string {
	return s.String()
}

func (s *DescribeSecretsResponse) SetHeaders(v map[string]*string) *DescribeSecretsResponse {
	s.Headers = v
	return s
}

func (s *DescribeSecretsResponse) SetStatusCode(v int32) *DescribeSecretsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeSecretsResponse) SetBody(v *DescribeSecretsResponseBody) *DescribeSecretsResponse {
	s.Body = v
	return s
}

type DescribeSecurityGroupConfigurationRequest struct {
	// The ID of the instance.
	DBInstanceId         *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeSecurityGroupConfigurationRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeSecurityGroupConfigurationRequest) GoString() string {
	return s.String()
}

func (s *DescribeSecurityGroupConfigurationRequest) SetDBInstanceId(v string) *DescribeSecurityGroupConfigurationRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeSecurityGroupConfigurationRequest) SetOwnerId(v int64) *DescribeSecurityGroupConfigurationRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeSecurityGroupConfigurationRequest) SetResourceOwnerAccount(v string) *DescribeSecurityGroupConfigurationRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeSecurityGroupConfigurationRequest) SetResourceOwnerId(v int64) *DescribeSecurityGroupConfigurationRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeSecurityGroupConfigurationResponseBody struct {
	// The ID of the instance.
	DBInstanceName *string `json:"DBInstanceName,omitempty" xml:"DBInstanceName,omitempty"`
	// An array that consists of ECS security groups.
	Items *DescribeSecurityGroupConfigurationResponseBodyItems `json:"Items,omitempty" xml:"Items,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeSecurityGroupConfigurationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeSecurityGroupConfigurationResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeSecurityGroupConfigurationResponseBody) SetDBInstanceName(v string) *DescribeSecurityGroupConfigurationResponseBody {
	s.DBInstanceName = &v
	return s
}

func (s *DescribeSecurityGroupConfigurationResponseBody) SetItems(v *DescribeSecurityGroupConfigurationResponseBodyItems) *DescribeSecurityGroupConfigurationResponseBody {
	s.Items = v
	return s
}

func (s *DescribeSecurityGroupConfigurationResponseBody) SetRequestId(v string) *DescribeSecurityGroupConfigurationResponseBody {
	s.RequestId = &v
	return s
}

type DescribeSecurityGroupConfigurationResponseBodyItems struct {
	EcsSecurityGroupRelation []*DescribeSecurityGroupConfigurationResponseBodyItemsEcsSecurityGroupRelation `json:"EcsSecurityGroupRelation,omitempty" xml:"EcsSecurityGroupRelation,omitempty" type:"Repeated"`
}

func (s DescribeSecurityGroupConfigurationResponseBodyItems) String() string {
	return tea.Prettify(s)
}

func (s DescribeSecurityGroupConfigurationResponseBodyItems) GoString() string {
	return s.String()
}

func (s *DescribeSecurityGroupConfigurationResponseBodyItems) SetEcsSecurityGroupRelation(v []*DescribeSecurityGroupConfigurationResponseBodyItemsEcsSecurityGroupRelation) *DescribeSecurityGroupConfigurationResponseBodyItems {
	s.EcsSecurityGroupRelation = v
	return s
}

type DescribeSecurityGroupConfigurationResponseBodyItemsEcsSecurityGroupRelation struct {
	// The network type of the ECS security group. Valid values:
	//
	// *   **Classic**
	// *   **VPC**
	NetworkType *string `json:"NetworkType,omitempty" xml:"NetworkType,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the ECS security group.
	SecurityGroupId *string `json:"SecurityGroupId,omitempty" xml:"SecurityGroupId,omitempty"`
	// The name of the security group.
	SecurityGroupName *string `json:"SecurityGroupName,omitempty" xml:"SecurityGroupName,omitempty"`
}

func (s DescribeSecurityGroupConfigurationResponseBodyItemsEcsSecurityGroupRelation) String() string {
	return tea.Prettify(s)
}

func (s DescribeSecurityGroupConfigurationResponseBodyItemsEcsSecurityGroupRelation) GoString() string {
	return s.String()
}

func (s *DescribeSecurityGroupConfigurationResponseBodyItemsEcsSecurityGroupRelation) SetNetworkType(v string) *DescribeSecurityGroupConfigurationResponseBodyItemsEcsSecurityGroupRelation {
	s.NetworkType = &v
	return s
}

func (s *DescribeSecurityGroupConfigurationResponseBodyItemsEcsSecurityGroupRelation) SetRegionId(v string) *DescribeSecurityGroupConfigurationResponseBodyItemsEcsSecurityGroupRelation {
	s.RegionId = &v
	return s
}

func (s *DescribeSecurityGroupConfigurationResponseBodyItemsEcsSecurityGroupRelation) SetSecurityGroupId(v string) *DescribeSecurityGroupConfigurationResponseBodyItemsEcsSecurityGroupRelation {
	s.SecurityGroupId = &v
	return s
}

func (s *DescribeSecurityGroupConfigurationResponseBodyItemsEcsSecurityGroupRelation) SetSecurityGroupName(v string) *DescribeSecurityGroupConfigurationResponseBodyItemsEcsSecurityGroupRelation {
	s.SecurityGroupName = &v
	return s
}

type DescribeSecurityGroupConfigurationResponse struct {
	Headers    map[string]*string                              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeSecurityGroupConfigurationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeSecurityGroupConfigurationResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeSecurityGroupConfigurationResponse) GoString() string {
	return s.String()
}

func (s *DescribeSecurityGroupConfigurationResponse) SetHeaders(v map[string]*string) *DescribeSecurityGroupConfigurationResponse {
	s.Headers = v
	return s
}

func (s *DescribeSecurityGroupConfigurationResponse) SetStatusCode(v int32) *DescribeSecurityGroupConfigurationResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeSecurityGroupConfigurationResponse) SetBody(v *DescribeSecurityGroupConfigurationResponseBody) *DescribeSecurityGroupConfigurationResponse {
	s.Body = v
	return s
}

type DescribeSlotsRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The instance ID. You can call the [DescribeDBInstances](~~26232~~) operation to query the ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the resource group. You can leave this parameter empty.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeSlotsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeSlotsRequest) GoString() string {
	return s.String()
}

func (s *DescribeSlotsRequest) SetClientToken(v string) *DescribeSlotsRequest {
	s.ClientToken = &v
	return s
}

func (s *DescribeSlotsRequest) SetDBInstanceId(v string) *DescribeSlotsRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeSlotsRequest) SetOwnerAccount(v string) *DescribeSlotsRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeSlotsRequest) SetOwnerId(v int64) *DescribeSlotsRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeSlotsRequest) SetResourceGroupId(v string) *DescribeSlotsRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeSlotsRequest) SetResourceOwnerAccount(v string) *DescribeSlotsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeSlotsRequest) SetResourceOwnerId(v int64) *DescribeSlotsRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeSlotsResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Details about the replication slot.
	Slots []*DescribeSlotsResponseBodySlots `json:"Slots,omitempty" xml:"Slots,omitempty" type:"Repeated"`
}

func (s DescribeSlotsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeSlotsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeSlotsResponseBody) SetRequestId(v string) *DescribeSlotsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeSlotsResponseBody) SetSlots(v []*DescribeSlotsResponseBodySlots) *DescribeSlotsResponseBody {
	s.Slots = v
	return s
}

type DescribeSlotsResponseBodySlots struct {
	// The name of the database in which the replication slot resides.
	Database *string `json:"Database,omitempty" xml:"Database,omitempty"`
	// The extension used by the replication slot.
	//
	// Valid values:
	//
	// *   test_decoding
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   pgoutput
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   wal2json
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	Plugin *string `json:"Plugin,omitempty" xml:"Plugin,omitempty"`
	// The name of the replication slot.
	SlotName *string `json:"SlotName,omitempty" xml:"SlotName,omitempty"`
	// The status of the replication slot.
	//
	// Valid values:
	//
	// *   ACTIVE
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   INACTIVE
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	SlotStatus *string `json:"SlotStatus,omitempty" xml:"SlotStatus,omitempty"`
	// The type of the replication slot.
	//
	// Valid values:
	//
	// *   physical
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   logical
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	SlotType *string `json:"SlotType,omitempty" xml:"SlotType,omitempty"`
	// The latency of the logical subscription on the subscriber node that corresponds to the current replication slot. Unit: seconds.
	SubReplayLag *string `json:"SubReplayLag,omitempty" xml:"SubReplayLag,omitempty"`
	// Indicates whether the replication slot is a temporary replication slot.
	//
	// Valid values:
	//
	// *   true
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   false
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	Temporary *string `json:"Temporary,omitempty" xml:"Temporary,omitempty"`
	// The number of logs accumulated in the replication slot.
	WalDelay *string `json:"WalDelay,omitempty" xml:"WalDelay,omitempty"`
}

func (s DescribeSlotsResponseBodySlots) String() string {
	return tea.Prettify(s)
}

func (s DescribeSlotsResponseBodySlots) GoString() string {
	return s.String()
}

func (s *DescribeSlotsResponseBodySlots) SetDatabase(v string) *DescribeSlotsResponseBodySlots {
	s.Database = &v
	return s
}

func (s *DescribeSlotsResponseBodySlots) SetPlugin(v string) *DescribeSlotsResponseBodySlots {
	s.Plugin = &v
	return s
}

func (s *DescribeSlotsResponseBodySlots) SetSlotName(v string) *DescribeSlotsResponseBodySlots {
	s.SlotName = &v
	return s
}

func (s *DescribeSlotsResponseBodySlots) SetSlotStatus(v string) *DescribeSlotsResponseBodySlots {
	s.SlotStatus = &v
	return s
}

func (s *DescribeSlotsResponseBodySlots) SetSlotType(v string) *DescribeSlotsResponseBodySlots {
	s.SlotType = &v
	return s
}

func (s *DescribeSlotsResponseBodySlots) SetSubReplayLag(v string) *DescribeSlotsResponseBodySlots {
	s.SubReplayLag = &v
	return s
}

func (s *DescribeSlotsResponseBodySlots) SetTemporary(v string) *DescribeSlotsResponseBodySlots {
	s.Temporary = &v
	return s
}

func (s *DescribeSlotsResponseBodySlots) SetWalDelay(v string) *DescribeSlotsResponseBodySlots {
	s.WalDelay = &v
	return s
}

type DescribeSlotsResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeSlotsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeSlotsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeSlotsResponse) GoString() string {
	return s.String()
}

func (s *DescribeSlotsResponse) SetHeaders(v map[string]*string) *DescribeSlotsResponse {
	s.Headers = v
	return s
}

func (s *DescribeSlotsResponse) SetStatusCode(v int32) *DescribeSlotsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeSlotsResponse) SetBody(v *DescribeSlotsResponseBody) *DescribeSlotsResponse {
	s.Body = v
	return s
}

type DescribeSlowLogRecordsRequest struct {
	// The ID of the instance. You can call the [DescribeDBInstances](~~610396~~) operation to query the ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The name of the database.
	DBName *string `json:"DBName,omitempty" xml:"DBName,omitempty"`
	// The end of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-ddTHH:mm:ssZ* format. The time must be in UTC.**
	//
	// > The end time must be later than the start time.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The ID of the node.
	//
	// > This parameter is available only for instances that run RDS Cluster Edition. You can specify this parameter to query the logs of a specified node. If this parameter is not specified, the logs of the primary node are returned by default.
	NodeId       *string `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The page number. Pages start from page 1. Default value: 1.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries per page. Valid value: **30 to 200**. Default value: **30**.
	PageSize             *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The unique ID of the SQL statement. The ID is used to obtain the slow query logs of the SQL statement.
	SQLHASH *string `json:"SQLHASH,omitempty" xml:"SQLHASH,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeSlowLogRecordsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeSlowLogRecordsRequest) GoString() string {
	return s.String()
}

func (s *DescribeSlowLogRecordsRequest) SetDBInstanceId(v string) *DescribeSlowLogRecordsRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeSlowLogRecordsRequest) SetDBName(v string) *DescribeSlowLogRecordsRequest {
	s.DBName = &v
	return s
}

func (s *DescribeSlowLogRecordsRequest) SetEndTime(v string) *DescribeSlowLogRecordsRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeSlowLogRecordsRequest) SetNodeId(v string) *DescribeSlowLogRecordsRequest {
	s.NodeId = &v
	return s
}

func (s *DescribeSlowLogRecordsRequest) SetOwnerAccount(v string) *DescribeSlowLogRecordsRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeSlowLogRecordsRequest) SetOwnerId(v int64) *DescribeSlowLogRecordsRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeSlowLogRecordsRequest) SetPageNumber(v int32) *DescribeSlowLogRecordsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeSlowLogRecordsRequest) SetPageSize(v int32) *DescribeSlowLogRecordsRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeSlowLogRecordsRequest) SetResourceOwnerAccount(v string) *DescribeSlowLogRecordsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeSlowLogRecordsRequest) SetResourceOwnerId(v int64) *DescribeSlowLogRecordsRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeSlowLogRecordsRequest) SetSQLHASH(v string) *DescribeSlowLogRecordsRequest {
	s.SQLHASH = &v
	return s
}

func (s *DescribeSlowLogRecordsRequest) SetStartTime(v string) *DescribeSlowLogRecordsRequest {
	s.StartTime = &v
	return s
}

type DescribeSlowLogRecordsResponseBody struct {
	// The ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The type of the database engine.
	Engine *string `json:"Engine,omitempty" xml:"Engine,omitempty"`
	// An array that consists of the information about each slow log.
	Items *DescribeSlowLogRecordsResponseBodyItems `json:"Items,omitempty" xml:"Items,omitempty" type:"Struct"`
	// The page number.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of SQL log reports on the current page.
	PageRecordCount *int32 `json:"PageRecordCount,omitempty" xml:"PageRecordCount,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalRecordCount *int32 `json:"TotalRecordCount,omitempty" xml:"TotalRecordCount,omitempty"`
}

func (s DescribeSlowLogRecordsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeSlowLogRecordsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeSlowLogRecordsResponseBody) SetDBInstanceId(v string) *DescribeSlowLogRecordsResponseBody {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeSlowLogRecordsResponseBody) SetEngine(v string) *DescribeSlowLogRecordsResponseBody {
	s.Engine = &v
	return s
}

func (s *DescribeSlowLogRecordsResponseBody) SetItems(v *DescribeSlowLogRecordsResponseBodyItems) *DescribeSlowLogRecordsResponseBody {
	s.Items = v
	return s
}

func (s *DescribeSlowLogRecordsResponseBody) SetPageNumber(v int32) *DescribeSlowLogRecordsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeSlowLogRecordsResponseBody) SetPageRecordCount(v int32) *DescribeSlowLogRecordsResponseBody {
	s.PageRecordCount = &v
	return s
}

func (s *DescribeSlowLogRecordsResponseBody) SetRequestId(v string) *DescribeSlowLogRecordsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeSlowLogRecordsResponseBody) SetTotalRecordCount(v int32) *DescribeSlowLogRecordsResponseBody {
	s.TotalRecordCount = &v
	return s
}

type DescribeSlowLogRecordsResponseBodyItems struct {
	SQLSlowRecord []*DescribeSlowLogRecordsResponseBodyItemsSQLSlowRecord `json:"SQLSlowRecord,omitempty" xml:"SQLSlowRecord,omitempty" type:"Repeated"`
}

func (s DescribeSlowLogRecordsResponseBodyItems) String() string {
	return tea.Prettify(s)
}

func (s DescribeSlowLogRecordsResponseBodyItems) GoString() string {
	return s.String()
}

func (s *DescribeSlowLogRecordsResponseBodyItems) SetSQLSlowRecord(v []*DescribeSlowLogRecordsResponseBodyItemsSQLSlowRecord) *DescribeSlowLogRecordsResponseBodyItems {
	s.SQLSlowRecord = v
	return s
}

type DescribeSlowLogRecordsResponseBodyItemsSQLSlowRecord struct {
	// The name of the application that is connected to the instance.
	//
	// > This parameter is returned only for instances that run SQL Server.
	ApplicationName *string `json:"ApplicationName,omitempty" xml:"ApplicationName,omitempty"`
	// The hostname of the client.
	//
	// > This parameter is returned only for instances that run SQL Server.
	ClientHostName *string `json:"ClientHostName,omitempty" xml:"ClientHostName,omitempty"`
	// The duration during which the SQL statement is processed by the CPU. Unit: milliseconds.
	//
	// > This parameter is returned only for instances that run SQL Server.
	CpuTime *int64 `json:"CpuTime,omitempty" xml:"CpuTime,omitempty"`
	// The name of the database.
	DBName *string `json:"DBName,omitempty" xml:"DBName,omitempty"`
	// The time when the execution of the SQL statement started. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	ExecutionStartTime *string `json:"ExecutionStartTime,omitempty" xml:"ExecutionStartTime,omitempty"`
	// The name and IP address of the client that is connected to the database.
	HostAddress *string `json:"HostAddress,omitempty" xml:"HostAddress,omitempty"`
	// The number of rows that are affected by the last SQL statement.
	//
	// > This parameter is returned only for instances that run SQL Server.
	LastRowsAffectedCount *int64 `json:"LastRowsAffectedCount,omitempty" xml:"LastRowsAffectedCount,omitempty"`
	// The lock duration of the query. Unit: seconds.
	LockTimes *int64 `json:"LockTimes,omitempty" xml:"LockTimes,omitempty"`
	// The number of logical reads.
	//
	// > This parameter is returned only for instances that run SQL Server.
	LogicalIORead *int64 `json:"LogicalIORead,omitempty" xml:"LogicalIORead,omitempty"`
	// The number of parsed rows.
	ParseRowCounts *int64 `json:"ParseRowCounts,omitempty" xml:"ParseRowCounts,omitempty"`
	// The number of physical reads.
	//
	// > This parameter is returned only for instances that run SQL Server.
	PhysicalIORead *int64 `json:"PhysicalIORead,omitempty" xml:"PhysicalIORead,omitempty"`
	// The execution duration of the query. Unit: milliseconds.
	QueryTimeMS *int64 `json:"QueryTimeMS,omitempty" xml:"QueryTimeMS,omitempty"`
	// The execution duration of the query. Unit: seconds.
	QueryTimes *int64 `json:"QueryTimes,omitempty" xml:"QueryTimes,omitempty"`
	// The number of rows returned.
	ReturnRowCounts *int64 `json:"ReturnRowCounts,omitempty" xml:"ReturnRowCounts,omitempty"`
	// The number of affected rows.
	//
	// > This parameter is returned only for instances that run SQL Server.
	RowsAffectedCount *int64 `json:"RowsAffectedCount,omitempty" xml:"RowsAffectedCount,omitempty"`
	// The unique ID of the SQL statement.
	SQLHash *string `json:"SQLHash,omitempty" xml:"SQLHash,omitempty"`
	// The details of the SQL statement.
	SQLText *string `json:"SQLText,omitempty" xml:"SQLText,omitempty"`
	// The name of the user.
	//
	// > This parameter is returned only for instances that run SQL Server.
	UserName *string `json:"UserName,omitempty" xml:"UserName,omitempty"`
	// The number of I/O writes.
	//
	// > This parameter is returned only for instances that run SQL Server.
	WriteIOCount *int64 `json:"WriteIOCount,omitempty" xml:"WriteIOCount,omitempty"`
}

func (s DescribeSlowLogRecordsResponseBodyItemsSQLSlowRecord) String() string {
	return tea.Prettify(s)
}

func (s DescribeSlowLogRecordsResponseBodyItemsSQLSlowRecord) GoString() string {
	return s.String()
}

func (s *DescribeSlowLogRecordsResponseBodyItemsSQLSlowRecord) SetApplicationName(v string) *DescribeSlowLogRecordsResponseBodyItemsSQLSlowRecord {
	s.ApplicationName = &v
	return s
}

func (s *DescribeSlowLogRecordsResponseBodyItemsSQLSlowRecord) SetClientHostName(v string) *DescribeSlowLogRecordsResponseBodyItemsSQLSlowRecord {
	s.ClientHostName = &v
	return s
}

func (s *DescribeSlowLogRecordsResponseBodyItemsSQLSlowRecord) SetCpuTime(v int64) *DescribeSlowLogRecordsResponseBodyItemsSQLSlowRecord {
	s.CpuTime = &v
	return s
}

func (s *DescribeSlowLogRecordsResponseBodyItemsSQLSlowRecord) SetDBName(v string) *DescribeSlowLogRecordsResponseBodyItemsSQLSlowRecord {
	s.DBName = &v
	return s
}

func (s *DescribeSlowLogRecordsResponseBodyItemsSQLSlowRecord) SetExecutionStartTime(v string) *DescribeSlowLogRecordsResponseBodyItemsSQLSlowRecord {
	s.ExecutionStartTime = &v
	return s
}

func (s *DescribeSlowLogRecordsResponseBodyItemsSQLSlowRecord) SetHostAddress(v string) *DescribeSlowLogRecordsResponseBodyItemsSQLSlowRecord {
	s.HostAddress = &v
	return s
}

func (s *DescribeSlowLogRecordsResponseBodyItemsSQLSlowRecord) SetLastRowsAffectedCount(v int64) *DescribeSlowLogRecordsResponseBodyItemsSQLSlowRecord {
	s.LastRowsAffectedCount = &v
	return s
}

func (s *DescribeSlowLogRecordsResponseBodyItemsSQLSlowRecord) SetLockTimes(v int64) *DescribeSlowLogRecordsResponseBodyItemsSQLSlowRecord {
	s.LockTimes = &v
	return s
}

func (s *DescribeSlowLogRecordsResponseBodyItemsSQLSlowRecord) SetLogicalIORead(v int64) *DescribeSlowLogRecordsResponseBodyItemsSQLSlowRecord {
	s.LogicalIORead = &v
	return s
}

func (s *DescribeSlowLogRecordsResponseBodyItemsSQLSlowRecord) SetParseRowCounts(v int64) *DescribeSlowLogRecordsResponseBodyItemsSQLSlowRecord {
	s.ParseRowCounts = &v
	return s
}

func (s *DescribeSlowLogRecordsResponseBodyItemsSQLSlowRecord) SetPhysicalIORead(v int64) *DescribeSlowLogRecordsResponseBodyItemsSQLSlowRecord {
	s.PhysicalIORead = &v
	return s
}

func (s *DescribeSlowLogRecordsResponseBodyItemsSQLSlowRecord) SetQueryTimeMS(v int64) *DescribeSlowLogRecordsResponseBodyItemsSQLSlowRecord {
	s.QueryTimeMS = &v
	return s
}

func (s *DescribeSlowLogRecordsResponseBodyItemsSQLSlowRecord) SetQueryTimes(v int64) *DescribeSlowLogRecordsResponseBodyItemsSQLSlowRecord {
	s.QueryTimes = &v
	return s
}

func (s *DescribeSlowLogRecordsResponseBodyItemsSQLSlowRecord) SetReturnRowCounts(v int64) *DescribeSlowLogRecordsResponseBodyItemsSQLSlowRecord {
	s.ReturnRowCounts = &v
	return s
}

func (s *DescribeSlowLogRecordsResponseBodyItemsSQLSlowRecord) SetRowsAffectedCount(v int64) *DescribeSlowLogRecordsResponseBodyItemsSQLSlowRecord {
	s.RowsAffectedCount = &v
	return s
}

func (s *DescribeSlowLogRecordsResponseBodyItemsSQLSlowRecord) SetSQLHash(v string) *DescribeSlowLogRecordsResponseBodyItemsSQLSlowRecord {
	s.SQLHash = &v
	return s
}

func (s *DescribeSlowLogRecordsResponseBodyItemsSQLSlowRecord) SetSQLText(v string) *DescribeSlowLogRecordsResponseBodyItemsSQLSlowRecord {
	s.SQLText = &v
	return s
}

func (s *DescribeSlowLogRecordsResponseBodyItemsSQLSlowRecord) SetUserName(v string) *DescribeSlowLogRecordsResponseBodyItemsSQLSlowRecord {
	s.UserName = &v
	return s
}

func (s *DescribeSlowLogRecordsResponseBodyItemsSQLSlowRecord) SetWriteIOCount(v int64) *DescribeSlowLogRecordsResponseBodyItemsSQLSlowRecord {
	s.WriteIOCount = &v
	return s
}

type DescribeSlowLogRecordsResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeSlowLogRecordsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeSlowLogRecordsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeSlowLogRecordsResponse) GoString() string {
	return s.String()
}

func (s *DescribeSlowLogRecordsResponse) SetHeaders(v map[string]*string) *DescribeSlowLogRecordsResponse {
	s.Headers = v
	return s
}

func (s *DescribeSlowLogRecordsResponse) SetStatusCode(v int32) *DescribeSlowLogRecordsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeSlowLogRecordsResponse) SetBody(v *DescribeSlowLogRecordsResponseBody) *DescribeSlowLogRecordsResponse {
	s.Body = v
	return s
}

type DescribeSlowLogsRequest struct {
	// The instance ID. You can call the DescribeDBInstances operation to query the instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The name of the database.
	DBName *string `json:"DBName,omitempty" xml:"DBName,omitempty"`
	// The end of the time range to query. The end time must be later than the start time. The time span between the start time and the end time cannot exceed 31 days. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*Z format. The time must be in UTC.
	EndTime      *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The page number. Valid values: any non-zero positive integer.
	//
	// Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Valid values: **30** to **100**. Default value: **30**.
	PageSize             *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The dimension based on which the system sorts the entries to return. Valid values:
	//
	// *   **TotalExecutionCounts**: The system sorts the entries to return based on the number of times that SQL statements are executed.
	// *   **TotalQueryTimes**: The system sorts the entries to return based on the total execution duration.
	// *   **TotalLogicalReads**: The system sorts the entries to return based on the total number of logical reads.
	// *   **TotalPhysicalReads**: The system sorts the entries to return based on the total number of physical reads.
	//
	// > This parameter is supported only for instances that run SQL Server 2008 R2.
	SortKey *string `json:"SortKey,omitempty" xml:"SortKey,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*Z format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeSlowLogsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeSlowLogsRequest) GoString() string {
	return s.String()
}

func (s *DescribeSlowLogsRequest) SetDBInstanceId(v string) *DescribeSlowLogsRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeSlowLogsRequest) SetDBName(v string) *DescribeSlowLogsRequest {
	s.DBName = &v
	return s
}

func (s *DescribeSlowLogsRequest) SetEndTime(v string) *DescribeSlowLogsRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeSlowLogsRequest) SetOwnerAccount(v string) *DescribeSlowLogsRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeSlowLogsRequest) SetOwnerId(v int64) *DescribeSlowLogsRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeSlowLogsRequest) SetPageNumber(v int32) *DescribeSlowLogsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeSlowLogsRequest) SetPageSize(v int32) *DescribeSlowLogsRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeSlowLogsRequest) SetResourceOwnerAccount(v string) *DescribeSlowLogsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeSlowLogsRequest) SetResourceOwnerId(v int64) *DescribeSlowLogsRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeSlowLogsRequest) SetSortKey(v string) *DescribeSlowLogsRequest {
	s.SortKey = &v
	return s
}

func (s *DescribeSlowLogsRequest) SetStartTime(v string) *DescribeSlowLogsRequest {
	s.StartTime = &v
	return s
}

type DescribeSlowLogsResponseBody struct {
	// The ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The end date of the query.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The database engine of the instance.
	Engine *string `json:"Engine,omitempty" xml:"Engine,omitempty"`
	// An array that consists of the information about each slow query log.
	Items *DescribeSlowLogsResponseBodyItems `json:"Items,omitempty" xml:"Items,omitempty" type:"Struct"`
	// The number of the page returned.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of SQL statements that are returned on the current page.
	PageRecordCount *int32 `json:"PageRecordCount,omitempty" xml:"PageRecordCount,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The start date of the query.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The total number of entries that are returned.
	TotalRecordCount *int32 `json:"TotalRecordCount,omitempty" xml:"TotalRecordCount,omitempty"`
}

func (s DescribeSlowLogsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeSlowLogsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeSlowLogsResponseBody) SetDBInstanceId(v string) *DescribeSlowLogsResponseBody {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeSlowLogsResponseBody) SetEndTime(v string) *DescribeSlowLogsResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeSlowLogsResponseBody) SetEngine(v string) *DescribeSlowLogsResponseBody {
	s.Engine = &v
	return s
}

func (s *DescribeSlowLogsResponseBody) SetItems(v *DescribeSlowLogsResponseBodyItems) *DescribeSlowLogsResponseBody {
	s.Items = v
	return s
}

func (s *DescribeSlowLogsResponseBody) SetPageNumber(v int32) *DescribeSlowLogsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeSlowLogsResponseBody) SetPageRecordCount(v int32) *DescribeSlowLogsResponseBody {
	s.PageRecordCount = &v
	return s
}

func (s *DescribeSlowLogsResponseBody) SetRequestId(v string) *DescribeSlowLogsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeSlowLogsResponseBody) SetStartTime(v string) *DescribeSlowLogsResponseBody {
	s.StartTime = &v
	return s
}

func (s *DescribeSlowLogsResponseBody) SetTotalRecordCount(v int32) *DescribeSlowLogsResponseBody {
	s.TotalRecordCount = &v
	return s
}

type DescribeSlowLogsResponseBodyItems struct {
	SQLSlowLog []*DescribeSlowLogsResponseBodyItemsSQLSlowLog `json:"SQLSlowLog,omitempty" xml:"SQLSlowLog,omitempty" type:"Repeated"`
}

func (s DescribeSlowLogsResponseBodyItems) String() string {
	return tea.Prettify(s)
}

func (s DescribeSlowLogsResponseBodyItems) GoString() string {
	return s.String()
}

func (s *DescribeSlowLogsResponseBodyItems) SetSQLSlowLog(v []*DescribeSlowLogsResponseBodyItemsSQLSlowLog) *DescribeSlowLogsResponseBodyItems {
	s.SQLSlowLog = v
	return s
}

type DescribeSlowLogsResponseBodyItemsSQLSlowLog struct {
	// The average execution duration per SQL statement in the query. Unit: seconds.
	//
	// **
	//
	// ****
	AvgExecutionTime *int64 `json:"AvgExecutionTime,omitempty" xml:"AvgExecutionTime,omitempty"`
	// The average number of I/O writes per SQL statement in the query.
	//
	// > This parameter is returned only for instances that run SQL Server.
	AvgIOWriteCounts *int64 `json:"AvgIOWriteCounts,omitempty" xml:"AvgIOWriteCounts,omitempty"`
	// The average number of rows that were affected by the last SQL statement in the query.
	//
	// > This parameter is returned only for instances that run SQL Server.
	AvgLastRowsAffectedCounts *int64 `json:"AvgLastRowsAffectedCounts,omitempty" xml:"AvgLastRowsAffectedCounts,omitempty"`
	// The average number of logical reads per SQL statement in the query.
	//
	// > This parameter is returned only for instances that run SQL Server.
	AvgLogicalReadCounts *int64 `json:"AvgLogicalReadCounts,omitempty" xml:"AvgLogicalReadCounts,omitempty"`
	// The average number of physical reads per SQL statement in the query.
	//
	// > This parameter is returned only for instances that run SQL Server.
	AvgPhysicalReadCounts *int64 `json:"AvgPhysicalReadCounts,omitempty" xml:"AvgPhysicalReadCounts,omitempty"`
	// The average number of rows that were affected per SQL statement in the query.
	//
	// > This parameter is returned only for instances that run SQL Server.
	AvgRowsAffectedCounts *int64 `json:"AvgRowsAffectedCounts,omitempty" xml:"AvgRowsAffectedCounts,omitempty"`
	// The date when the data was generated.
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The name of the database.
	DBName *string `json:"DBName,omitempty" xml:"DBName,omitempty"`
	// The longest execution duration of a specific SQL statement in the query. Unit: seconds.
	MaxExecutionTime *int64 `json:"MaxExecutionTime,omitempty" xml:"MaxExecutionTime,omitempty"`
	// The longest execution duration of a specific SQL statement in the query. Unit: milliseconds.
	MaxExecutionTimeMS *int64 `json:"MaxExecutionTimeMS,omitempty" xml:"MaxExecutionTimeMS,omitempty"`
	// The largest number of I/O writes that were performed by a specific SQL statement in the query.
	//
	// > This parameter is returned only for instances that run SQL Server.
	MaxIOWriteCounts *int64 `json:"MaxIOWriteCounts,omitempty" xml:"MaxIOWriteCounts,omitempty"`
	// The largest number of rows that were affected by the last SQL statement in the query.
	//
	// > This parameter is returned only for instances that run SQL Server.
	MaxLastRowsAffectedCounts *int64 `json:"MaxLastRowsAffectedCounts,omitempty" xml:"MaxLastRowsAffectedCounts,omitempty"`
	// The longest lock duration that was caused by a specific SQL statement in the query. Unit: seconds.
	MaxLockTime *int64 `json:"MaxLockTime,omitempty" xml:"MaxLockTime,omitempty"`
	// The longest lock duration that was caused by a specific SQL statement in the query. Unit: milliseconds.
	MaxLockTimeMS *int64 `json:"MaxLockTimeMS,omitempty" xml:"MaxLockTimeMS,omitempty"`
	// The largest number of logical reads that were performed by a specific SQL statement in the query.
	//
	// > This parameter is returned only for instances that run SQL Server.
	MaxLogicalReadCounts *int64 `json:"MaxLogicalReadCounts,omitempty" xml:"MaxLogicalReadCounts,omitempty"`
	// The largest number of physical reads that were performed by a specific SQL statement in the query.
	//
	// > This parameter is returned only for instances that run SQL Server.
	MaxPhysicalReadCounts *int64 `json:"MaxPhysicalReadCounts,omitempty" xml:"MaxPhysicalReadCounts,omitempty"`
	// The largest number of rows that were affected by a specific SQL statement in the query.
	//
	// > This parameter is returned only for instances that run SQL Server.
	MaxRowsAffectedCounts *int64 `json:"MaxRowsAffectedCounts,omitempty" xml:"MaxRowsAffectedCounts,omitempty"`
	// The smallest number of I/O writes that were performed by a specific SQL statement in the query.
	//
	// > This parameter is returned only for instances that run SQL Server.
	MinIOWriteCounts *int64 `json:"MinIOWriteCounts,omitempty" xml:"MinIOWriteCounts,omitempty"`
	// The smallest number of rows that were affected by the last SQL statement in the query.
	//
	// > This parameter is returned only for instances that run SQL Server.
	MinLastRowsAffectedCounts *int64 `json:"MinLastRowsAffectedCounts,omitempty" xml:"MinLastRowsAffectedCounts,omitempty"`
	// The smallest number of logical reads that were performed by a specific SQL statement in the query.
	//
	// > This parameter is returned only for instances that run SQL Server.
	MinLogicalReadCounts *int64 `json:"MinLogicalReadCounts,omitempty" xml:"MinLogicalReadCounts,omitempty"`
	// The smallest number of physical reads that were performed by a specific SQL statement in the query.
	//
	// > This parameter is returned only for instances that run SQL Server.
	MinPhysicalReadCounts *int64 `json:"MinPhysicalReadCounts,omitempty" xml:"MinPhysicalReadCounts,omitempty"`
	// The smallest number of rows that were affected by a specific SQL statement in the query.
	//
	// > This parameter is returned only for instances that run SQL Server.
	MinRowsAffectedCounts *int64 `json:"MinRowsAffectedCounts,omitempty" xml:"MinRowsAffectedCounts,omitempty"`
	// The total number of SQL statements that were executed in the query. This parameter is returned only for instances that run MySQL.
	MySQLTotalExecutionCounts *int64 `json:"MySQLTotalExecutionCounts,omitempty" xml:"MySQLTotalExecutionCounts,omitempty"`
	// The total execution duration of all SQL statements in the query. Unit: seconds. This parameter is returned only for instances that run MySQL.
	MySQLTotalExecutionTimes *int64 `json:"MySQLTotalExecutionTimes,omitempty" xml:"MySQLTotalExecutionTimes,omitempty"`
	// The largest number of rows that were parsed by a specific SQL statement in the query.
	ParseMaxRowCount *int64 `json:"ParseMaxRowCount,omitempty" xml:"ParseMaxRowCount,omitempty"`
	// The total number of rows that were parsed by all SQL statements in the query.
	ParseTotalRowCounts *int64 `json:"ParseTotalRowCounts,omitempty" xml:"ParseTotalRowCounts,omitempty"`
	// The date on which the data report was generated.
	ReportTime *string `json:"ReportTime,omitempty" xml:"ReportTime,omitempty"`
	// The largest number of rows that were returned by a specific SQL statement in the query.
	ReturnMaxRowCount *int64 `json:"ReturnMaxRowCount,omitempty" xml:"ReturnMaxRowCount,omitempty"`
	// The total number of rows that were returned by all SQL statements in the query.
	ReturnTotalRowCounts *int64 `json:"ReturnTotalRowCounts,omitempty" xml:"ReturnTotalRowCounts,omitempty"`
	// The unique ID of the SQL statement. The ID is used to obtain the slow query logs of the SQL statement.
	SQLHASH *string `json:"SQLHASH,omitempty" xml:"SQLHASH,omitempty"`
	// The ID of the SQL statement in the statistical template of slow query logs. This parameter is replaced by the **SQLHASH** parameter.
	SQLIdStr *string `json:"SQLIdStr,omitempty" xml:"SQLIdStr,omitempty"`
	// The average amount of CPU time per SQL statement in the query. Unit: seconds.
	//
	// > This parameter is returned only for instances that run SQL Server.
	SQLServerAvgCpuTime *int64 `json:"SQLServerAvgCpuTime,omitempty" xml:"SQLServerAvgCpuTime,omitempty"`
	// The average execution duration per SQL statement in the query. Unit: seconds.
	//
	// > This parameter is returned only for instances that run SQL Server.
	SQLServerAvgExecutionTime *int64 `json:"SQLServerAvgExecutionTime,omitempty" xml:"SQLServerAvgExecutionTime,omitempty"`
	// The largest amount of CPU time that was used by a specific SQL statement in the query. Unit: seconds.
	//
	// > This parameter is returned only for instances that run SQL Server.
	SQLServerMaxCpuTime *int64 `json:"SQLServerMaxCpuTime,omitempty" xml:"SQLServerMaxCpuTime,omitempty"`
	// The smallest amount of CPU time that was used by a specific SQL statement. Unit: seconds.
	//
	// > This parameter is returned only for instances that run SQL Server.
	SQLServerMinCpuTime *int64 `json:"SQLServerMinCpuTime,omitempty" xml:"SQLServerMinCpuTime,omitempty"`
	// The smallest execution duration of a specific SQL statement in the query. Unit: seconds.
	//
	// > This parameter is returned only for instances that run SQL Server.
	SQLServerMinExecutionTime *int64 `json:"SQLServerMinExecutionTime,omitempty" xml:"SQLServerMinExecutionTime,omitempty"`
	// The total amount of CPU time that was used by all SQL statements in the query. Unit: seconds.
	//
	// > This parameter is returned only for instances that run SQL Server.
	SQLServerTotalCpuTime *int64 `json:"SQLServerTotalCpuTime,omitempty" xml:"SQLServerTotalCpuTime,omitempty"`
	// The total number of SQL statements that were executed in the query. This parameter is returned only for instances that run SQL Server.
	SQLServerTotalExecutionCounts *int64 `json:"SQLServerTotalExecutionCounts,omitempty" xml:"SQLServerTotalExecutionCounts,omitempty"`
	// The total execution duration of all SQL statements in the query. This parameter is returned only for instances that run SQL Server. Unit: milliseconds.
	SQLServerTotalExecutionTimes *int64 `json:"SQLServerTotalExecutionTimes,omitempty" xml:"SQLServerTotalExecutionTimes,omitempty"`
	// The SQL statement that was executed in the query.
	SQLText *string `json:"SQLText,omitempty" xml:"SQLText,omitempty"`
	// The ID of the slow query log summary.
	SlowLogId *int64 `json:"SlowLogId,omitempty" xml:"SlowLogId,omitempty"`
	// The total number of I/O writes that were performed by all SQL statements in the query.
	//
	// > This parameter is returned only for instances that run SQL Server.
	TotalIOWriteCounts *int64 `json:"TotalIOWriteCounts,omitempty" xml:"TotalIOWriteCounts,omitempty"`
	// The total number of rows that were affected by the last SQL statement in the query.
	//
	// > This parameter is returned only for instances that run SQL Server.
	TotalLastRowsAffectedCounts *int64 `json:"TotalLastRowsAffectedCounts,omitempty" xml:"TotalLastRowsAffectedCounts,omitempty"`
	// The total lock duration that was caused by all SQL statements in the query. Unit: seconds.
	TotalLockTimes *int64 `json:"TotalLockTimes,omitempty" xml:"TotalLockTimes,omitempty"`
	// The total number of logical reads that were performed by all SQL statements in the query.
	TotalLogicalReadCounts *int64 `json:"TotalLogicalReadCounts,omitempty" xml:"TotalLogicalReadCounts,omitempty"`
	// The total number of physical reads that were performed by all SQL statements in the query .
	TotalPhysicalReadCounts *int64 `json:"TotalPhysicalReadCounts,omitempty" xml:"TotalPhysicalReadCounts,omitempty"`
	// The total number of rows that were affected by all SQL statements in the query.
	TotalRowsAffectedCounts *int64 `json:"TotalRowsAffectedCounts,omitempty" xml:"TotalRowsAffectedCounts,omitempty"`
}

func (s DescribeSlowLogsResponseBodyItemsSQLSlowLog) String() string {
	return tea.Prettify(s)
}

func (s DescribeSlowLogsResponseBodyItemsSQLSlowLog) GoString() string {
	return s.String()
}

func (s *DescribeSlowLogsResponseBodyItemsSQLSlowLog) SetAvgExecutionTime(v int64) *DescribeSlowLogsResponseBodyItemsSQLSlowLog {
	s.AvgExecutionTime = &v
	return s
}

func (s *DescribeSlowLogsResponseBodyItemsSQLSlowLog) SetAvgIOWriteCounts(v int64) *DescribeSlowLogsResponseBodyItemsSQLSlowLog {
	s.AvgIOWriteCounts = &v
	return s
}

func (s *DescribeSlowLogsResponseBodyItemsSQLSlowLog) SetAvgLastRowsAffectedCounts(v int64) *DescribeSlowLogsResponseBodyItemsSQLSlowLog {
	s.AvgLastRowsAffectedCounts = &v
	return s
}

func (s *DescribeSlowLogsResponseBodyItemsSQLSlowLog) SetAvgLogicalReadCounts(v int64) *DescribeSlowLogsResponseBodyItemsSQLSlowLog {
	s.AvgLogicalReadCounts = &v
	return s
}

func (s *DescribeSlowLogsResponseBodyItemsSQLSlowLog) SetAvgPhysicalReadCounts(v int64) *DescribeSlowLogsResponseBodyItemsSQLSlowLog {
	s.AvgPhysicalReadCounts = &v
	return s
}

func (s *DescribeSlowLogsResponseBodyItemsSQLSlowLog) SetAvgRowsAffectedCounts(v int64) *DescribeSlowLogsResponseBodyItemsSQLSlowLog {
	s.AvgRowsAffectedCounts = &v
	return s
}

func (s *DescribeSlowLogsResponseBodyItemsSQLSlowLog) SetCreateTime(v string) *DescribeSlowLogsResponseBodyItemsSQLSlowLog {
	s.CreateTime = &v
	return s
}

func (s *DescribeSlowLogsResponseBodyItemsSQLSlowLog) SetDBName(v string) *DescribeSlowLogsResponseBodyItemsSQLSlowLog {
	s.DBName = &v
	return s
}

func (s *DescribeSlowLogsResponseBodyItemsSQLSlowLog) SetMaxExecutionTime(v int64) *DescribeSlowLogsResponseBodyItemsSQLSlowLog {
	s.MaxExecutionTime = &v
	return s
}

func (s *DescribeSlowLogsResponseBodyItemsSQLSlowLog) SetMaxExecutionTimeMS(v int64) *DescribeSlowLogsResponseBodyItemsSQLSlowLog {
	s.MaxExecutionTimeMS = &v
	return s
}

func (s *DescribeSlowLogsResponseBodyItemsSQLSlowLog) SetMaxIOWriteCounts(v int64) *DescribeSlowLogsResponseBodyItemsSQLSlowLog {
	s.MaxIOWriteCounts = &v
	return s
}

func (s *DescribeSlowLogsResponseBodyItemsSQLSlowLog) SetMaxLastRowsAffectedCounts(v int64) *DescribeSlowLogsResponseBodyItemsSQLSlowLog {
	s.MaxLastRowsAffectedCounts = &v
	return s
}

func (s *DescribeSlowLogsResponseBodyItemsSQLSlowLog) SetMaxLockTime(v int64) *DescribeSlowLogsResponseBodyItemsSQLSlowLog {
	s.MaxLockTime = &v
	return s
}

func (s *DescribeSlowLogsResponseBodyItemsSQLSlowLog) SetMaxLockTimeMS(v int64) *DescribeSlowLogsResponseBodyItemsSQLSlowLog {
	s.MaxLockTimeMS = &v
	return s
}

func (s *DescribeSlowLogsResponseBodyItemsSQLSlowLog) SetMaxLogicalReadCounts(v int64) *DescribeSlowLogsResponseBodyItemsSQLSlowLog {
	s.MaxLogicalReadCounts = &v
	return s
}

func (s *DescribeSlowLogsResponseBodyItemsSQLSlowLog) SetMaxPhysicalReadCounts(v int64) *DescribeSlowLogsResponseBodyItemsSQLSlowLog {
	s.MaxPhysicalReadCounts = &v
	return s
}

func (s *DescribeSlowLogsResponseBodyItemsSQLSlowLog) SetMaxRowsAffectedCounts(v int64) *DescribeSlowLogsResponseBodyItemsSQLSlowLog {
	s.MaxRowsAffectedCounts = &v
	return s
}

func (s *DescribeSlowLogsResponseBodyItemsSQLSlowLog) SetMinIOWriteCounts(v int64) *DescribeSlowLogsResponseBodyItemsSQLSlowLog {
	s.MinIOWriteCounts = &v
	return s
}

func (s *DescribeSlowLogsResponseBodyItemsSQLSlowLog) SetMinLastRowsAffectedCounts(v int64) *DescribeSlowLogsResponseBodyItemsSQLSlowLog {
	s.MinLastRowsAffectedCounts = &v
	return s
}

func (s *DescribeSlowLogsResponseBodyItemsSQLSlowLog) SetMinLogicalReadCounts(v int64) *DescribeSlowLogsResponseBodyItemsSQLSlowLog {
	s.MinLogicalReadCounts = &v
	return s
}

func (s *DescribeSlowLogsResponseBodyItemsSQLSlowLog) SetMinPhysicalReadCounts(v int64) *DescribeSlowLogsResponseBodyItemsSQLSlowLog {
	s.MinPhysicalReadCounts = &v
	return s
}

func (s *DescribeSlowLogsResponseBodyItemsSQLSlowLog) SetMinRowsAffectedCounts(v int64) *DescribeSlowLogsResponseBodyItemsSQLSlowLog {
	s.MinRowsAffectedCounts = &v
	return s
}

func (s *DescribeSlowLogsResponseBodyItemsSQLSlowLog) SetMySQLTotalExecutionCounts(v int64) *DescribeSlowLogsResponseBodyItemsSQLSlowLog {
	s.MySQLTotalExecutionCounts = &v
	return s
}

func (s *DescribeSlowLogsResponseBodyItemsSQLSlowLog) SetMySQLTotalExecutionTimes(v int64) *DescribeSlowLogsResponseBodyItemsSQLSlowLog {
	s.MySQLTotalExecutionTimes = &v
	return s
}

func (s *DescribeSlowLogsResponseBodyItemsSQLSlowLog) SetParseMaxRowCount(v int64) *DescribeSlowLogsResponseBodyItemsSQLSlowLog {
	s.ParseMaxRowCount = &v
	return s
}

func (s *DescribeSlowLogsResponseBodyItemsSQLSlowLog) SetParseTotalRowCounts(v int64) *DescribeSlowLogsResponseBodyItemsSQLSlowLog {
	s.ParseTotalRowCounts = &v
	return s
}

func (s *DescribeSlowLogsResponseBodyItemsSQLSlowLog) SetReportTime(v string) *DescribeSlowLogsResponseBodyItemsSQLSlowLog {
	s.ReportTime = &v
	return s
}

func (s *DescribeSlowLogsResponseBodyItemsSQLSlowLog) SetReturnMaxRowCount(v int64) *DescribeSlowLogsResponseBodyItemsSQLSlowLog {
	s.ReturnMaxRowCount = &v
	return s
}

func (s *DescribeSlowLogsResponseBodyItemsSQLSlowLog) SetReturnTotalRowCounts(v int64) *DescribeSlowLogsResponseBodyItemsSQLSlowLog {
	s.ReturnTotalRowCounts = &v
	return s
}

func (s *DescribeSlowLogsResponseBodyItemsSQLSlowLog) SetSQLHASH(v string) *DescribeSlowLogsResponseBodyItemsSQLSlowLog {
	s.SQLHASH = &v
	return s
}

func (s *DescribeSlowLogsResponseBodyItemsSQLSlowLog) SetSQLIdStr(v string) *DescribeSlowLogsResponseBodyItemsSQLSlowLog {
	s.SQLIdStr = &v
	return s
}

func (s *DescribeSlowLogsResponseBodyItemsSQLSlowLog) SetSQLServerAvgCpuTime(v int64) *DescribeSlowLogsResponseBodyItemsSQLSlowLog {
	s.SQLServerAvgCpuTime = &v
	return s
}

func (s *DescribeSlowLogsResponseBodyItemsSQLSlowLog) SetSQLServerAvgExecutionTime(v int64) *DescribeSlowLogsResponseBodyItemsSQLSlowLog {
	s.SQLServerAvgExecutionTime = &v
	return s
}

func (s *DescribeSlowLogsResponseBodyItemsSQLSlowLog) SetSQLServerMaxCpuTime(v int64) *DescribeSlowLogsResponseBodyItemsSQLSlowLog {
	s.SQLServerMaxCpuTime = &v
	return s
}

func (s *DescribeSlowLogsResponseBodyItemsSQLSlowLog) SetSQLServerMinCpuTime(v int64) *DescribeSlowLogsResponseBodyItemsSQLSlowLog {
	s.SQLServerMinCpuTime = &v
	return s
}

func (s *DescribeSlowLogsResponseBodyItemsSQLSlowLog) SetSQLServerMinExecutionTime(v int64) *DescribeSlowLogsResponseBodyItemsSQLSlowLog {
	s.SQLServerMinExecutionTime = &v
	return s
}

func (s *DescribeSlowLogsResponseBodyItemsSQLSlowLog) SetSQLServerTotalCpuTime(v int64) *DescribeSlowLogsResponseBodyItemsSQLSlowLog {
	s.SQLServerTotalCpuTime = &v
	return s
}

func (s *DescribeSlowLogsResponseBodyItemsSQLSlowLog) SetSQLServerTotalExecutionCounts(v int64) *DescribeSlowLogsResponseBodyItemsSQLSlowLog {
	s.SQLServerTotalExecutionCounts = &v
	return s
}

func (s *DescribeSlowLogsResponseBodyItemsSQLSlowLog) SetSQLServerTotalExecutionTimes(v int64) *DescribeSlowLogsResponseBodyItemsSQLSlowLog {
	s.SQLServerTotalExecutionTimes = &v
	return s
}

func (s *DescribeSlowLogsResponseBodyItemsSQLSlowLog) SetSQLText(v string) *DescribeSlowLogsResponseBodyItemsSQLSlowLog {
	s.SQLText = &v
	return s
}

func (s *DescribeSlowLogsResponseBodyItemsSQLSlowLog) SetSlowLogId(v int64) *DescribeSlowLogsResponseBodyItemsSQLSlowLog {
	s.SlowLogId = &v
	return s
}

func (s *DescribeSlowLogsResponseBodyItemsSQLSlowLog) SetTotalIOWriteCounts(v int64) *DescribeSlowLogsResponseBodyItemsSQLSlowLog {
	s.TotalIOWriteCounts = &v
	return s
}

func (s *DescribeSlowLogsResponseBodyItemsSQLSlowLog) SetTotalLastRowsAffectedCounts(v int64) *DescribeSlowLogsResponseBodyItemsSQLSlowLog {
	s.TotalLastRowsAffectedCounts = &v
	return s
}

func (s *DescribeSlowLogsResponseBodyItemsSQLSlowLog) SetTotalLockTimes(v int64) *DescribeSlowLogsResponseBodyItemsSQLSlowLog {
	s.TotalLockTimes = &v
	return s
}

func (s *DescribeSlowLogsResponseBodyItemsSQLSlowLog) SetTotalLogicalReadCounts(v int64) *DescribeSlowLogsResponseBodyItemsSQLSlowLog {
	s.TotalLogicalReadCounts = &v
	return s
}

func (s *DescribeSlowLogsResponseBodyItemsSQLSlowLog) SetTotalPhysicalReadCounts(v int64) *DescribeSlowLogsResponseBodyItemsSQLSlowLog {
	s.TotalPhysicalReadCounts = &v
	return s
}

func (s *DescribeSlowLogsResponseBodyItemsSQLSlowLog) SetTotalRowsAffectedCounts(v int64) *DescribeSlowLogsResponseBodyItemsSQLSlowLog {
	s.TotalRowsAffectedCounts = &v
	return s
}

type DescribeSlowLogsResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeSlowLogsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeSlowLogsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeSlowLogsResponse) GoString() string {
	return s.String()
}

func (s *DescribeSlowLogsResponse) SetHeaders(v map[string]*string) *DescribeSlowLogsResponse {
	s.Headers = v
	return s
}

func (s *DescribeSlowLogsResponse) SetStatusCode(v int32) *DescribeSlowLogsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeSlowLogsResponse) SetBody(v *DescribeSlowLogsResponseBody) *DescribeSlowLogsResponse {
	s.Body = v
	return s
}

type DescribeSupportOnlineResizeDiskRequest struct {
	// The instance ID. You can call the DescribeDBInstances operation to query the instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
}

func (s DescribeSupportOnlineResizeDiskRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeSupportOnlineResizeDiskRequest) GoString() string {
	return s.String()
}

func (s *DescribeSupportOnlineResizeDiskRequest) SetDBInstanceId(v string) *DescribeSupportOnlineResizeDiskRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeSupportOnlineResizeDiskRequest) SetOwnerAccount(v string) *DescribeSupportOnlineResizeDiskRequest {
	s.OwnerAccount = &v
	return s
}

type DescribeSupportOnlineResizeDiskResponseBody struct {
	// The response code returned.
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The response result set.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The response code.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DescribeSupportOnlineResizeDiskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeSupportOnlineResizeDiskResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeSupportOnlineResizeDiskResponseBody) SetCode(v string) *DescribeSupportOnlineResizeDiskResponseBody {
	s.Code = &v
	return s
}

func (s *DescribeSupportOnlineResizeDiskResponseBody) SetData(v string) *DescribeSupportOnlineResizeDiskResponseBody {
	s.Data = &v
	return s
}

func (s *DescribeSupportOnlineResizeDiskResponseBody) SetMessage(v string) *DescribeSupportOnlineResizeDiskResponseBody {
	s.Message = &v
	return s
}

func (s *DescribeSupportOnlineResizeDiskResponseBody) SetRequestId(v string) *DescribeSupportOnlineResizeDiskResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeSupportOnlineResizeDiskResponseBody) SetSuccess(v bool) *DescribeSupportOnlineResizeDiskResponseBody {
	s.Success = &v
	return s
}

type DescribeSupportOnlineResizeDiskResponse struct {
	Headers    map[string]*string                           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeSupportOnlineResizeDiskResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeSupportOnlineResizeDiskResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeSupportOnlineResizeDiskResponse) GoString() string {
	return s.String()
}

func (s *DescribeSupportOnlineResizeDiskResponse) SetHeaders(v map[string]*string) *DescribeSupportOnlineResizeDiskResponse {
	s.Headers = v
	return s
}

func (s *DescribeSupportOnlineResizeDiskResponse) SetStatusCode(v int32) *DescribeSupportOnlineResizeDiskResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeSupportOnlineResizeDiskResponse) SetBody(v *DescribeSupportOnlineResizeDiskResponseBody) *DescribeSupportOnlineResizeDiskResponse {
	s.Body = v
	return s
}

type DescribeTagsRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the instance. You can call the [DescribeDBInstances](~~610396~~) operation to query the ID of the instance.
	//
	// > If you specify this parameter, all tags that are added to the instance are queried. Other filter conditions are invalid.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region. You can call the [DescribeRegions](~~26243~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The type of resource. Set the value to INSTANCE.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The tag that you want to query. The value of the parameter consists of TagKey and TagValue. Format: `{"TagKey":"TagValue"}`.
	Tags *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
	// The ID of the proxy mode.
	ProxyId *string `json:"proxyId,omitempty" xml:"proxyId,omitempty"`
}

func (s DescribeTagsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeTagsRequest) GoString() string {
	return s.String()
}

func (s *DescribeTagsRequest) SetClientToken(v string) *DescribeTagsRequest {
	s.ClientToken = &v
	return s
}

func (s *DescribeTagsRequest) SetDBInstanceId(v string) *DescribeTagsRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeTagsRequest) SetOwnerAccount(v string) *DescribeTagsRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeTagsRequest) SetOwnerId(v int64) *DescribeTagsRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeTagsRequest) SetRegionId(v string) *DescribeTagsRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeTagsRequest) SetResourceOwnerAccount(v string) *DescribeTagsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeTagsRequest) SetResourceOwnerId(v int64) *DescribeTagsRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeTagsRequest) SetResourceType(v string) *DescribeTagsRequest {
	s.ResourceType = &v
	return s
}

func (s *DescribeTagsRequest) SetTags(v string) *DescribeTagsRequest {
	s.Tags = &v
	return s
}

func (s *DescribeTagsRequest) SetProxyId(v string) *DescribeTagsRequest {
	s.ProxyId = &v
	return s
}

type DescribeTagsResponseBody struct {
	// The tags that are added to the instance.
	Items *DescribeTagsResponseBodyItems `json:"Items,omitempty" xml:"Items,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeTagsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeTagsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeTagsResponseBody) SetItems(v *DescribeTagsResponseBodyItems) *DescribeTagsResponseBody {
	s.Items = v
	return s
}

func (s *DescribeTagsResponseBody) SetRequestId(v string) *DescribeTagsResponseBody {
	s.RequestId = &v
	return s
}

type DescribeTagsResponseBodyItems struct {
	TagInfos []*DescribeTagsResponseBodyItemsTagInfos `json:"TagInfos,omitempty" xml:"TagInfos,omitempty" type:"Repeated"`
}

func (s DescribeTagsResponseBodyItems) String() string {
	return tea.Prettify(s)
}

func (s DescribeTagsResponseBodyItems) GoString() string {
	return s.String()
}

func (s *DescribeTagsResponseBodyItems) SetTagInfos(v []*DescribeTagsResponseBodyItemsTagInfos) *DescribeTagsResponseBodyItems {
	s.TagInfos = v
	return s
}

type DescribeTagsResponseBodyItemsTagInfos struct {
	// The IDs of the instances to which the tag is added.
	DBInstanceIds *DescribeTagsResponseBodyItemsTagInfosDBInstanceIds `json:"DBInstanceIds,omitempty" xml:"DBInstanceIds,omitempty" type:"Struct"`
	// The tag key.
	TagKey *string `json:"TagKey,omitempty" xml:"TagKey,omitempty"`
	// The tag value.
	TagValue *string `json:"TagValue,omitempty" xml:"TagValue,omitempty"`
}

func (s DescribeTagsResponseBodyItemsTagInfos) String() string {
	return tea.Prettify(s)
}

func (s DescribeTagsResponseBodyItemsTagInfos) GoString() string {
	return s.String()
}

func (s *DescribeTagsResponseBodyItemsTagInfos) SetDBInstanceIds(v *DescribeTagsResponseBodyItemsTagInfosDBInstanceIds) *DescribeTagsResponseBodyItemsTagInfos {
	s.DBInstanceIds = v
	return s
}

func (s *DescribeTagsResponseBodyItemsTagInfos) SetTagKey(v string) *DescribeTagsResponseBodyItemsTagInfos {
	s.TagKey = &v
	return s
}

func (s *DescribeTagsResponseBodyItemsTagInfos) SetTagValue(v string) *DescribeTagsResponseBodyItemsTagInfos {
	s.TagValue = &v
	return s
}

type DescribeTagsResponseBodyItemsTagInfosDBInstanceIds struct {
	DBInstanceIds []*string `json:"DBInstanceIds,omitempty" xml:"DBInstanceIds,omitempty" type:"Repeated"`
}

func (s DescribeTagsResponseBodyItemsTagInfosDBInstanceIds) String() string {
	return tea.Prettify(s)
}

func (s DescribeTagsResponseBodyItemsTagInfosDBInstanceIds) GoString() string {
	return s.String()
}

func (s *DescribeTagsResponseBodyItemsTagInfosDBInstanceIds) SetDBInstanceIds(v []*string) *DescribeTagsResponseBodyItemsTagInfosDBInstanceIds {
	s.DBInstanceIds = v
	return s
}

type DescribeTagsResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeTagsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeTagsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeTagsResponse) GoString() string {
	return s.String()
}

func (s *DescribeTagsResponse) SetHeaders(v map[string]*string) *DescribeTagsResponse {
	s.Headers = v
	return s
}

func (s *DescribeTagsResponse) SetStatusCode(v int32) *DescribeTagsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeTagsResponse) SetBody(v *DescribeTagsResponseBody) *DescribeTagsResponse {
	s.Body = v
	return s
}

type DescribeTasksRequest struct {
	// The ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The end of the time range to query. The end time must be later than the start time. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm*Z format. The time must be in UTC.
	EndTime      *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of the page to return. Valid values: any non-zero positive integer. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Valid values: **30 to 100**. Default value: **30**.
	PageSize             *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm*Z format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The status of the task. This parameter is invalid.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The operation that is used by the task.
	TaskAction *string `json:"TaskAction,omitempty" xml:"TaskAction,omitempty"`
}

func (s DescribeTasksRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeTasksRequest) GoString() string {
	return s.String()
}

func (s *DescribeTasksRequest) SetDBInstanceId(v string) *DescribeTasksRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeTasksRequest) SetEndTime(v string) *DescribeTasksRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeTasksRequest) SetOwnerAccount(v string) *DescribeTasksRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeTasksRequest) SetOwnerId(v int64) *DescribeTasksRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeTasksRequest) SetPageNumber(v int32) *DescribeTasksRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeTasksRequest) SetPageSize(v int32) *DescribeTasksRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeTasksRequest) SetResourceOwnerAccount(v string) *DescribeTasksRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeTasksRequest) SetResourceOwnerId(v int64) *DescribeTasksRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeTasksRequest) SetStartTime(v string) *DescribeTasksRequest {
	s.StartTime = &v
	return s
}

func (s *DescribeTasksRequest) SetStatus(v string) *DescribeTasksRequest {
	s.Status = &v
	return s
}

func (s *DescribeTasksRequest) SetTaskAction(v string) *DescribeTasksRequest {
	s.TaskAction = &v
	return s
}

type DescribeTasksResponseBody struct {
	// The details of the task execution.
	Items *DescribeTasksResponseBodyItems `json:"Items,omitempty" xml:"Items,omitempty" type:"Struct"`
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries on the current page.
	PageRecordCount *int32 `json:"PageRecordCount,omitempty" xml:"PageRecordCount,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of returned entries.
	TotalRecordCount *int32 `json:"TotalRecordCount,omitempty" xml:"TotalRecordCount,omitempty"`
}

func (s DescribeTasksResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeTasksResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeTasksResponseBody) SetItems(v *DescribeTasksResponseBodyItems) *DescribeTasksResponseBody {
	s.Items = v
	return s
}

func (s *DescribeTasksResponseBody) SetPageNumber(v int32) *DescribeTasksResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeTasksResponseBody) SetPageRecordCount(v int32) *DescribeTasksResponseBody {
	s.PageRecordCount = &v
	return s
}

func (s *DescribeTasksResponseBody) SetRequestId(v string) *DescribeTasksResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeTasksResponseBody) SetTotalRecordCount(v int32) *DescribeTasksResponseBody {
	s.TotalRecordCount = &v
	return s
}

type DescribeTasksResponseBodyItems struct {
	TaskProgressInfo []*DescribeTasksResponseBodyItemsTaskProgressInfo `json:"TaskProgressInfo,omitempty" xml:"TaskProgressInfo,omitempty" type:"Repeated"`
}

func (s DescribeTasksResponseBodyItems) String() string {
	return tea.Prettify(s)
}

func (s DescribeTasksResponseBodyItems) GoString() string {
	return s.String()
}

func (s *DescribeTasksResponseBodyItems) SetTaskProgressInfo(v []*DescribeTasksResponseBodyItemsTaskProgressInfo) *DescribeTasksResponseBodyItems {
	s.TaskProgressInfo = v
	return s
}

type DescribeTasksResponseBodyItemsTaskProgressInfo struct {
	// The start time of the task. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm*Z format. The time is displayed in UTC .
	BeginTime *string `json:"BeginTime,omitempty" xml:"BeginTime,omitempty"`
	// The name of the subtask.
	CurrentStepName *string `json:"CurrentStepName,omitempty" xml:"CurrentStepName,omitempty"`
	// The name of the database. If the task involves a database, the database name is returned.
	DBName *string `json:"DBName,omitempty" xml:"DBName,omitempty"`
	// The estimated end time of the task.
	//
	// > In most cases, this parameter is empty.
	ExpectedFinishTime *string `json:"ExpectedFinishTime,omitempty" xml:"ExpectedFinishTime,omitempty"`
	// The end time of the task. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm*Z format. The time is displayed in UTC.
	FinishTime *string `json:"FinishTime,omitempty" xml:"FinishTime,omitempty"`
	// The progress of the task in percentage.
	Progress *string `json:"Progress,omitempty" xml:"Progress,omitempty"`
	// The description of the task progress.
	//
	// > If no progress description is provided for the task, this parameter is empty.
	ProgressInfo *string `json:"ProgressInfo,omitempty" xml:"ProgressInfo,omitempty"`
	// The estimated remaining time of the task. Unit: seconds.
	//
	// >  If the task is not running, this parameter is not returned or the returned value is **0**.
	Remain *int32 `json:"Remain,omitempty" xml:"Remain,omitempty"`
	// The status of the task.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The progress of the subtask. For example, a value of `1/4` indicates that the task consists of four subtasks and the first subtask is in progress.
	StepProgressInfo *string `json:"StepProgressInfo,omitempty" xml:"StepProgressInfo,omitempty"`
	// The details of the subtasks.
	StepsInfo *string `json:"StepsInfo,omitempty" xml:"StepsInfo,omitempty"`
	// The operation that is used by the task, such as **CreateDBInstance**.
	TaskAction *string `json:"TaskAction,omitempty" xml:"TaskAction,omitempty"`
	// The error code that is returned when an error occurs.
	//
	// > This parameter is returned only when an error occurs.
	TaskErrorCode *string `json:"TaskErrorCode,omitempty" xml:"TaskErrorCode,omitempty"`
	// The error message that is returned when an error occurs.
	//
	// >  This parameter is returned only when an error occurs.
	TaskErrorMessage *string `json:"TaskErrorMessage,omitempty" xml:"TaskErrorMessage,omitempty"`
	// The ID of the task.
	TaskId *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
}

func (s DescribeTasksResponseBodyItemsTaskProgressInfo) String() string {
	return tea.Prettify(s)
}

func (s DescribeTasksResponseBodyItemsTaskProgressInfo) GoString() string {
	return s.String()
}

func (s *DescribeTasksResponseBodyItemsTaskProgressInfo) SetBeginTime(v string) *DescribeTasksResponseBodyItemsTaskProgressInfo {
	s.BeginTime = &v
	return s
}

func (s *DescribeTasksResponseBodyItemsTaskProgressInfo) SetCurrentStepName(v string) *DescribeTasksResponseBodyItemsTaskProgressInfo {
	s.CurrentStepName = &v
	return s
}

func (s *DescribeTasksResponseBodyItemsTaskProgressInfo) SetDBName(v string) *DescribeTasksResponseBodyItemsTaskProgressInfo {
	s.DBName = &v
	return s
}

func (s *DescribeTasksResponseBodyItemsTaskProgressInfo) SetExpectedFinishTime(v string) *DescribeTasksResponseBodyItemsTaskProgressInfo {
	s.ExpectedFinishTime = &v
	return s
}

func (s *DescribeTasksResponseBodyItemsTaskProgressInfo) SetFinishTime(v string) *DescribeTasksResponseBodyItemsTaskProgressInfo {
	s.FinishTime = &v
	return s
}

func (s *DescribeTasksResponseBodyItemsTaskProgressInfo) SetProgress(v string) *DescribeTasksResponseBodyItemsTaskProgressInfo {
	s.Progress = &v
	return s
}

func (s *DescribeTasksResponseBodyItemsTaskProgressInfo) SetProgressInfo(v string) *DescribeTasksResponseBodyItemsTaskProgressInfo {
	s.ProgressInfo = &v
	return s
}

func (s *DescribeTasksResponseBodyItemsTaskProgressInfo) SetRemain(v int32) *DescribeTasksResponseBodyItemsTaskProgressInfo {
	s.Remain = &v
	return s
}

func (s *DescribeTasksResponseBodyItemsTaskProgressInfo) SetStatus(v string) *DescribeTasksResponseBodyItemsTaskProgressInfo {
	s.Status = &v
	return s
}

func (s *DescribeTasksResponseBodyItemsTaskProgressInfo) SetStepProgressInfo(v string) *DescribeTasksResponseBodyItemsTaskProgressInfo {
	s.StepProgressInfo = &v
	return s
}

func (s *DescribeTasksResponseBodyItemsTaskProgressInfo) SetStepsInfo(v string) *DescribeTasksResponseBodyItemsTaskProgressInfo {
	s.StepsInfo = &v
	return s
}

func (s *DescribeTasksResponseBodyItemsTaskProgressInfo) SetTaskAction(v string) *DescribeTasksResponseBodyItemsTaskProgressInfo {
	s.TaskAction = &v
	return s
}

func (s *DescribeTasksResponseBodyItemsTaskProgressInfo) SetTaskErrorCode(v string) *DescribeTasksResponseBodyItemsTaskProgressInfo {
	s.TaskErrorCode = &v
	return s
}

func (s *DescribeTasksResponseBodyItemsTaskProgressInfo) SetTaskErrorMessage(v string) *DescribeTasksResponseBodyItemsTaskProgressInfo {
	s.TaskErrorMessage = &v
	return s
}

func (s *DescribeTasksResponseBodyItemsTaskProgressInfo) SetTaskId(v string) *DescribeTasksResponseBodyItemsTaskProgressInfo {
	s.TaskId = &v
	return s
}

type DescribeTasksResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeTasksResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeTasksResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeTasksResponse) GoString() string {
	return s.String()
}

func (s *DescribeTasksResponse) SetHeaders(v map[string]*string) *DescribeTasksResponse {
	s.Headers = v
	return s
}

func (s *DescribeTasksResponse) SetStatusCode(v int32) *DescribeTasksResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeTasksResponse) SetBody(v *DescribeTasksResponseBody) *DescribeTasksResponse {
	s.Body = v
	return s
}

type DescribeUpgradeMajorVersionPrecheckTaskRequest struct {
	// The ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of the page to return in the upgrade check report.
	//
	// Valid values: any non-zero positive integer. Default value: 1.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page of the upgrade check report.
	//
	// Valid values:
	//
	// *   30 (This is the default value.)
	// *   50
	// *   100
	PageSize             *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The new major engine version of the instance. The new major engine version must be later than the original major engine version.
	//
	// For example, if the original major engine version is PostgreSQL 9.4, the new major engine version can be PostgreSQL 10, PostgreSQL 11, PostgreSQL 12, or PostgreSQL 13.
	TargetMajorVersion *string `json:"TargetMajorVersion,omitempty" xml:"TargetMajorVersion,omitempty"`
	// The ID of the upgrade check task. You can obtain the ID of the upgrade check task from the **TaskId** parameter that is returned from the call of the [UpgradeDBInstanceMajorVersionPrecheck](~~330050~~) operation.
	TaskId *int32 `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
}

func (s DescribeUpgradeMajorVersionPrecheckTaskRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeUpgradeMajorVersionPrecheckTaskRequest) GoString() string {
	return s.String()
}

func (s *DescribeUpgradeMajorVersionPrecheckTaskRequest) SetDBInstanceId(v string) *DescribeUpgradeMajorVersionPrecheckTaskRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeUpgradeMajorVersionPrecheckTaskRequest) SetOwnerAccount(v string) *DescribeUpgradeMajorVersionPrecheckTaskRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeUpgradeMajorVersionPrecheckTaskRequest) SetOwnerId(v int64) *DescribeUpgradeMajorVersionPrecheckTaskRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeUpgradeMajorVersionPrecheckTaskRequest) SetPageNumber(v int32) *DescribeUpgradeMajorVersionPrecheckTaskRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeUpgradeMajorVersionPrecheckTaskRequest) SetPageSize(v int32) *DescribeUpgradeMajorVersionPrecheckTaskRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeUpgradeMajorVersionPrecheckTaskRequest) SetResourceOwnerAccount(v string) *DescribeUpgradeMajorVersionPrecheckTaskRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeUpgradeMajorVersionPrecheckTaskRequest) SetResourceOwnerId(v int64) *DescribeUpgradeMajorVersionPrecheckTaskRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeUpgradeMajorVersionPrecheckTaskRequest) SetTargetMajorVersion(v string) *DescribeUpgradeMajorVersionPrecheckTaskRequest {
	s.TargetMajorVersion = &v
	return s
}

func (s *DescribeUpgradeMajorVersionPrecheckTaskRequest) SetTaskId(v int32) *DescribeUpgradeMajorVersionPrecheckTaskRequest {
	s.TaskId = &v
	return s
}

type DescribeUpgradeMajorVersionPrecheckTaskResponseBody struct {
	// An array that consists of the attributes in the upgrade check report.
	Items []*DescribeUpgradeMajorVersionPrecheckTaskResponseBodyItems `json:"Items,omitempty" xml:"Items,omitempty" type:"Repeated"`
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageRecordCount *int32 `json:"PageRecordCount,omitempty" xml:"PageRecordCount,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries in the upgrade check report.
	TotalRecordCount *int32 `json:"TotalRecordCount,omitempty" xml:"TotalRecordCount,omitempty"`
}

func (s DescribeUpgradeMajorVersionPrecheckTaskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeUpgradeMajorVersionPrecheckTaskResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeUpgradeMajorVersionPrecheckTaskResponseBody) SetItems(v []*DescribeUpgradeMajorVersionPrecheckTaskResponseBodyItems) *DescribeUpgradeMajorVersionPrecheckTaskResponseBody {
	s.Items = v
	return s
}

func (s *DescribeUpgradeMajorVersionPrecheckTaskResponseBody) SetPageNumber(v int32) *DescribeUpgradeMajorVersionPrecheckTaskResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeUpgradeMajorVersionPrecheckTaskResponseBody) SetPageRecordCount(v int32) *DescribeUpgradeMajorVersionPrecheckTaskResponseBody {
	s.PageRecordCount = &v
	return s
}

func (s *DescribeUpgradeMajorVersionPrecheckTaskResponseBody) SetRequestId(v string) *DescribeUpgradeMajorVersionPrecheckTaskResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeUpgradeMajorVersionPrecheckTaskResponseBody) SetTotalRecordCount(v int32) *DescribeUpgradeMajorVersionPrecheckTaskResponseBody {
	s.TotalRecordCount = &v
	return s
}

type DescribeUpgradeMajorVersionPrecheckTaskResponseBodyItems struct {
	// The time at which the upgrade check was performed.
	//
	// The value of this parameter is a timestamp that follows the UNIX time format. Unit: milliseconds.
	CheckTime *string `json:"CheckTime,omitempty" xml:"CheckTime,omitempty"`
	// The content of the upgrade check report.
	Detail *string `json:"Detail,omitempty" xml:"Detail,omitempty"`
	// The expiration time of the upgrade check report.
	//
	// The value of this parameter is a timestamp that follows the UNIX time format. Unit: milliseconds.
	EffectiveTime *string `json:"EffectiveTime,omitempty" xml:"EffectiveTime,omitempty"`
	// The result of the upgrade check.
	//
	// Valid values:
	//
	// *   Success
	// *   Fail
	//
	// >  If the check result is **Fail**, you must check the value of the **Detail** parameter to obtain the information about the errors that occurred. After you handle the errors, you can try again. For more information about how to handle common errors, see [Introduction to the check report for a major engine version upgrade to an ApsaraDB RDS for PostgreSQL instance](~~218391~~).
	Result *string `json:"Result,omitempty" xml:"Result,omitempty"`
	// The original major engine version of the instance.
	SourceMajorVersion *string `json:"SourceMajorVersion,omitempty" xml:"SourceMajorVersion,omitempty"`
	// The new major engine version of the instance.
	TargetMajorVersion *string `json:"TargetMajorVersion,omitempty" xml:"TargetMajorVersion,omitempty"`
	// The ID of the upgrade check task.
	TaskId *int32 `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
}

func (s DescribeUpgradeMajorVersionPrecheckTaskResponseBodyItems) String() string {
	return tea.Prettify(s)
}

func (s DescribeUpgradeMajorVersionPrecheckTaskResponseBodyItems) GoString() string {
	return s.String()
}

func (s *DescribeUpgradeMajorVersionPrecheckTaskResponseBodyItems) SetCheckTime(v string) *DescribeUpgradeMajorVersionPrecheckTaskResponseBodyItems {
	s.CheckTime = &v
	return s
}

func (s *DescribeUpgradeMajorVersionPrecheckTaskResponseBodyItems) SetDetail(v string) *DescribeUpgradeMajorVersionPrecheckTaskResponseBodyItems {
	s.Detail = &v
	return s
}

func (s *DescribeUpgradeMajorVersionPrecheckTaskResponseBodyItems) SetEffectiveTime(v string) *DescribeUpgradeMajorVersionPrecheckTaskResponseBodyItems {
	s.EffectiveTime = &v
	return s
}

func (s *DescribeUpgradeMajorVersionPrecheckTaskResponseBodyItems) SetResult(v string) *DescribeUpgradeMajorVersionPrecheckTaskResponseBodyItems {
	s.Result = &v
	return s
}

func (s *DescribeUpgradeMajorVersionPrecheckTaskResponseBodyItems) SetSourceMajorVersion(v string) *DescribeUpgradeMajorVersionPrecheckTaskResponseBodyItems {
	s.SourceMajorVersion = &v
	return s
}

func (s *DescribeUpgradeMajorVersionPrecheckTaskResponseBodyItems) SetTargetMajorVersion(v string) *DescribeUpgradeMajorVersionPrecheckTaskResponseBodyItems {
	s.TargetMajorVersion = &v
	return s
}

func (s *DescribeUpgradeMajorVersionPrecheckTaskResponseBodyItems) SetTaskId(v int32) *DescribeUpgradeMajorVersionPrecheckTaskResponseBodyItems {
	s.TaskId = &v
	return s
}

type DescribeUpgradeMajorVersionPrecheckTaskResponse struct {
	Headers    map[string]*string                                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeUpgradeMajorVersionPrecheckTaskResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeUpgradeMajorVersionPrecheckTaskResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeUpgradeMajorVersionPrecheckTaskResponse) GoString() string {
	return s.String()
}

func (s *DescribeUpgradeMajorVersionPrecheckTaskResponse) SetHeaders(v map[string]*string) *DescribeUpgradeMajorVersionPrecheckTaskResponse {
	s.Headers = v
	return s
}

func (s *DescribeUpgradeMajorVersionPrecheckTaskResponse) SetStatusCode(v int32) *DescribeUpgradeMajorVersionPrecheckTaskResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeUpgradeMajorVersionPrecheckTaskResponse) SetBody(v *DescribeUpgradeMajorVersionPrecheckTaskResponseBody) *DescribeUpgradeMajorVersionPrecheckTaskResponse {
	s.Body = v
	return s
}

type DescribeUpgradeMajorVersionTasksRequest struct {
	// The ID of the original instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of the page to return.
	//
	// Valid values: any non-zero positive integer.
	//
	// Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page.
	//
	// Valid values: **30** to **100**.
	//
	// Default value: **30**.
	PageSize             *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The major engine version of the new instance. Valid values:
	//
	// *   **10.0**
	// *   **11.0**
	// *   **12.0**
	// *   **13.0**
	TargetMajorVersion *string `json:"TargetMajorVersion,omitempty" xml:"TargetMajorVersion,omitempty"`
	// This parameter is reserved. You do not need to specify this parameter.
	TaskId *int32 `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
}

func (s DescribeUpgradeMajorVersionTasksRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeUpgradeMajorVersionTasksRequest) GoString() string {
	return s.String()
}

func (s *DescribeUpgradeMajorVersionTasksRequest) SetDBInstanceId(v string) *DescribeUpgradeMajorVersionTasksRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DescribeUpgradeMajorVersionTasksRequest) SetOwnerAccount(v string) *DescribeUpgradeMajorVersionTasksRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeUpgradeMajorVersionTasksRequest) SetOwnerId(v int64) *DescribeUpgradeMajorVersionTasksRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeUpgradeMajorVersionTasksRequest) SetPageNumber(v int32) *DescribeUpgradeMajorVersionTasksRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeUpgradeMajorVersionTasksRequest) SetPageSize(v int32) *DescribeUpgradeMajorVersionTasksRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeUpgradeMajorVersionTasksRequest) SetResourceOwnerAccount(v string) *DescribeUpgradeMajorVersionTasksRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeUpgradeMajorVersionTasksRequest) SetResourceOwnerId(v int64) *DescribeUpgradeMajorVersionTasksRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeUpgradeMajorVersionTasksRequest) SetTargetMajorVersion(v string) *DescribeUpgradeMajorVersionTasksRequest {
	s.TargetMajorVersion = &v
	return s
}

func (s *DescribeUpgradeMajorVersionTasksRequest) SetTaskId(v int32) *DescribeUpgradeMajorVersionTasksRequest {
	s.TaskId = &v
	return s
}

type DescribeUpgradeMajorVersionTasksResponseBody struct {
	// An array that consists of the information about the tasks that are returned.
	Items []*DescribeUpgradeMajorVersionTasksResponseBodyItems `json:"Items,omitempty" xml:"Items,omitempty" type:"Repeated"`
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned on each page.
	PageRecordCount *int32 `json:"PageRecordCount,omitempty" xml:"PageRecordCount,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries.
	TotalRecordCount *int32 `json:"TotalRecordCount,omitempty" xml:"TotalRecordCount,omitempty"`
}

func (s DescribeUpgradeMajorVersionTasksResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeUpgradeMajorVersionTasksResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeUpgradeMajorVersionTasksResponseBody) SetItems(v []*DescribeUpgradeMajorVersionTasksResponseBodyItems) *DescribeUpgradeMajorVersionTasksResponseBody {
	s.Items = v
	return s
}

func (s *DescribeUpgradeMajorVersionTasksResponseBody) SetPageNumber(v int32) *DescribeUpgradeMajorVersionTasksResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeUpgradeMajorVersionTasksResponseBody) SetPageRecordCount(v int32) *DescribeUpgradeMajorVersionTasksResponseBody {
	s.PageRecordCount = &v
	return s
}

func (s *DescribeUpgradeMajorVersionTasksResponseBody) SetRequestId(v string) *DescribeUpgradeMajorVersionTasksResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeUpgradeMajorVersionTasksResponseBody) SetTotalRecordCount(v int32) *DescribeUpgradeMajorVersionTasksResponseBody {
	s.TotalRecordCount = &v
	return s
}

type DescribeUpgradeMajorVersionTasksResponseBodyItems struct {
	// The time at which ApsaraDB RDS collects the statistics of the new RDS instance.
	//
	// Valid values:
	//
	// *   **After**: ApsaraDB RDS collects the statistics of the new instance after a switchover.
	// *   **Before**: ApsaraDB RDS collects the statistics of the new instance before a switchover.
	CollectStatMode *string `json:"CollectStatMode,omitempty" xml:"CollectStatMode,omitempty"`
	// The details of the task.
	Detail *string `json:"Detail,omitempty" xml:"Detail,omitempty"`
	// The time at which the task ended.
	//
	// The value of this parameter is a timestamp that follows the UNIX time format. Unit: milliseconds.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The status of the task.
	//
	// *   **Success**: The task is successful.
	// *   **Failed**: The task failed.
	// *   **Running**: The task is in the phase in which data is being migrated to a new instance.
	Result *string `json:"Result,omitempty" xml:"Result,omitempty"`
	// The ID of the original instance.
	SourceInsName *string `json:"SourceInsName,omitempty" xml:"SourceInsName,omitempty"`
	// The major engine version of the original instance.
	SourceMajorVersion *string `json:"SourceMajorVersion,omitempty" xml:"SourceMajorVersion,omitempty"`
	// The time at which the task started.
	//
	// The value of this parameter is a timestamp that follows the UNIX time format. Unit: milliseconds.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The time at which your workloads are switched over from the original instance to the new instance.
	//
	// The value of this parameter is a timestamp that follows the UNIX time format. Unit: milliseconds.
	SwitchTime *string `json:"SwitchTime,omitempty" xml:"SwitchTime,omitempty"`
	// The ID of the new instance.
	TargetInsName *string `json:"TargetInsName,omitempty" xml:"TargetInsName,omitempty"`
	// The major engine version of the new instance. Valid values:
	//
	// *   **10.0**
	// *   **11.0**
	// *   **12.0**
	// *   **13.0**
	TargetMajorVersion *string `json:"TargetMajorVersion,omitempty" xml:"TargetMajorVersion,omitempty"`
	// The ID of the task.
	TaskId *int32 `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
	// Indicates whether ApsaraDB RDS migrates data to the new instance and switches your workloads over to the new instance.
	//
	// Valid values:
	//
	// *   **clone**: ApsaraDB RDS does not migrate data to the new instance and does not switch your workloads over to the new instance.
	// *   **switch**: ApsaraDB RDS migrates data to the new instance and switches your workloads over to the new instance.
	UpgradeMode *string `json:"UpgradeMode,omitempty" xml:"UpgradeMode,omitempty"`
}

func (s DescribeUpgradeMajorVersionTasksResponseBodyItems) String() string {
	return tea.Prettify(s)
}

func (s DescribeUpgradeMajorVersionTasksResponseBodyItems) GoString() string {
	return s.String()
}

func (s *DescribeUpgradeMajorVersionTasksResponseBodyItems) SetCollectStatMode(v string) *DescribeUpgradeMajorVersionTasksResponseBodyItems {
	s.CollectStatMode = &v
	return s
}

func (s *DescribeUpgradeMajorVersionTasksResponseBodyItems) SetDetail(v string) *DescribeUpgradeMajorVersionTasksResponseBodyItems {
	s.Detail = &v
	return s
}

func (s *DescribeUpgradeMajorVersionTasksResponseBodyItems) SetEndTime(v string) *DescribeUpgradeMajorVersionTasksResponseBodyItems {
	s.EndTime = &v
	return s
}

func (s *DescribeUpgradeMajorVersionTasksResponseBodyItems) SetResult(v string) *DescribeUpgradeMajorVersionTasksResponseBodyItems {
	s.Result = &v
	return s
}

func (s *DescribeUpgradeMajorVersionTasksResponseBodyItems) SetSourceInsName(v string) *DescribeUpgradeMajorVersionTasksResponseBodyItems {
	s.SourceInsName = &v
	return s
}

func (s *DescribeUpgradeMajorVersionTasksResponseBodyItems) SetSourceMajorVersion(v string) *DescribeUpgradeMajorVersionTasksResponseBodyItems {
	s.SourceMajorVersion = &v
	return s
}

func (s *DescribeUpgradeMajorVersionTasksResponseBodyItems) SetStartTime(v string) *DescribeUpgradeMajorVersionTasksResponseBodyItems {
	s.StartTime = &v
	return s
}

func (s *DescribeUpgradeMajorVersionTasksResponseBodyItems) SetSwitchTime(v string) *DescribeUpgradeMajorVersionTasksResponseBodyItems {
	s.SwitchTime = &v
	return s
}

func (s *DescribeUpgradeMajorVersionTasksResponseBodyItems) SetTargetInsName(v string) *DescribeUpgradeMajorVersionTasksResponseBodyItems {
	s.TargetInsName = &v
	return s
}

func (s *DescribeUpgradeMajorVersionTasksResponseBodyItems) SetTargetMajorVersion(v string) *DescribeUpgradeMajorVersionTasksResponseBodyItems {
	s.TargetMajorVersion = &v
	return s
}

func (s *DescribeUpgradeMajorVersionTasksResponseBodyItems) SetTaskId(v int32) *DescribeUpgradeMajorVersionTasksResponseBodyItems {
	s.TaskId = &v
	return s
}

func (s *DescribeUpgradeMajorVersionTasksResponseBodyItems) SetUpgradeMode(v string) *DescribeUpgradeMajorVersionTasksResponseBodyItems {
	s.UpgradeMode = &v
	return s
}

type DescribeUpgradeMajorVersionTasksResponse struct {
	Headers    map[string]*string                            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeUpgradeMajorVersionTasksResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeUpgradeMajorVersionTasksResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeUpgradeMajorVersionTasksResponse) GoString() string {
	return s.String()
}

func (s *DescribeUpgradeMajorVersionTasksResponse) SetHeaders(v map[string]*string) *DescribeUpgradeMajorVersionTasksResponse {
	s.Headers = v
	return s
}

func (s *DescribeUpgradeMajorVersionTasksResponse) SetStatusCode(v int32) *DescribeUpgradeMajorVersionTasksResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeUpgradeMajorVersionTasksResponse) SetBody(v *DescribeUpgradeMajorVersionTasksResponseBody) *DescribeUpgradeMajorVersionTasksResponse {
	s.Body = v
	return s
}

type DescribeVSwitchesRequest struct {
	// The ID of the dedicated cluster. You can call the [DescribeDedicatedHostGroups](~~610640~~) operation to query the ID of the dedicated cluster. If you configure this parameter, the details of all vSwitches in the VPC to which the dedicated cluster belongs are returned.
	//
	// > You must configure this parameter or **VpcId**.
	DedicatedHostGroupId *string `json:"DedicatedHostGroupId,omitempty" xml:"DedicatedHostGroupId,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of the page to return. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Valid values: **1 to 50**. Default value: **30**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The region ID of the vSwitch. You can call the [DescribeRegions](~~610399~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	SecurityToken        *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
	// The ID of the VPC to which the vSwitch belongs.
	//
	// > You must configure this parameter or **DedicatedHostGroupId**.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
	// The ID of the zone to which the vSwitch belongs. You can call the [DescribeAvailableZones](~~610392~~) operation to query the ID of the zone. If you specify this parameter, the query results are filtered based on the value of this parameter and only the details of the vSwitch that is deployed in the specified zone is returned.
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
}

func (s DescribeVSwitchesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeVSwitchesRequest) GoString() string {
	return s.String()
}

func (s *DescribeVSwitchesRequest) SetDedicatedHostGroupId(v string) *DescribeVSwitchesRequest {
	s.DedicatedHostGroupId = &v
	return s
}

func (s *DescribeVSwitchesRequest) SetOwnerAccount(v string) *DescribeVSwitchesRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeVSwitchesRequest) SetOwnerId(v int64) *DescribeVSwitchesRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeVSwitchesRequest) SetPageNumber(v int32) *DescribeVSwitchesRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeVSwitchesRequest) SetPageSize(v int32) *DescribeVSwitchesRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeVSwitchesRequest) SetRegionId(v string) *DescribeVSwitchesRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeVSwitchesRequest) SetResourceGroupId(v string) *DescribeVSwitchesRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeVSwitchesRequest) SetResourceOwnerAccount(v string) *DescribeVSwitchesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeVSwitchesRequest) SetResourceOwnerId(v int64) *DescribeVSwitchesRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeVSwitchesRequest) SetSecurityToken(v string) *DescribeVSwitchesRequest {
	s.SecurityToken = &v
	return s
}

func (s *DescribeVSwitchesRequest) SetVpcId(v string) *DescribeVSwitchesRequest {
	s.VpcId = &v
	return s
}

func (s *DescribeVSwitchesRequest) SetZoneId(v string) *DescribeVSwitchesRequest {
	s.ZoneId = &v
	return s
}

type DescribeVSwitchesResponseBody struct {
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned on each page. The value of this parameter is the same as the value of the **PageSize** parameter in the request parameters.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of returned entries.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
	// The information about the vSwitches.
	VSwitchs []*DescribeVSwitchesResponseBodyVSwitchs `json:"VSwitchs,omitempty" xml:"VSwitchs,omitempty" type:"Repeated"`
}

func (s DescribeVSwitchesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeVSwitchesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeVSwitchesResponseBody) SetPageNumber(v int32) *DescribeVSwitchesResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeVSwitchesResponseBody) SetPageSize(v int32) *DescribeVSwitchesResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeVSwitchesResponseBody) SetRequestId(v string) *DescribeVSwitchesResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeVSwitchesResponseBody) SetTotalCount(v int32) *DescribeVSwitchesResponseBody {
	s.TotalCount = &v
	return s
}

func (s *DescribeVSwitchesResponseBody) SetVSwitchs(v []*DescribeVSwitchesResponseBodyVSwitchs) *DescribeVSwitchesResponseBody {
	s.VSwitchs = v
	return s
}

type DescribeVSwitchesResponseBodyVSwitchs struct {
	// The number of available IP addresses in the vSwitch.
	AvailableIpAddressCount *string `json:"AvailableIpAddressCount,omitempty" xml:"AvailableIpAddressCount,omitempty"`
	// The CIDR block of the vSwitch.
	CidrBlock *string `json:"CidrBlock,omitempty" xml:"CidrBlock,omitempty"`
	// The description of the vSwitch.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// Indicates whether the vSwitch is the default vSwitch. Valid values:
	//
	// *   **true**
	// *   **false**
	IsDefault *bool `json:"IsDefault,omitempty" xml:"IsDefault,omitempty"`
	// The ID of the zone to which the vSwitch belongs.
	IzNo *string `json:"IzNo,omitempty" xml:"IzNo,omitempty"`
	// The status of the vSwitch. Valid values:
	//
	// *   **Pending**: The vSwitch is being configured.
	// *   **Available**: The vSwitch is available.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The vSwitch ID.
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
	// The vSwitch name.
	VSwitchName *string `json:"VSwitchName,omitempty" xml:"VSwitchName,omitempty"`
}

func (s DescribeVSwitchesResponseBodyVSwitchs) String() string {
	return tea.Prettify(s)
}

func (s DescribeVSwitchesResponseBodyVSwitchs) GoString() string {
	return s.String()
}

func (s *DescribeVSwitchesResponseBodyVSwitchs) SetAvailableIpAddressCount(v string) *DescribeVSwitchesResponseBodyVSwitchs {
	s.AvailableIpAddressCount = &v
	return s
}

func (s *DescribeVSwitchesResponseBodyVSwitchs) SetCidrBlock(v string) *DescribeVSwitchesResponseBodyVSwitchs {
	s.CidrBlock = &v
	return s
}

func (s *DescribeVSwitchesResponseBodyVSwitchs) SetDescription(v string) *DescribeVSwitchesResponseBodyVSwitchs {
	s.Description = &v
	return s
}

func (s *DescribeVSwitchesResponseBodyVSwitchs) SetIsDefault(v bool) *DescribeVSwitchesResponseBodyVSwitchs {
	s.IsDefault = &v
	return s
}

func (s *DescribeVSwitchesResponseBodyVSwitchs) SetIzNo(v string) *DescribeVSwitchesResponseBodyVSwitchs {
	s.IzNo = &v
	return s
}

func (s *DescribeVSwitchesResponseBodyVSwitchs) SetStatus(v string) *DescribeVSwitchesResponseBodyVSwitchs {
	s.Status = &v
	return s
}

func (s *DescribeVSwitchesResponseBodyVSwitchs) SetVSwitchId(v string) *DescribeVSwitchesResponseBodyVSwitchs {
	s.VSwitchId = &v
	return s
}

func (s *DescribeVSwitchesResponseBodyVSwitchs) SetVSwitchName(v string) *DescribeVSwitchesResponseBodyVSwitchs {
	s.VSwitchName = &v
	return s
}

type DescribeVSwitchesResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeVSwitchesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeVSwitchesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeVSwitchesResponse) GoString() string {
	return s.String()
}

func (s *DescribeVSwitchesResponse) SetHeaders(v map[string]*string) *DescribeVSwitchesResponse {
	s.Headers = v
	return s
}

func (s *DescribeVSwitchesResponse) SetStatusCode(v int32) *DescribeVSwitchesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeVSwitchesResponse) SetBody(v *DescribeVSwitchesResponseBody) *DescribeVSwitchesResponse {
	s.Body = v
	return s
}

type DescribeWhitelistTemplateRequest struct {
	// The resource group ID.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the whitelist template. You can call the [DescribeAllWhitelistTemplate](~~2412075~~) operation to obtain the ID of the whitelist template.
	TemplateId *int32 `json:"TemplateId,omitempty" xml:"TemplateId,omitempty"`
}

func (s DescribeWhitelistTemplateRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeWhitelistTemplateRequest) GoString() string {
	return s.String()
}

func (s *DescribeWhitelistTemplateRequest) SetResourceGroupId(v string) *DescribeWhitelistTemplateRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeWhitelistTemplateRequest) SetResourceOwnerAccount(v string) *DescribeWhitelistTemplateRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeWhitelistTemplateRequest) SetResourceOwnerId(v int64) *DescribeWhitelistTemplateRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeWhitelistTemplateRequest) SetTemplateId(v int32) *DescribeWhitelistTemplateRequest {
	s.TemplateId = &v
	return s
}

type DescribeWhitelistTemplateResponseBody struct {
	// The response code returned. Valid values:
	//
	// *   **200**: success
	// *   **400**: client error
	// *   **401**: identity authentication failed
	// *   **404**: request page not found
	// *   **500**: server error
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data returned.
	Data *DescribeWhitelistTemplateResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The HTTP status code returned. Valid values:
	//
	// *   **200**: success
	// *   **400**: client error
	// *   **500**: server error
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The response parameters.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful. Valid values:
	//
	// *   **true**
	// *   **false**
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DescribeWhitelistTemplateResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeWhitelistTemplateResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeWhitelistTemplateResponseBody) SetCode(v string) *DescribeWhitelistTemplateResponseBody {
	s.Code = &v
	return s
}

func (s *DescribeWhitelistTemplateResponseBody) SetData(v *DescribeWhitelistTemplateResponseBodyData) *DescribeWhitelistTemplateResponseBody {
	s.Data = v
	return s
}

func (s *DescribeWhitelistTemplateResponseBody) SetHttpStatusCode(v int32) *DescribeWhitelistTemplateResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *DescribeWhitelistTemplateResponseBody) SetMessage(v string) *DescribeWhitelistTemplateResponseBody {
	s.Message = &v
	return s
}

func (s *DescribeWhitelistTemplateResponseBody) SetRequestId(v string) *DescribeWhitelistTemplateResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeWhitelistTemplateResponseBody) SetSuccess(v bool) *DescribeWhitelistTemplateResponseBody {
	s.Success = &v
	return s
}

type DescribeWhitelistTemplateResponseBodyData struct {
	// The information about the IP whitelist template.
	Template *DescribeWhitelistTemplateResponseBodyDataTemplate `json:"Template,omitempty" xml:"Template,omitempty" type:"Struct"`
}

func (s DescribeWhitelistTemplateResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s DescribeWhitelistTemplateResponseBodyData) GoString() string {
	return s.String()
}

func (s *DescribeWhitelistTemplateResponseBodyData) SetTemplate(v *DescribeWhitelistTemplateResponseBodyDataTemplate) *DescribeWhitelistTemplateResponseBodyData {
	s.Template = v
	return s
}

type DescribeWhitelistTemplateResponseBodyDataTemplate struct {
	// The primary key of the data table.
	Id *int32 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The IP addresses.
	Ips *string `json:"Ips,omitempty" xml:"Ips,omitempty"`
	// The ID of the whitelist template.
	TemplateId *int32 `json:"TemplateId,omitempty" xml:"TemplateId,omitempty"`
	// The name of the IP whitelist template.
	TemplateName *string `json:"TemplateName,omitempty" xml:"TemplateName,omitempty"`
	// The user ID.
	UserId *int32 `json:"UserId,omitempty" xml:"UserId,omitempty"`
}

func (s DescribeWhitelistTemplateResponseBodyDataTemplate) String() string {
	return tea.Prettify(s)
}

func (s DescribeWhitelistTemplateResponseBodyDataTemplate) GoString() string {
	return s.String()
}

func (s *DescribeWhitelistTemplateResponseBodyDataTemplate) SetId(v int32) *DescribeWhitelistTemplateResponseBodyDataTemplate {
	s.Id = &v
	return s
}

func (s *DescribeWhitelistTemplateResponseBodyDataTemplate) SetIps(v string) *DescribeWhitelistTemplateResponseBodyDataTemplate {
	s.Ips = &v
	return s
}

func (s *DescribeWhitelistTemplateResponseBodyDataTemplate) SetTemplateId(v int32) *DescribeWhitelistTemplateResponseBodyDataTemplate {
	s.TemplateId = &v
	return s
}

func (s *DescribeWhitelistTemplateResponseBodyDataTemplate) SetTemplateName(v string) *DescribeWhitelistTemplateResponseBodyDataTemplate {
	s.TemplateName = &v
	return s
}

func (s *DescribeWhitelistTemplateResponseBodyDataTemplate) SetUserId(v int32) *DescribeWhitelistTemplateResponseBodyDataTemplate {
	s.UserId = &v
	return s
}

type DescribeWhitelistTemplateResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeWhitelistTemplateResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeWhitelistTemplateResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeWhitelistTemplateResponse) GoString() string {
	return s.String()
}

func (s *DescribeWhitelistTemplateResponse) SetHeaders(v map[string]*string) *DescribeWhitelistTemplateResponse {
	s.Headers = v
	return s
}

func (s *DescribeWhitelistTemplateResponse) SetStatusCode(v int32) *DescribeWhitelistTemplateResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeWhitelistTemplateResponse) SetBody(v *DescribeWhitelistTemplateResponseBody) *DescribeWhitelistTemplateResponse {
	s.Body = v
	return s
}

type DescribeWhitelistTemplateLinkedInstanceRequest struct {
	// 资源组ID，可以为空。
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the whitelist template. You can call the DescribeAllWhitelistTemplate operation to obtain the ID of the whitelist template.
	TemplateId *int32 `json:"TemplateId,omitempty" xml:"TemplateId,omitempty"`
}

func (s DescribeWhitelistTemplateLinkedInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeWhitelistTemplateLinkedInstanceRequest) GoString() string {
	return s.String()
}

func (s *DescribeWhitelistTemplateLinkedInstanceRequest) SetResourceGroupId(v string) *DescribeWhitelistTemplateLinkedInstanceRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeWhitelistTemplateLinkedInstanceRequest) SetResourceOwnerAccount(v string) *DescribeWhitelistTemplateLinkedInstanceRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeWhitelistTemplateLinkedInstanceRequest) SetResourceOwnerId(v int64) *DescribeWhitelistTemplateLinkedInstanceRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeWhitelistTemplateLinkedInstanceRequest) SetTemplateId(v int32) *DescribeWhitelistTemplateLinkedInstanceRequest {
	s.TemplateId = &v
	return s
}

type DescribeWhitelistTemplateLinkedInstanceResponseBody struct {
	// The response code returned. Valid values:
	//
	// *   **200**: success
	// *   **400**: client error
	// *   **401**: identity authentication failed
	// *   **404**: request page not found
	// *   **500**: server error
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data returned.
	Data *DescribeWhitelistTemplateLinkedInstanceResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The HTTP status code returned. Valid values:
	//
	// *   **200**: success
	// *   **400**: client error
	// *   **500**: server error
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The returned message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful. Valid values:
	//
	// *   **true**
	// *   **false**
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DescribeWhitelistTemplateLinkedInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeWhitelistTemplateLinkedInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeWhitelistTemplateLinkedInstanceResponseBody) SetCode(v string) *DescribeWhitelistTemplateLinkedInstanceResponseBody {
	s.Code = &v
	return s
}

func (s *DescribeWhitelistTemplateLinkedInstanceResponseBody) SetData(v *DescribeWhitelistTemplateLinkedInstanceResponseBodyData) *DescribeWhitelistTemplateLinkedInstanceResponseBody {
	s.Data = v
	return s
}

func (s *DescribeWhitelistTemplateLinkedInstanceResponseBody) SetHttpStatusCode(v int32) *DescribeWhitelistTemplateLinkedInstanceResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *DescribeWhitelistTemplateLinkedInstanceResponseBody) SetMessage(v string) *DescribeWhitelistTemplateLinkedInstanceResponseBody {
	s.Message = &v
	return s
}

func (s *DescribeWhitelistTemplateLinkedInstanceResponseBody) SetRequestId(v string) *DescribeWhitelistTemplateLinkedInstanceResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeWhitelistTemplateLinkedInstanceResponseBody) SetSuccess(v bool) *DescribeWhitelistTemplateLinkedInstanceResponseBody {
	s.Success = &v
	return s
}

type DescribeWhitelistTemplateLinkedInstanceResponseBodyData struct {
	// The information about the instance.
	InsName []*string `json:"InsName,omitempty" xml:"InsName,omitempty" type:"Repeated"`
	// The ID of the whitelist template.
	TemplateId *int32 `json:"TemplateId,omitempty" xml:"TemplateId,omitempty"`
}

func (s DescribeWhitelistTemplateLinkedInstanceResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s DescribeWhitelistTemplateLinkedInstanceResponseBodyData) GoString() string {
	return s.String()
}

func (s *DescribeWhitelistTemplateLinkedInstanceResponseBodyData) SetInsName(v []*string) *DescribeWhitelistTemplateLinkedInstanceResponseBodyData {
	s.InsName = v
	return s
}

func (s *DescribeWhitelistTemplateLinkedInstanceResponseBodyData) SetTemplateId(v int32) *DescribeWhitelistTemplateLinkedInstanceResponseBodyData {
	s.TemplateId = &v
	return s
}

type DescribeWhitelistTemplateLinkedInstanceResponse struct {
	Headers    map[string]*string                                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeWhitelistTemplateLinkedInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeWhitelistTemplateLinkedInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeWhitelistTemplateLinkedInstanceResponse) GoString() string {
	return s.String()
}

func (s *DescribeWhitelistTemplateLinkedInstanceResponse) SetHeaders(v map[string]*string) *DescribeWhitelistTemplateLinkedInstanceResponse {
	s.Headers = v
	return s
}

func (s *DescribeWhitelistTemplateLinkedInstanceResponse) SetStatusCode(v int32) *DescribeWhitelistTemplateLinkedInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeWhitelistTemplateLinkedInstanceResponse) SetBody(v *DescribeWhitelistTemplateLinkedInstanceResponseBody) *DescribeWhitelistTemplateLinkedInstanceResponse {
	s.Body = v
	return s
}

type DestroyDBInstanceRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// > You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the instance. You can call the [DescribeDBInstances](~~26232~~) operation to query the ID of the instance.
	DBInstanceId         *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DestroyDBInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s DestroyDBInstanceRequest) GoString() string {
	return s.String()
}

func (s *DestroyDBInstanceRequest) SetClientToken(v string) *DestroyDBInstanceRequest {
	s.ClientToken = &v
	return s
}

func (s *DestroyDBInstanceRequest) SetDBInstanceId(v string) *DestroyDBInstanceRequest {
	s.DBInstanceId = &v
	return s
}

func (s *DestroyDBInstanceRequest) SetOwnerAccount(v string) *DestroyDBInstanceRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DestroyDBInstanceRequest) SetOwnerId(v int64) *DestroyDBInstanceRequest {
	s.OwnerId = &v
	return s
}

func (s *DestroyDBInstanceRequest) SetResourceOwnerAccount(v string) *DestroyDBInstanceRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DestroyDBInstanceRequest) SetResourceOwnerId(v int64) *DestroyDBInstanceRequest {
	s.ResourceOwnerId = &v
	return s
}

type DestroyDBInstanceResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DestroyDBInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DestroyDBInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *DestroyDBInstanceResponseBody) SetRequestId(v string) *DestroyDBInstanceResponseBody {
	s.RequestId = &v
	return s
}

type DestroyDBInstanceResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DestroyDBInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DestroyDBInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s DestroyDBInstanceResponse) GoString() string {
	return s.String()
}

func (s *DestroyDBInstanceResponse) SetHeaders(v map[string]*string) *DestroyDBInstanceResponse {
	s.Headers = v
	return s
}

func (s *DestroyDBInstanceResponse) SetStatusCode(v int32) *DestroyDBInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *DestroyDBInstanceResponse) SetBody(v *DestroyDBInstanceResponseBody) *DestroyDBInstanceResponse {
	s.Body = v
	return s
}

type DetachGadInstanceMemberRequest struct {
	// The ID of the global active database cluster.
	GadInstanceName *string `json:"GadInstanceName,omitempty" xml:"GadInstanceName,omitempty"`
	// The ID of the instance that serves as the unit node you want to remove. You can call the [DescribeGadInstances](~~330105~~) query the ID of the instance.
	MemberInstanceName *string `json:"MemberInstanceName,omitempty" xml:"MemberInstanceName,omitempty"`
	// The region ID of the central node. You can call the [DescribeGadInstances](~~330105~~) operation to query the information.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group. You can call the [DescribeDBInstanceAttribute](~~610394~~) to obtain the ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
}

func (s DetachGadInstanceMemberRequest) String() string {
	return tea.Prettify(s)
}

func (s DetachGadInstanceMemberRequest) GoString() string {
	return s.String()
}

func (s *DetachGadInstanceMemberRequest) SetGadInstanceName(v string) *DetachGadInstanceMemberRequest {
	s.GadInstanceName = &v
	return s
}

func (s *DetachGadInstanceMemberRequest) SetMemberInstanceName(v string) *DetachGadInstanceMemberRequest {
	s.MemberInstanceName = &v
	return s
}

func (s *DetachGadInstanceMemberRequest) SetRegionId(v string) *DetachGadInstanceMemberRequest {
	s.RegionId = &v
	return s
}

func (s *DetachGadInstanceMemberRequest) SetResourceGroupId(v string) *DetachGadInstanceMemberRequest {
	s.ResourceGroupId = &v
	return s
}

type DetachGadInstanceMemberResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DetachGadInstanceMemberResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DetachGadInstanceMemberResponseBody) GoString() string {
	return s.String()
}

func (s *DetachGadInstanceMemberResponseBody) SetRequestId(v string) *DetachGadInstanceMemberResponseBody {
	s.RequestId = &v
	return s
}

type DetachGadInstanceMemberResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DetachGadInstanceMemberResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DetachGadInstanceMemberResponse) String() string {
	return tea.Prettify(s)
}

func (s DetachGadInstanceMemberResponse) GoString() string {
	return s.String()
}

func (s *DetachGadInstanceMemberResponse) SetHeaders(v map[string]*string) *DetachGadInstanceMemberResponse {
	s.Headers = v
	return s
}

func (s *DetachGadInstanceMemberResponse) SetStatusCode(v int32) *DetachGadInstanceMemberResponse {
	s.StatusCode = &v
	return s
}

func (s *DetachGadInstanceMemberResponse) SetBody(v *DetachGadInstanceMemberResponseBody) *DetachGadInstanceMemberResponse {
	s.Body = v
	return s
}

type DetachWhitelistTemplateToInstanceRequest struct {
	// The instance name.
	InsName *string `json:"InsName,omitempty" xml:"InsName,omitempty"`
	// The resource group ID. For more information about resource groups, see Resource groups.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the whitelist template. You can call the DescribeAllWhitelistTemplate operation to obtain the ID of the whitelist template.
	TemplateId *int32 `json:"TemplateId,omitempty" xml:"TemplateId,omitempty"`
}

func (s DetachWhitelistTemplateToInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s DetachWhitelistTemplateToInstanceRequest) GoString() string {
	return s.String()
}

func (s *DetachWhitelistTemplateToInstanceRequest) SetInsName(v string) *DetachWhitelistTemplateToInstanceRequest {
	s.InsName = &v
	return s
}

func (s *DetachWhitelistTemplateToInstanceRequest) SetResourceGroupId(v string) *DetachWhitelistTemplateToInstanceRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DetachWhitelistTemplateToInstanceRequest) SetResourceOwnerAccount(v string) *DetachWhitelistTemplateToInstanceRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DetachWhitelistTemplateToInstanceRequest) SetResourceOwnerId(v int64) *DetachWhitelistTemplateToInstanceRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DetachWhitelistTemplateToInstanceRequest) SetTemplateId(v int32) *DetachWhitelistTemplateToInstanceRequest {
	s.TemplateId = &v
	return s
}

type DetachWhitelistTemplateToInstanceResponseBody struct {
	// The response code. Valid values:
	//
	// *   **200**: success
	// *   **400**: client error
	// *   **401**: identity authentication failed
	// *   **404**: request page not found
	// *   **500**: server error
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data returned.
	Data *DetachWhitelistTemplateToInstanceResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The HTTP status code returned. Valid values:
	//
	// *   **200**: success
	// *   **400**: client error
	// *   **500**: server error
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The response parameters.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful. Valid values:
	//
	// *   **true**
	// *   **false**
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DetachWhitelistTemplateToInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DetachWhitelistTemplateToInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *DetachWhitelistTemplateToInstanceResponseBody) SetCode(v string) *DetachWhitelistTemplateToInstanceResponseBody {
	s.Code = &v
	return s
}

func (s *DetachWhitelistTemplateToInstanceResponseBody) SetData(v *DetachWhitelistTemplateToInstanceResponseBodyData) *DetachWhitelistTemplateToInstanceResponseBody {
	s.Data = v
	return s
}

func (s *DetachWhitelistTemplateToInstanceResponseBody) SetHttpStatusCode(v int32) *DetachWhitelistTemplateToInstanceResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *DetachWhitelistTemplateToInstanceResponseBody) SetMessage(v string) *DetachWhitelistTemplateToInstanceResponseBody {
	s.Message = &v
	return s
}

func (s *DetachWhitelistTemplateToInstanceResponseBody) SetRequestId(v string) *DetachWhitelistTemplateToInstanceResponseBody {
	s.RequestId = &v
	return s
}

func (s *DetachWhitelistTemplateToInstanceResponseBody) SetSuccess(v bool) *DetachWhitelistTemplateToInstanceResponseBody {
	s.Success = &v
	return s
}

type DetachWhitelistTemplateToInstanceResponseBodyData struct {
	// The status code returned. Valid values:
	//
	// *   **ok**: The request is successful.
	// *   **error**: The request fails.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DetachWhitelistTemplateToInstanceResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s DetachWhitelistTemplateToInstanceResponseBodyData) GoString() string {
	return s.String()
}

func (s *DetachWhitelistTemplateToInstanceResponseBodyData) SetStatus(v string) *DetachWhitelistTemplateToInstanceResponseBodyData {
	s.Status = &v
	return s
}

type DetachWhitelistTemplateToInstanceResponse struct {
	Headers    map[string]*string                             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DetachWhitelistTemplateToInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DetachWhitelistTemplateToInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s DetachWhitelistTemplateToInstanceResponse) GoString() string {
	return s.String()
}

func (s *DetachWhitelistTemplateToInstanceResponse) SetHeaders(v map[string]*string) *DetachWhitelistTemplateToInstanceResponse {
	s.Headers = v
	return s
}

func (s *DetachWhitelistTemplateToInstanceResponse) SetStatusCode(v int32) *DetachWhitelistTemplateToInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *DetachWhitelistTemplateToInstanceResponse) SetBody(v *DetachWhitelistTemplateToInstanceResponseBody) *DetachWhitelistTemplateToInstanceResponse {
	s.Body = v
	return s
}

type EvaluateLocalExtendDiskRequest struct {
	// The instance name.
	DBInstanceName *string `json:"DBInstanceName,omitempty" xml:"DBInstanceName,omitempty"`
	OwnerId        *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID. You can call the [DescribeRegions](~~26243~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The resource group ID.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The new storage capacity. Unit: GB.
	Storage *int32 `json:"Storage,omitempty" xml:"Storage,omitempty"`
}

func (s EvaluateLocalExtendDiskRequest) String() string {
	return tea.Prettify(s)
}

func (s EvaluateLocalExtendDiskRequest) GoString() string {
	return s.String()
}

func (s *EvaluateLocalExtendDiskRequest) SetDBInstanceName(v string) *EvaluateLocalExtendDiskRequest {
	s.DBInstanceName = &v
	return s
}

func (s *EvaluateLocalExtendDiskRequest) SetOwnerId(v int64) *EvaluateLocalExtendDiskRequest {
	s.OwnerId = &v
	return s
}

func (s *EvaluateLocalExtendDiskRequest) SetRegionId(v string) *EvaluateLocalExtendDiskRequest {
	s.RegionId = &v
	return s
}

func (s *EvaluateLocalExtendDiskRequest) SetResourceGroupId(v string) *EvaluateLocalExtendDiskRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *EvaluateLocalExtendDiskRequest) SetResourceOwnerAccount(v string) *EvaluateLocalExtendDiskRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *EvaluateLocalExtendDiskRequest) SetResourceOwnerId(v int64) *EvaluateLocalExtendDiskRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *EvaluateLocalExtendDiskRequest) SetStorage(v int32) *EvaluateLocalExtendDiskRequest {
	s.Storage = &v
	return s
}

type EvaluateLocalExtendDiskResponseBody struct {
	// Indicates whether the instance is available. Valid values: true and false.
	Available *string `json:"Available,omitempty" xml:"Available,omitempty"`
	// The instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The data transfer type supported by the instance.
	DBInstanceTransType *string `json:"DBInstanceTransType,omitempty" xml:"DBInstanceTransType,omitempty"`
	// The maximum value of the local disk. Unit: GB.
	LocalUpgradeDiskLimit *int64 `json:"LocalUpgradeDiskLimit,omitempty" xml:"LocalUpgradeDiskLimit,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s EvaluateLocalExtendDiskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s EvaluateLocalExtendDiskResponseBody) GoString() string {
	return s.String()
}

func (s *EvaluateLocalExtendDiskResponseBody) SetAvailable(v string) *EvaluateLocalExtendDiskResponseBody {
	s.Available = &v
	return s
}

func (s *EvaluateLocalExtendDiskResponseBody) SetDBInstanceId(v string) *EvaluateLocalExtendDiskResponseBody {
	s.DBInstanceId = &v
	return s
}

func (s *EvaluateLocalExtendDiskResponseBody) SetDBInstanceTransType(v string) *EvaluateLocalExtendDiskResponseBody {
	s.DBInstanceTransType = &v
	return s
}

func (s *EvaluateLocalExtendDiskResponseBody) SetLocalUpgradeDiskLimit(v int64) *EvaluateLocalExtendDiskResponseBody {
	s.LocalUpgradeDiskLimit = &v
	return s
}

func (s *EvaluateLocalExtendDiskResponseBody) SetRequestId(v string) *EvaluateLocalExtendDiskResponseBody {
	s.RequestId = &v
	return s
}

type EvaluateLocalExtendDiskResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *EvaluateLocalExtendDiskResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s EvaluateLocalExtendDiskResponse) String() string {
	return tea.Prettify(s)
}

func (s EvaluateLocalExtendDiskResponse) GoString() string {
	return s.String()
}

func (s *EvaluateLocalExtendDiskResponse) SetHeaders(v map[string]*string) *EvaluateLocalExtendDiskResponse {
	s.Headers = v
	return s
}

func (s *EvaluateLocalExtendDiskResponse) SetStatusCode(v int32) *EvaluateLocalExtendDiskResponse {
	s.StatusCode = &v
	return s
}

func (s *EvaluateLocalExtendDiskResponse) SetBody(v *EvaluateLocalExtendDiskResponseBody) *EvaluateLocalExtendDiskResponse {
	s.Body = v
	return s
}

type GetDBInstanceTopologyRequest struct {
	// The instance ID. You can call the DescribeDBInstances operation to query the instance ID.
	DBInstanceId    *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerId         *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerId *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s GetDBInstanceTopologyRequest) String() string {
	return tea.Prettify(s)
}

func (s GetDBInstanceTopologyRequest) GoString() string {
	return s.String()
}

func (s *GetDBInstanceTopologyRequest) SetDBInstanceId(v string) *GetDBInstanceTopologyRequest {
	s.DBInstanceId = &v
	return s
}

func (s *GetDBInstanceTopologyRequest) SetOwnerId(v int64) *GetDBInstanceTopologyRequest {
	s.OwnerId = &v
	return s
}

func (s *GetDBInstanceTopologyRequest) SetResourceOwnerId(v int64) *GetDBInstanceTopologyRequest {
	s.ResourceOwnerId = &v
	return s
}

type GetDBInstanceTopologyResponseBody struct {
	// An internal parameter. You can ignore this parameter.
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The details about the topology.
	Data *GetDBInstanceTopologyResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// An internal parameter. You can ignore this parameter.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetDBInstanceTopologyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetDBInstanceTopologyResponseBody) GoString() string {
	return s.String()
}

func (s *GetDBInstanceTopologyResponseBody) SetCode(v string) *GetDBInstanceTopologyResponseBody {
	s.Code = &v
	return s
}

func (s *GetDBInstanceTopologyResponseBody) SetData(v *GetDBInstanceTopologyResponseBodyData) *GetDBInstanceTopologyResponseBody {
	s.Data = v
	return s
}

func (s *GetDBInstanceTopologyResponseBody) SetMessage(v string) *GetDBInstanceTopologyResponseBody {
	s.Message = &v
	return s
}

func (s *GetDBInstanceTopologyResponseBody) SetRequestId(v string) *GetDBInstanceTopologyResponseBody {
	s.RequestId = &v
	return s
}

type GetDBInstanceTopologyResponseBodyData struct {
	// The network connection information of the instance.
	Connections []*GetDBInstanceTopologyResponseBodyDataConnections `json:"Connections,omitempty" xml:"Connections,omitempty" type:"Repeated"`
	// The instance ID.
	DBInstanceName *string `json:"DBInstanceName,omitempty" xml:"DBInstanceName,omitempty"`
	// The queried nodes.
	Nodes []*GetDBInstanceTopologyResponseBodyDataNodes `json:"Nodes,omitempty" xml:"Nodes,omitempty" type:"Repeated"`
}

func (s GetDBInstanceTopologyResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetDBInstanceTopologyResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetDBInstanceTopologyResponseBodyData) SetConnections(v []*GetDBInstanceTopologyResponseBodyDataConnections) *GetDBInstanceTopologyResponseBodyData {
	s.Connections = v
	return s
}

func (s *GetDBInstanceTopologyResponseBodyData) SetDBInstanceName(v string) *GetDBInstanceTopologyResponseBodyData {
	s.DBInstanceName = &v
	return s
}

func (s *GetDBInstanceTopologyResponseBodyData) SetNodes(v []*GetDBInstanceTopologyResponseBodyDataNodes) *GetDBInstanceTopologyResponseBodyData {
	s.Nodes = v
	return s
}

type GetDBInstanceTopologyResponseBodyDataConnections struct {
	// The endpoint that is used to connect to the database instance.
	ConnectionString *string `json:"ConnectionString,omitempty" xml:"ConnectionString,omitempty"`
	// The instance ID.
	DBInstanceName *string `json:"DBInstanceName,omitempty" xml:"DBInstanceName,omitempty"`
	// The network type of the endpoint. Valid values:
	//
	// *   **vpc**
	// *   **public**
	NetType *string `json:"NetType,omitempty" xml:"NetType,omitempty"`
	// The zone ID of the instance.
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
}

func (s GetDBInstanceTopologyResponseBodyDataConnections) String() string {
	return tea.Prettify(s)
}

func (s GetDBInstanceTopologyResponseBodyDataConnections) GoString() string {
	return s.String()
}

func (s *GetDBInstanceTopologyResponseBodyDataConnections) SetConnectionString(v string) *GetDBInstanceTopologyResponseBodyDataConnections {
	s.ConnectionString = &v
	return s
}

func (s *GetDBInstanceTopologyResponseBodyDataConnections) SetDBInstanceName(v string) *GetDBInstanceTopologyResponseBodyDataConnections {
	s.DBInstanceName = &v
	return s
}

func (s *GetDBInstanceTopologyResponseBodyDataConnections) SetNetType(v string) *GetDBInstanceTopologyResponseBodyDataConnections {
	s.NetType = &v
	return s
}

func (s *GetDBInstanceTopologyResponseBodyDataConnections) SetZoneId(v string) *GetDBInstanceTopologyResponseBodyDataConnections {
	s.ZoneId = &v
	return s
}

type GetDBInstanceTopologyResponseBodyDataNodes struct {
	// The ID of the instance.
	DBInstanceName *string `json:"DBInstanceName,omitempty" xml:"DBInstanceName,omitempty"`
	// The ID of the dedicated cluster.
	//
	// > : If the instance does not reside in the specified dedicated cluster, no value is returned.
	DedicatedHostGroupId *string `json:"DedicatedHostGroupId,omitempty" xml:"DedicatedHostGroupId,omitempty"`
	// The host ID of the instance in the dedicated cluster.
	//
	// > : If the instance does not reside in the specified dedicated cluster, no value is returned.
	DedicatedHostId *string `json:"DedicatedHostId,omitempty" xml:"DedicatedHostId,omitempty"`
	// The ID of the instance.
	//
	// > : The value \*\*-1\*\* is returned for an instance that does not reside in a dedicated cluster.
	NodeId *string `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	// The type of the node. The following result is returned:
	//
	// *   **Master**: a primary node
	// *   **Slave**: a secondary node
	Role *string `json:"Role,omitempty" xml:"Role,omitempty"`
	// The zone ID of the instance.
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
}

func (s GetDBInstanceTopologyResponseBodyDataNodes) String() string {
	return tea.Prettify(s)
}

func (s GetDBInstanceTopologyResponseBodyDataNodes) GoString() string {
	return s.String()
}

func (s *GetDBInstanceTopologyResponseBodyDataNodes) SetDBInstanceName(v string) *GetDBInstanceTopologyResponseBodyDataNodes {
	s.DBInstanceName = &v
	return s
}

func (s *GetDBInstanceTopologyResponseBodyDataNodes) SetDedicatedHostGroupId(v string) *GetDBInstanceTopologyResponseBodyDataNodes {
	s.DedicatedHostGroupId = &v
	return s
}

func (s *GetDBInstanceTopologyResponseBodyDataNodes) SetDedicatedHostId(v string) *GetDBInstanceTopologyResponseBodyDataNodes {
	s.DedicatedHostId = &v
	return s
}

func (s *GetDBInstanceTopologyResponseBodyDataNodes) SetNodeId(v string) *GetDBInstanceTopologyResponseBodyDataNodes {
	s.NodeId = &v
	return s
}

func (s *GetDBInstanceTopologyResponseBodyDataNodes) SetRole(v string) *GetDBInstanceTopologyResponseBodyDataNodes {
	s.Role = &v
	return s
}

func (s *GetDBInstanceTopologyResponseBodyDataNodes) SetZoneId(v string) *GetDBInstanceTopologyResponseBodyDataNodes {
	s.ZoneId = &v
	return s
}

type GetDBInstanceTopologyResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetDBInstanceTopologyResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetDBInstanceTopologyResponse) String() string {
	return tea.Prettify(s)
}

func (s GetDBInstanceTopologyResponse) GoString() string {
	return s.String()
}

func (s *GetDBInstanceTopologyResponse) SetHeaders(v map[string]*string) *GetDBInstanceTopologyResponse {
	s.Headers = v
	return s
}

func (s *GetDBInstanceTopologyResponse) SetStatusCode(v int32) *GetDBInstanceTopologyResponse {
	s.StatusCode = &v
	return s
}

func (s *GetDBInstanceTopologyResponse) SetBody(v *GetDBInstanceTopologyResponseBody) *GetDBInstanceTopologyResponse {
	s.Body = v
	return s
}

type GetDbProxyInstanceSslRequest struct {
	// A reserved parameter. You do not need to specify this parameter.
	DBProxyEngineType *string `json:"DBProxyEngineType,omitempty" xml:"DBProxyEngineType,omitempty"`
	// The instance ID. You can call the [DescribeDBInstances](~~610396~~) operation to query the ID of the instance.
	DbInstanceId *string `json:"DbInstanceId,omitempty" xml:"DbInstanceId,omitempty"`
	// The region ID. You can call the [DescribeRegions](~~610399~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s GetDbProxyInstanceSslRequest) String() string {
	return tea.Prettify(s)
}

func (s GetDbProxyInstanceSslRequest) GoString() string {
	return s.String()
}

func (s *GetDbProxyInstanceSslRequest) SetDBProxyEngineType(v string) *GetDbProxyInstanceSslRequest {
	s.DBProxyEngineType = &v
	return s
}

func (s *GetDbProxyInstanceSslRequest) SetDbInstanceId(v string) *GetDbProxyInstanceSslRequest {
	s.DbInstanceId = &v
	return s
}

func (s *GetDbProxyInstanceSslRequest) SetRegionId(v string) *GetDbProxyInstanceSslRequest {
	s.RegionId = &v
	return s
}

type GetDbProxyInstanceSslResponseBody struct {
	// An array that consists of SSL encryption settings.
	DbProxyCertListItems *GetDbProxyInstanceSslResponseBodyDbProxyCertListItems `json:"DbProxyCertListItems,omitempty" xml:"DbProxyCertListItems,omitempty" type:"Struct"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetDbProxyInstanceSslResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetDbProxyInstanceSslResponseBody) GoString() string {
	return s.String()
}

func (s *GetDbProxyInstanceSslResponseBody) SetDbProxyCertListItems(v *GetDbProxyInstanceSslResponseBodyDbProxyCertListItems) *GetDbProxyInstanceSslResponseBody {
	s.DbProxyCertListItems = v
	return s
}

func (s *GetDbProxyInstanceSslResponseBody) SetRequestId(v string) *GetDbProxyInstanceSslResponseBody {
	s.RequestId = &v
	return s
}

type GetDbProxyInstanceSslResponseBodyDbProxyCertListItems struct {
	DbProxyCertListItems []*GetDbProxyInstanceSslResponseBodyDbProxyCertListItemsDbProxyCertListItems `json:"DbProxyCertListItems,omitempty" xml:"DbProxyCertListItems,omitempty" type:"Repeated"`
}

func (s GetDbProxyInstanceSslResponseBodyDbProxyCertListItems) String() string {
	return tea.Prettify(s)
}

func (s GetDbProxyInstanceSslResponseBodyDbProxyCertListItems) GoString() string {
	return s.String()
}

func (s *GetDbProxyInstanceSslResponseBodyDbProxyCertListItems) SetDbProxyCertListItems(v []*GetDbProxyInstanceSslResponseBodyDbProxyCertListItemsDbProxyCertListItems) *GetDbProxyInstanceSslResponseBodyDbProxyCertListItems {
	s.DbProxyCertListItems = v
	return s
}

type GetDbProxyInstanceSslResponseBodyDbProxyCertListItemsDbProxyCertListItems struct {
	// The dedicated proxy endpoint for which SSL encryption is enabled.
	CertCommonName *string `json:"CertCommonName,omitempty" xml:"CertCommonName,omitempty"`
	// The instance ID.
	DbInstanceName *string `json:"DbInstanceName,omitempty" xml:"DbInstanceName,omitempty"`
	// The ID of the dedicated proxy endpoint.
	EndpointName *string `json:"EndpointName,omitempty" xml:"EndpointName,omitempty"`
	// The default identifier of the dedicated proxy endpoint. The value is fixed as **RWSplit**.
	EndpointType *string `json:"EndpointType,omitempty" xml:"EndpointType,omitempty"`
	// The time at which the certificate expires.
	SslExpiredTime *string `json:"SslExpiredTime,omitempty" xml:"SslExpiredTime,omitempty"`
}

func (s GetDbProxyInstanceSslResponseBodyDbProxyCertListItemsDbProxyCertListItems) String() string {
	return tea.Prettify(s)
}

func (s GetDbProxyInstanceSslResponseBodyDbProxyCertListItemsDbProxyCertListItems) GoString() string {
	return s.String()
}

func (s *GetDbProxyInstanceSslResponseBodyDbProxyCertListItemsDbProxyCertListItems) SetCertCommonName(v string) *GetDbProxyInstanceSslResponseBodyDbProxyCertListItemsDbProxyCertListItems {
	s.CertCommonName = &v
	return s
}

func (s *GetDbProxyInstanceSslResponseBodyDbProxyCertListItemsDbProxyCertListItems) SetDbInstanceName(v string) *GetDbProxyInstanceSslResponseBodyDbProxyCertListItemsDbProxyCertListItems {
	s.DbInstanceName = &v
	return s
}

func (s *GetDbProxyInstanceSslResponseBodyDbProxyCertListItemsDbProxyCertListItems) SetEndpointName(v string) *GetDbProxyInstanceSslResponseBodyDbProxyCertListItemsDbProxyCertListItems {
	s.EndpointName = &v
	return s
}

func (s *GetDbProxyInstanceSslResponseBodyDbProxyCertListItemsDbProxyCertListItems) SetEndpointType(v string) *GetDbProxyInstanceSslResponseBodyDbProxyCertListItemsDbProxyCertListItems {
	s.EndpointType = &v
	return s
}

func (s *GetDbProxyInstanceSslResponseBodyDbProxyCertListItemsDbProxyCertListItems) SetSslExpiredTime(v string) *GetDbProxyInstanceSslResponseBodyDbProxyCertListItemsDbProxyCertListItems {
	s.SslExpiredTime = &v
	return s
}

type GetDbProxyInstanceSslResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetDbProxyInstanceSslResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetDbProxyInstanceSslResponse) String() string {
	return tea.Prettify(s)
}

func (s GetDbProxyInstanceSslResponse) GoString() string {
	return s.String()
}

func (s *GetDbProxyInstanceSslResponse) SetHeaders(v map[string]*string) *GetDbProxyInstanceSslResponse {
	s.Headers = v
	return s
}

func (s *GetDbProxyInstanceSslResponse) SetStatusCode(v int32) *GetDbProxyInstanceSslResponse {
	s.StatusCode = &v
	return s
}

func (s *GetDbProxyInstanceSslResponse) SetBody(v *GetDbProxyInstanceSslResponseBody) *GetDbProxyInstanceSslResponse {
	s.Body = v
	return s
}

type GrantAccountPrivilegeRequest struct {
	// The username of the account.
	AccountName *string `json:"AccountName,omitempty" xml:"AccountName,omitempty"`
	// The permissions that you want to grant to the account. The number of permissions must be the same as the number of databases that you specify for the DBName parameter. You can specify this parameter based on your business requirements. Valid values:
	//
	// *   **ReadWrite**: read and write permissions
	// *   **ReadOnly**: read-only permissions
	// *   **DDLOnly**: DDL-only permissions
	// *   **DMLOnly**: DML-only permissions
	// *   **DBOwner**: database owner permissions
	//
	// >
	//
	// *   If the instance runs MySQL or MariaDB, you can set this parameter to **ReadWrite**, **ReadOnly**, **DDLOnly**, or **DMLOnly**.
	//
	// *   If the instance runs SQL Server, you can set this parameter to **ReadWrite**, **ReadOnly**, or **DBOwner**.
	// *   If the instance runs PostgreSQL and uses cloud disks, you can set this parameter to **DBOwner**.
	AccountPrivilege *string `json:"AccountPrivilege,omitempty" xml:"AccountPrivilege,omitempty"`
	// The ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The name of the database on which you want to grant permissions. Separate multiple database names with commas (,).
	DBName          *string `json:"DBName,omitempty" xml:"DBName,omitempty"`
	ResourceOwnerId *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s GrantAccountPrivilegeRequest) String() string {
	return tea.Prettify(s)
}

func (s GrantAccountPrivilegeRequest) GoString() string {
	return s.String()
}

func (s *GrantAccountPrivilegeRequest) SetAccountName(v string) *GrantAccountPrivilegeRequest {
	s.AccountName = &v
	return s
}

func (s *GrantAccountPrivilegeRequest) SetAccountPrivilege(v string) *GrantAccountPrivilegeRequest {
	s.AccountPrivilege = &v
	return s
}

func (s *GrantAccountPrivilegeRequest) SetDBInstanceId(v string) *GrantAccountPrivilegeRequest {
	s.DBInstanceId = &v
	return s
}

func (s *GrantAccountPrivilegeRequest) SetDBName(v string) *GrantAccountPrivilegeRequest {
	s.DBName = &v
	return s
}

func (s *GrantAccountPrivilegeRequest) SetResourceOwnerId(v int64) *GrantAccountPrivilegeRequest {
	s.ResourceOwnerId = &v
	return s
}

type GrantAccountPrivilegeResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GrantAccountPrivilegeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GrantAccountPrivilegeResponseBody) GoString() string {
	return s.String()
}

func (s *GrantAccountPrivilegeResponseBody) SetRequestId(v string) *GrantAccountPrivilegeResponseBody {
	s.RequestId = &v
	return s
}

type GrantAccountPrivilegeResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GrantAccountPrivilegeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GrantAccountPrivilegeResponse) String() string {
	return tea.Prettify(s)
}

func (s GrantAccountPrivilegeResponse) GoString() string {
	return s.String()
}

func (s *GrantAccountPrivilegeResponse) SetHeaders(v map[string]*string) *GrantAccountPrivilegeResponse {
	s.Headers = v
	return s
}

func (s *GrantAccountPrivilegeResponse) SetStatusCode(v int32) *GrantAccountPrivilegeResponse {
	s.StatusCode = &v
	return s
}

func (s *GrantAccountPrivilegeResponse) SetBody(v *GrantAccountPrivilegeResponseBody) *GrantAccountPrivilegeResponse {
	s.Body = v
	return s
}

type GrantOperatorPermissionRequest struct {
	// The instance ID. You can call the DescribeDBInstances operation to query the instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The expiration time of the permissions. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
	ExpiredTime  *string `json:"ExpiredTime,omitempty" xml:"ExpiredTime,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The permissions that you want to grant to the service account. Valid values:
	//
	// *   **Control**: the configuration permissions, which allow you to view and modify configurations of the instance.
	// *   **Data**: the data permissions, which allow you to view schemas, indexes, and SQL statements of the instance.
	Privileges           *string `json:"Privileges,omitempty" xml:"Privileges,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s GrantOperatorPermissionRequest) String() string {
	return tea.Prettify(s)
}

func (s GrantOperatorPermissionRequest) GoString() string {
	return s.String()
}

func (s *GrantOperatorPermissionRequest) SetDBInstanceId(v string) *GrantOperatorPermissionRequest {
	s.DBInstanceId = &v
	return s
}

func (s *GrantOperatorPermissionRequest) SetExpiredTime(v string) *GrantOperatorPermissionRequest {
	s.ExpiredTime = &v
	return s
}

func (s *GrantOperatorPermissionRequest) SetOwnerAccount(v string) *GrantOperatorPermissionRequest {
	s.OwnerAccount = &v
	return s
}

func (s *GrantOperatorPermissionRequest) SetOwnerId(v int64) *GrantOperatorPermissionRequest {
	s.OwnerId = &v
	return s
}

func (s *GrantOperatorPermissionRequest) SetPrivileges(v string) *GrantOperatorPermissionRequest {
	s.Privileges = &v
	return s
}

func (s *GrantOperatorPermissionRequest) SetResourceOwnerAccount(v string) *GrantOperatorPermissionRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *GrantOperatorPermissionRequest) SetResourceOwnerId(v int64) *GrantOperatorPermissionRequest {
	s.ResourceOwnerId = &v
	return s
}

type GrantOperatorPermissionResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GrantOperatorPermissionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GrantOperatorPermissionResponseBody) GoString() string {
	return s.String()
}

func (s *GrantOperatorPermissionResponseBody) SetRequestId(v string) *GrantOperatorPermissionResponseBody {
	s.RequestId = &v
	return s
}

type GrantOperatorPermissionResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GrantOperatorPermissionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GrantOperatorPermissionResponse) String() string {
	return tea.Prettify(s)
}

func (s GrantOperatorPermissionResponse) GoString() string {
	return s.String()
}

func (s *GrantOperatorPermissionResponse) SetHeaders(v map[string]*string) *GrantOperatorPermissionResponse {
	s.Headers = v
	return s
}

func (s *GrantOperatorPermissionResponse) SetStatusCode(v int32) *GrantOperatorPermissionResponse {
	s.StatusCode = &v
	return s
}

func (s *GrantOperatorPermissionResponse) SetBody(v *GrantOperatorPermissionResponseBody) *GrantOperatorPermissionResponse {
	s.Body = v
	return s
}

type ImportDatabaseBetweenInstancesRequest struct {
	// The names of the source and destination databases. The value of this parameter is a JSON string.
	//
	// > If the source and destination instances run SQL Server, the value of this parameter consists of one or more key-value pairs. In each key-value pair, the key specifies the name of the source database, and the value specifies the name of the destination database. A source database can have a different name from the destination database. For example, `{"DBNames":{"srcdb":"destdb","srcdb2":"destmydb2"}}` indicates that srcdb is migrated to destdb and srcdb2 is migrated to destmydb2. The names of source databases cannot be the same, and the names of destination databases cannot be the same.
	DBInfo *string `json:"DBInfo,omitempty" xml:"DBInfo,omitempty"`
	// The ID of the instance.
	DBInstanceId         *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the source instance, which cannot be the same as the ID of the destination instance.
	SourceDBInstanceId *string `json:"SourceDBInstanceId,omitempty" xml:"SourceDBInstanceId,omitempty"`
}

func (s ImportDatabaseBetweenInstancesRequest) String() string {
	return tea.Prettify(s)
}

func (s ImportDatabaseBetweenInstancesRequest) GoString() string {
	return s.String()
}

func (s *ImportDatabaseBetweenInstancesRequest) SetDBInfo(v string) *ImportDatabaseBetweenInstancesRequest {
	s.DBInfo = &v
	return s
}

func (s *ImportDatabaseBetweenInstancesRequest) SetDBInstanceId(v string) *ImportDatabaseBetweenInstancesRequest {
	s.DBInstanceId = &v
	return s
}

func (s *ImportDatabaseBetweenInstancesRequest) SetOwnerAccount(v string) *ImportDatabaseBetweenInstancesRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ImportDatabaseBetweenInstancesRequest) SetOwnerId(v int64) *ImportDatabaseBetweenInstancesRequest {
	s.OwnerId = &v
	return s
}

func (s *ImportDatabaseBetweenInstancesRequest) SetResourceOwnerAccount(v string) *ImportDatabaseBetweenInstancesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ImportDatabaseBetweenInstancesRequest) SetResourceOwnerId(v int64) *ImportDatabaseBetweenInstancesRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ImportDatabaseBetweenInstancesRequest) SetSourceDBInstanceId(v string) *ImportDatabaseBetweenInstancesRequest {
	s.SourceDBInstanceId = &v
	return s
}

type ImportDatabaseBetweenInstancesResponseBody struct {
	// The ID of the import task.
	ImportId *string `json:"ImportId,omitempty" xml:"ImportId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ImportDatabaseBetweenInstancesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ImportDatabaseBetweenInstancesResponseBody) GoString() string {
	return s.String()
}

func (s *ImportDatabaseBetweenInstancesResponseBody) SetImportId(v string) *ImportDatabaseBetweenInstancesResponseBody {
	s.ImportId = &v
	return s
}

func (s *ImportDatabaseBetweenInstancesResponseBody) SetRequestId(v string) *ImportDatabaseBetweenInstancesResponseBody {
	s.RequestId = &v
	return s
}

type ImportDatabaseBetweenInstancesResponse struct {
	Headers    map[string]*string                          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ImportDatabaseBetweenInstancesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ImportDatabaseBetweenInstancesResponse) String() string {
	return tea.Prettify(s)
}

func (s ImportDatabaseBetweenInstancesResponse) GoString() string {
	return s.String()
}

func (s *ImportDatabaseBetweenInstancesResponse) SetHeaders(v map[string]*string) *ImportDatabaseBetweenInstancesResponse {
	s.Headers = v
	return s
}

func (s *ImportDatabaseBetweenInstancesResponse) SetStatusCode(v int32) *ImportDatabaseBetweenInstancesResponse {
	s.StatusCode = &v
	return s
}

func (s *ImportDatabaseBetweenInstancesResponse) SetBody(v *ImportDatabaseBetweenInstancesResponseBody) *ImportDatabaseBetweenInstancesResponse {
	s.Body = v
	return s
}

type ImportUserBackupFileRequest struct {
	// A JSON array that consists of the information about the full backup file stored as an object in an OSS bucket. Example: `{"Bucket":"test", "Object":"test/test_db_employees.xb","Location":"ap-southeast-1"}`
	//
	// The JSON array contains the following fields:
	//
	// *   **Bucket**: The name of the OSS bucket in which the full backup file is stored as an object. You can call the [GetBucket](~~31965~~) operation to query the name of the bucket.
	// *   **Object**: The path of the full backup file that is stored as an object in the OSS bucket. You can call the [GetObject](~~31980~~) operation to query the path of the object.
	// *   **Location**: The ID of the region in which the OSS bucket is located. You can call the [GetBucketLocation](~~31967~~) operation to query the region of the bucket.
	BackupFile *string `json:"BackupFile,omitempty" xml:"BackupFile,omitempty"`
	// The region ID of the OSS bucket where the full backup file of the self-managed MySQL database is located. You can call the [DescribeRegions](~~26243~~) operation to query the most recent region list.
	BucketRegion *string `json:"BucketRegion,omitempty" xml:"BucketRegion,omitempty"`
	// The description of the full backup file.
	Comment *string `json:"Comment,omitempty" xml:"Comment,omitempty"`
	// The version of the database engine that is run on the self-managed MySQL database and ApsaraDB RDS for MySQL instance. Set the value to **5.7**.
	EngineVersion *string `json:"EngineVersion,omitempty" xml:"EngineVersion,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the instance. You can call the [DescribeRegions](~~26243~~) operation to query the most recent region list.
	//
	// >
	//
	// *   The value of this parameter is the ID of the region in which you want to create the instance.
	//
	// *   The value of this parameter must be consistent with the value of **BucketRegion**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group. You can call the [DescribeDBInstanceAttribute](~~610394~~) operation to obtain the ID of the resource group.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The amount of storage that is required to restore the data of the full backup file. Unit: GB.
	//
	// >
	//
	// *   The default value of this parameter is 5 times the size of the full backup file.
	//
	// *   The minimum value of this parameter is 20.
	RestoreSize *int32 `json:"RestoreSize,omitempty" xml:"RestoreSize,omitempty"`
	// The retention period of the full backup file. Unit: days. Valid values: any **non-zero** positive integer.
	Retention *int32 `json:"Retention,omitempty" xml:"Retention,omitempty"`
	// The ID of the zone. You can call the [DescribeRegions](~~26243~~) operation to query the ID of the zone.
	//
	// >
	//
	// *   If you specify this parameter, the system creates a snapshot in single-digit seconds, which greatly reduces the time that is required to import the full backup file.
	//
	// *   When you call the [CreateDBInstance](~~26228~~) operation to create an instance by using the full backup file, the instance is created in the zone that you specify for this parameter.
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
}

func (s ImportUserBackupFileRequest) String() string {
	return tea.Prettify(s)
}

func (s ImportUserBackupFileRequest) GoString() string {
	return s.String()
}

func (s *ImportUserBackupFileRequest) SetBackupFile(v string) *ImportUserBackupFileRequest {
	s.BackupFile = &v
	return s
}

func (s *ImportUserBackupFileRequest) SetBucketRegion(v string) *ImportUserBackupFileRequest {
	s.BucketRegion = &v
	return s
}

func (s *ImportUserBackupFileRequest) SetComment(v string) *ImportUserBackupFileRequest {
	s.Comment = &v
	return s
}

func (s *ImportUserBackupFileRequest) SetEngineVersion(v string) *ImportUserBackupFileRequest {
	s.EngineVersion = &v
	return s
}

func (s *ImportUserBackupFileRequest) SetOwnerId(v int64) *ImportUserBackupFileRequest {
	s.OwnerId = &v
	return s
}

func (s *ImportUserBackupFileRequest) SetRegionId(v string) *ImportUserBackupFileRequest {
	s.RegionId = &v
	return s
}

func (s *ImportUserBackupFileRequest) SetResourceGroupId(v string) *ImportUserBackupFileRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *ImportUserBackupFileRequest) SetResourceOwnerAccount(v string) *ImportUserBackupFileRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ImportUserBackupFileRequest) SetResourceOwnerId(v int64) *ImportUserBackupFileRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ImportUserBackupFileRequest) SetRestoreSize(v int32) *ImportUserBackupFileRequest {
	s.RestoreSize = &v
	return s
}

func (s *ImportUserBackupFileRequest) SetRetention(v int32) *ImportUserBackupFileRequest {
	s.Retention = &v
	return s
}

func (s *ImportUserBackupFileRequest) SetZoneId(v string) *ImportUserBackupFileRequest {
	s.ZoneId = &v
	return s
}

type ImportUserBackupFileResponseBody struct {
	// The ID of the full backup file.
	BackupId *string `json:"BackupId,omitempty" xml:"BackupId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the full backup file is successfully imported into the instance. If the full backup file is successfully imported, **true** is returned. Otherwise, an error message is returned.
	Status *bool `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s ImportUserBackupFileResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ImportUserBackupFileResponseBody) GoString() string {
	return s.String()
}

func (s *ImportUserBackupFileResponseBody) SetBackupId(v string) *ImportUserBackupFileResponseBody {
	s.BackupId = &v
	return s
}

func (s *ImportUserBackupFileResponseBody) SetRequestId(v string) *ImportUserBackupFileResponseBody {
	s.RequestId = &v
	return s
}

func (s *ImportUserBackupFileResponseBody) SetStatus(v bool) *ImportUserBackupFileResponseBody {
	s.Status = &v
	return s
}

type ImportUserBackupFileResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ImportUserBackupFileResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ImportUserBackupFileResponse) String() string {
	return tea.Prettify(s)
}

func (s ImportUserBackupFileResponse) GoString() string {
	return s.String()
}

func (s *ImportUserBackupFileResponse) SetHeaders(v map[string]*string) *ImportUserBackupFileResponse {
	s.Headers = v
	return s
}

func (s *ImportUserBackupFileResponse) SetStatusCode(v int32) *ImportUserBackupFileResponse {
	s.StatusCode = &v
	return s
}

func (s *ImportUserBackupFileResponse) SetBody(v *ImportUserBackupFileResponseBody) *ImportUserBackupFileResponse {
	s.Body = v
	return s
}

type ListClassesRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The commodity code of the instances.
	//
	// *   **bards_intl**: The instances are pay-as-you-go primary instances.
	// *   **rds_intl**: The instances are subscription primary instances.
	// *   **rords_intl**: The instances are pay-as-you-go read-only instances.
	// *   **rds_rordspre_public_intl**: The instances are subscription read-only instances.
	CommodityCode *string `json:"CommodityCode,omitempty" xml:"CommodityCode,omitempty"`
	// The instance ID. You can call the [DescribeDBInstances](~~610396~~) operation to query the ID of the instance.
	//
	// > If you use **CommodityCode** to query the instance types that are available to read-only instances, you must specify DBInstanceId.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The type of order that you want to query. Valid values:
	//
	// *   **BUY**: specifies the query orders that are used to purchase instances.
	// *   **UPGRADE**: specifies the query orders that are used to change the specifications of instances.
	// *   **RENEW**: specifies the query orders that are used to renew instances.
	// *   **CONVERT**: specifies the query orders that are used to change the billing methods of instances.
	OrderType *string `json:"OrderType,omitempty" xml:"OrderType,omitempty"`
	OwnerId   *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID. You can call the [DescribeRegions](~~610399~~) operation to query the most recent region list.
	//
	// > If you are using an Alibaba Cloud account on the International site (alibabacloud.com), you must specify RegionId.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ListClassesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListClassesRequest) GoString() string {
	return s.String()
}

func (s *ListClassesRequest) SetClientToken(v string) *ListClassesRequest {
	s.ClientToken = &v
	return s
}

func (s *ListClassesRequest) SetCommodityCode(v string) *ListClassesRequest {
	s.CommodityCode = &v
	return s
}

func (s *ListClassesRequest) SetDBInstanceId(v string) *ListClassesRequest {
	s.DBInstanceId = &v
	return s
}

func (s *ListClassesRequest) SetOrderType(v string) *ListClassesRequest {
	s.OrderType = &v
	return s
}

func (s *ListClassesRequest) SetOwnerId(v int64) *ListClassesRequest {
	s.OwnerId = &v
	return s
}

func (s *ListClassesRequest) SetRegionId(v string) *ListClassesRequest {
	s.RegionId = &v
	return s
}

func (s *ListClassesRequest) SetResourceOwnerAccount(v string) *ListClassesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ListClassesRequest) SetResourceOwnerId(v int64) *ListClassesRequest {
	s.ResourceOwnerId = &v
	return s
}

type ListClassesResponseBody struct {
	// The list of instance specifications.
	Items []*ListClassesResponseBodyItems `json:"Items,omitempty" xml:"Items,omitempty" type:"Repeated"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListClassesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListClassesResponseBody) GoString() string {
	return s.String()
}

func (s *ListClassesResponseBody) SetItems(v []*ListClassesResponseBodyItems) *ListClassesResponseBody {
	s.Items = v
	return s
}

func (s *ListClassesResponseBody) SetRegionId(v string) *ListClassesResponseBody {
	s.RegionId = &v
	return s
}

func (s *ListClassesResponseBody) SetRequestId(v string) *ListClassesResponseBody {
	s.RequestId = &v
	return s
}

type ListClassesResponseBodyItems struct {
	// The code of the instance type. For more information, see [Primary ApsaraDB RDS instance types](~~26312~~) and [Read-only ApsaraDB RDS instance types](~~145759~~).
	ClassCode *string `json:"ClassCode,omitempty" xml:"ClassCode,omitempty"`
	// The instance family. For more information, see [Overview of instance families](~~57184~~).
	ClassGroup *string `json:"ClassGroup,omitempty" xml:"ClassGroup,omitempty"`
	// The number of CPU cores that are supported by the instance type. Unit: cores.
	Cpu *string `json:"Cpu,omitempty" xml:"Cpu,omitempty"`
	// The size of the encrypted memory that is supported by the security-enhanced instance type. Unit: GB.
	EncryptedMemory *string `json:"EncryptedMemory,omitempty" xml:"EncryptedMemory,omitempty"`
	// The architecture of the instance type. Valid values:
	//
	// *   If the architecture of the instance type is **x86**, an empty string is returned by default.
	// *   If the architecture of the instance type is **ARM**, **arm** is returned.
	InstructionSetArch *string `json:"InstructionSetArch,omitempty" xml:"InstructionSetArch,omitempty"`
	// The maximum number of connections that are supported by the instance type. Unit: connections.
	MaxConnections *string `json:"MaxConnections,omitempty" xml:"MaxConnections,omitempty"`
	// The maximum I/O bandwidth that is supported by the instance type. Unit: Mbit/s.
	MaxIOMBPS *string `json:"MaxIOMBPS,omitempty" xml:"MaxIOMBPS,omitempty"`
	// The maximum input/output operations per second (IOPS) that is supported by the instance type. Unit: operations per second.
	MaxIOPS *string `json:"MaxIOPS,omitempty" xml:"MaxIOPS,omitempty"`
	// The memory size that is supported by the instance type. Unit: GB.
	MemoryClass *string `json:"MemoryClass,omitempty" xml:"MemoryClass,omitempty"`
	// The fee that you must pay for the instance type.
	//
	// *   Unit: cents (USD).
	//
	// >
	//
	// *   If you set **CommodityCode** to a value that indicates the pay-as-you-go billing method, the ReferencePrice parameter specifies the hourly fee that you must pay.
	//
	// *   If you set **CommodityCode** to a value that indicates the subscription billing method, the ReferencePrice parameter specifies the monthly fee that you must pay.
	ReferencePrice *string `json:"ReferencePrice,omitempty" xml:"ReferencePrice,omitempty"`
}

func (s ListClassesResponseBodyItems) String() string {
	return tea.Prettify(s)
}

func (s ListClassesResponseBodyItems) GoString() string {
	return s.String()
}

func (s *ListClassesResponseBodyItems) SetClassCode(v string) *ListClassesResponseBodyItems {
	s.ClassCode = &v
	return s
}

func (s *ListClassesResponseBodyItems) SetClassGroup(v string) *ListClassesResponseBodyItems {
	s.ClassGroup = &v
	return s
}

func (s *ListClassesResponseBodyItems) SetCpu(v string) *ListClassesResponseBodyItems {
	s.Cpu = &v
	return s
}

func (s *ListClassesResponseBodyItems) SetEncryptedMemory(v string) *ListClassesResponseBodyItems {
	s.EncryptedMemory = &v
	return s
}

func (s *ListClassesResponseBodyItems) SetInstructionSetArch(v string) *ListClassesResponseBodyItems {
	s.InstructionSetArch = &v
	return s
}

func (s *ListClassesResponseBodyItems) SetMaxConnections(v string) *ListClassesResponseBodyItems {
	s.MaxConnections = &v
	return s
}

func (s *ListClassesResponseBodyItems) SetMaxIOMBPS(v string) *ListClassesResponseBodyItems {
	s.MaxIOMBPS = &v
	return s
}

func (s *ListClassesResponseBodyItems) SetMaxIOPS(v string) *ListClassesResponseBodyItems {
	s.MaxIOPS = &v
	return s
}

func (s *ListClassesResponseBodyItems) SetMemoryClass(v string) *ListClassesResponseBodyItems {
	s.MemoryClass = &v
	return s
}

func (s *ListClassesResponseBodyItems) SetReferencePrice(v string) *ListClassesResponseBodyItems {
	s.ReferencePrice = &v
	return s
}

type ListClassesResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListClassesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListClassesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListClassesResponse) GoString() string {
	return s.String()
}

func (s *ListClassesResponse) SetHeaders(v map[string]*string) *ListClassesResponse {
	s.Headers = v
	return s
}

func (s *ListClassesResponse) SetStatusCode(v int32) *ListClassesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListClassesResponse) SetBody(v *ListClassesResponseBody) *ListClassesResponse {
	s.Body = v
	return s
}

type ListTagResourcesRequest struct {
	// The token required to obtain more results. This parameter is not required in the first query. If a query does not return all results, you can specify the token returned from the previous query for the next query to obtain more results.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	OwnerId   *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID. You can call the [DescribeRegions](~~26243~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The instance ID. You can specify a maximum of **50** instance IDs.****
	//
	// >  You must specify at least one of the **ResourceId** and **Key** parameters.
	ResourceId           []*string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty" type:"Repeated"`
	ResourceOwnerAccount *string   `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64    `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The type of the resource. Set the value to **INSTANCE**.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The tag list.
	Tag []*ListTagResourcesRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s ListTagResourcesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesRequest) GoString() string {
	return s.String()
}

func (s *ListTagResourcesRequest) SetNextToken(v string) *ListTagResourcesRequest {
	s.NextToken = &v
	return s
}

func (s *ListTagResourcesRequest) SetOwnerId(v int64) *ListTagResourcesRequest {
	s.OwnerId = &v
	return s
}

func (s *ListTagResourcesRequest) SetRegionId(v string) *ListTagResourcesRequest {
	s.RegionId = &v
	return s
}

func (s *ListTagResourcesRequest) SetResourceId(v []*string) *ListTagResourcesRequest {
	s.ResourceId = v
	return s
}

func (s *ListTagResourcesRequest) SetResourceOwnerAccount(v string) *ListTagResourcesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ListTagResourcesRequest) SetResourceOwnerId(v int64) *ListTagResourcesRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ListTagResourcesRequest) SetResourceType(v string) *ListTagResourcesRequest {
	s.ResourceType = &v
	return s
}

func (s *ListTagResourcesRequest) SetTag(v []*ListTagResourcesRequestTag) *ListTagResourcesRequest {
	s.Tag = v
	return s
}

type ListTagResourcesRequestTag struct {
	// The tag key. You can query N tag keys at a time. Valid values of N: **1** to **20**. The value cannot be an empty string.
	//
	// >  You must specify at least one of the **ResourceId** and **Key** parameters.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value that is associated with the specified tag key. You can specify N tag values at a time. Valid values of N: **1** to **20**. The value can be an empty string.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListTagResourcesRequestTag) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesRequestTag) GoString() string {
	return s.String()
}

func (s *ListTagResourcesRequestTag) SetKey(v string) *ListTagResourcesRequestTag {
	s.Key = &v
	return s
}

func (s *ListTagResourcesRequestTag) SetValue(v string) *ListTagResourcesRequestTag {
	s.Value = &v
	return s
}

type ListTagResourcesResponseBody struct {
	// You must specify the token that is obtained from the previous query as the value of NextToken.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The list of queried instances and tags.
	TagResources *ListTagResourcesResponseBodyTagResources `json:"TagResources,omitempty" xml:"TagResources,omitempty" type:"Struct"`
}

func (s ListTagResourcesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesResponseBody) GoString() string {
	return s.String()
}

func (s *ListTagResourcesResponseBody) SetNextToken(v string) *ListTagResourcesResponseBody {
	s.NextToken = &v
	return s
}

func (s *ListTagResourcesResponseBody) SetRequestId(v string) *ListTagResourcesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListTagResourcesResponseBody) SetTagResources(v *ListTagResourcesResponseBodyTagResources) *ListTagResourcesResponseBody {
	s.TagResources = v
	return s
}

type ListTagResourcesResponseBodyTagResources struct {
	TagResource []*ListTagResourcesResponseBodyTagResourcesTagResource `json:"TagResource,omitempty" xml:"TagResource,omitempty" type:"Repeated"`
}

func (s ListTagResourcesResponseBodyTagResources) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesResponseBodyTagResources) GoString() string {
	return s.String()
}

func (s *ListTagResourcesResponseBodyTagResources) SetTagResource(v []*ListTagResourcesResponseBodyTagResourcesTagResource) *ListTagResourcesResponseBodyTagResources {
	s.TagResource = v
	return s
}

type ListTagResourcesResponseBodyTagResourcesTagResource struct {
	// The instance ID.
	ResourceId *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	// The resource type. The value `ALIYUN::RDS::INSTANCE` indicates ApsaraDB RDS instances.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The tag key.
	TagKey *string `json:"TagKey,omitempty" xml:"TagKey,omitempty"`
	// The tag value that is associated with the specified tag key.
	TagValue *string `json:"TagValue,omitempty" xml:"TagValue,omitempty"`
}

func (s ListTagResourcesResponseBodyTagResourcesTagResource) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesResponseBodyTagResourcesTagResource) GoString() string {
	return s.String()
}

func (s *ListTagResourcesResponseBodyTagResourcesTagResource) SetResourceId(v string) *ListTagResourcesResponseBodyTagResourcesTagResource {
	s.ResourceId = &v
	return s
}

func (s *ListTagResourcesResponseBodyTagResourcesTagResource) SetResourceType(v string) *ListTagResourcesResponseBodyTagResourcesTagResource {
	s.ResourceType = &v
	return s
}

func (s *ListTagResourcesResponseBodyTagResourcesTagResource) SetTagKey(v string) *ListTagResourcesResponseBodyTagResourcesTagResource {
	s.TagKey = &v
	return s
}

func (s *ListTagResourcesResponseBodyTagResourcesTagResource) SetTagValue(v string) *ListTagResourcesResponseBodyTagResourcesTagResource {
	s.TagValue = &v
	return s
}

type ListTagResourcesResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListTagResourcesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListTagResourcesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesResponse) GoString() string {
	return s.String()
}

func (s *ListTagResourcesResponse) SetHeaders(v map[string]*string) *ListTagResourcesResponse {
	s.Headers = v
	return s
}

func (s *ListTagResourcesResponse) SetStatusCode(v int32) *ListTagResourcesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListTagResourcesResponse) SetBody(v *ListTagResourcesResponseBody) *ListTagResourcesResponse {
	s.Body = v
	return s
}

type ListUserBackupFilesRequest struct {
	// The ID of the full backup file.
	BackupId *string `json:"BackupId,omitempty" xml:"BackupId,omitempty"`
	// The description of the full backup file.
	//
	// > The system implements a fuzzy match based on the value of this parameter.
	Comment *string `json:"Comment,omitempty" xml:"Comment,omitempty"`
	// The URL from which you can download the full backup file that is stored as an object in an Object Storage Service (OSS) bucket. For more information about how to obtain the URL, see [Obtain the access URL after you upload objects](~~39607~~).
	OssUrl  *string `json:"OssUrl,omitempty" xml:"OssUrl,omitempty"`
	OwnerId *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region. You can call the [DescribeRegions](~~26243~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group. You can call the [DescribeDBInstanceAttribute](~~610394~~) operation to obtain the ID of the resource group.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The status of the full backup file. Valid values:
	//
	// *   **Importing**: The full backup file is being imported.
	// *   **Failed**: The full backup file fails to be imported.
	// *   **CheckSucccess**: The full backup file passes the check.
	// *   **BackupSuccess**: The full backup file is imported.
	// *   **Deleted**: The full backup file is deleted.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The tag that is added to the full backup file.
	Tags *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
}

func (s ListUserBackupFilesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListUserBackupFilesRequest) GoString() string {
	return s.String()
}

func (s *ListUserBackupFilesRequest) SetBackupId(v string) *ListUserBackupFilesRequest {
	s.BackupId = &v
	return s
}

func (s *ListUserBackupFilesRequest) SetComment(v string) *ListUserBackupFilesRequest {
	s.Comment = &v
	return s
}

func (s *ListUserBackupFilesRequest) SetOssUrl(v string) *ListUserBackupFilesRequest {
	s.OssUrl = &v
	return s
}

func (s *ListUserBackupFilesRequest) SetOwnerId(v int64) *ListUserBackupFilesRequest {
	s.OwnerId = &v
	return s
}

func (s *ListUserBackupFilesRequest) SetRegionId(v string) *ListUserBackupFilesRequest {
	s.RegionId = &v
	return s
}

func (s *ListUserBackupFilesRequest) SetResourceGroupId(v string) *ListUserBackupFilesRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *ListUserBackupFilesRequest) SetResourceOwnerAccount(v string) *ListUserBackupFilesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ListUserBackupFilesRequest) SetResourceOwnerId(v int64) *ListUserBackupFilesRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ListUserBackupFilesRequest) SetStatus(v string) *ListUserBackupFilesRequest {
	s.Status = &v
	return s
}

func (s *ListUserBackupFilesRequest) SetTags(v string) *ListUserBackupFilesRequest {
	s.Tags = &v
	return s
}

type ListUserBackupFilesResponseBody struct {
	// An array that consists of the information about the full backup files that are returned.
	Records []*ListUserBackupFilesResponseBodyRecords `json:"Records,omitempty" xml:"Records,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListUserBackupFilesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListUserBackupFilesResponseBody) GoString() string {
	return s.String()
}

func (s *ListUserBackupFilesResponseBody) SetRecords(v []*ListUserBackupFilesResponseBodyRecords) *ListUserBackupFilesResponseBody {
	s.Records = v
	return s
}

func (s *ListUserBackupFilesResponseBody) SetRequestId(v string) *ListUserBackupFilesResponseBody {
	s.RequestId = &v
	return s
}

type ListUserBackupFilesResponseBodyRecords struct {
	// The ID of the full backup file.
	BackupId *string `json:"BackupId,omitempty" xml:"BackupId,omitempty"`
	// The information about the binary log file that contains incremental data. If incremental data is generated during the full backup, this parameter is returned.
	BinlogInfo *string `json:"BinlogInfo,omitempty" xml:"BinlogInfo,omitempty"`
	// The description of the full backup file.
	Comment *string `json:"Comment,omitempty" xml:"Comment,omitempty"`
	// The time when the system started to import the full backup file. The value is a UNIX timestamp. Unit: milliseconds.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The database engine of the instance.
	Engine *string `json:"Engine,omitempty" xml:"Engine,omitempty"`
	// The database engine version of the instance.
	EngineVersion *string `json:"EngineVersion,omitempty" xml:"EngineVersion,omitempty"`
	// The time when the full backup file is successfully imported. The value is a UNIX timestamp. Unit: milliseconds.
	FinishTime *string `json:"FinishTime,omitempty" xml:"FinishTime,omitempty"`
	// The time when the full backup file is successfully imported. The value is a UNIX timestamp. Unit: milliseconds.
	ModificationTime *string `json:"ModificationTime,omitempty" xml:"ModificationTime,omitempty"`
	// The name of the OSS bucket in which the full backup file is stored as an object.
	OssBucket *string `json:"OssBucket,omitempty" xml:"OssBucket,omitempty"`
	// The metadata of the full backup file. For more information, see [Manage object metadata](~~31859~~).
	OssFileMetaData *string `json:"OssFileMetaData,omitempty" xml:"OssFileMetaData,omitempty"`
	// The name of the full backup file that is stored as an object in an OSS bucket.
	OssFileName *string `json:"OssFileName,omitempty" xml:"OssFileName,omitempty"`
	// The path of the full backup file that is stored as an object in an OSS bucket.
	OssFilePath *string `json:"OssFilePath,omitempty" xml:"OssFilePath,omitempty"`
	// The size of the full backup file that is stored as an object in an OSS bucket. Unit: KB.
	OssFileSize *int64 `json:"OssFileSize,omitempty" xml:"OssFileSize,omitempty"`
	// The URL to download the full backup file from the OSS bucket.
	OssUrl *string `json:"OssUrl,omitempty" xml:"OssUrl,omitempty"`
	// The reason why the full backup file failed to be imported.
	Reason *string `json:"Reason,omitempty" xml:"Reason,omitempty"`
	// The amount of storage that is required to restore the data of the full backup file. Unit: GB.
	RestoreSize *string `json:"RestoreSize,omitempty" xml:"RestoreSize,omitempty"`
	// The retention period of the full backup file. Unit: days.
	Retention *int32 `json:"Retention,omitempty" xml:"Retention,omitempty"`
	// The status of the full backup file. Valid values:
	//
	// *   **Importing**: The full backup file is being imported.
	// *   **Failed**: The full backup file fails to be imported.
	// *   **CheckSucccess**: The full backup file passes the check.
	// *   **BackupSuccess**: The full backup file is imported.
	// *   **Deleted**: The full backup file is deleted.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The zone ID of the full backup file.
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
}

func (s ListUserBackupFilesResponseBodyRecords) String() string {
	return tea.Prettify(s)
}

func (s ListUserBackupFilesResponseBodyRecords) GoString() string {
	return s.String()
}

func (s *ListUserBackupFilesResponseBodyRecords) SetBackupId(v string) *ListUserBackupFilesResponseBodyRecords {
	s.BackupId = &v
	return s
}

func (s *ListUserBackupFilesResponseBodyRecords) SetBinlogInfo(v string) *ListUserBackupFilesResponseBodyRecords {
	s.BinlogInfo = &v
	return s
}

func (s *ListUserBackupFilesResponseBodyRecords) SetComment(v string) *ListUserBackupFilesResponseBodyRecords {
	s.Comment = &v
	return s
}

func (s *ListUserBackupFilesResponseBodyRecords) SetCreationTime(v string) *ListUserBackupFilesResponseBodyRecords {
	s.CreationTime = &v
	return s
}

func (s *ListUserBackupFilesResponseBodyRecords) SetEngine(v string) *ListUserBackupFilesResponseBodyRecords {
	s.Engine = &v
	return s
}

func (s *ListUserBackupFilesResponseBodyRecords) SetEngineVersion(v string) *ListUserBackupFilesResponseBodyRecords {
	s.EngineVersion = &v
	return s
}

func (s *ListUserBackupFilesResponseBodyRecords) SetFinishTime(v string) *ListUserBackupFilesResponseBodyRecords {
	s.FinishTime = &v
	return s
}

func (s *ListUserBackupFilesResponseBodyRecords) SetModificationTime(v string) *ListUserBackupFilesResponseBodyRecords {
	s.ModificationTime = &v
	return s
}

func (s *ListUserBackupFilesResponseBodyRecords) SetOssBucket(v string) *ListUserBackupFilesResponseBodyRecords {
	s.OssBucket = &v
	return s
}

func (s *ListUserBackupFilesResponseBodyRecords) SetOssFileMetaData(v string) *ListUserBackupFilesResponseBodyRecords {
	s.OssFileMetaData = &v
	return s
}

func (s *ListUserBackupFilesResponseBodyRecords) SetOssFileName(v string) *ListUserBackupFilesResponseBodyRecords {
	s.OssFileName = &v
	return s
}

func (s *ListUserBackupFilesResponseBodyRecords) SetOssFilePath(v string) *ListUserBackupFilesResponseBodyRecords {
	s.OssFilePath = &v
	return s
}

func (s *ListUserBackupFilesResponseBodyRecords) SetOssFileSize(v int64) *ListUserBackupFilesResponseBodyRecords {
	s.OssFileSize = &v
	return s
}

func (s *ListUserBackupFilesResponseBodyRecords) SetOssUrl(v string) *ListUserBackupFilesResponseBodyRecords {
	s.OssUrl = &v
	return s
}

func (s *ListUserBackupFilesResponseBodyRecords) SetReason(v string) *ListUserBackupFilesResponseBodyRecords {
	s.Reason = &v
	return s
}

func (s *ListUserBackupFilesResponseBodyRecords) SetRestoreSize(v string) *ListUserBackupFilesResponseBodyRecords {
	s.RestoreSize = &v
	return s
}

func (s *ListUserBackupFilesResponseBodyRecords) SetRetention(v int32) *ListUserBackupFilesResponseBodyRecords {
	s.Retention = &v
	return s
}

func (s *ListUserBackupFilesResponseBodyRecords) SetStatus(v string) *ListUserBackupFilesResponseBodyRecords {
	s.Status = &v
	return s
}

func (s *ListUserBackupFilesResponseBodyRecords) SetZoneId(v string) *ListUserBackupFilesResponseBodyRecords {
	s.ZoneId = &v
	return s
}

type ListUserBackupFilesResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListUserBackupFilesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListUserBackupFilesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListUserBackupFilesResponse) GoString() string {
	return s.String()
}

func (s *ListUserBackupFilesResponse) SetHeaders(v map[string]*string) *ListUserBackupFilesResponse {
	s.Headers = v
	return s
}

func (s *ListUserBackupFilesResponse) SetStatusCode(v int32) *ListUserBackupFilesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListUserBackupFilesResponse) SetBody(v *ListUserBackupFilesResponseBody) *ListUserBackupFilesResponse {
	s.Body = v
	return s
}

type LockAccountRequest struct {
	// The account that you want to lock. You can lock only one account at a time.
	AccountName *string `json:"AccountName,omitempty" xml:"AccountName,omitempty"`
	// The ID of the ApsaraDB RDS for PostgreSQL instance.
	DBInstanceId         *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s LockAccountRequest) String() string {
	return tea.Prettify(s)
}

func (s LockAccountRequest) GoString() string {
	return s.String()
}

func (s *LockAccountRequest) SetAccountName(v string) *LockAccountRequest {
	s.AccountName = &v
	return s
}

func (s *LockAccountRequest) SetDBInstanceId(v string) *LockAccountRequest {
	s.DBInstanceId = &v
	return s
}

func (s *LockAccountRequest) SetOwnerId(v int64) *LockAccountRequest {
	s.OwnerId = &v
	return s
}

func (s *LockAccountRequest) SetResourceOwnerAccount(v string) *LockAccountRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *LockAccountRequest) SetResourceOwnerId(v int64) *LockAccountRequest {
	s.ResourceOwnerId = &v
	return s
}

type LockAccountResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s LockAccountResponseBody) String() string {
	return tea.Prettify(s)
}

func (s LockAccountResponseBody) GoString() string {
	return s.String()
}

func (s *LockAccountResponseBody) SetRequestId(v string) *LockAccountResponseBody {
	s.RequestId = &v
	return s
}

type LockAccountResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *LockAccountResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s LockAccountResponse) String() string {
	return tea.Prettify(s)
}

func (s LockAccountResponse) GoString() string {
	return s.String()
}

func (s *LockAccountResponse) SetHeaders(v map[string]*string) *LockAccountResponse {
	s.Headers = v
	return s
}

func (s *LockAccountResponse) SetStatusCode(v int32) *LockAccountResponse {
	s.StatusCode = &v
	return s
}

func (s *LockAccountResponse) SetBody(v *LockAccountResponseBody) *LockAccountResponse {
	s.Body = v
	return s
}

type MigrateConnectionToOtherZoneRequest struct {
	// The endpoint of the instance. The endpoint is specified when you create the instance.
	ConnectionString *string `json:"ConnectionString,omitempty" xml:"ConnectionString,omitempty"`
	// The ID of the instance. You can call the [DescribeDBInstances](~~610396~~) operation to query the ID of the instance.
	DBInstanceId    *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerId         *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerId *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the zone.
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
}

func (s MigrateConnectionToOtherZoneRequest) String() string {
	return tea.Prettify(s)
}

func (s MigrateConnectionToOtherZoneRequest) GoString() string {
	return s.String()
}

func (s *MigrateConnectionToOtherZoneRequest) SetConnectionString(v string) *MigrateConnectionToOtherZoneRequest {
	s.ConnectionString = &v
	return s
}

func (s *MigrateConnectionToOtherZoneRequest) SetDBInstanceId(v string) *MigrateConnectionToOtherZoneRequest {
	s.DBInstanceId = &v
	return s
}

func (s *MigrateConnectionToOtherZoneRequest) SetOwnerId(v int64) *MigrateConnectionToOtherZoneRequest {
	s.OwnerId = &v
	return s
}

func (s *MigrateConnectionToOtherZoneRequest) SetResourceOwnerId(v int64) *MigrateConnectionToOtherZoneRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *MigrateConnectionToOtherZoneRequest) SetZoneId(v string) *MigrateConnectionToOtherZoneRequest {
	s.ZoneId = &v
	return s
}

type MigrateConnectionToOtherZoneResponseBody struct {
	// The error code.
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s MigrateConnectionToOtherZoneResponseBody) String() string {
	return tea.Prettify(s)
}

func (s MigrateConnectionToOtherZoneResponseBody) GoString() string {
	return s.String()
}

func (s *MigrateConnectionToOtherZoneResponseBody) SetCode(v string) *MigrateConnectionToOtherZoneResponseBody {
	s.Code = &v
	return s
}

func (s *MigrateConnectionToOtherZoneResponseBody) SetMessage(v string) *MigrateConnectionToOtherZoneResponseBody {
	s.Message = &v
	return s
}

func (s *MigrateConnectionToOtherZoneResponseBody) SetRequestId(v string) *MigrateConnectionToOtherZoneResponseBody {
	s.RequestId = &v
	return s
}

type MigrateConnectionToOtherZoneResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *MigrateConnectionToOtherZoneResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s MigrateConnectionToOtherZoneResponse) String() string {
	return tea.Prettify(s)
}

func (s MigrateConnectionToOtherZoneResponse) GoString() string {
	return s.String()
}

func (s *MigrateConnectionToOtherZoneResponse) SetHeaders(v map[string]*string) *MigrateConnectionToOtherZoneResponse {
	s.Headers = v
	return s
}

func (s *MigrateConnectionToOtherZoneResponse) SetStatusCode(v int32) *MigrateConnectionToOtherZoneResponse {
	s.StatusCode = &v
	return s
}

func (s *MigrateConnectionToOtherZoneResponse) SetBody(v *MigrateConnectionToOtherZoneResponseBody) *MigrateConnectionToOtherZoneResponse {
	s.Body = v
	return s
}

type MigrateDBInstanceRequest struct {
	// The ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The ID of the dedicated cluster. You can call the [DescribeDedicatedHostGroups](~~141946~~) operation to query the ID of the dedicated cluster.
	DedicatedHostGroupId *string `json:"DedicatedHostGroupId,omitempty" xml:"DedicatedHostGroupId,omitempty"`
	// The time when you want the system to start the migration. Valid values:
	//
	// *   **Immediately**: The system immediately starts the migration. This is the default value.
	// *   **MaintainTime**: The system starts the migration during the specified maintenance window.
	// *   **Specified**: The system starts the migration at the specified point in time.
	EffectiveTime *string `json:"EffectiveTime,omitempty" xml:"EffectiveTime,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region. You can call the [DescribeRegions](~~26243~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The point in time when you want the system to start the migration. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
	//
	// > This parameter must be specified when you set **EffectiveTime** to **Specified**.
	SpecifiedTime *string `json:"SpecifiedTime,omitempty" xml:"SpecifiedTime,omitempty"`
	// The ID of the host to which you want to migrate the primary instance. You can call the [DescribeDedicatedHosts](~~200944~~) operation to obtain the ID of the host.
	TargetDedicatedHostIdForMaster *string `json:"TargetDedicatedHostIdForMaster,omitempty" xml:"TargetDedicatedHostIdForMaster,omitempty"`
	// The ID of the host to which you want to migrate the secondary instance. You can call the [DescribeDedicatedHosts](~~200944~~) operation to obtain the ID of the host.
	TargetDedicatedHostIdForSlave *string `json:"TargetDedicatedHostIdForSlave,omitempty" xml:"TargetDedicatedHostIdForSlave,omitempty"`
	// The zone ID of the secondary instance.
	ZoneIdForFollower *string `json:"ZoneIdForFollower,omitempty" xml:"ZoneIdForFollower,omitempty"`
	// The zone ID of the logger instance.
	ZoneIdForLog *string `json:"ZoneIdForLog,omitempty" xml:"ZoneIdForLog,omitempty"`
}

func (s MigrateDBInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s MigrateDBInstanceRequest) GoString() string {
	return s.String()
}

func (s *MigrateDBInstanceRequest) SetDBInstanceId(v string) *MigrateDBInstanceRequest {
	s.DBInstanceId = &v
	return s
}

func (s *MigrateDBInstanceRequest) SetDedicatedHostGroupId(v string) *MigrateDBInstanceRequest {
	s.DedicatedHostGroupId = &v
	return s
}

func (s *MigrateDBInstanceRequest) SetEffectiveTime(v string) *MigrateDBInstanceRequest {
	s.EffectiveTime = &v
	return s
}

func (s *MigrateDBInstanceRequest) SetOwnerId(v int64) *MigrateDBInstanceRequest {
	s.OwnerId = &v
	return s
}

func (s *MigrateDBInstanceRequest) SetRegionId(v string) *MigrateDBInstanceRequest {
	s.RegionId = &v
	return s
}

func (s *MigrateDBInstanceRequest) SetResourceOwnerAccount(v string) *MigrateDBInstanceRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *MigrateDBInstanceRequest) SetResourceOwnerId(v int64) *MigrateDBInstanceRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *MigrateDBInstanceRequest) SetSpecifiedTime(v string) *MigrateDBInstanceRequest {
	s.SpecifiedTime = &v
	return s
}

func (s *MigrateDBInstanceRequest) SetTargetDedicatedHostIdForMaster(v string) *MigrateDBInstanceRequest {
	s.TargetDedicatedHostIdForMaster = &v
	return s
}

func (s *MigrateDBInstanceRequest) SetTargetDedicatedHostIdForSlave(v string) *MigrateDBInstanceRequest {
	s.TargetDedicatedHostIdForSlave = &v
	return s
}

func (s *MigrateDBInstanceRequest) SetZoneIdForFollower(v string) *MigrateDBInstanceRequest {
	s.ZoneIdForFollower = &v
	return s
}

func (s *MigrateDBInstanceRequest) SetZoneIdForLog(v string) *MigrateDBInstanceRequest {
	s.ZoneIdForLog = &v
	return s
}

type MigrateDBInstanceResponseBody struct {
	// The serial number of the task in the migration task queue. When the serial number becomes 0, the system starts the migration.
	MigrationId *int32 `json:"MigrationId,omitempty" xml:"MigrationId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the task.
	TaskId *int32 `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
}

func (s MigrateDBInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s MigrateDBInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *MigrateDBInstanceResponseBody) SetMigrationId(v int32) *MigrateDBInstanceResponseBody {
	s.MigrationId = &v
	return s
}

func (s *MigrateDBInstanceResponseBody) SetRequestId(v string) *MigrateDBInstanceResponseBody {
	s.RequestId = &v
	return s
}

func (s *MigrateDBInstanceResponseBody) SetTaskId(v int32) *MigrateDBInstanceResponseBody {
	s.TaskId = &v
	return s
}

type MigrateDBInstanceResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *MigrateDBInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s MigrateDBInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s MigrateDBInstanceResponse) GoString() string {
	return s.String()
}

func (s *MigrateDBInstanceResponse) SetHeaders(v map[string]*string) *MigrateDBInstanceResponse {
	s.Headers = v
	return s
}

func (s *MigrateDBInstanceResponse) SetStatusCode(v int32) *MigrateDBInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *MigrateDBInstanceResponse) SetBody(v *MigrateDBInstanceResponseBody) *MigrateDBInstanceResponse {
	s.Body = v
	return s
}

type MigrateSecurityIPModeRequest struct {
	// The ID of the instance. You can call the [DescribeDBInstances](~~610396~~) operation to query the ID of the instance.
	DBInstanceId         *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s MigrateSecurityIPModeRequest) String() string {
	return tea.Prettify(s)
}

func (s MigrateSecurityIPModeRequest) GoString() string {
	return s.String()
}

func (s *MigrateSecurityIPModeRequest) SetDBInstanceId(v string) *MigrateSecurityIPModeRequest {
	s.DBInstanceId = &v
	return s
}

func (s *MigrateSecurityIPModeRequest) SetOwnerId(v int64) *MigrateSecurityIPModeRequest {
	s.OwnerId = &v
	return s
}

func (s *MigrateSecurityIPModeRequest) SetResourceOwnerAccount(v string) *MigrateSecurityIPModeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *MigrateSecurityIPModeRequest) SetResourceOwnerId(v int64) *MigrateSecurityIPModeRequest {
	s.ResourceOwnerId = &v
	return s
}

type MigrateSecurityIPModeResponseBody struct {
	// The ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The whitelist mode after the change, which is the enhanced whitelist mode.
	//
	// Valid values:
	//
	// *   safety
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     enhanced whitelist mode
	//
	//     <!-- -->
	SecurityIPMode *string `json:"SecurityIPMode,omitempty" xml:"SecurityIPMode,omitempty"`
}

func (s MigrateSecurityIPModeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s MigrateSecurityIPModeResponseBody) GoString() string {
	return s.String()
}

func (s *MigrateSecurityIPModeResponseBody) SetDBInstanceId(v string) *MigrateSecurityIPModeResponseBody {
	s.DBInstanceId = &v
	return s
}

func (s *MigrateSecurityIPModeResponseBody) SetRequestId(v string) *MigrateSecurityIPModeResponseBody {
	s.RequestId = &v
	return s
}

func (s *MigrateSecurityIPModeResponseBody) SetSecurityIPMode(v string) *MigrateSecurityIPModeResponseBody {
	s.SecurityIPMode = &v
	return s
}

type MigrateSecurityIPModeResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *MigrateSecurityIPModeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s MigrateSecurityIPModeResponse) String() string {
	return tea.Prettify(s)
}

func (s MigrateSecurityIPModeResponse) GoString() string {
	return s.String()
}

func (s *MigrateSecurityIPModeResponse) SetHeaders(v map[string]*string) *MigrateSecurityIPModeResponse {
	s.Headers = v
	return s
}

func (s *MigrateSecurityIPModeResponse) SetStatusCode(v int32) *MigrateSecurityIPModeResponse {
	s.StatusCode = &v
	return s
}

func (s *MigrateSecurityIPModeResponse) SetBody(v *MigrateSecurityIPModeResponseBody) *MigrateSecurityIPModeResponse {
	s.Body = v
	return s
}

type MigrateToOtherZoneRequest struct {
	// The RDS edition of the instance. Valid values:
	//
	// *   **Basic**: RDS Basic Edition
	// *   **HighAvailability**: RDS High-availability Edition
	// *   **AlwaysOn**: SQL Server on RDS Cluster Edition
	// *   **cluster**: MySQL on RDS Cluster Edition
	// *   **Finance**: RDS Enterprise Edition
	Category *string `json:"Category,omitempty" xml:"Category,omitempty"`
	// The new instance type of the instance. You can change the instance type of the instance. You cannot change the storage type of the instance. If you set **IsModifySpec** to **true**, you must specify at least one of DBInstanceClass and **DBInstanceStorage**.
	//
	// For more information about instance types, see [Primary ApsaraDB RDS for MySQL instance types](~~276975~~).
	DBInstanceClass *string `json:"DBInstanceClass,omitempty" xml:"DBInstanceClass,omitempty"`
	// The instance ID. You can call the [DescribeDBInstances](~~610396~~) operation to query the instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The new storage capacity of the instance. If you set **IsModifySpec** to **true**, you must specify at least one of DBInstanceStorage and **DBInstanceClass**.
	//
	// Unit: GB. The available storage capacity range varies based on the instance type of the instance. For more information, see [Primary ApsaraDB RDS for MySQL instance types](~~276975~~).
	DBInstanceStorage *int64 `json:"DBInstanceStorage,omitempty" xml:"DBInstanceStorage,omitempty"`
	// The effective time. Valid values:
	//
	// *   **Immediate**: The instance is immediately migrated. This is the default value.
	// *   **MaintainTime**: The instance is migrated during the maintenance window. For more information, see [ModifyDBInstanceMaintainTime](~~26249~~).
	// *   **ScheduleTime**: The instance is migrated at the point in time that you specify.
	//
	// >  If you set this parameter to **ScheduleTime**, you must specify the **SwitchTime** parameter.
	EffectiveTime *string `json:"EffectiveTime,omitempty" xml:"EffectiveTime,omitempty"`
	// Specifies whether to change the specifications of the instance during the cross-zone migration. Valid values:
	//
	// *   **true**: You want to change the specifications of the instance during the cross-zone migration. If you set this parameter to **true**, you must specify at least one of **DBInstanceClass** and **DBInstanceStorage**.
	// *   **false** (default): You do not want to change the specifications of the instance during the cross-zone migration.
	//
	// > This parameter applies only to instances that run MySQL.
	IsModifySpec         *string `json:"IsModifySpec,omitempty" xml:"IsModifySpec,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The migration time. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
	//
	// > This parameter is used with **EffectiveTime**. You must specify this parameter only when **EffectiveTime** is set to **ScheduleTime**.
	SwitchTime *string `json:"SwitchTime,omitempty" xml:"SwitchTime,omitempty"`
	// The ID of the virtual private cloud (VPC). Do not change the VPC of the instance when you migrate the instance across zones.
	//
	// *   This parameter must be specified when the instance resides in a VPC.
	// *   If the instance runs SQL Server, you can change the VPC of the instance.
	VPCId *string `json:"VPCId,omitempty" xml:"VPCId,omitempty"`
	// The vSwitch ID.
	//
	// *   This parameter must be specified when the instance resides in a VPC. You can call the [DescribeVSwitches](~~35748~~) operation to query the vSwitch ID.
	// *   If the instance runs PostgreSQL or SQL Server and a secondary zone is specified for the instance, you can specify multiple vSwitch IDs, each of which corresponds to a zone. Separate the vSwitch IDs with commas (,).
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
	// The zone ID of the new instance. You can call the [DescribeRegions](~~610399~~) operation to query the most recent region list.
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
	// The secondary zone 1 of the instance.
	//
	// >  This parameter must be configured if the instance runs RDS editions other than RDS Basic Edition.
	ZoneIdSlave1 *string `json:"ZoneIdSlave1,omitempty" xml:"ZoneIdSlave1,omitempty"`
	// The secondary zone 2 of the instance.
	//
	// >  You can specify this parameter only for instances that run RDS Enterprise Edition.
	ZoneIdSlave2 *string `json:"ZoneIdSlave2,omitempty" xml:"ZoneIdSlave2,omitempty"`
}

func (s MigrateToOtherZoneRequest) String() string {
	return tea.Prettify(s)
}

func (s MigrateToOtherZoneRequest) GoString() string {
	return s.String()
}

func (s *MigrateToOtherZoneRequest) SetCategory(v string) *MigrateToOtherZoneRequest {
	s.Category = &v
	return s
}

func (s *MigrateToOtherZoneRequest) SetDBInstanceClass(v string) *MigrateToOtherZoneRequest {
	s.DBInstanceClass = &v
	return s
}

func (s *MigrateToOtherZoneRequest) SetDBInstanceId(v string) *MigrateToOtherZoneRequest {
	s.DBInstanceId = &v
	return s
}

func (s *MigrateToOtherZoneRequest) SetDBInstanceStorage(v int64) *MigrateToOtherZoneRequest {
	s.DBInstanceStorage = &v
	return s
}

func (s *MigrateToOtherZoneRequest) SetEffectiveTime(v string) *MigrateToOtherZoneRequest {
	s.EffectiveTime = &v
	return s
}

func (s *MigrateToOtherZoneRequest) SetIsModifySpec(v string) *MigrateToOtherZoneRequest {
	s.IsModifySpec = &v
	return s
}

func (s *MigrateToOtherZoneRequest) SetOwnerAccount(v string) *MigrateToOtherZoneRequest {
	s.OwnerAccount = &v
	return s
}

func (s *MigrateToOtherZoneRequest) SetOwnerId(v int64) *MigrateToOtherZoneRequest {
	s.OwnerId = &v
	return s
}

func (s *MigrateToOtherZoneRequest) SetResourceOwnerAccount(v string) *MigrateToOtherZoneRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *MigrateToOtherZoneRequest) SetResourceOwnerId(v int64) *MigrateToOtherZoneRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *MigrateToOtherZoneRequest) SetSwitchTime(v string) *MigrateToOtherZoneRequest {
	s.SwitchTime = &v
	return s
}

func (s *MigrateToOtherZoneRequest) SetVPCId(v string) *MigrateToOtherZoneRequest {
	s.VPCId = &v
	return s
}

func (s *MigrateToOtherZoneRequest) SetVSwitchId(v string) *MigrateToOtherZoneRequest {
	s.VSwitchId = &v
	return s
}

func (s *MigrateToOtherZoneRequest) SetZoneId(v string) *MigrateToOtherZoneRequest {
	s.ZoneId = &v
	return s
}

func (s *MigrateToOtherZoneRequest) SetZoneIdSlave1(v string) *MigrateToOtherZoneRequest {
	s.ZoneIdSlave1 = &v
	return s
}

func (s *MigrateToOtherZoneRequest) SetZoneIdSlave2(v string) *MigrateToOtherZoneRequest {
	s.ZoneIdSlave2 = &v
	return s
}

type MigrateToOtherZoneResponseBody struct {
	// The instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The ID of the order. This parameter is returned only when the instance runs MySQL.
	OrderId *int64 `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s MigrateToOtherZoneResponseBody) String() string {
	return tea.Prettify(s)
}

func (s MigrateToOtherZoneResponseBody) GoString() string {
	return s.String()
}

func (s *MigrateToOtherZoneResponseBody) SetDBInstanceId(v string) *MigrateToOtherZoneResponseBody {
	s.DBInstanceId = &v
	return s
}

func (s *MigrateToOtherZoneResponseBody) SetOrderId(v int64) *MigrateToOtherZoneResponseBody {
	s.OrderId = &v
	return s
}

func (s *MigrateToOtherZoneResponseBody) SetRequestId(v string) *MigrateToOtherZoneResponseBody {
	s.RequestId = &v
	return s
}

type MigrateToOtherZoneResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *MigrateToOtherZoneResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s MigrateToOtherZoneResponse) String() string {
	return tea.Prettify(s)
}

func (s MigrateToOtherZoneResponse) GoString() string {
	return s.String()
}

func (s *MigrateToOtherZoneResponse) SetHeaders(v map[string]*string) *MigrateToOtherZoneResponse {
	s.Headers = v
	return s
}

func (s *MigrateToOtherZoneResponse) SetStatusCode(v int32) *MigrateToOtherZoneResponse {
	s.StatusCode = &v
	return s
}

func (s *MigrateToOtherZoneResponse) SetBody(v *MigrateToOtherZoneResponseBody) *MigrateToOtherZoneResponse {
	s.Body = v
	return s
}

type ModifyADInfoRequest struct {
	// The account of the AD domain.
	ADAccountName *string `json:"ADAccountName,omitempty" xml:"ADAccountName,omitempty"`
	// The DNS information about the AD domain.
	ADDNS *string `json:"ADDNS,omitempty" xml:"ADDNS,omitempty"`
	// The password for the account of the AD domain.
	ADPassword *string `json:"ADPassword,omitempty" xml:"ADPassword,omitempty"`
	// The IP address of the AD domain.
	ADServerIpAddress *string `json:"ADServerIpAddress,omitempty" xml:"ADServerIpAddress,omitempty"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The instance ID. You can call the [DescribeDBInstances](~~26232~~) operation to query the instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID. You can call the [DescribeRegions](~~26243~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ModifyADInfoRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyADInfoRequest) GoString() string {
	return s.String()
}

func (s *ModifyADInfoRequest) SetADAccountName(v string) *ModifyADInfoRequest {
	s.ADAccountName = &v
	return s
}

func (s *ModifyADInfoRequest) SetADDNS(v string) *ModifyADInfoRequest {
	s.ADDNS = &v
	return s
}

func (s *ModifyADInfoRequest) SetADPassword(v string) *ModifyADInfoRequest {
	s.ADPassword = &v
	return s
}

func (s *ModifyADInfoRequest) SetADServerIpAddress(v string) *ModifyADInfoRequest {
	s.ADServerIpAddress = &v
	return s
}

func (s *ModifyADInfoRequest) SetClientToken(v string) *ModifyADInfoRequest {
	s.ClientToken = &v
	return s
}

func (s *ModifyADInfoRequest) SetDBInstanceId(v string) *ModifyADInfoRequest {
	s.DBInstanceId = &v
	return s
}

func (s *ModifyADInfoRequest) SetOwnerId(v int64) *ModifyADInfoRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyADInfoRequest) SetRegionId(v string) *ModifyADInfoRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyADInfoRequest) SetResourceOwnerAccount(v string) *ModifyADInfoRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyADInfoRequest) SetResourceOwnerId(v int64) *ModifyADInfoRequest {
	s.ResourceOwnerId = &v
	return s
}

type ModifyADInfoResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyADInfoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyADInfoResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyADInfoResponseBody) SetRequestId(v string) *ModifyADInfoResponseBody {
	s.RequestId = &v
	return s
}

type ModifyADInfoResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyADInfoResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyADInfoResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyADInfoResponse) GoString() string {
	return s.String()
}

func (s *ModifyADInfoResponse) SetHeaders(v map[string]*string) *ModifyADInfoResponse {
	s.Headers = v
	return s
}

func (s *ModifyADInfoResponse) SetStatusCode(v int32) *ModifyADInfoResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyADInfoResponse) SetBody(v *ModifyADInfoResponseBody) *ModifyADInfoResponse {
	s.Body = v
	return s
}

type ModifyAccountDescriptionRequest struct {
	// The description of the account. The value must be 2 to 256 characters in length. The value can contain letters, digits, underscores (\_), and hyphens (-), and must start with a letter.
	//
	// >  The description cannot start with http:// or https://.
	AccountDescription *string `json:"AccountDescription,omitempty" xml:"AccountDescription,omitempty"`
	// The username of the account. You can call the DescribeAccounts operation to obtain the username of the account.
	AccountName *string `json:"AccountName,omitempty" xml:"AccountName,omitempty"`
	// The instance ID. You can call the DescribeDBInstances operation to query the instance ID.
	DBInstanceId         *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ModifyAccountDescriptionRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyAccountDescriptionRequest) GoString() string {
	return s.String()
}

func (s *ModifyAccountDescriptionRequest) SetAccountDescription(v string) *ModifyAccountDescriptionRequest {
	s.AccountDescription = &v
	return s
}

func (s *ModifyAccountDescriptionRequest) SetAccountName(v string) *ModifyAccountDescriptionRequest {
	s.AccountName = &v
	return s
}

func (s *ModifyAccountDescriptionRequest) SetDBInstanceId(v string) *ModifyAccountDescriptionRequest {
	s.DBInstanceId = &v
	return s
}

func (s *ModifyAccountDescriptionRequest) SetOwnerAccount(v string) *ModifyAccountDescriptionRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyAccountDescriptionRequest) SetOwnerId(v int64) *ModifyAccountDescriptionRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyAccountDescriptionRequest) SetResourceOwnerAccount(v string) *ModifyAccountDescriptionRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyAccountDescriptionRequest) SetResourceOwnerId(v int64) *ModifyAccountDescriptionRequest {
	s.ResourceOwnerId = &v
	return s
}

type ModifyAccountDescriptionResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyAccountDescriptionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyAccountDescriptionResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyAccountDescriptionResponseBody) SetRequestId(v string) *ModifyAccountDescriptionResponseBody {
	s.RequestId = &v
	return s
}

type ModifyAccountDescriptionResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyAccountDescriptionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyAccountDescriptionResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyAccountDescriptionResponse) GoString() string {
	return s.String()
}

func (s *ModifyAccountDescriptionResponse) SetHeaders(v map[string]*string) *ModifyAccountDescriptionResponse {
	s.Headers = v
	return s
}

func (s *ModifyAccountDescriptionResponse) SetStatusCode(v int32) *ModifyAccountDescriptionResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyAccountDescriptionResponse) SetBody(v *ModifyAccountDescriptionResponseBody) *ModifyAccountDescriptionResponse {
	s.Body = v
	return s
}

type ModifyActionEventPolicyRequest struct {
	// Specifies whether to enable the event history feature. Valid values: **True | False**.
	EnableEventLog *string `json:"EnableEventLog,omitempty" xml:"EnableEventLog,omitempty"`
	OwnerId        *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region for which you want to enable the event history feature. You can call the [DescribeRegions](~~26243~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ModifyActionEventPolicyRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyActionEventPolicyRequest) GoString() string {
	return s.String()
}

func (s *ModifyActionEventPolicyRequest) SetEnableEventLog(v string) *ModifyActionEventPolicyRequest {
	s.EnableEventLog = &v
	return s
}

func (s *ModifyActionEventPolicyRequest) SetOwnerId(v int64) *ModifyActionEventPolicyRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyActionEventPolicyRequest) SetRegionId(v string) *ModifyActionEventPolicyRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyActionEventPolicyRequest) SetResourceOwnerAccount(v string) *ModifyActionEventPolicyRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyActionEventPolicyRequest) SetResourceOwnerId(v int64) *ModifyActionEventPolicyRequest {
	s.ResourceOwnerId = &v
	return s
}

type ModifyActionEventPolicyResponseBody struct {
	// Indicates whether the event history feature is enabled.
	EnableEventLog *string `json:"EnableEventLog,omitempty" xml:"EnableEventLog,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyActionEventPolicyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyActionEventPolicyResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyActionEventPolicyResponseBody) SetEnableEventLog(v string) *ModifyActionEventPolicyResponseBody {
	s.EnableEventLog = &v
	return s
}

func (s *ModifyActionEventPolicyResponseBody) SetRegionId(v string) *ModifyActionEventPolicyResponseBody {
	s.RegionId = &v
	return s
}

func (s *ModifyActionEventPolicyResponseBody) SetRequestId(v string) *ModifyActionEventPolicyResponseBody {
	s.RequestId = &v
	return s
}

type ModifyActionEventPolicyResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyActionEventPolicyResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyActionEventPolicyResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyActionEventPolicyResponse) GoString() string {
	return s.String()
}

func (s *ModifyActionEventPolicyResponse) SetHeaders(v map[string]*string) *ModifyActionEventPolicyResponse {
	s.Headers = v
	return s
}

func (s *ModifyActionEventPolicyResponse) SetStatusCode(v int32) *ModifyActionEventPolicyResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyActionEventPolicyResponse) SetBody(v *ModifyActionEventPolicyResponseBody) *ModifyActionEventPolicyResponse {
	s.Body = v
	return s
}

type ModifyActiveOperationTasksRequest struct {
	// The ID of the O\&M task. Separate multiple IDs with commas (,).
	//
	// > You can call the [DescribeActiveOperationTask](~~611455~~) operation to query the IDs of O\&M tasks.
	Ids *string `json:"Ids,omitempty" xml:"Ids,omitempty"`
	// Specifies whether to immediately start scheduling. The value 0 indicates that scheduling is not immediately started. This is the default value. The value 1 indicates that scheduling is immediately started. If you set this parameter to 0, SwitchTime takes effect. If you set this parameter to 1, SwitchTimer does not take effect. In this case, the start time of the task is set to the current time, and the system determines the switching time based on the start time.
	//
	// > Immediate scheduling indicates that the task enters the preparation state instead of the immediate switchover. After the preparation is complete, the switchover is performed. You can call the [DescribeActiveOperationTasks](~~611455~~) operation to obtain the period of time for preparation. The period of time for preparation is returned in PrepareInterva.
	ImmediateStart       *int32  `json:"ImmediateStart,omitempty" xml:"ImmediateStart,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	SecurityToken        *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
	// The scheduled switching time that you want to specify. Specify the time in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// > The time that you specify cannot be later than the deadline for performing the O\&M task. You can call [DescribeActiveOperationTasks](~~611455~~) to query the deadlines of O\&M tasks. The deadline of a task is returned in Deadline.
	SwitchTime *string `json:"SwitchTime,omitempty" xml:"SwitchTime,omitempty"`
}

func (s ModifyActiveOperationTasksRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyActiveOperationTasksRequest) GoString() string {
	return s.String()
}

func (s *ModifyActiveOperationTasksRequest) SetIds(v string) *ModifyActiveOperationTasksRequest {
	s.Ids = &v
	return s
}

func (s *ModifyActiveOperationTasksRequest) SetImmediateStart(v int32) *ModifyActiveOperationTasksRequest {
	s.ImmediateStart = &v
	return s
}

func (s *ModifyActiveOperationTasksRequest) SetOwnerAccount(v string) *ModifyActiveOperationTasksRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyActiveOperationTasksRequest) SetOwnerId(v int64) *ModifyActiveOperationTasksRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyActiveOperationTasksRequest) SetResourceOwnerAccount(v string) *ModifyActiveOperationTasksRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyActiveOperationTasksRequest) SetResourceOwnerId(v int64) *ModifyActiveOperationTasksRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ModifyActiveOperationTasksRequest) SetSecurityToken(v string) *ModifyActiveOperationTasksRequest {
	s.SecurityToken = &v
	return s
}

func (s *ModifyActiveOperationTasksRequest) SetSwitchTime(v string) *ModifyActiveOperationTasksRequest {
	s.SwitchTime = &v
	return s
}

type ModifyActiveOperationTasksResponseBody struct {
	// The ID of the O\&M task. IDs are separated by commas (,).
	Ids *string `json:"Ids,omitempty" xml:"Ids,omitempty"`
	// The ID of the region.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyActiveOperationTasksResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyActiveOperationTasksResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyActiveOperationTasksResponseBody) SetIds(v string) *ModifyActiveOperationTasksResponseBody {
	s.Ids = &v
	return s
}

func (s *ModifyActiveOperationTasksResponseBody) SetRequestId(v string) *ModifyActiveOperationTasksResponseBody {
	s.RequestId = &v
	return s
}

type ModifyActiveOperationTasksResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyActiveOperationTasksResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyActiveOperationTasksResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyActiveOperationTasksResponse) GoString() string {
	return s.String()
}

func (s *ModifyActiveOperationTasksResponse) SetHeaders(v map[string]*string) *ModifyActiveOperationTasksResponse {
	s.Headers = v
	return s
}

func (s *ModifyActiveOperationTasksResponse) SetStatusCode(v int32) *ModifyActiveOperationTasksResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyActiveOperationTasksResponse) SetBody(v *ModifyActiveOperationTasksResponseBody) *ModifyActiveOperationTasksResponse {
	s.Body = v
	return s
}

type ModifyBackupPolicyRequest struct {
	// The number of archived backup files that are retained. Default value: **1**. Valid values:
	//
	// *   Valid values when **ArchiveBackupKeepPolicy** is set to **ByMonth**: **1** to **31**.
	// *   Valid values when **ArchiveBackupKeepPolicy** is set to **ByWeek**: **1** to **7**.
	//
	// >
	//
	// *   You do not need to specify this parameter when **ArchiveBackupKeepPolicy** is set to **KeepAll**.
	//
	// *   This parameter takes effect only when **BackupPolicyMode** is set to **DataBackupPolicy**.
	ArchiveBackupKeepCount *int32 `json:"ArchiveBackupKeepCount,omitempty" xml:"ArchiveBackupKeepCount,omitempty"`
	// The retention period of archived backup files. The number of archived backup files that can be retained within the specified retention period is specified by **ArchiveBackupKeepCount**. Default value: **0**. Valid values:
	//
	// *   **ByMonth**
	// *   **ByWeek**
	// *   **KeepAll**
	//
	// > This parameter takes effect only when **BackupPolicyMode** is set to **DataBackupPolicy**.
	ArchiveBackupKeepPolicy *string `json:"ArchiveBackupKeepPolicy,omitempty" xml:"ArchiveBackupKeepPolicy,omitempty"`
	// The number of days for which the archived backup is retained. The default value **0** specifies that the backup archiving feature is disabled. Valid values: **30** to **1095**.
	//
	// > This parameter takes effect only when **BackupPolicyMode** is set to **DataBackupPolicy**.
	ArchiveBackupRetentionPeriod *string `json:"ArchiveBackupRetentionPeriod,omitempty" xml:"ArchiveBackupRetentionPeriod,omitempty"`
	// The frequency at which you want to perform a snapshot backup on the instance. Valid values:
	//
	// *   **-1**: No backup frequencies are specified.
	// *   **30**: A snapshot backup is performed every 30 minutes.
	// *   **60**: A snapshot backup is performed every 60 minutes.
	// *   **120**: A snapshot backup is performed every 120 minutes.
	// *   **240**: A snapshot backup is performed every 240 minutes.
	// *   **480**: A snapshot backup is performed every 480 minutes.
	//
	// >
	//
	// *   You can configure a backup policy by using this parameter and the **PreferredBackupPeriod** parameter. For example, if you set **PreferredBackupPeriod** to Saturday,Sunday and BackupInterval to \*\*-1\*\*, a snapshot backup is performed on every Saturday and Sunday.
	//
	// *   If the instance runs PostgreSQL, BackupInterval is supported only when the instance is equipped with cloud disks.
	//
	// *   If the instance runs SQL Server, BackupInterval is supported only when the snapshot backup feature is enabled for the instance. For more information, see [Enable snapshot backups for an ApsaraDB RDS for SQL Server instance](~~211143~~).
	//
	// *   If **Category** is set to **Flash**, BackupInterval is invalid.
	//
	// *   This parameter takes effect only when **BackupPolicyMode** is set to **DataBackupPolicy**.
	BackupInterval *string `json:"BackupInterval,omitempty" xml:"BackupInterval,omitempty"`
	// Specifies whether to enable the log backup feature. Valid values:
	//
	// *   **Enable**: enables the feature.
	// *   **Disabled**: disables the feature.
	//
	// >
	//
	// *   This parameter must be specified when **BackupPolicyMode** is set to **DataBackupPolicy**.
	//
	// *   This parameter takes effect only when **BackupPolicyMode** is set to **DataBackupPolicy**.
	BackupLog *string `json:"BackupLog,omitempty" xml:"BackupLog,omitempty"`
	// The backup method of the instance. Valid values:
	//
	// *   **Physical**: physical backup
	// *   **Snapshot**: snapshot backup
	//
	// Default value: **Physical**.
	//
	// >
	//
	// *   This parameter takes effect only on instances that run SQL Server with cloud disks.
	//
	// *   This parameter takes effect only when **BackupPolicyMode** is set to **DataBackupPolicy**.
	BackupMethod *string `json:"BackupMethod,omitempty" xml:"BackupMethod,omitempty"`
	// The type of the backup. Valid values:
	//
	// *   **DataBackupPolicy**: data backup
	// *   **LogBackupPolicy**: log backup
	BackupPolicyMode *string `json:"BackupPolicyMode,omitempty" xml:"BackupPolicyMode,omitempty"`
	// Specifies whether the backup settings of a secondary instance are configured. Valid values:
	//
	// *   **1**: secondary instance preferred
	// *   **2**: primary instance preferred
	//
	// >
	//
	// *   This parameter is suitable only for instances that run SQL Server on RDS Cluster Edition.
	//
	// *   This parameter takes effect only when **BackupMethod** is set to **Physical**. If **BackupMethod** is set to **Snapshot**, backups are forcefully performed on the primary instance that runs SQL Server on RDS Cluster Edition.
	BackupPriority *int32 `json:"BackupPriority,omitempty" xml:"BackupPriority,omitempty"`
	// The number of days for which you want to retain data backup files. Valid values: **7 to 730**.
	//
	// >
	//
	// *   This parameter must be specified when **BackupPolicyMode** is set to **DataBackupPolicy**.
	//
	// *   This parameter takes effect only when **BackupPolicyMode** is set to **DataBackupPolicy**.
	BackupRetentionPeriod *string `json:"BackupRetentionPeriod,omitempty" xml:"BackupRetentionPeriod,omitempty"`
	// Specifies whether to enable the single-digit second backup feature. Valid values:
	//
	// *   **Flash**: enables the feature.
	// *   **Standard**: disables the feature.
	//
	// > This parameter takes effect only when **BackupPolicyMode** is set to **DataBackupPolicy**.
	Category *string `json:"Category,omitempty" xml:"Category,omitempty"`
	// The format that is used to compress backup data. Valid values:
	//
	// *   **0**: Backups are not compressed.
	// *   **1**: The zlib tool is used to compress backups into .tar.gz files.
	// *   **2**: The zlib tool is used to compress backups in parallel.
	// *   **4**: The QuickLZ tool is used to compress backups into .xb.gz files. This compression format is supported for instances that run MySQL 5.6 or MySQL 5.7. Backups in this compression format can be used to restore individual databases and tables. For more information, see [Restore individual databases and tables of an ApsaraDB RDS for MySQL instance](~~103175~~).
	// *   **8**: The QuickLZ tool is used to compress backups into .xb.gz files. This compression format is supported only for instances that run MySQL 8.0. Backups in this compression format cannot be used to restore individual databases and tables.
	//
	// > This parameter takes effect only when **BackupPolicyMode** is set to **DataBackupPolicy**.
	CompressType *string `json:"CompressType,omitempty" xml:"CompressType,omitempty"`
	// The instance ID. You can call the [DescribeDBInstances](~~610396~~) operation to query the ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// Specifies whether to enable the log backup feature. Valid values:
	//
	// *   **True** or **1**: enables the feature.
	// *   **False** or **0**: disables the feature.
	//
	// >
	//
	// *   This parameter must be specified when **BackupPolicyMode** is set to **LogBackupPolicy**.
	//
	// *   This parameter takes effect only when **BackupPolicyMode** is set to **LogBackupPolicy**.
	EnableBackupLog *string `json:"EnableBackupLog,omitempty" xml:"EnableBackupLog,omitempty"`
	// Specifies whether to enable incremental backup. Valid values:
	//
	// *   **false** (default): disables the feature.
	// *   **true**: enables the feature.
	//
	// >
	//
	// *   This parameter takes effect only on instances that run SQL Server with cloud disks.
	//
	// *   This parameter takes effect only when **BackupPolicyMode** is set to **DataBackupPolicy**.
	EnableIncrementDataBackup *bool `json:"EnableIncrementDataBackup,omitempty" xml:"EnableIncrementDataBackup,omitempty"`
	// Specifies whether to forcefully delete log backup files from the instance when the storage usage of the instance exceeds 80% or the amount of remaining storage on the instance is less than 5 GB. Valid values: **Enable and Disable**. You can retain the default value.
	//
	// >
	//
	// *   This parameter must be specified when **BackupPolicyMode** is set to **LogBackupPolicy**.
	//
	// *   This parameter takes effect only when **BackupPolicyMode** is set to **LogBackupPolicy**.
	HighSpaceUsageProtection *string `json:"HighSpaceUsageProtection,omitempty" xml:"HighSpaceUsageProtection,omitempty"`
	// The number of hours for which you want to retain log backup files on the instance. Valid values: **0 to 168**. The value 0 specifies that log backup files are not retained on the instance. The value 168 is calculated based on the following formula: 7 × 24.
	//
	// >
	//
	// *   This parameter must be specified when **BackupPolicyMode** is set to **LogBackupPolicy**.
	//
	// *   This parameter takes effect only when **BackupPolicyMode** is set to **LogBackupPolicy**.
	LocalLogRetentionHours *string `json:"LocalLogRetentionHours,omitempty" xml:"LocalLogRetentionHours,omitempty"`
	// The maximum storage usage that is allowed for log backup files on the instance. If the storage usage for log backup files on the instance exceeds the value of this parameter, the system deletes earlier log backup files until the storage usage falls below the value of this parameter. Valid values:**0 to 50**. You can retain the default value.
	//
	// >
	//
	// *   This parameter must be specified when **BackupPolicyMode** is set to **LogBackupPolicy**.
	//
	// *   This parameter takes effect only when **BackupPolicyMode** is set to **LogBackupPolicy**.
	LocalLogRetentionSpace *string `json:"LocalLogRetentionSpace,omitempty" xml:"LocalLogRetentionSpace,omitempty"`
	// The frequency at which you want to back up the logs of the instance. Valid values:
	//
	// *   **LogInterval**: A log backup is performed every 30 minutes.
	// *   The default value is the same as the data backup frequency.
	//
	// >
	//
	// *   The value **LogInterval** is supported only for instances that run SQL Server.
	//
	// *   This parameter takes effect only when **BackupPolicyMode** is set to **DataBackupPolicy**.
	LogBackupFrequency *string `json:"LogBackupFrequency,omitempty" xml:"LogBackupFrequency,omitempty"`
	// The number of binary log files that you want to retain on the instance. Default value: **60**. Valid values: **6** to **100**.
	//
	// >
	//
	// *   This parameter takes effect only when **BackupPolicyMode** is set to **LogBackupPolicy**.
	//
	// *   If the instance runs MySQL, you can set this parameter to \*\*-1\*\*. The value -1 specifies that no limits are imposed on the number of binary log files retained on the instance.
	LogBackupLocalRetentionNumber *int32 `json:"LogBackupLocalRetentionNumber,omitempty" xml:"LogBackupLocalRetentionNumber,omitempty"`
	// The number of days for which the log backup is retained. Valid values: **7 to 730**. The log backup retention period cannot be longer than the data backup retention period.
	//
	// >
	//
	// *   If you enable the log backup feature, you can specify the log backup retention period. This parameter is supported for instances that run MySQL and PostgreSQL.
	//
	// *   This parameter takes effect only when **BackupPolicyMode** is set to **DataBackupPolicy** or **LogBackupPolicy**.
	LogBackupRetentionPeriod *string `json:"LogBackupRetentionPeriod,omitempty" xml:"LogBackupRetentionPeriod,omitempty"`
	OwnerAccount             *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId                  *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The backup cycle. Specify at least two days of the week and separate the days with commas (,). Valid values:
	//
	// *   **Monday**
	// *   **Tuesday**
	// *   **Wednesday**
	// *   **Thursday**
	// *   **Friday**
	// *   **Saturday**
	// *   **Sunday**
	//
	// >
	//
	// *   You can configure a backup policy by using this parameter and the **BackupInterval** parameter. For example, if you set this parameter to Saturday,Sunday and the **BackupInterval** parameter to 30, a backup is performed every 30 minutes on every Saturday and Sunday.
	//
	// *   This parameter must be specified when **BackupPolicyMode** is set to **DataBackupPolicy**.
	//
	// *   This parameter takes effect only when **BackupPolicyMode** is set to **DataBackupPolicy**.
	PreferredBackupPeriod *string `json:"PreferredBackupPeriod,omitempty" xml:"PreferredBackupPeriod,omitempty"`
	// The time at which you want to perform a backup. Specify the time in the ISO 8601 standard in the *HH:mm*Z-*HH:mm*Z format. The time must be in UTC.
	//
	// >
	//
	// *   This parameter must be specified when **BackupPolicyMode** is set to **DataBackupPolicy**.
	//
	// *   This parameter takes effect only when **BackupPolicyMode** is set to **DataBackupPolicy**.
	PreferredBackupTime *string `json:"PreferredBackupTime,omitempty" xml:"PreferredBackupTime,omitempty"`
	// The policy that is used to retain archived backup files if the instance is released. Default value: None. Valid values:
	//
	// *   **None**: No archived backup files are retained.
	// *   **Lastest**: Only the last archived backup file is retained.
	// *   **All**: All archived backup files are retained.
	//
	// > This parameter takes effect only when **BackupPolicyMode** is set to **DataBackupPolicy**.
	ReleasedKeepPolicy   *string `json:"ReleasedKeepPolicy,omitempty" xml:"ReleasedKeepPolicy,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ModifyBackupPolicyRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyBackupPolicyRequest) GoString() string {
	return s.String()
}

func (s *ModifyBackupPolicyRequest) SetArchiveBackupKeepCount(v int32) *ModifyBackupPolicyRequest {
	s.ArchiveBackupKeepCount = &v
	return s
}

func (s *ModifyBackupPolicyRequest) SetArchiveBackupKeepPolicy(v string) *ModifyBackupPolicyRequest {
	s.ArchiveBackupKeepPolicy = &v
	return s
}

func (s *ModifyBackupPolicyRequest) SetArchiveBackupRetentionPeriod(v string) *ModifyBackupPolicyRequest {
	s.ArchiveBackupRetentionPeriod = &v
	return s
}

func (s *ModifyBackupPolicyRequest) SetBackupInterval(v string) *ModifyBackupPolicyRequest {
	s.BackupInterval = &v
	return s
}

func (s *ModifyBackupPolicyRequest) SetBackupLog(v string) *ModifyBackupPolicyRequest {
	s.BackupLog = &v
	return s
}

func (s *ModifyBackupPolicyRequest) SetBackupMethod(v string) *ModifyBackupPolicyRequest {
	s.BackupMethod = &v
	return s
}

func (s *ModifyBackupPolicyRequest) SetBackupPolicyMode(v string) *ModifyBackupPolicyRequest {
	s.BackupPolicyMode = &v
	return s
}

func (s *ModifyBackupPolicyRequest) SetBackupPriority(v int32) *ModifyBackupPolicyRequest {
	s.BackupPriority = &v
	return s
}

func (s *ModifyBackupPolicyRequest) SetBackupRetentionPeriod(v string) *ModifyBackupPolicyRequest {
	s.BackupRetentionPeriod = &v
	return s
}

func (s *ModifyBackupPolicyRequest) SetCategory(v string) *ModifyBackupPolicyRequest {
	s.Category = &v
	return s
}

func (s *ModifyBackupPolicyRequest) SetCompressType(v string) *ModifyBackupPolicyRequest {
	s.CompressType = &v
	return s
}

func (s *ModifyBackupPolicyRequest) SetDBInstanceId(v string) *ModifyBackupPolicyRequest {
	s.DBInstanceId = &v
	return s
}

func (s *ModifyBackupPolicyRequest) SetEnableBackupLog(v string) *ModifyBackupPolicyRequest {
	s.EnableBackupLog = &v
	return s
}

func (s *ModifyBackupPolicyRequest) SetEnableIncrementDataBackup(v bool) *ModifyBackupPolicyRequest {
	s.EnableIncrementDataBackup = &v
	return s
}

func (s *ModifyBackupPolicyRequest) SetHighSpaceUsageProtection(v string) *ModifyBackupPolicyRequest {
	s.HighSpaceUsageProtection = &v
	return s
}

func (s *ModifyBackupPolicyRequest) SetLocalLogRetentionHours(v string) *ModifyBackupPolicyRequest {
	s.LocalLogRetentionHours = &v
	return s
}

func (s *ModifyBackupPolicyRequest) SetLocalLogRetentionSpace(v string) *ModifyBackupPolicyRequest {
	s.LocalLogRetentionSpace = &v
	return s
}

func (s *ModifyBackupPolicyRequest) SetLogBackupFrequency(v string) *ModifyBackupPolicyRequest {
	s.LogBackupFrequency = &v
	return s
}

func (s *ModifyBackupPolicyRequest) SetLogBackupLocalRetentionNumber(v int32) *ModifyBackupPolicyRequest {
	s.LogBackupLocalRetentionNumber = &v
	return s
}

func (s *ModifyBackupPolicyRequest) SetLogBackupRetentionPeriod(v string) *ModifyBackupPolicyRequest {
	s.LogBackupRetentionPeriod = &v
	return s
}

func (s *ModifyBackupPolicyRequest) SetOwnerAccount(v string) *ModifyBackupPolicyRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyBackupPolicyRequest) SetOwnerId(v int64) *ModifyBackupPolicyRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyBackupPolicyRequest) SetPreferredBackupPeriod(v string) *ModifyBackupPolicyRequest {
	s.PreferredBackupPeriod = &v
	return s
}

func (s *ModifyBackupPolicyRequest) SetPreferredBackupTime(v string) *ModifyBackupPolicyRequest {
	s.PreferredBackupTime = &v
	return s
}

func (s *ModifyBackupPolicyRequest) SetReleasedKeepPolicy(v string) *ModifyBackupPolicyRequest {
	s.ReleasedKeepPolicy = &v
	return s
}

func (s *ModifyBackupPolicyRequest) SetResourceOwnerAccount(v string) *ModifyBackupPolicyRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyBackupPolicyRequest) SetResourceOwnerId(v int64) *ModifyBackupPolicyRequest {
	s.ResourceOwnerId = &v
	return s
}

type ModifyBackupPolicyResponseBody struct {
	// The method that is used to compress backups. Valid values:
	//
	// *   **0:** Backups are not compressed.
	// *   **1**: Backups are compressed by using the zlib tool.
	// *   **2**: Backups are compressed in parallel by using the zlib tool.
	// *   **4**: Backups are compressed by using the QuickLZ tool and can be used to restore individual databases and tables.
	// *   **8**: Backups are compressed by using the QuickLZ tool but cannot be used to restore individual databases or tables. This value is supported only for instances that run MySQL 8.0.
	CompressType *string `json:"CompressType,omitempty" xml:"CompressType,omitempty"`
	// The instance ID.
	DBInstanceID *string `json:"DBInstanceID,omitempty" xml:"DBInstanceID,omitempty"`
	// Indicates whether the log backup feature is enabled. Valid values:
	//
	// *   **1**: The feature is enabled.
	// *   **0**: The feature is disabled.
	EnableBackupLog *string `json:"EnableBackupLog,omitempty" xml:"EnableBackupLog,omitempty"`
	// Specifies whether to forcefully delete log backup files from the instance when the storage usage of the instance exceeds 80% or the amount of remaining storage on the instance is less than 5 GB.
	HighSpaceUsageProtection *string `json:"HighSpaceUsageProtection,omitempty" xml:"HighSpaceUsageProtection,omitempty"`
	// The number of hours for which log backup files are retained on the instance.
	LocalLogRetentionHours *int32 `json:"LocalLogRetentionHours,omitempty" xml:"LocalLogRetentionHours,omitempty"`
	// The maximum storage usage that is allowed for log backup files on the instance.
	LocalLogRetentionSpace *string `json:"LocalLogRetentionSpace,omitempty" xml:"LocalLogRetentionSpace,omitempty"`
	// The number of binary log files on the instance.
	LogBackupLocalRetentionNumber *int32 `json:"LogBackupLocalRetentionNumber,omitempty" xml:"LogBackupLocalRetentionNumber,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyBackupPolicyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyBackupPolicyResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyBackupPolicyResponseBody) SetCompressType(v string) *ModifyBackupPolicyResponseBody {
	s.CompressType = &v
	return s
}

func (s *ModifyBackupPolicyResponseBody) SetDBInstanceID(v string) *ModifyBackupPolicyResponseBody {
	s.DBInstanceID = &v
	return s
}

func (s *ModifyBackupPolicyResponseBody) SetEnableBackupLog(v string) *ModifyBackupPolicyResponseBody {
	s.EnableBackupLog = &v
	return s
}

func (s *ModifyBackupPolicyResponseBody) SetHighSpaceUsageProtection(v string) *ModifyBackupPolicyResponseBody {
	s.HighSpaceUsageProtection = &v
	return s
}

func (s *ModifyBackupPolicyResponseBody) SetLocalLogRetentionHours(v int32) *ModifyBackupPolicyResponseBody {
	s.LocalLogRetentionHours = &v
	return s
}

func (s *ModifyBackupPolicyResponseBody) SetLocalLogRetentionSpace(v string) *ModifyBackupPolicyResponseBody {
	s.LocalLogRetentionSpace = &v
	return s
}

func (s *ModifyBackupPolicyResponseBody) SetLogBackupLocalRetentionNumber(v int32) *ModifyBackupPolicyResponseBody {
	s.LogBackupLocalRetentionNumber = &v
	return s
}

func (s *ModifyBackupPolicyResponseBody) SetRequestId(v string) *ModifyBackupPolicyResponseBody {
	s.RequestId = &v
	return s
}

type ModifyBackupPolicyResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyBackupPolicyResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyBackupPolicyResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyBackupPolicyResponse) GoString() string {
	return s.String()
}

func (s *ModifyBackupPolicyResponse) SetHeaders(v map[string]*string) *ModifyBackupPolicyResponse {
	s.Headers = v
	return s
}

func (s *ModifyBackupPolicyResponse) SetStatusCode(v int32) *ModifyBackupPolicyResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyBackupPolicyResponse) SetBody(v *ModifyBackupPolicyResponseBody) *ModifyBackupPolicyResponse {
	s.Body = v
	return s
}

type ModifyCollationTimeZoneRequest struct {
	// The character set collation of the instance. Valid values:
	//
	// *   **Latin1\_General_CI_AS**
	// *   **Latin1\_General_CS_AS**
	// *   **SQL_Latin1\_General_CP1\_CI_AS**
	// *   **SQL_Latin1\_General_CP1\_CS_AS**
	// *   **Chinese_PRC_CS_AS**
	// *   **Chinese_PRC_BIN**
	// *   **Chinese_PRC_CI_AS**
	// *   **Japanese_CI_AS**
	// *   **Japanese_CS_AS**
	// *   **Chinese_Taiwan_Stroke_CI_AS**
	// *   **Chinese_Taiwan_Stroke_CS_AS**
	//
	// By default, the system does not modify the character set collation of the instance.
	//
	// > You must specify one of the **Collation** and **Timezone** parameters.
	Collation *string `json:"Collation,omitempty" xml:"Collation,omitempty"`
	// The ID of the instance.
	DBInstanceId         *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The time zone of the instance. By default, the system does not modify the time zone.
	//
	// > You must specify one of the **Collation** and **Timezone** parameters.
	Timezone *string `json:"Timezone,omitempty" xml:"Timezone,omitempty"`
}

func (s ModifyCollationTimeZoneRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyCollationTimeZoneRequest) GoString() string {
	return s.String()
}

func (s *ModifyCollationTimeZoneRequest) SetCollation(v string) *ModifyCollationTimeZoneRequest {
	s.Collation = &v
	return s
}

func (s *ModifyCollationTimeZoneRequest) SetDBInstanceId(v string) *ModifyCollationTimeZoneRequest {
	s.DBInstanceId = &v
	return s
}

func (s *ModifyCollationTimeZoneRequest) SetOwnerId(v int64) *ModifyCollationTimeZoneRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyCollationTimeZoneRequest) SetResourceOwnerAccount(v string) *ModifyCollationTimeZoneRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyCollationTimeZoneRequest) SetResourceOwnerId(v int64) *ModifyCollationTimeZoneRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ModifyCollationTimeZoneRequest) SetTimezone(v string) *ModifyCollationTimeZoneRequest {
	s.Timezone = &v
	return s
}

type ModifyCollationTimeZoneResponseBody struct {
	// The character set collation of the instance.
	Collation *string `json:"Collation,omitempty" xml:"Collation,omitempty"`
	// The ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the task.
	TaskId *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
	// The time zone of the instance.
	Timezone *string `json:"Timezone,omitempty" xml:"Timezone,omitempty"`
}

func (s ModifyCollationTimeZoneResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyCollationTimeZoneResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyCollationTimeZoneResponseBody) SetCollation(v string) *ModifyCollationTimeZoneResponseBody {
	s.Collation = &v
	return s
}

func (s *ModifyCollationTimeZoneResponseBody) SetDBInstanceId(v string) *ModifyCollationTimeZoneResponseBody {
	s.DBInstanceId = &v
	return s
}

func (s *ModifyCollationTimeZoneResponseBody) SetRequestId(v string) *ModifyCollationTimeZoneResponseBody {
	s.RequestId = &v
	return s
}

func (s *ModifyCollationTimeZoneResponseBody) SetTaskId(v string) *ModifyCollationTimeZoneResponseBody {
	s.TaskId = &v
	return s
}

func (s *ModifyCollationTimeZoneResponseBody) SetTimezone(v string) *ModifyCollationTimeZoneResponseBody {
	s.Timezone = &v
	return s
}

type ModifyCollationTimeZoneResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyCollationTimeZoneResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyCollationTimeZoneResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyCollationTimeZoneResponse) GoString() string {
	return s.String()
}

func (s *ModifyCollationTimeZoneResponse) SetHeaders(v map[string]*string) *ModifyCollationTimeZoneResponse {
	s.Headers = v
	return s
}

func (s *ModifyCollationTimeZoneResponse) SetStatusCode(v int32) *ModifyCollationTimeZoneResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyCollationTimeZoneResponse) SetBody(v *ModifyCollationTimeZoneResponseBody) *ModifyCollationTimeZoneResponse {
	s.Body = v
	return s
}

type ModifyCustinsResourceRequest struct {
	// The deadline for the modification.
	AdjustDeadline *string `json:"AdjustDeadline,omitempty" xml:"AdjustDeadline,omitempty"`
	// The instance ID. You can call the [DescribeDBInstances](~~26232~~) operation to query the instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The increase rate.
	IncreaseRatio   *string `json:"IncreaseRatio,omitempty" xml:"IncreaseRatio,omitempty"`
	ResourceOwnerId *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The resource type.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The original value. This parameter must be specified when **ResourceType** is set to **instance**.
	RestoreOriginalSpecification *string `json:"RestoreOriginalSpecification,omitempty" xml:"RestoreOriginalSpecification,omitempty"`
	// The target value. This parameter is available only if you set the ScalingRuleType parameter to TargetTrackingScalingRule or PredictiveScalingRule. The value must be greater than 0 and can contain up to three decimal places.
	TargetValue *int32 `json:"TargetValue,omitempty" xml:"TargetValue,omitempty"`
}

func (s ModifyCustinsResourceRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyCustinsResourceRequest) GoString() string {
	return s.String()
}

func (s *ModifyCustinsResourceRequest) SetAdjustDeadline(v string) *ModifyCustinsResourceRequest {
	s.AdjustDeadline = &v
	return s
}

func (s *ModifyCustinsResourceRequest) SetDBInstanceId(v string) *ModifyCustinsResourceRequest {
	s.DBInstanceId = &v
	return s
}

func (s *ModifyCustinsResourceRequest) SetIncreaseRatio(v string) *ModifyCustinsResourceRequest {
	s.IncreaseRatio = &v
	return s
}

func (s *ModifyCustinsResourceRequest) SetResourceOwnerId(v int64) *ModifyCustinsResourceRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ModifyCustinsResourceRequest) SetResourceType(v string) *ModifyCustinsResourceRequest {
	s.ResourceType = &v
	return s
}

func (s *ModifyCustinsResourceRequest) SetRestoreOriginalSpecification(v string) *ModifyCustinsResourceRequest {
	s.RestoreOriginalSpecification = &v
	return s
}

func (s *ModifyCustinsResourceRequest) SetTargetValue(v int32) *ModifyCustinsResourceRequest {
	s.TargetValue = &v
	return s
}

type ModifyCustinsResourceResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The task ID.
	TaskId *int32 `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
}

func (s ModifyCustinsResourceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyCustinsResourceResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyCustinsResourceResponseBody) SetRequestId(v string) *ModifyCustinsResourceResponseBody {
	s.RequestId = &v
	return s
}

func (s *ModifyCustinsResourceResponseBody) SetTaskId(v int32) *ModifyCustinsResourceResponseBody {
	s.TaskId = &v
	return s
}

type ModifyCustinsResourceResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyCustinsResourceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyCustinsResourceResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyCustinsResourceResponse) GoString() string {
	return s.String()
}

func (s *ModifyCustinsResourceResponse) SetHeaders(v map[string]*string) *ModifyCustinsResourceResponse {
	s.Headers = v
	return s
}

func (s *ModifyCustinsResourceResponse) SetStatusCode(v int32) *ModifyCustinsResourceResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyCustinsResourceResponse) SetBody(v *ModifyCustinsResourceResponseBody) *ModifyCustinsResourceResponse {
	s.Body = v
	return s
}

type ModifyDBDescriptionRequest struct {
	// The description of the database.
	DBDescription *string `json:"DBDescription,omitempty" xml:"DBDescription,omitempty"`
	// The instance ID. You can call the DescribeDBInstances operation to query the instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The name of the database.
	DBName               *string `json:"DBName,omitempty" xml:"DBName,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ModifyDBDescriptionRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBDescriptionRequest) GoString() string {
	return s.String()
}

func (s *ModifyDBDescriptionRequest) SetDBDescription(v string) *ModifyDBDescriptionRequest {
	s.DBDescription = &v
	return s
}

func (s *ModifyDBDescriptionRequest) SetDBInstanceId(v string) *ModifyDBDescriptionRequest {
	s.DBInstanceId = &v
	return s
}

func (s *ModifyDBDescriptionRequest) SetDBName(v string) *ModifyDBDescriptionRequest {
	s.DBName = &v
	return s
}

func (s *ModifyDBDescriptionRequest) SetOwnerAccount(v string) *ModifyDBDescriptionRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyDBDescriptionRequest) SetOwnerId(v int64) *ModifyDBDescriptionRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyDBDescriptionRequest) SetResourceOwnerAccount(v string) *ModifyDBDescriptionRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyDBDescriptionRequest) SetResourceOwnerId(v int64) *ModifyDBDescriptionRequest {
	s.ResourceOwnerId = &v
	return s
}

type ModifyDBDescriptionResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyDBDescriptionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBDescriptionResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyDBDescriptionResponseBody) SetRequestId(v string) *ModifyDBDescriptionResponseBody {
	s.RequestId = &v
	return s
}

type ModifyDBDescriptionResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyDBDescriptionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyDBDescriptionResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBDescriptionResponse) GoString() string {
	return s.String()
}

func (s *ModifyDBDescriptionResponse) SetHeaders(v map[string]*string) *ModifyDBDescriptionResponse {
	s.Headers = v
	return s
}

func (s *ModifyDBDescriptionResponse) SetStatusCode(v int32) *ModifyDBDescriptionResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyDBDescriptionResponse) SetBody(v *ModifyDBDescriptionResponseBody) *ModifyDBDescriptionResponse {
	s.Body = v
	return s
}

type ModifyDBInstanceAutoUpgradeMinorVersionRequest struct {
	// The method that is used to update the minor engine version of the instance. Valid values:
	//
	// *   **Auto:** automatic update.
	// *   **Manual**: manual update. ApsaraDB RDS automatically updates the current minor engine version of the instance only when the current minor engine version is phased out.
	AutoUpgradeMinorVersion *string `json:"AutoUpgradeMinorVersion,omitempty" xml:"AutoUpgradeMinorVersion,omitempty"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the generated token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the instance.
	DBInstanceId         *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ModifyDBInstanceAutoUpgradeMinorVersionRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBInstanceAutoUpgradeMinorVersionRequest) GoString() string {
	return s.String()
}

func (s *ModifyDBInstanceAutoUpgradeMinorVersionRequest) SetAutoUpgradeMinorVersion(v string) *ModifyDBInstanceAutoUpgradeMinorVersionRequest {
	s.AutoUpgradeMinorVersion = &v
	return s
}

func (s *ModifyDBInstanceAutoUpgradeMinorVersionRequest) SetClientToken(v string) *ModifyDBInstanceAutoUpgradeMinorVersionRequest {
	s.ClientToken = &v
	return s
}

func (s *ModifyDBInstanceAutoUpgradeMinorVersionRequest) SetDBInstanceId(v string) *ModifyDBInstanceAutoUpgradeMinorVersionRequest {
	s.DBInstanceId = &v
	return s
}

func (s *ModifyDBInstanceAutoUpgradeMinorVersionRequest) SetOwnerId(v int64) *ModifyDBInstanceAutoUpgradeMinorVersionRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyDBInstanceAutoUpgradeMinorVersionRequest) SetResourceOwnerAccount(v string) *ModifyDBInstanceAutoUpgradeMinorVersionRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyDBInstanceAutoUpgradeMinorVersionRequest) SetResourceOwnerId(v int64) *ModifyDBInstanceAutoUpgradeMinorVersionRequest {
	s.ResourceOwnerId = &v
	return s
}

type ModifyDBInstanceAutoUpgradeMinorVersionResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyDBInstanceAutoUpgradeMinorVersionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBInstanceAutoUpgradeMinorVersionResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyDBInstanceAutoUpgradeMinorVersionResponseBody) SetRequestId(v string) *ModifyDBInstanceAutoUpgradeMinorVersionResponseBody {
	s.RequestId = &v
	return s
}

type ModifyDBInstanceAutoUpgradeMinorVersionResponse struct {
	Headers    map[string]*string                                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyDBInstanceAutoUpgradeMinorVersionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyDBInstanceAutoUpgradeMinorVersionResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBInstanceAutoUpgradeMinorVersionResponse) GoString() string {
	return s.String()
}

func (s *ModifyDBInstanceAutoUpgradeMinorVersionResponse) SetHeaders(v map[string]*string) *ModifyDBInstanceAutoUpgradeMinorVersionResponse {
	s.Headers = v
	return s
}

func (s *ModifyDBInstanceAutoUpgradeMinorVersionResponse) SetStatusCode(v int32) *ModifyDBInstanceAutoUpgradeMinorVersionResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyDBInstanceAutoUpgradeMinorVersionResponse) SetBody(v *ModifyDBInstanceAutoUpgradeMinorVersionResponseBody) *ModifyDBInstanceAutoUpgradeMinorVersionResponse {
	s.Body = v
	return s
}

type ModifyDBInstanceConfigRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The name of the configuration item that you want to modify.
	//
	// *   **pgbouncer**
	ConfigName *string `json:"ConfigName,omitempty" xml:"ConfigName,omitempty"`
	// The value of the configuration item that you want to modify.
	//
	// *   **true**
	// *   **false**
	ConfigValue *string `json:"ConfigValue,omitempty" xml:"ConfigValue,omitempty"`
	// The instance ID. You can call the [DescribeDBInstances](~~610396~~) operation to query the ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the resource group. You can call the [DescribeDBInstanceAttribute](~~610394~~) operation to obtain the ID of the resource group.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ModifyDBInstanceConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBInstanceConfigRequest) GoString() string {
	return s.String()
}

func (s *ModifyDBInstanceConfigRequest) SetClientToken(v string) *ModifyDBInstanceConfigRequest {
	s.ClientToken = &v
	return s
}

func (s *ModifyDBInstanceConfigRequest) SetConfigName(v string) *ModifyDBInstanceConfigRequest {
	s.ConfigName = &v
	return s
}

func (s *ModifyDBInstanceConfigRequest) SetConfigValue(v string) *ModifyDBInstanceConfigRequest {
	s.ConfigValue = &v
	return s
}

func (s *ModifyDBInstanceConfigRequest) SetDBInstanceId(v string) *ModifyDBInstanceConfigRequest {
	s.DBInstanceId = &v
	return s
}

func (s *ModifyDBInstanceConfigRequest) SetOwnerAccount(v string) *ModifyDBInstanceConfigRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyDBInstanceConfigRequest) SetOwnerId(v int64) *ModifyDBInstanceConfigRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyDBInstanceConfigRequest) SetResourceGroupId(v string) *ModifyDBInstanceConfigRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *ModifyDBInstanceConfigRequest) SetResourceOwnerAccount(v string) *ModifyDBInstanceConfigRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyDBInstanceConfigRequest) SetResourceOwnerId(v int64) *ModifyDBInstanceConfigRequest {
	s.ResourceOwnerId = &v
	return s
}

type ModifyDBInstanceConfigResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyDBInstanceConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBInstanceConfigResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyDBInstanceConfigResponseBody) SetRequestId(v string) *ModifyDBInstanceConfigResponseBody {
	s.RequestId = &v
	return s
}

type ModifyDBInstanceConfigResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyDBInstanceConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyDBInstanceConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBInstanceConfigResponse) GoString() string {
	return s.String()
}

func (s *ModifyDBInstanceConfigResponse) SetHeaders(v map[string]*string) *ModifyDBInstanceConfigResponse {
	s.Headers = v
	return s
}

func (s *ModifyDBInstanceConfigResponse) SetStatusCode(v int32) *ModifyDBInstanceConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyDBInstanceConfigResponse) SetBody(v *ModifyDBInstanceConfigResponseBody) *ModifyDBInstanceConfigResponse {
	s.Body = v
	return s
}

type ModifyDBInstanceConnectionModeRequest struct {
	// The connection mode of the instance. Valid values:
	//
	// *   **Standard**: standard mode
	// *   **Safe**: database proxy mode
	//
	// The system automatically assigns a connection mode to the instance.
	//
	// >  SQL Server 2012, SQL Server 2016, and SQL Server 2017 support only the standard mode.
	ConnectionMode *string `json:"ConnectionMode,omitempty" xml:"ConnectionMode,omitempty"`
	// The ID of the instance.
	DBInstanceId         *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ModifyDBInstanceConnectionModeRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBInstanceConnectionModeRequest) GoString() string {
	return s.String()
}

func (s *ModifyDBInstanceConnectionModeRequest) SetConnectionMode(v string) *ModifyDBInstanceConnectionModeRequest {
	s.ConnectionMode = &v
	return s
}

func (s *ModifyDBInstanceConnectionModeRequest) SetDBInstanceId(v string) *ModifyDBInstanceConnectionModeRequest {
	s.DBInstanceId = &v
	return s
}

func (s *ModifyDBInstanceConnectionModeRequest) SetOwnerAccount(v string) *ModifyDBInstanceConnectionModeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyDBInstanceConnectionModeRequest) SetOwnerId(v int64) *ModifyDBInstanceConnectionModeRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyDBInstanceConnectionModeRequest) SetResourceOwnerAccount(v string) *ModifyDBInstanceConnectionModeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyDBInstanceConnectionModeRequest) SetResourceOwnerId(v int64) *ModifyDBInstanceConnectionModeRequest {
	s.ResourceOwnerId = &v
	return s
}

type ModifyDBInstanceConnectionModeResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyDBInstanceConnectionModeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBInstanceConnectionModeResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyDBInstanceConnectionModeResponseBody) SetRequestId(v string) *ModifyDBInstanceConnectionModeResponseBody {
	s.RequestId = &v
	return s
}

type ModifyDBInstanceConnectionModeResponse struct {
	Headers    map[string]*string                          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyDBInstanceConnectionModeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyDBInstanceConnectionModeResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBInstanceConnectionModeResponse) GoString() string {
	return s.String()
}

func (s *ModifyDBInstanceConnectionModeResponse) SetHeaders(v map[string]*string) *ModifyDBInstanceConnectionModeResponse {
	s.Headers = v
	return s
}

func (s *ModifyDBInstanceConnectionModeResponse) SetStatusCode(v int32) *ModifyDBInstanceConnectionModeResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyDBInstanceConnectionModeResponse) SetBody(v *ModifyDBInstanceConnectionModeResponseBody) *ModifyDBInstanceConnectionModeResponse {
	s.Body = v
	return s
}

type ModifyDBInstanceConnectionStringRequest struct {
	// The Tabular Data Stream (TDS) port of the instance for which Babelfish is enabled.
	//
	// > This parameter applies only to ApsaraDB RDS for PostgreSQL instances. For more information about Babelfish for ApsaraDB RDS for PostgreSQL, see [Introduction to Babelfish](~~428613~~).
	BabelfishPort *string `json:"BabelfishPort,omitempty" xml:"BabelfishPort,omitempty"`
	// The prefix of the endpoint after the change. Only the prefix of the value of **CurrentConnectionString** can be changed.
	//
	// > The value must be 8 to 64 characters in length and can contain letters, digits, and hyphens (-). The value cannot contain any of the following special characters: ! # % ^ & \* = + | {} ; : \" " ,<> / ?
	ConnectionStringPrefix *string `json:"ConnectionStringPrefix,omitempty" xml:"ConnectionStringPrefix,omitempty"`
	// The endpoint of the instance. It can be an internal endpoint, a public endpoint, or a classic network endpoint in hybrid access mode.
	//
	// > The read/write splitting endpoint cannot be changed.
	CurrentConnectionString *string `json:"CurrentConnectionString,omitempty" xml:"CurrentConnectionString,omitempty"`
	// The instance ID. You can call the [DescribeDBInstances](~~610396~~) operation to query the ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The name of the dedicated cluster to which the instance belongs. This parameter is returned only when the instance is created in an ApsaraDB MyBase cluster that runs MySQL on Standard Edition.
	GeneralGroupName *string `json:"GeneralGroupName,omitempty" xml:"GeneralGroupName,omitempty"`
	OwnerAccount     *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId          *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The PgBouncer port.
	//
	// > This parameter is suitable only for ApsaraDB RDS for PostgreSQL instances. If you enable PgBouncer for your instance, you can change the PgBouncer port of the instance.
	PGBouncerPort *string `json:"PGBouncerPort,omitempty" xml:"PGBouncerPort,omitempty"`
	// The port number after the change.
	Port                 *string `json:"Port,omitempty" xml:"Port,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ModifyDBInstanceConnectionStringRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBInstanceConnectionStringRequest) GoString() string {
	return s.String()
}

func (s *ModifyDBInstanceConnectionStringRequest) SetBabelfishPort(v string) *ModifyDBInstanceConnectionStringRequest {
	s.BabelfishPort = &v
	return s
}

func (s *ModifyDBInstanceConnectionStringRequest) SetConnectionStringPrefix(v string) *ModifyDBInstanceConnectionStringRequest {
	s.ConnectionStringPrefix = &v
	return s
}

func (s *ModifyDBInstanceConnectionStringRequest) SetCurrentConnectionString(v string) *ModifyDBInstanceConnectionStringRequest {
	s.CurrentConnectionString = &v
	return s
}

func (s *ModifyDBInstanceConnectionStringRequest) SetDBInstanceId(v string) *ModifyDBInstanceConnectionStringRequest {
	s.DBInstanceId = &v
	return s
}

func (s *ModifyDBInstanceConnectionStringRequest) SetGeneralGroupName(v string) *ModifyDBInstanceConnectionStringRequest {
	s.GeneralGroupName = &v
	return s
}

func (s *ModifyDBInstanceConnectionStringRequest) SetOwnerAccount(v string) *ModifyDBInstanceConnectionStringRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyDBInstanceConnectionStringRequest) SetOwnerId(v int64) *ModifyDBInstanceConnectionStringRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyDBInstanceConnectionStringRequest) SetPGBouncerPort(v string) *ModifyDBInstanceConnectionStringRequest {
	s.PGBouncerPort = &v
	return s
}

func (s *ModifyDBInstanceConnectionStringRequest) SetPort(v string) *ModifyDBInstanceConnectionStringRequest {
	s.Port = &v
	return s
}

func (s *ModifyDBInstanceConnectionStringRequest) SetResourceOwnerAccount(v string) *ModifyDBInstanceConnectionStringRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyDBInstanceConnectionStringRequest) SetResourceOwnerId(v int64) *ModifyDBInstanceConnectionStringRequest {
	s.ResourceOwnerId = &v
	return s
}

type ModifyDBInstanceConnectionStringResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyDBInstanceConnectionStringResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBInstanceConnectionStringResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyDBInstanceConnectionStringResponseBody) SetRequestId(v string) *ModifyDBInstanceConnectionStringResponseBody {
	s.RequestId = &v
	return s
}

type ModifyDBInstanceConnectionStringResponse struct {
	Headers    map[string]*string                            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyDBInstanceConnectionStringResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyDBInstanceConnectionStringResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBInstanceConnectionStringResponse) GoString() string {
	return s.String()
}

func (s *ModifyDBInstanceConnectionStringResponse) SetHeaders(v map[string]*string) *ModifyDBInstanceConnectionStringResponse {
	s.Headers = v
	return s
}

func (s *ModifyDBInstanceConnectionStringResponse) SetStatusCode(v int32) *ModifyDBInstanceConnectionStringResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyDBInstanceConnectionStringResponse) SetBody(v *ModifyDBInstanceConnectionStringResponseBody) *ModifyDBInstanceConnectionStringResponse {
	s.Body = v
	return s
}

type ModifyDBInstanceDelayedReplicationTimeRequest struct {
	// The ID of the instance. You can call the [DescribeDBInstances](~~26232~~) operation to query the ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The replication latency of the read-only instance. Unit: seconds.
	ReadSQLReplicationTime *string `json:"ReadSQLReplicationTime,omitempty" xml:"ReadSQLReplicationTime,omitempty"`
	ResourceOwnerAccount   *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId        *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ModifyDBInstanceDelayedReplicationTimeRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBInstanceDelayedReplicationTimeRequest) GoString() string {
	return s.String()
}

func (s *ModifyDBInstanceDelayedReplicationTimeRequest) SetDBInstanceId(v string) *ModifyDBInstanceDelayedReplicationTimeRequest {
	s.DBInstanceId = &v
	return s
}

func (s *ModifyDBInstanceDelayedReplicationTimeRequest) SetOwnerId(v int64) *ModifyDBInstanceDelayedReplicationTimeRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyDBInstanceDelayedReplicationTimeRequest) SetReadSQLReplicationTime(v string) *ModifyDBInstanceDelayedReplicationTimeRequest {
	s.ReadSQLReplicationTime = &v
	return s
}

func (s *ModifyDBInstanceDelayedReplicationTimeRequest) SetResourceOwnerAccount(v string) *ModifyDBInstanceDelayedReplicationTimeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyDBInstanceDelayedReplicationTimeRequest) SetResourceOwnerId(v int64) *ModifyDBInstanceDelayedReplicationTimeRequest {
	s.ResourceOwnerId = &v
	return s
}

type ModifyDBInstanceDelayedReplicationTimeResponseBody struct {
	// The ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The replication latency of the read-only instance. Unit: seconds.
	ReadSQLReplicationTime *string `json:"ReadSQLReplicationTime,omitempty" xml:"ReadSQLReplicationTime,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the task.
	TaskId *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
}

func (s ModifyDBInstanceDelayedReplicationTimeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBInstanceDelayedReplicationTimeResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyDBInstanceDelayedReplicationTimeResponseBody) SetDBInstanceId(v string) *ModifyDBInstanceDelayedReplicationTimeResponseBody {
	s.DBInstanceId = &v
	return s
}

func (s *ModifyDBInstanceDelayedReplicationTimeResponseBody) SetReadSQLReplicationTime(v string) *ModifyDBInstanceDelayedReplicationTimeResponseBody {
	s.ReadSQLReplicationTime = &v
	return s
}

func (s *ModifyDBInstanceDelayedReplicationTimeResponseBody) SetRequestId(v string) *ModifyDBInstanceDelayedReplicationTimeResponseBody {
	s.RequestId = &v
	return s
}

func (s *ModifyDBInstanceDelayedReplicationTimeResponseBody) SetTaskId(v string) *ModifyDBInstanceDelayedReplicationTimeResponseBody {
	s.TaskId = &v
	return s
}

type ModifyDBInstanceDelayedReplicationTimeResponse struct {
	Headers    map[string]*string                                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyDBInstanceDelayedReplicationTimeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyDBInstanceDelayedReplicationTimeResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBInstanceDelayedReplicationTimeResponse) GoString() string {
	return s.String()
}

func (s *ModifyDBInstanceDelayedReplicationTimeResponse) SetHeaders(v map[string]*string) *ModifyDBInstanceDelayedReplicationTimeResponse {
	s.Headers = v
	return s
}

func (s *ModifyDBInstanceDelayedReplicationTimeResponse) SetStatusCode(v int32) *ModifyDBInstanceDelayedReplicationTimeResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyDBInstanceDelayedReplicationTimeResponse) SetBody(v *ModifyDBInstanceDelayedReplicationTimeResponseBody) *ModifyDBInstanceDelayedReplicationTimeResponse {
	s.Body = v
	return s
}

type ModifyDBInstanceDeletionProtectionRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the generated token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the instance. You can call the [DescribeDBInstances](~~26232~~) operation to query the ID of the instance.
	//
	// >
	//
	// *   Before you call the DescribeDBInstances operation, make sure that your instance is one of the following instances:
	//
	//     *   The instance runs MySQL.
	//     *   The instance runs PostgreSQL.
	//     *   The instance runs MariaDB.
	//
	// *   The instance is a pay-as-you-go instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// Specifies whether to enable the release protection feature for the read-only instance. Valid values:
	//
	// *   **true**
	// *   **false**
	DeletionProtection   *bool   `json:"DeletionProtection,omitempty" xml:"DeletionProtection,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ModifyDBInstanceDeletionProtectionRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBInstanceDeletionProtectionRequest) GoString() string {
	return s.String()
}

func (s *ModifyDBInstanceDeletionProtectionRequest) SetClientToken(v string) *ModifyDBInstanceDeletionProtectionRequest {
	s.ClientToken = &v
	return s
}

func (s *ModifyDBInstanceDeletionProtectionRequest) SetDBInstanceId(v string) *ModifyDBInstanceDeletionProtectionRequest {
	s.DBInstanceId = &v
	return s
}

func (s *ModifyDBInstanceDeletionProtectionRequest) SetDeletionProtection(v bool) *ModifyDBInstanceDeletionProtectionRequest {
	s.DeletionProtection = &v
	return s
}

func (s *ModifyDBInstanceDeletionProtectionRequest) SetOwnerAccount(v string) *ModifyDBInstanceDeletionProtectionRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyDBInstanceDeletionProtectionRequest) SetOwnerId(v int64) *ModifyDBInstanceDeletionProtectionRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyDBInstanceDeletionProtectionRequest) SetResourceOwnerAccount(v string) *ModifyDBInstanceDeletionProtectionRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyDBInstanceDeletionProtectionRequest) SetResourceOwnerId(v int64) *ModifyDBInstanceDeletionProtectionRequest {
	s.ResourceOwnerId = &v
	return s
}

type ModifyDBInstanceDeletionProtectionResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyDBInstanceDeletionProtectionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBInstanceDeletionProtectionResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyDBInstanceDeletionProtectionResponseBody) SetRequestId(v string) *ModifyDBInstanceDeletionProtectionResponseBody {
	s.RequestId = &v
	return s
}

type ModifyDBInstanceDeletionProtectionResponse struct {
	Headers    map[string]*string                              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyDBInstanceDeletionProtectionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyDBInstanceDeletionProtectionResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBInstanceDeletionProtectionResponse) GoString() string {
	return s.String()
}

func (s *ModifyDBInstanceDeletionProtectionResponse) SetHeaders(v map[string]*string) *ModifyDBInstanceDeletionProtectionResponse {
	s.Headers = v
	return s
}

func (s *ModifyDBInstanceDeletionProtectionResponse) SetStatusCode(v int32) *ModifyDBInstanceDeletionProtectionResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyDBInstanceDeletionProtectionResponse) SetBody(v *ModifyDBInstanceDeletionProtectionResponseBody) *ModifyDBInstanceDeletionProtectionResponse {
	s.Body = v
	return s
}

type ModifyDBInstanceDescriptionRequest struct {
	// The name of the instance.
	//
	// > The name must be 2 to 64 characters in length.
	DBInstanceDescription *string `json:"DBInstanceDescription,omitempty" xml:"DBInstanceDescription,omitempty"`
	// The ID of the instance.
	DBInstanceId         *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ModifyDBInstanceDescriptionRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBInstanceDescriptionRequest) GoString() string {
	return s.String()
}

func (s *ModifyDBInstanceDescriptionRequest) SetDBInstanceDescription(v string) *ModifyDBInstanceDescriptionRequest {
	s.DBInstanceDescription = &v
	return s
}

func (s *ModifyDBInstanceDescriptionRequest) SetDBInstanceId(v string) *ModifyDBInstanceDescriptionRequest {
	s.DBInstanceId = &v
	return s
}

func (s *ModifyDBInstanceDescriptionRequest) SetOwnerAccount(v string) *ModifyDBInstanceDescriptionRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyDBInstanceDescriptionRequest) SetOwnerId(v int64) *ModifyDBInstanceDescriptionRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyDBInstanceDescriptionRequest) SetResourceOwnerAccount(v string) *ModifyDBInstanceDescriptionRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyDBInstanceDescriptionRequest) SetResourceOwnerId(v int64) *ModifyDBInstanceDescriptionRequest {
	s.ResourceOwnerId = &v
	return s
}

type ModifyDBInstanceDescriptionResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyDBInstanceDescriptionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBInstanceDescriptionResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyDBInstanceDescriptionResponseBody) SetRequestId(v string) *ModifyDBInstanceDescriptionResponseBody {
	s.RequestId = &v
	return s
}

type ModifyDBInstanceDescriptionResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyDBInstanceDescriptionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyDBInstanceDescriptionResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBInstanceDescriptionResponse) GoString() string {
	return s.String()
}

func (s *ModifyDBInstanceDescriptionResponse) SetHeaders(v map[string]*string) *ModifyDBInstanceDescriptionResponse {
	s.Headers = v
	return s
}

func (s *ModifyDBInstanceDescriptionResponse) SetStatusCode(v int32) *ModifyDBInstanceDescriptionResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyDBInstanceDescriptionResponse) SetBody(v *ModifyDBInstanceDescriptionResponseBody) *ModifyDBInstanceDescriptionResponse {
	s.Body = v
	return s
}

type ModifyDBInstanceEndpointRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests.
	//
	// The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The user-defined description of the endpoint.
	DBInstanceEndpointDescription *string `json:"DBInstanceEndpointDescription,omitempty" xml:"DBInstanceEndpointDescription,omitempty"`
	// The endpoint ID of the instance. You can call the [DescribeDBInstanceEndpoints](~~610488~~) operation to query the endpoint ID of the instance.
	DBInstanceEndpointId *string `json:"DBInstanceEndpointId,omitempty" xml:"DBInstanceEndpointId,omitempty"`
	// The instance ID. You can call the [DescribeDBInstances](~~610396~~) operation to query the ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The information about the node that is configured for the endpoint.
	NodeItems       []*ModifyDBInstanceEndpointRequestNodeItems `json:"NodeItems,omitempty" xml:"NodeItems,omitempty" type:"Repeated"`
	ResourceOwnerId *int64                                      `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ModifyDBInstanceEndpointRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBInstanceEndpointRequest) GoString() string {
	return s.String()
}

func (s *ModifyDBInstanceEndpointRequest) SetClientToken(v string) *ModifyDBInstanceEndpointRequest {
	s.ClientToken = &v
	return s
}

func (s *ModifyDBInstanceEndpointRequest) SetDBInstanceEndpointDescription(v string) *ModifyDBInstanceEndpointRequest {
	s.DBInstanceEndpointDescription = &v
	return s
}

func (s *ModifyDBInstanceEndpointRequest) SetDBInstanceEndpointId(v string) *ModifyDBInstanceEndpointRequest {
	s.DBInstanceEndpointId = &v
	return s
}

func (s *ModifyDBInstanceEndpointRequest) SetDBInstanceId(v string) *ModifyDBInstanceEndpointRequest {
	s.DBInstanceId = &v
	return s
}

func (s *ModifyDBInstanceEndpointRequest) SetNodeItems(v []*ModifyDBInstanceEndpointRequestNodeItems) *ModifyDBInstanceEndpointRequest {
	s.NodeItems = v
	return s
}

func (s *ModifyDBInstanceEndpointRequest) SetResourceOwnerId(v int64) *ModifyDBInstanceEndpointRequest {
	s.ResourceOwnerId = &v
	return s
}

type ModifyDBInstanceEndpointRequestNodeItems struct {
	// The instance ID. You can call the [DescribeDBInstances](~~610396~~) operation to query the ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The node ID.
	//
	// You can use one of the following methods to query the ID of the node:
	//
	// *   Log on to the ApsaraDB RDS console, go to the instance details page, and then view the ID of the node in the instance topology section.
	// *   Call the [DescribeDBInstanceAttribute](~~610394~~) operation to query the ID of the node.
	NodeId *string `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	// The weight of the node. Read requests are distributed based on the weight.
	//
	// Valid values: 0 to 100.
	Weight *int64 `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s ModifyDBInstanceEndpointRequestNodeItems) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBInstanceEndpointRequestNodeItems) GoString() string {
	return s.String()
}

func (s *ModifyDBInstanceEndpointRequestNodeItems) SetDBInstanceId(v string) *ModifyDBInstanceEndpointRequestNodeItems {
	s.DBInstanceId = &v
	return s
}

func (s *ModifyDBInstanceEndpointRequestNodeItems) SetNodeId(v string) *ModifyDBInstanceEndpointRequestNodeItems {
	s.NodeId = &v
	return s
}

func (s *ModifyDBInstanceEndpointRequestNodeItems) SetWeight(v int64) *ModifyDBInstanceEndpointRequestNodeItems {
	s.Weight = &v
	return s
}

type ModifyDBInstanceEndpointShrinkRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests.
	//
	// The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The user-defined description of the endpoint.
	DBInstanceEndpointDescription *string `json:"DBInstanceEndpointDescription,omitempty" xml:"DBInstanceEndpointDescription,omitempty"`
	// The endpoint ID of the instance. You can call the [DescribeDBInstanceEndpoints](~~610488~~) operation to query the endpoint ID of the instance.
	DBInstanceEndpointId *string `json:"DBInstanceEndpointId,omitempty" xml:"DBInstanceEndpointId,omitempty"`
	// The instance ID. You can call the [DescribeDBInstances](~~610396~~) operation to query the ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The information about the node that is configured for the endpoint.
	NodeItemsShrink *string `json:"NodeItems,omitempty" xml:"NodeItems,omitempty"`
	ResourceOwnerId *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ModifyDBInstanceEndpointShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBInstanceEndpointShrinkRequest) GoString() string {
	return s.String()
}

func (s *ModifyDBInstanceEndpointShrinkRequest) SetClientToken(v string) *ModifyDBInstanceEndpointShrinkRequest {
	s.ClientToken = &v
	return s
}

func (s *ModifyDBInstanceEndpointShrinkRequest) SetDBInstanceEndpointDescription(v string) *ModifyDBInstanceEndpointShrinkRequest {
	s.DBInstanceEndpointDescription = &v
	return s
}

func (s *ModifyDBInstanceEndpointShrinkRequest) SetDBInstanceEndpointId(v string) *ModifyDBInstanceEndpointShrinkRequest {
	s.DBInstanceEndpointId = &v
	return s
}

func (s *ModifyDBInstanceEndpointShrinkRequest) SetDBInstanceId(v string) *ModifyDBInstanceEndpointShrinkRequest {
	s.DBInstanceId = &v
	return s
}

func (s *ModifyDBInstanceEndpointShrinkRequest) SetNodeItemsShrink(v string) *ModifyDBInstanceEndpointShrinkRequest {
	s.NodeItemsShrink = &v
	return s
}

func (s *ModifyDBInstanceEndpointShrinkRequest) SetResourceOwnerId(v int64) *ModifyDBInstanceEndpointShrinkRequest {
	s.ResourceOwnerId = &v
	return s
}

type ModifyDBInstanceEndpointResponseBody struct {
	// The returned data.
	Data *ModifyDBInstanceEndpointResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyDBInstanceEndpointResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBInstanceEndpointResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyDBInstanceEndpointResponseBody) SetData(v *ModifyDBInstanceEndpointResponseBodyData) *ModifyDBInstanceEndpointResponseBody {
	s.Data = v
	return s
}

func (s *ModifyDBInstanceEndpointResponseBody) SetRequestId(v string) *ModifyDBInstanceEndpointResponseBody {
	s.RequestId = &v
	return s
}

type ModifyDBInstanceEndpointResponseBodyData struct {
	// The endpoint ID of the instance.
	DBInstanceEndpointId *string `json:"DBInstanceEndpointId,omitempty" xml:"DBInstanceEndpointId,omitempty"`
	// The ID of the instance.
	DBInstanceName *string `json:"DBInstanceName,omitempty" xml:"DBInstanceName,omitempty"`
}

func (s ModifyDBInstanceEndpointResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBInstanceEndpointResponseBodyData) GoString() string {
	return s.String()
}

func (s *ModifyDBInstanceEndpointResponseBodyData) SetDBInstanceEndpointId(v string) *ModifyDBInstanceEndpointResponseBodyData {
	s.DBInstanceEndpointId = &v
	return s
}

func (s *ModifyDBInstanceEndpointResponseBodyData) SetDBInstanceName(v string) *ModifyDBInstanceEndpointResponseBodyData {
	s.DBInstanceName = &v
	return s
}

type ModifyDBInstanceEndpointResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyDBInstanceEndpointResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyDBInstanceEndpointResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBInstanceEndpointResponse) GoString() string {
	return s.String()
}

func (s *ModifyDBInstanceEndpointResponse) SetHeaders(v map[string]*string) *ModifyDBInstanceEndpointResponse {
	s.Headers = v
	return s
}

func (s *ModifyDBInstanceEndpointResponse) SetStatusCode(v int32) *ModifyDBInstanceEndpointResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyDBInstanceEndpointResponse) SetBody(v *ModifyDBInstanceEndpointResponseBody) *ModifyDBInstanceEndpointResponse {
	s.Body = v
	return s
}

type ModifyDBInstanceEndpointAddressRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests.
	//
	// The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The endpoint that you want to modify. The endpoint can be a public endpoint or an internal endpoint.
	ConnectionString *string `json:"ConnectionString,omitempty" xml:"ConnectionString,omitempty"`
	// The prefix of the new endpoint. You can modify only the prefix of the endpoint that is specified by the ConnectionString parameter.
	ConnectionStringPrefix *string `json:"ConnectionStringPrefix,omitempty" xml:"ConnectionStringPrefix,omitempty"`
	// The endpoint ID of the instance. You can call the [DescribeDBInstanceEndpoints](~~610488~~) operation to query the endpoint ID of the instance.
	DBInstanceEndpointId *string `json:"DBInstanceEndpointId,omitempty" xml:"DBInstanceEndpointId,omitempty"`
	// The instance ID. You can call the [DescribeDBInstances](~~610396~~) operation to query the ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The port number of the new endpoint.
	Port *string `json:"Port,omitempty" xml:"Port,omitempty"`
	// The IP address of the internal endpoint.
	PrivateIpAddress *string `json:"PrivateIpAddress,omitempty" xml:"PrivateIpAddress,omitempty"`
	ResourceOwnerId  *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The vSwitch ID of the internal endpoint.
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
	// The VPC ID of the internal endpoint.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s ModifyDBInstanceEndpointAddressRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBInstanceEndpointAddressRequest) GoString() string {
	return s.String()
}

func (s *ModifyDBInstanceEndpointAddressRequest) SetClientToken(v string) *ModifyDBInstanceEndpointAddressRequest {
	s.ClientToken = &v
	return s
}

func (s *ModifyDBInstanceEndpointAddressRequest) SetConnectionString(v string) *ModifyDBInstanceEndpointAddressRequest {
	s.ConnectionString = &v
	return s
}

func (s *ModifyDBInstanceEndpointAddressRequest) SetConnectionStringPrefix(v string) *ModifyDBInstanceEndpointAddressRequest {
	s.ConnectionStringPrefix = &v
	return s
}

func (s *ModifyDBInstanceEndpointAddressRequest) SetDBInstanceEndpointId(v string) *ModifyDBInstanceEndpointAddressRequest {
	s.DBInstanceEndpointId = &v
	return s
}

func (s *ModifyDBInstanceEndpointAddressRequest) SetDBInstanceId(v string) *ModifyDBInstanceEndpointAddressRequest {
	s.DBInstanceId = &v
	return s
}

func (s *ModifyDBInstanceEndpointAddressRequest) SetPort(v string) *ModifyDBInstanceEndpointAddressRequest {
	s.Port = &v
	return s
}

func (s *ModifyDBInstanceEndpointAddressRequest) SetPrivateIpAddress(v string) *ModifyDBInstanceEndpointAddressRequest {
	s.PrivateIpAddress = &v
	return s
}

func (s *ModifyDBInstanceEndpointAddressRequest) SetResourceOwnerId(v int64) *ModifyDBInstanceEndpointAddressRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ModifyDBInstanceEndpointAddressRequest) SetVSwitchId(v string) *ModifyDBInstanceEndpointAddressRequest {
	s.VSwitchId = &v
	return s
}

func (s *ModifyDBInstanceEndpointAddressRequest) SetVpcId(v string) *ModifyDBInstanceEndpointAddressRequest {
	s.VpcId = &v
	return s
}

type ModifyDBInstanceEndpointAddressResponseBody struct {
	// The data returned.
	Data *ModifyDBInstanceEndpointAddressResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyDBInstanceEndpointAddressResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBInstanceEndpointAddressResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyDBInstanceEndpointAddressResponseBody) SetData(v *ModifyDBInstanceEndpointAddressResponseBodyData) *ModifyDBInstanceEndpointAddressResponseBody {
	s.Data = v
	return s
}

func (s *ModifyDBInstanceEndpointAddressResponseBody) SetRequestId(v string) *ModifyDBInstanceEndpointAddressResponseBody {
	s.RequestId = &v
	return s
}

type ModifyDBInstanceEndpointAddressResponseBodyData struct {
	// The endpoint ID of the instance.
	DBInstanceEndpointId *string `json:"DBInstanceEndpointId,omitempty" xml:"DBInstanceEndpointId,omitempty"`
	// The ID of the instance.
	DBInstanceName *string `json:"DBInstanceName,omitempty" xml:"DBInstanceName,omitempty"`
}

func (s ModifyDBInstanceEndpointAddressResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBInstanceEndpointAddressResponseBodyData) GoString() string {
	return s.String()
}

func (s *ModifyDBInstanceEndpointAddressResponseBodyData) SetDBInstanceEndpointId(v string) *ModifyDBInstanceEndpointAddressResponseBodyData {
	s.DBInstanceEndpointId = &v
	return s
}

func (s *ModifyDBInstanceEndpointAddressResponseBodyData) SetDBInstanceName(v string) *ModifyDBInstanceEndpointAddressResponseBodyData {
	s.DBInstanceName = &v
	return s
}

type ModifyDBInstanceEndpointAddressResponse struct {
	Headers    map[string]*string                           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyDBInstanceEndpointAddressResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyDBInstanceEndpointAddressResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBInstanceEndpointAddressResponse) GoString() string {
	return s.String()
}

func (s *ModifyDBInstanceEndpointAddressResponse) SetHeaders(v map[string]*string) *ModifyDBInstanceEndpointAddressResponse {
	s.Headers = v
	return s
}

func (s *ModifyDBInstanceEndpointAddressResponse) SetStatusCode(v int32) *ModifyDBInstanceEndpointAddressResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyDBInstanceEndpointAddressResponse) SetBody(v *ModifyDBInstanceEndpointAddressResponseBody) *ModifyDBInstanceEndpointAddressResponse {
	s.Body = v
	return s
}

type ModifyDBInstanceHAConfigRequest struct {
	// The ID of the instance.
	DbInstanceId *string `json:"DbInstanceId,omitempty" xml:"DbInstanceId,omitempty"`
	// The HA mode of the instance.
	//
	// *   RPO: Data consistency is preferred. The instance ensures data reliability to minimize data losses. If you have high requirements on data consistency, select this mode.
	// *   RTO: Service availability is preferred. The instance restores the database service at the earliest opportunity to ensure service availability. If you have high requirements for service availability, select this mode.
	HAMode               *string `json:"HAMode,omitempty" xml:"HAMode,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The data replication mode of the instance. For more information, see [Data replication mode](~~96055~~).
	//
	// *   Semi-sync: the semi-synchronous mode.
	// *   Sync: the synchronous mode.
	// *   gAsyncg: the asynchronous mode.
	// *   Mgr: the MySQL group replication (MGR) mode. This mode is available only for the China site (aliyun.com).
	//
	// > This parameter is not supported for instances that run SQL Server 2017 on RDS Cluster Edition.
	SyncMode *string `json:"SyncMode,omitempty" xml:"SyncMode,omitempty"`
}

func (s ModifyDBInstanceHAConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBInstanceHAConfigRequest) GoString() string {
	return s.String()
}

func (s *ModifyDBInstanceHAConfigRequest) SetDbInstanceId(v string) *ModifyDBInstanceHAConfigRequest {
	s.DbInstanceId = &v
	return s
}

func (s *ModifyDBInstanceHAConfigRequest) SetHAMode(v string) *ModifyDBInstanceHAConfigRequest {
	s.HAMode = &v
	return s
}

func (s *ModifyDBInstanceHAConfigRequest) SetOwnerAccount(v string) *ModifyDBInstanceHAConfigRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyDBInstanceHAConfigRequest) SetOwnerId(v int64) *ModifyDBInstanceHAConfigRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyDBInstanceHAConfigRequest) SetResourceOwnerAccount(v string) *ModifyDBInstanceHAConfigRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyDBInstanceHAConfigRequest) SetResourceOwnerId(v int64) *ModifyDBInstanceHAConfigRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ModifyDBInstanceHAConfigRequest) SetSyncMode(v string) *ModifyDBInstanceHAConfigRequest {
	s.SyncMode = &v
	return s
}

type ModifyDBInstanceHAConfigResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyDBInstanceHAConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBInstanceHAConfigResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyDBInstanceHAConfigResponseBody) SetRequestId(v string) *ModifyDBInstanceHAConfigResponseBody {
	s.RequestId = &v
	return s
}

type ModifyDBInstanceHAConfigResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyDBInstanceHAConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyDBInstanceHAConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBInstanceHAConfigResponse) GoString() string {
	return s.String()
}

func (s *ModifyDBInstanceHAConfigResponse) SetHeaders(v map[string]*string) *ModifyDBInstanceHAConfigResponse {
	s.Headers = v
	return s
}

func (s *ModifyDBInstanceHAConfigResponse) SetStatusCode(v int32) *ModifyDBInstanceHAConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyDBInstanceHAConfigResponse) SetBody(v *ModifyDBInstanceHAConfigResponseBody) *ModifyDBInstanceHAConfigResponse {
	s.Body = v
	return s
}

type ModifyDBInstanceMaintainTimeRequest struct {
	// The client token that is used to ensure the idempotency of requests. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The maintenance time of the instance. Specify the time in the ISO 8601 standard in the *HH:mm*Z-*HH:mm*Z format. The time must be in UTC.
	MaintainTime         *string `json:"MaintainTime,omitempty" xml:"MaintainTime,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ModifyDBInstanceMaintainTimeRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBInstanceMaintainTimeRequest) GoString() string {
	return s.String()
}

func (s *ModifyDBInstanceMaintainTimeRequest) SetClientToken(v string) *ModifyDBInstanceMaintainTimeRequest {
	s.ClientToken = &v
	return s
}

func (s *ModifyDBInstanceMaintainTimeRequest) SetDBInstanceId(v string) *ModifyDBInstanceMaintainTimeRequest {
	s.DBInstanceId = &v
	return s
}

func (s *ModifyDBInstanceMaintainTimeRequest) SetMaintainTime(v string) *ModifyDBInstanceMaintainTimeRequest {
	s.MaintainTime = &v
	return s
}

func (s *ModifyDBInstanceMaintainTimeRequest) SetOwnerAccount(v string) *ModifyDBInstanceMaintainTimeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyDBInstanceMaintainTimeRequest) SetOwnerId(v int64) *ModifyDBInstanceMaintainTimeRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyDBInstanceMaintainTimeRequest) SetResourceOwnerAccount(v string) *ModifyDBInstanceMaintainTimeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyDBInstanceMaintainTimeRequest) SetResourceOwnerId(v int64) *ModifyDBInstanceMaintainTimeRequest {
	s.ResourceOwnerId = &v
	return s
}

type ModifyDBInstanceMaintainTimeResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyDBInstanceMaintainTimeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBInstanceMaintainTimeResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyDBInstanceMaintainTimeResponseBody) SetRequestId(v string) *ModifyDBInstanceMaintainTimeResponseBody {
	s.RequestId = &v
	return s
}

type ModifyDBInstanceMaintainTimeResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyDBInstanceMaintainTimeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyDBInstanceMaintainTimeResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBInstanceMaintainTimeResponse) GoString() string {
	return s.String()
}

func (s *ModifyDBInstanceMaintainTimeResponse) SetHeaders(v map[string]*string) *ModifyDBInstanceMaintainTimeResponse {
	s.Headers = v
	return s
}

func (s *ModifyDBInstanceMaintainTimeResponse) SetStatusCode(v int32) *ModifyDBInstanceMaintainTimeResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyDBInstanceMaintainTimeResponse) SetBody(v *ModifyDBInstanceMaintainTimeResponseBody) *ModifyDBInstanceMaintainTimeResponse {
	s.Body = v
	return s
}

type ModifyDBInstanceMetricsRequest struct {
	// The instance ID. You can call the [DescribeDBInstances](~~26232~~) operation to query the instance ID.
	DBInstanceName *string `json:"DBInstanceName,omitempty" xml:"DBInstanceName,omitempty"`
	// The keys of the Enhanced Monitoring metrics that you want to display for the instance. You can enter a maximum of 30 metric keys. If you enter multiple metric keys, you must separate the metric keys with commas (,).
	//
	// You can call the [DescribeAvailableMetrics](~~314326~~) operation to query the keys of metrics.
	MetricsConfig   *string `json:"MetricsConfig,omitempty" xml:"MetricsConfig,omitempty"`
	ResourceOwnerId *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The application scope of this modification. Valid values:
	//
	// *   **instance**: This modification is applied only to the current instance.
	// *   **region**: This modification is applied to all ApsaraDB RDS for PostgreSQL instances that are equipped with the same type of storage media as the current instance in the region to which the current instance belongs. For example, if the current instance is equipped with cloud disks, this modification is applied to all ApsaraDB RDS for PostgreSQL instances that are equipped with cloud disks in the region to which the current instance belongs.
	Scope *string `json:"Scope,omitempty" xml:"Scope,omitempty"`
}

func (s ModifyDBInstanceMetricsRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBInstanceMetricsRequest) GoString() string {
	return s.String()
}

func (s *ModifyDBInstanceMetricsRequest) SetDBInstanceName(v string) *ModifyDBInstanceMetricsRequest {
	s.DBInstanceName = &v
	return s
}

func (s *ModifyDBInstanceMetricsRequest) SetMetricsConfig(v string) *ModifyDBInstanceMetricsRequest {
	s.MetricsConfig = &v
	return s
}

func (s *ModifyDBInstanceMetricsRequest) SetResourceOwnerId(v int64) *ModifyDBInstanceMetricsRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ModifyDBInstanceMetricsRequest) SetScope(v string) *ModifyDBInstanceMetricsRequest {
	s.Scope = &v
	return s
}

type ModifyDBInstanceMetricsResponseBody struct {
	// The instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The application scope of this modification. Valid values:
	//
	// *   **instance**: This modification is applied only to the current instance.
	// *   **region**: This modification is applied to all ApsaraDB RDS for PostgreSQL instances that are equipped with the same type of storage media as the current instance in the region to which the current instance belongs.
	Scope *string `json:"Scope,omitempty" xml:"Scope,omitempty"`
}

func (s ModifyDBInstanceMetricsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBInstanceMetricsResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyDBInstanceMetricsResponseBody) SetDBInstanceId(v string) *ModifyDBInstanceMetricsResponseBody {
	s.DBInstanceId = &v
	return s
}

func (s *ModifyDBInstanceMetricsResponseBody) SetRequestId(v string) *ModifyDBInstanceMetricsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ModifyDBInstanceMetricsResponseBody) SetScope(v string) *ModifyDBInstanceMetricsResponseBody {
	s.Scope = &v
	return s
}

type ModifyDBInstanceMetricsResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyDBInstanceMetricsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyDBInstanceMetricsResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBInstanceMetricsResponse) GoString() string {
	return s.String()
}

func (s *ModifyDBInstanceMetricsResponse) SetHeaders(v map[string]*string) *ModifyDBInstanceMetricsResponse {
	s.Headers = v
	return s
}

func (s *ModifyDBInstanceMetricsResponse) SetStatusCode(v int32) *ModifyDBInstanceMetricsResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyDBInstanceMetricsResponse) SetBody(v *ModifyDBInstanceMetricsResponseBody) *ModifyDBInstanceMetricsResponse {
	s.Body = v
	return s
}

type ModifyDBInstanceMonitorRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The instance ID. You can call the DescribeDBInstances operation to query the instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The monitoring frequency that you want to use. Valid values:
	//
	// *   **5**
	// *   **10**
	// *   **60**
	// *   **300**
	//
	// Unit: seconds.
	Period               *string `json:"Period,omitempty" xml:"Period,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ModifyDBInstanceMonitorRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBInstanceMonitorRequest) GoString() string {
	return s.String()
}

func (s *ModifyDBInstanceMonitorRequest) SetClientToken(v string) *ModifyDBInstanceMonitorRequest {
	s.ClientToken = &v
	return s
}

func (s *ModifyDBInstanceMonitorRequest) SetDBInstanceId(v string) *ModifyDBInstanceMonitorRequest {
	s.DBInstanceId = &v
	return s
}

func (s *ModifyDBInstanceMonitorRequest) SetOwnerAccount(v string) *ModifyDBInstanceMonitorRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyDBInstanceMonitorRequest) SetOwnerId(v int64) *ModifyDBInstanceMonitorRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyDBInstanceMonitorRequest) SetPeriod(v string) *ModifyDBInstanceMonitorRequest {
	s.Period = &v
	return s
}

func (s *ModifyDBInstanceMonitorRequest) SetResourceOwnerAccount(v string) *ModifyDBInstanceMonitorRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyDBInstanceMonitorRequest) SetResourceOwnerId(v int64) *ModifyDBInstanceMonitorRequest {
	s.ResourceOwnerId = &v
	return s
}

type ModifyDBInstanceMonitorResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyDBInstanceMonitorResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBInstanceMonitorResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyDBInstanceMonitorResponseBody) SetRequestId(v string) *ModifyDBInstanceMonitorResponseBody {
	s.RequestId = &v
	return s
}

type ModifyDBInstanceMonitorResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyDBInstanceMonitorResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyDBInstanceMonitorResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBInstanceMonitorResponse) GoString() string {
	return s.String()
}

func (s *ModifyDBInstanceMonitorResponse) SetHeaders(v map[string]*string) *ModifyDBInstanceMonitorResponse {
	s.Headers = v
	return s
}

func (s *ModifyDBInstanceMonitorResponse) SetStatusCode(v int32) *ModifyDBInstanceMonitorResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyDBInstanceMonitorResponse) SetBody(v *ModifyDBInstanceMonitorResponseBody) *ModifyDBInstanceMonitorResponse {
	s.Body = v
	return s
}

type ModifyDBInstanceNetworkExpireTimeRequest struct {
	// The retention days of the classic network endpoint. Valid values: **1 to 120**. Unit: days.
	ClassicExpiredDays *int32 `json:"ClassicExpiredDays,omitempty" xml:"ClassicExpiredDays,omitempty"`
	// The classic network endpoint whose expiration time you want to extend. Two types of classic network endpoints are supported:
	//
	// *   The internal endpoint of the classic network.
	// *   The read/write splitting endpoint of the classic network.
	ConnectionString *string `json:"ConnectionString,omitempty" xml:"ConnectionString,omitempty"`
	// The ID of the instance.
	DBInstanceId         *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ModifyDBInstanceNetworkExpireTimeRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBInstanceNetworkExpireTimeRequest) GoString() string {
	return s.String()
}

func (s *ModifyDBInstanceNetworkExpireTimeRequest) SetClassicExpiredDays(v int32) *ModifyDBInstanceNetworkExpireTimeRequest {
	s.ClassicExpiredDays = &v
	return s
}

func (s *ModifyDBInstanceNetworkExpireTimeRequest) SetConnectionString(v string) *ModifyDBInstanceNetworkExpireTimeRequest {
	s.ConnectionString = &v
	return s
}

func (s *ModifyDBInstanceNetworkExpireTimeRequest) SetDBInstanceId(v string) *ModifyDBInstanceNetworkExpireTimeRequest {
	s.DBInstanceId = &v
	return s
}

func (s *ModifyDBInstanceNetworkExpireTimeRequest) SetOwnerAccount(v string) *ModifyDBInstanceNetworkExpireTimeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyDBInstanceNetworkExpireTimeRequest) SetOwnerId(v int64) *ModifyDBInstanceNetworkExpireTimeRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyDBInstanceNetworkExpireTimeRequest) SetResourceOwnerAccount(v string) *ModifyDBInstanceNetworkExpireTimeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyDBInstanceNetworkExpireTimeRequest) SetResourceOwnerId(v int64) *ModifyDBInstanceNetworkExpireTimeRequest {
	s.ResourceOwnerId = &v
	return s
}

type ModifyDBInstanceNetworkExpireTimeResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyDBInstanceNetworkExpireTimeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBInstanceNetworkExpireTimeResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyDBInstanceNetworkExpireTimeResponseBody) SetRequestId(v string) *ModifyDBInstanceNetworkExpireTimeResponseBody {
	s.RequestId = &v
	return s
}

type ModifyDBInstanceNetworkExpireTimeResponse struct {
	Headers    map[string]*string                             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyDBInstanceNetworkExpireTimeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyDBInstanceNetworkExpireTimeResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBInstanceNetworkExpireTimeResponse) GoString() string {
	return s.String()
}

func (s *ModifyDBInstanceNetworkExpireTimeResponse) SetHeaders(v map[string]*string) *ModifyDBInstanceNetworkExpireTimeResponse {
	s.Headers = v
	return s
}

func (s *ModifyDBInstanceNetworkExpireTimeResponse) SetStatusCode(v int32) *ModifyDBInstanceNetworkExpireTimeResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyDBInstanceNetworkExpireTimeResponse) SetBody(v *ModifyDBInstanceNetworkExpireTimeResponseBody) *ModifyDBInstanceNetworkExpireTimeResponse {
	s.Body = v
	return s
}

type ModifyDBInstanceNetworkTypeRequest struct {
	// The number of days for which you want to retain the classic network endpoint. Valid values: **1 to 120**. Default value: **7**.
	//
	// > If you set the **RetainClassic** parameter to **True**, you must also specify this parameter.
	ClassicExpiredDays *string `json:"ClassicExpiredDays,omitempty" xml:"ClassicExpiredDays,omitempty"`
	// The instance ID. You can call the [DescribeDBInstances](~~610396~~) operation to query the ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The network type after the modification. Set the value to **VPC**.
	InstanceNetworkType *string `json:"InstanceNetworkType,omitempty" xml:"InstanceNetworkType,omitempty"`
	OwnerAccount        *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId             *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The internal IP address of the instance. The internal IP address must be within the CIDR block supported by the specified vSwitch. The system automatically assigns a private IP address to an instance based on the values of **VPCId** and **VSwitchId**.
	PrivateIpAddress *string `json:"PrivateIpAddress,omitempty" xml:"PrivateIpAddress,omitempty"`
	// The number of days for which you want to retain the read/write splitting endpoint of the classic network type. Valid values: **1 to 120**. Default value: **7**.
	//
	// >  This parameter takes effect only when a read/write splitting endpoint of the classic network type exists and the **RetainClassic** parameter is set to **True**.
	ReadWriteSplittingClassicExpiredDays *int32 `json:"ReadWriteSplittingClassicExpiredDays,omitempty" xml:"ReadWriteSplittingClassicExpiredDays,omitempty"`
	// The internal IP address that corresponds to the read/write splitting endpoint of the instance. The internal IP address must be within the CIDR block supported by the specified vSwitch. The system automatically assigns a private IP address to an instance based on the values of **VPCId** and **VSwitchId**.
	//
	// >  This parameter is valid when a read/write splitting endpoint of the classic network type exists.
	ReadWriteSplittingPrivateIpAddress *string `json:"ReadWriteSplittingPrivateIpAddress,omitempty" xml:"ReadWriteSplittingPrivateIpAddress,omitempty"`
	ResourceOwnerAccount               *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId                    *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// Specifies whether to retain the classic network endpoint. Valid values:
	//
	// *   **True**: retains the classic network endpoint.
	// *   **False** (default): does not retain the classic network endpoint.
	RetainClassic *string `json:"RetainClassic,omitempty" xml:"RetainClassic,omitempty"`
	// The VPC ID.
	VPCId *string `json:"VPCId,omitempty" xml:"VPCId,omitempty"`
	// The ID of the vSwitch. This parameter is required if the **VPCId** parameter is specified.
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
}

func (s ModifyDBInstanceNetworkTypeRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBInstanceNetworkTypeRequest) GoString() string {
	return s.String()
}

func (s *ModifyDBInstanceNetworkTypeRequest) SetClassicExpiredDays(v string) *ModifyDBInstanceNetworkTypeRequest {
	s.ClassicExpiredDays = &v
	return s
}

func (s *ModifyDBInstanceNetworkTypeRequest) SetDBInstanceId(v string) *ModifyDBInstanceNetworkTypeRequest {
	s.DBInstanceId = &v
	return s
}

func (s *ModifyDBInstanceNetworkTypeRequest) SetInstanceNetworkType(v string) *ModifyDBInstanceNetworkTypeRequest {
	s.InstanceNetworkType = &v
	return s
}

func (s *ModifyDBInstanceNetworkTypeRequest) SetOwnerAccount(v string) *ModifyDBInstanceNetworkTypeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyDBInstanceNetworkTypeRequest) SetOwnerId(v int64) *ModifyDBInstanceNetworkTypeRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyDBInstanceNetworkTypeRequest) SetPrivateIpAddress(v string) *ModifyDBInstanceNetworkTypeRequest {
	s.PrivateIpAddress = &v
	return s
}

func (s *ModifyDBInstanceNetworkTypeRequest) SetReadWriteSplittingClassicExpiredDays(v int32) *ModifyDBInstanceNetworkTypeRequest {
	s.ReadWriteSplittingClassicExpiredDays = &v
	return s
}

func (s *ModifyDBInstanceNetworkTypeRequest) SetReadWriteSplittingPrivateIpAddress(v string) *ModifyDBInstanceNetworkTypeRequest {
	s.ReadWriteSplittingPrivateIpAddress = &v
	return s
}

func (s *ModifyDBInstanceNetworkTypeRequest) SetResourceOwnerAccount(v string) *ModifyDBInstanceNetworkTypeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyDBInstanceNetworkTypeRequest) SetResourceOwnerId(v int64) *ModifyDBInstanceNetworkTypeRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ModifyDBInstanceNetworkTypeRequest) SetRetainClassic(v string) *ModifyDBInstanceNetworkTypeRequest {
	s.RetainClassic = &v
	return s
}

func (s *ModifyDBInstanceNetworkTypeRequest) SetVPCId(v string) *ModifyDBInstanceNetworkTypeRequest {
	s.VPCId = &v
	return s
}

func (s *ModifyDBInstanceNetworkTypeRequest) SetVSwitchId(v string) *ModifyDBInstanceNetworkTypeRequest {
	s.VSwitchId = &v
	return s
}

type ModifyDBInstanceNetworkTypeResponseBody struct {
	// The endpoint that is used to connect to the instance.
	ConnectionString *string `json:"ConnectionString,omitempty" xml:"ConnectionString,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the task.
	TaskId *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
}

func (s ModifyDBInstanceNetworkTypeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBInstanceNetworkTypeResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyDBInstanceNetworkTypeResponseBody) SetConnectionString(v string) *ModifyDBInstanceNetworkTypeResponseBody {
	s.ConnectionString = &v
	return s
}

func (s *ModifyDBInstanceNetworkTypeResponseBody) SetRequestId(v string) *ModifyDBInstanceNetworkTypeResponseBody {
	s.RequestId = &v
	return s
}

func (s *ModifyDBInstanceNetworkTypeResponseBody) SetTaskId(v string) *ModifyDBInstanceNetworkTypeResponseBody {
	s.TaskId = &v
	return s
}

type ModifyDBInstanceNetworkTypeResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyDBInstanceNetworkTypeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyDBInstanceNetworkTypeResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBInstanceNetworkTypeResponse) GoString() string {
	return s.String()
}

func (s *ModifyDBInstanceNetworkTypeResponse) SetHeaders(v map[string]*string) *ModifyDBInstanceNetworkTypeResponse {
	s.Headers = v
	return s
}

func (s *ModifyDBInstanceNetworkTypeResponse) SetStatusCode(v int32) *ModifyDBInstanceNetworkTypeResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyDBInstanceNetworkTypeResponse) SetBody(v *ModifyDBInstanceNetworkTypeResponseBody) *ModifyDBInstanceNetworkTypeResponse {
	s.Body = v
	return s
}

type ModifyDBInstancePayTypeRequest struct {
	// The ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The billing method of the instance. Valid values:
	//
	// *   Postpaid: pay-as-you-go
	// *   Prepaid: subscription
	PayType *string `json:"PayType,omitempty" xml:"PayType,omitempty"`
	// The subscription method of the instance. This parameter must be specified when PayType is set to Prepaid.
	//
	// *   Year
	// *   Month
	Period          *string `json:"Period,omitempty" xml:"Period,omitempty"`
	ResourceOwnerId *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// Valid values when Period is set to Year: 1 to 9. Valid values when Period is set to Month: 1, 2, and 3.
	UsedTime *int32 `json:"UsedTime,omitempty" xml:"UsedTime,omitempty"`
}

func (s ModifyDBInstancePayTypeRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBInstancePayTypeRequest) GoString() string {
	return s.String()
}

func (s *ModifyDBInstancePayTypeRequest) SetDBInstanceId(v string) *ModifyDBInstancePayTypeRequest {
	s.DBInstanceId = &v
	return s
}

func (s *ModifyDBInstancePayTypeRequest) SetPayType(v string) *ModifyDBInstancePayTypeRequest {
	s.PayType = &v
	return s
}

func (s *ModifyDBInstancePayTypeRequest) SetPeriod(v string) *ModifyDBInstancePayTypeRequest {
	s.Period = &v
	return s
}

func (s *ModifyDBInstancePayTypeRequest) SetResourceOwnerId(v int64) *ModifyDBInstancePayTypeRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ModifyDBInstancePayTypeRequest) SetUsedTime(v int32) *ModifyDBInstancePayTypeRequest {
	s.UsedTime = &v
	return s
}

type ModifyDBInstancePayTypeResponseBody struct {
	// The ID of the order.
	OrderId *int64 `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
}

func (s ModifyDBInstancePayTypeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBInstancePayTypeResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyDBInstancePayTypeResponseBody) SetOrderId(v int64) *ModifyDBInstancePayTypeResponseBody {
	s.OrderId = &v
	return s
}

type ModifyDBInstancePayTypeResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyDBInstancePayTypeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyDBInstancePayTypeResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBInstancePayTypeResponse) GoString() string {
	return s.String()
}

func (s *ModifyDBInstancePayTypeResponse) SetHeaders(v map[string]*string) *ModifyDBInstancePayTypeResponse {
	s.Headers = v
	return s
}

func (s *ModifyDBInstancePayTypeResponse) SetStatusCode(v int32) *ModifyDBInstancePayTypeResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyDBInstancePayTypeResponse) SetBody(v *ModifyDBInstancePayTypeResponseBody) *ModifyDBInstancePayTypeResponse {
	s.Body = v
	return s
}

type ModifyDBInstanceProxyConfigurationRequest struct {
	// The ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The key of the **configuration item** for the database proxy. Valid values:
	//
	// *   **TransparentSwitch**: transparent switchover
	// *   **PersistentConnections**: short-lived connection optimization
	// *   **AttacksProtection**: brute-force attack protection
	ProxyConfigurationKey *string `json:"ProxyConfigurationKey,omitempty" xml:"ProxyConfigurationKey,omitempty"`
	// The features and status of the database proxy:
	//
	// *   **TransparentSwitch**: transparent switchover. Valid values:
	//
	//     *   **Enable**: The feature is enabled. This is the default value.
	//     *   **Disable**: The feature is disabled.
	//
	// *   **PersistentConnections**: short-lived connection optimization. Valid values:
	//
	//     *   **Enable**: The feature is enabled.
	//     *   **Disable**: The feature is disabled. This is the default value.
	//
	// *   **AttacksProtection**: brute-force attack protection. Valid values:
	//
	//     *   **Enable**: The feature is enabled.
	//     *   **Disable**: The feature is disabled. This is the default value.
	//
	// Format: {"Feature 1":"Status 1","Feature 2":"Status 2"...}
	ProxyConfigurationValue *string `json:"ProxyConfigurationValue,omitempty" xml:"ProxyConfigurationValue,omitempty"`
	ResourceOwnerAccount    *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId         *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ModifyDBInstanceProxyConfigurationRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBInstanceProxyConfigurationRequest) GoString() string {
	return s.String()
}

func (s *ModifyDBInstanceProxyConfigurationRequest) SetDBInstanceId(v string) *ModifyDBInstanceProxyConfigurationRequest {
	s.DBInstanceId = &v
	return s
}

func (s *ModifyDBInstanceProxyConfigurationRequest) SetOwnerId(v int64) *ModifyDBInstanceProxyConfigurationRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyDBInstanceProxyConfigurationRequest) SetProxyConfigurationKey(v string) *ModifyDBInstanceProxyConfigurationRequest {
	s.ProxyConfigurationKey = &v
	return s
}

func (s *ModifyDBInstanceProxyConfigurationRequest) SetProxyConfigurationValue(v string) *ModifyDBInstanceProxyConfigurationRequest {
	s.ProxyConfigurationValue = &v
	return s
}

func (s *ModifyDBInstanceProxyConfigurationRequest) SetResourceOwnerAccount(v string) *ModifyDBInstanceProxyConfigurationRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyDBInstanceProxyConfigurationRequest) SetResourceOwnerId(v int64) *ModifyDBInstanceProxyConfigurationRequest {
	s.ResourceOwnerId = &v
	return s
}

type ModifyDBInstanceProxyConfigurationResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyDBInstanceProxyConfigurationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBInstanceProxyConfigurationResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyDBInstanceProxyConfigurationResponseBody) SetRequestId(v string) *ModifyDBInstanceProxyConfigurationResponseBody {
	s.RequestId = &v
	return s
}

type ModifyDBInstanceProxyConfigurationResponse struct {
	Headers    map[string]*string                              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyDBInstanceProxyConfigurationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyDBInstanceProxyConfigurationResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBInstanceProxyConfigurationResponse) GoString() string {
	return s.String()
}

func (s *ModifyDBInstanceProxyConfigurationResponse) SetHeaders(v map[string]*string) *ModifyDBInstanceProxyConfigurationResponse {
	s.Headers = v
	return s
}

func (s *ModifyDBInstanceProxyConfigurationResponse) SetStatusCode(v int32) *ModifyDBInstanceProxyConfigurationResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyDBInstanceProxyConfigurationResponse) SetBody(v *ModifyDBInstanceProxyConfigurationResponseBody) *ModifyDBInstanceProxyConfigurationResponse {
	s.Body = v
	return s
}

type ModifyDBInstanceSSLRequest struct {
	// The method that is used to verify the identities of clients. This parameter is supported only when the instance runs PostgreSQL with cloud disks. In addition, this parameter is available only when the public key of the CA that issues client certificates is enabled. Valid values:
	//
	// *   **cert**
	// *   **perfer**
	// *   **verify-ca**
	// *   **verify-full** (supported only when the instance runs PostgreSQL 12 or later)
	ACL *string `json:"ACL,omitempty" xml:"ACL,omitempty"`
	// The type of the server certificate. This parameter is supported only when the instance runs PostgreSQL with cloud disks. If you set SSLEnabled to **1**, the default value of this parameter is **aliyun**. Valid values:
	//
	// *   **aliyun**: a cloud certificate
	// *   **custom**: a custom certificate
	CAType *string `json:"CAType,omitempty" xml:"CAType,omitempty"`
	// The public key of the CA that issues client certificates. This parameter is supported only when the instance runs PostgreSQL with cloud disks. This parameter must be specified when ClientCAEbabled is set to **1**.
	ClientCACert *string `json:"ClientCACert,omitempty" xml:"ClientCACert,omitempty"`
	// Specifies whether to enable the public key of the CA that issues client certificates. This parameter is supported only when the instance runs PostgreSQL with cloud disks. Valid values:
	//
	// *   **1**: enables the public key.
	// *   **0**: disables the public key.
	ClientCAEnabled *int32 `json:"ClientCAEnabled,omitempty" xml:"ClientCAEnabled,omitempty"`
	// The CRL that contains revoked client certificates. This parameter is supported only when the instance runs PostgreSQL with cloud disks. This parameter must be specified when ClientCrlEnabled is set to **1**.
	ClientCertRevocationList *string `json:"ClientCertRevocationList,omitempty" xml:"ClientCertRevocationList,omitempty"`
	// Specifies whether to enable a certificate revocation list (CRL) that contains revoked client certificates. This parameter is supported only when the instance runs PostgreSQL with cloud disks. In addition, this parameter is available only when the public key of the CA that issues client certificates is enabled. Valid values:
	//
	// *   **1**: enables the CRL.
	// *   **0**: disables the CRL.
	ClientCrlEnabled *int32 `json:"ClientCrlEnabled,omitempty" xml:"ClientCrlEnabled,omitempty"`
	// The internal or public endpoint for which the server certificate needs to be created or updated.
	ConnectionString *string `json:"ConnectionString,omitempty" xml:"ConnectionString,omitempty"`
	// The instance ID. You can call the DescribeDBInstances operation to query the instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The method that is used to verify the replication permission. This parameter is supported only when the instance runs PostgreSQL with cloud disks. In addition, this parameter is available only when the public key of the CA that issues client certificates is enabled. Valid values:
	//
	// *   **cert**
	// *   **perfer**
	// *   **verify-ca**
	// *   **verify-full** (supported only when the instance runs PostgreSQL 12 or later)
	ReplicationACL       *string `json:"ReplicationACL,omitempty" xml:"ReplicationACL,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// Specifies whether to enable or disable the SSL encryption feature. Valid values:
	//
	// *   **1**: enables the feature.
	// *   **0**: disables the feature.
	SSLEnabled *int32 `json:"SSLEnabled,omitempty" xml:"SSLEnabled,omitempty"`
	// The content of the server certificate. This parameter is supported only when the instance runs PostgreSQL with cloud disks. This parameter must be specified when CAType is set to **custom**.
	ServerCert *string `json:"ServerCert,omitempty" xml:"ServerCert,omitempty"`
	// The private key of the server certificate. This parameter is supported only when the instance runs PostgreSQL with cloud disks. This parameter must be specified when CAType is set to **custom**.
	ServerKey *string `json:"ServerKey,omitempty" xml:"ServerKey,omitempty"`
}

func (s ModifyDBInstanceSSLRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBInstanceSSLRequest) GoString() string {
	return s.String()
}

func (s *ModifyDBInstanceSSLRequest) SetACL(v string) *ModifyDBInstanceSSLRequest {
	s.ACL = &v
	return s
}

func (s *ModifyDBInstanceSSLRequest) SetCAType(v string) *ModifyDBInstanceSSLRequest {
	s.CAType = &v
	return s
}

func (s *ModifyDBInstanceSSLRequest) SetClientCACert(v string) *ModifyDBInstanceSSLRequest {
	s.ClientCACert = &v
	return s
}

func (s *ModifyDBInstanceSSLRequest) SetClientCAEnabled(v int32) *ModifyDBInstanceSSLRequest {
	s.ClientCAEnabled = &v
	return s
}

func (s *ModifyDBInstanceSSLRequest) SetClientCertRevocationList(v string) *ModifyDBInstanceSSLRequest {
	s.ClientCertRevocationList = &v
	return s
}

func (s *ModifyDBInstanceSSLRequest) SetClientCrlEnabled(v int32) *ModifyDBInstanceSSLRequest {
	s.ClientCrlEnabled = &v
	return s
}

func (s *ModifyDBInstanceSSLRequest) SetConnectionString(v string) *ModifyDBInstanceSSLRequest {
	s.ConnectionString = &v
	return s
}

func (s *ModifyDBInstanceSSLRequest) SetDBInstanceId(v string) *ModifyDBInstanceSSLRequest {
	s.DBInstanceId = &v
	return s
}

func (s *ModifyDBInstanceSSLRequest) SetOwnerAccount(v string) *ModifyDBInstanceSSLRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyDBInstanceSSLRequest) SetOwnerId(v int64) *ModifyDBInstanceSSLRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyDBInstanceSSLRequest) SetReplicationACL(v string) *ModifyDBInstanceSSLRequest {
	s.ReplicationACL = &v
	return s
}

func (s *ModifyDBInstanceSSLRequest) SetResourceOwnerAccount(v string) *ModifyDBInstanceSSLRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyDBInstanceSSLRequest) SetResourceOwnerId(v int64) *ModifyDBInstanceSSLRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ModifyDBInstanceSSLRequest) SetSSLEnabled(v int32) *ModifyDBInstanceSSLRequest {
	s.SSLEnabled = &v
	return s
}

func (s *ModifyDBInstanceSSLRequest) SetServerCert(v string) *ModifyDBInstanceSSLRequest {
	s.ServerCert = &v
	return s
}

func (s *ModifyDBInstanceSSLRequest) SetServerKey(v string) *ModifyDBInstanceSSLRequest {
	s.ServerKey = &v
	return s
}

type ModifyDBInstanceSSLResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyDBInstanceSSLResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBInstanceSSLResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyDBInstanceSSLResponseBody) SetRequestId(v string) *ModifyDBInstanceSSLResponseBody {
	s.RequestId = &v
	return s
}

type ModifyDBInstanceSSLResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyDBInstanceSSLResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyDBInstanceSSLResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBInstanceSSLResponse) GoString() string {
	return s.String()
}

func (s *ModifyDBInstanceSSLResponse) SetHeaders(v map[string]*string) *ModifyDBInstanceSSLResponse {
	s.Headers = v
	return s
}

func (s *ModifyDBInstanceSSLResponse) SetStatusCode(v int32) *ModifyDBInstanceSSLResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyDBInstanceSSLResponse) SetBody(v *ModifyDBInstanceSSLResponseBody) *ModifyDBInstanceSSLResponse {
	s.Body = v
	return s
}

type ModifyDBInstanceSpecRequest struct {
	// Specifies whether to use vouchers to offset fees. Valid values:
	//
	// *   **true**
	// *   **false** (default)
	AutoUseCoupon *bool `json:"AutoUseCoupon,omitempty" xml:"AutoUseCoupon,omitempty"`
	// An invalid parameter. You do not need to specify this parameter.
	BurstingEnabled *bool `json:"BurstingEnabled,omitempty" xml:"BurstingEnabled,omitempty"`
	// The RDS edition of the instance. Valid values:
	//
	// *   Regular RDS instance
	//
	//     *   **Basic**: RDS Basic Edition
	//     *   **HighAvailability**: RDS High-availability Edition
	//     *   **AlwaysOn**: RDS Cluster Edition for ApsaraDB RDS for SQL Server
	//     *   **Cluster**: RDS Cluster Edition for ApsaraDB RDS for MySQL.
	//
	// *   Serverless instance
	//
	//     *   **serverless_basic**: RDS Basic Edition. This edition is available only for serverless instances that run MySQL and PostgreSQL.
	//     *   **serverless_standard**: RDS High-availability Edition for ApsaraDB RDS for MySQL.
	//     *   **serverless_ha**: RDS High-availability Edition for ApsaraDB RDS for SQL Server.
	//
	//     **
	//
	//     **Note** If you set the **EngineVersion** parameter to an SQL Server version number, you must also specify this parameter.
	Category *string `json:"Category,omitempty" xml:"Category,omitempty"`
	// The new instance type of the instance. For more information, see [Primary ApsaraDB RDS instance types](~~26312~~). You can also call the [DescribeAvailableClasses](~~610393~~) operation to query the instance types that are supported by an instance.
	//
	// - You must specify at least one of DBInstanceClass and **DBInstanceStorage**.
	// - You can call the [DescribeDBInstanceAttribute](~~610394~~) operation to query the current instance type of the instance.
	DBInstanceClass *string `json:"DBInstanceClass,omitempty" xml:"DBInstanceClass,omitempty"`
	// The instance ID. You can call the [DescribeDBInstances](~~610396~~) operation to query the ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The new storage capacity of the instance. Unit: GB. You can increase the storage capacity in increments of 5 GB. For more information, see [Primary ApsaraDB RDS instance types](~~26312~~). You can call the [DescribeAvailableClasses](~~610393~~) operation to query the storage capacity range that is supported by the new instance type.
	//
	// *   You must specify at least one of the DBInstanceStorage and **DBInstanceClass** parameters.
	// *   You can call the [DescribeDBInstanceAttribute](~~610394~~) operation to query the current storage capacity of the instance.
	DBInstanceStorage *int32 `json:"DBInstanceStorage,omitempty" xml:"DBInstanceStorage,omitempty"`
	// The storage type of the instance. Valid values:
	//
	// *   **local_ssd**: local SSD.
	// *   **cloud_ssd**: standard SSD. This storage type is not recommended and is unavailable in some Alibaba Cloud regions.
	// *   **cloud_essd**: enhanced SSD (ESSD) of performance level 1 (PL1).
	// *   **cloud_essd2**: ESSDs of PL2.
	// *   **cloud_essd3**: ESSD of PL3.
	//
	// To change the storage type, take note of the following items:
	//
	// If the instance runs PostgreSQL, you can upgrade the storage type of the instance from standard SSD to ESSD. However, you cannot downgrade the storage type of the instance from ESSD to standard SSD. ESSDs provide the following PLs: PL1, PL2, and PL3. You can upgrade or downgrade the storage type between ESSD of PL1, ESSD of PL2, and ESSD of PL3. For more information, see [Configuration items](~~96750~~).
	DBInstanceStorageType *string `json:"DBInstanceStorageType,omitempty" xml:"DBInstanceStorageType,omitempty"`
	// The ID of the dedicated cluster.
	DedicatedHostGroupId *string `json:"DedicatedHostGroupId,omitempty" xml:"DedicatedHostGroupId,omitempty"`
	// The type of change that you want to perform on the instance. Valid values:
	//
	// *   **Up** (default): upgrades a subscription instance, or upgrades or downgrades a pay-as-you-go instance.
	// *   **Down**: downgrades a subscription instance.
	// *   **TempUpgrade**: performs auto scaling on a subscription instance that runs SQL Server. This value is required for auto scaling.
	// *   **Serverless**: modifies the auto scaling settings of a serverless instance. This value is required if you want to modify the auto scaling settings of a serverless instance.
	//
	// >  If you specify only **DBInstanceStorageType**, you can leave Direction empty. For example, if you want to change only the storage type of the instance from standard SSD to ESSD, you do not need to specify Direction.
	Direction *string `json:"Direction,omitempty" xml:"Direction,omitempty"`
	// The time when you want the change to take effect. Valid values:
	//
	// *   **Immediate**: This is the default value.
	// *   **MaintainTime**: The effective time is within the maintenance window. For more information, see [ModifyDBInstanceMaintainTime](~~610402~~).
	EffectiveTime *string `json:"EffectiveTime,omitempty" xml:"EffectiveTime,omitempty"`
	// The database engine version of the instance.
	//
	// *   Regular instance
	//
	//     *   Valid values if you set Engine to MySQL: **5.5**, **5.6**, **5.7**, and **8.0**
	//     *   Valid values if you set Engine to SQLServer: **2008r2**, **08r2\_ent_ha**, **2012**, **2012\_ent_ha**, **2012\_std_ha**, **2012\_web**, **2014\_std_ha**, **2016\_ent_ha**, **2016\_std_ha**, **2016\_web**, **2017\_std_ha**, **2017\_ent**, **2019\_std_ha**, and **2019\_ent**
	//     *   Valid values if you set Engine to PostgreSQL: **10.0**, **11.0**, **12.0**, **13.0**, **14.0**, and **15.0**
	//     *   Valid value if you set Engine to MariaDB: **10.3**
	//
	// *   Serverless instance
	//
	//     *   Valid values if you set Engine to MySQL: **5.7** and **8.0**
	//     *   Valid values if you set Engine to SQLServer: **2016\_std_sl**, **2017\_std_sl**, and **2019\_std_sl**
	//     *   Valid value if you set Engine to PostgreSQL: **14.0**
	//
	//     **
	//
	//     **Note**ApsaraDB RDS for MariaDB does not support serverless instances.
	EngineVersion *string `json:"EngineVersion,omitempty" xml:"EngineVersion,omitempty"`
	OwnerAccount  *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The billing method of the instance. Valid values:
	//
	// *   **Postpaid**: pay-as-you-go.
	// *   **Prepaid**: subscription.
	// *   **Serverless**: serverless. This value is not supported for instances that run MariaDB. If you set the value to Serverless, you must specify the scaling range of computing resources, configure the automatic start and stop feature, and configure auto scaling policies for your serverless instance. For more information, see [Overview of serverless ApsaraDB RDS for MySQL instances](~~411291~~), [Overview of serverless ApsaraDB RDS for SQL Server instances](~~604344~~), and [Overview of serverless ApsaraDB RDS for PostgreSQL instances](~~607742~~).
	PayType *string `json:"PayType,omitempty" xml:"PayType,omitempty"`
	// The ID of the resource group.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The serverless instance on which you want to perform the specification change.
	ServerlessConfiguration *ModifyDBInstanceSpecRequestServerlessConfiguration `json:"ServerlessConfiguration,omitempty" xml:"ServerlessConfiguration,omitempty" type:"Struct"`
	// A deprecated parameter. You do not need to specify this parameter.
	SourceBiz *string `json:"SourceBiz,omitempty" xml:"SourceBiz,omitempty"`
	// The response parameters.
	SwitchTime *string `json:"SwitchTime,omitempty" xml:"SwitchTime,omitempty"`
	// The number of the minor version.
	//
	// This parameter is required only for instances that run PostgreSQL. If the minor engine version does not support changing the instance type, you must specify the minor engine version to update the minor engine version when you change the instance type.
	//
	// Format: `rds_postgres_<Major engine version>00_<Minor engine version>`. Example: `rds_postgres_1200_20200830`.
	//
	// >  For more information about minor engine versions, see [Release notes for AliPG](~~126002~~).
	TargetMinorVersion *string `json:"TargetMinorVersion,omitempty" xml:"TargetMinorVersion,omitempty"`
	// The ID of the order.
	UsedTime *int64 `json:"UsedTime,omitempty" xml:"UsedTime,omitempty"`
	// The RDS edition of the instance. Valid values:
	//
	// *   **Basic**: RDS Basic Edition.
	// *   **HighAvailability**: RDS High-availability Edition.
	// *   **AlwaysOn**: RDS Cluster Edition for SQL Server.
	// *   **Finance**: RDS Enterprise Edition. This edition is available only on the China site (aliyun.com).
	//
	// > If you set **EngineVersion** to an SQL Server version number, you must also specify this parameter.
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
}

func (s ModifyDBInstanceSpecRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBInstanceSpecRequest) GoString() string {
	return s.String()
}

func (s *ModifyDBInstanceSpecRequest) SetAutoUseCoupon(v bool) *ModifyDBInstanceSpecRequest {
	s.AutoUseCoupon = &v
	return s
}

func (s *ModifyDBInstanceSpecRequest) SetBurstingEnabled(v bool) *ModifyDBInstanceSpecRequest {
	s.BurstingEnabled = &v
	return s
}

func (s *ModifyDBInstanceSpecRequest) SetCategory(v string) *ModifyDBInstanceSpecRequest {
	s.Category = &v
	return s
}

func (s *ModifyDBInstanceSpecRequest) SetDBInstanceClass(v string) *ModifyDBInstanceSpecRequest {
	s.DBInstanceClass = &v
	return s
}

func (s *ModifyDBInstanceSpecRequest) SetDBInstanceId(v string) *ModifyDBInstanceSpecRequest {
	s.DBInstanceId = &v
	return s
}

func (s *ModifyDBInstanceSpecRequest) SetDBInstanceStorage(v int32) *ModifyDBInstanceSpecRequest {
	s.DBInstanceStorage = &v
	return s
}

func (s *ModifyDBInstanceSpecRequest) SetDBInstanceStorageType(v string) *ModifyDBInstanceSpecRequest {
	s.DBInstanceStorageType = &v
	return s
}

func (s *ModifyDBInstanceSpecRequest) SetDedicatedHostGroupId(v string) *ModifyDBInstanceSpecRequest {
	s.DedicatedHostGroupId = &v
	return s
}

func (s *ModifyDBInstanceSpecRequest) SetDirection(v string) *ModifyDBInstanceSpecRequest {
	s.Direction = &v
	return s
}

func (s *ModifyDBInstanceSpecRequest) SetEffectiveTime(v string) *ModifyDBInstanceSpecRequest {
	s.EffectiveTime = &v
	return s
}

func (s *ModifyDBInstanceSpecRequest) SetEngineVersion(v string) *ModifyDBInstanceSpecRequest {
	s.EngineVersion = &v
	return s
}

func (s *ModifyDBInstanceSpecRequest) SetOwnerAccount(v string) *ModifyDBInstanceSpecRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyDBInstanceSpecRequest) SetOwnerId(v int64) *ModifyDBInstanceSpecRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyDBInstanceSpecRequest) SetPayType(v string) *ModifyDBInstanceSpecRequest {
	s.PayType = &v
	return s
}

func (s *ModifyDBInstanceSpecRequest) SetResourceGroupId(v string) *ModifyDBInstanceSpecRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *ModifyDBInstanceSpecRequest) SetResourceOwnerAccount(v string) *ModifyDBInstanceSpecRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyDBInstanceSpecRequest) SetResourceOwnerId(v int64) *ModifyDBInstanceSpecRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ModifyDBInstanceSpecRequest) SetServerlessConfiguration(v *ModifyDBInstanceSpecRequestServerlessConfiguration) *ModifyDBInstanceSpecRequest {
	s.ServerlessConfiguration = v
	return s
}

func (s *ModifyDBInstanceSpecRequest) SetSourceBiz(v string) *ModifyDBInstanceSpecRequest {
	s.SourceBiz = &v
	return s
}

func (s *ModifyDBInstanceSpecRequest) SetSwitchTime(v string) *ModifyDBInstanceSpecRequest {
	s.SwitchTime = &v
	return s
}

func (s *ModifyDBInstanceSpecRequest) SetTargetMinorVersion(v string) *ModifyDBInstanceSpecRequest {
	s.TargetMinorVersion = &v
	return s
}

func (s *ModifyDBInstanceSpecRequest) SetUsedTime(v int64) *ModifyDBInstanceSpecRequest {
	s.UsedTime = &v
	return s
}

func (s *ModifyDBInstanceSpecRequest) SetZoneId(v string) *ModifyDBInstanceSpecRequest {
	s.ZoneId = &v
	return s
}

type ModifyDBInstanceSpecRequestServerlessConfiguration struct {
	// Specifies whether to enable the automatic start and stop feature for the serverless instance. Valid values:
	//
	// *   **true**
	// *   **false** (default)
	//
	// >  This parameter is required only for serverless instances that run MySQL and PostgreSQL. After the automatic start and stop feature is enabled, if no connections to the instance are established within 10 minutes, the instance is suspended. After a connection to the instance is established, the instance is resumed.
	AutoPause *bool `json:"AutoPause,omitempty" xml:"AutoPause,omitempty"`
	// The maximum number of RDS Capacity Units (RCUs). Valid values:
	//
	// *   Serverless ApsaraDB RDS for MySQL instances: **1 to 8**
	// *   Serverless ApsaraDB RDS for SQL Server instances: **2 to 8**
	// *   Serverless ApsaraDB RDS for PostgreSQL instances: **1 to 12**
	//
	// >  The value of this parameter must be greater than or equal to the value of **MinCapacity** and can be specified only to an **integer**.
	MaxCapacity *float64 `json:"MaxCapacity,omitempty" xml:"MaxCapacity,omitempty"`
	// The minimum number of RCUs. Valid values:
	//
	// *   Serverless ApsaraDB RDS for MySQL instances: **0.5 to 8**.
	// *   Serverless ApsaraDB RDS for SQL Server instances: **2 to 8**. Only integers are supported.
	// *   Serverless ApsaraDB RDS for PostgreSQL instances: **0.5 to 12**.
	//
	// >  The value of this parameter must be less than or equal to the value of **MaxCapacity**.
	MinCapacity *float64 `json:"MinCapacity,omitempty" xml:"MinCapacity,omitempty"`
	// Specifies whether to enable the forced scaling feature for the serverless instance.
	//
	// *   **true**
	// *   **false** (default)
	//
	// >
	//
	// *   This parameter is required only for serverless instances that run MySQL and PostgreSQL. If you set this parameter to true, a transient connection that lasts approximately 1 minute occurs during forced scaling. Process with caution.
	//
	// *   The RCU scaling for a serverless instance immediately takes effect. In some cases, such as the execution of large transactions, the scaling does not immediately take effect. In this case, you can enable this feature to forcefully scale the RCUs of the instance.
	SwitchForce *bool `json:"SwitchForce,omitempty" xml:"SwitchForce,omitempty"`
}

func (s ModifyDBInstanceSpecRequestServerlessConfiguration) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBInstanceSpecRequestServerlessConfiguration) GoString() string {
	return s.String()
}

func (s *ModifyDBInstanceSpecRequestServerlessConfiguration) SetAutoPause(v bool) *ModifyDBInstanceSpecRequestServerlessConfiguration {
	s.AutoPause = &v
	return s
}

func (s *ModifyDBInstanceSpecRequestServerlessConfiguration) SetMaxCapacity(v float64) *ModifyDBInstanceSpecRequestServerlessConfiguration {
	s.MaxCapacity = &v
	return s
}

func (s *ModifyDBInstanceSpecRequestServerlessConfiguration) SetMinCapacity(v float64) *ModifyDBInstanceSpecRequestServerlessConfiguration {
	s.MinCapacity = &v
	return s
}

func (s *ModifyDBInstanceSpecRequestServerlessConfiguration) SetSwitchForce(v bool) *ModifyDBInstanceSpecRequestServerlessConfiguration {
	s.SwitchForce = &v
	return s
}

type ModifyDBInstanceSpecShrinkRequest struct {
	// Specifies whether to use vouchers to offset fees. Valid values:
	//
	// *   **true**
	// *   **false** (default)
	AutoUseCoupon *bool `json:"AutoUseCoupon,omitempty" xml:"AutoUseCoupon,omitempty"`
	// An invalid parameter. You do not need to specify this parameter.
	BurstingEnabled *bool `json:"BurstingEnabled,omitempty" xml:"BurstingEnabled,omitempty"`
	// The RDS edition of the instance. Valid values:
	//
	// *   Regular RDS instance
	//
	//     *   **Basic**: RDS Basic Edition
	//     *   **HighAvailability**: RDS High-availability Edition
	//     *   **AlwaysOn**: RDS Cluster Edition for ApsaraDB RDS for SQL Server
	//     *   **Cluster**: RDS Cluster Edition for ApsaraDB RDS for MySQL.
	//
	// *   Serverless instance
	//
	//     *   **serverless_basic**: RDS Basic Edition. This edition is available only for serverless instances that run MySQL and PostgreSQL.
	//     *   **serverless_standard**: RDS High-availability Edition for ApsaraDB RDS for MySQL.
	//     *   **serverless_ha**: RDS High-availability Edition for ApsaraDB RDS for SQL Server.
	//
	//     **
	//
	//     **Note** If you set the **EngineVersion** parameter to an SQL Server version number, you must also specify this parameter.
	Category *string `json:"Category,omitempty" xml:"Category,omitempty"`
	// The new instance type of the instance. For more information, see [Primary ApsaraDB RDS instance types](~~26312~~). You can also call the [DescribeAvailableClasses](~~610393~~) operation to query the instance types that are supported by an instance.
	//
	// - You must specify at least one of DBInstanceClass and **DBInstanceStorage**.
	// - You can call the [DescribeDBInstanceAttribute](~~610394~~) operation to query the current instance type of the instance.
	DBInstanceClass *string `json:"DBInstanceClass,omitempty" xml:"DBInstanceClass,omitempty"`
	// The instance ID. You can call the [DescribeDBInstances](~~610396~~) operation to query the ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The new storage capacity of the instance. Unit: GB. You can increase the storage capacity in increments of 5 GB. For more information, see [Primary ApsaraDB RDS instance types](~~26312~~). You can call the [DescribeAvailableClasses](~~610393~~) operation to query the storage capacity range that is supported by the new instance type.
	//
	// *   You must specify at least one of the DBInstanceStorage and **DBInstanceClass** parameters.
	// *   You can call the [DescribeDBInstanceAttribute](~~610394~~) operation to query the current storage capacity of the instance.
	DBInstanceStorage *int32 `json:"DBInstanceStorage,omitempty" xml:"DBInstanceStorage,omitempty"`
	// The storage type of the instance. Valid values:
	//
	// *   **local_ssd**: local SSD.
	// *   **cloud_ssd**: standard SSD. This storage type is not recommended and is unavailable in some Alibaba Cloud regions.
	// *   **cloud_essd**: enhanced SSD (ESSD) of performance level 1 (PL1).
	// *   **cloud_essd2**: ESSDs of PL2.
	// *   **cloud_essd3**: ESSD of PL3.
	//
	// To change the storage type, take note of the following items:
	//
	// If the instance runs PostgreSQL, you can upgrade the storage type of the instance from standard SSD to ESSD. However, you cannot downgrade the storage type of the instance from ESSD to standard SSD. ESSDs provide the following PLs: PL1, PL2, and PL3. You can upgrade or downgrade the storage type between ESSD of PL1, ESSD of PL2, and ESSD of PL3. For more information, see [Configuration items](~~96750~~).
	DBInstanceStorageType *string `json:"DBInstanceStorageType,omitempty" xml:"DBInstanceStorageType,omitempty"`
	// The ID of the dedicated cluster.
	DedicatedHostGroupId *string `json:"DedicatedHostGroupId,omitempty" xml:"DedicatedHostGroupId,omitempty"`
	// The type of change that you want to perform on the instance. Valid values:
	//
	// *   **Up** (default): upgrades a subscription instance, or upgrades or downgrades a pay-as-you-go instance.
	// *   **Down**: downgrades a subscription instance.
	// *   **TempUpgrade**: performs auto scaling on a subscription instance that runs SQL Server. This value is required for auto scaling.
	// *   **Serverless**: modifies the auto scaling settings of a serverless instance. This value is required if you want to modify the auto scaling settings of a serverless instance.
	//
	// >  If you specify only **DBInstanceStorageType**, you can leave Direction empty. For example, if you want to change only the storage type of the instance from standard SSD to ESSD, you do not need to specify Direction.
	Direction *string `json:"Direction,omitempty" xml:"Direction,omitempty"`
	// The time when you want the change to take effect. Valid values:
	//
	// *   **Immediate**: This is the default value.
	// *   **MaintainTime**: The effective time is within the maintenance window. For more information, see [ModifyDBInstanceMaintainTime](~~610402~~).
	EffectiveTime *string `json:"EffectiveTime,omitempty" xml:"EffectiveTime,omitempty"`
	// The database engine version of the instance.
	//
	// *   Regular instance
	//
	//     *   Valid values if you set Engine to MySQL: **5.5**, **5.6**, **5.7**, and **8.0**
	//     *   Valid values if you set Engine to SQLServer: **2008r2**, **08r2\_ent_ha**, **2012**, **2012\_ent_ha**, **2012\_std_ha**, **2012\_web**, **2014\_std_ha**, **2016\_ent_ha**, **2016\_std_ha**, **2016\_web**, **2017\_std_ha**, **2017\_ent**, **2019\_std_ha**, and **2019\_ent**
	//     *   Valid values if you set Engine to PostgreSQL: **10.0**, **11.0**, **12.0**, **13.0**, **14.0**, and **15.0**
	//     *   Valid value if you set Engine to MariaDB: **10.3**
	//
	// *   Serverless instance
	//
	//     *   Valid values if you set Engine to MySQL: **5.7** and **8.0**
	//     *   Valid values if you set Engine to SQLServer: **2016\_std_sl**, **2017\_std_sl**, and **2019\_std_sl**
	//     *   Valid value if you set Engine to PostgreSQL: **14.0**
	//
	//     **
	//
	//     **Note**ApsaraDB RDS for MariaDB does not support serverless instances.
	EngineVersion *string `json:"EngineVersion,omitempty" xml:"EngineVersion,omitempty"`
	OwnerAccount  *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The billing method of the instance. Valid values:
	//
	// *   **Postpaid**: pay-as-you-go.
	// *   **Prepaid**: subscription.
	// *   **Serverless**: serverless. This value is not supported for instances that run MariaDB. If you set the value to Serverless, you must specify the scaling range of computing resources, configure the automatic start and stop feature, and configure auto scaling policies for your serverless instance. For more information, see [Overview of serverless ApsaraDB RDS for MySQL instances](~~411291~~), [Overview of serverless ApsaraDB RDS for SQL Server instances](~~604344~~), and [Overview of serverless ApsaraDB RDS for PostgreSQL instances](~~607742~~).
	PayType *string `json:"PayType,omitempty" xml:"PayType,omitempty"`
	// The ID of the resource group.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The serverless instance on which you want to perform the specification change.
	ServerlessConfigurationShrink *string `json:"ServerlessConfiguration,omitempty" xml:"ServerlessConfiguration,omitempty"`
	// A deprecated parameter. You do not need to specify this parameter.
	SourceBiz *string `json:"SourceBiz,omitempty" xml:"SourceBiz,omitempty"`
	// The response parameters.
	SwitchTime *string `json:"SwitchTime,omitempty" xml:"SwitchTime,omitempty"`
	// The number of the minor version.
	//
	// This parameter is required only for instances that run PostgreSQL. If the minor engine version does not support changing the instance type, you must specify the minor engine version to update the minor engine version when you change the instance type.
	//
	// Format: `rds_postgres_<Major engine version>00_<Minor engine version>`. Example: `rds_postgres_1200_20200830`.
	//
	// >  For more information about minor engine versions, see [Release notes for AliPG](~~126002~~).
	TargetMinorVersion *string `json:"TargetMinorVersion,omitempty" xml:"TargetMinorVersion,omitempty"`
	// The ID of the order.
	UsedTime *int64 `json:"UsedTime,omitempty" xml:"UsedTime,omitempty"`
	// The RDS edition of the instance. Valid values:
	//
	// *   **Basic**: RDS Basic Edition.
	// *   **HighAvailability**: RDS High-availability Edition.
	// *   **AlwaysOn**: RDS Cluster Edition for SQL Server.
	// *   **Finance**: RDS Enterprise Edition. This edition is available only on the China site (aliyun.com).
	//
	// > If you set **EngineVersion** to an SQL Server version number, you must also specify this parameter.
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
}

func (s ModifyDBInstanceSpecShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBInstanceSpecShrinkRequest) GoString() string {
	return s.String()
}

func (s *ModifyDBInstanceSpecShrinkRequest) SetAutoUseCoupon(v bool) *ModifyDBInstanceSpecShrinkRequest {
	s.AutoUseCoupon = &v
	return s
}

func (s *ModifyDBInstanceSpecShrinkRequest) SetBurstingEnabled(v bool) *ModifyDBInstanceSpecShrinkRequest {
	s.BurstingEnabled = &v
	return s
}

func (s *ModifyDBInstanceSpecShrinkRequest) SetCategory(v string) *ModifyDBInstanceSpecShrinkRequest {
	s.Category = &v
	return s
}

func (s *ModifyDBInstanceSpecShrinkRequest) SetDBInstanceClass(v string) *ModifyDBInstanceSpecShrinkRequest {
	s.DBInstanceClass = &v
	return s
}

func (s *ModifyDBInstanceSpecShrinkRequest) SetDBInstanceId(v string) *ModifyDBInstanceSpecShrinkRequest {
	s.DBInstanceId = &v
	return s
}

func (s *ModifyDBInstanceSpecShrinkRequest) SetDBInstanceStorage(v int32) *ModifyDBInstanceSpecShrinkRequest {
	s.DBInstanceStorage = &v
	return s
}

func (s *ModifyDBInstanceSpecShrinkRequest) SetDBInstanceStorageType(v string) *ModifyDBInstanceSpecShrinkRequest {
	s.DBInstanceStorageType = &v
	return s
}

func (s *ModifyDBInstanceSpecShrinkRequest) SetDedicatedHostGroupId(v string) *ModifyDBInstanceSpecShrinkRequest {
	s.DedicatedHostGroupId = &v
	return s
}

func (s *ModifyDBInstanceSpecShrinkRequest) SetDirection(v string) *ModifyDBInstanceSpecShrinkRequest {
	s.Direction = &v
	return s
}

func (s *ModifyDBInstanceSpecShrinkRequest) SetEffectiveTime(v string) *ModifyDBInstanceSpecShrinkRequest {
	s.EffectiveTime = &v
	return s
}

func (s *ModifyDBInstanceSpecShrinkRequest) SetEngineVersion(v string) *ModifyDBInstanceSpecShrinkRequest {
	s.EngineVersion = &v
	return s
}

func (s *ModifyDBInstanceSpecShrinkRequest) SetOwnerAccount(v string) *ModifyDBInstanceSpecShrinkRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyDBInstanceSpecShrinkRequest) SetOwnerId(v int64) *ModifyDBInstanceSpecShrinkRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyDBInstanceSpecShrinkRequest) SetPayType(v string) *ModifyDBInstanceSpecShrinkRequest {
	s.PayType = &v
	return s
}

func (s *ModifyDBInstanceSpecShrinkRequest) SetResourceGroupId(v string) *ModifyDBInstanceSpecShrinkRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *ModifyDBInstanceSpecShrinkRequest) SetResourceOwnerAccount(v string) *ModifyDBInstanceSpecShrinkRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyDBInstanceSpecShrinkRequest) SetResourceOwnerId(v int64) *ModifyDBInstanceSpecShrinkRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ModifyDBInstanceSpecShrinkRequest) SetServerlessConfigurationShrink(v string) *ModifyDBInstanceSpecShrinkRequest {
	s.ServerlessConfigurationShrink = &v
	return s
}

func (s *ModifyDBInstanceSpecShrinkRequest) SetSourceBiz(v string) *ModifyDBInstanceSpecShrinkRequest {
	s.SourceBiz = &v
	return s
}

func (s *ModifyDBInstanceSpecShrinkRequest) SetSwitchTime(v string) *ModifyDBInstanceSpecShrinkRequest {
	s.SwitchTime = &v
	return s
}

func (s *ModifyDBInstanceSpecShrinkRequest) SetTargetMinorVersion(v string) *ModifyDBInstanceSpecShrinkRequest {
	s.TargetMinorVersion = &v
	return s
}

func (s *ModifyDBInstanceSpecShrinkRequest) SetUsedTime(v int64) *ModifyDBInstanceSpecShrinkRequest {
	s.UsedTime = &v
	return s
}

func (s *ModifyDBInstanceSpecShrinkRequest) SetZoneId(v string) *ModifyDBInstanceSpecShrinkRequest {
	s.ZoneId = &v
	return s
}

type ModifyDBInstanceSpecResponseBody struct {
	// The instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The ID of the order.
	OrderId *int64 `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyDBInstanceSpecResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBInstanceSpecResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyDBInstanceSpecResponseBody) SetDBInstanceId(v string) *ModifyDBInstanceSpecResponseBody {
	s.DBInstanceId = &v
	return s
}

func (s *ModifyDBInstanceSpecResponseBody) SetOrderId(v int64) *ModifyDBInstanceSpecResponseBody {
	s.OrderId = &v
	return s
}

func (s *ModifyDBInstanceSpecResponseBody) SetRequestId(v string) *ModifyDBInstanceSpecResponseBody {
	s.RequestId = &v
	return s
}

type ModifyDBInstanceSpecResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyDBInstanceSpecResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyDBInstanceSpecResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBInstanceSpecResponse) GoString() string {
	return s.String()
}

func (s *ModifyDBInstanceSpecResponse) SetHeaders(v map[string]*string) *ModifyDBInstanceSpecResponse {
	s.Headers = v
	return s
}

func (s *ModifyDBInstanceSpecResponse) SetStatusCode(v int32) *ModifyDBInstanceSpecResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyDBInstanceSpecResponse) SetBody(v *ModifyDBInstanceSpecResponseBody) *ModifyDBInstanceSpecResponse {
	s.Body = v
	return s
}

type ModifyDBInstanceTDERequest struct {
	// The file that contains the certificate.\
	// Format:
	//
	// *   Public endpoint: `oss-<The ID of the region>.aliyuncs.com:<The name of the bucket>:<The name of the certificate file>` (The file name contains the extension.)
	// *   Internal endpoint: `oss-<The ID of the region>-internal.aliyuncs.com:<The name of the bucket>:<The name of the certificate file>` (The file name contains the extension.)
	//
	// >
	//
	// *   This parameter is available when the instance runs SQL Server 2019 SE or an Enterprise Edition of SQL Server.
	//
	// *   You can call the [DescribeRegions](~~26243~~) operation to query the most recent region list.
	Certificate *string `json:"Certificate,omitempty" xml:"Certificate,omitempty"`
	// The instance ID. You can call the [DescribeDBInstances](~~610396~~) operation to query the ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The name of the database for which you want to enable TDE. You can specify up to 50 database names in a single request. If you specify multiple database names, separate the database names with commas (,).
	//
	// > This parameter is available and must be specified only when the instance runs SQL Server 2019 SE or an Enterprise Edition of SQL Server.
	DBName *string `json:"DBName,omitempty" xml:"DBName,omitempty"`
	// The ID of the custom key.
	//
	// > This parameter is available when the instance runs MySQL or PostgreSQL.
	EncryptionKey *string `json:"EncryptionKey,omitempty" xml:"EncryptionKey,omitempty"`
	// Specifies whether to replace the key. Valid values:
	//
	// *   **true**: replaces the key.
	// *   **false**: does not replace the key.
	//
	// Default value: **false**
	//
	// > This parameter is available only when the instance runs PostgreSQL.
	IsRotate     *bool   `json:"IsRotate,omitempty" xml:"IsRotate,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The password of the certificate.
	//
	// > This parameter is available when the instance runs SQL Server 2019 SE or an Enterprise Edition of SQL Server.
	PassWord *string `json:"PassWord,omitempty" xml:"PassWord,omitempty"`
	// The file that contains the private key of the certificate.\
	// Format:
	//
	// *   Public endpoint: `oss-<The ID of the region>.aliyuncs.com:<The name of the bucket>:<The name of the file that contains the private key>` (The file name contains the extension.)
	// *   Internal endpoint: `oss-<The ID of the region>-internal.aliyuncs.com:<The name of the bucket>:<The name of the file that contains the private key>` (The file name contains the extension.)
	//
	// >
	//
	// *   This parameter is available when the instance runs SQL Server 2019 SE or an Enterprise Edition of SQL Server.
	//
	// *   You can call the [DescribeRegions](~~26243~~) operation to query the most recent region list.
	PrivateKey           *string `json:"PrivateKey,omitempty" xml:"PrivateKey,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The Alibaba Cloud Resource Name (ARN) of the RAM role. A RAM role is a virtual identity that you can create within your Alibaba Cloud account. For more information, see [RAM role overview](~~93689~~).
	//
	// > This parameter is available when the instance runs MySQL or PostgreSQL.
	RoleArn *string `json:"RoleArn,omitempty" xml:"RoleArn,omitempty"`
	// The status of TDE. Valid values:
	//
	// *   **Enabled**
	// *   **Disabled**
	TDEStatus *string `json:"TDEStatus,omitempty" xml:"TDEStatus,omitempty"`
}

func (s ModifyDBInstanceTDERequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBInstanceTDERequest) GoString() string {
	return s.String()
}

func (s *ModifyDBInstanceTDERequest) SetCertificate(v string) *ModifyDBInstanceTDERequest {
	s.Certificate = &v
	return s
}

func (s *ModifyDBInstanceTDERequest) SetDBInstanceId(v string) *ModifyDBInstanceTDERequest {
	s.DBInstanceId = &v
	return s
}

func (s *ModifyDBInstanceTDERequest) SetDBName(v string) *ModifyDBInstanceTDERequest {
	s.DBName = &v
	return s
}

func (s *ModifyDBInstanceTDERequest) SetEncryptionKey(v string) *ModifyDBInstanceTDERequest {
	s.EncryptionKey = &v
	return s
}

func (s *ModifyDBInstanceTDERequest) SetIsRotate(v bool) *ModifyDBInstanceTDERequest {
	s.IsRotate = &v
	return s
}

func (s *ModifyDBInstanceTDERequest) SetOwnerAccount(v string) *ModifyDBInstanceTDERequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyDBInstanceTDERequest) SetOwnerId(v int64) *ModifyDBInstanceTDERequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyDBInstanceTDERequest) SetPassWord(v string) *ModifyDBInstanceTDERequest {
	s.PassWord = &v
	return s
}

func (s *ModifyDBInstanceTDERequest) SetPrivateKey(v string) *ModifyDBInstanceTDERequest {
	s.PrivateKey = &v
	return s
}

func (s *ModifyDBInstanceTDERequest) SetResourceOwnerAccount(v string) *ModifyDBInstanceTDERequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyDBInstanceTDERequest) SetResourceOwnerId(v int64) *ModifyDBInstanceTDERequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ModifyDBInstanceTDERequest) SetRoleArn(v string) *ModifyDBInstanceTDERequest {
	s.RoleArn = &v
	return s
}

func (s *ModifyDBInstanceTDERequest) SetTDEStatus(v string) *ModifyDBInstanceTDERequest {
	s.TDEStatus = &v
	return s
}

type ModifyDBInstanceTDEResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyDBInstanceTDEResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBInstanceTDEResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyDBInstanceTDEResponseBody) SetRequestId(v string) *ModifyDBInstanceTDEResponseBody {
	s.RequestId = &v
	return s
}

type ModifyDBInstanceTDEResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyDBInstanceTDEResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyDBInstanceTDEResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBInstanceTDEResponse) GoString() string {
	return s.String()
}

func (s *ModifyDBInstanceTDEResponse) SetHeaders(v map[string]*string) *ModifyDBInstanceTDEResponse {
	s.Headers = v
	return s
}

func (s *ModifyDBInstanceTDEResponse) SetStatusCode(v int32) *ModifyDBInstanceTDEResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyDBInstanceTDEResponse) SetBody(v *ModifyDBInstanceTDEResponseBody) *ModifyDBInstanceTDEResponse {
	s.Body = v
	return s
}

type ModifyDBNodeRequest struct {
	// Specifies whether to automatically complete the payment. Valid values:
	//
	// 1.  **true**: automatically completes the payment. Make sure that your account balance is sufficient.
	// 2.  **false**: does not automatically complete the payment. An unpaid order is generated.
	//
	// >  The default value is true. If your account balance is insufficient, you can set the AutoPay parameter to false to generate an unpaid order. Then, you can log on to the ApsaraDB RDS console to pay for the order.
	AutoPay *bool `json:"AutoPay,omitempty" xml:"AutoPay,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The new storage capacity of the instance. Unit: GB For more information, see [Instance types](~~26312~~).
	DBInstanceStorage *string `json:"DBInstanceStorage,omitempty" xml:"DBInstanceStorage,omitempty"`
	// The storage type of the instance. Valid values:
	//
	// *   **cloud_essd**: performance level 1 (PL1) enhanced SSD (ESSD)
	// *   **cloud_essd2**: PL2 ESSD
	// *   **cloud_essd3**: PL3 ESSD
	DBInstanceStorageType *string `json:"DBInstanceStorageType,omitempty" xml:"DBInstanceStorageType,omitempty"`
	// The information about the node.
	//
	// >  This parameter is supported for ApsaraDB RDS for MySQL instances that run RDS Cluster Edition.
	DBNode []*ModifyDBNodeRequestDBNode `json:"DBNode,omitempty" xml:"DBNode,omitempty" type:"Repeated"`
	// Specifies whether to perform a dry run. Valid values: Valid values:
	//
	// *   **true**: performs a dry run and does not perform the actual request. The system checks items such as the request parameters, request format, service limits, and available resources.
	// *   **false** (default): performs a dry run and performs the actual request. If the request passes the dry run, the operation is performed.
	DryRun       *bool   `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// Specifies whether to asynchronously perform the operation. Valid values:
	//
	// *   **true** (default): sends only the order. The operation is asynchronously performed.
	// *   **false**: sends the request. After the request passes the check, the operation is directly performed.
	//
	// >  The default value is true, which indicates that the change operation is asynchronously performed. If you set this parameter to false, the change operation is simultaneously performed. This prolongs the response time of the operation.
	ProduceAsync         *bool   `json:"ProduceAsync,omitempty" xml:"ProduceAsync,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ModifyDBNodeRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBNodeRequest) GoString() string {
	return s.String()
}

func (s *ModifyDBNodeRequest) SetAutoPay(v bool) *ModifyDBNodeRequest {
	s.AutoPay = &v
	return s
}

func (s *ModifyDBNodeRequest) SetClientToken(v string) *ModifyDBNodeRequest {
	s.ClientToken = &v
	return s
}

func (s *ModifyDBNodeRequest) SetDBInstanceId(v string) *ModifyDBNodeRequest {
	s.DBInstanceId = &v
	return s
}

func (s *ModifyDBNodeRequest) SetDBInstanceStorage(v string) *ModifyDBNodeRequest {
	s.DBInstanceStorage = &v
	return s
}

func (s *ModifyDBNodeRequest) SetDBInstanceStorageType(v string) *ModifyDBNodeRequest {
	s.DBInstanceStorageType = &v
	return s
}

func (s *ModifyDBNodeRequest) SetDBNode(v []*ModifyDBNodeRequestDBNode) *ModifyDBNodeRequest {
	s.DBNode = v
	return s
}

func (s *ModifyDBNodeRequest) SetDryRun(v bool) *ModifyDBNodeRequest {
	s.DryRun = &v
	return s
}

func (s *ModifyDBNodeRequest) SetOwnerAccount(v string) *ModifyDBNodeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyDBNodeRequest) SetOwnerId(v int64) *ModifyDBNodeRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyDBNodeRequest) SetProduceAsync(v bool) *ModifyDBNodeRequest {
	s.ProduceAsync = &v
	return s
}

func (s *ModifyDBNodeRequest) SetResourceOwnerAccount(v string) *ModifyDBNodeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyDBNodeRequest) SetResourceOwnerId(v int64) *ModifyDBNodeRequest {
	s.ResourceOwnerId = &v
	return s
}

type ModifyDBNodeRequestDBNode struct {
	// The instance type of the node.
	ClassCode *string `json:"classCode,omitempty" xml:"classCode,omitempty"`
	// The node ID.
	NodeId *string `json:"nodeId,omitempty" xml:"nodeId,omitempty"`
}

func (s ModifyDBNodeRequestDBNode) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBNodeRequestDBNode) GoString() string {
	return s.String()
}

func (s *ModifyDBNodeRequestDBNode) SetClassCode(v string) *ModifyDBNodeRequestDBNode {
	s.ClassCode = &v
	return s
}

func (s *ModifyDBNodeRequestDBNode) SetNodeId(v string) *ModifyDBNodeRequestDBNode {
	s.NodeId = &v
	return s
}

type ModifyDBNodeShrinkRequest struct {
	// Specifies whether to automatically complete the payment. Valid values:
	//
	// 1.  **true**: automatically completes the payment. Make sure that your account balance is sufficient.
	// 2.  **false**: does not automatically complete the payment. An unpaid order is generated.
	//
	// >  The default value is true. If your account balance is insufficient, you can set the AutoPay parameter to false to generate an unpaid order. Then, you can log on to the ApsaraDB RDS console to pay for the order.
	AutoPay *bool `json:"AutoPay,omitempty" xml:"AutoPay,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The new storage capacity of the instance. Unit: GB For more information, see [Instance types](~~26312~~).
	DBInstanceStorage *string `json:"DBInstanceStorage,omitempty" xml:"DBInstanceStorage,omitempty"`
	// The storage type of the instance. Valid values:
	//
	// *   **cloud_essd**: performance level 1 (PL1) enhanced SSD (ESSD)
	// *   **cloud_essd2**: PL2 ESSD
	// *   **cloud_essd3**: PL3 ESSD
	DBInstanceStorageType *string `json:"DBInstanceStorageType,omitempty" xml:"DBInstanceStorageType,omitempty"`
	// The information about the node.
	//
	// >  This parameter is supported for ApsaraDB RDS for MySQL instances that run RDS Cluster Edition.
	DBNodeShrink *string `json:"DBNode,omitempty" xml:"DBNode,omitempty"`
	// Specifies whether to perform a dry run. Valid values: Valid values:
	//
	// *   **true**: performs a dry run and does not perform the actual request. The system checks items such as the request parameters, request format, service limits, and available resources.
	// *   **false** (default): performs a dry run and performs the actual request. If the request passes the dry run, the operation is performed.
	DryRun       *bool   `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// Specifies whether to asynchronously perform the operation. Valid values:
	//
	// *   **true** (default): sends only the order. The operation is asynchronously performed.
	// *   **false**: sends the request. After the request passes the check, the operation is directly performed.
	//
	// >  The default value is true, which indicates that the change operation is asynchronously performed. If you set this parameter to false, the change operation is simultaneously performed. This prolongs the response time of the operation.
	ProduceAsync         *bool   `json:"ProduceAsync,omitempty" xml:"ProduceAsync,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ModifyDBNodeShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBNodeShrinkRequest) GoString() string {
	return s.String()
}

func (s *ModifyDBNodeShrinkRequest) SetAutoPay(v bool) *ModifyDBNodeShrinkRequest {
	s.AutoPay = &v
	return s
}

func (s *ModifyDBNodeShrinkRequest) SetClientToken(v string) *ModifyDBNodeShrinkRequest {
	s.ClientToken = &v
	return s
}

func (s *ModifyDBNodeShrinkRequest) SetDBInstanceId(v string) *ModifyDBNodeShrinkRequest {
	s.DBInstanceId = &v
	return s
}

func (s *ModifyDBNodeShrinkRequest) SetDBInstanceStorage(v string) *ModifyDBNodeShrinkRequest {
	s.DBInstanceStorage = &v
	return s
}

func (s *ModifyDBNodeShrinkRequest) SetDBInstanceStorageType(v string) *ModifyDBNodeShrinkRequest {
	s.DBInstanceStorageType = &v
	return s
}

func (s *ModifyDBNodeShrinkRequest) SetDBNodeShrink(v string) *ModifyDBNodeShrinkRequest {
	s.DBNodeShrink = &v
	return s
}

func (s *ModifyDBNodeShrinkRequest) SetDryRun(v bool) *ModifyDBNodeShrinkRequest {
	s.DryRun = &v
	return s
}

func (s *ModifyDBNodeShrinkRequest) SetOwnerAccount(v string) *ModifyDBNodeShrinkRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyDBNodeShrinkRequest) SetOwnerId(v int64) *ModifyDBNodeShrinkRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyDBNodeShrinkRequest) SetProduceAsync(v bool) *ModifyDBNodeShrinkRequest {
	s.ProduceAsync = &v
	return s
}

func (s *ModifyDBNodeShrinkRequest) SetResourceOwnerAccount(v string) *ModifyDBNodeShrinkRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyDBNodeShrinkRequest) SetResourceOwnerId(v int64) *ModifyDBNodeShrinkRequest {
	s.ResourceOwnerId = &v
	return s
}

type ModifyDBNodeResponseBody struct {
	// The instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The ID of the order.
	OrderId *int64 `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ModifyDBNodeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBNodeResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyDBNodeResponseBody) SetDBInstanceId(v string) *ModifyDBNodeResponseBody {
	s.DBInstanceId = &v
	return s
}

func (s *ModifyDBNodeResponseBody) SetOrderId(v int64) *ModifyDBNodeResponseBody {
	s.OrderId = &v
	return s
}

func (s *ModifyDBNodeResponseBody) SetRequestId(v string) *ModifyDBNodeResponseBody {
	s.RequestId = &v
	return s
}

func (s *ModifyDBNodeResponseBody) SetSuccess(v bool) *ModifyDBNodeResponseBody {
	s.Success = &v
	return s
}

type ModifyDBNodeResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyDBNodeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyDBNodeResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBNodeResponse) GoString() string {
	return s.String()
}

func (s *ModifyDBNodeResponse) SetHeaders(v map[string]*string) *ModifyDBNodeResponse {
	s.Headers = v
	return s
}

func (s *ModifyDBNodeResponse) SetStatusCode(v int32) *ModifyDBNodeResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyDBNodeResponse) SetBody(v *ModifyDBNodeResponseBody) *ModifyDBNodeResponse {
	s.Body = v
	return s
}

type ModifyDBProxyRequest struct {
	// Specifies whether to enable or disable the database proxy feature. Valid values:
	//
	// *   **Startup**: enables the database proxy feature.
	// *   **Shutdown**: disables the database proxy feature.
	ConfigDBProxyService *string `json:"ConfigDBProxyService,omitempty" xml:"ConfigDBProxyService,omitempty"`
	// The instance ID. You can call the [DescribeDBInstances](~~610396~~) operation to query the instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// A reserved parameter. You do not need to specify this parameter.
	DBProxyEngineType *string `json:"DBProxyEngineType,omitempty" xml:"DBProxyEngineType,omitempty"`
	// The number of proxy instances that are enabled. Valid values: **1** to **16**. Default value: **1**.
	//
	// >  The capability of the database proxy to process requests increases with the number of proxy instances that are enabled. You can monitor the load on the instance and specify an appropriate number of proxy instances based on the load monitoring data.
	DBProxyInstanceNum *string `json:"DBProxyInstanceNum,omitempty" xml:"DBProxyInstanceNum,omitempty"`
	// The network type of the instance. Set the value to **VPC**.
	//
	// > This parameter is required if you enable the database proxy feature for an ApsaraDB RDS for MySQL instance that uses cloud disks or an ApsaraDB RDS for PostgreSQL instance.
	InstanceNetworkType *string `json:"InstanceNetworkType,omitempty" xml:"InstanceNetworkType,omitempty"`
	OwnerId             *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the instance. You can call the [DescribeRegions](~~610399~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The resource group ID.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the virtual private cloud (VPC) to which the instance belongs. You can call the [DescribeDBInstanceAttribute](~~610394~~) operation to query the VPC ID of the instance.
	//
	// >  This parameter is required if you enable the database proxy feature for an ApsaraDB RDS for MySQL instance that uses cloud disks or an ApsaraDB RDS for PostgreSQL instance.
	VPCId *string `json:"VPCId,omitempty" xml:"VPCId,omitempty"`
	// The vSwitch ID of the instance. You can call the [DescribeDBInstanceAttribute](~~610394~~) operation to query the vSwitch ID of the instance.
	//
	// >  This parameter is required if you enable the database proxy feature for an ApsaraDB RDS for MySQL instance that uses cloud disks or an ApsaraDB RDS for PostgreSQL instance.
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
}

func (s ModifyDBProxyRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBProxyRequest) GoString() string {
	return s.String()
}

func (s *ModifyDBProxyRequest) SetConfigDBProxyService(v string) *ModifyDBProxyRequest {
	s.ConfigDBProxyService = &v
	return s
}

func (s *ModifyDBProxyRequest) SetDBInstanceId(v string) *ModifyDBProxyRequest {
	s.DBInstanceId = &v
	return s
}

func (s *ModifyDBProxyRequest) SetDBProxyEngineType(v string) *ModifyDBProxyRequest {
	s.DBProxyEngineType = &v
	return s
}

func (s *ModifyDBProxyRequest) SetDBProxyInstanceNum(v string) *ModifyDBProxyRequest {
	s.DBProxyInstanceNum = &v
	return s
}

func (s *ModifyDBProxyRequest) SetInstanceNetworkType(v string) *ModifyDBProxyRequest {
	s.InstanceNetworkType = &v
	return s
}

func (s *ModifyDBProxyRequest) SetOwnerId(v int64) *ModifyDBProxyRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyDBProxyRequest) SetRegionId(v string) *ModifyDBProxyRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyDBProxyRequest) SetResourceGroupId(v string) *ModifyDBProxyRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *ModifyDBProxyRequest) SetResourceOwnerAccount(v string) *ModifyDBProxyRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyDBProxyRequest) SetResourceOwnerId(v int64) *ModifyDBProxyRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ModifyDBProxyRequest) SetVPCId(v string) *ModifyDBProxyRequest {
	s.VPCId = &v
	return s
}

func (s *ModifyDBProxyRequest) SetVSwitchId(v string) *ModifyDBProxyRequest {
	s.VSwitchId = &v
	return s
}

type ModifyDBProxyResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyDBProxyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBProxyResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyDBProxyResponseBody) SetRequestId(v string) *ModifyDBProxyResponseBody {
	s.RequestId = &v
	return s
}

type ModifyDBProxyResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyDBProxyResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyDBProxyResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBProxyResponse) GoString() string {
	return s.String()
}

func (s *ModifyDBProxyResponse) SetHeaders(v map[string]*string) *ModifyDBProxyResponse {
	s.Headers = v
	return s
}

func (s *ModifyDBProxyResponse) SetStatusCode(v int32) *ModifyDBProxyResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyDBProxyResponse) SetBody(v *ModifyDBProxyResponseBody) *ModifyDBProxyResponse {
	s.Body = v
	return s
}

type ModifyDBProxyEndpointRequest struct {
	// The features that you want to enable for the proxy endpoint. If you specify more than one feature, separate the features with semicolons (;). Format: `Feature 1:Status;Feature 2:Status;...`. Do not add a semicolon (;) at the end of the last value.
	//
	// Valid feature values:
	//
	// *   **ReadWriteSpliting**: read/write splitting
	// *   **ConnectionPersist**: connection pooling
	// *   **TransactionReadSqlRouteOptimizeStatus**: transaction splitting
	//
	// Valid status values:
	//
	// *   **1**: enabled
	// *   **0**: disabled
	//
	// > If the instance runs PostgreSQL, you can enable only the read/write splitting feature, which is specified by **ReadWriteSpliting**.
	ConfigDBProxyFeatures *string `json:"ConfigDBProxyFeatures,omitempty" xml:"ConfigDBProxyFeatures,omitempty"`
	// The instance ID. You can call the [DescribeDBInstances](~~610396~~) operation to query the ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The ID of the proxy endpoint. You can call the [DescribeDBProxyEndpoint](~~610507~~) operation to query the ID of the proxy endpoint.
	//
	// > *   If the instance runs MySQL and you set **DbEndpointOperator** to **Delete** or **Modify**, you must specify DBProxyEndpointId.
	// > *   If the instance runs PostgreSQL and you set **DbEndpointOperator** to **Delete**, **Modify**, or **Create**, you must specify DBProxyEndpointId.
	DBProxyEndpointId *string `json:"DBProxyEndpointId,omitempty" xml:"DBProxyEndpointId,omitempty"`
	// A reserved parameter. You do not need to specify this parameter.
	DBProxyEngineType *string `json:"DBProxyEngineType,omitempty" xml:"DBProxyEngineType,omitempty"`
	// The description of the proxy terminal.
	DbEndpointAliases *string `json:"DbEndpointAliases,omitempty" xml:"DbEndpointAliases,omitempty"`
	// The type of operation that you want to perform. Valid values:
	//
	// *   **Modify**: Modify a proxy terminal. This is the default value.
	// *   **Create**: Create a proxy terminal.
	// *   **Delete**: Delete a proxy terminal.
	DbEndpointOperator *string `json:"DbEndpointOperator,omitempty" xml:"DbEndpointOperator,omitempty"`
	// The read and write attributes of the proxy terminal. Valid values:
	//
	// *   **ReadWrite**: The proxy terminal connects to the primary instance and can receive both read and write requests.
	// *   **ReadOnly**: The proxy terminal does not connect to the primary instance and can receive only read requests. This is the default value.
	//
	// > *   If you set **DbEndpointOperator** to **Create**, you must also specify DbEndpointReadWriteMode.
	// > *   If the instance runs MySQL and you change the value of this parameter from **ReadWrite** to **ReadOnly**, the transaction splitting feature is disabled.
	DbEndpointReadWriteMode *string `json:"DbEndpointReadWriteMode,omitempty" xml:"DbEndpointReadWriteMode,omitempty"`
	// The type of the proxy terminal. This is a reserved parameter. You do not need to specify this parameter.
	DbEndpointType *string `json:"DbEndpointType,omitempty" xml:"DbEndpointType,omitempty"`
	OwnerId        *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The policy that is used to allocate read weights. Valid values:
	//
	// *   **Standard**: The system automatically allocates read weights to the instance and its read-only instances based on the specifications of the instances.
	// *   **Custom**: You must manually allocate read weights to the instance and its read-only instances.
	//
	// > You must specify this parameter only when the read/write splitting feature is enabled. For more information about the permission allocation policy, see [Modify the latency threshold and read weights of ApsaraDB RDS for MySQL instances](~~96076~~) and [Enable and configure the database proxy feature for an ApsaraDB RDS for PostgreSQL instance](~~418272~~).
	ReadOnlyInstanceDistributionType *string `json:"ReadOnlyInstanceDistributionType,omitempty" xml:"ReadOnlyInstanceDistributionType,omitempty"`
	// The latency threshold that is allowed for read/write splitting. If the latency on a read-only instance exceeds the threshold that you specified, the system no longer forwards read requests to the read-only instance. Unit: seconds If you do not specify this parameter, the original value of this parameter is retained. Valid values: **0** to **3600**. Default value: **30**.
	//
	// > You must specify this parameter only when the read/write splitting feature is enabled.
	ReadOnlyInstanceMaxDelayTime *string `json:"ReadOnlyInstanceMaxDelayTime,omitempty" xml:"ReadOnlyInstanceMaxDelayTime,omitempty"`
	// The read weights of the instance and its read-only instances. A read weight must be a multiple of 100 and cannot exceed 10000. Formats:
	//
	// *   Standard instance: `{"ID of the primary instance":"Weight","ID of the read-only instance":"Weight"...}`
	//
	//     Example: `{"rm-uf6wjk5****":"500","rr-tfhfgk5xxx":"200"...}`
	//
	// *   Instance on RDS Cluster Edition: `{"ID of the read-only instance":"Weight","DBClusterNode":{"ID of the primary node":"Weight","ID of the secondary node":"Weight","ID of the secondary node":"Weight"...}}`
	//
	//     Example: `{"rr-tfhfgk5****":"200","DBClusterNode":{"rn-2z****":"0","rn-2z****":"400","rn-2z****":"400"...}}`
	//
	//     **
	//
	//     **Note** **DBClusterNode** is required if the instance runs RDS Cluster Edition. The DBClusterNode parameter includes information about **IDs** and **weights** of the primary and secondary nodes..
	ReadOnlyInstanceWeight *string `json:"ReadOnlyInstanceWeight,omitempty" xml:"ReadOnlyInstanceWeight,omitempty"`
	// The region ID. You can call the [DescribeRegions](~~610399~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ModifyDBProxyEndpointRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBProxyEndpointRequest) GoString() string {
	return s.String()
}

func (s *ModifyDBProxyEndpointRequest) SetConfigDBProxyFeatures(v string) *ModifyDBProxyEndpointRequest {
	s.ConfigDBProxyFeatures = &v
	return s
}

func (s *ModifyDBProxyEndpointRequest) SetDBInstanceId(v string) *ModifyDBProxyEndpointRequest {
	s.DBInstanceId = &v
	return s
}

func (s *ModifyDBProxyEndpointRequest) SetDBProxyEndpointId(v string) *ModifyDBProxyEndpointRequest {
	s.DBProxyEndpointId = &v
	return s
}

func (s *ModifyDBProxyEndpointRequest) SetDBProxyEngineType(v string) *ModifyDBProxyEndpointRequest {
	s.DBProxyEngineType = &v
	return s
}

func (s *ModifyDBProxyEndpointRequest) SetDbEndpointAliases(v string) *ModifyDBProxyEndpointRequest {
	s.DbEndpointAliases = &v
	return s
}

func (s *ModifyDBProxyEndpointRequest) SetDbEndpointOperator(v string) *ModifyDBProxyEndpointRequest {
	s.DbEndpointOperator = &v
	return s
}

func (s *ModifyDBProxyEndpointRequest) SetDbEndpointReadWriteMode(v string) *ModifyDBProxyEndpointRequest {
	s.DbEndpointReadWriteMode = &v
	return s
}

func (s *ModifyDBProxyEndpointRequest) SetDbEndpointType(v string) *ModifyDBProxyEndpointRequest {
	s.DbEndpointType = &v
	return s
}

func (s *ModifyDBProxyEndpointRequest) SetOwnerId(v int64) *ModifyDBProxyEndpointRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyDBProxyEndpointRequest) SetReadOnlyInstanceDistributionType(v string) *ModifyDBProxyEndpointRequest {
	s.ReadOnlyInstanceDistributionType = &v
	return s
}

func (s *ModifyDBProxyEndpointRequest) SetReadOnlyInstanceMaxDelayTime(v string) *ModifyDBProxyEndpointRequest {
	s.ReadOnlyInstanceMaxDelayTime = &v
	return s
}

func (s *ModifyDBProxyEndpointRequest) SetReadOnlyInstanceWeight(v string) *ModifyDBProxyEndpointRequest {
	s.ReadOnlyInstanceWeight = &v
	return s
}

func (s *ModifyDBProxyEndpointRequest) SetRegionId(v string) *ModifyDBProxyEndpointRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyDBProxyEndpointRequest) SetResourceOwnerAccount(v string) *ModifyDBProxyEndpointRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyDBProxyEndpointRequest) SetResourceOwnerId(v int64) *ModifyDBProxyEndpointRequest {
	s.ResourceOwnerId = &v
	return s
}

type ModifyDBProxyEndpointResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyDBProxyEndpointResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBProxyEndpointResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyDBProxyEndpointResponseBody) SetRequestId(v string) *ModifyDBProxyEndpointResponseBody {
	s.RequestId = &v
	return s
}

type ModifyDBProxyEndpointResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyDBProxyEndpointResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyDBProxyEndpointResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBProxyEndpointResponse) GoString() string {
	return s.String()
}

func (s *ModifyDBProxyEndpointResponse) SetHeaders(v map[string]*string) *ModifyDBProxyEndpointResponse {
	s.Headers = v
	return s
}

func (s *ModifyDBProxyEndpointResponse) SetStatusCode(v int32) *ModifyDBProxyEndpointResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyDBProxyEndpointResponse) SetBody(v *ModifyDBProxyEndpointResponseBody) *ModifyDBProxyEndpointResponse {
	s.Body = v
	return s
}

type ModifyDBProxyEndpointAddressRequest struct {
	// The instance ID. You can call the DescribeDBInstances operation to query the instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The network type of the proxy endpoint. Valid values:
	//
	// *   **Public**: Internet
	// *   **VPC**: virtual private cloud (VPC)
	// *   **Classic**: classic network
	//
	// If the instance runs MySQL, the default value of this parameter is **Classic**.
	//
	// > If the instance runs PostgreSQL, you must set this parameter to **Public** or **VPC**.
	DBProxyConnectStringNetType *string `json:"DBProxyConnectStringNetType,omitempty" xml:"DBProxyConnectStringNetType,omitempty"`
	// The ID of the dedicated proxy endpoint. You can call the DescribeDBProxyEndpoint operation to query the ID of the proxy endpoint.
	DBProxyEndpointId *string `json:"DBProxyEndpointId,omitempty" xml:"DBProxyEndpointId,omitempty"`
	// A reserved parameter. You do not need to specify this parameter.
	DBProxyEngineType *string `json:"DBProxyEngineType,omitempty" xml:"DBProxyEngineType,omitempty"`
	// The new prefix of the proxy endpoint. Enter a prefix.
	//
	// > You must specify at least one of the **DBProxyNewConnectString** and **DBProxyNewConnectStringPort** parameters.
	DBProxyNewConnectString *string `json:"DBProxyNewConnectString,omitempty" xml:"DBProxyNewConnectString,omitempty"`
	// The port number that is associated with the proxy endpoint. Enter a port number.
	//
	// > You must specify at least one of the **DBProxyNewConnectString** and **DBProxyNewConnectStringPort** parameters.
	DBProxyNewConnectStringPort *string `json:"DBProxyNewConnectStringPort,omitempty" xml:"DBProxyNewConnectStringPort,omitempty"`
	OwnerId                     *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount        *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId             *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ModifyDBProxyEndpointAddressRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBProxyEndpointAddressRequest) GoString() string {
	return s.String()
}

func (s *ModifyDBProxyEndpointAddressRequest) SetDBInstanceId(v string) *ModifyDBProxyEndpointAddressRequest {
	s.DBInstanceId = &v
	return s
}

func (s *ModifyDBProxyEndpointAddressRequest) SetDBProxyConnectStringNetType(v string) *ModifyDBProxyEndpointAddressRequest {
	s.DBProxyConnectStringNetType = &v
	return s
}

func (s *ModifyDBProxyEndpointAddressRequest) SetDBProxyEndpointId(v string) *ModifyDBProxyEndpointAddressRequest {
	s.DBProxyEndpointId = &v
	return s
}

func (s *ModifyDBProxyEndpointAddressRequest) SetDBProxyEngineType(v string) *ModifyDBProxyEndpointAddressRequest {
	s.DBProxyEngineType = &v
	return s
}

func (s *ModifyDBProxyEndpointAddressRequest) SetDBProxyNewConnectString(v string) *ModifyDBProxyEndpointAddressRequest {
	s.DBProxyNewConnectString = &v
	return s
}

func (s *ModifyDBProxyEndpointAddressRequest) SetDBProxyNewConnectStringPort(v string) *ModifyDBProxyEndpointAddressRequest {
	s.DBProxyNewConnectStringPort = &v
	return s
}

func (s *ModifyDBProxyEndpointAddressRequest) SetOwnerId(v int64) *ModifyDBProxyEndpointAddressRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyDBProxyEndpointAddressRequest) SetResourceOwnerAccount(v string) *ModifyDBProxyEndpointAddressRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyDBProxyEndpointAddressRequest) SetResourceOwnerId(v int64) *ModifyDBProxyEndpointAddressRequest {
	s.ResourceOwnerId = &v
	return s
}

type ModifyDBProxyEndpointAddressResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyDBProxyEndpointAddressResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBProxyEndpointAddressResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyDBProxyEndpointAddressResponseBody) SetRequestId(v string) *ModifyDBProxyEndpointAddressResponseBody {
	s.RequestId = &v
	return s
}

type ModifyDBProxyEndpointAddressResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyDBProxyEndpointAddressResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyDBProxyEndpointAddressResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBProxyEndpointAddressResponse) GoString() string {
	return s.String()
}

func (s *ModifyDBProxyEndpointAddressResponse) SetHeaders(v map[string]*string) *ModifyDBProxyEndpointAddressResponse {
	s.Headers = v
	return s
}

func (s *ModifyDBProxyEndpointAddressResponse) SetStatusCode(v int32) *ModifyDBProxyEndpointAddressResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyDBProxyEndpointAddressResponse) SetBody(v *ModifyDBProxyEndpointAddressResponseBody) *ModifyDBProxyEndpointAddressResponse {
	s.Body = v
	return s
}

type ModifyDBProxyInstanceRequest struct {
	// The ID of the instance. You can call the [DescribeDBInstances](~~26232~~) operation to query the ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// An internal parameter. You do not need to specify this parameter.
	DBProxyEngineType *string `json:"DBProxyEngineType,omitempty" xml:"DBProxyEngineType,omitempty"`
	// The number of proxy instances that are enabled. If the value of this parameter is 0, the database proxy feature is disabled for the instance. Valid values: **1** to **60**.
	//
	// >  The capability of the database proxy to process requests increases with the number of proxy instances that are enabled. You can monitor the load on the instance and specify an appropriate number of proxy instances based on the load monitoring data.
	DBProxyInstanceNum *string `json:"DBProxyInstanceNum,omitempty" xml:"DBProxyInstanceNum,omitempty"`
	// The type of database proxy that is enabled for the instance. Set the value to **DedicatedProxy**.
	DBProxyInstanceType *string `json:"DBProxyInstanceType,omitempty" xml:"DBProxyInstanceType,omitempty"`
	// The point in time at which you want to apply the new database proxy settings. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
	//
	// >  If you set the **EffectiveTime** parameter to **SpecificTime**, you must specify the EffectiveSpecificTime parameter.
	EffectiveSpecificTime *string `json:"EffectiveSpecificTime,omitempty" xml:"EffectiveSpecificTime,omitempty"`
	// The time when you want to apply the new database proxy settings. Valid values:
	//
	// *   **Immediate**: ApsaraDB RDS immediately applies the new settings.
	// *   **MaintainTime**: ApsaraDB RDS applies the new settings during the maintenance window that you specified. For more information, see [Modify the maintenance window](~~26249~~).
	// *   **SpecificTime**: ApsaraDB RDS applies the new settings at a specified point in time.
	//
	// Default value: **MaintainTime**.
	EffectiveTime *string `json:"EffectiveTime,omitempty" xml:"EffectiveTime,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region where the instance resides. You can call the [DescribeRegions](~~26243~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ModifyDBProxyInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBProxyInstanceRequest) GoString() string {
	return s.String()
}

func (s *ModifyDBProxyInstanceRequest) SetDBInstanceId(v string) *ModifyDBProxyInstanceRequest {
	s.DBInstanceId = &v
	return s
}

func (s *ModifyDBProxyInstanceRequest) SetDBProxyEngineType(v string) *ModifyDBProxyInstanceRequest {
	s.DBProxyEngineType = &v
	return s
}

func (s *ModifyDBProxyInstanceRequest) SetDBProxyInstanceNum(v string) *ModifyDBProxyInstanceRequest {
	s.DBProxyInstanceNum = &v
	return s
}

func (s *ModifyDBProxyInstanceRequest) SetDBProxyInstanceType(v string) *ModifyDBProxyInstanceRequest {
	s.DBProxyInstanceType = &v
	return s
}

func (s *ModifyDBProxyInstanceRequest) SetEffectiveSpecificTime(v string) *ModifyDBProxyInstanceRequest {
	s.EffectiveSpecificTime = &v
	return s
}

func (s *ModifyDBProxyInstanceRequest) SetEffectiveTime(v string) *ModifyDBProxyInstanceRequest {
	s.EffectiveTime = &v
	return s
}

func (s *ModifyDBProxyInstanceRequest) SetOwnerId(v int64) *ModifyDBProxyInstanceRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyDBProxyInstanceRequest) SetRegionId(v string) *ModifyDBProxyInstanceRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyDBProxyInstanceRequest) SetResourceOwnerAccount(v string) *ModifyDBProxyInstanceRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyDBProxyInstanceRequest) SetResourceOwnerId(v int64) *ModifyDBProxyInstanceRequest {
	s.ResourceOwnerId = &v
	return s
}

type ModifyDBProxyInstanceResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyDBProxyInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBProxyInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyDBProxyInstanceResponseBody) SetRequestId(v string) *ModifyDBProxyInstanceResponseBody {
	s.RequestId = &v
	return s
}

type ModifyDBProxyInstanceResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyDBProxyInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyDBProxyInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyDBProxyInstanceResponse) GoString() string {
	return s.String()
}

func (s *ModifyDBProxyInstanceResponse) SetHeaders(v map[string]*string) *ModifyDBProxyInstanceResponse {
	s.Headers = v
	return s
}

func (s *ModifyDBProxyInstanceResponse) SetStatusCode(v int32) *ModifyDBProxyInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyDBProxyInstanceResponse) SetBody(v *ModifyDBProxyInstanceResponseBody) *ModifyDBProxyInstanceResponse {
	s.Body = v
	return s
}

type ModifyDTCSecurityIpHostsForSQLServerRequest struct {
	// The ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region. You can call the [DescribeRegions](~~26243~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The IP address of the ECS instance and the hostname of the Windows computer. Format: IP address,Hostname. Multiple values are separated with semicolons (;).
	//
	// >  For more information about how to query the computer hostname, see [Configure a distributed transaction whitelist](~~124321~~).
	SecurityIpHosts *string `json:"SecurityIpHosts,omitempty" xml:"SecurityIpHosts,omitempty"`
	SecurityToken   *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
	// The name of the whitelist.
	WhiteListGroupName *string `json:"WhiteListGroupName,omitempty" xml:"WhiteListGroupName,omitempty"`
}

func (s ModifyDTCSecurityIpHostsForSQLServerRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyDTCSecurityIpHostsForSQLServerRequest) GoString() string {
	return s.String()
}

func (s *ModifyDTCSecurityIpHostsForSQLServerRequest) SetDBInstanceId(v string) *ModifyDTCSecurityIpHostsForSQLServerRequest {
	s.DBInstanceId = &v
	return s
}

func (s *ModifyDTCSecurityIpHostsForSQLServerRequest) SetOwnerAccount(v string) *ModifyDTCSecurityIpHostsForSQLServerRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyDTCSecurityIpHostsForSQLServerRequest) SetOwnerId(v int64) *ModifyDTCSecurityIpHostsForSQLServerRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyDTCSecurityIpHostsForSQLServerRequest) SetRegionId(v string) *ModifyDTCSecurityIpHostsForSQLServerRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyDTCSecurityIpHostsForSQLServerRequest) SetResourceOwnerAccount(v string) *ModifyDTCSecurityIpHostsForSQLServerRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyDTCSecurityIpHostsForSQLServerRequest) SetResourceOwnerId(v int64) *ModifyDTCSecurityIpHostsForSQLServerRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ModifyDTCSecurityIpHostsForSQLServerRequest) SetSecurityIpHosts(v string) *ModifyDTCSecurityIpHostsForSQLServerRequest {
	s.SecurityIpHosts = &v
	return s
}

func (s *ModifyDTCSecurityIpHostsForSQLServerRequest) SetSecurityToken(v string) *ModifyDTCSecurityIpHostsForSQLServerRequest {
	s.SecurityToken = &v
	return s
}

func (s *ModifyDTCSecurityIpHostsForSQLServerRequest) SetWhiteListGroupName(v string) *ModifyDTCSecurityIpHostsForSQLServerRequest {
	s.WhiteListGroupName = &v
	return s
}

type ModifyDTCSecurityIpHostsForSQLServerResponseBody struct {
	// The ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The result of the whitelist configuration. Valid values:
	//
	// *   **Success**
	// *   **Fail**
	DTCSetResult *string `json:"DTCSetResult,omitempty" xml:"DTCSetResult,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the task.
	TaskId *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
}

func (s ModifyDTCSecurityIpHostsForSQLServerResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyDTCSecurityIpHostsForSQLServerResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyDTCSecurityIpHostsForSQLServerResponseBody) SetDBInstanceId(v string) *ModifyDTCSecurityIpHostsForSQLServerResponseBody {
	s.DBInstanceId = &v
	return s
}

func (s *ModifyDTCSecurityIpHostsForSQLServerResponseBody) SetDTCSetResult(v string) *ModifyDTCSecurityIpHostsForSQLServerResponseBody {
	s.DTCSetResult = &v
	return s
}

func (s *ModifyDTCSecurityIpHostsForSQLServerResponseBody) SetRequestId(v string) *ModifyDTCSecurityIpHostsForSQLServerResponseBody {
	s.RequestId = &v
	return s
}

func (s *ModifyDTCSecurityIpHostsForSQLServerResponseBody) SetTaskId(v string) *ModifyDTCSecurityIpHostsForSQLServerResponseBody {
	s.TaskId = &v
	return s
}

type ModifyDTCSecurityIpHostsForSQLServerResponse struct {
	Headers    map[string]*string                                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyDTCSecurityIpHostsForSQLServerResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyDTCSecurityIpHostsForSQLServerResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyDTCSecurityIpHostsForSQLServerResponse) GoString() string {
	return s.String()
}

func (s *ModifyDTCSecurityIpHostsForSQLServerResponse) SetHeaders(v map[string]*string) *ModifyDTCSecurityIpHostsForSQLServerResponse {
	s.Headers = v
	return s
}

func (s *ModifyDTCSecurityIpHostsForSQLServerResponse) SetStatusCode(v int32) *ModifyDTCSecurityIpHostsForSQLServerResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyDTCSecurityIpHostsForSQLServerResponse) SetBody(v *ModifyDTCSecurityIpHostsForSQLServerResponseBody) *ModifyDTCSecurityIpHostsForSQLServerResponse {
	s.Body = v
	return s
}

type ModifyDasInstanceConfigRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the generated token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The instance ID. You can call the DescribeDBInstances operation to query the instance ID.
	DBInstanceId         *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// Specifies whether to enable automatic storage expansion. Valid values:
	//
	// *   **Enable**
	// *   **Disable**
	StorageAutoScale *string `json:"StorageAutoScale,omitempty" xml:"StorageAutoScale,omitempty"`
	// The threshold in percentage based on which an automatic storage expansion is triggered. If the available storage reaches the threshold, ApsaraDB RDS increases the storage capacity of the instance. Valid values:
	//
	// *   **10**
	// *   **20**
	// *   **30**
	// *   **40**
	// *   **50**
	//
	// >  If you set the StorageAutoScale parameter to **Enable**, you must specify this parameter.
	StorageThreshold *int32 `json:"StorageThreshold,omitempty" xml:"StorageThreshold,omitempty"`
	// The maximum storage capacity that is allowed for an automatic storage expansion. The value of this parameter must be greater than or equal to the current storage capacity of the RDS instance.
	//
	// *   If the RDS instance uses ESSDs, the maximum value of this parameter can be set to 32000 GB.
	// *   If the RDS instance uses standard SSDs, the maximum value of this parameter can be set to 6000 GB.
	//
	// >  If you set the **StorageAutoScale** parameter to **Enable**, you must specify this parameter.
	StorageUpperBound *int32 `json:"StorageUpperBound,omitempty" xml:"StorageUpperBound,omitempty"`
}

func (s ModifyDasInstanceConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyDasInstanceConfigRequest) GoString() string {
	return s.String()
}

func (s *ModifyDasInstanceConfigRequest) SetClientToken(v string) *ModifyDasInstanceConfigRequest {
	s.ClientToken = &v
	return s
}

func (s *ModifyDasInstanceConfigRequest) SetDBInstanceId(v string) *ModifyDasInstanceConfigRequest {
	s.DBInstanceId = &v
	return s
}

func (s *ModifyDasInstanceConfigRequest) SetOwnerId(v int64) *ModifyDasInstanceConfigRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyDasInstanceConfigRequest) SetResourceOwnerAccount(v string) *ModifyDasInstanceConfigRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyDasInstanceConfigRequest) SetResourceOwnerId(v int64) *ModifyDasInstanceConfigRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ModifyDasInstanceConfigRequest) SetStorageAutoScale(v string) *ModifyDasInstanceConfigRequest {
	s.StorageAutoScale = &v
	return s
}

func (s *ModifyDasInstanceConfigRequest) SetStorageThreshold(v int32) *ModifyDasInstanceConfigRequest {
	s.StorageThreshold = &v
	return s
}

func (s *ModifyDasInstanceConfigRequest) SetStorageUpperBound(v int32) *ModifyDasInstanceConfigRequest {
	s.StorageUpperBound = &v
	return s
}

type ModifyDasInstanceConfigResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyDasInstanceConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyDasInstanceConfigResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyDasInstanceConfigResponseBody) SetRequestId(v string) *ModifyDasInstanceConfigResponseBody {
	s.RequestId = &v
	return s
}

type ModifyDasInstanceConfigResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyDasInstanceConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyDasInstanceConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyDasInstanceConfigResponse) GoString() string {
	return s.String()
}

func (s *ModifyDasInstanceConfigResponse) SetHeaders(v map[string]*string) *ModifyDasInstanceConfigResponse {
	s.Headers = v
	return s
}

func (s *ModifyDasInstanceConfigResponse) SetStatusCode(v int32) *ModifyDasInstanceConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyDasInstanceConfigResponse) SetBody(v *ModifyDasInstanceConfigResponseBody) *ModifyDasInstanceConfigResponse {
	s.Body = v
	return s
}

type ModifyDatabaseConfigRequest struct {
	// The instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The database name.
	//
	// >  You can specify only one database name.
	DBName *string `json:"DBName,omitempty" xml:"DBName,omitempty"`
	// The name of the database property that you want to modify.
	DatabasePropertyName *string `json:"DatabasePropertyName,omitempty" xml:"DatabasePropertyName,omitempty"`
	// The value of the database property that you want to modify.
	DatabasePropertyValue *string `json:"DatabasePropertyValue,omitempty" xml:"DatabasePropertyValue,omitempty"`
	OwnerAccount          *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId               *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount  *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId       *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ModifyDatabaseConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyDatabaseConfigRequest) GoString() string {
	return s.String()
}

func (s *ModifyDatabaseConfigRequest) SetDBInstanceId(v string) *ModifyDatabaseConfigRequest {
	s.DBInstanceId = &v
	return s
}

func (s *ModifyDatabaseConfigRequest) SetDBName(v string) *ModifyDatabaseConfigRequest {
	s.DBName = &v
	return s
}

func (s *ModifyDatabaseConfigRequest) SetDatabasePropertyName(v string) *ModifyDatabaseConfigRequest {
	s.DatabasePropertyName = &v
	return s
}

func (s *ModifyDatabaseConfigRequest) SetDatabasePropertyValue(v string) *ModifyDatabaseConfigRequest {
	s.DatabasePropertyValue = &v
	return s
}

func (s *ModifyDatabaseConfigRequest) SetOwnerAccount(v string) *ModifyDatabaseConfigRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyDatabaseConfigRequest) SetOwnerId(v int64) *ModifyDatabaseConfigRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyDatabaseConfigRequest) SetResourceOwnerAccount(v string) *ModifyDatabaseConfigRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyDatabaseConfigRequest) SetResourceOwnerId(v int64) *ModifyDatabaseConfigRequest {
	s.ResourceOwnerId = &v
	return s
}

type ModifyDatabaseConfigResponseBody struct {
	// The code.
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyDatabaseConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyDatabaseConfigResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyDatabaseConfigResponseBody) SetCode(v string) *ModifyDatabaseConfigResponseBody {
	s.Code = &v
	return s
}

func (s *ModifyDatabaseConfigResponseBody) SetMessage(v string) *ModifyDatabaseConfigResponseBody {
	s.Message = &v
	return s
}

func (s *ModifyDatabaseConfigResponseBody) SetRequestId(v string) *ModifyDatabaseConfigResponseBody {
	s.RequestId = &v
	return s
}

type ModifyDatabaseConfigResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyDatabaseConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyDatabaseConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyDatabaseConfigResponse) GoString() string {
	return s.String()
}

func (s *ModifyDatabaseConfigResponse) SetHeaders(v map[string]*string) *ModifyDatabaseConfigResponse {
	s.Headers = v
	return s
}

func (s *ModifyDatabaseConfigResponse) SetStatusCode(v int32) *ModifyDatabaseConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyDatabaseConfigResponse) SetBody(v *ModifyDatabaseConfigResponseBody) *ModifyDatabaseConfigResponse {
	s.Body = v
	return s
}

type ModifyDbProxyInstanceSslRequest struct {
	// A reserved parameter. You do not need to specify this parameter.
	DBProxyEngineType *string `json:"DBProxyEngineType,omitempty" xml:"DBProxyEngineType,omitempty"`
	// The instance ID. You can call the DescribeDBInstances operation to query the instance ID.
	DbInstanceId *string `json:"DbInstanceId,omitempty" xml:"DbInstanceId,omitempty"`
	// The dedicated proxy endpoint of the instance.
	DbProxyConnectString *string `json:"DbProxyConnectString,omitempty" xml:"DbProxyConnectString,omitempty"`
	// The ID of the proxy endpoint. You can call the DescribeDBProxyEndpoint operation to query the ID of the proxy endpoint.
	DbProxyEndpointId *string `json:"DbProxyEndpointId,omitempty" xml:"DbProxyEndpointId,omitempty"`
	// The SSL configuration setting that you want to apply on the instance. Valid values:
	//
	// *   0: disables SSL encryption.
	// *   1: enables SSL encryption or modifies the endpoint that requires SSL encryption.
	// *   2: updates the validity period of the SSL certificate.
	//
	// > This setting causes your instance to restart. Proceed with caution.
	DbProxySslEnabled *string `json:"DbProxySslEnabled,omitempty" xml:"DbProxySslEnabled,omitempty"`
	// The region ID. You can call the DescribeRegions operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s ModifyDbProxyInstanceSslRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyDbProxyInstanceSslRequest) GoString() string {
	return s.String()
}

func (s *ModifyDbProxyInstanceSslRequest) SetDBProxyEngineType(v string) *ModifyDbProxyInstanceSslRequest {
	s.DBProxyEngineType = &v
	return s
}

func (s *ModifyDbProxyInstanceSslRequest) SetDbInstanceId(v string) *ModifyDbProxyInstanceSslRequest {
	s.DbInstanceId = &v
	return s
}

func (s *ModifyDbProxyInstanceSslRequest) SetDbProxyConnectString(v string) *ModifyDbProxyInstanceSslRequest {
	s.DbProxyConnectString = &v
	return s
}

func (s *ModifyDbProxyInstanceSslRequest) SetDbProxyEndpointId(v string) *ModifyDbProxyInstanceSslRequest {
	s.DbProxyEndpointId = &v
	return s
}

func (s *ModifyDbProxyInstanceSslRequest) SetDbProxySslEnabled(v string) *ModifyDbProxyInstanceSslRequest {
	s.DbProxySslEnabled = &v
	return s
}

func (s *ModifyDbProxyInstanceSslRequest) SetRegionId(v string) *ModifyDbProxyInstanceSslRequest {
	s.RegionId = &v
	return s
}

type ModifyDbProxyInstanceSslResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyDbProxyInstanceSslResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyDbProxyInstanceSslResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyDbProxyInstanceSslResponseBody) SetRequestId(v string) *ModifyDbProxyInstanceSslResponseBody {
	s.RequestId = &v
	return s
}

type ModifyDbProxyInstanceSslResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyDbProxyInstanceSslResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyDbProxyInstanceSslResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyDbProxyInstanceSslResponse) GoString() string {
	return s.String()
}

func (s *ModifyDbProxyInstanceSslResponse) SetHeaders(v map[string]*string) *ModifyDbProxyInstanceSslResponse {
	s.Headers = v
	return s
}

func (s *ModifyDbProxyInstanceSslResponse) SetStatusCode(v int32) *ModifyDbProxyInstanceSslResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyDbProxyInstanceSslResponse) SetBody(v *ModifyDbProxyInstanceSslResponseBody) *ModifyDbProxyInstanceSslResponse {
	s.Body = v
	return s
}

type ModifyHADiagnoseConfigRequest struct {
	// The ID of the instance. You can call the [DescribeDBInstances](~~26232~~) operation to query the ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the instance. You can call the [DescribeRegions](~~26243~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The availability check method of the instance. Valid values:
	//
	// *   **SHORT**: Alibaba Cloud uses short-lived connections to check the availability of the instance.
	// *   **LONG**: Alibaba Cloud uses persistent connections to check the availability of the instance.
	TcpConnectionType *string `json:"TcpConnectionType,omitempty" xml:"TcpConnectionType,omitempty"`
}

func (s ModifyHADiagnoseConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyHADiagnoseConfigRequest) GoString() string {
	return s.String()
}

func (s *ModifyHADiagnoseConfigRequest) SetDBInstanceId(v string) *ModifyHADiagnoseConfigRequest {
	s.DBInstanceId = &v
	return s
}

func (s *ModifyHADiagnoseConfigRequest) SetOwnerId(v int64) *ModifyHADiagnoseConfigRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyHADiagnoseConfigRequest) SetRegionId(v string) *ModifyHADiagnoseConfigRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyHADiagnoseConfigRequest) SetResourceOwnerAccount(v string) *ModifyHADiagnoseConfigRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyHADiagnoseConfigRequest) SetResourceOwnerId(v int64) *ModifyHADiagnoseConfigRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ModifyHADiagnoseConfigRequest) SetTcpConnectionType(v string) *ModifyHADiagnoseConfigRequest {
	s.TcpConnectionType = &v
	return s
}

type ModifyHADiagnoseConfigResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyHADiagnoseConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyHADiagnoseConfigResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyHADiagnoseConfigResponseBody) SetRequestId(v string) *ModifyHADiagnoseConfigResponseBody {
	s.RequestId = &v
	return s
}

type ModifyHADiagnoseConfigResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyHADiagnoseConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyHADiagnoseConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyHADiagnoseConfigResponse) GoString() string {
	return s.String()
}

func (s *ModifyHADiagnoseConfigResponse) SetHeaders(v map[string]*string) *ModifyHADiagnoseConfigResponse {
	s.Headers = v
	return s
}

func (s *ModifyHADiagnoseConfigResponse) SetStatusCode(v int32) *ModifyHADiagnoseConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyHADiagnoseConfigResponse) SetBody(v *ModifyHADiagnoseConfigResponseBody) *ModifyHADiagnoseConfigResponse {
	s.Body = v
	return s
}

type ModifyHASwitchConfigRequest struct {
	// The instance ID. You can call the [DescribeDBInstances](~~610396~~) operation to query the instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The mode of the automatic primary/secondary switchover feature. Valid values:
	//
	// *   **Auto**: The automatic primary/secondary switchover feature is enabled. The system automatically switches your workloads over from the instance to its secondary instance in the event of a fault.
	// *   **Manual**: The automatic primary/secondary switchover feature is disabled. You must manually switch your workloads over from the instance to its secondary instance in the event of a fault.
	//
	// Default value: **Auto**.
	//
	// >  If you set this parameter to **Manual**, you must specify the **ManualHATime** parameter.
	HAConfig *string `json:"HAConfig,omitempty" xml:"HAConfig,omitempty"`
	// The time to disable the automatic primary/secondary switchover feature. The time can range from the current time to 23:59:59 seven days later. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
	//
	// >  This parameter takes effect only when you set the **HAConfig** parameter to **Manual**.
	ManualHATime *string `json:"ManualHATime,omitempty" xml:"ManualHATime,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the instance. You can call the [DescribeRegions](~~26243~~) operation to query most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ModifyHASwitchConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyHASwitchConfigRequest) GoString() string {
	return s.String()
}

func (s *ModifyHASwitchConfigRequest) SetDBInstanceId(v string) *ModifyHASwitchConfigRequest {
	s.DBInstanceId = &v
	return s
}

func (s *ModifyHASwitchConfigRequest) SetHAConfig(v string) *ModifyHASwitchConfigRequest {
	s.HAConfig = &v
	return s
}

func (s *ModifyHASwitchConfigRequest) SetManualHATime(v string) *ModifyHASwitchConfigRequest {
	s.ManualHATime = &v
	return s
}

func (s *ModifyHASwitchConfigRequest) SetOwnerId(v int64) *ModifyHASwitchConfigRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyHASwitchConfigRequest) SetRegionId(v string) *ModifyHASwitchConfigRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyHASwitchConfigRequest) SetResourceOwnerAccount(v string) *ModifyHASwitchConfigRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyHASwitchConfigRequest) SetResourceOwnerId(v int64) *ModifyHASwitchConfigRequest {
	s.ResourceOwnerId = &v
	return s
}

type ModifyHASwitchConfigResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyHASwitchConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyHASwitchConfigResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyHASwitchConfigResponseBody) SetRequestId(v string) *ModifyHASwitchConfigResponseBody {
	s.RequestId = &v
	return s
}

type ModifyHASwitchConfigResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyHASwitchConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyHASwitchConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyHASwitchConfigResponse) GoString() string {
	return s.String()
}

func (s *ModifyHASwitchConfigResponse) SetHeaders(v map[string]*string) *ModifyHASwitchConfigResponse {
	s.Headers = v
	return s
}

func (s *ModifyHASwitchConfigResponse) SetStatusCode(v int32) *ModifyHASwitchConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyHASwitchConfigResponse) SetBody(v *ModifyHASwitchConfigResponseBody) *ModifyHASwitchConfigResponse {
	s.Body = v
	return s
}

type ModifyInstanceAutoRenewalAttributeRequest struct {
	// Specifies whether to enable or disable auto-renewal. Valid values: **True and False**.
	AutoRenew *string `json:"AutoRenew,omitempty" xml:"AutoRenew,omitempty"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The number of months for auto-renewal. Valid values: **1 to 12**.
	//
	// >  You must specify this parameter if you set the** AutoRenew **parameter to** True**.
	Duration     *string `json:"Duration,omitempty" xml:"Duration,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the instance. You can call the [DescribeRegions](~~26243~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ModifyInstanceAutoRenewalAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyInstanceAutoRenewalAttributeRequest) GoString() string {
	return s.String()
}

func (s *ModifyInstanceAutoRenewalAttributeRequest) SetAutoRenew(v string) *ModifyInstanceAutoRenewalAttributeRequest {
	s.AutoRenew = &v
	return s
}

func (s *ModifyInstanceAutoRenewalAttributeRequest) SetClientToken(v string) *ModifyInstanceAutoRenewalAttributeRequest {
	s.ClientToken = &v
	return s
}

func (s *ModifyInstanceAutoRenewalAttributeRequest) SetDBInstanceId(v string) *ModifyInstanceAutoRenewalAttributeRequest {
	s.DBInstanceId = &v
	return s
}

func (s *ModifyInstanceAutoRenewalAttributeRequest) SetDuration(v string) *ModifyInstanceAutoRenewalAttributeRequest {
	s.Duration = &v
	return s
}

func (s *ModifyInstanceAutoRenewalAttributeRequest) SetOwnerAccount(v string) *ModifyInstanceAutoRenewalAttributeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyInstanceAutoRenewalAttributeRequest) SetOwnerId(v int64) *ModifyInstanceAutoRenewalAttributeRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyInstanceAutoRenewalAttributeRequest) SetRegionId(v string) *ModifyInstanceAutoRenewalAttributeRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyInstanceAutoRenewalAttributeRequest) SetResourceOwnerAccount(v string) *ModifyInstanceAutoRenewalAttributeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyInstanceAutoRenewalAttributeRequest) SetResourceOwnerId(v int64) *ModifyInstanceAutoRenewalAttributeRequest {
	s.ResourceOwnerId = &v
	return s
}

type ModifyInstanceAutoRenewalAttributeResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyInstanceAutoRenewalAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyInstanceAutoRenewalAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyInstanceAutoRenewalAttributeResponseBody) SetRequestId(v string) *ModifyInstanceAutoRenewalAttributeResponseBody {
	s.RequestId = &v
	return s
}

type ModifyInstanceAutoRenewalAttributeResponse struct {
	Headers    map[string]*string                              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyInstanceAutoRenewalAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyInstanceAutoRenewalAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyInstanceAutoRenewalAttributeResponse) GoString() string {
	return s.String()
}

func (s *ModifyInstanceAutoRenewalAttributeResponse) SetHeaders(v map[string]*string) *ModifyInstanceAutoRenewalAttributeResponse {
	s.Headers = v
	return s
}

func (s *ModifyInstanceAutoRenewalAttributeResponse) SetStatusCode(v int32) *ModifyInstanceAutoRenewalAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyInstanceAutoRenewalAttributeResponse) SetBody(v *ModifyInstanceAutoRenewalAttributeResponseBody) *ModifyInstanceAutoRenewalAttributeResponse {
	s.Body = v
	return s
}

type ModifyInstanceCrossBackupPolicyRequest struct {
	// Specifies whether to enable the cross-region backup feature on the instance. This parameter specifies whether you can back up data and logs. Valid values:
	//
	// *   **0**: disables the feature.
	// *   **1:** enables the feature.
	//
	// > Before you enable the cross-region backup feature, you must configure the CrossBackupRegion parameter.
	BackupEnabled *string `json:"BackupEnabled,omitempty" xml:"BackupEnabled,omitempty"`
	// The ID of the region in which the cross-region backup files of the instance are stored.
	CrossBackupRegion *string `json:"CrossBackupRegion,omitempty" xml:"CrossBackupRegion,omitempty"`
	// The policy that is used to save the cross-region backup files of the instance. Set the value to **1**. The value 1 specifies that all cross-region backup files are saved.
	CrossBackupType *string `json:"CrossBackupType,omitempty" xml:"CrossBackupType,omitempty"`
	// The ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// Specifies whether to enable the cross-region log backup feature on the instance. Valid values:
	//
	// *   **0**: disables the feature.
	// *   **1:** enables the feature.
	//
	// > You can enable the cross-region log backup feature only when the cross-region backup feature is enabled.
	LogBackupEnabled *string `json:"LogBackupEnabled,omitempty" xml:"LogBackupEnabled,omitempty"`
	OwnerId          *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region to which the source instance belongs. You can call the [DescribeRegions](~~26243~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The policy that is used to retain the cross-region backup files of the instance. Set the value to 1. The value **1** specifies that the cross-region backup files of the instance are retained based on the specified retention period.
	RetentType *int32 `json:"RetentType,omitempty" xml:"RetentType,omitempty"`
	// The number of days for which the cross-region backup files of the instance are retained. Valid values: **7 to 1825**.
	Retention *int32 `json:"Retention,omitempty" xml:"Retention,omitempty"`
}

func (s ModifyInstanceCrossBackupPolicyRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyInstanceCrossBackupPolicyRequest) GoString() string {
	return s.String()
}

func (s *ModifyInstanceCrossBackupPolicyRequest) SetBackupEnabled(v string) *ModifyInstanceCrossBackupPolicyRequest {
	s.BackupEnabled = &v
	return s
}

func (s *ModifyInstanceCrossBackupPolicyRequest) SetCrossBackupRegion(v string) *ModifyInstanceCrossBackupPolicyRequest {
	s.CrossBackupRegion = &v
	return s
}

func (s *ModifyInstanceCrossBackupPolicyRequest) SetCrossBackupType(v string) *ModifyInstanceCrossBackupPolicyRequest {
	s.CrossBackupType = &v
	return s
}

func (s *ModifyInstanceCrossBackupPolicyRequest) SetDBInstanceId(v string) *ModifyInstanceCrossBackupPolicyRequest {
	s.DBInstanceId = &v
	return s
}

func (s *ModifyInstanceCrossBackupPolicyRequest) SetLogBackupEnabled(v string) *ModifyInstanceCrossBackupPolicyRequest {
	s.LogBackupEnabled = &v
	return s
}

func (s *ModifyInstanceCrossBackupPolicyRequest) SetOwnerId(v int64) *ModifyInstanceCrossBackupPolicyRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyInstanceCrossBackupPolicyRequest) SetRegionId(v string) *ModifyInstanceCrossBackupPolicyRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyInstanceCrossBackupPolicyRequest) SetResourceOwnerAccount(v string) *ModifyInstanceCrossBackupPolicyRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyInstanceCrossBackupPolicyRequest) SetResourceOwnerId(v int64) *ModifyInstanceCrossBackupPolicyRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ModifyInstanceCrossBackupPolicyRequest) SetRetentType(v int32) *ModifyInstanceCrossBackupPolicyRequest {
	s.RetentType = &v
	return s
}

func (s *ModifyInstanceCrossBackupPolicyRequest) SetRetention(v int32) *ModifyInstanceCrossBackupPolicyRequest {
	s.Retention = &v
	return s
}

type ModifyInstanceCrossBackupPolicyResponseBody struct {
	// The status of the cross-region backup feature on the instance. Valid values:
	//
	// *   **Disable**
	// *   **Enable**
	BackupEnabled *string `json:"BackupEnabled,omitempty" xml:"BackupEnabled,omitempty"`
	// The ID of the region in which the cross-region backup files of the instance are stored.
	CrossBackupRegion *string `json:"CrossBackupRegion,omitempty" xml:"CrossBackupRegion,omitempty"`
	// The policy that is used to save the cross-region backup files of the instance. Default value: **1**. The value 1 indicates that all cross-region backup files are saved.
	CrossBackupType *string `json:"CrossBackupType,omitempty" xml:"CrossBackupType,omitempty"`
	// The ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The status of the cross-region log backup feature on the instance. Valid values:
	//
	// *   **Disable**
	// *   **Enable**
	LogBackupEnabled *string `json:"LogBackupEnabled,omitempty" xml:"LogBackupEnabled,omitempty"`
	// The region ID of the source instance. You can call the [DescribeRegions](~~26243~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The policy that is used to retain the cross-region backup files of the instance. Default value: **1**. The value 1 indicates that the cross-region backup files of the instance are retained based on the specified retention period.
	RetentType *int32 `json:"RetentType,omitempty" xml:"RetentType,omitempty"`
	// The number of days for which the cross-region backup files of the instance are retained. Valid values: **7 to 1825**.
	Retention *int32 `json:"Retention,omitempty" xml:"Retention,omitempty"`
}

func (s ModifyInstanceCrossBackupPolicyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyInstanceCrossBackupPolicyResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyInstanceCrossBackupPolicyResponseBody) SetBackupEnabled(v string) *ModifyInstanceCrossBackupPolicyResponseBody {
	s.BackupEnabled = &v
	return s
}

func (s *ModifyInstanceCrossBackupPolicyResponseBody) SetCrossBackupRegion(v string) *ModifyInstanceCrossBackupPolicyResponseBody {
	s.CrossBackupRegion = &v
	return s
}

func (s *ModifyInstanceCrossBackupPolicyResponseBody) SetCrossBackupType(v string) *ModifyInstanceCrossBackupPolicyResponseBody {
	s.CrossBackupType = &v
	return s
}

func (s *ModifyInstanceCrossBackupPolicyResponseBody) SetDBInstanceId(v string) *ModifyInstanceCrossBackupPolicyResponseBody {
	s.DBInstanceId = &v
	return s
}

func (s *ModifyInstanceCrossBackupPolicyResponseBody) SetLogBackupEnabled(v string) *ModifyInstanceCrossBackupPolicyResponseBody {
	s.LogBackupEnabled = &v
	return s
}

func (s *ModifyInstanceCrossBackupPolicyResponseBody) SetRegionId(v string) *ModifyInstanceCrossBackupPolicyResponseBody {
	s.RegionId = &v
	return s
}

func (s *ModifyInstanceCrossBackupPolicyResponseBody) SetRequestId(v string) *ModifyInstanceCrossBackupPolicyResponseBody {
	s.RequestId = &v
	return s
}

func (s *ModifyInstanceCrossBackupPolicyResponseBody) SetRetentType(v int32) *ModifyInstanceCrossBackupPolicyResponseBody {
	s.RetentType = &v
	return s
}

func (s *ModifyInstanceCrossBackupPolicyResponseBody) SetRetention(v int32) *ModifyInstanceCrossBackupPolicyResponseBody {
	s.Retention = &v
	return s
}

type ModifyInstanceCrossBackupPolicyResponse struct {
	Headers    map[string]*string                           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyInstanceCrossBackupPolicyResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyInstanceCrossBackupPolicyResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyInstanceCrossBackupPolicyResponse) GoString() string {
	return s.String()
}

func (s *ModifyInstanceCrossBackupPolicyResponse) SetHeaders(v map[string]*string) *ModifyInstanceCrossBackupPolicyResponse {
	s.Headers = v
	return s
}

func (s *ModifyInstanceCrossBackupPolicyResponse) SetStatusCode(v int32) *ModifyInstanceCrossBackupPolicyResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyInstanceCrossBackupPolicyResponse) SetBody(v *ModifyInstanceCrossBackupPolicyResponseBody) *ModifyInstanceCrossBackupPolicyResponse {
	s.Body = v
	return s
}

type ModifyPGHbaConfigRequest struct {
	// A reserved parameter. You do not need to specify this parameter.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The instance ID. You can call the DescribeDBInstances operation to query the instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// An array that consists of the details of the AD domain services.
	HbaItem []*ModifyPGHbaConfigRequestHbaItem `json:"HbaItem,omitempty" xml:"HbaItem,omitempty" type:"Repeated"`
	// The method that you use to modify the pg_hba.conf file. Valid values:
	//
	// *   **add**: adds one or more records. If you use this method, make sure that the value of the PriorityId parameter for each new record is different from the value of the PriorityId parameter for any existing record.
	// *   **delete**: deletes one or more records. If you use this method, the record that corresponds to the specified value of the **PriorityId** parameter is deleted from the pg_hba.conf file.
	// *   **modify**: modifies one or more records. If you use this method, the record that corresponds to the specified value of the **PriorityId** parameter is modified.
	// *   **update**: overwrites the existing configuration in the pg_hba.conf file by using the new configuration.
	OpsType              *string `json:"OpsType,omitempty" xml:"OpsType,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ModifyPGHbaConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyPGHbaConfigRequest) GoString() string {
	return s.String()
}

func (s *ModifyPGHbaConfigRequest) SetClientToken(v string) *ModifyPGHbaConfigRequest {
	s.ClientToken = &v
	return s
}

func (s *ModifyPGHbaConfigRequest) SetDBInstanceId(v string) *ModifyPGHbaConfigRequest {
	s.DBInstanceId = &v
	return s
}

func (s *ModifyPGHbaConfigRequest) SetHbaItem(v []*ModifyPGHbaConfigRequestHbaItem) *ModifyPGHbaConfigRequest {
	s.HbaItem = v
	return s
}

func (s *ModifyPGHbaConfigRequest) SetOpsType(v string) *ModifyPGHbaConfigRequest {
	s.OpsType = &v
	return s
}

func (s *ModifyPGHbaConfigRequest) SetOwnerAccount(v string) *ModifyPGHbaConfigRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyPGHbaConfigRequest) SetOwnerId(v int64) *ModifyPGHbaConfigRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyPGHbaConfigRequest) SetResourceOwnerAccount(v string) *ModifyPGHbaConfigRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyPGHbaConfigRequest) SetResourceOwnerId(v int64) *ModifyPGHbaConfigRequest {
	s.ResourceOwnerId = &v
	return s
}

type ModifyPGHbaConfigRequestHbaItem struct {
	// The IP addresses from which the specified users can access the specified databases. If you set this parameter to 0.0.0.0/0, the specified users are allowed to access the specified databases from all IP addresses.
	Address *string `json:"Address,omitempty" xml:"Address,omitempty"`
	// The name of the database. If you set this parameter to all, the specified users are allowed to access all databases on the instance.
	//
	// If you specify multiple entries, separate the entries with commas (,).
	Database *string `json:"Database,omitempty" xml:"Database,omitempty"`
	// The mask of the IP address. If the value of the **Address** parameter is an IP address, you can use this parameter to specify the mask of the IP address.
	Mask *string `json:"Mask,omitempty" xml:"Mask,omitempty"`
	// The authentication method. Valid values:
	//
	// *   **trust**
	// *   **reject**
	// *   **scram-sha-256**
	// *   **md5**
	// *   **password**
	// *   **gss**
	// *   **sspi**
	// *   **ldap**
	// *   **radius**
	// *   **cert**
	// *   **pam**
	Method *string `json:"Method,omitempty" xml:"Method,omitempty"`
	// The options of the authentication method. In this topic, LDAP is used as an example. You must configure this parameter. For more information, see [Authentication Methods](https://www.postgresql.org/docs/11/auth-methods.html).
	Option *string `json:"Option,omitempty" xml:"Option,omitempty"`
	// The priority of the record. If you set this parameter to 0, the record has the highest priority. Valid values: 0 to 10000.
	//
	// This parameter is used to identify each record. When you add a record, the value of the PriorityId parameter for the new record must be different from the value of the PriorityId parameter of any existing record. When you modify or delete a record, you must also modify or delete the value of the PriorityId parameter for this record.
	PriorityId *int32 `json:"PriorityId,omitempty" xml:"PriorityId,omitempty"`
	// The connection type.
	//
	// Valid values:
	//
	// *   **host**: The record matches TCP/IP connections, including SSL connections and non-SSL connections.
	// *   **hostssl**: The record matches only TCP/IP connections that are established over SSL.
	// *   **hostnossl**: The record matches only TCP/IP connections that are not established over SSL connections.
	//
	// >  You can set this parameter to hostssl only when SSL encryption is enabled for the instance. For more information, see Configure SSL encryption for an ApsaraDB RDS for PostgreSQL instance.[](~~229518~~)
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The user who is allowed to access the specified databases. You must specify the user that is used to log on to the RDS instance. If you specify multiple entries, separate the entries with commas (,).
	User *string `json:"User,omitempty" xml:"User,omitempty"`
}

func (s ModifyPGHbaConfigRequestHbaItem) String() string {
	return tea.Prettify(s)
}

func (s ModifyPGHbaConfigRequestHbaItem) GoString() string {
	return s.String()
}

func (s *ModifyPGHbaConfigRequestHbaItem) SetAddress(v string) *ModifyPGHbaConfigRequestHbaItem {
	s.Address = &v
	return s
}

func (s *ModifyPGHbaConfigRequestHbaItem) SetDatabase(v string) *ModifyPGHbaConfigRequestHbaItem {
	s.Database = &v
	return s
}

func (s *ModifyPGHbaConfigRequestHbaItem) SetMask(v string) *ModifyPGHbaConfigRequestHbaItem {
	s.Mask = &v
	return s
}

func (s *ModifyPGHbaConfigRequestHbaItem) SetMethod(v string) *ModifyPGHbaConfigRequestHbaItem {
	s.Method = &v
	return s
}

func (s *ModifyPGHbaConfigRequestHbaItem) SetOption(v string) *ModifyPGHbaConfigRequestHbaItem {
	s.Option = &v
	return s
}

func (s *ModifyPGHbaConfigRequestHbaItem) SetPriorityId(v int32) *ModifyPGHbaConfigRequestHbaItem {
	s.PriorityId = &v
	return s
}

func (s *ModifyPGHbaConfigRequestHbaItem) SetType(v string) *ModifyPGHbaConfigRequestHbaItem {
	s.Type = &v
	return s
}

func (s *ModifyPGHbaConfigRequestHbaItem) SetUser(v string) *ModifyPGHbaConfigRequestHbaItem {
	s.User = &v
	return s
}

type ModifyPGHbaConfigResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyPGHbaConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyPGHbaConfigResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyPGHbaConfigResponseBody) SetRequestId(v string) *ModifyPGHbaConfigResponseBody {
	s.RequestId = &v
	return s
}

type ModifyPGHbaConfigResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyPGHbaConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyPGHbaConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyPGHbaConfigResponse) GoString() string {
	return s.String()
}

func (s *ModifyPGHbaConfigResponse) SetHeaders(v map[string]*string) *ModifyPGHbaConfigResponse {
	s.Headers = v
	return s
}

func (s *ModifyPGHbaConfigResponse) SetStatusCode(v int32) *ModifyPGHbaConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyPGHbaConfigResponse) SetBody(v *ModifyPGHbaConfigResponseBody) *ModifyPGHbaConfigResponse {
	s.Body = v
	return s
}

type ModifyParameterRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// Specifies whether to restart the instance for a new parameter value to take effect. Valid values:
	//
	// *   **true**: The system forcefully restarts the instance. If a new parameter value takes effect only after the instance restarts, you must set this parameter to true. Otherwise, the new parameter value cannot take effect.
	// *   **false**: The system does not forcefully restart the instance.
	//
	// Default value: **false**.
	Forcerestart *bool   `json:"Forcerestart,omitempty" xml:"Forcerestart,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the parameter template.
	//
	// > *   If you specify this parameter, you do not need to specify **Parameters**.
	// > *   If the parameter template can be applied only after the instance is restarted, you must specify **Forcerestart**.
	ParameterGroupId *string `json:"ParameterGroupId,omitempty" xml:"ParameterGroupId,omitempty"`
	// The JSON strings of parameters and their values. All the parameter values are of the string type. Format: {"Parameter name 1":"Parameter value 1","Parameter name 2":"Parameter value 2"...}. You can call the [DescribeParameterTemplates](~~26284~~) operation to query parameter names and values.
	//
	// > If you specify this parameter, you do not need to specify **ParameterGroupId**.
	Parameters           *string `json:"Parameters,omitempty" xml:"Parameters,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The time at which the modification takes effect. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
	//
	// > This time must be later than the time at which you call this operation.
	SwitchTime *string `json:"SwitchTime,omitempty" xml:"SwitchTime,omitempty"`
	// The time at which the modification takes effect. Valid values:
	//
	// *   **Immediately**: immediately modifies the parameter. This is the default value.
	// *   **MaintainTime**: modifies the parameter during the maintenance window of the instance. You can call the [ModifyDBInstanceMaintainTime](~~26249~~) operation to change the maintenance window of the instance.
	// *   **ScheduleTime**: The modification takes effect at the point in time that you specify. If you specify this value, you must also specify **SwitchTime**.
	SwitchTimeMode *string `json:"SwitchTimeMode,omitempty" xml:"SwitchTimeMode,omitempty"`
}

func (s ModifyParameterRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyParameterRequest) GoString() string {
	return s.String()
}

func (s *ModifyParameterRequest) SetClientToken(v string) *ModifyParameterRequest {
	s.ClientToken = &v
	return s
}

func (s *ModifyParameterRequest) SetDBInstanceId(v string) *ModifyParameterRequest {
	s.DBInstanceId = &v
	return s
}

func (s *ModifyParameterRequest) SetForcerestart(v bool) *ModifyParameterRequest {
	s.Forcerestart = &v
	return s
}

func (s *ModifyParameterRequest) SetOwnerAccount(v string) *ModifyParameterRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyParameterRequest) SetOwnerId(v int64) *ModifyParameterRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyParameterRequest) SetParameterGroupId(v string) *ModifyParameterRequest {
	s.ParameterGroupId = &v
	return s
}

func (s *ModifyParameterRequest) SetParameters(v string) *ModifyParameterRequest {
	s.Parameters = &v
	return s
}

func (s *ModifyParameterRequest) SetResourceOwnerAccount(v string) *ModifyParameterRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyParameterRequest) SetResourceOwnerId(v int64) *ModifyParameterRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ModifyParameterRequest) SetSwitchTime(v string) *ModifyParameterRequest {
	s.SwitchTime = &v
	return s
}

func (s *ModifyParameterRequest) SetSwitchTimeMode(v string) *ModifyParameterRequest {
	s.SwitchTimeMode = &v
	return s
}

type ModifyParameterResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyParameterResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyParameterResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyParameterResponseBody) SetRequestId(v string) *ModifyParameterResponseBody {
	s.RequestId = &v
	return s
}

type ModifyParameterResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyParameterResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyParameterResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyParameterResponse) GoString() string {
	return s.String()
}

func (s *ModifyParameterResponse) SetHeaders(v map[string]*string) *ModifyParameterResponse {
	s.Headers = v
	return s
}

func (s *ModifyParameterResponse) SetStatusCode(v int32) *ModifyParameterResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyParameterResponse) SetBody(v *ModifyParameterResponseBody) *ModifyParameterResponse {
	s.Body = v
	return s
}

type ModifyParameterGroupRequest struct {
	// The modification mode of the parameter template. Valid values:
	//
	// *   **Collectivity** (default): adds new parameters or modifies parameters in the original parameter template.
	//
	// > If ModifyMode is set to Collectivity, the system adds the value of **Parameters** to the parameter template or modifies the corresponding parameters in the parameter template. Other parameters in the original parameter template are not affected.
	//
	// *   **Individual**: overwrites original parameters.
	//
	// > If ModifyMode is set to Individual, the system uses the value of **Parameters** to overwrite the original parameter in the parameter template.
	ModifyMode *string `json:"ModifyMode,omitempty" xml:"ModifyMode,omitempty"`
	OwnerId    *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The new description of the parameter template. The description can be up to 200 characters in length.
	//
	// > If you do not specify this parameter, the original description of the parameter template is retained.
	ParameterGroupDesc *string `json:"ParameterGroupDesc,omitempty" xml:"ParameterGroupDesc,omitempty"`
	// The parameter template ID. You can call the [DescribeParameterGroups](~~144491~~) operation to query the parameter template ID.
	ParameterGroupId *string `json:"ParameterGroupId,omitempty" xml:"ParameterGroupId,omitempty"`
	// The parameter template name.
	//
	// *   The name can contain letters, digits, periods (.), and underscores (\_). It must start with a letter.
	// *   It can be 8 to 64 characters in length.
	//
	// > If you do not specify this parameter, the original name of the parameter template is retained.
	ParameterGroupName *string `json:"ParameterGroupName,omitempty" xml:"ParameterGroupName,omitempty"`
	// A JSON string that consists of parameters and their values in the parameter template. Format: {"Parameter 1":"Value of Parameter 1","Parameter 2":"Value of Parameter 2"...}. For more information about the parameters that can be modified, see [Modify the parameters of an ApsaraDB RDS for MySQL instance](~~96063~~) or [Modify the parameters of an ApsaraDB RDS for PostgreSQL instance](~~96751~~).
	//
	// >
	//
	// *   If **ModifyMode** is set to **Individual** and this parameter is specified, the new parameters overwrite the parameters in the original parameter template.
	//
	// *   If you set **ModifyMode** to **Collectivity** and specify this parameter, the new parameters are added to the original parameter template, or the parameters in the original parameter template are modified.
	// *   If you do not specify this parameter, the parameters in the original parameter template remain unchanged.
	Parameters *string `json:"Parameters,omitempty" xml:"Parameters,omitempty"`
	// The region ID. You can call the [DescribeRegions](~~26243~~) operation to query the most recent region list.
	//
	// > The region of a parameter template cannot be changed. You can call the [CloneParameterGroup](~~144581~~) operation to replicate a parameter template to a specific region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group. You can call the [DescribeDBInstanceAttribute](~~610394~~) operation to obtain the ID of the resource group.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ModifyParameterGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyParameterGroupRequest) GoString() string {
	return s.String()
}

func (s *ModifyParameterGroupRequest) SetModifyMode(v string) *ModifyParameterGroupRequest {
	s.ModifyMode = &v
	return s
}

func (s *ModifyParameterGroupRequest) SetOwnerId(v int64) *ModifyParameterGroupRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyParameterGroupRequest) SetParameterGroupDesc(v string) *ModifyParameterGroupRequest {
	s.ParameterGroupDesc = &v
	return s
}

func (s *ModifyParameterGroupRequest) SetParameterGroupId(v string) *ModifyParameterGroupRequest {
	s.ParameterGroupId = &v
	return s
}

func (s *ModifyParameterGroupRequest) SetParameterGroupName(v string) *ModifyParameterGroupRequest {
	s.ParameterGroupName = &v
	return s
}

func (s *ModifyParameterGroupRequest) SetParameters(v string) *ModifyParameterGroupRequest {
	s.Parameters = &v
	return s
}

func (s *ModifyParameterGroupRequest) SetRegionId(v string) *ModifyParameterGroupRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyParameterGroupRequest) SetResourceGroupId(v string) *ModifyParameterGroupRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *ModifyParameterGroupRequest) SetResourceOwnerAccount(v string) *ModifyParameterGroupRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyParameterGroupRequest) SetResourceOwnerId(v int64) *ModifyParameterGroupRequest {
	s.ResourceOwnerId = &v
	return s
}

type ModifyParameterGroupResponseBody struct {
	// The parameter template ID.
	ParameterGroupId *string `json:"ParameterGroupId,omitempty" xml:"ParameterGroupId,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyParameterGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyParameterGroupResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyParameterGroupResponseBody) SetParameterGroupId(v string) *ModifyParameterGroupResponseBody {
	s.ParameterGroupId = &v
	return s
}

func (s *ModifyParameterGroupResponseBody) SetRequestId(v string) *ModifyParameterGroupResponseBody {
	s.RequestId = &v
	return s
}

type ModifyParameterGroupResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyParameterGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyParameterGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyParameterGroupResponse) GoString() string {
	return s.String()
}

func (s *ModifyParameterGroupResponse) SetHeaders(v map[string]*string) *ModifyParameterGroupResponse {
	s.Headers = v
	return s
}

func (s *ModifyParameterGroupResponse) SetStatusCode(v int32) *ModifyParameterGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyParameterGroupResponse) SetBody(v *ModifyParameterGroupResponseBody) *ModifyParameterGroupResponse {
	s.Body = v
	return s
}

type ModifyReadWriteSplittingConnectionRequest struct {
	// The prefix of the read/write splitting endpoint. The prefix must be unique. It can be up to 30 characters in length and can contain lowercase letters and hyphens (-). It must start with a lowercase letter.
	//
	// > The default prefix consists of the name of the primary instance followed by the letters rw.
	ConnectionStringPrefix *string `json:"ConnectionStringPrefix,omitempty" xml:"ConnectionStringPrefix,omitempty"`
	// The ID of the primary instance. You can call the DescribeDBInstances operation to query the instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The method that is used to assign read weights. Valid values:
	//
	// *   **Standard**: The system automatically assigns read weights to the primary and read-only instances based on the specifications of these instances.
	// *   **Custom**: You must manually assign a read weight to each instance.
	//
	// > You must specify at least one of **MaxDelayTime** and **DistributionType**.
	DistributionType *string `json:"DistributionType,omitempty" xml:"DistributionType,omitempty"`
	// The latency threshold that is allowed by the read/write splitting link. Unit: seconds. If the latency on a read-only instance exceeds the specified threshold, the system no longer routes read requests to the read-only instance. If you do not specify this parameter, the default value of this parameter is retained.
	//
	// > *   If the primary instance runs SQL Server 2017 on RDS Cluster Edition, the **MaxDelayTime** parameter is not supported.
	// > *   You must specify at least one of **MaxDelayTime** and **DistributionType**.
	MaxDelayTime *string `json:"MaxDelayTime,omitempty" xml:"MaxDelayTime,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The port that is associated with the read/write splitting endpoint.
	Port                 *string `json:"Port,omitempty" xml:"Port,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The read weights of the primary instance and its read-only instances. A read weight must be a multiple of 100 and cannot exceed 10,000.
	//
	// *   For ApsaraDB RDS instances, the value of this parameter is in the following format: `{"<ID of the read-only instance >":<Weight>,"master":<Weight>,"slave":<Weight>}`.
	// *   For ApsaraDB MyBase instances, the value of this parameter is in the following format: `[{"instanceName":"<ID of the primary instance>","weight":<Weight>,"role":"master"},{"instanceName":"<ID of the primary instance>","weight":<Weight>,"role":"slave"},{"instanceName":"<ID of the read-only instance>","weight":<Weight>,"role":"master"}]`
	//
	// >
	//
	// *   This parameter must be specified when **DistributionType** is set to **Custom**.
	//
	// *   If **DistributionType** is set to **Standard**, this parameter is invalid.
	Weight *string `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s ModifyReadWriteSplittingConnectionRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyReadWriteSplittingConnectionRequest) GoString() string {
	return s.String()
}

func (s *ModifyReadWriteSplittingConnectionRequest) SetConnectionStringPrefix(v string) *ModifyReadWriteSplittingConnectionRequest {
	s.ConnectionStringPrefix = &v
	return s
}

func (s *ModifyReadWriteSplittingConnectionRequest) SetDBInstanceId(v string) *ModifyReadWriteSplittingConnectionRequest {
	s.DBInstanceId = &v
	return s
}

func (s *ModifyReadWriteSplittingConnectionRequest) SetDistributionType(v string) *ModifyReadWriteSplittingConnectionRequest {
	s.DistributionType = &v
	return s
}

func (s *ModifyReadWriteSplittingConnectionRequest) SetMaxDelayTime(v string) *ModifyReadWriteSplittingConnectionRequest {
	s.MaxDelayTime = &v
	return s
}

func (s *ModifyReadWriteSplittingConnectionRequest) SetOwnerAccount(v string) *ModifyReadWriteSplittingConnectionRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyReadWriteSplittingConnectionRequest) SetOwnerId(v int64) *ModifyReadWriteSplittingConnectionRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyReadWriteSplittingConnectionRequest) SetPort(v string) *ModifyReadWriteSplittingConnectionRequest {
	s.Port = &v
	return s
}

func (s *ModifyReadWriteSplittingConnectionRequest) SetResourceOwnerAccount(v string) *ModifyReadWriteSplittingConnectionRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyReadWriteSplittingConnectionRequest) SetResourceOwnerId(v int64) *ModifyReadWriteSplittingConnectionRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ModifyReadWriteSplittingConnectionRequest) SetWeight(v string) *ModifyReadWriteSplittingConnectionRequest {
	s.Weight = &v
	return s
}

type ModifyReadWriteSplittingConnectionResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyReadWriteSplittingConnectionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyReadWriteSplittingConnectionResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyReadWriteSplittingConnectionResponseBody) SetRequestId(v string) *ModifyReadWriteSplittingConnectionResponseBody {
	s.RequestId = &v
	return s
}

type ModifyReadWriteSplittingConnectionResponse struct {
	Headers    map[string]*string                              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyReadWriteSplittingConnectionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyReadWriteSplittingConnectionResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyReadWriteSplittingConnectionResponse) GoString() string {
	return s.String()
}

func (s *ModifyReadWriteSplittingConnectionResponse) SetHeaders(v map[string]*string) *ModifyReadWriteSplittingConnectionResponse {
	s.Headers = v
	return s
}

func (s *ModifyReadWriteSplittingConnectionResponse) SetStatusCode(v int32) *ModifyReadWriteSplittingConnectionResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyReadWriteSplittingConnectionResponse) SetBody(v *ModifyReadWriteSplittingConnectionResponseBody) *ModifyReadWriteSplittingConnectionResponse {
	s.Body = v
	return s
}

type ModifyReadonlyInstanceDelayReplicationTimeRequest struct {
	// The ID of the read-only instance. You can call the DescribeDBInstances operation to query the instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The replication latency of the data replication. Unit: seconds.
	ReadSQLReplicationTime *string `json:"ReadSQLReplicationTime,omitempty" xml:"ReadSQLReplicationTime,omitempty"`
	// The resource group ID. You can call the DescribeDBInstanceAttribute to query the resource group ID.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ModifyReadonlyInstanceDelayReplicationTimeRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyReadonlyInstanceDelayReplicationTimeRequest) GoString() string {
	return s.String()
}

func (s *ModifyReadonlyInstanceDelayReplicationTimeRequest) SetDBInstanceId(v string) *ModifyReadonlyInstanceDelayReplicationTimeRequest {
	s.DBInstanceId = &v
	return s
}

func (s *ModifyReadonlyInstanceDelayReplicationTimeRequest) SetOwnerId(v int64) *ModifyReadonlyInstanceDelayReplicationTimeRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyReadonlyInstanceDelayReplicationTimeRequest) SetReadSQLReplicationTime(v string) *ModifyReadonlyInstanceDelayReplicationTimeRequest {
	s.ReadSQLReplicationTime = &v
	return s
}

func (s *ModifyReadonlyInstanceDelayReplicationTimeRequest) SetResourceGroupId(v string) *ModifyReadonlyInstanceDelayReplicationTimeRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *ModifyReadonlyInstanceDelayReplicationTimeRequest) SetResourceOwnerAccount(v string) *ModifyReadonlyInstanceDelayReplicationTimeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyReadonlyInstanceDelayReplicationTimeRequest) SetResourceOwnerId(v int64) *ModifyReadonlyInstanceDelayReplicationTimeRequest {
	s.ResourceOwnerId = &v
	return s
}

type ModifyReadonlyInstanceDelayReplicationTimeResponseBody struct {
	// The ID of the read-only instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The latency at which to replicate data from the primary instance to the read-only instance. Unit: seconds.
	ReadSQLReplicationTime *string `json:"ReadSQLReplicationTime,omitempty" xml:"ReadSQLReplicationTime,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The task ID.
	TaskId *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
}

func (s ModifyReadonlyInstanceDelayReplicationTimeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyReadonlyInstanceDelayReplicationTimeResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyReadonlyInstanceDelayReplicationTimeResponseBody) SetDBInstanceId(v string) *ModifyReadonlyInstanceDelayReplicationTimeResponseBody {
	s.DBInstanceId = &v
	return s
}

func (s *ModifyReadonlyInstanceDelayReplicationTimeResponseBody) SetReadSQLReplicationTime(v string) *ModifyReadonlyInstanceDelayReplicationTimeResponseBody {
	s.ReadSQLReplicationTime = &v
	return s
}

func (s *ModifyReadonlyInstanceDelayReplicationTimeResponseBody) SetRequestId(v string) *ModifyReadonlyInstanceDelayReplicationTimeResponseBody {
	s.RequestId = &v
	return s
}

func (s *ModifyReadonlyInstanceDelayReplicationTimeResponseBody) SetTaskId(v string) *ModifyReadonlyInstanceDelayReplicationTimeResponseBody {
	s.TaskId = &v
	return s
}

type ModifyReadonlyInstanceDelayReplicationTimeResponse struct {
	Headers    map[string]*string                                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyReadonlyInstanceDelayReplicationTimeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyReadonlyInstanceDelayReplicationTimeResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyReadonlyInstanceDelayReplicationTimeResponse) GoString() string {
	return s.String()
}

func (s *ModifyReadonlyInstanceDelayReplicationTimeResponse) SetHeaders(v map[string]*string) *ModifyReadonlyInstanceDelayReplicationTimeResponse {
	s.Headers = v
	return s
}

func (s *ModifyReadonlyInstanceDelayReplicationTimeResponse) SetStatusCode(v int32) *ModifyReadonlyInstanceDelayReplicationTimeResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyReadonlyInstanceDelayReplicationTimeResponse) SetBody(v *ModifyReadonlyInstanceDelayReplicationTimeResponseBody) *ModifyReadonlyInstanceDelayReplicationTimeResponse {
	s.Body = v
	return s
}

type ModifyResourceGroupRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The instance ID. You can call the DescribeDBInstances operation to query the instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The resource group ID. You can call the ListResourceGroups operation to obtain the resource group ID.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ModifyResourceGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyResourceGroupRequest) GoString() string {
	return s.String()
}

func (s *ModifyResourceGroupRequest) SetClientToken(v string) *ModifyResourceGroupRequest {
	s.ClientToken = &v
	return s
}

func (s *ModifyResourceGroupRequest) SetDBInstanceId(v string) *ModifyResourceGroupRequest {
	s.DBInstanceId = &v
	return s
}

func (s *ModifyResourceGroupRequest) SetOwnerAccount(v string) *ModifyResourceGroupRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyResourceGroupRequest) SetOwnerId(v int64) *ModifyResourceGroupRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyResourceGroupRequest) SetResourceGroupId(v string) *ModifyResourceGroupRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *ModifyResourceGroupRequest) SetResourceOwnerAccount(v string) *ModifyResourceGroupRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyResourceGroupRequest) SetResourceOwnerId(v int64) *ModifyResourceGroupRequest {
	s.ResourceOwnerId = &v
	return s
}

type ModifyResourceGroupResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyResourceGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyResourceGroupResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyResourceGroupResponseBody) SetRequestId(v string) *ModifyResourceGroupResponseBody {
	s.RequestId = &v
	return s
}

type ModifyResourceGroupResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyResourceGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyResourceGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyResourceGroupResponse) GoString() string {
	return s.String()
}

func (s *ModifyResourceGroupResponse) SetHeaders(v map[string]*string) *ModifyResourceGroupResponse {
	s.Headers = v
	return s
}

func (s *ModifyResourceGroupResponse) SetStatusCode(v int32) *ModifyResourceGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyResourceGroupResponse) SetBody(v *ModifyResourceGroupResponseBody) *ModifyResourceGroupResponse {
	s.Body = v
	return s
}

type ModifySQLCollectorPolicyRequest struct {
	// The ID of the instance. You can call the [DescribeDBInstances](~~610396~~) operation to query the ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the resource group. You can call the [DescribeDBInstanceAttribute](~~610394~~) operation to obtain the ID of the resource group.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// Specifies whether to enable the SQL Explorer (SQL Audit) feature. Valid values:
	//
	// *   **Enable**
	// *   **Disabled**
	SQLCollectorStatus *string `json:"SQLCollectorStatus,omitempty" xml:"SQLCollectorStatus,omitempty"`
}

func (s ModifySQLCollectorPolicyRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifySQLCollectorPolicyRequest) GoString() string {
	return s.String()
}

func (s *ModifySQLCollectorPolicyRequest) SetDBInstanceId(v string) *ModifySQLCollectorPolicyRequest {
	s.DBInstanceId = &v
	return s
}

func (s *ModifySQLCollectorPolicyRequest) SetOwnerAccount(v string) *ModifySQLCollectorPolicyRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifySQLCollectorPolicyRequest) SetOwnerId(v int64) *ModifySQLCollectorPolicyRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifySQLCollectorPolicyRequest) SetResourceGroupId(v string) *ModifySQLCollectorPolicyRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *ModifySQLCollectorPolicyRequest) SetResourceOwnerAccount(v string) *ModifySQLCollectorPolicyRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifySQLCollectorPolicyRequest) SetResourceOwnerId(v int64) *ModifySQLCollectorPolicyRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ModifySQLCollectorPolicyRequest) SetSQLCollectorStatus(v string) *ModifySQLCollectorPolicyRequest {
	s.SQLCollectorStatus = &v
	return s
}

type ModifySQLCollectorPolicyResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifySQLCollectorPolicyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifySQLCollectorPolicyResponseBody) GoString() string {
	return s.String()
}

func (s *ModifySQLCollectorPolicyResponseBody) SetRequestId(v string) *ModifySQLCollectorPolicyResponseBody {
	s.RequestId = &v
	return s
}

type ModifySQLCollectorPolicyResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifySQLCollectorPolicyResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifySQLCollectorPolicyResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifySQLCollectorPolicyResponse) GoString() string {
	return s.String()
}

func (s *ModifySQLCollectorPolicyResponse) SetHeaders(v map[string]*string) *ModifySQLCollectorPolicyResponse {
	s.Headers = v
	return s
}

func (s *ModifySQLCollectorPolicyResponse) SetStatusCode(v int32) *ModifySQLCollectorPolicyResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifySQLCollectorPolicyResponse) SetBody(v *ModifySQLCollectorPolicyResponseBody) *ModifySQLCollectorPolicyResponse {
	s.Body = v
	return s
}

type ModifySQLCollectorRetentionRequest struct {
	// The log retention period that is allowed by the SQL Explorer feature on the instance. Valid values:
	//
	// *   30: 30 days
	// *   180: 180 days
	// *   365: one year
	// *   1095: three years
	// *   1825: five years
	ConfigValue *string `json:"ConfigValue,omitempty" xml:"ConfigValue,omitempty"`
	// The instance ID. You can call the DescribeDBInstances operation to query the instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The resource group ID. You can call the DescribeDBInstanceAttribute operation to obtain the resource group ID.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	SecurityToken        *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s ModifySQLCollectorRetentionRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifySQLCollectorRetentionRequest) GoString() string {
	return s.String()
}

func (s *ModifySQLCollectorRetentionRequest) SetConfigValue(v string) *ModifySQLCollectorRetentionRequest {
	s.ConfigValue = &v
	return s
}

func (s *ModifySQLCollectorRetentionRequest) SetDBInstanceId(v string) *ModifySQLCollectorRetentionRequest {
	s.DBInstanceId = &v
	return s
}

func (s *ModifySQLCollectorRetentionRequest) SetOwnerAccount(v string) *ModifySQLCollectorRetentionRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifySQLCollectorRetentionRequest) SetOwnerId(v int64) *ModifySQLCollectorRetentionRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifySQLCollectorRetentionRequest) SetResourceGroupId(v string) *ModifySQLCollectorRetentionRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *ModifySQLCollectorRetentionRequest) SetResourceOwnerAccount(v string) *ModifySQLCollectorRetentionRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifySQLCollectorRetentionRequest) SetResourceOwnerId(v int64) *ModifySQLCollectorRetentionRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ModifySQLCollectorRetentionRequest) SetSecurityToken(v string) *ModifySQLCollectorRetentionRequest {
	s.SecurityToken = &v
	return s
}

type ModifySQLCollectorRetentionResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifySQLCollectorRetentionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifySQLCollectorRetentionResponseBody) GoString() string {
	return s.String()
}

func (s *ModifySQLCollectorRetentionResponseBody) SetRequestId(v string) *ModifySQLCollectorRetentionResponseBody {
	s.RequestId = &v
	return s
}

type ModifySQLCollectorRetentionResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifySQLCollectorRetentionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifySQLCollectorRetentionResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifySQLCollectorRetentionResponse) GoString() string {
	return s.String()
}

func (s *ModifySQLCollectorRetentionResponse) SetHeaders(v map[string]*string) *ModifySQLCollectorRetentionResponse {
	s.Headers = v
	return s
}

func (s *ModifySQLCollectorRetentionResponse) SetStatusCode(v int32) *ModifySQLCollectorRetentionResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifySQLCollectorRetentionResponse) SetBody(v *ModifySQLCollectorRetentionResponseBody) *ModifySQLCollectorRetentionResponse {
	s.Body = v
	return s
}

type ModifySecurityGroupConfigurationRequest struct {
	// The ID of the instance.
	DBInstanceId         *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the ECS security group. Each RDS instance can be added to up to three security groups. Separate the security group IDs with commas (,). To delete an ECS security group for the RDS instance, leave this parameter empty. You can call the [DescribeSecurityGroups](~~25556~~) operation to query the ECS security group list.
	SecurityGroupId *string `json:"SecurityGroupId,omitempty" xml:"SecurityGroupId,omitempty"`
}

func (s ModifySecurityGroupConfigurationRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifySecurityGroupConfigurationRequest) GoString() string {
	return s.String()
}

func (s *ModifySecurityGroupConfigurationRequest) SetDBInstanceId(v string) *ModifySecurityGroupConfigurationRequest {
	s.DBInstanceId = &v
	return s
}

func (s *ModifySecurityGroupConfigurationRequest) SetOwnerId(v int64) *ModifySecurityGroupConfigurationRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifySecurityGroupConfigurationRequest) SetResourceOwnerAccount(v string) *ModifySecurityGroupConfigurationRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifySecurityGroupConfigurationRequest) SetResourceOwnerId(v int64) *ModifySecurityGroupConfigurationRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ModifySecurityGroupConfigurationRequest) SetSecurityGroupId(v string) *ModifySecurityGroupConfigurationRequest {
	s.SecurityGroupId = &v
	return s
}

type ModifySecurityGroupConfigurationResponseBody struct {
	// The ID of the instance.
	DBInstanceName *string `json:"DBInstanceName,omitempty" xml:"DBInstanceName,omitempty"`
	// An array that consists of ECS security groups.
	Items *ModifySecurityGroupConfigurationResponseBodyItems `json:"Items,omitempty" xml:"Items,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifySecurityGroupConfigurationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifySecurityGroupConfigurationResponseBody) GoString() string {
	return s.String()
}

func (s *ModifySecurityGroupConfigurationResponseBody) SetDBInstanceName(v string) *ModifySecurityGroupConfigurationResponseBody {
	s.DBInstanceName = &v
	return s
}

func (s *ModifySecurityGroupConfigurationResponseBody) SetItems(v *ModifySecurityGroupConfigurationResponseBodyItems) *ModifySecurityGroupConfigurationResponseBody {
	s.Items = v
	return s
}

func (s *ModifySecurityGroupConfigurationResponseBody) SetRequestId(v string) *ModifySecurityGroupConfigurationResponseBody {
	s.RequestId = &v
	return s
}

type ModifySecurityGroupConfigurationResponseBodyItems struct {
	EcsSecurityGroupRelation []*ModifySecurityGroupConfigurationResponseBodyItemsEcsSecurityGroupRelation `json:"EcsSecurityGroupRelation,omitempty" xml:"EcsSecurityGroupRelation,omitempty" type:"Repeated"`
}

func (s ModifySecurityGroupConfigurationResponseBodyItems) String() string {
	return tea.Prettify(s)
}

func (s ModifySecurityGroupConfigurationResponseBodyItems) GoString() string {
	return s.String()
}

func (s *ModifySecurityGroupConfigurationResponseBodyItems) SetEcsSecurityGroupRelation(v []*ModifySecurityGroupConfigurationResponseBodyItemsEcsSecurityGroupRelation) *ModifySecurityGroupConfigurationResponseBodyItems {
	s.EcsSecurityGroupRelation = v
	return s
}

type ModifySecurityGroupConfigurationResponseBodyItemsEcsSecurityGroupRelation struct {
	// The network type of an ECS security group. Valid values:
	//
	// *   **Classic**
	// *   **VPC**
	NetworkType *string `json:"NetworkType,omitempty" xml:"NetworkType,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the ECS security group.
	SecurityGroupId *string `json:"SecurityGroupId,omitempty" xml:"SecurityGroupId,omitempty"`
}

func (s ModifySecurityGroupConfigurationResponseBodyItemsEcsSecurityGroupRelation) String() string {
	return tea.Prettify(s)
}

func (s ModifySecurityGroupConfigurationResponseBodyItemsEcsSecurityGroupRelation) GoString() string {
	return s.String()
}

func (s *ModifySecurityGroupConfigurationResponseBodyItemsEcsSecurityGroupRelation) SetNetworkType(v string) *ModifySecurityGroupConfigurationResponseBodyItemsEcsSecurityGroupRelation {
	s.NetworkType = &v
	return s
}

func (s *ModifySecurityGroupConfigurationResponseBodyItemsEcsSecurityGroupRelation) SetRegionId(v string) *ModifySecurityGroupConfigurationResponseBodyItemsEcsSecurityGroupRelation {
	s.RegionId = &v
	return s
}

func (s *ModifySecurityGroupConfigurationResponseBodyItemsEcsSecurityGroupRelation) SetSecurityGroupId(v string) *ModifySecurityGroupConfigurationResponseBodyItemsEcsSecurityGroupRelation {
	s.SecurityGroupId = &v
	return s
}

type ModifySecurityGroupConfigurationResponse struct {
	Headers    map[string]*string                            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifySecurityGroupConfigurationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifySecurityGroupConfigurationResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifySecurityGroupConfigurationResponse) GoString() string {
	return s.String()
}

func (s *ModifySecurityGroupConfigurationResponse) SetHeaders(v map[string]*string) *ModifySecurityGroupConfigurationResponse {
	s.Headers = v
	return s
}

func (s *ModifySecurityGroupConfigurationResponse) SetStatusCode(v int32) *ModifySecurityGroupConfigurationResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifySecurityGroupConfigurationResponse) SetBody(v *ModifySecurityGroupConfigurationResponseBody) *ModifySecurityGroupConfigurationResponse {
	s.Body = v
	return s
}

type ModifySecurityIpsRequest struct {
	// The attribute of the IP address whitelist. By default, this parameter is empty.
	//
	// > The IP address whitelists that have the hidden attribute are not displayed in the ApsaraDB RDS console. These IP address whitelists are used to access Alibaba Cloud services, such as Data Transmission Service (DTS).
	DBInstanceIPArrayAttribute *string `json:"DBInstanceIPArrayAttribute,omitempty" xml:"DBInstanceIPArrayAttribute,omitempty"`
	// The name of the IP address whitelist that you want to modify. Default value: **Default**.
	//
	// > A maximum of 200 IP address whitelists can be configured for each instance.
	DBInstanceIPArrayName *string `json:"DBInstanceIPArrayName,omitempty" xml:"DBInstanceIPArrayName,omitempty"`
	// The ID of the instance. You can call the [DescribeDBInstances](~~610396~~) operation to query the ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The read-only instances to which you want to synchronize the IP address whitelist.
	//
	// *   This parameter applies only to ApsaraDB RDS for PostgreSQL instances.
	// *   If the instance is attached with a read-only instance, you can use this parameter to synchronize the IP address whitelist to the read-only instance. If the instance is attached with multiple read-only instances, separate the read-only instances with commas (,).
	// *   If the instance is not attached with a read-only instance, leave this parameter empty.
	FreshWhiteListReadins *string `json:"FreshWhiteListReadins,omitempty" xml:"FreshWhiteListReadins,omitempty"`
	// The method that is used to modify the whitelist. Valid values:
	//
	// *   **Cover**: Use the IP addresses and CIDR blocks that are specified in the **SecurityIps** parameter to overwrite the existing IP addresses and CIDR blocks in the IP address whitelist.
	// *   **Append**: Add the IP addresses and CIDR blocks that are specified in the **SecurityIps** parameter to the IP address whitelist.
	// *   **Delete**: Delete the IP addresses and CIDR blocks that are specified in the **SecurityIps** parameter from the IP address whitelist. You must retain at least one IP address or CIDR block.
	//
	// Default value: **Cover**.
	ModifyMode      *string `json:"ModifyMode,omitempty" xml:"ModifyMode,omitempty"`
	ResourceOwnerId *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The type of the IP addresses in the IP address whitelist. Set the value to IPv4. IPv6 is not supported.
	SecurityIPType *string `json:"SecurityIPType,omitempty" xml:"SecurityIPType,omitempty"`
	// The IP addresses in an IP address whitelist. Separate multiple IP addresses with commas (,). Each IP address in the IP address whitelist must be unique. The entries in the IP address whitelist must be in one of the following formats:
	//
	// *   IP addresses, such as 10.23.XX.XX.
	// *   CIDR blocks, such as 10.23.XX.XX/24. In this example, 24 indicates that the prefix of each IP address in the IP address whitelist is 24 bits in length. You can replace 24 with a value within the range of 1 to 32.
	//
	// > A maximum of 1,000 IP addresses or CIDR blocks can be added for each instance. If you want to add a large number of IP addresses, we recommend that you merge them into CIDR blocks, such as 10.23.XX.XX/24.
	SecurityIps *string `json:"SecurityIps,omitempty" xml:"SecurityIps,omitempty"`
	// The network type of the IP address whitelist. Valid values:
	//
	// *   **Classic**: classic network in enhanced whitelist mode
	// *   **VPC**: virtual private cloud (VPC) in enhanced whitelist mode
	// *   **MIX**: standard whitelist mode
	//
	// Default value: **MIX**.
	//
	// > In standard whitelist mode, IP addresses and CIDR blocks are added only to the default IP address whitelist. In enhanced whitelist mode, IP addresses and CIDR blocks are added to the IP address whitelists of the classic network type and the VPC network type.
	WhitelistNetworkType *string `json:"WhitelistNetworkType,omitempty" xml:"WhitelistNetworkType,omitempty"`
}

func (s ModifySecurityIpsRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifySecurityIpsRequest) GoString() string {
	return s.String()
}

func (s *ModifySecurityIpsRequest) SetDBInstanceIPArrayAttribute(v string) *ModifySecurityIpsRequest {
	s.DBInstanceIPArrayAttribute = &v
	return s
}

func (s *ModifySecurityIpsRequest) SetDBInstanceIPArrayName(v string) *ModifySecurityIpsRequest {
	s.DBInstanceIPArrayName = &v
	return s
}

func (s *ModifySecurityIpsRequest) SetDBInstanceId(v string) *ModifySecurityIpsRequest {
	s.DBInstanceId = &v
	return s
}

func (s *ModifySecurityIpsRequest) SetFreshWhiteListReadins(v string) *ModifySecurityIpsRequest {
	s.FreshWhiteListReadins = &v
	return s
}

func (s *ModifySecurityIpsRequest) SetModifyMode(v string) *ModifySecurityIpsRequest {
	s.ModifyMode = &v
	return s
}

func (s *ModifySecurityIpsRequest) SetResourceOwnerId(v int64) *ModifySecurityIpsRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ModifySecurityIpsRequest) SetSecurityIPType(v string) *ModifySecurityIpsRequest {
	s.SecurityIPType = &v
	return s
}

func (s *ModifySecurityIpsRequest) SetSecurityIps(v string) *ModifySecurityIpsRequest {
	s.SecurityIps = &v
	return s
}

func (s *ModifySecurityIpsRequest) SetWhitelistNetworkType(v string) *ModifySecurityIpsRequest {
	s.WhitelistNetworkType = &v
	return s
}

type ModifySecurityIpsResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The task ID.
	TaskId *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
}

func (s ModifySecurityIpsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifySecurityIpsResponseBody) GoString() string {
	return s.String()
}

func (s *ModifySecurityIpsResponseBody) SetRequestId(v string) *ModifySecurityIpsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ModifySecurityIpsResponseBody) SetTaskId(v string) *ModifySecurityIpsResponseBody {
	s.TaskId = &v
	return s
}

type ModifySecurityIpsResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifySecurityIpsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifySecurityIpsResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifySecurityIpsResponse) GoString() string {
	return s.String()
}

func (s *ModifySecurityIpsResponse) SetHeaders(v map[string]*string) *ModifySecurityIpsResponse {
	s.Headers = v
	return s
}

func (s *ModifySecurityIpsResponse) SetStatusCode(v int32) *ModifySecurityIpsResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifySecurityIpsResponse) SetBody(v *ModifySecurityIpsResponseBody) *ModifySecurityIpsResponse {
	s.Body = v
	return s
}

type ModifyWhitelistTemplateRequest struct {
	// The IP addresses in an IP address whitelist. Separate multiple IP addresses with commas (,). Each IP address in the IP address whitelist must be unique. The entries in the IP address whitelist must be in one of the following formats:
	//
	// *   IP addresses, such as 10.23.XX.XX.
	// *   CIDR blocks, such as 10.23.XX.XX/24. In this example, 24 indicates that the prefix of the CIDR block is 24-bit in length. You can replace 24 with a value that ranges from 1 to 32.
	//
	// > : A maximum of 1,000 IP addresses or CIDR blocks can be added for each instance. If you want to add a large number of IP addresses, we recommend that you merge them into CIDR blocks, such as 10.23.XX.XX/24.
	IpWhitelist *string `json:"IpWhitelist,omitempty" xml:"IpWhitelist,omitempty"`
	// 资源组ID。 关于资源组的更多信息，请参见什么是资源组。
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the whitelist template. This parameter is required when you modify or delete a whitelist. You can call the DescribeAllWhitelistTemplate operation to obtain the ID of the whitelist.
	TemplateId *int32 `json:"TemplateId,omitempty" xml:"TemplateId,omitempty"`
	// The name of the IP whitelist. This parameter is required when you create a whitelist. The value of this parameter cannot be modified after the whitelist is created. The value must be unique to an Alibaba Cloud account and start with a letter. You can call the DescribeWhitelistTemplate operation to obtain the name of the whitelist.
	TemplateName *string `json:"TemplateName,omitempty" xml:"TemplateName,omitempty"`
}

func (s ModifyWhitelistTemplateRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyWhitelistTemplateRequest) GoString() string {
	return s.String()
}

func (s *ModifyWhitelistTemplateRequest) SetIpWhitelist(v string) *ModifyWhitelistTemplateRequest {
	s.IpWhitelist = &v
	return s
}

func (s *ModifyWhitelistTemplateRequest) SetResourceGroupId(v string) *ModifyWhitelistTemplateRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *ModifyWhitelistTemplateRequest) SetResourceOwnerAccount(v string) *ModifyWhitelistTemplateRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyWhitelistTemplateRequest) SetResourceOwnerId(v int64) *ModifyWhitelistTemplateRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ModifyWhitelistTemplateRequest) SetTemplateId(v int32) *ModifyWhitelistTemplateRequest {
	s.TemplateId = &v
	return s
}

func (s *ModifyWhitelistTemplateRequest) SetTemplateName(v string) *ModifyWhitelistTemplateRequest {
	s.TemplateName = &v
	return s
}

type ModifyWhitelistTemplateResponseBody struct {
	// The response code returned. Valid values:
	//
	// *   **200**: success
	// *   **400**: client error
	// *   **401**: identity authentication failed
	// *   **404**: request page not found
	// *   **500**: server error
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data returned.
	Data *ModifyWhitelistTemplateResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The HTTP status code returned. Valid values:
	//
	// *   **200**: success
	// *   **400**: client error
	// *   **500**: server error
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The returned message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful. Valid values:
	//
	// *   **true**
	// *   **false**
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ModifyWhitelistTemplateResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyWhitelistTemplateResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyWhitelistTemplateResponseBody) SetCode(v string) *ModifyWhitelistTemplateResponseBody {
	s.Code = &v
	return s
}

func (s *ModifyWhitelistTemplateResponseBody) SetData(v *ModifyWhitelistTemplateResponseBodyData) *ModifyWhitelistTemplateResponseBody {
	s.Data = v
	return s
}

func (s *ModifyWhitelistTemplateResponseBody) SetHttpStatusCode(v int32) *ModifyWhitelistTemplateResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ModifyWhitelistTemplateResponseBody) SetMessage(v string) *ModifyWhitelistTemplateResponseBody {
	s.Message = &v
	return s
}

func (s *ModifyWhitelistTemplateResponseBody) SetRequestId(v string) *ModifyWhitelistTemplateResponseBody {
	s.RequestId = &v
	return s
}

func (s *ModifyWhitelistTemplateResponseBody) SetSuccess(v bool) *ModifyWhitelistTemplateResponseBody {
	s.Success = &v
	return s
}

type ModifyWhitelistTemplateResponseBodyData struct {
	// The status code returned. Valid values:
	//
	// *   **ok**: The request is successful.
	// *   **error**: The request fails.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s ModifyWhitelistTemplateResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ModifyWhitelistTemplateResponseBodyData) GoString() string {
	return s.String()
}

func (s *ModifyWhitelistTemplateResponseBodyData) SetStatus(v string) *ModifyWhitelistTemplateResponseBodyData {
	s.Status = &v
	return s
}

type ModifyWhitelistTemplateResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyWhitelistTemplateResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyWhitelistTemplateResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyWhitelistTemplateResponse) GoString() string {
	return s.String()
}

func (s *ModifyWhitelistTemplateResponse) SetHeaders(v map[string]*string) *ModifyWhitelistTemplateResponse {
	s.Headers = v
	return s
}

func (s *ModifyWhitelistTemplateResponse) SetStatusCode(v int32) *ModifyWhitelistTemplateResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyWhitelistTemplateResponse) SetBody(v *ModifyWhitelistTemplateResponseBody) *ModifyWhitelistTemplateResponse {
	s.Body = v
	return s
}

type PreCheckCreateOrderForCreateDBNodesRequest struct {
	// Specifies whether to automatically complete the payment. Valid value:
	//
	// 1.  **true**: automatically completes the payment. You must make sure that your account balance is sufficient.
	// 2.  **false**: does not automatically complete the payment. An unpaid order is generated.
	//
	// >  Default value: true. If your account balance is insufficient, you can set the AutoPay parameter to false to generate an unpaid order. Then, you can log on to the ApsaraDB RDS console to complete the payment.
	AutoPay *bool `json:"AutoPay,omitempty" xml:"AutoPay,omitempty"`
	// The additional business information about the instance.
	BusinessInfo *string `json:"BusinessInfo,omitempty" xml:"BusinessInfo,omitempty"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The commodity code of the instance. Valid values:
	//
	// *   **bards**: The instance is a pay-as-you-go primary instance.
	// *   **rds**: The instance is a subscription primary instance.
	// *   **rords**: The instance is a pay-as-you-go read-only instance.
	// *   **rds_rordspre_public_cn**: The instance is a subscription read-only instance.
	// *   **bards_intl**: The instance is a pay-as-you-go primary instance.
	// *   **rds_intl**: The instance is a subscription primary instance.
	// *   **rords_intl**: The instance is a pay-as-you-go read-only instance.
	// *   **rds_rordspre_public_intl**: The instance is a subscription read-only instance.
	CommodityCode *string `json:"CommodityCode,omitempty" xml:"CommodityCode,omitempty"`
	// The ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The details about the node.
	DBNode []*PreCheckCreateOrderForCreateDBNodesRequestDBNode `json:"DBNode,omitempty" xml:"DBNode,omitempty" type:"Repeated"`
	// The major engine version of the destination instance. The value of this parameter varies based on the value of **Engine**.
	//
	// *   Valid values when Engine is set to MySQL: **5.5, 5.6, 5.7, and 8.0**
	// *   Valid values when Engine is set to SQLServer: **2008r2, 08r2\_ent_ha, 2012, 2012\_ent_ha, 2012\_std_ha, 2012\_web, 2014\_std_ha, 2016\_ent_ha, 2016\_std_ha, 2016\_web, 2017\_std_ha, 2017\_ent, 2019\_std_ha, and 2019\_ent**
	// *   Valid values when Engine is set to PostgreSQL: **9.4, 10.0, 11.0, 12.0, and 13.0**
	EngineVersion *string `json:"EngineVersion,omitempty" xml:"EngineVersion,omitempty"`
	// The type of the database node. Valid values:
	//
	// *   **Master**: the primary node
	// *   **Slave**: the secondary node
	NodeType *string `json:"NodeType,omitempty" xml:"NodeType,omitempty"`
	OwnerId  *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The coupon code.
	PromotionCode *string `json:"PromotionCode,omitempty" xml:"PromotionCode,omitempty"`
	// The region ID. You can call the [DescribeRegions](~~610399~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The resource of the instance.
	Resource             *string `json:"Resource,omitempty" xml:"Resource,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The zone ID. You can call the [DescribeRegions](~~610399~~) operation to query the most recent zone list.
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
}

func (s PreCheckCreateOrderForCreateDBNodesRequest) String() string {
	return tea.Prettify(s)
}

func (s PreCheckCreateOrderForCreateDBNodesRequest) GoString() string {
	return s.String()
}

func (s *PreCheckCreateOrderForCreateDBNodesRequest) SetAutoPay(v bool) *PreCheckCreateOrderForCreateDBNodesRequest {
	s.AutoPay = &v
	return s
}

func (s *PreCheckCreateOrderForCreateDBNodesRequest) SetBusinessInfo(v string) *PreCheckCreateOrderForCreateDBNodesRequest {
	s.BusinessInfo = &v
	return s
}

func (s *PreCheckCreateOrderForCreateDBNodesRequest) SetClientToken(v string) *PreCheckCreateOrderForCreateDBNodesRequest {
	s.ClientToken = &v
	return s
}

func (s *PreCheckCreateOrderForCreateDBNodesRequest) SetCommodityCode(v string) *PreCheckCreateOrderForCreateDBNodesRequest {
	s.CommodityCode = &v
	return s
}

func (s *PreCheckCreateOrderForCreateDBNodesRequest) SetDBInstanceId(v string) *PreCheckCreateOrderForCreateDBNodesRequest {
	s.DBInstanceId = &v
	return s
}

func (s *PreCheckCreateOrderForCreateDBNodesRequest) SetDBNode(v []*PreCheckCreateOrderForCreateDBNodesRequestDBNode) *PreCheckCreateOrderForCreateDBNodesRequest {
	s.DBNode = v
	return s
}

func (s *PreCheckCreateOrderForCreateDBNodesRequest) SetEngineVersion(v string) *PreCheckCreateOrderForCreateDBNodesRequest {
	s.EngineVersion = &v
	return s
}

func (s *PreCheckCreateOrderForCreateDBNodesRequest) SetNodeType(v string) *PreCheckCreateOrderForCreateDBNodesRequest {
	s.NodeType = &v
	return s
}

func (s *PreCheckCreateOrderForCreateDBNodesRequest) SetOwnerId(v int64) *PreCheckCreateOrderForCreateDBNodesRequest {
	s.OwnerId = &v
	return s
}

func (s *PreCheckCreateOrderForCreateDBNodesRequest) SetPromotionCode(v string) *PreCheckCreateOrderForCreateDBNodesRequest {
	s.PromotionCode = &v
	return s
}

func (s *PreCheckCreateOrderForCreateDBNodesRequest) SetRegionId(v string) *PreCheckCreateOrderForCreateDBNodesRequest {
	s.RegionId = &v
	return s
}

func (s *PreCheckCreateOrderForCreateDBNodesRequest) SetResource(v string) *PreCheckCreateOrderForCreateDBNodesRequest {
	s.Resource = &v
	return s
}

func (s *PreCheckCreateOrderForCreateDBNodesRequest) SetResourceOwnerAccount(v string) *PreCheckCreateOrderForCreateDBNodesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *PreCheckCreateOrderForCreateDBNodesRequest) SetResourceOwnerId(v int64) *PreCheckCreateOrderForCreateDBNodesRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *PreCheckCreateOrderForCreateDBNodesRequest) SetZoneId(v string) *PreCheckCreateOrderForCreateDBNodesRequest {
	s.ZoneId = &v
	return s
}

type PreCheckCreateOrderForCreateDBNodesRequestDBNode struct {
	// The specification information of the node.
	ClassCode *string `json:"classCode,omitempty" xml:"classCode,omitempty"`
	// The zone ID of the node.
	ZoneId *string `json:"zoneId,omitempty" xml:"zoneId,omitempty"`
}

func (s PreCheckCreateOrderForCreateDBNodesRequestDBNode) String() string {
	return tea.Prettify(s)
}

func (s PreCheckCreateOrderForCreateDBNodesRequestDBNode) GoString() string {
	return s.String()
}

func (s *PreCheckCreateOrderForCreateDBNodesRequestDBNode) SetClassCode(v string) *PreCheckCreateOrderForCreateDBNodesRequestDBNode {
	s.ClassCode = &v
	return s
}

func (s *PreCheckCreateOrderForCreateDBNodesRequestDBNode) SetZoneId(v string) *PreCheckCreateOrderForCreateDBNodesRequestDBNode {
	s.ZoneId = &v
	return s
}

type PreCheckCreateOrderForCreateDBNodesShrinkRequest struct {
	// Specifies whether to automatically complete the payment. Valid value:
	//
	// 1.  **true**: automatically completes the payment. You must make sure that your account balance is sufficient.
	// 2.  **false**: does not automatically complete the payment. An unpaid order is generated.
	//
	// >  Default value: true. If your account balance is insufficient, you can set the AutoPay parameter to false to generate an unpaid order. Then, you can log on to the ApsaraDB RDS console to complete the payment.
	AutoPay *bool `json:"AutoPay,omitempty" xml:"AutoPay,omitempty"`
	// The additional business information about the instance.
	BusinessInfo *string `json:"BusinessInfo,omitempty" xml:"BusinessInfo,omitempty"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The commodity code of the instance. Valid values:
	//
	// *   **bards**: The instance is a pay-as-you-go primary instance.
	// *   **rds**: The instance is a subscription primary instance.
	// *   **rords**: The instance is a pay-as-you-go read-only instance.
	// *   **rds_rordspre_public_cn**: The instance is a subscription read-only instance.
	// *   **bards_intl**: The instance is a pay-as-you-go primary instance.
	// *   **rds_intl**: The instance is a subscription primary instance.
	// *   **rords_intl**: The instance is a pay-as-you-go read-only instance.
	// *   **rds_rordspre_public_intl**: The instance is a subscription read-only instance.
	CommodityCode *string `json:"CommodityCode,omitempty" xml:"CommodityCode,omitempty"`
	// The ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The details about the node.
	DBNodeShrink *string `json:"DBNode,omitempty" xml:"DBNode,omitempty"`
	// The major engine version of the destination instance. The value of this parameter varies based on the value of **Engine**.
	//
	// *   Valid values when Engine is set to MySQL: **5.5, 5.6, 5.7, and 8.0**
	// *   Valid values when Engine is set to SQLServer: **2008r2, 08r2\_ent_ha, 2012, 2012\_ent_ha, 2012\_std_ha, 2012\_web, 2014\_std_ha, 2016\_ent_ha, 2016\_std_ha, 2016\_web, 2017\_std_ha, 2017\_ent, 2019\_std_ha, and 2019\_ent**
	// *   Valid values when Engine is set to PostgreSQL: **9.4, 10.0, 11.0, 12.0, and 13.0**
	EngineVersion *string `json:"EngineVersion,omitempty" xml:"EngineVersion,omitempty"`
	// The type of the database node. Valid values:
	//
	// *   **Master**: the primary node
	// *   **Slave**: the secondary node
	NodeType *string `json:"NodeType,omitempty" xml:"NodeType,omitempty"`
	OwnerId  *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The coupon code.
	PromotionCode *string `json:"PromotionCode,omitempty" xml:"PromotionCode,omitempty"`
	// The region ID. You can call the [DescribeRegions](~~610399~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The resource of the instance.
	Resource             *string `json:"Resource,omitempty" xml:"Resource,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The zone ID. You can call the [DescribeRegions](~~610399~~) operation to query the most recent zone list.
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
}

func (s PreCheckCreateOrderForCreateDBNodesShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s PreCheckCreateOrderForCreateDBNodesShrinkRequest) GoString() string {
	return s.String()
}

func (s *PreCheckCreateOrderForCreateDBNodesShrinkRequest) SetAutoPay(v bool) *PreCheckCreateOrderForCreateDBNodesShrinkRequest {
	s.AutoPay = &v
	return s
}

func (s *PreCheckCreateOrderForCreateDBNodesShrinkRequest) SetBusinessInfo(v string) *PreCheckCreateOrderForCreateDBNodesShrinkRequest {
	s.BusinessInfo = &v
	return s
}

func (s *PreCheckCreateOrderForCreateDBNodesShrinkRequest) SetClientToken(v string) *PreCheckCreateOrderForCreateDBNodesShrinkRequest {
	s.ClientToken = &v
	return s
}

func (s *PreCheckCreateOrderForCreateDBNodesShrinkRequest) SetCommodityCode(v string) *PreCheckCreateOrderForCreateDBNodesShrinkRequest {
	s.CommodityCode = &v
	return s
}

func (s *PreCheckCreateOrderForCreateDBNodesShrinkRequest) SetDBInstanceId(v string) *PreCheckCreateOrderForCreateDBNodesShrinkRequest {
	s.DBInstanceId = &v
	return s
}

func (s *PreCheckCreateOrderForCreateDBNodesShrinkRequest) SetDBNodeShrink(v string) *PreCheckCreateOrderForCreateDBNodesShrinkRequest {
	s.DBNodeShrink = &v
	return s
}

func (s *PreCheckCreateOrderForCreateDBNodesShrinkRequest) SetEngineVersion(v string) *PreCheckCreateOrderForCreateDBNodesShrinkRequest {
	s.EngineVersion = &v
	return s
}

func (s *PreCheckCreateOrderForCreateDBNodesShrinkRequest) SetNodeType(v string) *PreCheckCreateOrderForCreateDBNodesShrinkRequest {
	s.NodeType = &v
	return s
}

func (s *PreCheckCreateOrderForCreateDBNodesShrinkRequest) SetOwnerId(v int64) *PreCheckCreateOrderForCreateDBNodesShrinkRequest {
	s.OwnerId = &v
	return s
}

func (s *PreCheckCreateOrderForCreateDBNodesShrinkRequest) SetPromotionCode(v string) *PreCheckCreateOrderForCreateDBNodesShrinkRequest {
	s.PromotionCode = &v
	return s
}

func (s *PreCheckCreateOrderForCreateDBNodesShrinkRequest) SetRegionId(v string) *PreCheckCreateOrderForCreateDBNodesShrinkRequest {
	s.RegionId = &v
	return s
}

func (s *PreCheckCreateOrderForCreateDBNodesShrinkRequest) SetResource(v string) *PreCheckCreateOrderForCreateDBNodesShrinkRequest {
	s.Resource = &v
	return s
}

func (s *PreCheckCreateOrderForCreateDBNodesShrinkRequest) SetResourceOwnerAccount(v string) *PreCheckCreateOrderForCreateDBNodesShrinkRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *PreCheckCreateOrderForCreateDBNodesShrinkRequest) SetResourceOwnerId(v int64) *PreCheckCreateOrderForCreateDBNodesShrinkRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *PreCheckCreateOrderForCreateDBNodesShrinkRequest) SetZoneId(v string) *PreCheckCreateOrderForCreateDBNodesShrinkRequest {
	s.ZoneId = &v
	return s
}

type PreCheckCreateOrderForCreateDBNodesResponseBody struct {
	// The returned data.
	Failures *PreCheckCreateOrderForCreateDBNodesResponseBodyFailures `json:"Failures,omitempty" xml:"Failures,omitempty" type:"Struct"`
	// Indicates the result of the precheck task.
	PreCheckResult *bool `json:"PreCheckResult,omitempty" xml:"PreCheckResult,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s PreCheckCreateOrderForCreateDBNodesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s PreCheckCreateOrderForCreateDBNodesResponseBody) GoString() string {
	return s.String()
}

func (s *PreCheckCreateOrderForCreateDBNodesResponseBody) SetFailures(v *PreCheckCreateOrderForCreateDBNodesResponseBodyFailures) *PreCheckCreateOrderForCreateDBNodesResponseBody {
	s.Failures = v
	return s
}

func (s *PreCheckCreateOrderForCreateDBNodesResponseBody) SetPreCheckResult(v bool) *PreCheckCreateOrderForCreateDBNodesResponseBody {
	s.PreCheckResult = &v
	return s
}

func (s *PreCheckCreateOrderForCreateDBNodesResponseBody) SetRequestId(v string) *PreCheckCreateOrderForCreateDBNodesResponseBody {
	s.RequestId = &v
	return s
}

type PreCheckCreateOrderForCreateDBNodesResponseBodyFailures struct {
	Failures []*PreCheckCreateOrderForCreateDBNodesResponseBodyFailuresFailures `json:"Failures,omitempty" xml:"Failures,omitempty" type:"Repeated"`
}

func (s PreCheckCreateOrderForCreateDBNodesResponseBodyFailures) String() string {
	return tea.Prettify(s)
}

func (s PreCheckCreateOrderForCreateDBNodesResponseBodyFailures) GoString() string {
	return s.String()
}

func (s *PreCheckCreateOrderForCreateDBNodesResponseBodyFailures) SetFailures(v []*PreCheckCreateOrderForCreateDBNodesResponseBodyFailuresFailures) *PreCheckCreateOrderForCreateDBNodesResponseBodyFailures {
	s.Failures = v
	return s
}

type PreCheckCreateOrderForCreateDBNodesResponseBodyFailuresFailures struct {
	// The response code returned. Valid values:
	//
	// *   **200**: success
	// *   **400**: client error
	// *   **401**: identity authentication failed
	// *   **404**: request page not found
	// *   **500**: server error
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
}

func (s PreCheckCreateOrderForCreateDBNodesResponseBodyFailuresFailures) String() string {
	return tea.Prettify(s)
}

func (s PreCheckCreateOrderForCreateDBNodesResponseBodyFailuresFailures) GoString() string {
	return s.String()
}

func (s *PreCheckCreateOrderForCreateDBNodesResponseBodyFailuresFailures) SetCode(v string) *PreCheckCreateOrderForCreateDBNodesResponseBodyFailuresFailures {
	s.Code = &v
	return s
}

func (s *PreCheckCreateOrderForCreateDBNodesResponseBodyFailuresFailures) SetMessage(v string) *PreCheckCreateOrderForCreateDBNodesResponseBodyFailuresFailures {
	s.Message = &v
	return s
}

type PreCheckCreateOrderForCreateDBNodesResponse struct {
	Headers    map[string]*string                               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *PreCheckCreateOrderForCreateDBNodesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s PreCheckCreateOrderForCreateDBNodesResponse) String() string {
	return tea.Prettify(s)
}

func (s PreCheckCreateOrderForCreateDBNodesResponse) GoString() string {
	return s.String()
}

func (s *PreCheckCreateOrderForCreateDBNodesResponse) SetHeaders(v map[string]*string) *PreCheckCreateOrderForCreateDBNodesResponse {
	s.Headers = v
	return s
}

func (s *PreCheckCreateOrderForCreateDBNodesResponse) SetStatusCode(v int32) *PreCheckCreateOrderForCreateDBNodesResponse {
	s.StatusCode = &v
	return s
}

func (s *PreCheckCreateOrderForCreateDBNodesResponse) SetBody(v *PreCheckCreateOrderForCreateDBNodesResponseBody) *PreCheckCreateOrderForCreateDBNodesResponse {
	s.Body = v
	return s
}

type PreCheckCreateOrderForDeleteDBNodesRequest struct {
	// Specifies whether to automatically complete the payment. Valid value:
	//
	// 1.  **true**: automatically completes the payment. You must make sure that your account balance is sufficient.
	// 2.  **false**: does not automatically complete the payment. An unpaid order is generated.
	//
	// >  Default value: true. If your account balance is insufficient, you can set the AutoPay parameter to false to generate an unpaid order. Then, you can log on to the ApsaraDB RDS console to complete the payment.
	AutoPay *bool `json:"AutoPay,omitempty" xml:"AutoPay,omitempty"`
	// The additional business information about the instance.
	BusinessInfo *string `json:"BusinessInfo,omitempty" xml:"BusinessInfo,omitempty"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the generated token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The commodity code of the instance. Valid values:
	//
	// *   **bards**: The instance is a pay-as-you-go primary instance.
	// *   **rds**: The instance is a subscription primary instance.
	// *   **rords**: The instance is a pay-as-you-go read-only instance.
	// *   **rds_rordspre_public_cn**: The instance is a subscription read-only instance.
	// *   **bards_intl**: The instance is a pay-as-you-go primary instance.
	// *   **rds_intl**: The instance is a subscription primary instance.
	// *   **rords_intl**: The instance is a pay-as-you-go read-only instance.
	// *   **rds_rordspre_public_intl**: The instance is a subscription read-only instance.
	CommodityCode *string `json:"CommodityCode,omitempty" xml:"CommodityCode,omitempty"`
	// The instance ID. You can call the [DescribeDBInstances](~~610396~~) operation to query the ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The node IDs.
	DBNodeId []*string `json:"DBNodeId,omitempty" xml:"DBNodeId,omitempty" type:"Repeated"`
	// The database engine version of the instance. Valid values:
	//
	// *   Valid values if you set Engine to MySQL: **5.5, 5.6, 5.7, and 8.0**
	// *   Valid values if you set Engine to SQLServer: **2008r2, 08r2\_ent_ha, 2012, 2012\_ent_ha, 2012\_std_ha, 2012\_web, 2014\_std_ha, 2016\_ent_ha, 2016\_std_ha, 2016\_web, 2017\_std_ha, 2017\_ent, 2019\_std_ha, and 2019\_ent**
	// *   Valid values if you set Engine to PostgreSQL: **10.0, 11.0, 12.0, 13.0, and 14.0**
	// *   Valid value if you set Engine to MariaDB: **10.3**
	EngineVersion *string `json:"EngineVersion,omitempty" xml:"EngineVersion,omitempty"`
	// The type of the database node. Valid values:
	//
	// *   **Master**: the primary instance role
	// *   **Slave**: the secondary instance role
	NodeType *string `json:"NodeType,omitempty" xml:"NodeType,omitempty"`
	OwnerId  *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The coupon code.
	PromotionCode *string `json:"PromotionCode,omitempty" xml:"PromotionCode,omitempty"`
	// The region ID. You can call the [DescribeRegions](~~610399~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The resource of the instance.
	Resource             *string `json:"Resource,omitempty" xml:"Resource,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The zone ID of the instance.
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
}

func (s PreCheckCreateOrderForDeleteDBNodesRequest) String() string {
	return tea.Prettify(s)
}

func (s PreCheckCreateOrderForDeleteDBNodesRequest) GoString() string {
	return s.String()
}

func (s *PreCheckCreateOrderForDeleteDBNodesRequest) SetAutoPay(v bool) *PreCheckCreateOrderForDeleteDBNodesRequest {
	s.AutoPay = &v
	return s
}

func (s *PreCheckCreateOrderForDeleteDBNodesRequest) SetBusinessInfo(v string) *PreCheckCreateOrderForDeleteDBNodesRequest {
	s.BusinessInfo = &v
	return s
}

func (s *PreCheckCreateOrderForDeleteDBNodesRequest) SetClientToken(v string) *PreCheckCreateOrderForDeleteDBNodesRequest {
	s.ClientToken = &v
	return s
}

func (s *PreCheckCreateOrderForDeleteDBNodesRequest) SetCommodityCode(v string) *PreCheckCreateOrderForDeleteDBNodesRequest {
	s.CommodityCode = &v
	return s
}

func (s *PreCheckCreateOrderForDeleteDBNodesRequest) SetDBInstanceId(v string) *PreCheckCreateOrderForDeleteDBNodesRequest {
	s.DBInstanceId = &v
	return s
}

func (s *PreCheckCreateOrderForDeleteDBNodesRequest) SetDBNodeId(v []*string) *PreCheckCreateOrderForDeleteDBNodesRequest {
	s.DBNodeId = v
	return s
}

func (s *PreCheckCreateOrderForDeleteDBNodesRequest) SetEngineVersion(v string) *PreCheckCreateOrderForDeleteDBNodesRequest {
	s.EngineVersion = &v
	return s
}

func (s *PreCheckCreateOrderForDeleteDBNodesRequest) SetNodeType(v string) *PreCheckCreateOrderForDeleteDBNodesRequest {
	s.NodeType = &v
	return s
}

func (s *PreCheckCreateOrderForDeleteDBNodesRequest) SetOwnerId(v int64) *PreCheckCreateOrderForDeleteDBNodesRequest {
	s.OwnerId = &v
	return s
}

func (s *PreCheckCreateOrderForDeleteDBNodesRequest) SetPromotionCode(v string) *PreCheckCreateOrderForDeleteDBNodesRequest {
	s.PromotionCode = &v
	return s
}

func (s *PreCheckCreateOrderForDeleteDBNodesRequest) SetRegionId(v string) *PreCheckCreateOrderForDeleteDBNodesRequest {
	s.RegionId = &v
	return s
}

func (s *PreCheckCreateOrderForDeleteDBNodesRequest) SetResource(v string) *PreCheckCreateOrderForDeleteDBNodesRequest {
	s.Resource = &v
	return s
}

func (s *PreCheckCreateOrderForDeleteDBNodesRequest) SetResourceOwnerAccount(v string) *PreCheckCreateOrderForDeleteDBNodesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *PreCheckCreateOrderForDeleteDBNodesRequest) SetResourceOwnerId(v int64) *PreCheckCreateOrderForDeleteDBNodesRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *PreCheckCreateOrderForDeleteDBNodesRequest) SetZoneId(v string) *PreCheckCreateOrderForDeleteDBNodesRequest {
	s.ZoneId = &v
	return s
}

type PreCheckCreateOrderForDeleteDBNodesShrinkRequest struct {
	// Specifies whether to automatically complete the payment. Valid value:
	//
	// 1.  **true**: automatically completes the payment. You must make sure that your account balance is sufficient.
	// 2.  **false**: does not automatically complete the payment. An unpaid order is generated.
	//
	// >  Default value: true. If your account balance is insufficient, you can set the AutoPay parameter to false to generate an unpaid order. Then, you can log on to the ApsaraDB RDS console to complete the payment.
	AutoPay *bool `json:"AutoPay,omitempty" xml:"AutoPay,omitempty"`
	// The additional business information about the instance.
	BusinessInfo *string `json:"BusinessInfo,omitempty" xml:"BusinessInfo,omitempty"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the generated token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The commodity code of the instance. Valid values:
	//
	// *   **bards**: The instance is a pay-as-you-go primary instance.
	// *   **rds**: The instance is a subscription primary instance.
	// *   **rords**: The instance is a pay-as-you-go read-only instance.
	// *   **rds_rordspre_public_cn**: The instance is a subscription read-only instance.
	// *   **bards_intl**: The instance is a pay-as-you-go primary instance.
	// *   **rds_intl**: The instance is a subscription primary instance.
	// *   **rords_intl**: The instance is a pay-as-you-go read-only instance.
	// *   **rds_rordspre_public_intl**: The instance is a subscription read-only instance.
	CommodityCode *string `json:"CommodityCode,omitempty" xml:"CommodityCode,omitempty"`
	// The instance ID. You can call the [DescribeDBInstances](~~610396~~) operation to query the ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The node IDs.
	DBNodeIdShrink *string `json:"DBNodeId,omitempty" xml:"DBNodeId,omitempty"`
	// The database engine version of the instance. Valid values:
	//
	// *   Valid values if you set Engine to MySQL: **5.5, 5.6, 5.7, and 8.0**
	// *   Valid values if you set Engine to SQLServer: **2008r2, 08r2\_ent_ha, 2012, 2012\_ent_ha, 2012\_std_ha, 2012\_web, 2014\_std_ha, 2016\_ent_ha, 2016\_std_ha, 2016\_web, 2017\_std_ha, 2017\_ent, 2019\_std_ha, and 2019\_ent**
	// *   Valid values if you set Engine to PostgreSQL: **10.0, 11.0, 12.0, 13.0, and 14.0**
	// *   Valid value if you set Engine to MariaDB: **10.3**
	EngineVersion *string `json:"EngineVersion,omitempty" xml:"EngineVersion,omitempty"`
	// The type of the database node. Valid values:
	//
	// *   **Master**: the primary instance role
	// *   **Slave**: the secondary instance role
	NodeType *string `json:"NodeType,omitempty" xml:"NodeType,omitempty"`
	OwnerId  *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The coupon code.
	PromotionCode *string `json:"PromotionCode,omitempty" xml:"PromotionCode,omitempty"`
	// The region ID. You can call the [DescribeRegions](~~610399~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The resource of the instance.
	Resource             *string `json:"Resource,omitempty" xml:"Resource,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The zone ID of the instance.
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
}

func (s PreCheckCreateOrderForDeleteDBNodesShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s PreCheckCreateOrderForDeleteDBNodesShrinkRequest) GoString() string {
	return s.String()
}

func (s *PreCheckCreateOrderForDeleteDBNodesShrinkRequest) SetAutoPay(v bool) *PreCheckCreateOrderForDeleteDBNodesShrinkRequest {
	s.AutoPay = &v
	return s
}

func (s *PreCheckCreateOrderForDeleteDBNodesShrinkRequest) SetBusinessInfo(v string) *PreCheckCreateOrderForDeleteDBNodesShrinkRequest {
	s.BusinessInfo = &v
	return s
}

func (s *PreCheckCreateOrderForDeleteDBNodesShrinkRequest) SetClientToken(v string) *PreCheckCreateOrderForDeleteDBNodesShrinkRequest {
	s.ClientToken = &v
	return s
}

func (s *PreCheckCreateOrderForDeleteDBNodesShrinkRequest) SetCommodityCode(v string) *PreCheckCreateOrderForDeleteDBNodesShrinkRequest {
	s.CommodityCode = &v
	return s
}

func (s *PreCheckCreateOrderForDeleteDBNodesShrinkRequest) SetDBInstanceId(v string) *PreCheckCreateOrderForDeleteDBNodesShrinkRequest {
	s.DBInstanceId = &v
	return s
}

func (s *PreCheckCreateOrderForDeleteDBNodesShrinkRequest) SetDBNodeIdShrink(v string) *PreCheckCreateOrderForDeleteDBNodesShrinkRequest {
	s.DBNodeIdShrink = &v
	return s
}

func (s *PreCheckCreateOrderForDeleteDBNodesShrinkRequest) SetEngineVersion(v string) *PreCheckCreateOrderForDeleteDBNodesShrinkRequest {
	s.EngineVersion = &v
	return s
}

func (s *PreCheckCreateOrderForDeleteDBNodesShrinkRequest) SetNodeType(v string) *PreCheckCreateOrderForDeleteDBNodesShrinkRequest {
	s.NodeType = &v
	return s
}

func (s *PreCheckCreateOrderForDeleteDBNodesShrinkRequest) SetOwnerId(v int64) *PreCheckCreateOrderForDeleteDBNodesShrinkRequest {
	s.OwnerId = &v
	return s
}

func (s *PreCheckCreateOrderForDeleteDBNodesShrinkRequest) SetPromotionCode(v string) *PreCheckCreateOrderForDeleteDBNodesShrinkRequest {
	s.PromotionCode = &v
	return s
}

func (s *PreCheckCreateOrderForDeleteDBNodesShrinkRequest) SetRegionId(v string) *PreCheckCreateOrderForDeleteDBNodesShrinkRequest {
	s.RegionId = &v
	return s
}

func (s *PreCheckCreateOrderForDeleteDBNodesShrinkRequest) SetResource(v string) *PreCheckCreateOrderForDeleteDBNodesShrinkRequest {
	s.Resource = &v
	return s
}

func (s *PreCheckCreateOrderForDeleteDBNodesShrinkRequest) SetResourceOwnerAccount(v string) *PreCheckCreateOrderForDeleteDBNodesShrinkRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *PreCheckCreateOrderForDeleteDBNodesShrinkRequest) SetResourceOwnerId(v int64) *PreCheckCreateOrderForDeleteDBNodesShrinkRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *PreCheckCreateOrderForDeleteDBNodesShrinkRequest) SetZoneId(v string) *PreCheckCreateOrderForDeleteDBNodesShrinkRequest {
	s.ZoneId = &v
	return s
}

type PreCheckCreateOrderForDeleteDBNodesResponseBody struct {
	// The returned data.
	Failures *PreCheckCreateOrderForDeleteDBNodesResponseBodyFailures `json:"Failures,omitempty" xml:"Failures,omitempty" type:"Struct"`
	// Indicates the result of the precheck task.
	PreCheckResult *bool `json:"PreCheckResult,omitempty" xml:"PreCheckResult,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s PreCheckCreateOrderForDeleteDBNodesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s PreCheckCreateOrderForDeleteDBNodesResponseBody) GoString() string {
	return s.String()
}

func (s *PreCheckCreateOrderForDeleteDBNodesResponseBody) SetFailures(v *PreCheckCreateOrderForDeleteDBNodesResponseBodyFailures) *PreCheckCreateOrderForDeleteDBNodesResponseBody {
	s.Failures = v
	return s
}

func (s *PreCheckCreateOrderForDeleteDBNodesResponseBody) SetPreCheckResult(v bool) *PreCheckCreateOrderForDeleteDBNodesResponseBody {
	s.PreCheckResult = &v
	return s
}

func (s *PreCheckCreateOrderForDeleteDBNodesResponseBody) SetRequestId(v string) *PreCheckCreateOrderForDeleteDBNodesResponseBody {
	s.RequestId = &v
	return s
}

type PreCheckCreateOrderForDeleteDBNodesResponseBodyFailures struct {
	Failures []*PreCheckCreateOrderForDeleteDBNodesResponseBodyFailuresFailures `json:"Failures,omitempty" xml:"Failures,omitempty" type:"Repeated"`
}

func (s PreCheckCreateOrderForDeleteDBNodesResponseBodyFailures) String() string {
	return tea.Prettify(s)
}

func (s PreCheckCreateOrderForDeleteDBNodesResponseBodyFailures) GoString() string {
	return s.String()
}

func (s *PreCheckCreateOrderForDeleteDBNodesResponseBodyFailures) SetFailures(v []*PreCheckCreateOrderForDeleteDBNodesResponseBodyFailuresFailures) *PreCheckCreateOrderForDeleteDBNodesResponseBodyFailures {
	s.Failures = v
	return s
}

type PreCheckCreateOrderForDeleteDBNodesResponseBodyFailuresFailures struct {
	// The response code returned. Valid values:
	//
	// *   **200**: success
	// *   **400**: client error
	// *   **401**: identity authentication failed
	// *   **404**: request page not found
	// *   **500**: server error
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
}

func (s PreCheckCreateOrderForDeleteDBNodesResponseBodyFailuresFailures) String() string {
	return tea.Prettify(s)
}

func (s PreCheckCreateOrderForDeleteDBNodesResponseBodyFailuresFailures) GoString() string {
	return s.String()
}

func (s *PreCheckCreateOrderForDeleteDBNodesResponseBodyFailuresFailures) SetCode(v string) *PreCheckCreateOrderForDeleteDBNodesResponseBodyFailuresFailures {
	s.Code = &v
	return s
}

func (s *PreCheckCreateOrderForDeleteDBNodesResponseBodyFailuresFailures) SetMessage(v string) *PreCheckCreateOrderForDeleteDBNodesResponseBodyFailuresFailures {
	s.Message = &v
	return s
}

type PreCheckCreateOrderForDeleteDBNodesResponse struct {
	Headers    map[string]*string                               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *PreCheckCreateOrderForDeleteDBNodesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s PreCheckCreateOrderForDeleteDBNodesResponse) String() string {
	return tea.Prettify(s)
}

func (s PreCheckCreateOrderForDeleteDBNodesResponse) GoString() string {
	return s.String()
}

func (s *PreCheckCreateOrderForDeleteDBNodesResponse) SetHeaders(v map[string]*string) *PreCheckCreateOrderForDeleteDBNodesResponse {
	s.Headers = v
	return s
}

func (s *PreCheckCreateOrderForDeleteDBNodesResponse) SetStatusCode(v int32) *PreCheckCreateOrderForDeleteDBNodesResponse {
	s.StatusCode = &v
	return s
}

func (s *PreCheckCreateOrderForDeleteDBNodesResponse) SetBody(v *PreCheckCreateOrderForDeleteDBNodesResponseBody) *PreCheckCreateOrderForDeleteDBNodesResponse {
	s.Body = v
	return s
}

type PurgeDBInstanceLogRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the instance. You can call the [DescribeDBInstances](~~610396~~) operation to query the ID of the instance.
	DBInstanceId         *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s PurgeDBInstanceLogRequest) String() string {
	return tea.Prettify(s)
}

func (s PurgeDBInstanceLogRequest) GoString() string {
	return s.String()
}

func (s *PurgeDBInstanceLogRequest) SetClientToken(v string) *PurgeDBInstanceLogRequest {
	s.ClientToken = &v
	return s
}

func (s *PurgeDBInstanceLogRequest) SetDBInstanceId(v string) *PurgeDBInstanceLogRequest {
	s.DBInstanceId = &v
	return s
}

func (s *PurgeDBInstanceLogRequest) SetOwnerAccount(v string) *PurgeDBInstanceLogRequest {
	s.OwnerAccount = &v
	return s
}

func (s *PurgeDBInstanceLogRequest) SetOwnerId(v int64) *PurgeDBInstanceLogRequest {
	s.OwnerId = &v
	return s
}

func (s *PurgeDBInstanceLogRequest) SetResourceOwnerAccount(v string) *PurgeDBInstanceLogRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *PurgeDBInstanceLogRequest) SetResourceOwnerId(v int64) *PurgeDBInstanceLogRequest {
	s.ResourceOwnerId = &v
	return s
}

type PurgeDBInstanceLogResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s PurgeDBInstanceLogResponseBody) String() string {
	return tea.Prettify(s)
}

func (s PurgeDBInstanceLogResponseBody) GoString() string {
	return s.String()
}

func (s *PurgeDBInstanceLogResponseBody) SetRequestId(v string) *PurgeDBInstanceLogResponseBody {
	s.RequestId = &v
	return s
}

type PurgeDBInstanceLogResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *PurgeDBInstanceLogResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s PurgeDBInstanceLogResponse) String() string {
	return tea.Prettify(s)
}

func (s PurgeDBInstanceLogResponse) GoString() string {
	return s.String()
}

func (s *PurgeDBInstanceLogResponse) SetHeaders(v map[string]*string) *PurgeDBInstanceLogResponse {
	s.Headers = v
	return s
}

func (s *PurgeDBInstanceLogResponse) SetStatusCode(v int32) *PurgeDBInstanceLogResponse {
	s.StatusCode = &v
	return s
}

func (s *PurgeDBInstanceLogResponse) SetBody(v *PurgeDBInstanceLogResponseBody) *PurgeDBInstanceLogResponse {
	s.Body = v
	return s
}

type QueryNotifyRequest struct {
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
	From *string `json:"From,omitempty" xml:"From,omitempty"`
	// The number of the page to return. Valid values: any **non-zero** positive integer.
	//
	// Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Valid values:
	//
	// *   **30**
	// *   **50**
	// *   **100**
	//
	// Default value: **30**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The end of the time range to query. The end time must be later than the start time. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
	To *string `json:"To,omitempty" xml:"To,omitempty"`
	// Specifies whether the query results contain confirmed notifications. Valid values:
	//
	// *   **true**
	// *   **false**
	//
	// > You can call the [ConfirmNotify](~~610444~~) operation to confirm notifications of an instance.
	WithConfirmed *bool `json:"WithConfirmed,omitempty" xml:"WithConfirmed,omitempty"`
}

func (s QueryNotifyRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryNotifyRequest) GoString() string {
	return s.String()
}

func (s *QueryNotifyRequest) SetFrom(v string) *QueryNotifyRequest {
	s.From = &v
	return s
}

func (s *QueryNotifyRequest) SetPageNumber(v int32) *QueryNotifyRequest {
	s.PageNumber = &v
	return s
}

func (s *QueryNotifyRequest) SetPageSize(v int32) *QueryNotifyRequest {
	s.PageSize = &v
	return s
}

func (s *QueryNotifyRequest) SetTo(v string) *QueryNotifyRequest {
	s.To = &v
	return s
}

func (s *QueryNotifyRequest) SetWithConfirmed(v bool) *QueryNotifyRequest {
	s.WithConfirmed = &v
	return s
}

type QueryNotifyResponseBody struct {
	// The response parameters.
	Data *QueryNotifyResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s QueryNotifyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryNotifyResponseBody) GoString() string {
	return s.String()
}

func (s *QueryNotifyResponseBody) SetData(v *QueryNotifyResponseBodyData) *QueryNotifyResponseBody {
	s.Data = v
	return s
}

func (s *QueryNotifyResponseBody) SetRequestId(v string) *QueryNotifyResponseBody {
	s.RequestId = &v
	return s
}

type QueryNotifyResponseBodyData struct {
	// The details of notifications.
	NotifyItemList []*QueryNotifyResponseBodyDataNotifyItemList `json:"NotifyItemList,omitempty" xml:"NotifyItemList,omitempty" type:"Repeated"`
	// The page number of the page returned.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The total number of entries returned.
	TotalRecordCount *int32 `json:"TotalRecordCount,omitempty" xml:"TotalRecordCount,omitempty"`
}

func (s QueryNotifyResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryNotifyResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryNotifyResponseBodyData) SetNotifyItemList(v []*QueryNotifyResponseBodyDataNotifyItemList) *QueryNotifyResponseBodyData {
	s.NotifyItemList = v
	return s
}

func (s *QueryNotifyResponseBodyData) SetPageNumber(v int32) *QueryNotifyResponseBodyData {
	s.PageNumber = &v
	return s
}

func (s *QueryNotifyResponseBodyData) SetPageSize(v int32) *QueryNotifyResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *QueryNotifyResponseBodyData) SetTotalRecordCount(v int32) *QueryNotifyResponseBodyData {
	s.TotalRecordCount = &v
	return s
}

type QueryNotifyResponseBodyDataNotifyItemList struct {
	// The ID of the Alibaba Cloud account.
	AliUid *int64 `json:"AliUid,omitempty" xml:"AliUid,omitempty"`
	// Indicates whether the notification has been confirmed. You can call the [ConfirmNotify](~~610444~~) operation to mark the notification as confirmed. Valid values:
	//
	// *   **true**
	// *   **false**
	ConfirmFlag *bool `json:"ConfirmFlag,omitempty" xml:"ConfirmFlag,omitempty"`
	// The UID of the contact who called the [ConfirmNotify](~~610444~~) operation to mark the notification as confirmed. The contact belongs to the current Alibaba Cloud account.
	//
	// The value **0** indicates that the notification is automatically confirmed by the system.
	Confirmor *int64 `json:"Confirmor,omitempty" xml:"Confirmor,omitempty"`
	// The time when the notification was created.
	GmtCreated *string `json:"GmtCreated,omitempty" xml:"GmtCreated,omitempty"`
	// The time when the notification was modified.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The ID of the notification.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The number of times that repeatedly sent notifications are blocked.
	IdempotentCount *string `json:"IdempotentCount,omitempty" xml:"IdempotentCount,omitempty"`
	// This parameter ensures the idempotence of the notification and prevents the notification from being repeatedly sent.
	IdempotentId *string `json:"IdempotentId,omitempty" xml:"IdempotentId,omitempty"`
	// The level of the notification. Valid values:
	//
	// *   **help**
	// *   **success**
	// *   **warning**
	// *   **error**
	// *   **loading**
	// *   **notice**
	Level *string `json:"Level,omitempty" xml:"Level,omitempty"`
	// The element in the notification template. This parameter is a JSON string. Fields in the JSON string vary based on the value of the **TemplateName** parameter.
	//
	// *   If the **TemplateName** parameter is **RenewalRecommend**, the JSON string contains the following fields:
	//
	//     *   **instanceName**: the ID of the instance that is about to expire
	//     *   **reservedTime**: the remaining validity period of the instance in days
	//
	// *   If the **TemplateName** parameter is **InstanceCreateFailed**, the JSON string contains the following fields:
	//
	//     *   **orderId**: the ID of the order to purchase the instance
	//     *   **reason**: the cause of the instance creation failure
	NotifyElement *string `json:"NotifyElement,omitempty" xml:"NotifyElement,omitempty"`
	// The template of the notification. Valid values:
	//
	// *   **RenewalRecommend**: The template that is used to notify of renewal suggestions.
	// *   **InstanceCreateFailed**: The template that is used to notify that an instance fails to be created and is refunded.
	TemplateName *string `json:"TemplateName,omitempty" xml:"TemplateName,omitempty"`
	// The type of the notification. Valid values:
	//
	// *   **Sell**: sales notification
	// *   **Operation**: O\&M notification
	// *   **Promotion**: promotion notification
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s QueryNotifyResponseBodyDataNotifyItemList) String() string {
	return tea.Prettify(s)
}

func (s QueryNotifyResponseBodyDataNotifyItemList) GoString() string {
	return s.String()
}

func (s *QueryNotifyResponseBodyDataNotifyItemList) SetAliUid(v int64) *QueryNotifyResponseBodyDataNotifyItemList {
	s.AliUid = &v
	return s
}

func (s *QueryNotifyResponseBodyDataNotifyItemList) SetConfirmFlag(v bool) *QueryNotifyResponseBodyDataNotifyItemList {
	s.ConfirmFlag = &v
	return s
}

func (s *QueryNotifyResponseBodyDataNotifyItemList) SetConfirmor(v int64) *QueryNotifyResponseBodyDataNotifyItemList {
	s.Confirmor = &v
	return s
}

func (s *QueryNotifyResponseBodyDataNotifyItemList) SetGmtCreated(v string) *QueryNotifyResponseBodyDataNotifyItemList {
	s.GmtCreated = &v
	return s
}

func (s *QueryNotifyResponseBodyDataNotifyItemList) SetGmtModified(v string) *QueryNotifyResponseBodyDataNotifyItemList {
	s.GmtModified = &v
	return s
}

func (s *QueryNotifyResponseBodyDataNotifyItemList) SetId(v int64) *QueryNotifyResponseBodyDataNotifyItemList {
	s.Id = &v
	return s
}

func (s *QueryNotifyResponseBodyDataNotifyItemList) SetIdempotentCount(v string) *QueryNotifyResponseBodyDataNotifyItemList {
	s.IdempotentCount = &v
	return s
}

func (s *QueryNotifyResponseBodyDataNotifyItemList) SetIdempotentId(v string) *QueryNotifyResponseBodyDataNotifyItemList {
	s.IdempotentId = &v
	return s
}

func (s *QueryNotifyResponseBodyDataNotifyItemList) SetLevel(v string) *QueryNotifyResponseBodyDataNotifyItemList {
	s.Level = &v
	return s
}

func (s *QueryNotifyResponseBodyDataNotifyItemList) SetNotifyElement(v string) *QueryNotifyResponseBodyDataNotifyItemList {
	s.NotifyElement = &v
	return s
}

func (s *QueryNotifyResponseBodyDataNotifyItemList) SetTemplateName(v string) *QueryNotifyResponseBodyDataNotifyItemList {
	s.TemplateName = &v
	return s
}

func (s *QueryNotifyResponseBodyDataNotifyItemList) SetType(v string) *QueryNotifyResponseBodyDataNotifyItemList {
	s.Type = &v
	return s
}

type QueryNotifyResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryNotifyResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryNotifyResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryNotifyResponse) GoString() string {
	return s.String()
}

func (s *QueryNotifyResponse) SetHeaders(v map[string]*string) *QueryNotifyResponse {
	s.Headers = v
	return s
}

func (s *QueryNotifyResponse) SetStatusCode(v int32) *QueryNotifyResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryNotifyResponse) SetBody(v *QueryNotifyResponseBody) *QueryNotifyResponse {
	s.Body = v
	return s
}

type QueryRecommendByCodeRequest struct {
	// The code.
	Code    *string `json:"Code,omitempty" xml:"Code,omitempty"`
	OwnerId *string `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The resource group ID.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *string `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s QueryRecommendByCodeRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryRecommendByCodeRequest) GoString() string {
	return s.String()
}

func (s *QueryRecommendByCodeRequest) SetCode(v string) *QueryRecommendByCodeRequest {
	s.Code = &v
	return s
}

func (s *QueryRecommendByCodeRequest) SetOwnerId(v string) *QueryRecommendByCodeRequest {
	s.OwnerId = &v
	return s
}

func (s *QueryRecommendByCodeRequest) SetResourceGroupId(v string) *QueryRecommendByCodeRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *QueryRecommendByCodeRequest) SetResourceOwnerAccount(v string) *QueryRecommendByCodeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *QueryRecommendByCodeRequest) SetResourceOwnerId(v string) *QueryRecommendByCodeRequest {
	s.ResourceOwnerId = &v
	return s
}

type QueryRecommendByCodeResponseBody struct {
	// The returned data.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**
	// *   **false**
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryRecommendByCodeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryRecommendByCodeResponseBody) GoString() string {
	return s.String()
}

func (s *QueryRecommendByCodeResponseBody) SetData(v string) *QueryRecommendByCodeResponseBody {
	s.Data = &v
	return s
}

func (s *QueryRecommendByCodeResponseBody) SetRequestId(v string) *QueryRecommendByCodeResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryRecommendByCodeResponseBody) SetSuccess(v bool) *QueryRecommendByCodeResponseBody {
	s.Success = &v
	return s
}

type QueryRecommendByCodeResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryRecommendByCodeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryRecommendByCodeResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryRecommendByCodeResponse) GoString() string {
	return s.String()
}

func (s *QueryRecommendByCodeResponse) SetHeaders(v map[string]*string) *QueryRecommendByCodeResponse {
	s.Headers = v
	return s
}

func (s *QueryRecommendByCodeResponse) SetStatusCode(v int32) *QueryRecommendByCodeResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryRecommendByCodeResponse) SetBody(v *QueryRecommendByCodeResponseBody) *QueryRecommendByCodeResponse {
	s.Body = v
	return s
}

type RebuildDBInstanceRequest struct {
	// The ID of the primary instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The ID of the dedicated cluster. You can call the [DescribeDedicatedHostGroups](~~141946~~) operation to query the IDs of dedicated clusters.
	DedicatedHostGroupId *string `json:"DedicatedHostGroupId,omitempty" xml:"DedicatedHostGroupId,omitempty"`
	// The ID of the host on which the system rebuilds the secondary instance.
	//
	// >  If you do not specify this parameter, the system preferentially rebuilds the secondary instance on the original host on which the secondary instance resides. If the remaining storage space of the original host is insufficient, the system rebuilds the secondary instance on a host on which the primary instance does not reside. If no suitable hosts are found, the system reports an error that indicates insufficient storage space.
	DedicatedHostId *string `json:"DedicatedHostId,omitempty" xml:"DedicatedHostId,omitempty"`
	OwnerId         *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The role of the secondary instance that you want to rebuild. Valid values:
	//
	// *   **FOLLOWER**: secondary instance
	// *   **LOG**: logger instance
	RebuildNodeType *string `json:"RebuildNodeType,omitempty" xml:"RebuildNodeType,omitempty"`
	// The region ID of the instance. You can call the [DescribeRegions](~~26243~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s RebuildDBInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s RebuildDBInstanceRequest) GoString() string {
	return s.String()
}

func (s *RebuildDBInstanceRequest) SetDBInstanceId(v string) *RebuildDBInstanceRequest {
	s.DBInstanceId = &v
	return s
}

func (s *RebuildDBInstanceRequest) SetDedicatedHostGroupId(v string) *RebuildDBInstanceRequest {
	s.DedicatedHostGroupId = &v
	return s
}

func (s *RebuildDBInstanceRequest) SetDedicatedHostId(v string) *RebuildDBInstanceRequest {
	s.DedicatedHostId = &v
	return s
}

func (s *RebuildDBInstanceRequest) SetOwnerId(v int64) *RebuildDBInstanceRequest {
	s.OwnerId = &v
	return s
}

func (s *RebuildDBInstanceRequest) SetRebuildNodeType(v string) *RebuildDBInstanceRequest {
	s.RebuildNodeType = &v
	return s
}

func (s *RebuildDBInstanceRequest) SetRegionId(v string) *RebuildDBInstanceRequest {
	s.RegionId = &v
	return s
}

func (s *RebuildDBInstanceRequest) SetResourceOwnerAccount(v string) *RebuildDBInstanceRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *RebuildDBInstanceRequest) SetResourceOwnerId(v int64) *RebuildDBInstanceRequest {
	s.ResourceOwnerId = &v
	return s
}

type RebuildDBInstanceResponseBody struct {
	// The serial number of the task in the rebuild task queue. When the serial number becomes 0, the system starts to rebuild the secondary instance.
	MigrationId *int32 `json:"MigrationId,omitempty" xml:"MigrationId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the task.
	TaskId *int32 `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
}

func (s RebuildDBInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RebuildDBInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *RebuildDBInstanceResponseBody) SetMigrationId(v int32) *RebuildDBInstanceResponseBody {
	s.MigrationId = &v
	return s
}

func (s *RebuildDBInstanceResponseBody) SetRequestId(v string) *RebuildDBInstanceResponseBody {
	s.RequestId = &v
	return s
}

func (s *RebuildDBInstanceResponseBody) SetTaskId(v int32) *RebuildDBInstanceResponseBody {
	s.TaskId = &v
	return s
}

type RebuildDBInstanceResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RebuildDBInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RebuildDBInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s RebuildDBInstanceResponse) GoString() string {
	return s.String()
}

func (s *RebuildDBInstanceResponse) SetHeaders(v map[string]*string) *RebuildDBInstanceResponse {
	s.Headers = v
	return s
}

func (s *RebuildDBInstanceResponse) SetStatusCode(v int32) *RebuildDBInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *RebuildDBInstanceResponse) SetBody(v *RebuildDBInstanceResponseBody) *RebuildDBInstanceResponse {
	s.Body = v
	return s
}

type ReceiveDBInstanceRequest struct {
	// The ID of the primary instance. You can call the [DescribeDBInstances](~~26232~~) operation to query the ID of the primary instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The ID of the disaster recovery instance. You can call the [DescribeDBInstances](~~26232~~) operation to query the ID of the disaster recovery instance.
	GuardDBInstanceId    *string `json:"GuardDBInstanceId,omitempty" xml:"GuardDBInstanceId,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ReceiveDBInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s ReceiveDBInstanceRequest) GoString() string {
	return s.String()
}

func (s *ReceiveDBInstanceRequest) SetDBInstanceId(v string) *ReceiveDBInstanceRequest {
	s.DBInstanceId = &v
	return s
}

func (s *ReceiveDBInstanceRequest) SetGuardDBInstanceId(v string) *ReceiveDBInstanceRequest {
	s.GuardDBInstanceId = &v
	return s
}

func (s *ReceiveDBInstanceRequest) SetOwnerAccount(v string) *ReceiveDBInstanceRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ReceiveDBInstanceRequest) SetOwnerId(v int64) *ReceiveDBInstanceRequest {
	s.OwnerId = &v
	return s
}

func (s *ReceiveDBInstanceRequest) SetResourceOwnerAccount(v string) *ReceiveDBInstanceRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ReceiveDBInstanceRequest) SetResourceOwnerId(v int64) *ReceiveDBInstanceRequest {
	s.ResourceOwnerId = &v
	return s
}

type ReceiveDBInstanceResponseBody struct {
	// The ID of the disaster recovery instance after the switchover.
	GuardDBInstanceId *string `json:"GuardDBInstanceId,omitempty" xml:"GuardDBInstanceId,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ReceiveDBInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ReceiveDBInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *ReceiveDBInstanceResponseBody) SetGuardDBInstanceId(v string) *ReceiveDBInstanceResponseBody {
	s.GuardDBInstanceId = &v
	return s
}

func (s *ReceiveDBInstanceResponseBody) SetRequestId(v string) *ReceiveDBInstanceResponseBody {
	s.RequestId = &v
	return s
}

type ReceiveDBInstanceResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ReceiveDBInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ReceiveDBInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s ReceiveDBInstanceResponse) GoString() string {
	return s.String()
}

func (s *ReceiveDBInstanceResponse) SetHeaders(v map[string]*string) *ReceiveDBInstanceResponse {
	s.Headers = v
	return s
}

func (s *ReceiveDBInstanceResponse) SetStatusCode(v int32) *ReceiveDBInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *ReceiveDBInstanceResponse) SetBody(v *ReceiveDBInstanceResponseBody) *ReceiveDBInstanceResponse {
	s.Body = v
	return s
}

type RecoveryDBInstanceRequest struct {
	// The ID of the backup set. You can call the [DescribeBackups](~~26273~~) operation to query the ID of the backup set.
	//
	// If you specify this parameter, you do not need to specify **DBInstanceId**.
	//
	// > You must specify at least one of **BackupId** and **RestoreTime**.
	BackupId *string `json:"BackupId,omitempty" xml:"BackupId,omitempty"`
	// The instance type of the new instance. For more information, see [Instance types](~~26312~~).
	DBInstanceClass *string `json:"DBInstanceClass,omitempty" xml:"DBInstanceClass,omitempty"`
	// The ID of the original instance.
	//
	// > *   If you specify BackupId, you do not need to specify this parameter.
	// > *   If you specify RestoreTime, you must also specify this parameter.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The storage capacity of the new instance. Unit: GB. For more information, see [Instance types](~~26312~~).
	DBInstanceStorage *int32 `json:"DBInstanceStorage,omitempty" xml:"DBInstanceStorage,omitempty"`
	// The storage type of the new instance. Valid values:
	//
	// *   **local_ssd/ephemeral_ssd**: local SSD
	// *   **cloud_ssd**: standard SSD
	// *   **cloud_essd**: enhanced SSD (ESSD)
	DBInstanceStorageType *string `json:"DBInstanceStorageType,omitempty" xml:"DBInstanceStorageType,omitempty"`
	// The name of the database.
	//
	// *   If you want to restore databases to a new instance, the value is in the format of `Original database name 1,New database name 2`.
	// *   If you want to restore databases to an existing instance, the value is in the format of `{"Original database name 1":"New database name 1","Original database name 2":"New database name 2"`.
	DbNames *string `json:"DbNames,omitempty" xml:"DbNames,omitempty"`
	// The network type of the new instance. Valid values:
	//
	// *   **Classic**
	// *   **VPC**
	//
	// By default, the new instance uses the same network type as the original instance.
	InstanceNetworkType *string `json:"InstanceNetworkType,omitempty" xml:"InstanceNetworkType,omitempty"`
	// The billing method of the new instance. Valid values:
	//
	// *   **Postpaid**: pay-as-you-go
	// *   **Prepaid**: subscription
	PayType *string `json:"PayType,omitempty" xml:"PayType,omitempty"`
	// The unit that is used to calculate the billing cycle of the new instance. This parameter takes effect only when you select the subscription billing method for the new instance. Valid values:
	//
	// *   **Year**
	// *   **Month**
	//
	// > This parameter must be specified when **PayType** is set to **Prepaid**.
	Period *string `json:"Period,omitempty" xml:"Period,omitempty"`
	// The internal IP address of the new instance. The internal IP address must be within the CIDR block that is supported by the specified vSwitch. The system automatically assigns a private IP address to an instance based on the values of **VPCId** and **VSwitchId**.
	PrivateIpAddress *string `json:"PrivateIpAddress,omitempty" xml:"PrivateIpAddress,omitempty"`
	ResourceOwnerId  *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The point in time to which you want to restore data. The point in time must fall within the specified log backup retention period. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
	//
	// If you specify this parameter, you must also specify **DBInstanceId**.
	//
	// > You must specify at least one of **BackupId** and **RestoreTime**.
	RestoreTime *string `json:"RestoreTime,omitempty" xml:"RestoreTime,omitempty"`
	// The ID of the destination instance.
	TargetDBInstanceId *string `json:"TargetDBInstanceId,omitempty" xml:"TargetDBInstanceId,omitempty"`
	// The subscription duration of the instance. Valid values:
	//
	// *   Valid values when **Period** is set to **Year**: **1 to 3**.****
	// *   Valid values when **Period** is set to **Month**: **1 to 9**.****
	//
	// > This parameter must be specified when PayType is set to **Prepaid**.
	UsedTime *string `json:"UsedTime,omitempty" xml:"UsedTime,omitempty"`
	// The VPC ID of the new instance.
	VPCId *string `json:"VPCId,omitempty" xml:"VPCId,omitempty"`
	// The vSwitch ID of the new instance. If you specify more than one vSwitch ID, you must separate the IDs with commas (,).
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
}

func (s RecoveryDBInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s RecoveryDBInstanceRequest) GoString() string {
	return s.String()
}

func (s *RecoveryDBInstanceRequest) SetBackupId(v string) *RecoveryDBInstanceRequest {
	s.BackupId = &v
	return s
}

func (s *RecoveryDBInstanceRequest) SetDBInstanceClass(v string) *RecoveryDBInstanceRequest {
	s.DBInstanceClass = &v
	return s
}

func (s *RecoveryDBInstanceRequest) SetDBInstanceId(v string) *RecoveryDBInstanceRequest {
	s.DBInstanceId = &v
	return s
}

func (s *RecoveryDBInstanceRequest) SetDBInstanceStorage(v int32) *RecoveryDBInstanceRequest {
	s.DBInstanceStorage = &v
	return s
}

func (s *RecoveryDBInstanceRequest) SetDBInstanceStorageType(v string) *RecoveryDBInstanceRequest {
	s.DBInstanceStorageType = &v
	return s
}

func (s *RecoveryDBInstanceRequest) SetDbNames(v string) *RecoveryDBInstanceRequest {
	s.DbNames = &v
	return s
}

func (s *RecoveryDBInstanceRequest) SetInstanceNetworkType(v string) *RecoveryDBInstanceRequest {
	s.InstanceNetworkType = &v
	return s
}

func (s *RecoveryDBInstanceRequest) SetPayType(v string) *RecoveryDBInstanceRequest {
	s.PayType = &v
	return s
}

func (s *RecoveryDBInstanceRequest) SetPeriod(v string) *RecoveryDBInstanceRequest {
	s.Period = &v
	return s
}

func (s *RecoveryDBInstanceRequest) SetPrivateIpAddress(v string) *RecoveryDBInstanceRequest {
	s.PrivateIpAddress = &v
	return s
}

func (s *RecoveryDBInstanceRequest) SetResourceOwnerId(v int64) *RecoveryDBInstanceRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *RecoveryDBInstanceRequest) SetRestoreTime(v string) *RecoveryDBInstanceRequest {
	s.RestoreTime = &v
	return s
}

func (s *RecoveryDBInstanceRequest) SetTargetDBInstanceId(v string) *RecoveryDBInstanceRequest {
	s.TargetDBInstanceId = &v
	return s
}

func (s *RecoveryDBInstanceRequest) SetUsedTime(v string) *RecoveryDBInstanceRequest {
	s.UsedTime = &v
	return s
}

func (s *RecoveryDBInstanceRequest) SetVPCId(v string) *RecoveryDBInstanceRequest {
	s.VPCId = &v
	return s
}

func (s *RecoveryDBInstanceRequest) SetVSwitchId(v string) *RecoveryDBInstanceRequest {
	s.VSwitchId = &v
	return s
}

type RecoveryDBInstanceResponseBody struct {
	// The ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The ID of the order.
	OrderId *string `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s RecoveryDBInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RecoveryDBInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *RecoveryDBInstanceResponseBody) SetDBInstanceId(v string) *RecoveryDBInstanceResponseBody {
	s.DBInstanceId = &v
	return s
}

func (s *RecoveryDBInstanceResponseBody) SetOrderId(v string) *RecoveryDBInstanceResponseBody {
	s.OrderId = &v
	return s
}

func (s *RecoveryDBInstanceResponseBody) SetRequestId(v string) *RecoveryDBInstanceResponseBody {
	s.RequestId = &v
	return s
}

type RecoveryDBInstanceResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RecoveryDBInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RecoveryDBInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s RecoveryDBInstanceResponse) GoString() string {
	return s.String()
}

func (s *RecoveryDBInstanceResponse) SetHeaders(v map[string]*string) *RecoveryDBInstanceResponse {
	s.Headers = v
	return s
}

func (s *RecoveryDBInstanceResponse) SetStatusCode(v int32) *RecoveryDBInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *RecoveryDBInstanceResponse) SetBody(v *RecoveryDBInstanceResponseBody) *RecoveryDBInstanceResponse {
	s.Body = v
	return s
}

type ReleaseInstanceConnectionRequest struct {
	// The public endpoint of the instance.
	CurrentConnectionString *string `json:"CurrentConnectionString,omitempty" xml:"CurrentConnectionString,omitempty"`
	// The instance ID. You can call the [DescribeDBInstances](~~610396~~) operation to query the ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The network type of the instance. Valid values:
	//
	// *   **VPC**
	// *   **Classic**
	InstanceNetworkType  *string `json:"InstanceNetworkType,omitempty" xml:"InstanceNetworkType,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ReleaseInstanceConnectionRequest) String() string {
	return tea.Prettify(s)
}

func (s ReleaseInstanceConnectionRequest) GoString() string {
	return s.String()
}

func (s *ReleaseInstanceConnectionRequest) SetCurrentConnectionString(v string) *ReleaseInstanceConnectionRequest {
	s.CurrentConnectionString = &v
	return s
}

func (s *ReleaseInstanceConnectionRequest) SetDBInstanceId(v string) *ReleaseInstanceConnectionRequest {
	s.DBInstanceId = &v
	return s
}

func (s *ReleaseInstanceConnectionRequest) SetInstanceNetworkType(v string) *ReleaseInstanceConnectionRequest {
	s.InstanceNetworkType = &v
	return s
}

func (s *ReleaseInstanceConnectionRequest) SetOwnerAccount(v string) *ReleaseInstanceConnectionRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ReleaseInstanceConnectionRequest) SetOwnerId(v int64) *ReleaseInstanceConnectionRequest {
	s.OwnerId = &v
	return s
}

func (s *ReleaseInstanceConnectionRequest) SetResourceOwnerAccount(v string) *ReleaseInstanceConnectionRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ReleaseInstanceConnectionRequest) SetResourceOwnerId(v int64) *ReleaseInstanceConnectionRequest {
	s.ResourceOwnerId = &v
	return s
}

type ReleaseInstanceConnectionResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ReleaseInstanceConnectionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ReleaseInstanceConnectionResponseBody) GoString() string {
	return s.String()
}

func (s *ReleaseInstanceConnectionResponseBody) SetRequestId(v string) *ReleaseInstanceConnectionResponseBody {
	s.RequestId = &v
	return s
}

type ReleaseInstanceConnectionResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ReleaseInstanceConnectionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ReleaseInstanceConnectionResponse) String() string {
	return tea.Prettify(s)
}

func (s ReleaseInstanceConnectionResponse) GoString() string {
	return s.String()
}

func (s *ReleaseInstanceConnectionResponse) SetHeaders(v map[string]*string) *ReleaseInstanceConnectionResponse {
	s.Headers = v
	return s
}

func (s *ReleaseInstanceConnectionResponse) SetStatusCode(v int32) *ReleaseInstanceConnectionResponse {
	s.StatusCode = &v
	return s
}

func (s *ReleaseInstanceConnectionResponse) SetBody(v *ReleaseInstanceConnectionResponseBody) *ReleaseInstanceConnectionResponse {
	s.Body = v
	return s
}

type ReleaseInstancePublicConnectionRequest struct {
	// The public endpoint.
	CurrentConnectionString *string `json:"CurrentConnectionString,omitempty" xml:"CurrentConnectionString,omitempty"`
	// The ID of the instance.
	DBInstanceId         *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ReleaseInstancePublicConnectionRequest) String() string {
	return tea.Prettify(s)
}

func (s ReleaseInstancePublicConnectionRequest) GoString() string {
	return s.String()
}

func (s *ReleaseInstancePublicConnectionRequest) SetCurrentConnectionString(v string) *ReleaseInstancePublicConnectionRequest {
	s.CurrentConnectionString = &v
	return s
}

func (s *ReleaseInstancePublicConnectionRequest) SetDBInstanceId(v string) *ReleaseInstancePublicConnectionRequest {
	s.DBInstanceId = &v
	return s
}

func (s *ReleaseInstancePublicConnectionRequest) SetOwnerAccount(v string) *ReleaseInstancePublicConnectionRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ReleaseInstancePublicConnectionRequest) SetOwnerId(v int64) *ReleaseInstancePublicConnectionRequest {
	s.OwnerId = &v
	return s
}

func (s *ReleaseInstancePublicConnectionRequest) SetResourceOwnerAccount(v string) *ReleaseInstancePublicConnectionRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ReleaseInstancePublicConnectionRequest) SetResourceOwnerId(v int64) *ReleaseInstancePublicConnectionRequest {
	s.ResourceOwnerId = &v
	return s
}

type ReleaseInstancePublicConnectionResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ReleaseInstancePublicConnectionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ReleaseInstancePublicConnectionResponseBody) GoString() string {
	return s.String()
}

func (s *ReleaseInstancePublicConnectionResponseBody) SetRequestId(v string) *ReleaseInstancePublicConnectionResponseBody {
	s.RequestId = &v
	return s
}

type ReleaseInstancePublicConnectionResponse struct {
	Headers    map[string]*string                           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ReleaseInstancePublicConnectionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ReleaseInstancePublicConnectionResponse) String() string {
	return tea.Prettify(s)
}

func (s ReleaseInstancePublicConnectionResponse) GoString() string {
	return s.String()
}

func (s *ReleaseInstancePublicConnectionResponse) SetHeaders(v map[string]*string) *ReleaseInstancePublicConnectionResponse {
	s.Headers = v
	return s
}

func (s *ReleaseInstancePublicConnectionResponse) SetStatusCode(v int32) *ReleaseInstancePublicConnectionResponse {
	s.StatusCode = &v
	return s
}

func (s *ReleaseInstancePublicConnectionResponse) SetBody(v *ReleaseInstancePublicConnectionResponseBody) *ReleaseInstancePublicConnectionResponse {
	s.Body = v
	return s
}

type ReleaseReadWriteSplittingConnectionRequest struct {
	// The ID of the primary instance. You can call the DescribeDBInstances operation to query the instance ID.
	DBInstanceId         *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ReleaseReadWriteSplittingConnectionRequest) String() string {
	return tea.Prettify(s)
}

func (s ReleaseReadWriteSplittingConnectionRequest) GoString() string {
	return s.String()
}

func (s *ReleaseReadWriteSplittingConnectionRequest) SetDBInstanceId(v string) *ReleaseReadWriteSplittingConnectionRequest {
	s.DBInstanceId = &v
	return s
}

func (s *ReleaseReadWriteSplittingConnectionRequest) SetOwnerAccount(v string) *ReleaseReadWriteSplittingConnectionRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ReleaseReadWriteSplittingConnectionRequest) SetOwnerId(v int64) *ReleaseReadWriteSplittingConnectionRequest {
	s.OwnerId = &v
	return s
}

func (s *ReleaseReadWriteSplittingConnectionRequest) SetResourceOwnerAccount(v string) *ReleaseReadWriteSplittingConnectionRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ReleaseReadWriteSplittingConnectionRequest) SetResourceOwnerId(v int64) *ReleaseReadWriteSplittingConnectionRequest {
	s.ResourceOwnerId = &v
	return s
}

type ReleaseReadWriteSplittingConnectionResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ReleaseReadWriteSplittingConnectionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ReleaseReadWriteSplittingConnectionResponseBody) GoString() string {
	return s.String()
}

func (s *ReleaseReadWriteSplittingConnectionResponseBody) SetRequestId(v string) *ReleaseReadWriteSplittingConnectionResponseBody {
	s.RequestId = &v
	return s
}

type ReleaseReadWriteSplittingConnectionResponse struct {
	Headers    map[string]*string                               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ReleaseReadWriteSplittingConnectionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ReleaseReadWriteSplittingConnectionResponse) String() string {
	return tea.Prettify(s)
}

func (s ReleaseReadWriteSplittingConnectionResponse) GoString() string {
	return s.String()
}

func (s *ReleaseReadWriteSplittingConnectionResponse) SetHeaders(v map[string]*string) *ReleaseReadWriteSplittingConnectionResponse {
	s.Headers = v
	return s
}

func (s *ReleaseReadWriteSplittingConnectionResponse) SetStatusCode(v int32) *ReleaseReadWriteSplittingConnectionResponse {
	s.StatusCode = &v
	return s
}

func (s *ReleaseReadWriteSplittingConnectionResponse) SetBody(v *ReleaseReadWriteSplittingConnectionResponseBody) *ReleaseReadWriteSplittingConnectionResponse {
	s.Body = v
	return s
}

type RemoveTagsFromResourceRequest struct {
	Tag []*RemoveTagsFromResourceRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region. You can call the [DescribeRegions](~~26243~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group. You can call the [ListResourceGroups](~~158855~~) operation to obtain the ID of the resource group.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// A set of a TagKey and a TagValue that you use to unbind the tag. Format: {"key1":"value1"}.
	//
	// >  You cannot specify an empty string for TagKey. You can specify an empty string for TagValue.
	Tags *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
	// The ID of the proxy mode.
	ProxyId *string `json:"proxyId,omitempty" xml:"proxyId,omitempty"`
}

func (s RemoveTagsFromResourceRequest) String() string {
	return tea.Prettify(s)
}

func (s RemoveTagsFromResourceRequest) GoString() string {
	return s.String()
}

func (s *RemoveTagsFromResourceRequest) SetTag(v []*RemoveTagsFromResourceRequestTag) *RemoveTagsFromResourceRequest {
	s.Tag = v
	return s
}

func (s *RemoveTagsFromResourceRequest) SetClientToken(v string) *RemoveTagsFromResourceRequest {
	s.ClientToken = &v
	return s
}

func (s *RemoveTagsFromResourceRequest) SetDBInstanceId(v string) *RemoveTagsFromResourceRequest {
	s.DBInstanceId = &v
	return s
}

func (s *RemoveTagsFromResourceRequest) SetOwnerAccount(v string) *RemoveTagsFromResourceRequest {
	s.OwnerAccount = &v
	return s
}

func (s *RemoveTagsFromResourceRequest) SetOwnerId(v int64) *RemoveTagsFromResourceRequest {
	s.OwnerId = &v
	return s
}

func (s *RemoveTagsFromResourceRequest) SetRegionId(v string) *RemoveTagsFromResourceRequest {
	s.RegionId = &v
	return s
}

func (s *RemoveTagsFromResourceRequest) SetResourceGroupId(v string) *RemoveTagsFromResourceRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *RemoveTagsFromResourceRequest) SetResourceOwnerAccount(v string) *RemoveTagsFromResourceRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *RemoveTagsFromResourceRequest) SetResourceOwnerId(v int64) *RemoveTagsFromResourceRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *RemoveTagsFromResourceRequest) SetTags(v string) *RemoveTagsFromResourceRequest {
	s.Tags = &v
	return s
}

func (s *RemoveTagsFromResourceRequest) SetProxyId(v string) *RemoveTagsFromResourceRequest {
	s.ProxyId = &v
	return s
}

type RemoveTagsFromResourceRequestTag struct {
	// The TagKey of the first tag that you want to unbind. Each tag consists of a TagKey and a TagValue. You can specify up to five tags in a single request. You cannot specify an empty string as the tag key. You can specify an empty string as the tag value.
	Key *string `json:"key,omitempty" xml:"key,omitempty"`
	// The TagValue of the first tag that you want to unbind. Each tag consists of a TagKey and a TagValue. You can specify up to five tags in a single request. You cannot specify an empty string as the tag key. You can specify an empty string as the tag value.
	Value *string `json:"value,omitempty" xml:"value,omitempty"`
}

func (s RemoveTagsFromResourceRequestTag) String() string {
	return tea.Prettify(s)
}

func (s RemoveTagsFromResourceRequestTag) GoString() string {
	return s.String()
}

func (s *RemoveTagsFromResourceRequestTag) SetKey(v string) *RemoveTagsFromResourceRequestTag {
	s.Key = &v
	return s
}

func (s *RemoveTagsFromResourceRequestTag) SetValue(v string) *RemoveTagsFromResourceRequestTag {
	s.Value = &v
	return s
}

type RemoveTagsFromResourceResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s RemoveTagsFromResourceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RemoveTagsFromResourceResponseBody) GoString() string {
	return s.String()
}

func (s *RemoveTagsFromResourceResponseBody) SetRequestId(v string) *RemoveTagsFromResourceResponseBody {
	s.RequestId = &v
	return s
}

type RemoveTagsFromResourceResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RemoveTagsFromResourceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RemoveTagsFromResourceResponse) String() string {
	return tea.Prettify(s)
}

func (s RemoveTagsFromResourceResponse) GoString() string {
	return s.String()
}

func (s *RemoveTagsFromResourceResponse) SetHeaders(v map[string]*string) *RemoveTagsFromResourceResponse {
	s.Headers = v
	return s
}

func (s *RemoveTagsFromResourceResponse) SetStatusCode(v int32) *RemoveTagsFromResourceResponse {
	s.StatusCode = &v
	return s
}

func (s *RemoveTagsFromResourceResponse) SetBody(v *RemoveTagsFromResourceResponseBody) *RemoveTagsFromResourceResponse {
	s.Body = v
	return s
}

type RenewInstanceRequest struct {
	// Specifies whether payment is automatically made during renewal. Valid values:
	//
	// *   **True**: enables automatic payment. Make sure that your Alibaba Cloud account has adequate balance.
	// *   **False** (default): disables automatic payment. You have to manually pay the order in the console. Log on to the ApsaraDB RDS console. In the upper-right corner, choose **Expenses > User Center**. In the left-side navigation pane, click **Orders**. On the page that appears, find your order and complete the payment.
	AutoPay *string `json:"AutoPay,omitempty" xml:"AutoPay,omitempty"`
	// Specifies whether to enable auto-renewal for the instance. Valid values:
	//
	// *   **true**.
	// *   **false** (default)
	AutoRenew *string `json:"AutoRenew,omitempty" xml:"AutoRenew,omitempty"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the generated token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The duration of the subscription renewal. Unit: month. Valid values:
	//
	// *   **1~9**
	// *   **12**
	// *   **24**
	// *   **36**
	// *   **48**
	// *   **60**
	Period               *int32  `json:"Period,omitempty" xml:"Period,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s RenewInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s RenewInstanceRequest) GoString() string {
	return s.String()
}

func (s *RenewInstanceRequest) SetAutoPay(v string) *RenewInstanceRequest {
	s.AutoPay = &v
	return s
}

func (s *RenewInstanceRequest) SetAutoRenew(v string) *RenewInstanceRequest {
	s.AutoRenew = &v
	return s
}

func (s *RenewInstanceRequest) SetClientToken(v string) *RenewInstanceRequest {
	s.ClientToken = &v
	return s
}

func (s *RenewInstanceRequest) SetDBInstanceId(v string) *RenewInstanceRequest {
	s.DBInstanceId = &v
	return s
}

func (s *RenewInstanceRequest) SetOwnerId(v int64) *RenewInstanceRequest {
	s.OwnerId = &v
	return s
}

func (s *RenewInstanceRequest) SetPeriod(v int32) *RenewInstanceRequest {
	s.Period = &v
	return s
}

func (s *RenewInstanceRequest) SetResourceOwnerAccount(v string) *RenewInstanceRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *RenewInstanceRequest) SetResourceOwnerId(v int64) *RenewInstanceRequest {
	s.ResourceOwnerId = &v
	return s
}

type RenewInstanceResponseBody struct {
	// The ID of the order.
	OrderId *int64 `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s RenewInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RenewInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *RenewInstanceResponseBody) SetOrderId(v int64) *RenewInstanceResponseBody {
	s.OrderId = &v
	return s
}

func (s *RenewInstanceResponseBody) SetRequestId(v string) *RenewInstanceResponseBody {
	s.RequestId = &v
	return s
}

type RenewInstanceResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RenewInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RenewInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s RenewInstanceResponse) GoString() string {
	return s.String()
}

func (s *RenewInstanceResponse) SetHeaders(v map[string]*string) *RenewInstanceResponse {
	s.Headers = v
	return s
}

func (s *RenewInstanceResponse) SetStatusCode(v int32) *RenewInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *RenewInstanceResponse) SetBody(v *RenewInstanceResponseBody) *RenewInstanceResponse {
	s.Body = v
	return s
}

type ResetAccountRequest struct {
	// The name of the privileged account.
	AccountName *string `json:"AccountName,omitempty" xml:"AccountName,omitempty"`
	// The new password of the privileged account.
	//
	// >
	//
	// *   The password must be 8 to 32 characters in length.
	//
	// *   It must contain at least three of the following character types: uppercase letters, lowercase letters, digits, and special characters.
	//
	// *   It can contain the following special characters: `! @ # $ & ; % ^ * () _ + - =`.
	AccountPassword *string `json:"AccountPassword,omitempty" xml:"AccountPassword,omitempty"`
	// The instance ID. You can call the DescribeDBInstances operation to query the instance ID.
	DBInstanceId         *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ResetAccountRequest) String() string {
	return tea.Prettify(s)
}

func (s ResetAccountRequest) GoString() string {
	return s.String()
}

func (s *ResetAccountRequest) SetAccountName(v string) *ResetAccountRequest {
	s.AccountName = &v
	return s
}

func (s *ResetAccountRequest) SetAccountPassword(v string) *ResetAccountRequest {
	s.AccountPassword = &v
	return s
}

func (s *ResetAccountRequest) SetDBInstanceId(v string) *ResetAccountRequest {
	s.DBInstanceId = &v
	return s
}

func (s *ResetAccountRequest) SetOwnerAccount(v string) *ResetAccountRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ResetAccountRequest) SetOwnerId(v int64) *ResetAccountRequest {
	s.OwnerId = &v
	return s
}

func (s *ResetAccountRequest) SetResourceOwnerAccount(v string) *ResetAccountRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ResetAccountRequest) SetResourceOwnerId(v int64) *ResetAccountRequest {
	s.ResourceOwnerId = &v
	return s
}

type ResetAccountResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ResetAccountResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ResetAccountResponseBody) GoString() string {
	return s.String()
}

func (s *ResetAccountResponseBody) SetRequestId(v string) *ResetAccountResponseBody {
	s.RequestId = &v
	return s
}

type ResetAccountResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ResetAccountResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ResetAccountResponse) String() string {
	return tea.Prettify(s)
}

func (s ResetAccountResponse) GoString() string {
	return s.String()
}

func (s *ResetAccountResponse) SetHeaders(v map[string]*string) *ResetAccountResponse {
	s.Headers = v
	return s
}

func (s *ResetAccountResponse) SetStatusCode(v int32) *ResetAccountResponse {
	s.StatusCode = &v
	return s
}

func (s *ResetAccountResponse) SetBody(v *ResetAccountResponseBody) *ResetAccountResponse {
	s.Body = v
	return s
}

type ResetAccountPasswordRequest struct {
	// The username of the account.
	AccountName *string `json:"AccountName,omitempty" xml:"AccountName,omitempty"`
	// The new password.
	//
	// >
	//
	// *   The value must be 8 to 32 characters in length.
	//
	// *   The value must contain at least three types of the following characters: uppercase letters, lowercase letters, digits, and special characters.
	// *   The following special characters are supported: ! @ # $ & % ^ \* ( ) \_ + - =
	AccountPassword *string `json:"AccountPassword,omitempty" xml:"AccountPassword,omitempty"`
	// The instance ID. You can call the DescribeDBInstances operation to query the instance ID.
	DBInstanceId         *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ResetAccountPasswordRequest) String() string {
	return tea.Prettify(s)
}

func (s ResetAccountPasswordRequest) GoString() string {
	return s.String()
}

func (s *ResetAccountPasswordRequest) SetAccountName(v string) *ResetAccountPasswordRequest {
	s.AccountName = &v
	return s
}

func (s *ResetAccountPasswordRequest) SetAccountPassword(v string) *ResetAccountPasswordRequest {
	s.AccountPassword = &v
	return s
}

func (s *ResetAccountPasswordRequest) SetDBInstanceId(v string) *ResetAccountPasswordRequest {
	s.DBInstanceId = &v
	return s
}

func (s *ResetAccountPasswordRequest) SetOwnerAccount(v string) *ResetAccountPasswordRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ResetAccountPasswordRequest) SetOwnerId(v int64) *ResetAccountPasswordRequest {
	s.OwnerId = &v
	return s
}

func (s *ResetAccountPasswordRequest) SetResourceOwnerAccount(v string) *ResetAccountPasswordRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ResetAccountPasswordRequest) SetResourceOwnerId(v int64) *ResetAccountPasswordRequest {
	s.ResourceOwnerId = &v
	return s
}

type ResetAccountPasswordResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ResetAccountPasswordResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ResetAccountPasswordResponseBody) GoString() string {
	return s.String()
}

func (s *ResetAccountPasswordResponseBody) SetRequestId(v string) *ResetAccountPasswordResponseBody {
	s.RequestId = &v
	return s
}

type ResetAccountPasswordResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ResetAccountPasswordResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ResetAccountPasswordResponse) String() string {
	return tea.Prettify(s)
}

func (s ResetAccountPasswordResponse) GoString() string {
	return s.String()
}

func (s *ResetAccountPasswordResponse) SetHeaders(v map[string]*string) *ResetAccountPasswordResponse {
	s.Headers = v
	return s
}

func (s *ResetAccountPasswordResponse) SetStatusCode(v int32) *ResetAccountPasswordResponse {
	s.StatusCode = &v
	return s
}

func (s *ResetAccountPasswordResponse) SetBody(v *ResetAccountPasswordResponseBody) *ResetAccountPasswordResponse {
	s.Body = v
	return s
}

type RestartDBInstanceRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The instance ID. You can call the [DescribeDBInstances](~~610396~~) operation to query the ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The node ID, which can be used to restart a specified node. You can call the [DescribeDBInstanceHAConfig](~~610434~~) operation to obtain the node ID.
	//
	// > : The secondary instance restart feature is supported for RDS instances that run SQL Server EE on RDS Cluster Edition. For more information, see [Restart a secondary database](~~2411880~~).
	NodeId               *string `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s RestartDBInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s RestartDBInstanceRequest) GoString() string {
	return s.String()
}

func (s *RestartDBInstanceRequest) SetClientToken(v string) *RestartDBInstanceRequest {
	s.ClientToken = &v
	return s
}

func (s *RestartDBInstanceRequest) SetDBInstanceId(v string) *RestartDBInstanceRequest {
	s.DBInstanceId = &v
	return s
}

func (s *RestartDBInstanceRequest) SetNodeId(v string) *RestartDBInstanceRequest {
	s.NodeId = &v
	return s
}

func (s *RestartDBInstanceRequest) SetOwnerAccount(v string) *RestartDBInstanceRequest {
	s.OwnerAccount = &v
	return s
}

func (s *RestartDBInstanceRequest) SetOwnerId(v int64) *RestartDBInstanceRequest {
	s.OwnerId = &v
	return s
}

func (s *RestartDBInstanceRequest) SetResourceOwnerAccount(v string) *RestartDBInstanceRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *RestartDBInstanceRequest) SetResourceOwnerId(v int64) *RestartDBInstanceRequest {
	s.ResourceOwnerId = &v
	return s
}

type RestartDBInstanceResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s RestartDBInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RestartDBInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *RestartDBInstanceResponseBody) SetRequestId(v string) *RestartDBInstanceResponseBody {
	s.RequestId = &v
	return s
}

type RestartDBInstanceResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RestartDBInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RestartDBInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s RestartDBInstanceResponse) GoString() string {
	return s.String()
}

func (s *RestartDBInstanceResponse) SetHeaders(v map[string]*string) *RestartDBInstanceResponse {
	s.Headers = v
	return s
}

func (s *RestartDBInstanceResponse) SetStatusCode(v int32) *RestartDBInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *RestartDBInstanceResponse) SetBody(v *RestartDBInstanceResponseBody) *RestartDBInstanceResponse {
	s.Body = v
	return s
}

type RestoreDdrTableRequest struct {
	// The ID of the backup set.
	BackupId *string `json:"BackupId,omitempty" xml:"BackupId,omitempty"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the instance. You can call the [DescribeRegions](~~26243~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The point in time to which you want to restore data. The point in time that you specify must be earlier than the current time. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
	//
	// > If **RestoreType** is set to **BackupTime**, you must specify this parameter.
	RestoreTime *string `json:"RestoreTime,omitempty" xml:"RestoreTime,omitempty"`
	// The method that is used to restore data. Valid values:
	//
	// *   **0**: restores data from a backup set. If you set this parameter to 0, you must also specify the **BackupSetId** parameter.
	// *   **1**: restores data to a point in time. If you set this parameter to 1, you must also specify the **RestoreTime**, **SourceRegion**, and **SourceDBInstanceName** parameters.
	//
	// Default value: **0**.
	RestoreType *string `json:"RestoreType,omitempty" xml:"RestoreType,omitempty"`
	// The ID of the source instance if you want to restore data to a point in time.
	//
	// > : If you set **RestoreType** to **1**, you must also specify this parameter.
	SourceDBInstanceName *string `json:"SourceDBInstanceName,omitempty" xml:"SourceDBInstanceName,omitempty"`
	// The region ID of the source instance if you want to restore data to a point in time.
	//
	// > : If you set **RestoreType** to **1**, you must also specify this parameter.
	SourceRegion *string `json:"SourceRegion,omitempty" xml:"SourceRegion,omitempty"`
	// The names of the databases and tables that you want to restore. The value is in the following format: `[{"type":"db","name":"<The name of Database 1 on the source instance>","newname":"<The name of Database 1 on the destination instance>","tables":[{"type":"table","name":"<The name of Table 1 in Database 1 on the source instance>","newname":"<The name of Table 1 in Database 1 on the destination instance>"},{"type":"table","name":"<The name of Table 2 in Database 1 on the source instance>","newname":"<The name of Table 2 in Database 1 on the destination instance>"}]},{"type":"db","name":"<The name of Database 2 on the source instance>","newname":"<The name of Database 2 on the destination instance>","tables":[{"type":"table","name":"<The name of Table 3 in Database 2 on the source instance>","newname":"<The name of Table 3 in Database 2 on the destination instance>"},{"type":"table","name":"<The name of Table 4 in Database 2 on the source instance>","newname":"<The name of Table 4 in Database 2 on the destination instance>"}]}]`
	TableMeta *string `json:"TableMeta,omitempty" xml:"TableMeta,omitempty"`
}

func (s RestoreDdrTableRequest) String() string {
	return tea.Prettify(s)
}

func (s RestoreDdrTableRequest) GoString() string {
	return s.String()
}

func (s *RestoreDdrTableRequest) SetBackupId(v string) *RestoreDdrTableRequest {
	s.BackupId = &v
	return s
}

func (s *RestoreDdrTableRequest) SetClientToken(v string) *RestoreDdrTableRequest {
	s.ClientToken = &v
	return s
}

func (s *RestoreDdrTableRequest) SetDBInstanceId(v string) *RestoreDdrTableRequest {
	s.DBInstanceId = &v
	return s
}

func (s *RestoreDdrTableRequest) SetOwnerId(v int64) *RestoreDdrTableRequest {
	s.OwnerId = &v
	return s
}

func (s *RestoreDdrTableRequest) SetRegionId(v string) *RestoreDdrTableRequest {
	s.RegionId = &v
	return s
}

func (s *RestoreDdrTableRequest) SetResourceGroupId(v string) *RestoreDdrTableRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *RestoreDdrTableRequest) SetResourceOwnerAccount(v string) *RestoreDdrTableRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *RestoreDdrTableRequest) SetResourceOwnerId(v int64) *RestoreDdrTableRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *RestoreDdrTableRequest) SetRestoreTime(v string) *RestoreDdrTableRequest {
	s.RestoreTime = &v
	return s
}

func (s *RestoreDdrTableRequest) SetRestoreType(v string) *RestoreDdrTableRequest {
	s.RestoreType = &v
	return s
}

func (s *RestoreDdrTableRequest) SetSourceDBInstanceName(v string) *RestoreDdrTableRequest {
	s.SourceDBInstanceName = &v
	return s
}

func (s *RestoreDdrTableRequest) SetSourceRegion(v string) *RestoreDdrTableRequest {
	s.SourceRegion = &v
	return s
}

func (s *RestoreDdrTableRequest) SetTableMeta(v string) *RestoreDdrTableRequest {
	s.TableMeta = &v
	return s
}

type RestoreDdrTableResponseBody struct {
	// The ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s RestoreDdrTableResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RestoreDdrTableResponseBody) GoString() string {
	return s.String()
}

func (s *RestoreDdrTableResponseBody) SetDBInstanceId(v string) *RestoreDdrTableResponseBody {
	s.DBInstanceId = &v
	return s
}

func (s *RestoreDdrTableResponseBody) SetRequestId(v string) *RestoreDdrTableResponseBody {
	s.RequestId = &v
	return s
}

type RestoreDdrTableResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RestoreDdrTableResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RestoreDdrTableResponse) String() string {
	return tea.Prettify(s)
}

func (s RestoreDdrTableResponse) GoString() string {
	return s.String()
}

func (s *RestoreDdrTableResponse) SetHeaders(v map[string]*string) *RestoreDdrTableResponse {
	s.Headers = v
	return s
}

func (s *RestoreDdrTableResponse) SetStatusCode(v int32) *RestoreDdrTableResponse {
	s.StatusCode = &v
	return s
}

func (s *RestoreDdrTableResponse) SetBody(v *RestoreDdrTableResponseBody) *RestoreDdrTableResponse {
	s.Body = v
	return s
}

type RestoreTableRequest struct {
	// The ID of the backup set. You can call the [DescribeBackups](~~26273~~) operation to obtain the ID of the backup set.
	//
	// > You must specify at least one of BackupId or **RestoreTime** parameters.
	BackupId *string `json:"BackupId,omitempty" xml:"BackupId,omitempty"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// Specifies whether to enable the fast restoration feature for individual databases and tables. Valid values:
	//
	// *   **true**: enables the feature.
	// *   **false**: disables the feature.
	//
	// > For more information, see [Restore individual databases and tables of an ApsaraDB RDS for MySQL instance](~~103175~~).
	InstantRecovery      *bool   `json:"InstantRecovery,omitempty" xml:"InstantRecovery,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The point in time to which you want to restore data. The point in time must fall within the specified log backup retention period. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
	//
	// > *   You must specify at least one of **BackupId** and **RestoreTime**.
	// > *   You must enable the log backup feature. For more information, see [Back up an ApsaraDB RDS for MySQL instance](~~98818~~).
	RestoreTime *string `json:"RestoreTime,omitempty" xml:"RestoreTime,omitempty"`
	// The names of the databases and tables that you want to restore. The value is in the following format: `[{"type":"db","name":"<The name of Database 1 on the source instance>","newname":"<The name of Database 1 on the destination instance>","tables":[{"type":"table","name":"<The name of Table 1 in Database 1 on the source instance>","newname":"<The name of Table 1 in Database 1 on the destination instance>"},{"type":"table","name":"<The name of Table 2 in Database 1 on the source instance>","newname":"<The name of Table 2 in Database 1 on the destination instance>"}]},{"type":"db","name":"<The name of Database 2 on the source instance>","newname":"<The name of Database 2 on the destination instance>","tables":[{"type":"table","name":"<The name of Table 3 in Database 2 on the source instance>","newname":"<The name of Table 3 in Database 2 on the destination instance>"},{"type":"table","name":"<The name of Table 4 in Database 2 on the source instance>","newname":"<The name of Table 4 in Database 2 on the destination instance>"}]}]`
	TableMeta *string `json:"TableMeta,omitempty" xml:"TableMeta,omitempty"`
}

func (s RestoreTableRequest) String() string {
	return tea.Prettify(s)
}

func (s RestoreTableRequest) GoString() string {
	return s.String()
}

func (s *RestoreTableRequest) SetBackupId(v string) *RestoreTableRequest {
	s.BackupId = &v
	return s
}

func (s *RestoreTableRequest) SetClientToken(v string) *RestoreTableRequest {
	s.ClientToken = &v
	return s
}

func (s *RestoreTableRequest) SetDBInstanceId(v string) *RestoreTableRequest {
	s.DBInstanceId = &v
	return s
}

func (s *RestoreTableRequest) SetInstantRecovery(v bool) *RestoreTableRequest {
	s.InstantRecovery = &v
	return s
}

func (s *RestoreTableRequest) SetOwnerAccount(v string) *RestoreTableRequest {
	s.OwnerAccount = &v
	return s
}

func (s *RestoreTableRequest) SetOwnerId(v int64) *RestoreTableRequest {
	s.OwnerId = &v
	return s
}

func (s *RestoreTableRequest) SetResourceOwnerAccount(v string) *RestoreTableRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *RestoreTableRequest) SetResourceOwnerId(v int64) *RestoreTableRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *RestoreTableRequest) SetRestoreTime(v string) *RestoreTableRequest {
	s.RestoreTime = &v
	return s
}

func (s *RestoreTableRequest) SetTableMeta(v string) *RestoreTableRequest {
	s.TableMeta = &v
	return s
}

type RestoreTableResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s RestoreTableResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RestoreTableResponseBody) GoString() string {
	return s.String()
}

func (s *RestoreTableResponseBody) SetRequestId(v string) *RestoreTableResponseBody {
	s.RequestId = &v
	return s
}

type RestoreTableResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RestoreTableResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RestoreTableResponse) String() string {
	return tea.Prettify(s)
}

func (s RestoreTableResponse) GoString() string {
	return s.String()
}

func (s *RestoreTableResponse) SetHeaders(v map[string]*string) *RestoreTableResponse {
	s.Headers = v
	return s
}

func (s *RestoreTableResponse) SetStatusCode(v int32) *RestoreTableResponse {
	s.StatusCode = &v
	return s
}

func (s *RestoreTableResponse) SetBody(v *RestoreTableResponseBody) *RestoreTableResponse {
	s.Body = v
	return s
}

type RevokeAccountPrivilegeRequest struct {
	// The name of the account.
	AccountName *string `json:"AccountName,omitempty" xml:"AccountName,omitempty"`
	// The instance ID. You can call the DescribeDBInstances operation to query the instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The name of the database. You can revoke all permissions of the account on this database. Separate multiple databases with commas (,).
	DBName               *string `json:"DBName,omitempty" xml:"DBName,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s RevokeAccountPrivilegeRequest) String() string {
	return tea.Prettify(s)
}

func (s RevokeAccountPrivilegeRequest) GoString() string {
	return s.String()
}

func (s *RevokeAccountPrivilegeRequest) SetAccountName(v string) *RevokeAccountPrivilegeRequest {
	s.AccountName = &v
	return s
}

func (s *RevokeAccountPrivilegeRequest) SetDBInstanceId(v string) *RevokeAccountPrivilegeRequest {
	s.DBInstanceId = &v
	return s
}

func (s *RevokeAccountPrivilegeRequest) SetDBName(v string) *RevokeAccountPrivilegeRequest {
	s.DBName = &v
	return s
}

func (s *RevokeAccountPrivilegeRequest) SetOwnerAccount(v string) *RevokeAccountPrivilegeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *RevokeAccountPrivilegeRequest) SetOwnerId(v int64) *RevokeAccountPrivilegeRequest {
	s.OwnerId = &v
	return s
}

func (s *RevokeAccountPrivilegeRequest) SetResourceOwnerAccount(v string) *RevokeAccountPrivilegeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *RevokeAccountPrivilegeRequest) SetResourceOwnerId(v int64) *RevokeAccountPrivilegeRequest {
	s.ResourceOwnerId = &v
	return s
}

type RevokeAccountPrivilegeResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s RevokeAccountPrivilegeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RevokeAccountPrivilegeResponseBody) GoString() string {
	return s.String()
}

func (s *RevokeAccountPrivilegeResponseBody) SetRequestId(v string) *RevokeAccountPrivilegeResponseBody {
	s.RequestId = &v
	return s
}

type RevokeAccountPrivilegeResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RevokeAccountPrivilegeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RevokeAccountPrivilegeResponse) String() string {
	return tea.Prettify(s)
}

func (s RevokeAccountPrivilegeResponse) GoString() string {
	return s.String()
}

func (s *RevokeAccountPrivilegeResponse) SetHeaders(v map[string]*string) *RevokeAccountPrivilegeResponse {
	s.Headers = v
	return s
}

func (s *RevokeAccountPrivilegeResponse) SetStatusCode(v int32) *RevokeAccountPrivilegeResponse {
	s.StatusCode = &v
	return s
}

func (s *RevokeAccountPrivilegeResponse) SetBody(v *RevokeAccountPrivilegeResponseBody) *RevokeAccountPrivilegeResponse {
	s.Body = v
	return s
}

type RevokeOperatorPermissionRequest struct {
	// The instance ID. You can call the DescribeDBInstances operation to query the instance ID.
	DBInstanceId         *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s RevokeOperatorPermissionRequest) String() string {
	return tea.Prettify(s)
}

func (s RevokeOperatorPermissionRequest) GoString() string {
	return s.String()
}

func (s *RevokeOperatorPermissionRequest) SetDBInstanceId(v string) *RevokeOperatorPermissionRequest {
	s.DBInstanceId = &v
	return s
}

func (s *RevokeOperatorPermissionRequest) SetOwnerAccount(v string) *RevokeOperatorPermissionRequest {
	s.OwnerAccount = &v
	return s
}

func (s *RevokeOperatorPermissionRequest) SetOwnerId(v int64) *RevokeOperatorPermissionRequest {
	s.OwnerId = &v
	return s
}

func (s *RevokeOperatorPermissionRequest) SetResourceOwnerAccount(v string) *RevokeOperatorPermissionRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *RevokeOperatorPermissionRequest) SetResourceOwnerId(v int64) *RevokeOperatorPermissionRequest {
	s.ResourceOwnerId = &v
	return s
}

type RevokeOperatorPermissionResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s RevokeOperatorPermissionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RevokeOperatorPermissionResponseBody) GoString() string {
	return s.String()
}

func (s *RevokeOperatorPermissionResponseBody) SetRequestId(v string) *RevokeOperatorPermissionResponseBody {
	s.RequestId = &v
	return s
}

type RevokeOperatorPermissionResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RevokeOperatorPermissionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RevokeOperatorPermissionResponse) String() string {
	return tea.Prettify(s)
}

func (s RevokeOperatorPermissionResponse) GoString() string {
	return s.String()
}

func (s *RevokeOperatorPermissionResponse) SetHeaders(v map[string]*string) *RevokeOperatorPermissionResponse {
	s.Headers = v
	return s
}

func (s *RevokeOperatorPermissionResponse) SetStatusCode(v int32) *RevokeOperatorPermissionResponse {
	s.StatusCode = &v
	return s
}

func (s *RevokeOperatorPermissionResponse) SetBody(v *RevokeOperatorPermissionResponseBody) *RevokeOperatorPermissionResponse {
	s.Body = v
	return s
}

type StartDBInstanceRequest struct {
	// The instance ID. You can call the [DescribeDBInstances](~~610396~~) operation to query the ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The data migration method of the instance. This parameter is available only for instances that are created in dedicated clusters. Valid values:
	//
	// *   **0** (default): The system preferentially upgrades or downgrades the instance without a migration. If the resources on the host on which the instance resides are insufficient, the system migrates the instance to another suitable host.
	// *   **1**: The system upgrades or downgrades the instance without a migration. If the upgrade or downgrade is not supported, the system reports an error.
	// *   **2**: The system migrates the data of the instance from the host on which the instance resides to another host. You must also specify **DedicatedHostGroupId**, **TargetDedicatedHostIdForMaster**, and **TargetDedicatedHostIdForSlave**. If you set DBInstanceTransType to 2, you cannot migrate the data of the instance to the host on which the instance resides. If you migrate the data of the instance to the host on which the instance resides, the migration fails.
	DBInstanceTransType *int32 `json:"DBInstanceTransType,omitempty" xml:"DBInstanceTransType,omitempty"`
	// The ID of the dedicated cluster. This parameter is required when you want to resume an instance in a dedicated cluster. You can call the [DescribeDedicatedHostGroups](~~610640~~) operation to query the ID of the dedicated cluster.
	DedicatedHostGroupId *string `json:"DedicatedHostGroupId,omitempty" xml:"DedicatedHostGroupId,omitempty"`
	// The effective time. This parameter is available only for instances that are created in dedicated clusters.
	//
	// *   **Immediate**
	// *   **MaintainTime**: The effective time is within the maintenance window. For more information, see [ModifyDBInstanceMaintainTime](~~26249~~).
	// *   **SpecificTime**: The effective time is specified.
	//
	// Default value: MaintainTime.
	EffectiveTime *string `json:"EffectiveTime,omitempty" xml:"EffectiveTime,omitempty"`
	// The database engine version of the instance. This parameter is available only for instances that are created in dedicated clusters.
	EngineVersion *string `json:"EngineVersion,omitempty" xml:"EngineVersion,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the instance. You can call the [DescribeRegions](~~610399~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The switching time. This parameter is available only for instances that are created in dedicated clusters. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// > This parameter must be specified when **EffectiveTime** is set to **Specified**.
	SpecifiedTime *string `json:"SpecifiedTime,omitempty" xml:"SpecifiedTime,omitempty"`
	// The storage capacity of the instance. This parameter is available only for instances that are created in dedicated clusters. Valid values: **5 to 2000**. Unit: GB. If you do not specify this parameter, the storage capacity of the instance remains unchanged.
	Storage *int32 `json:"Storage,omitempty" xml:"Storage,omitempty"`
	// The instance type of the required instance. This parameter is available only for instances that are created in dedicated clusters.
	TargetDBInstanceClass *string `json:"TargetDBInstanceClass,omitempty" xml:"TargetDBInstanceClass,omitempty"`
	// A deprecated parameter. You do not need to specify this parameter.
	TargetDedicatedHostIdForLog *string `json:"TargetDedicatedHostIdForLog,omitempty" xml:"TargetDedicatedHostIdForLog,omitempty"`
	// The ID of the host on which the primary instance is created. This parameter is available only for instances that are created in dedicated clusters.
	//
	// > This parameter must be specified when **DBInstanceTransType** is set to **2**.
	TargetDedicatedHostIdForMaster *string `json:"TargetDedicatedHostIdForMaster,omitempty" xml:"TargetDedicatedHostIdForMaster,omitempty"`
	// The ID of the host on which the secondary instance is created. This parameter is available only for instances that are created in dedicated clusters.
	//
	// > This parameter must be specified when **DBInstanceTransType** is set to **2**.
	TargetDedicatedHostIdForSlave *string `json:"TargetDedicatedHostIdForSlave,omitempty" xml:"TargetDedicatedHostIdForSlave,omitempty"`
	// The vSwitch ID. This parameter is available only for instances that are created in dedicated clusters.
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
	// The zone ID. This parameter is available only for instances that are created in dedicated clusters.
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
}

func (s StartDBInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s StartDBInstanceRequest) GoString() string {
	return s.String()
}

func (s *StartDBInstanceRequest) SetDBInstanceId(v string) *StartDBInstanceRequest {
	s.DBInstanceId = &v
	return s
}

func (s *StartDBInstanceRequest) SetDBInstanceTransType(v int32) *StartDBInstanceRequest {
	s.DBInstanceTransType = &v
	return s
}

func (s *StartDBInstanceRequest) SetDedicatedHostGroupId(v string) *StartDBInstanceRequest {
	s.DedicatedHostGroupId = &v
	return s
}

func (s *StartDBInstanceRequest) SetEffectiveTime(v string) *StartDBInstanceRequest {
	s.EffectiveTime = &v
	return s
}

func (s *StartDBInstanceRequest) SetEngineVersion(v string) *StartDBInstanceRequest {
	s.EngineVersion = &v
	return s
}

func (s *StartDBInstanceRequest) SetOwnerId(v int64) *StartDBInstanceRequest {
	s.OwnerId = &v
	return s
}

func (s *StartDBInstanceRequest) SetRegionId(v string) *StartDBInstanceRequest {
	s.RegionId = &v
	return s
}

func (s *StartDBInstanceRequest) SetResourceOwnerAccount(v string) *StartDBInstanceRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *StartDBInstanceRequest) SetResourceOwnerId(v int64) *StartDBInstanceRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *StartDBInstanceRequest) SetSpecifiedTime(v string) *StartDBInstanceRequest {
	s.SpecifiedTime = &v
	return s
}

func (s *StartDBInstanceRequest) SetStorage(v int32) *StartDBInstanceRequest {
	s.Storage = &v
	return s
}

func (s *StartDBInstanceRequest) SetTargetDBInstanceClass(v string) *StartDBInstanceRequest {
	s.TargetDBInstanceClass = &v
	return s
}

func (s *StartDBInstanceRequest) SetTargetDedicatedHostIdForLog(v string) *StartDBInstanceRequest {
	s.TargetDedicatedHostIdForLog = &v
	return s
}

func (s *StartDBInstanceRequest) SetTargetDedicatedHostIdForMaster(v string) *StartDBInstanceRequest {
	s.TargetDedicatedHostIdForMaster = &v
	return s
}

func (s *StartDBInstanceRequest) SetTargetDedicatedHostIdForSlave(v string) *StartDBInstanceRequest {
	s.TargetDedicatedHostIdForSlave = &v
	return s
}

func (s *StartDBInstanceRequest) SetVSwitchId(v string) *StartDBInstanceRequest {
	s.VSwitchId = &v
	return s
}

func (s *StartDBInstanceRequest) SetZoneId(v string) *StartDBInstanceRequest {
	s.ZoneId = &v
	return s
}

type StartDBInstanceResponseBody struct {
	// The migration task ID. This parameter is available only for instances that are created in dedicated clusters.
	MigrationId *int32 `json:"MigrationId,omitempty" xml:"MigrationId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the task.
	TaskId *int32 `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
}

func (s StartDBInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s StartDBInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *StartDBInstanceResponseBody) SetMigrationId(v int32) *StartDBInstanceResponseBody {
	s.MigrationId = &v
	return s
}

func (s *StartDBInstanceResponseBody) SetRequestId(v string) *StartDBInstanceResponseBody {
	s.RequestId = &v
	return s
}

func (s *StartDBInstanceResponseBody) SetTaskId(v int32) *StartDBInstanceResponseBody {
	s.TaskId = &v
	return s
}

type StartDBInstanceResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *StartDBInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s StartDBInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s StartDBInstanceResponse) GoString() string {
	return s.String()
}

func (s *StartDBInstanceResponse) SetHeaders(v map[string]*string) *StartDBInstanceResponse {
	s.Headers = v
	return s
}

func (s *StartDBInstanceResponse) SetStatusCode(v int32) *StartDBInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *StartDBInstanceResponse) SetBody(v *StartDBInstanceResponseBody) *StartDBInstanceResponse {
	s.Body = v
	return s
}

type StopDBInstanceRequest struct {
	// The instance ID. You can call the DescribeDBInstances operation to query the instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID. You can call the DescribeRegions operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s StopDBInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s StopDBInstanceRequest) GoString() string {
	return s.String()
}

func (s *StopDBInstanceRequest) SetDBInstanceId(v string) *StopDBInstanceRequest {
	s.DBInstanceId = &v
	return s
}

func (s *StopDBInstanceRequest) SetOwnerId(v int64) *StopDBInstanceRequest {
	s.OwnerId = &v
	return s
}

func (s *StopDBInstanceRequest) SetRegionId(v string) *StopDBInstanceRequest {
	s.RegionId = &v
	return s
}

func (s *StopDBInstanceRequest) SetResourceOwnerAccount(v string) *StopDBInstanceRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *StopDBInstanceRequest) SetResourceOwnerId(v int64) *StopDBInstanceRequest {
	s.ResourceOwnerId = &v
	return s
}

type StopDBInstanceResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s StopDBInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s StopDBInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *StopDBInstanceResponseBody) SetRequestId(v string) *StopDBInstanceResponseBody {
	s.RequestId = &v
	return s
}

type StopDBInstanceResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *StopDBInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s StopDBInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s StopDBInstanceResponse) GoString() string {
	return s.String()
}

func (s *StopDBInstanceResponse) SetHeaders(v map[string]*string) *StopDBInstanceResponse {
	s.Headers = v
	return s
}

func (s *StopDBInstanceResponse) SetStatusCode(v int32) *StopDBInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *StopDBInstanceResponse) SetBody(v *StopDBInstanceResponseBody) *StopDBInstanceResponse {
	s.Body = v
	return s
}

type SwitchDBInstanceHARequest struct {
	// The instance ID. You can call the [DescribeDBInstances](~~610396~~) operation to query the ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The time when the switching takes effect. Valid values:
	//
	// *   **Immediate**: The switching immediately takes effect.
	// *   **MaintainTime**: The switching takes effect during the maintenance time.
	//
	// Default value: **Immediate**.
	EffectiveTime *string `json:"EffectiveTime,omitempty" xml:"EffectiveTime,omitempty"`
	// Specifies whether to enable forcible switching. Valid values:
	//
	// *   **Yes**
	// *   **No**
	//
	// Default value: **No**.
	Force *string `json:"Force,omitempty" xml:"Force,omitempty"`
	// The globally unique identifier (GUID) of the secondary instance. You can call the [DescribeDBInstanceHAConfig](~~610434~~) operation to query the GUID of the secondary instance.
	NodeId               *string `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s SwitchDBInstanceHARequest) String() string {
	return tea.Prettify(s)
}

func (s SwitchDBInstanceHARequest) GoString() string {
	return s.String()
}

func (s *SwitchDBInstanceHARequest) SetDBInstanceId(v string) *SwitchDBInstanceHARequest {
	s.DBInstanceId = &v
	return s
}

func (s *SwitchDBInstanceHARequest) SetEffectiveTime(v string) *SwitchDBInstanceHARequest {
	s.EffectiveTime = &v
	return s
}

func (s *SwitchDBInstanceHARequest) SetForce(v string) *SwitchDBInstanceHARequest {
	s.Force = &v
	return s
}

func (s *SwitchDBInstanceHARequest) SetNodeId(v string) *SwitchDBInstanceHARequest {
	s.NodeId = &v
	return s
}

func (s *SwitchDBInstanceHARequest) SetOwnerAccount(v string) *SwitchDBInstanceHARequest {
	s.OwnerAccount = &v
	return s
}

func (s *SwitchDBInstanceHARequest) SetOwnerId(v int64) *SwitchDBInstanceHARequest {
	s.OwnerId = &v
	return s
}

func (s *SwitchDBInstanceHARequest) SetResourceOwnerAccount(v string) *SwitchDBInstanceHARequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *SwitchDBInstanceHARequest) SetResourceOwnerId(v int64) *SwitchDBInstanceHARequest {
	s.ResourceOwnerId = &v
	return s
}

type SwitchDBInstanceHAResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SwitchDBInstanceHAResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SwitchDBInstanceHAResponseBody) GoString() string {
	return s.String()
}

func (s *SwitchDBInstanceHAResponseBody) SetRequestId(v string) *SwitchDBInstanceHAResponseBody {
	s.RequestId = &v
	return s
}

type SwitchDBInstanceHAResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SwitchDBInstanceHAResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SwitchDBInstanceHAResponse) String() string {
	return tea.Prettify(s)
}

func (s SwitchDBInstanceHAResponse) GoString() string {
	return s.String()
}

func (s *SwitchDBInstanceHAResponse) SetHeaders(v map[string]*string) *SwitchDBInstanceHAResponse {
	s.Headers = v
	return s
}

func (s *SwitchDBInstanceHAResponse) SetStatusCode(v int32) *SwitchDBInstanceHAResponse {
	s.StatusCode = &v
	return s
}

func (s *SwitchDBInstanceHAResponse) SetBody(v *SwitchDBInstanceHAResponseBody) *SwitchDBInstanceHAResponse {
	s.Body = v
	return s
}

type SwitchDBInstanceNetTypeRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The prefix of the custom endpoint. The prefix must be 8 to 64 characters in length and can contain letters and digits. It must start with a lowercase letter. A valid endpoint is in the following format: Prefix.Database engine.rds.aliyuncs.com. Example: test1234.mysql.rds.aliyuncs.com.
	ConnectionStringPrefix *string `json:"ConnectionStringPrefix,omitempty" xml:"ConnectionStringPrefix,omitempty"`
	// The type of the endpoint. Valid values:
	//
	// *   **Normal**
	// *   **ReadWriteSplitting**
	//
	// By default, the system returns both types of endpoints.
	ConnectionStringType *string `json:"ConnectionStringType,omitempty" xml:"ConnectionStringType,omitempty"`
	// The instance ID. You can call the DescribeDBInstances operation to query the instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of the port that is used to connect to the instance. Valid values: **3001 to 3999**.
	Port                 *string `json:"Port,omitempty" xml:"Port,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s SwitchDBInstanceNetTypeRequest) String() string {
	return tea.Prettify(s)
}

func (s SwitchDBInstanceNetTypeRequest) GoString() string {
	return s.String()
}

func (s *SwitchDBInstanceNetTypeRequest) SetClientToken(v string) *SwitchDBInstanceNetTypeRequest {
	s.ClientToken = &v
	return s
}

func (s *SwitchDBInstanceNetTypeRequest) SetConnectionStringPrefix(v string) *SwitchDBInstanceNetTypeRequest {
	s.ConnectionStringPrefix = &v
	return s
}

func (s *SwitchDBInstanceNetTypeRequest) SetConnectionStringType(v string) *SwitchDBInstanceNetTypeRequest {
	s.ConnectionStringType = &v
	return s
}

func (s *SwitchDBInstanceNetTypeRequest) SetDBInstanceId(v string) *SwitchDBInstanceNetTypeRequest {
	s.DBInstanceId = &v
	return s
}

func (s *SwitchDBInstanceNetTypeRequest) SetOwnerAccount(v string) *SwitchDBInstanceNetTypeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *SwitchDBInstanceNetTypeRequest) SetOwnerId(v int64) *SwitchDBInstanceNetTypeRequest {
	s.OwnerId = &v
	return s
}

func (s *SwitchDBInstanceNetTypeRequest) SetPort(v string) *SwitchDBInstanceNetTypeRequest {
	s.Port = &v
	return s
}

func (s *SwitchDBInstanceNetTypeRequest) SetResourceOwnerAccount(v string) *SwitchDBInstanceNetTypeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *SwitchDBInstanceNetTypeRequest) SetResourceOwnerId(v int64) *SwitchDBInstanceNetTypeRequest {
	s.ResourceOwnerId = &v
	return s
}

type SwitchDBInstanceNetTypeResponseBody struct {
	// The endpoint that is used to connect to the instance after the switch of endpoints.
	NewConnectionString *string `json:"NewConnectionString,omitempty" xml:"NewConnectionString,omitempty"`
	// The endpoint that is used to connect to the instance before the switch of endpoints.
	OldConnectionString *string `json:"OldConnectionString,omitempty" xml:"OldConnectionString,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SwitchDBInstanceNetTypeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SwitchDBInstanceNetTypeResponseBody) GoString() string {
	return s.String()
}

func (s *SwitchDBInstanceNetTypeResponseBody) SetNewConnectionString(v string) *SwitchDBInstanceNetTypeResponseBody {
	s.NewConnectionString = &v
	return s
}

func (s *SwitchDBInstanceNetTypeResponseBody) SetOldConnectionString(v string) *SwitchDBInstanceNetTypeResponseBody {
	s.OldConnectionString = &v
	return s
}

func (s *SwitchDBInstanceNetTypeResponseBody) SetRequestId(v string) *SwitchDBInstanceNetTypeResponseBody {
	s.RequestId = &v
	return s
}

type SwitchDBInstanceNetTypeResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SwitchDBInstanceNetTypeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SwitchDBInstanceNetTypeResponse) String() string {
	return tea.Prettify(s)
}

func (s SwitchDBInstanceNetTypeResponse) GoString() string {
	return s.String()
}

func (s *SwitchDBInstanceNetTypeResponse) SetHeaders(v map[string]*string) *SwitchDBInstanceNetTypeResponse {
	s.Headers = v
	return s
}

func (s *SwitchDBInstanceNetTypeResponse) SetStatusCode(v int32) *SwitchDBInstanceNetTypeResponse {
	s.StatusCode = &v
	return s
}

func (s *SwitchDBInstanceNetTypeResponse) SetBody(v *SwitchDBInstanceNetTypeResponseBody) *SwitchDBInstanceNetTypeResponse {
	s.Body = v
	return s
}

type SwitchDBInstanceVpcRequest struct {
	// The instance ID. You can call the DescribeDBInstances operation to query the instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The private IP address of the instance. The private IP address must be within the CIDR block of the vSwitch that is specified by the **VSwitchId** parameter.
	//
	// >  You can call the DescribeVSwitches operation to query the CIDR block of the vSwitch.
	PrivateIpAddress *string `json:"PrivateIpAddress,omitempty" xml:"PrivateIpAddress,omitempty"`
	ResourceOwnerId  *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The VPC ID.
	//
	// > The VPC must reside in the same region as the instance.
	VPCId *string `json:"VPCId,omitempty" xml:"VPCId,omitempty"`
	// The vSwitch ID of the instance.
	//
	// > The vSwitch must belong to the same zone as the instance.
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
}

func (s SwitchDBInstanceVpcRequest) String() string {
	return tea.Prettify(s)
}

func (s SwitchDBInstanceVpcRequest) GoString() string {
	return s.String()
}

func (s *SwitchDBInstanceVpcRequest) SetDBInstanceId(v string) *SwitchDBInstanceVpcRequest {
	s.DBInstanceId = &v
	return s
}

func (s *SwitchDBInstanceVpcRequest) SetPrivateIpAddress(v string) *SwitchDBInstanceVpcRequest {
	s.PrivateIpAddress = &v
	return s
}

func (s *SwitchDBInstanceVpcRequest) SetResourceOwnerId(v int64) *SwitchDBInstanceVpcRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *SwitchDBInstanceVpcRequest) SetVPCId(v string) *SwitchDBInstanceVpcRequest {
	s.VPCId = &v
	return s
}

func (s *SwitchDBInstanceVpcRequest) SetVSwitchId(v string) *SwitchDBInstanceVpcRequest {
	s.VSwitchId = &v
	return s
}

type SwitchDBInstanceVpcResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SwitchDBInstanceVpcResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SwitchDBInstanceVpcResponseBody) GoString() string {
	return s.String()
}

func (s *SwitchDBInstanceVpcResponseBody) SetRequestId(v string) *SwitchDBInstanceVpcResponseBody {
	s.RequestId = &v
	return s
}

type SwitchDBInstanceVpcResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SwitchDBInstanceVpcResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SwitchDBInstanceVpcResponse) String() string {
	return tea.Prettify(s)
}

func (s SwitchDBInstanceVpcResponse) GoString() string {
	return s.String()
}

func (s *SwitchDBInstanceVpcResponse) SetHeaders(v map[string]*string) *SwitchDBInstanceVpcResponse {
	s.Headers = v
	return s
}

func (s *SwitchDBInstanceVpcResponse) SetStatusCode(v int32) *SwitchDBInstanceVpcResponse {
	s.StatusCode = &v
	return s
}

func (s *SwitchDBInstanceVpcResponse) SetBody(v *SwitchDBInstanceVpcResponseBody) *SwitchDBInstanceVpcResponse {
	s.Body = v
	return s
}

type SwitchGuardToMasterInstanceRequest struct {
	// The ID of the disaster recovery instance. You can call the [DescribeDBInstances](~~26232~~) operation to query the instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the resource group. You can call the [DescribeDBInstanceAttribute](~~610394~~) to obtain the ID of the resource group.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s SwitchGuardToMasterInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s SwitchGuardToMasterInstanceRequest) GoString() string {
	return s.String()
}

func (s *SwitchGuardToMasterInstanceRequest) SetDBInstanceId(v string) *SwitchGuardToMasterInstanceRequest {
	s.DBInstanceId = &v
	return s
}

func (s *SwitchGuardToMasterInstanceRequest) SetOwnerAccount(v string) *SwitchGuardToMasterInstanceRequest {
	s.OwnerAccount = &v
	return s
}

func (s *SwitchGuardToMasterInstanceRequest) SetOwnerId(v int64) *SwitchGuardToMasterInstanceRequest {
	s.OwnerId = &v
	return s
}

func (s *SwitchGuardToMasterInstanceRequest) SetResourceGroupId(v string) *SwitchGuardToMasterInstanceRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *SwitchGuardToMasterInstanceRequest) SetResourceOwnerAccount(v string) *SwitchGuardToMasterInstanceRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *SwitchGuardToMasterInstanceRequest) SetResourceOwnerId(v int64) *SwitchGuardToMasterInstanceRequest {
	s.ResourceOwnerId = &v
	return s
}

type SwitchGuardToMasterInstanceResponseBody struct {
	// The instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SwitchGuardToMasterInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SwitchGuardToMasterInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *SwitchGuardToMasterInstanceResponseBody) SetDBInstanceId(v string) *SwitchGuardToMasterInstanceResponseBody {
	s.DBInstanceId = &v
	return s
}

func (s *SwitchGuardToMasterInstanceResponseBody) SetRequestId(v string) *SwitchGuardToMasterInstanceResponseBody {
	s.RequestId = &v
	return s
}

type SwitchGuardToMasterInstanceResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SwitchGuardToMasterInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SwitchGuardToMasterInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s SwitchGuardToMasterInstanceResponse) GoString() string {
	return s.String()
}

func (s *SwitchGuardToMasterInstanceResponse) SetHeaders(v map[string]*string) *SwitchGuardToMasterInstanceResponse {
	s.Headers = v
	return s
}

func (s *SwitchGuardToMasterInstanceResponse) SetStatusCode(v int32) *SwitchGuardToMasterInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *SwitchGuardToMasterInstanceResponse) SetBody(v *SwitchGuardToMasterInstanceResponseBody) *SwitchGuardToMasterInstanceResponse {
	s.Body = v
	return s
}

type TagResourcesRequest struct {
	OwnerId *int64 `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region. You can call the [DescribeRegions](~~26243~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The instance ID.
	ResourceId           []*string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty" type:"Repeated"`
	ResourceOwnerAccount *string   `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64    `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The type of the resource. Set the value to **INSTANCE**.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The list of tags.
	Tag []*TagResourcesRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s TagResourcesRequest) String() string {
	return tea.Prettify(s)
}

func (s TagResourcesRequest) GoString() string {
	return s.String()
}

func (s *TagResourcesRequest) SetOwnerId(v int64) *TagResourcesRequest {
	s.OwnerId = &v
	return s
}

func (s *TagResourcesRequest) SetRegionId(v string) *TagResourcesRequest {
	s.RegionId = &v
	return s
}

func (s *TagResourcesRequest) SetResourceId(v []*string) *TagResourcesRequest {
	s.ResourceId = v
	return s
}

func (s *TagResourcesRequest) SetResourceOwnerAccount(v string) *TagResourcesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *TagResourcesRequest) SetResourceOwnerId(v int64) *TagResourcesRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *TagResourcesRequest) SetResourceType(v string) *TagResourcesRequest {
	s.ResourceType = &v
	return s
}

func (s *TagResourcesRequest) SetTag(v []*TagResourcesRequestTag) *TagResourcesRequest {
	s.Tag = v
	return s
}

type TagResourcesRequestTag struct {
	// The key of the tag. You can create N tag keys at a time. Valid values of N: **1** to **20**. The value of this parameter cannot be an empty string.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The value of the tag. You can create N tag values at a time. Valid values of N: **1** to **20**. The value of this parameter can be an empty string.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s TagResourcesRequestTag) String() string {
	return tea.Prettify(s)
}

func (s TagResourcesRequestTag) GoString() string {
	return s.String()
}

func (s *TagResourcesRequestTag) SetKey(v string) *TagResourcesRequestTag {
	s.Key = &v
	return s
}

func (s *TagResourcesRequestTag) SetValue(v string) *TagResourcesRequestTag {
	s.Value = &v
	return s
}

type TagResourcesResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s TagResourcesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s TagResourcesResponseBody) GoString() string {
	return s.String()
}

func (s *TagResourcesResponseBody) SetRequestId(v string) *TagResourcesResponseBody {
	s.RequestId = &v
	return s
}

type TagResourcesResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *TagResourcesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s TagResourcesResponse) String() string {
	return tea.Prettify(s)
}

func (s TagResourcesResponse) GoString() string {
	return s.String()
}

func (s *TagResourcesResponse) SetHeaders(v map[string]*string) *TagResourcesResponse {
	s.Headers = v
	return s
}

func (s *TagResourcesResponse) SetStatusCode(v int32) *TagResourcesResponse {
	s.StatusCode = &v
	return s
}

func (s *TagResourcesResponse) SetBody(v *TagResourcesResponseBody) *TagResourcesResponse {
	s.Body = v
	return s
}

type TerminateMigrateTaskRequest struct {
	// The instance ID. You can call the [DescribeDBInstances](~~26232~~) operation to query the instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The ID of the migration task. You can call the [DescribeMigrateTasks](~~64563~~) operation to query the ID of the migration task.
	MigrateTaskId        *string `json:"MigrateTaskId,omitempty" xml:"MigrateTaskId,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s TerminateMigrateTaskRequest) String() string {
	return tea.Prettify(s)
}

func (s TerminateMigrateTaskRequest) GoString() string {
	return s.String()
}

func (s *TerminateMigrateTaskRequest) SetDBInstanceId(v string) *TerminateMigrateTaskRequest {
	s.DBInstanceId = &v
	return s
}

func (s *TerminateMigrateTaskRequest) SetMigrateTaskId(v string) *TerminateMigrateTaskRequest {
	s.MigrateTaskId = &v
	return s
}

func (s *TerminateMigrateTaskRequest) SetOwnerId(v int64) *TerminateMigrateTaskRequest {
	s.OwnerId = &v
	return s
}

func (s *TerminateMigrateTaskRequest) SetResourceOwnerAccount(v string) *TerminateMigrateTaskRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *TerminateMigrateTaskRequest) SetResourceOwnerId(v int64) *TerminateMigrateTaskRequest {
	s.ResourceOwnerId = &v
	return s
}

type TerminateMigrateTaskResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s TerminateMigrateTaskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s TerminateMigrateTaskResponseBody) GoString() string {
	return s.String()
}

func (s *TerminateMigrateTaskResponseBody) SetRequestId(v string) *TerminateMigrateTaskResponseBody {
	s.RequestId = &v
	return s
}

type TerminateMigrateTaskResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *TerminateMigrateTaskResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s TerminateMigrateTaskResponse) String() string {
	return tea.Prettify(s)
}

func (s TerminateMigrateTaskResponse) GoString() string {
	return s.String()
}

func (s *TerminateMigrateTaskResponse) SetHeaders(v map[string]*string) *TerminateMigrateTaskResponse {
	s.Headers = v
	return s
}

func (s *TerminateMigrateTaskResponse) SetStatusCode(v int32) *TerminateMigrateTaskResponse {
	s.StatusCode = &v
	return s
}

func (s *TerminateMigrateTaskResponse) SetBody(v *TerminateMigrateTaskResponseBody) *TerminateMigrateTaskResponse {
	s.Body = v
	return s
}

type TransformDBInstancePayTypeRequest struct {
	// Specifies whether to enable the auto-renewal feature for the instance. Valid values:
	//
	// *   **true**
	// *   **false**
	//
	// > - This parameter is valid only when you change the billing method from pay-as-you-go to subscription.
	// > - All strings except **true** are considered **false**.
	AutoRenew *string `json:"AutoRenew,omitempty" xml:"AutoRenew,omitempty"`
	// The additional business information about the instance.
	BusinessInfo *string `json:"BusinessInfo,omitempty" xml:"BusinessInfo,omitempty"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The instance ID. You can call the [DescribeDBInstances](~~610396~~) operation to query the ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The new billing method of the instance. Valid values:
	//
	// *   **Postpaid**: pay-as-you-go
	// *   **Prepaid**: subscription
	PayType *string `json:"PayType,omitempty" xml:"PayType,omitempty"`
	// The renewal cycle of the instance. Valid values:
	//
	// *   **Year**
	// *   **Month**
	//
	// > This parameter must be specified if you set **PayType** to **Prepaid**.
	Period               *string `json:"Period,omitempty" xml:"Period,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The subscription duration of the instance. Valid values:
	//
	// *   If you set **Period** to **Year**, the value of UsedTime ranges from **1 to 5**.
	// *   If you set **Period** to **Month**, the value of UsedTime ranges from **1 to 11**.
	//
	// > This parameter must be specified when **PayType** is set to **Prepaid**.
	UsedTime *int32 `json:"UsedTime,omitempty" xml:"UsedTime,omitempty"`
}

func (s TransformDBInstancePayTypeRequest) String() string {
	return tea.Prettify(s)
}

func (s TransformDBInstancePayTypeRequest) GoString() string {
	return s.String()
}

func (s *TransformDBInstancePayTypeRequest) SetAutoRenew(v string) *TransformDBInstancePayTypeRequest {
	s.AutoRenew = &v
	return s
}

func (s *TransformDBInstancePayTypeRequest) SetBusinessInfo(v string) *TransformDBInstancePayTypeRequest {
	s.BusinessInfo = &v
	return s
}

func (s *TransformDBInstancePayTypeRequest) SetClientToken(v string) *TransformDBInstancePayTypeRequest {
	s.ClientToken = &v
	return s
}

func (s *TransformDBInstancePayTypeRequest) SetDBInstanceId(v string) *TransformDBInstancePayTypeRequest {
	s.DBInstanceId = &v
	return s
}

func (s *TransformDBInstancePayTypeRequest) SetOwnerAccount(v string) *TransformDBInstancePayTypeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *TransformDBInstancePayTypeRequest) SetOwnerId(v int64) *TransformDBInstancePayTypeRequest {
	s.OwnerId = &v
	return s
}

func (s *TransformDBInstancePayTypeRequest) SetPayType(v string) *TransformDBInstancePayTypeRequest {
	s.PayType = &v
	return s
}

func (s *TransformDBInstancePayTypeRequest) SetPeriod(v string) *TransformDBInstancePayTypeRequest {
	s.Period = &v
	return s
}

func (s *TransformDBInstancePayTypeRequest) SetResourceOwnerAccount(v string) *TransformDBInstancePayTypeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *TransformDBInstancePayTypeRequest) SetResourceOwnerId(v int64) *TransformDBInstancePayTypeRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *TransformDBInstancePayTypeRequest) SetUsedTime(v int32) *TransformDBInstancePayTypeRequest {
	s.UsedTime = &v
	return s
}

type TransformDBInstancePayTypeResponseBody struct {
	// The payment type.
	//
	// *   Valid value if the new billing method is pay-as-you-go: POSTPAY
	// *   Valid value if the new billing method is subscription: PREPAY
	ChargeType *string `json:"ChargeType,omitempty" xml:"ChargeType,omitempty"`
	// The instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The expiration time.
	//
	// > If you call this operation to change the billing method of an instance from subscription to pay-as-you-go, this parameter is not returned.
	ExpiredTime *string `json:"ExpiredTime,omitempty" xml:"ExpiredTime,omitempty"`
	// The order ID.
	OrderId *int64 `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s TransformDBInstancePayTypeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s TransformDBInstancePayTypeResponseBody) GoString() string {
	return s.String()
}

func (s *TransformDBInstancePayTypeResponseBody) SetChargeType(v string) *TransformDBInstancePayTypeResponseBody {
	s.ChargeType = &v
	return s
}

func (s *TransformDBInstancePayTypeResponseBody) SetDBInstanceId(v string) *TransformDBInstancePayTypeResponseBody {
	s.DBInstanceId = &v
	return s
}

func (s *TransformDBInstancePayTypeResponseBody) SetExpiredTime(v string) *TransformDBInstancePayTypeResponseBody {
	s.ExpiredTime = &v
	return s
}

func (s *TransformDBInstancePayTypeResponseBody) SetOrderId(v int64) *TransformDBInstancePayTypeResponseBody {
	s.OrderId = &v
	return s
}

func (s *TransformDBInstancePayTypeResponseBody) SetRequestId(v string) *TransformDBInstancePayTypeResponseBody {
	s.RequestId = &v
	return s
}

type TransformDBInstancePayTypeResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *TransformDBInstancePayTypeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s TransformDBInstancePayTypeResponse) String() string {
	return tea.Prettify(s)
}

func (s TransformDBInstancePayTypeResponse) GoString() string {
	return s.String()
}

func (s *TransformDBInstancePayTypeResponse) SetHeaders(v map[string]*string) *TransformDBInstancePayTypeResponse {
	s.Headers = v
	return s
}

func (s *TransformDBInstancePayTypeResponse) SetStatusCode(v int32) *TransformDBInstancePayTypeResponse {
	s.StatusCode = &v
	return s
}

func (s *TransformDBInstancePayTypeResponse) SetBody(v *TransformDBInstancePayTypeResponseBody) *TransformDBInstancePayTypeResponse {
	s.Body = v
	return s
}

type UnlockAccountRequest struct {
	// The account that you want to unlock. You can unlock a single account at a time.
	AccountName *string `json:"AccountName,omitempty" xml:"AccountName,omitempty"`
	// The instance ID. You can call the DescribeDBInstances operation to query the instance ID.
	DBInstanceId         *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s UnlockAccountRequest) String() string {
	return tea.Prettify(s)
}

func (s UnlockAccountRequest) GoString() string {
	return s.String()
}

func (s *UnlockAccountRequest) SetAccountName(v string) *UnlockAccountRequest {
	s.AccountName = &v
	return s
}

func (s *UnlockAccountRequest) SetDBInstanceId(v string) *UnlockAccountRequest {
	s.DBInstanceId = &v
	return s
}

func (s *UnlockAccountRequest) SetOwnerId(v int64) *UnlockAccountRequest {
	s.OwnerId = &v
	return s
}

func (s *UnlockAccountRequest) SetResourceOwnerAccount(v string) *UnlockAccountRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *UnlockAccountRequest) SetResourceOwnerId(v int64) *UnlockAccountRequest {
	s.ResourceOwnerId = &v
	return s
}

type UnlockAccountResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UnlockAccountResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UnlockAccountResponseBody) GoString() string {
	return s.String()
}

func (s *UnlockAccountResponseBody) SetRequestId(v string) *UnlockAccountResponseBody {
	s.RequestId = &v
	return s
}

type UnlockAccountResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UnlockAccountResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UnlockAccountResponse) String() string {
	return tea.Prettify(s)
}

func (s UnlockAccountResponse) GoString() string {
	return s.String()
}

func (s *UnlockAccountResponse) SetHeaders(v map[string]*string) *UnlockAccountResponse {
	s.Headers = v
	return s
}

func (s *UnlockAccountResponse) SetStatusCode(v int32) *UnlockAccountResponse {
	s.StatusCode = &v
	return s
}

func (s *UnlockAccountResponse) SetBody(v *UnlockAccountResponseBody) *UnlockAccountResponse {
	s.Body = v
	return s
}

type UntagResourcesRequest struct {
	// Specifies whether to delete all tags of the instance. Valid values:
	//
	// *   **true**
	// *   **false**
	//
	// Default value: **false**.
	//
	// > This parameter is valid if parameters that contain **TagKey.N** are not specified.
	All     *bool  `json:"All,omitempty" xml:"All,omitempty"`
	OwnerId *int64 `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region. You can call the [DescribeRegions](~~26243~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The instance ID. You can remove tags from N instances at a time. Valid values of N: **1** to **50**.
	ResourceId           []*string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty" type:"Repeated"`
	ResourceOwnerAccount *string   `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64    `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The type of the resource. Set the value to **INSTANCE**.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The list of tag keys. You can delete N tag keys at a time. Valid values of N: **1** to **20**. The value of this parameter cannot be an empty string.
	TagKey []*string `json:"TagKey,omitempty" xml:"TagKey,omitempty" type:"Repeated"`
}

func (s UntagResourcesRequest) String() string {
	return tea.Prettify(s)
}

func (s UntagResourcesRequest) GoString() string {
	return s.String()
}

func (s *UntagResourcesRequest) SetAll(v bool) *UntagResourcesRequest {
	s.All = &v
	return s
}

func (s *UntagResourcesRequest) SetOwnerId(v int64) *UntagResourcesRequest {
	s.OwnerId = &v
	return s
}

func (s *UntagResourcesRequest) SetRegionId(v string) *UntagResourcesRequest {
	s.RegionId = &v
	return s
}

func (s *UntagResourcesRequest) SetResourceId(v []*string) *UntagResourcesRequest {
	s.ResourceId = v
	return s
}

func (s *UntagResourcesRequest) SetResourceOwnerAccount(v string) *UntagResourcesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *UntagResourcesRequest) SetResourceOwnerId(v int64) *UntagResourcesRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *UntagResourcesRequest) SetResourceType(v string) *UntagResourcesRequest {
	s.ResourceType = &v
	return s
}

func (s *UntagResourcesRequest) SetTagKey(v []*string) *UntagResourcesRequest {
	s.TagKey = v
	return s
}

type UntagResourcesResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UntagResourcesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UntagResourcesResponseBody) GoString() string {
	return s.String()
}

func (s *UntagResourcesResponseBody) SetRequestId(v string) *UntagResourcesResponseBody {
	s.RequestId = &v
	return s
}

type UntagResourcesResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UntagResourcesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UntagResourcesResponse) String() string {
	return tea.Prettify(s)
}

func (s UntagResourcesResponse) GoString() string {
	return s.String()
}

func (s *UntagResourcesResponse) SetHeaders(v map[string]*string) *UntagResourcesResponse {
	s.Headers = v
	return s
}

func (s *UntagResourcesResponse) SetStatusCode(v int32) *UntagResourcesResponse {
	s.StatusCode = &v
	return s
}

func (s *UntagResourcesResponse) SetBody(v *UntagResourcesResponseBody) *UntagResourcesResponse {
	s.Body = v
	return s
}

type UpdatePostgresExtensionsRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The instance ID. You can call the DescribeDBInstances operation to query the instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The database name. You can call the DescribeDatabases operation to obtain the database name.
	DBNames *string `json:"DBNames,omitempty" xml:"DBNames,omitempty"`
	// The name of the extension. Separate multiple extensions with commas (,).
	Extensions   *string `json:"Extensions,omitempty" xml:"Extensions,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s UpdatePostgresExtensionsRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdatePostgresExtensionsRequest) GoString() string {
	return s.String()
}

func (s *UpdatePostgresExtensionsRequest) SetClientToken(v string) *UpdatePostgresExtensionsRequest {
	s.ClientToken = &v
	return s
}

func (s *UpdatePostgresExtensionsRequest) SetDBInstanceId(v string) *UpdatePostgresExtensionsRequest {
	s.DBInstanceId = &v
	return s
}

func (s *UpdatePostgresExtensionsRequest) SetDBNames(v string) *UpdatePostgresExtensionsRequest {
	s.DBNames = &v
	return s
}

func (s *UpdatePostgresExtensionsRequest) SetExtensions(v string) *UpdatePostgresExtensionsRequest {
	s.Extensions = &v
	return s
}

func (s *UpdatePostgresExtensionsRequest) SetOwnerAccount(v string) *UpdatePostgresExtensionsRequest {
	s.OwnerAccount = &v
	return s
}

func (s *UpdatePostgresExtensionsRequest) SetOwnerId(v int64) *UpdatePostgresExtensionsRequest {
	s.OwnerId = &v
	return s
}

func (s *UpdatePostgresExtensionsRequest) SetResourceGroupId(v string) *UpdatePostgresExtensionsRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *UpdatePostgresExtensionsRequest) SetResourceOwnerAccount(v string) *UpdatePostgresExtensionsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *UpdatePostgresExtensionsRequest) SetResourceOwnerId(v int64) *UpdatePostgresExtensionsRequest {
	s.ResourceOwnerId = &v
	return s
}

type UpdatePostgresExtensionsResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdatePostgresExtensionsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdatePostgresExtensionsResponseBody) GoString() string {
	return s.String()
}

func (s *UpdatePostgresExtensionsResponseBody) SetRequestId(v string) *UpdatePostgresExtensionsResponseBody {
	s.RequestId = &v
	return s
}

type UpdatePostgresExtensionsResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdatePostgresExtensionsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdatePostgresExtensionsResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdatePostgresExtensionsResponse) GoString() string {
	return s.String()
}

func (s *UpdatePostgresExtensionsResponse) SetHeaders(v map[string]*string) *UpdatePostgresExtensionsResponse {
	s.Headers = v
	return s
}

func (s *UpdatePostgresExtensionsResponse) SetStatusCode(v int32) *UpdatePostgresExtensionsResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdatePostgresExtensionsResponse) SetBody(v *UpdatePostgresExtensionsResponseBody) *UpdatePostgresExtensionsResponse {
	s.Body = v
	return s
}

type UpdateUserBackupFileRequest struct {
	// The ID of the backup file. You can call the [ListUserBackupFiles](~~610600~~) operation to query the ID of the file.
	BackupId *string `json:"BackupId,omitempty" xml:"BackupId,omitempty"`
	// The new description of the full backup file.
	Comment *string `json:"Comment,omitempty" xml:"Comment,omitempty"`
	OwnerId *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region. You can call the [DescribeRegions](~~26243~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The resource group ID. You can call the [DescribeDBInstanceAttribute](~~610394~~) operation to obtain the resource group ID.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The new retention period of the full backup file. Unit: days. Valid values: any non-zero positive integer.
	Retention *int32 `json:"Retention,omitempty" xml:"Retention,omitempty"`
}

func (s UpdateUserBackupFileRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateUserBackupFileRequest) GoString() string {
	return s.String()
}

func (s *UpdateUserBackupFileRequest) SetBackupId(v string) *UpdateUserBackupFileRequest {
	s.BackupId = &v
	return s
}

func (s *UpdateUserBackupFileRequest) SetComment(v string) *UpdateUserBackupFileRequest {
	s.Comment = &v
	return s
}

func (s *UpdateUserBackupFileRequest) SetOwnerId(v int64) *UpdateUserBackupFileRequest {
	s.OwnerId = &v
	return s
}

func (s *UpdateUserBackupFileRequest) SetRegionId(v string) *UpdateUserBackupFileRequest {
	s.RegionId = &v
	return s
}

func (s *UpdateUserBackupFileRequest) SetResourceGroupId(v string) *UpdateUserBackupFileRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *UpdateUserBackupFileRequest) SetResourceOwnerAccount(v string) *UpdateUserBackupFileRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *UpdateUserBackupFileRequest) SetResourceOwnerId(v int64) *UpdateUserBackupFileRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *UpdateUserBackupFileRequest) SetRetention(v int32) *UpdateUserBackupFileRequest {
	s.Retention = &v
	return s
}

type UpdateUserBackupFileResponseBody struct {
	// The ID of the backup file.
	BackupId *string `json:"BackupId,omitempty" xml:"BackupId,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateUserBackupFileResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateUserBackupFileResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateUserBackupFileResponseBody) SetBackupId(v string) *UpdateUserBackupFileResponseBody {
	s.BackupId = &v
	return s
}

func (s *UpdateUserBackupFileResponseBody) SetRequestId(v string) *UpdateUserBackupFileResponseBody {
	s.RequestId = &v
	return s
}

type UpdateUserBackupFileResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateUserBackupFileResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateUserBackupFileResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateUserBackupFileResponse) GoString() string {
	return s.String()
}

func (s *UpdateUserBackupFileResponse) SetHeaders(v map[string]*string) *UpdateUserBackupFileResponse {
	s.Headers = v
	return s
}

func (s *UpdateUserBackupFileResponse) SetStatusCode(v int32) *UpdateUserBackupFileResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateUserBackupFileResponse) SetBody(v *UpdateUserBackupFileResponseBody) *UpdateUserBackupFileResponse {
	s.Body = v
	return s
}

type UpgradeDBInstanceEngineVersionRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The instance ID. You can call the [DescribeDBInstances](~~610396~~) operation to query the ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The effective time. Valid values:
	//
	// *   **Immediate**: This is the default value.
	// *   **MaintainTime**: The effective time is within the maintenance window. For more information, see [ModifyDBInstanceMaintainTime](~~610402~~).
	EffectiveTime *string `json:"EffectiveTime,omitempty" xml:"EffectiveTime,omitempty"`
	// The major engine version that the new instance runs. Valid values:
	//
	// *   **8.0**
	// *   **5.7**
	// *   **5.6**
	EngineVersion        *string `json:"EngineVersion,omitempty" xml:"EngineVersion,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s UpgradeDBInstanceEngineVersionRequest) String() string {
	return tea.Prettify(s)
}

func (s UpgradeDBInstanceEngineVersionRequest) GoString() string {
	return s.String()
}

func (s *UpgradeDBInstanceEngineVersionRequest) SetClientToken(v string) *UpgradeDBInstanceEngineVersionRequest {
	s.ClientToken = &v
	return s
}

func (s *UpgradeDBInstanceEngineVersionRequest) SetDBInstanceId(v string) *UpgradeDBInstanceEngineVersionRequest {
	s.DBInstanceId = &v
	return s
}

func (s *UpgradeDBInstanceEngineVersionRequest) SetEffectiveTime(v string) *UpgradeDBInstanceEngineVersionRequest {
	s.EffectiveTime = &v
	return s
}

func (s *UpgradeDBInstanceEngineVersionRequest) SetEngineVersion(v string) *UpgradeDBInstanceEngineVersionRequest {
	s.EngineVersion = &v
	return s
}

func (s *UpgradeDBInstanceEngineVersionRequest) SetOwnerAccount(v string) *UpgradeDBInstanceEngineVersionRequest {
	s.OwnerAccount = &v
	return s
}

func (s *UpgradeDBInstanceEngineVersionRequest) SetOwnerId(v int64) *UpgradeDBInstanceEngineVersionRequest {
	s.OwnerId = &v
	return s
}

func (s *UpgradeDBInstanceEngineVersionRequest) SetResourceOwnerAccount(v string) *UpgradeDBInstanceEngineVersionRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *UpgradeDBInstanceEngineVersionRequest) SetResourceOwnerId(v int64) *UpgradeDBInstanceEngineVersionRequest {
	s.ResourceOwnerId = &v
	return s
}

type UpgradeDBInstanceEngineVersionResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the task.
	TaskId *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
}

func (s UpgradeDBInstanceEngineVersionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpgradeDBInstanceEngineVersionResponseBody) GoString() string {
	return s.String()
}

func (s *UpgradeDBInstanceEngineVersionResponseBody) SetRequestId(v string) *UpgradeDBInstanceEngineVersionResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpgradeDBInstanceEngineVersionResponseBody) SetTaskId(v string) *UpgradeDBInstanceEngineVersionResponseBody {
	s.TaskId = &v
	return s
}

type UpgradeDBInstanceEngineVersionResponse struct {
	Headers    map[string]*string                          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpgradeDBInstanceEngineVersionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpgradeDBInstanceEngineVersionResponse) String() string {
	return tea.Prettify(s)
}

func (s UpgradeDBInstanceEngineVersionResponse) GoString() string {
	return s.String()
}

func (s *UpgradeDBInstanceEngineVersionResponse) SetHeaders(v map[string]*string) *UpgradeDBInstanceEngineVersionResponse {
	s.Headers = v
	return s
}

func (s *UpgradeDBInstanceEngineVersionResponse) SetStatusCode(v int32) *UpgradeDBInstanceEngineVersionResponse {
	s.StatusCode = &v
	return s
}

func (s *UpgradeDBInstanceEngineVersionResponse) SetBody(v *UpgradeDBInstanceEngineVersionResponseBody) *UpgradeDBInstanceEngineVersionResponse {
	s.Body = v
	return s
}

type UpgradeDBInstanceKernelVersionRequest struct {
	// The ID of the instance. You can call the [DescribeDBInstances](~~610396~~) operation to query the ID of the instance.
	//
	// > *   If your instance runs PostgreSQL, you must make sure that the instance uses **cloud disks**. If the instance is equipped with local disks, you must call the [RestartDBInstance](~~26230~~) operation to restart the instance. The system automatically updates the instance to the latest minor engine version during the restart.
	// > *   If your instance runs SQL Server, you must make sure that the instance runs SQL Server 2019.
	DBInstanceId         *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The update time. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
	//
	// > This parameter takes effect only when you set **UpgradeTime** to **SpecifyTime**.
	SwitchTime *string `json:"SwitchTime,omitempty" xml:"SwitchTime,omitempty"`
	// The minor engine version to which you want to update the instance. Format:
	//
	// *   **PostgreSQL**: `rds_postgres_<Major engine version>00_<Minor engine version>`. Example: `rds_postgres_1200_20200830`.
	//
	// *   **MySQL**: `<RDS edition and MySQL version>_<Minor engine version>`. Examples: `rds_20200229`, `xcluster_20200229`, and `xcluster80_20200229`. The following RDS editions and MySQL versions are supported:
	//
	//     *   **rds**: The instance runs RDS Basic Edition or RDS High-availability Edition.
	//     *   **xcluster**: The instance runs MySQL 5.7 on RDS Enterprise Edition.
	//     *   **xcluster80**: The instance runs MySQL 8.0 on RDS Enterprise Edition.
	//
	// *   **SQLServer**: `<Minor engine version>`. Example: `15.0.4073.23`.
	//
	// If you do not specify this parameter, the instance is updated to the latest minor engine version.
	//
	// > For more information about minor engine versions, see [Release notes of minor AliPG versions](~~126002~~), [Release notes of minor AliSQL versions](~~96060~~), and [Release notes of minor engine versions of ApsaraDB RDS for SQL Server](~~213577~~).
	TargetMinorVersion *string `json:"TargetMinorVersion,omitempty" xml:"TargetMinorVersion,omitempty"`
	// The time when the update takes effect. Valid values:
	//
	// *   **Immediate** (default): The update takes effect immediately.
	// *   **MaintainTime**: The update takes effect during the maintenance window that you specify. For more information about how to change the maintenance window, see [ModifyDBInstanceMaintainTime](~~26249~~).
	// *   **SpecifyTime**: The update takes effect at the point in time you specify.
	UpgradeTime *string `json:"UpgradeTime,omitempty" xml:"UpgradeTime,omitempty"`
}

func (s UpgradeDBInstanceKernelVersionRequest) String() string {
	return tea.Prettify(s)
}

func (s UpgradeDBInstanceKernelVersionRequest) GoString() string {
	return s.String()
}

func (s *UpgradeDBInstanceKernelVersionRequest) SetDBInstanceId(v string) *UpgradeDBInstanceKernelVersionRequest {
	s.DBInstanceId = &v
	return s
}

func (s *UpgradeDBInstanceKernelVersionRequest) SetOwnerId(v int64) *UpgradeDBInstanceKernelVersionRequest {
	s.OwnerId = &v
	return s
}

func (s *UpgradeDBInstanceKernelVersionRequest) SetResourceOwnerAccount(v string) *UpgradeDBInstanceKernelVersionRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *UpgradeDBInstanceKernelVersionRequest) SetResourceOwnerId(v int64) *UpgradeDBInstanceKernelVersionRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *UpgradeDBInstanceKernelVersionRequest) SetSwitchTime(v string) *UpgradeDBInstanceKernelVersionRequest {
	s.SwitchTime = &v
	return s
}

func (s *UpgradeDBInstanceKernelVersionRequest) SetTargetMinorVersion(v string) *UpgradeDBInstanceKernelVersionRequest {
	s.TargetMinorVersion = &v
	return s
}

func (s *UpgradeDBInstanceKernelVersionRequest) SetUpgradeTime(v string) *UpgradeDBInstanceKernelVersionRequest {
	s.UpgradeTime = &v
	return s
}

type UpgradeDBInstanceKernelVersionResponseBody struct {
	// The ID of the instance.
	DBInstanceName *string `json:"DBInstanceName,omitempty" xml:"DBInstanceName,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The new minor engine version of the instance.
	TargetMinorVersion *string `json:"TargetMinorVersion,omitempty" xml:"TargetMinorVersion,omitempty"`
	// The ID of the task.
	TaskId *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
}

func (s UpgradeDBInstanceKernelVersionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpgradeDBInstanceKernelVersionResponseBody) GoString() string {
	return s.String()
}

func (s *UpgradeDBInstanceKernelVersionResponseBody) SetDBInstanceName(v string) *UpgradeDBInstanceKernelVersionResponseBody {
	s.DBInstanceName = &v
	return s
}

func (s *UpgradeDBInstanceKernelVersionResponseBody) SetRequestId(v string) *UpgradeDBInstanceKernelVersionResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpgradeDBInstanceKernelVersionResponseBody) SetTargetMinorVersion(v string) *UpgradeDBInstanceKernelVersionResponseBody {
	s.TargetMinorVersion = &v
	return s
}

func (s *UpgradeDBInstanceKernelVersionResponseBody) SetTaskId(v string) *UpgradeDBInstanceKernelVersionResponseBody {
	s.TaskId = &v
	return s
}

type UpgradeDBInstanceKernelVersionResponse struct {
	Headers    map[string]*string                          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpgradeDBInstanceKernelVersionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpgradeDBInstanceKernelVersionResponse) String() string {
	return tea.Prettify(s)
}

func (s UpgradeDBInstanceKernelVersionResponse) GoString() string {
	return s.String()
}

func (s *UpgradeDBInstanceKernelVersionResponse) SetHeaders(v map[string]*string) *UpgradeDBInstanceKernelVersionResponse {
	s.Headers = v
	return s
}

func (s *UpgradeDBInstanceKernelVersionResponse) SetStatusCode(v int32) *UpgradeDBInstanceKernelVersionResponse {
	s.StatusCode = &v
	return s
}

func (s *UpgradeDBInstanceKernelVersionResponse) SetBody(v *UpgradeDBInstanceKernelVersionResponseBody) *UpgradeDBInstanceKernelVersionResponse {
	s.Body = v
	return s
}

type UpgradeDBInstanceMajorVersionRequest struct {
	// The time at which the system collects the statistics of the new instance. Valid values:
	//
	// *   Before: ApsaraDB RDS collects the statistics of the new instance before the switchover to ensure service stability. If the original instance contains a large amount of data, the upgrade may require a long period of time.
	// *   After: ApsaraDB RDS collects the statistics of the new instance after the switchover to accelerate the upgrade. If you access tables for which no statistics are generated, the execution plans that you specify may be inaccurate. In addition, your database service may be unavailable during peak hours.
	//
	// > If you set SwitchOver to false, the value Before of this parameter specifies that ApsaraDB RDS collects the statistics of the new instance before the new instance starts to process read and write requests, and the value After of this parameter specifies that ApsaraDB RDS collects the statistics of the new instance after the new instance starts to process read and write requests.
	CollectStatMode *string `json:"CollectStatMode,omitempty" xml:"CollectStatMode,omitempty"`
	// The instance type of the new instance. The CPU and memory specifications of the new instance must be higher than or equal to the CPU and memory specifications of the original instance.
	//
	// For example, if the instance type of the original instance is `pg.n2.small.2c`, which provides 1 core and 2 GB of memory, the instance type of the new instance can be `pg.n2.medium.2c`, which provides 2 cores and 4 GB of memory.
	//
	// > For more information about instance types in ApsaraDB RDS for PostgreSQL, see [Primary ApsaraDB RDS for PostgreSQL instance types](~~276990~~).
	DBInstanceClass *string `json:"DBInstanceClass,omitempty" xml:"DBInstanceClass,omitempty"`
	// The ID of the original instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The storage capacity of the new instance.
	//
	// Unit: GB
	//
	// Valid values:
	//
	// *   Valid values if you use enhanced SSDs (ESSDs) of performance level 1 (PL1): 20 to 3200
	// *   Valid values if you use ESSDs of PL2: 500 to 3200
	// *   Valid values if you use ESSDs of PL3: 1500 to 3200
	//
	// > If the original instance uses local disks, you can reduce the storage capacity of the instance when you upgrade the major engine version of the instance. For more information about the minimum available storage capacity, see [Upgrade the major engine version of an ApsaraDB RDS for PostgreSQL instance](~~203309~~).
	DBInstanceStorage *int32 `json:"DBInstanceStorage,omitempty" xml:"DBInstanceStorage,omitempty"`
	// The storage type of the new instance.
	//
	// Valid values:
	//
	// *   cloud_ssd: standard SSDs
	// *   cloud_essd: ESSD of PL1
	// *   cloud_essd2: ESSD of PL2
	// *   cloud_essd3: ESSD of PL3
	//
	// The major engine version upgrade feature is based on cloud disk snapshots. You can select a storage type based on the following conditions:
	//
	// *   If the original instance uses standard SSDs, you can set this parameter to cloud_ssd.
	// *   If the original instance uses ESSDs, you can set this parameter to cloud_essd, cloud_essd2, or cloud_essd3.
	// *   If the original instance uses local disks, you can set this parameter to cloud_essd, cloud_essd2, or cloud_essd3.
	DBInstanceStorageType *string `json:"DBInstanceStorageType,omitempty" xml:"DBInstanceStorageType,omitempty"`
	// The network type of the new instance. Set the value to VPC. The major engine version upgrade feature is supported only for instances that reside in VPCs.
	//
	// If the original instance resides in the classic network, you must migrate the instance to a VPC before you call this operation. For more information about how to view or change the network type of an instance, see [Change the network type of an ApsaraDB RDS for PostgreSQL instance](~~96761~~).
	InstanceNetworkType *string `json:"InstanceNetworkType,omitempty" xml:"InstanceNetworkType,omitempty"`
	// The billing method of the new instance. Set the value to Postpaid.
	//
	// > For more information about how to change the billing method of an instance after the upgrade, see [Change the billing method of an instance from pay-as-you-go to subscription](~~96743~~).
	PayType *string `json:"PayType,omitempty" xml:"PayType,omitempty"`
	// A reserved parameter. You do not need to specify this parameter.
	Period *string `json:"Period,omitempty" xml:"Period,omitempty"`
	// The internal IP address of the new instance. You do not need to specify this parameter. The system automatically assigns an internal IP address based on the values of the VPCId and vSwitchId parameters.
	PrivateIpAddress *string `json:"PrivateIpAddress,omitempty" xml:"PrivateIpAddress,omitempty"`
	ResourceOwnerId  *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// Specifies whether the system automatically switches your workloads over to the new instance after data is migrated to the new instance.
	//
	// Valid values:
	//
	// *   true
	// *   false Before you perform an upgrade, we recommend that you set this parameter to false to test whether the new major engine version is compatible with your workloads.
	//
	// >
	//
	// *   If you set this parameter to true, you must take note of the following information:
	//
	//     *   After the switchover is complete, you cannot roll your workloads back to the original instance. Proceed with caution.
	//     *   During the switchover, the original instance processes only read requests. We recommend that you perform the switchover during off-peak hours.
	//     *   If read-only instances are attached to the original instance, you can set this parameter only to false. In this case, the read-only instances that are attached to the original instance cannot be cloned. After the upgrade is complete, you must create read-only instances for the new instance.
	//
	// *   If you set this parameter to false, you must take note of the following information:
	//
	//     *   The data migration does not interrupt your workloads on the original instance.
	//     *   After data is migrated to the new instance, you must update the endpoint configuration on your application. This update requires you to replace the endpoint of the original instance with the endpoint of the new instance. For more information about how to view the endpoint of an instance, see [View and change the internal and public endpoints and port numbers of an ApsaraDB RDS for PostgreSQL instance](~~96788~~).
	SwitchOver *string `json:"SwitchOver,omitempty" xml:"SwitchOver,omitempty"`
	// A reserved parameter. You do not need to specify this parameter.
	SwitchTime *string `json:"SwitchTime,omitempty" xml:"SwitchTime,omitempty"`
	// The cutover time. This parameter is used together with SwitchOver. This parameter is available only when **SwitchOver** is set to **true**.
	//
	// Valid values:
	//
	// *   Immediate: The settings immediately take effect.
	// *   MaintainTime: The settings take effect during the maintenance window of the instance. You can call the [ModifyDBInstanceMaintainTime](~~610402~~) operation to change the maintenance window of an instance.
	SwitchTimeMode *string `json:"SwitchTimeMode,omitempty" xml:"SwitchTimeMode,omitempty"`
	// The major engine version of the new instance. The value of this parameter must be the major engine version on which an upgrade check is performed.
	//
	// > You can call the [UpgradeDBInstanceMajorVersionPrecheck](~~610417~~) operation to perform an upgrade check.
	TargetMajorVersion *string `json:"TargetMajorVersion,omitempty" xml:"TargetMajorVersion,omitempty"`
	// A reserved parameter. You do not need to specify this parameter.
	UsedTime *string `json:"UsedTime,omitempty" xml:"UsedTime,omitempty"`
	// The VPC ID. You can call the [DescribeDBInstanceAttribute](~~610394~~) operation to query the VPC ID of the original instance.
	VPCId *string `json:"VPCId,omitempty" xml:"VPCId,omitempty"`
	// *   If the original instance runs RDS Basic Edition, you must enter the vSwitch ID of the new instance.
	// *   If the original instance runs RDS High-availability Edition, you must enter the vSwitch ID of the new instance and the vSwitch ID of the secondary instance of the new instance. Make sure that you separate the vSwitch IDs with commas (,).
	//
	// >  The vSwitches that you specify must reside in the same zone as the original instance. You can call the [DescribeVSwitches](~~35748~~) operation to query the ID of the vSwitch.
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
	// The zone ID of the new instance. You can call the [DescribeRegions](~~610399~~) operation to query the zone ID.
	//
	// You can select a zone that belongs to the region in which the original instance resides. The zone can be different from the zone of the original instance.
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
	// The zone ID of the secondary instance for the new instance. You can specify this parameter only when the original instance runs RDS High-availability Edition.
	//
	// You can select a zone that belongs to the region in which the original instance resides. The zone can be different from the zone of the original instance.
	//
	// You can call the [DescribeRegions](~~610399~~) operation to query the zone ID.
	ZoneIdSlave1 *string `json:"ZoneIdSlave1,omitempty" xml:"ZoneIdSlave1,omitempty"`
	// A reserved parameter. You do not need to specify this parameter.
	ZoneIdSlave2 *string `json:"ZoneIdSlave2,omitempty" xml:"ZoneIdSlave2,omitempty"`
}

func (s UpgradeDBInstanceMajorVersionRequest) String() string {
	return tea.Prettify(s)
}

func (s UpgradeDBInstanceMajorVersionRequest) GoString() string {
	return s.String()
}

func (s *UpgradeDBInstanceMajorVersionRequest) SetCollectStatMode(v string) *UpgradeDBInstanceMajorVersionRequest {
	s.CollectStatMode = &v
	return s
}

func (s *UpgradeDBInstanceMajorVersionRequest) SetDBInstanceClass(v string) *UpgradeDBInstanceMajorVersionRequest {
	s.DBInstanceClass = &v
	return s
}

func (s *UpgradeDBInstanceMajorVersionRequest) SetDBInstanceId(v string) *UpgradeDBInstanceMajorVersionRequest {
	s.DBInstanceId = &v
	return s
}

func (s *UpgradeDBInstanceMajorVersionRequest) SetDBInstanceStorage(v int32) *UpgradeDBInstanceMajorVersionRequest {
	s.DBInstanceStorage = &v
	return s
}

func (s *UpgradeDBInstanceMajorVersionRequest) SetDBInstanceStorageType(v string) *UpgradeDBInstanceMajorVersionRequest {
	s.DBInstanceStorageType = &v
	return s
}

func (s *UpgradeDBInstanceMajorVersionRequest) SetInstanceNetworkType(v string) *UpgradeDBInstanceMajorVersionRequest {
	s.InstanceNetworkType = &v
	return s
}

func (s *UpgradeDBInstanceMajorVersionRequest) SetPayType(v string) *UpgradeDBInstanceMajorVersionRequest {
	s.PayType = &v
	return s
}

func (s *UpgradeDBInstanceMajorVersionRequest) SetPeriod(v string) *UpgradeDBInstanceMajorVersionRequest {
	s.Period = &v
	return s
}

func (s *UpgradeDBInstanceMajorVersionRequest) SetPrivateIpAddress(v string) *UpgradeDBInstanceMajorVersionRequest {
	s.PrivateIpAddress = &v
	return s
}

func (s *UpgradeDBInstanceMajorVersionRequest) SetResourceOwnerId(v int64) *UpgradeDBInstanceMajorVersionRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *UpgradeDBInstanceMajorVersionRequest) SetSwitchOver(v string) *UpgradeDBInstanceMajorVersionRequest {
	s.SwitchOver = &v
	return s
}

func (s *UpgradeDBInstanceMajorVersionRequest) SetSwitchTime(v string) *UpgradeDBInstanceMajorVersionRequest {
	s.SwitchTime = &v
	return s
}

func (s *UpgradeDBInstanceMajorVersionRequest) SetSwitchTimeMode(v string) *UpgradeDBInstanceMajorVersionRequest {
	s.SwitchTimeMode = &v
	return s
}

func (s *UpgradeDBInstanceMajorVersionRequest) SetTargetMajorVersion(v string) *UpgradeDBInstanceMajorVersionRequest {
	s.TargetMajorVersion = &v
	return s
}

func (s *UpgradeDBInstanceMajorVersionRequest) SetUsedTime(v string) *UpgradeDBInstanceMajorVersionRequest {
	s.UsedTime = &v
	return s
}

func (s *UpgradeDBInstanceMajorVersionRequest) SetVPCId(v string) *UpgradeDBInstanceMajorVersionRequest {
	s.VPCId = &v
	return s
}

func (s *UpgradeDBInstanceMajorVersionRequest) SetVSwitchId(v string) *UpgradeDBInstanceMajorVersionRequest {
	s.VSwitchId = &v
	return s
}

func (s *UpgradeDBInstanceMajorVersionRequest) SetZoneId(v string) *UpgradeDBInstanceMajorVersionRequest {
	s.ZoneId = &v
	return s
}

func (s *UpgradeDBInstanceMajorVersionRequest) SetZoneIdSlave1(v string) *UpgradeDBInstanceMajorVersionRequest {
	s.ZoneIdSlave1 = &v
	return s
}

func (s *UpgradeDBInstanceMajorVersionRequest) SetZoneIdSlave2(v string) *UpgradeDBInstanceMajorVersionRequest {
	s.ZoneIdSlave2 = &v
	return s
}

type UpgradeDBInstanceMajorVersionResponseBody struct {
	// The ID of the instance.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// The ID of the order.
	OrderId *string `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// A reserved parameter.
	TaskId *int64 `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
}

func (s UpgradeDBInstanceMajorVersionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpgradeDBInstanceMajorVersionResponseBody) GoString() string {
	return s.String()
}

func (s *UpgradeDBInstanceMajorVersionResponseBody) SetDBInstanceId(v string) *UpgradeDBInstanceMajorVersionResponseBody {
	s.DBInstanceId = &v
	return s
}

func (s *UpgradeDBInstanceMajorVersionResponseBody) SetOrderId(v string) *UpgradeDBInstanceMajorVersionResponseBody {
	s.OrderId = &v
	return s
}

func (s *UpgradeDBInstanceMajorVersionResponseBody) SetRequestId(v string) *UpgradeDBInstanceMajorVersionResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpgradeDBInstanceMajorVersionResponseBody) SetTaskId(v int64) *UpgradeDBInstanceMajorVersionResponseBody {
	s.TaskId = &v
	return s
}

type UpgradeDBInstanceMajorVersionResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpgradeDBInstanceMajorVersionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpgradeDBInstanceMajorVersionResponse) String() string {
	return tea.Prettify(s)
}

func (s UpgradeDBInstanceMajorVersionResponse) GoString() string {
	return s.String()
}

func (s *UpgradeDBInstanceMajorVersionResponse) SetHeaders(v map[string]*string) *UpgradeDBInstanceMajorVersionResponse {
	s.Headers = v
	return s
}

func (s *UpgradeDBInstanceMajorVersionResponse) SetStatusCode(v int32) *UpgradeDBInstanceMajorVersionResponse {
	s.StatusCode = &v
	return s
}

func (s *UpgradeDBInstanceMajorVersionResponse) SetBody(v *UpgradeDBInstanceMajorVersionResponseBody) *UpgradeDBInstanceMajorVersionResponse {
	s.Body = v
	return s
}

type UpgradeDBInstanceMajorVersionPrecheckRequest struct {
	// The ID of the instance. You can call the [DescribeDBInstances](~~610396~~) operation to query the ID of the instance.
	DBInstanceId    *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	ResourceOwnerId *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The new major engine version of the instance. The new major engine version must be later than the original major engine version.
	TargetMajorVersion *string `json:"TargetMajorVersion,omitempty" xml:"TargetMajorVersion,omitempty"`
}

func (s UpgradeDBInstanceMajorVersionPrecheckRequest) String() string {
	return tea.Prettify(s)
}

func (s UpgradeDBInstanceMajorVersionPrecheckRequest) GoString() string {
	return s.String()
}

func (s *UpgradeDBInstanceMajorVersionPrecheckRequest) SetDBInstanceId(v string) *UpgradeDBInstanceMajorVersionPrecheckRequest {
	s.DBInstanceId = &v
	return s
}

func (s *UpgradeDBInstanceMajorVersionPrecheckRequest) SetResourceOwnerId(v int64) *UpgradeDBInstanceMajorVersionPrecheckRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *UpgradeDBInstanceMajorVersionPrecheckRequest) SetTargetMajorVersion(v string) *UpgradeDBInstanceMajorVersionPrecheckRequest {
	s.TargetMajorVersion = &v
	return s
}

type UpgradeDBInstanceMajorVersionPrecheckResponseBody struct {
	// The instance name.
	DBInstanceName *string `json:"DBInstanceName,omitempty" xml:"DBInstanceName,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The new major engine version of the instance.
	TargetMajorVersion *string `json:"TargetMajorVersion,omitempty" xml:"TargetMajorVersion,omitempty"`
	// The task ID.
	TaskId *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
}

func (s UpgradeDBInstanceMajorVersionPrecheckResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpgradeDBInstanceMajorVersionPrecheckResponseBody) GoString() string {
	return s.String()
}

func (s *UpgradeDBInstanceMajorVersionPrecheckResponseBody) SetDBInstanceName(v string) *UpgradeDBInstanceMajorVersionPrecheckResponseBody {
	s.DBInstanceName = &v
	return s
}

func (s *UpgradeDBInstanceMajorVersionPrecheckResponseBody) SetRequestId(v string) *UpgradeDBInstanceMajorVersionPrecheckResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpgradeDBInstanceMajorVersionPrecheckResponseBody) SetTargetMajorVersion(v string) *UpgradeDBInstanceMajorVersionPrecheckResponseBody {
	s.TargetMajorVersion = &v
	return s
}

func (s *UpgradeDBInstanceMajorVersionPrecheckResponseBody) SetTaskId(v string) *UpgradeDBInstanceMajorVersionPrecheckResponseBody {
	s.TaskId = &v
	return s
}

type UpgradeDBInstanceMajorVersionPrecheckResponse struct {
	Headers    map[string]*string                                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpgradeDBInstanceMajorVersionPrecheckResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpgradeDBInstanceMajorVersionPrecheckResponse) String() string {
	return tea.Prettify(s)
}

func (s UpgradeDBInstanceMajorVersionPrecheckResponse) GoString() string {
	return s.String()
}

func (s *UpgradeDBInstanceMajorVersionPrecheckResponse) SetHeaders(v map[string]*string) *UpgradeDBInstanceMajorVersionPrecheckResponse {
	s.Headers = v
	return s
}

func (s *UpgradeDBInstanceMajorVersionPrecheckResponse) SetStatusCode(v int32) *UpgradeDBInstanceMajorVersionPrecheckResponse {
	s.StatusCode = &v
	return s
}

func (s *UpgradeDBInstanceMajorVersionPrecheckResponse) SetBody(v *UpgradeDBInstanceMajorVersionPrecheckResponseBody) *UpgradeDBInstanceMajorVersionPrecheckResponse {
	s.Body = v
	return s
}

type UpgradeDBProxyInstanceKernelVersionRequest struct {
	// The instance ID. You can call the DescribeDBInstances operation to query the instance ID.
	DBInstanceId *string `json:"DBInstanceId,omitempty" xml:"DBInstanceId,omitempty"`
	// A reserved parameter. You do not need to specify this parameter.
	DBProxyEngineType    *string `json:"DBProxyEngineType,omitempty" xml:"DBProxyEngineType,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The specific point in time when you want to perform the upgrade. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
	//
	// > If you set **UpgradeTime** to **SpecificTime**, you must specify SwitchTime.
	SwitchTime *string `json:"SwitchTime,omitempty" xml:"SwitchTime,omitempty"`
	// The time when you want to upgrade the database proxy version of the instance. Valid values:
	//
	// *   **MaintainTime** (default): performs the upgrade during the maintenance window that you specified. For more information, see [Modify the maintenance window](~~610402~~).
	// *   **Immediate**: performs the upgrade immediately.
	// *   **SpecificTime**: performs the upgrade at a specified point in time.
	//
	// >
	//
	// *   If the instance runs MySQL, you can set this parameter to **MaintainTime**, **Immediate**, or **SpecificTime**.
	//
	// *   If the instance runs PostgreSQL, you can set this parameter to **MaintainTime** or **Immediate**.
	UpgradeTime *string `json:"UpgradeTime,omitempty" xml:"UpgradeTime,omitempty"`
}

func (s UpgradeDBProxyInstanceKernelVersionRequest) String() string {
	return tea.Prettify(s)
}

func (s UpgradeDBProxyInstanceKernelVersionRequest) GoString() string {
	return s.String()
}

func (s *UpgradeDBProxyInstanceKernelVersionRequest) SetDBInstanceId(v string) *UpgradeDBProxyInstanceKernelVersionRequest {
	s.DBInstanceId = &v
	return s
}

func (s *UpgradeDBProxyInstanceKernelVersionRequest) SetDBProxyEngineType(v string) *UpgradeDBProxyInstanceKernelVersionRequest {
	s.DBProxyEngineType = &v
	return s
}

func (s *UpgradeDBProxyInstanceKernelVersionRequest) SetOwnerId(v int64) *UpgradeDBProxyInstanceKernelVersionRequest {
	s.OwnerId = &v
	return s
}

func (s *UpgradeDBProxyInstanceKernelVersionRequest) SetResourceOwnerAccount(v string) *UpgradeDBProxyInstanceKernelVersionRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *UpgradeDBProxyInstanceKernelVersionRequest) SetResourceOwnerId(v int64) *UpgradeDBProxyInstanceKernelVersionRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *UpgradeDBProxyInstanceKernelVersionRequest) SetSwitchTime(v string) *UpgradeDBProxyInstanceKernelVersionRequest {
	s.SwitchTime = &v
	return s
}

func (s *UpgradeDBProxyInstanceKernelVersionRequest) SetUpgradeTime(v string) *UpgradeDBProxyInstanceKernelVersionRequest {
	s.UpgradeTime = &v
	return s
}

type UpgradeDBProxyInstanceKernelVersionResponseBody struct {
	// The ID of the database proxy of the instance.
	DBInstanceName *string `json:"DBInstanceName,omitempty" xml:"DBInstanceName,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The task ID.
	TaskId *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
}

func (s UpgradeDBProxyInstanceKernelVersionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpgradeDBProxyInstanceKernelVersionResponseBody) GoString() string {
	return s.String()
}

func (s *UpgradeDBProxyInstanceKernelVersionResponseBody) SetDBInstanceName(v string) *UpgradeDBProxyInstanceKernelVersionResponseBody {
	s.DBInstanceName = &v
	return s
}

func (s *UpgradeDBProxyInstanceKernelVersionResponseBody) SetRequestId(v string) *UpgradeDBProxyInstanceKernelVersionResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpgradeDBProxyInstanceKernelVersionResponseBody) SetTaskId(v string) *UpgradeDBProxyInstanceKernelVersionResponseBody {
	s.TaskId = &v
	return s
}

type UpgradeDBProxyInstanceKernelVersionResponse struct {
	Headers    map[string]*string                               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpgradeDBProxyInstanceKernelVersionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpgradeDBProxyInstanceKernelVersionResponse) String() string {
	return tea.Prettify(s)
}

func (s UpgradeDBProxyInstanceKernelVersionResponse) GoString() string {
	return s.String()
}

func (s *UpgradeDBProxyInstanceKernelVersionResponse) SetHeaders(v map[string]*string) *UpgradeDBProxyInstanceKernelVersionResponse {
	s.Headers = v
	return s
}

func (s *UpgradeDBProxyInstanceKernelVersionResponse) SetStatusCode(v int32) *UpgradeDBProxyInstanceKernelVersionResponse {
	s.StatusCode = &v
	return s
}

func (s *UpgradeDBProxyInstanceKernelVersionResponse) SetBody(v *UpgradeDBProxyInstanceKernelVersionResponseBody) *UpgradeDBProxyInstanceKernelVersionResponse {
	s.Body = v
	return s
}

type Client struct {
	openapi.Client
}

func NewClient(config *openapi.Config) (*Client, error) {
	client := new(Client)
	err := client.Init(config)
	return client, err
}

func (client *Client) Init(config *openapi.Config) (_err error) {
	_err = client.Client.Init(config)
	if _err != nil {
		return _err
	}
	client.EndpointRule = tea.String("regional")
	client.EndpointMap = map[string]*string{
		"cn-qingdao":                  tea.String("rds.aliyuncs.com"),
		"cn-beijing":                  tea.String("rds.aliyuncs.com"),
		"cn-hangzhou":                 tea.String("rds.aliyuncs.com"),
		"cn-shanghai":                 tea.String("rds.aliyuncs.com"),
		"cn-shenzhen":                 tea.String("rds.aliyuncs.com"),
		"cn-heyuan":                   tea.String("rds.aliyuncs.com"),
		"cn-hongkong":                 tea.String("rds.aliyuncs.com"),
		"ap-southeast-1":              tea.String("rds.aliyuncs.com"),
		"us-west-1":                   tea.String("rds.aliyuncs.com"),
		"us-east-1":                   tea.String("rds.aliyuncs.com"),
		"cn-shanghai-finance-1":       tea.String("rds.aliyuncs.com"),
		"cn-shenzhen-finance-1":       tea.String("rds.aliyuncs.com"),
		"cn-north-2-gov-1":            tea.String("rds.aliyuncs.com"),
		"ap-northeast-2-pop":          tea.String("rds.aliyuncs.com"),
		"cn-beijing-finance-1":        tea.String("rds.aliyuncs.com"),
		"cn-beijing-finance-pop":      tea.String("rds.aliyuncs.com"),
		"cn-beijing-gov-1":            tea.String("rds.aliyuncs.com"),
		"cn-beijing-nu16-b01":         tea.String("rds.aliyuncs.com"),
		"cn-edge-1":                   tea.String("rds.aliyuncs.com"),
		"cn-fujian":                   tea.String("rds.aliyuncs.com"),
		"cn-haidian-cm12-c01":         tea.String("rds.aliyuncs.com"),
		"cn-hangzhou-bj-b01":          tea.String("rds.aliyuncs.com"),
		"cn-hangzhou-finance":         tea.String("rds-vpc.cn-hangzhou-finance.aliyuncs.com"),
		"cn-hangzhou-internal-prod-1": tea.String("rds.aliyuncs.com"),
		"cn-hangzhou-internal-test-1": tea.String("rds.aliyuncs.com"),
		"cn-hangzhou-internal-test-2": tea.String("rds.aliyuncs.com"),
		"cn-hangzhou-internal-test-3": tea.String("rds.aliyuncs.com"),
		"cn-hangzhou-test-306":        tea.String("rds.aliyuncs.com"),
		"cn-hongkong-finance-pop":     tea.String("rds.aliyuncs.com"),
		"cn-qingdao-nebula":           tea.String("rds.aliyuncs.com"),
		"cn-shanghai-et15-b01":        tea.String("rds.aliyuncs.com"),
		"cn-shanghai-et2-b01":         tea.String("rds.aliyuncs.com"),
		"cn-shanghai-inner":           tea.String("rds.aliyuncs.com"),
		"cn-shanghai-internal-test-1": tea.String("rds.aliyuncs.com"),
		"cn-shenzhen-inner":           tea.String("rds.aliyuncs.com"),
		"cn-shenzhen-st4-d01":         tea.String("rds.aliyuncs.com"),
		"cn-shenzhen-su18-b01":        tea.String("rds.aliyuncs.com"),
		"cn-wuhan":                    tea.String("rds.aliyuncs.com"),
		"cn-yushanfang":               tea.String("rds.aliyuncs.com"),
		"cn-zhangbei":                 tea.String("rds.aliyuncs.com"),
		"cn-zhangbei-na61-b01":        tea.String("rds.aliyuncs.com"),
		"cn-zhangjiakou-na62-a01":     tea.String("rds.aliyuncs.com"),
		"cn-zhengzhou-nebula-1":       tea.String("rds.aliyuncs.com"),
		"eu-west-1-oxs":               tea.String("rds.aliyuncs.com"),
		"rus-west-1-pop":              tea.String("rds.aliyuncs.com"),
	}
	_err = client.CheckConfig(config)
	if _err != nil {
		return _err
	}
	client.Endpoint, _err = client.GetEndpoint(tea.String("rds"), client.RegionId, client.EndpointRule, client.Network, client.Suffix, client.EndpointMap, client.Endpoint)
	if _err != nil {
		return _err
	}

	return nil
}

func (client *Client) GetEndpoint(productId *string, regionId *string, endpointRule *string, network *string, suffix *string, endpointMap map[string]*string, endpoint *string) (_result *string, _err error) {
	if !tea.BoolValue(util.Empty(endpoint)) {
		_result = endpoint
		return _result, _err
	}

	if !tea.BoolValue(util.IsUnset(endpointMap)) && !tea.BoolValue(util.Empty(endpointMap[tea.StringValue(regionId)])) {
		_result = endpointMap[tea.StringValue(regionId)]
		return _result, _err
	}

	_body, _err := endpointutil.GetEndpointRules(productId, regionId, endpointRule, network, suffix)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   PostgreSQL
 * ### [](#)References
 * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * [Use the cloud migration feature](~~365562~~)
 *
 * @param request ActivateMigrationTargetInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ActivateMigrationTargetInstanceResponse
 */
func (client *Client) ActivateMigrationTargetInstanceWithOptions(request *ActivateMigrationTargetInstanceRequest, runtime *util.RuntimeOptions) (_result *ActivateMigrationTargetInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceName)) {
		query["DBInstanceName"] = request.DBInstanceName
	}

	if !tea.BoolValue(util.IsUnset(request.ForceSwitch)) {
		query["ForceSwitch"] = request.ForceSwitch
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SwitchTime)) {
		query["SwitchTime"] = request.SwitchTime
	}

	if !tea.BoolValue(util.IsUnset(request.SwitchTimeMode)) {
		query["SwitchTimeMode"] = request.SwitchTimeMode
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ActivateMigrationTargetInstance"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ActivateMigrationTargetInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   PostgreSQL
 * ### [](#)References
 * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * [Use the cloud migration feature](~~365562~~)
 *
 * @param request ActivateMigrationTargetInstanceRequest
 * @return ActivateMigrationTargetInstanceResponse
 */
func (client *Client) ActivateMigrationTargetInstance(request *ActivateMigrationTargetInstanceRequest) (_result *ActivateMigrationTargetInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ActivateMigrationTargetInstanceResponse{}
	_body, _err := client.ActivateMigrationTargetInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 * ### [](#)Usage notes
 * *   Each tag consists of a tag key and a tag value. The tag key is required, and the tag value is optional.
 * *   The tag key and tag value cannot start with aliyun.
 * *   The tag key and tag value are not case-sensitive.
 * *   The maximum length of a tag key is 64 characters, and the maximum length of a tag value is 128 characters.
 * *   A maximum of 10 tags can be added to each instance. Each tag that is added to the same instance must have a unique tag key. If you add a new tag to the instance and the key of the new tag is the same as that of an existing tag, the new tag overwrites the existing tag.
 *
 * @param request AddTagsToResourceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddTagsToResourceResponse
 */
func (client *Client) AddTagsToResourceWithOptions(request *AddTagsToResourceRequest, runtime *util.RuntimeOptions) (_result *AddTagsToResourceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	if !tea.BoolValue(util.IsUnset(request.ProxyId)) {
		query["proxyId"] = request.ProxyId
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddTagsToResource"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddTagsToResourceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 * ### [](#)Usage notes
 * *   Each tag consists of a tag key and a tag value. The tag key is required, and the tag value is optional.
 * *   The tag key and tag value cannot start with aliyun.
 * *   The tag key and tag value are not case-sensitive.
 * *   The maximum length of a tag key is 64 characters, and the maximum length of a tag value is 128 characters.
 * *   A maximum of 10 tags can be added to each instance. Each tag that is added to the same instance must have a unique tag key. If you add a new tag to the instance and the key of the new tag is the same as that of an existing tag, the new tag overwrites the existing tag.
 *
 * @param request AddTagsToResourceRequest
 * @return AddTagsToResourceResponse
 */
func (client *Client) AddTagsToResource(request *AddTagsToResourceRequest) (_result *AddTagsToResourceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddTagsToResourceResponse{}
	_body, _err := client.AddTagsToResourceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 * ### References
 * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
 * *   [Apply for a public endpoint for an ApsaraDB RDS for MySQL instance](~~26128~~)
 * *   [Apply for a public endpoint for an ApsaraDB RDS for PostgreSQL instance](~~97738~~)
 * *   [Apply for a public endpoint for an ApsaraDB RDS for SQL Server instance](~~97736~~)
 * *   [Apply for a public endpoint for an ApsaraDB RDS for MariaDB instance](~~97740~~)
 *
 * @param request AllocateInstancePublicConnectionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AllocateInstancePublicConnectionResponse
 */
func (client *Client) AllocateInstancePublicConnectionWithOptions(request *AllocateInstancePublicConnectionRequest, runtime *util.RuntimeOptions) (_result *AllocateInstancePublicConnectionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BabelfishPort)) {
		query["BabelfishPort"] = request.BabelfishPort
	}

	if !tea.BoolValue(util.IsUnset(request.ConnectionStringPrefix)) {
		query["ConnectionStringPrefix"] = request.ConnectionStringPrefix
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.GeneralGroupName)) {
		query["GeneralGroupName"] = request.GeneralGroupName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PGBouncerPort)) {
		query["PGBouncerPort"] = request.PGBouncerPort
	}

	if !tea.BoolValue(util.IsUnset(request.Port)) {
		query["Port"] = request.Port
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AllocateInstancePublicConnection"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AllocateInstancePublicConnectionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 * ### References
 * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
 * *   [Apply for a public endpoint for an ApsaraDB RDS for MySQL instance](~~26128~~)
 * *   [Apply for a public endpoint for an ApsaraDB RDS for PostgreSQL instance](~~97738~~)
 * *   [Apply for a public endpoint for an ApsaraDB RDS for SQL Server instance](~~97736~~)
 * *   [Apply for a public endpoint for an ApsaraDB RDS for MariaDB instance](~~97740~~)
 *
 * @param request AllocateInstancePublicConnectionRequest
 * @return AllocateInstancePublicConnectionResponse
 */
func (client *Client) AllocateInstancePublicConnection(request *AllocateInstancePublicConnectionRequest) (_result *AllocateInstancePublicConnectionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AllocateInstancePublicConnectionResponse{}
	_body, _err := client.AllocateInstancePublicConnectionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * If read-only instances are attached to a primary ApsaraDB RDS for SQL Server instance, you can call this operation to apply for a unified read-only routing endpoint for the primary instance. After you apply for a read-only routing endpoint for a primary instance, the existing endpoints of the primary instance and its read-only instances remain valid. In addition, you can still apply for internal and public endpoints.
 * Before you call this operation, make sure that the following requirements are met:
 * *   If the instance runs MySQL, the instance uses a shared proxy.
 * *   The instance is in the Running state.
 * *   Read-only instances are attached to the primary instance.
 * *   The instance does not have an ongoing Data Transmission Service (DTS) migration task.
 * *   The instance runs one of the following database versions and RDS editions:
 *     *   SQL Server (cluster edition)
 *     *   MySQL 5.7 on RDS High-availability Edition with local SSDs
 *     *   MySQL 5.6
 *
 * @param request AllocateReadWriteSplittingConnectionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AllocateReadWriteSplittingConnectionResponse
 */
func (client *Client) AllocateReadWriteSplittingConnectionWithOptions(request *AllocateReadWriteSplittingConnectionRequest, runtime *util.RuntimeOptions) (_result *AllocateReadWriteSplittingConnectionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ConnectionStringPrefix)) {
		query["ConnectionStringPrefix"] = request.ConnectionStringPrefix
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.DistributionType)) {
		query["DistributionType"] = request.DistributionType
	}

	if !tea.BoolValue(util.IsUnset(request.MaxDelayTime)) {
		query["MaxDelayTime"] = request.MaxDelayTime
	}

	if !tea.BoolValue(util.IsUnset(request.NetType)) {
		query["NetType"] = request.NetType
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Port)) {
		query["Port"] = request.Port
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Weight)) {
		query["Weight"] = request.Weight
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AllocateReadWriteSplittingConnection"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AllocateReadWriteSplittingConnectionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * If read-only instances are attached to a primary ApsaraDB RDS for SQL Server instance, you can call this operation to apply for a unified read-only routing endpoint for the primary instance. After you apply for a read-only routing endpoint for a primary instance, the existing endpoints of the primary instance and its read-only instances remain valid. In addition, you can still apply for internal and public endpoints.
 * Before you call this operation, make sure that the following requirements are met:
 * *   If the instance runs MySQL, the instance uses a shared proxy.
 * *   The instance is in the Running state.
 * *   Read-only instances are attached to the primary instance.
 * *   The instance does not have an ongoing Data Transmission Service (DTS) migration task.
 * *   The instance runs one of the following database versions and RDS editions:
 *     *   SQL Server (cluster edition)
 *     *   MySQL 5.7 on RDS High-availability Edition with local SSDs
 *     *   MySQL 5.6
 *
 * @param request AllocateReadWriteSplittingConnectionRequest
 * @return AllocateReadWriteSplittingConnectionResponse
 */
func (client *Client) AllocateReadWriteSplittingConnection(request *AllocateReadWriteSplittingConnectionRequest) (_result *AllocateReadWriteSplittingConnectionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AllocateReadWriteSplittingConnectionResponse{}
	_body, _err := client.AllocateReadWriteSplittingConnectionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 *
 * @param request AttachWhitelistTemplateToInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AttachWhitelistTemplateToInstanceResponse
 */
func (client *Client) AttachWhitelistTemplateToInstanceWithOptions(request *AttachWhitelistTemplateToInstanceRequest, runtime *util.RuntimeOptions) (_result *AttachWhitelistTemplateToInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InsName)) {
		query["InsName"] = request.InsName
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.TemplateId)) {
		query["TemplateId"] = request.TemplateId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AttachWhitelistTemplateToInstance"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AttachWhitelistTemplateToInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 *
 * @param request AttachWhitelistTemplateToInstanceRequest
 * @return AttachWhitelistTemplateToInstanceResponse
 */
func (client *Client) AttachWhitelistTemplateToInstance(request *AttachWhitelistTemplateToInstanceRequest) (_result *AttachWhitelistTemplateToInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AttachWhitelistTemplateToInstanceResponse{}
	_body, _err := client.AttachWhitelistTemplateToInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   SQL Server
 * ### [](#)Feature description
 * When the [read/write splitting](~~51073~~) feature is enabled, this operation is used to calculate system-assigned read weights. For more information about custom read weights, see [DescribeDBInstanceNetInfo](~~610423~~).
 * ### [](#)Prerequisites
 * Before you call this operation, make sure that the following requirements are met:
 * *   If the instance runs MySQL, the instance uses a shared proxy.
 * *   The instance runs one of the following MySQL versions and RDS editions:
 *     *   MySQL 5.7 on RDS High-availability Edition (with local disks)
 *     *   MySQL 5.6
 *     *   SQL Server on RDS Cluster Edition
 *
 * @param request CalculateDBInstanceWeightRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CalculateDBInstanceWeightResponse
 */
func (client *Client) CalculateDBInstanceWeightWithOptions(request *CalculateDBInstanceWeightRequest, runtime *util.RuntimeOptions) (_result *CalculateDBInstanceWeightResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CalculateDBInstanceWeight"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CalculateDBInstanceWeightResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   SQL Server
 * ### [](#)Feature description
 * When the [read/write splitting](~~51073~~) feature is enabled, this operation is used to calculate system-assigned read weights. For more information about custom read weights, see [DescribeDBInstanceNetInfo](~~610423~~).
 * ### [](#)Prerequisites
 * Before you call this operation, make sure that the following requirements are met:
 * *   If the instance runs MySQL, the instance uses a shared proxy.
 * *   The instance runs one of the following MySQL versions and RDS editions:
 *     *   MySQL 5.7 on RDS High-availability Edition (with local disks)
 *     *   MySQL 5.6
 *     *   SQL Server on RDS Cluster Edition
 *
 * @param request CalculateDBInstanceWeightRequest
 * @return CalculateDBInstanceWeightResponse
 */
func (client *Client) CalculateDBInstanceWeight(request *CalculateDBInstanceWeightRequest) (_result *CalculateDBInstanceWeightResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CalculateDBInstanceWeightResponse{}
	_body, _err := client.CalculateDBInstanceWeightWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * This operation is supported for instances that run SQL Server and belong to the dedicated or dedicated host instance family. For more information about how to start a migration task, see [ImportDatabaseBetweenInstances](~~26301~~).
 * >  This operation is not supported for instances that run SQL Server 2017 on RDS Cluster Edition.
 *
 * @param request CancelImportRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CancelImportResponse
 */
func (client *Client) CancelImportWithOptions(request *CancelImportRequest, runtime *util.RuntimeOptions) (_result *CancelImportResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ImportId)) {
		query["ImportId"] = request.ImportId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CancelImport"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CancelImportResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * This operation is supported for instances that run SQL Server and belong to the dedicated or dedicated host instance family. For more information about how to start a migration task, see [ImportDatabaseBetweenInstances](~~26301~~).
 * >  This operation is not supported for instances that run SQL Server 2017 on RDS Cluster Edition.
 *
 * @param request CancelImportRequest
 * @return CancelImportResponse
 */
func (client *Client) CancelImport(request *CancelImportRequest) (_result *CancelImportResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CancelImportResponse{}
	_body, _err := client.CancelImportWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CheckAccountNameAvailableWithOptions(request *CheckAccountNameAvailableRequest, runtime *util.RuntimeOptions) (_result *CheckAccountNameAvailableResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AccountName)) {
		query["AccountName"] = request.AccountName
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CheckAccountNameAvailable"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CheckAccountNameAvailableResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CheckAccountNameAvailable(request *CheckAccountNameAvailableRequest) (_result *CheckAccountNameAvailableResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CheckAccountNameAvailableResponse{}
	_body, _err := client.CheckAccountNameAvailableWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CheckCloudResourceAuthorizedWithOptions(request *CheckCloudResourceAuthorizedRequest, runtime *util.RuntimeOptions) (_result *CheckCloudResourceAuthorizedResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	if !tea.BoolValue(util.IsUnset(request.TargetRegionId)) {
		query["TargetRegionId"] = request.TargetRegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CheckCloudResourceAuthorized"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CheckCloudResourceAuthorizedResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CheckCloudResourceAuthorized(request *CheckCloudResourceAuthorizedRequest) (_result *CheckCloudResourceAuthorizedResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CheckCloudResourceAuthorizedResponse{}
	_body, _err := client.CheckCloudResourceAuthorizedWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Before you call this operation, make sure that the instance runs one of the following database engines:
 * *   MySQL. For more information, see [Back up an ApsaraDB RDS for MySQL instance across regions](~~120824~~).
 * *   SQL Server. For more information, see [Back up an ApsaraDB RDS for SQL Server instance across regions](~~187923~~).
 * *   PostgreSQL. For more information, see [Enable cross-region backups for an ApsaraDB RDS for PostgreSQL instance](~~206671~~).
 * > : If your RDS instance uses the new architecture and is created after October 10, 2022, this feature is not supported for the RDS instance. For more information, see [\\[Notice\\] SLR authorization is required to create an ApsaraDB RDS for PostgreSQL instance from October 10, 2022](~~452313~~).
 *
 * @param request CheckCreateDdrDBInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CheckCreateDdrDBInstanceResponse
 */
func (client *Client) CheckCreateDdrDBInstanceWithOptions(request *CheckCreateDdrDBInstanceRequest, runtime *util.RuntimeOptions) (_result *CheckCreateDdrDBInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BackupSetId)) {
		query["BackupSetId"] = request.BackupSetId
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceClass)) {
		query["DBInstanceClass"] = request.DBInstanceClass
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceStorage)) {
		query["DBInstanceStorage"] = request.DBInstanceStorage
	}

	if !tea.BoolValue(util.IsUnset(request.Engine)) {
		query["Engine"] = request.Engine
	}

	if !tea.BoolValue(util.IsUnset(request.EngineVersion)) {
		query["EngineVersion"] = request.EngineVersion
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RestoreTime)) {
		query["RestoreTime"] = request.RestoreTime
	}

	if !tea.BoolValue(util.IsUnset(request.RestoreType)) {
		query["RestoreType"] = request.RestoreType
	}

	if !tea.BoolValue(util.IsUnset(request.SourceDBInstanceName)) {
		query["SourceDBInstanceName"] = request.SourceDBInstanceName
	}

	if !tea.BoolValue(util.IsUnset(request.SourceRegion)) {
		query["SourceRegion"] = request.SourceRegion
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CheckCreateDdrDBInstance"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CheckCreateDdrDBInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Before you call this operation, make sure that the instance runs one of the following database engines:
 * *   MySQL. For more information, see [Back up an ApsaraDB RDS for MySQL instance across regions](~~120824~~).
 * *   SQL Server. For more information, see [Back up an ApsaraDB RDS for SQL Server instance across regions](~~187923~~).
 * *   PostgreSQL. For more information, see [Enable cross-region backups for an ApsaraDB RDS for PostgreSQL instance](~~206671~~).
 * > : If your RDS instance uses the new architecture and is created after October 10, 2022, this feature is not supported for the RDS instance. For more information, see [\\[Notice\\] SLR authorization is required to create an ApsaraDB RDS for PostgreSQL instance from October 10, 2022](~~452313~~).
 *
 * @param request CheckCreateDdrDBInstanceRequest
 * @return CheckCreateDdrDBInstanceResponse
 */
func (client *Client) CheckCreateDdrDBInstance(request *CheckCreateDdrDBInstanceRequest) (_result *CheckCreateDdrDBInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CheckCreateDdrDBInstanceResponse{}
	_body, _err := client.CheckCreateDdrDBInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   RDS MySQL
 * *   RDS PostgreSQL
 * *   RDS SQL Server
 * *   RDS MariaDB
 *
 * @param request CheckDBNameAvailableRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CheckDBNameAvailableResponse
 */
func (client *Client) CheckDBNameAvailableWithOptions(request *CheckDBNameAvailableRequest, runtime *util.RuntimeOptions) (_result *CheckDBNameAvailableResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.DBName)) {
		query["DBName"] = request.DBName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CheckDBNameAvailable"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CheckDBNameAvailableResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   RDS MySQL
 * *   RDS PostgreSQL
 * *   RDS SQL Server
 * *   RDS MariaDB
 *
 * @param request CheckDBNameAvailableRequest
 * @return CheckDBNameAvailableResponse
 */
func (client *Client) CheckDBNameAvailable(request *CheckDBNameAvailableRequest) (_result *CheckDBNameAvailableResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CheckDBNameAvailableResponse{}
	_body, _err := client.CheckDBNameAvailableWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CheckInstanceExistWithOptions(request *CheckInstanceExistRequest, runtime *util.RuntimeOptions) (_result *CheckInstanceExistResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CheckInstanceExist"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CheckInstanceExistResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CheckInstanceExist(request *CheckInstanceExistRequest) (_result *CheckInstanceExistResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CheckInstanceExistResponse{}
	_body, _err := client.CheckInstanceExistWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CheckServiceLinkedRoleWithOptions(request *CheckServiceLinkedRoleRequest, runtime *util.RuntimeOptions) (_result *CheckServiceLinkedRoleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceLinkedRole)) {
		query["ServiceLinkedRole"] = request.ServiceLinkedRole
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CheckServiceLinkedRole"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CheckServiceLinkedRoleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CheckServiceLinkedRole(request *CheckServiceLinkedRoleRequest) (_result *CheckServiceLinkedRoleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CheckServiceLinkedRoleResponse{}
	_body, _err := client.CheckServiceLinkedRoleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 * ### [](#)References
 * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * *   [Restore data of an ApsaraDB RDS for MySQL instance](~~96147~~)
 * *   [Restore data of an ApsaraDB RDS for PostgreSQL instance](~~96776~~)
 * *   [Restore data of an ApsaraDB RDS for SQL Server instance](~~95722~~)
 * *   [Restore data of an ApsaraDB RDS for MariaDB instance](~~97151~~)
 *
 * @param tmpReq CloneDBInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CloneDBInstanceResponse
 */
func (client *Client) CloneDBInstanceWithOptions(tmpReq *CloneDBInstanceRequest, runtime *util.RuntimeOptions) (_result *CloneDBInstanceResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &CloneDBInstanceShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.ServerlessConfig)) {
		request.ServerlessConfigShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.ServerlessConfig, tea.String("ServerlessConfig"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AutoPay)) {
		query["AutoPay"] = request.AutoPay
	}

	if !tea.BoolValue(util.IsUnset(request.BackupId)) {
		query["BackupId"] = request.BackupId
	}

	if !tea.BoolValue(util.IsUnset(request.BackupType)) {
		query["BackupType"] = request.BackupType
	}

	if !tea.BoolValue(util.IsUnset(request.BpeEnabled)) {
		query["BpeEnabled"] = request.BpeEnabled
	}

	if !tea.BoolValue(util.IsUnset(request.BurstingEnabled)) {
		query["BurstingEnabled"] = request.BurstingEnabled
	}

	if !tea.BoolValue(util.IsUnset(request.Category)) {
		query["Category"] = request.Category
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceClass)) {
		query["DBInstanceClass"] = request.DBInstanceClass
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceStorage)) {
		query["DBInstanceStorage"] = request.DBInstanceStorage
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceStorageType)) {
		query["DBInstanceStorageType"] = request.DBInstanceStorageType
	}

	if !tea.BoolValue(util.IsUnset(request.DbNames)) {
		query["DbNames"] = request.DbNames
	}

	if !tea.BoolValue(util.IsUnset(request.DedicatedHostGroupId)) {
		query["DedicatedHostGroupId"] = request.DedicatedHostGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.DeletionProtection)) {
		query["DeletionProtection"] = request.DeletionProtection
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceNetworkType)) {
		query["InstanceNetworkType"] = request.InstanceNetworkType
	}

	if !tea.BoolValue(util.IsUnset(request.PayType)) {
		query["PayType"] = request.PayType
	}

	if !tea.BoolValue(util.IsUnset(request.Period)) {
		query["Period"] = request.Period
	}

	if !tea.BoolValue(util.IsUnset(request.PrivateIpAddress)) {
		query["PrivateIpAddress"] = request.PrivateIpAddress
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RestoreTable)) {
		query["RestoreTable"] = request.RestoreTable
	}

	if !tea.BoolValue(util.IsUnset(request.RestoreTime)) {
		query["RestoreTime"] = request.RestoreTime
	}

	if !tea.BoolValue(util.IsUnset(request.ServerlessConfigShrink)) {
		query["ServerlessConfig"] = request.ServerlessConfigShrink
	}

	if !tea.BoolValue(util.IsUnset(request.TableMeta)) {
		query["TableMeta"] = request.TableMeta
	}

	if !tea.BoolValue(util.IsUnset(request.UsedTime)) {
		query["UsedTime"] = request.UsedTime
	}

	if !tea.BoolValue(util.IsUnset(request.VPCId)) {
		query["VPCId"] = request.VPCId
	}

	if !tea.BoolValue(util.IsUnset(request.VSwitchId)) {
		query["VSwitchId"] = request.VSwitchId
	}

	if !tea.BoolValue(util.IsUnset(request.ZoneId)) {
		query["ZoneId"] = request.ZoneId
	}

	if !tea.BoolValue(util.IsUnset(request.ZoneIdSlave1)) {
		query["ZoneIdSlave1"] = request.ZoneIdSlave1
	}

	if !tea.BoolValue(util.IsUnset(request.ZoneIdSlave2)) {
		query["ZoneIdSlave2"] = request.ZoneIdSlave2
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CloneDBInstance"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CloneDBInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 * ### [](#)References
 * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * *   [Restore data of an ApsaraDB RDS for MySQL instance](~~96147~~)
 * *   [Restore data of an ApsaraDB RDS for PostgreSQL instance](~~96776~~)
 * *   [Restore data of an ApsaraDB RDS for SQL Server instance](~~95722~~)
 * *   [Restore data of an ApsaraDB RDS for MariaDB instance](~~97151~~)
 *
 * @param request CloneDBInstanceRequest
 * @return CloneDBInstanceResponse
 */
func (client *Client) CloneDBInstance(request *CloneDBInstanceRequest) (_result *CloneDBInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CloneDBInstanceResponse{}
	_body, _err := client.CloneDBInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * ### [](#)References
 * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * *   [Use a parameter template to configure the parameters of ApsaraDB RDS for MySQL instances](~~130565~~)
 * *   [Use a parameter template to configure the parameters of ApsaraDB RDS for PostgreSQL instances](~~457176~~)
 *
 * @param request CloneParameterGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CloneParameterGroupResponse
 */
func (client *Client) CloneParameterGroupWithOptions(request *CloneParameterGroupRequest, runtime *util.RuntimeOptions) (_result *CloneParameterGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ParameterGroupDesc)) {
		query["ParameterGroupDesc"] = request.ParameterGroupDesc
	}

	if !tea.BoolValue(util.IsUnset(request.ParameterGroupId)) {
		query["ParameterGroupId"] = request.ParameterGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ParameterGroupName)) {
		query["ParameterGroupName"] = request.ParameterGroupName
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.TargetRegionId)) {
		query["TargetRegionId"] = request.TargetRegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CloneParameterGroup"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CloneParameterGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * ### [](#)References
 * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * *   [Use a parameter template to configure the parameters of ApsaraDB RDS for MySQL instances](~~130565~~)
 * *   [Use a parameter template to configure the parameters of ApsaraDB RDS for PostgreSQL instances](~~457176~~)
 *
 * @param request CloneParameterGroupRequest
 * @return CloneParameterGroupResponse
 */
func (client *Client) CloneParameterGroup(request *CloneParameterGroupRequest) (_result *CloneParameterGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CloneParameterGroupResponse{}
	_body, _err := client.CloneParameterGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * After you call the QueryNotify operation to query notifications for an instance, you can call this operation to mark the notifications as confirmed. For more information, see [Query notifications for an ApsaraDB RDS instance](~~427959~~).
 *
 * @param tmpReq ConfirmNotifyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ConfirmNotifyResponse
 */
func (client *Client) ConfirmNotifyWithOptions(tmpReq *ConfirmNotifyRequest, runtime *util.RuntimeOptions) (_result *ConfirmNotifyResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &ConfirmNotifyShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.NotifyIdList)) {
		request.NotifyIdListShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.NotifyIdList, tea.String("NotifyIdList"), tea.String("json"))
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Confirmor)) {
		body["Confirmor"] = request.Confirmor
	}

	if !tea.BoolValue(util.IsUnset(request.NotifyIdListShrink)) {
		body["NotifyIdList"] = request.NotifyIdListShrink
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("ConfirmNotify"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ConfirmNotifyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * After you call the QueryNotify operation to query notifications for an instance, you can call this operation to mark the notifications as confirmed. For more information, see [Query notifications for an ApsaraDB RDS instance](~~427959~~).
 *
 * @param request ConfirmNotifyRequest
 * @return ConfirmNotifyResponse
 */
func (client *Client) ConfirmNotify(request *ConfirmNotifyRequest) (_result *ConfirmNotifyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ConfirmNotifyResponse{}
	_body, _err := client.ConfirmNotifyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * This operation is phased out.
 *
 * @param request CopyDatabaseRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CopyDatabaseResponse
 */
func (client *Client) CopyDatabaseWithOptions(request *CopyDatabaseRequest, runtime *util.RuntimeOptions) (_result *CopyDatabaseResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CopyDatabase"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CopyDatabaseResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * This operation is phased out.
 *
 * @param request CopyDatabaseRequest
 * @return CopyDatabaseResponse
 */
func (client *Client) CopyDatabase(request *CopyDatabaseRequest) (_result *CopyDatabaseResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CopyDatabaseResponse{}
	_body, _err := client.CopyDatabaseWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Supported database engines
 * RDS SQL Server
 * ### References
 * > : Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
 * [Replicate databases between ApsaraDB RDS for SQL Server instances](~~95702~~)
 *
 * @param request CopyDatabaseBetweenInstancesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CopyDatabaseBetweenInstancesResponse
 */
func (client *Client) CopyDatabaseBetweenInstancesWithOptions(request *CopyDatabaseBetweenInstancesRequest, runtime *util.RuntimeOptions) (_result *CopyDatabaseBetweenInstancesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BackupId)) {
		query["BackupId"] = request.BackupId
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.DbNames)) {
		query["DbNames"] = request.DbNames
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RestoreTime)) {
		query["RestoreTime"] = request.RestoreTime
	}

	if !tea.BoolValue(util.IsUnset(request.SyncUserPrivilege)) {
		query["SyncUserPrivilege"] = request.SyncUserPrivilege
	}

	if !tea.BoolValue(util.IsUnset(request.TargetDBInstanceId)) {
		query["TargetDBInstanceId"] = request.TargetDBInstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CopyDatabaseBetweenInstances"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CopyDatabaseBetweenInstancesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Supported database engines
 * RDS SQL Server
 * ### References
 * > : Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
 * [Replicate databases between ApsaraDB RDS for SQL Server instances](~~95702~~)
 *
 * @param request CopyDatabaseBetweenInstancesRequest
 * @return CopyDatabaseBetweenInstancesResponse
 */
func (client *Client) CopyDatabaseBetweenInstances(request *CopyDatabaseBetweenInstancesRequest) (_result *CopyDatabaseBetweenInstancesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CopyDatabaseBetweenInstancesResponse{}
	_body, _err := client.CopyDatabaseBetweenInstancesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Supported database engines
 * *   RDS MySQL
 * *   RDS PostgreSQL
 * *   RDS SQL Server
 * *   RDS MariaDB
 * ### References
 * > : Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
 * *   [Create an account on an ApsaraDB RDS for MySQL instance](~~96089~~)
 * *   [Create an account on an ApsaraDB RDS for PostgreSQL instance](~~96753~~)
 * *   [Create an account on an ApsaraDB RDS for SQL Server instance](~~95810~~)
 * *   [Create an account on an ApsaraDB RDS for MariaDB instance](~~97132~~)
 *
 * @param request CreateAccountRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateAccountResponse
 */
func (client *Client) CreateAccountWithOptions(request *CreateAccountRequest, runtime *util.RuntimeOptions) (_result *CreateAccountResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AccountDescription)) {
		query["AccountDescription"] = request.AccountDescription
	}

	if !tea.BoolValue(util.IsUnset(request.AccountName)) {
		query["AccountName"] = request.AccountName
	}

	if !tea.BoolValue(util.IsUnset(request.AccountPassword)) {
		query["AccountPassword"] = request.AccountPassword
	}

	if !tea.BoolValue(util.IsUnset(request.AccountType)) {
		query["AccountType"] = request.AccountType
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateAccount"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateAccountResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Supported database engines
 * *   RDS MySQL
 * *   RDS PostgreSQL
 * *   RDS SQL Server
 * *   RDS MariaDB
 * ### References
 * > : Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
 * *   [Create an account on an ApsaraDB RDS for MySQL instance](~~96089~~)
 * *   [Create an account on an ApsaraDB RDS for PostgreSQL instance](~~96753~~)
 * *   [Create an account on an ApsaraDB RDS for SQL Server instance](~~95810~~)
 * *   [Create an account on an ApsaraDB RDS for MariaDB instance](~~97132~~)
 *
 * @param request CreateAccountRequest
 * @return CreateAccountResponse
 */
func (client *Client) CreateAccount(request *CreateAccountRequest) (_result *CreateAccountResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateAccountResponse{}
	_body, _err := client.CreateAccountWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 * ### [](#)Usage notes
 * This operation uses the backup feature of ApsaraDB RDS to create a backup set. You can also use an operation of Database Backup (DBS) to create a backup set. For more information, see [List of operations by function of DBS](~~437245~~).
 * ### [](#)Precautions
 * Before you call this operation, make sure that the following requirements are met:
 * *   The instance is in the Running state.
 * *   The instance does not have ongoing backup tasks.
 * *   The number of backup files that are created per day for an instance cannot exceed 20.
 * ### [](#)References
 * *   [Use the data backup feature for an ApsaraDB RDS for MySQL instance](~~378074~~)
 * *   [Use the data backup feature for an ApsaraDB RDS for PostgreSQL instance](~~96772~~)
 * *   [Use the data backup feature for an ApsaraDB RDS for SQL Server instance](~~95717~~)
 * *   [Use the data backup feature for an ApsaraDB RDS for MariaDB instance](~~97147~~)
 *
 * @param request CreateBackupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateBackupResponse
 */
func (client *Client) CreateBackupWithOptions(request *CreateBackupRequest, runtime *util.RuntimeOptions) (_result *CreateBackupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BackupMethod)) {
		query["BackupMethod"] = request.BackupMethod
	}

	if !tea.BoolValue(util.IsUnset(request.BackupStrategy)) {
		query["BackupStrategy"] = request.BackupStrategy
	}

	if !tea.BoolValue(util.IsUnset(request.BackupType)) {
		query["BackupType"] = request.BackupType
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.DBName)) {
		query["DBName"] = request.DBName
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateBackup"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateBackupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 * ### [](#)Usage notes
 * This operation uses the backup feature of ApsaraDB RDS to create a backup set. You can also use an operation of Database Backup (DBS) to create a backup set. For more information, see [List of operations by function of DBS](~~437245~~).
 * ### [](#)Precautions
 * Before you call this operation, make sure that the following requirements are met:
 * *   The instance is in the Running state.
 * *   The instance does not have ongoing backup tasks.
 * *   The number of backup files that are created per day for an instance cannot exceed 20.
 * ### [](#)References
 * *   [Use the data backup feature for an ApsaraDB RDS for MySQL instance](~~378074~~)
 * *   [Use the data backup feature for an ApsaraDB RDS for PostgreSQL instance](~~96772~~)
 * *   [Use the data backup feature for an ApsaraDB RDS for SQL Server instance](~~95717~~)
 * *   [Use the data backup feature for an ApsaraDB RDS for MariaDB instance](~~97147~~)
 *
 * @param request CreateBackupRequest
 * @return CreateBackupResponse
 */
func (client *Client) CreateBackup(request *CreateBackupRequest) (_result *CreateBackupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateBackupResponse{}
	_body, _err := client.CreateBackupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   PostgreSQL
 * ### [](#)References
 * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * *   [Use the cloud migration feature](~~365562~~)
 *
 * @param request CreateCloudMigrationPrecheckTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateCloudMigrationPrecheckTaskResponse
 */
func (client *Client) CreateCloudMigrationPrecheckTaskWithOptions(request *CreateCloudMigrationPrecheckTaskRequest, runtime *util.RuntimeOptions) (_result *CreateCloudMigrationPrecheckTaskResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceName)) {
		query["DBInstanceName"] = request.DBInstanceName
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SourceAccount)) {
		query["SourceAccount"] = request.SourceAccount
	}

	if !tea.BoolValue(util.IsUnset(request.SourceCategory)) {
		query["SourceCategory"] = request.SourceCategory
	}

	if !tea.BoolValue(util.IsUnset(request.SourceIpAddress)) {
		query["SourceIpAddress"] = request.SourceIpAddress
	}

	if !tea.BoolValue(util.IsUnset(request.SourcePassword)) {
		query["SourcePassword"] = request.SourcePassword
	}

	if !tea.BoolValue(util.IsUnset(request.SourcePort)) {
		query["SourcePort"] = request.SourcePort
	}

	if !tea.BoolValue(util.IsUnset(request.TaskName)) {
		query["TaskName"] = request.TaskName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateCloudMigrationPrecheckTask"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateCloudMigrationPrecheckTaskResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   PostgreSQL
 * ### [](#)References
 * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * *   [Use the cloud migration feature](~~365562~~)
 *
 * @param request CreateCloudMigrationPrecheckTaskRequest
 * @return CreateCloudMigrationPrecheckTaskResponse
 */
func (client *Client) CreateCloudMigrationPrecheckTask(request *CreateCloudMigrationPrecheckTaskRequest) (_result *CreateCloudMigrationPrecheckTaskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateCloudMigrationPrecheckTaskResponse{}
	_body, _err := client.CreateCloudMigrationPrecheckTaskWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   PostgreSQL
 * ### [](#)References
 * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * [Use the cloud migration feature](~~365562~~)
 *
 * @param request CreateCloudMigrationTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateCloudMigrationTaskResponse
 */
func (client *Client) CreateCloudMigrationTaskWithOptions(request *CreateCloudMigrationTaskRequest, runtime *util.RuntimeOptions) (_result *CreateCloudMigrationTaskResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceName)) {
		query["DBInstanceName"] = request.DBInstanceName
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SourceAccount)) {
		query["SourceAccount"] = request.SourceAccount
	}

	if !tea.BoolValue(util.IsUnset(request.SourceCategory)) {
		query["SourceCategory"] = request.SourceCategory
	}

	if !tea.BoolValue(util.IsUnset(request.SourceIpAddress)) {
		query["SourceIpAddress"] = request.SourceIpAddress
	}

	if !tea.BoolValue(util.IsUnset(request.SourcePassword)) {
		query["SourcePassword"] = request.SourcePassword
	}

	if !tea.BoolValue(util.IsUnset(request.SourcePort)) {
		query["SourcePort"] = request.SourcePort
	}

	if !tea.BoolValue(util.IsUnset(request.TaskName)) {
		query["TaskName"] = request.TaskName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateCloudMigrationTask"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateCloudMigrationTaskResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   PostgreSQL
 * ### [](#)References
 * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * [Use the cloud migration feature](~~365562~~)
 *
 * @param request CreateCloudMigrationTaskRequest
 * @return CreateCloudMigrationTaskResponse
 */
func (client *Client) CreateCloudMigrationTask(request *CreateCloudMigrationTaskRequest) (_result *CreateCloudMigrationTaskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateCloudMigrationTaskResponse{}
	_body, _err := client.CreateCloudMigrationTaskWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Supported database engines
 * *   RDS MySQL
 * *   RDS PostgreSQL
 * *   RDS SQL Server
 * *   RDS MariaDB
 * ### References
 * > : Fees are generated if the call is successful. Before you call this operation, carefully read the following documentation:
 * *   [Create an ApsaraDB RDS for MySQL instance](~~148036~~)
 * *   [Create a serverless ApsaraDB RDS for MySQL instance](~~412231~~)
 * *   [Create an ApsaraDB RDS for PostgreSQL instance](~~148038~~)
 * *   [Create a serverless ApsaraDB RDS for PostgreSQL instance](~~607753~~)
 * *   [Enable Babelfish for an ApsaraDB RDS for PostgreSQL instance](~~428615~~)
 * *   [Create an ApsaraDB RDS for SQL Server instance](~~148037~~)
 * *   [Create a serverless ApsaraDB RDS for SQL Server instance](~~603465~~)
 * *   [Create an ApsaraDB RDS for MariaDB instance](~~148040~~)
 *
 * @param tmpReq CreateDBInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDBInstanceResponse
 */
func (client *Client) CreateDBInstanceWithOptions(tmpReq *CreateDBInstanceRequest, runtime *util.RuntimeOptions) (_result *CreateDBInstanceResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &CreateDBInstanceShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.ServerlessConfig)) {
		request.ServerlessConfigShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.ServerlessConfig, tea.String("ServerlessConfig"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Amount)) {
		query["Amount"] = request.Amount
	}

	if !tea.BoolValue(util.IsUnset(request.AutoPay)) {
		query["AutoPay"] = request.AutoPay
	}

	if !tea.BoolValue(util.IsUnset(request.AutoRenew)) {
		query["AutoRenew"] = request.AutoRenew
	}

	if !tea.BoolValue(util.IsUnset(request.BabelfishConfig)) {
		query["BabelfishConfig"] = request.BabelfishConfig
	}

	if !tea.BoolValue(util.IsUnset(request.BpeEnabled)) {
		query["BpeEnabled"] = request.BpeEnabled
	}

	if !tea.BoolValue(util.IsUnset(request.BurstingEnabled)) {
		query["BurstingEnabled"] = request.BurstingEnabled
	}

	if !tea.BoolValue(util.IsUnset(request.BusinessInfo)) {
		query["BusinessInfo"] = request.BusinessInfo
	}

	if !tea.BoolValue(util.IsUnset(request.Category)) {
		query["Category"] = request.Category
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.ConnectionMode)) {
		query["ConnectionMode"] = request.ConnectionMode
	}

	if !tea.BoolValue(util.IsUnset(request.ConnectionString)) {
		query["ConnectionString"] = request.ConnectionString
	}

	if !tea.BoolValue(util.IsUnset(request.CreateStrategy)) {
		query["CreateStrategy"] = request.CreateStrategy
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceClass)) {
		query["DBInstanceClass"] = request.DBInstanceClass
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceDescription)) {
		query["DBInstanceDescription"] = request.DBInstanceDescription
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceNetType)) {
		query["DBInstanceNetType"] = request.DBInstanceNetType
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceStorage)) {
		query["DBInstanceStorage"] = request.DBInstanceStorage
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceStorageType)) {
		query["DBInstanceStorageType"] = request.DBInstanceStorageType
	}

	if !tea.BoolValue(util.IsUnset(request.DBIsIgnoreCase)) {
		query["DBIsIgnoreCase"] = request.DBIsIgnoreCase
	}

	if !tea.BoolValue(util.IsUnset(request.DBParamGroupId)) {
		query["DBParamGroupId"] = request.DBParamGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.DBTimeZone)) {
		query["DBTimeZone"] = request.DBTimeZone
	}

	if !tea.BoolValue(util.IsUnset(request.DedicatedHostGroupId)) {
		query["DedicatedHostGroupId"] = request.DedicatedHostGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.DeletionProtection)) {
		query["DeletionProtection"] = request.DeletionProtection
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.EncryptionKey)) {
		query["EncryptionKey"] = request.EncryptionKey
	}

	if !tea.BoolValue(util.IsUnset(request.Engine)) {
		query["Engine"] = request.Engine
	}

	if !tea.BoolValue(util.IsUnset(request.EngineVersion)) {
		query["EngineVersion"] = request.EngineVersion
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceNetworkType)) {
		query["InstanceNetworkType"] = request.InstanceNetworkType
	}

	if !tea.BoolValue(util.IsUnset(request.PayType)) {
		query["PayType"] = request.PayType
	}

	if !tea.BoolValue(util.IsUnset(request.Period)) {
		query["Period"] = request.Period
	}

	if !tea.BoolValue(util.IsUnset(request.Port)) {
		query["Port"] = request.Port
	}

	if !tea.BoolValue(util.IsUnset(request.PrivateIpAddress)) {
		query["PrivateIpAddress"] = request.PrivateIpAddress
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RoleARN)) {
		query["RoleARN"] = request.RoleARN
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityIPList)) {
		query["SecurityIPList"] = request.SecurityIPList
	}

	if !tea.BoolValue(util.IsUnset(request.ServerlessConfigShrink)) {
		query["ServerlessConfig"] = request.ServerlessConfigShrink
	}

	if !tea.BoolValue(util.IsUnset(request.StorageAutoScale)) {
		query["StorageAutoScale"] = request.StorageAutoScale
	}

	if !tea.BoolValue(util.IsUnset(request.StorageThreshold)) {
		query["StorageThreshold"] = request.StorageThreshold
	}

	if !tea.BoolValue(util.IsUnset(request.StorageUpperBound)) {
		query["StorageUpperBound"] = request.StorageUpperBound
	}

	if !tea.BoolValue(util.IsUnset(request.SystemDBCharset)) {
		query["SystemDBCharset"] = request.SystemDBCharset
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	if !tea.BoolValue(util.IsUnset(request.TargetDedicatedHostIdForLog)) {
		query["TargetDedicatedHostIdForLog"] = request.TargetDedicatedHostIdForLog
	}

	if !tea.BoolValue(util.IsUnset(request.TargetDedicatedHostIdForMaster)) {
		query["TargetDedicatedHostIdForMaster"] = request.TargetDedicatedHostIdForMaster
	}

	if !tea.BoolValue(util.IsUnset(request.TargetDedicatedHostIdForSlave)) {
		query["TargetDedicatedHostIdForSlave"] = request.TargetDedicatedHostIdForSlave
	}

	if !tea.BoolValue(util.IsUnset(request.TargetMinorVersion)) {
		query["TargetMinorVersion"] = request.TargetMinorVersion
	}

	if !tea.BoolValue(util.IsUnset(request.UsedTime)) {
		query["UsedTime"] = request.UsedTime
	}

	if !tea.BoolValue(util.IsUnset(request.UserBackupId)) {
		query["UserBackupId"] = request.UserBackupId
	}

	if !tea.BoolValue(util.IsUnset(request.VPCId)) {
		query["VPCId"] = request.VPCId
	}

	if !tea.BoolValue(util.IsUnset(request.VSwitchId)) {
		query["VSwitchId"] = request.VSwitchId
	}

	if !tea.BoolValue(util.IsUnset(request.ZoneId)) {
		query["ZoneId"] = request.ZoneId
	}

	if !tea.BoolValue(util.IsUnset(request.ZoneIdSlave1)) {
		query["ZoneIdSlave1"] = request.ZoneIdSlave1
	}

	if !tea.BoolValue(util.IsUnset(request.ZoneIdSlave2)) {
		query["ZoneIdSlave2"] = request.ZoneIdSlave2
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateDBInstance"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateDBInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Supported database engines
 * *   RDS MySQL
 * *   RDS PostgreSQL
 * *   RDS SQL Server
 * *   RDS MariaDB
 * ### References
 * > : Fees are generated if the call is successful. Before you call this operation, carefully read the following documentation:
 * *   [Create an ApsaraDB RDS for MySQL instance](~~148036~~)
 * *   [Create a serverless ApsaraDB RDS for MySQL instance](~~412231~~)
 * *   [Create an ApsaraDB RDS for PostgreSQL instance](~~148038~~)
 * *   [Create a serverless ApsaraDB RDS for PostgreSQL instance](~~607753~~)
 * *   [Enable Babelfish for an ApsaraDB RDS for PostgreSQL instance](~~428615~~)
 * *   [Create an ApsaraDB RDS for SQL Server instance](~~148037~~)
 * *   [Create a serverless ApsaraDB RDS for SQL Server instance](~~603465~~)
 * *   [Create an ApsaraDB RDS for MariaDB instance](~~148040~~)
 *
 * @param request CreateDBInstanceRequest
 * @return CreateDBInstanceResponse
 */
func (client *Client) CreateDBInstance(request *CreateDBInstanceRequest) (_result *CreateDBInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateDBInstanceResponse{}
	_body, _err := client.CreateDBInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Supported database engine
 * MySQL
 * ### References
 * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation:
 * [Add a read-only endpoint for a cluster](~~464132~~)
 *
 * @param tmpReq CreateDBInstanceEndpointRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDBInstanceEndpointResponse
 */
func (client *Client) CreateDBInstanceEndpointWithOptions(tmpReq *CreateDBInstanceEndpointRequest, runtime *util.RuntimeOptions) (_result *CreateDBInstanceEndpointResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &CreateDBInstanceEndpointShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.NodeItems)) {
		request.NodeItemsShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.NodeItems, tea.String("NodeItems"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.ConnectionStringPrefix)) {
		query["ConnectionStringPrefix"] = request.ConnectionStringPrefix
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceEndpointDescription)) {
		query["DBInstanceEndpointDescription"] = request.DBInstanceEndpointDescription
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceEndpointType)) {
		query["DBInstanceEndpointType"] = request.DBInstanceEndpointType
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.NodeItemsShrink)) {
		query["NodeItems"] = request.NodeItemsShrink
	}

	if !tea.BoolValue(util.IsUnset(request.Port)) {
		query["Port"] = request.Port
	}

	if !tea.BoolValue(util.IsUnset(request.PrivateIpAddress)) {
		query["PrivateIpAddress"] = request.PrivateIpAddress
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.VSwitchId)) {
		query["VSwitchId"] = request.VSwitchId
	}

	if !tea.BoolValue(util.IsUnset(request.VpcId)) {
		query["VpcId"] = request.VpcId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateDBInstanceEndpoint"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateDBInstanceEndpointResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Supported database engine
 * MySQL
 * ### References
 * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation:
 * [Add a read-only endpoint for a cluster](~~464132~~)
 *
 * @param request CreateDBInstanceEndpointRequest
 * @return CreateDBInstanceEndpointResponse
 */
func (client *Client) CreateDBInstanceEndpoint(request *CreateDBInstanceEndpointRequest) (_result *CreateDBInstanceEndpointResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateDBInstanceEndpointResponse{}
	_body, _err := client.CreateDBInstanceEndpointWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Supported database engine
 * MySQL
 * ### Precautions
 * *   You can create a public endpoint of an endpoint type only when no public endpoint is created for this endpoint type.
 * *   The node weights and other configurations are the same as those of the internal endpoint of this endpoint type. Only one public endpoint and one internal endpoint can be created for each endpoint type.
 *
 * @param request CreateDBInstanceEndpointAddressRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDBInstanceEndpointAddressResponse
 */
func (client *Client) CreateDBInstanceEndpointAddressWithOptions(request *CreateDBInstanceEndpointAddressRequest, runtime *util.RuntimeOptions) (_result *CreateDBInstanceEndpointAddressResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.ConnectionStringPrefix)) {
		query["ConnectionStringPrefix"] = request.ConnectionStringPrefix
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceEndpointId)) {
		query["DBInstanceEndpointId"] = request.DBInstanceEndpointId
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.IpType)) {
		query["IpType"] = request.IpType
	}

	if !tea.BoolValue(util.IsUnset(request.Port)) {
		query["Port"] = request.Port
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateDBInstanceEndpointAddress"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateDBInstanceEndpointAddressResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Supported database engine
 * MySQL
 * ### Precautions
 * *   You can create a public endpoint of an endpoint type only when no public endpoint is created for this endpoint type.
 * *   The node weights and other configurations are the same as those of the internal endpoint of this endpoint type. Only one public endpoint and one internal endpoint can be created for each endpoint type.
 *
 * @param request CreateDBInstanceEndpointAddressRequest
 * @return CreateDBInstanceEndpointAddressResponse
 */
func (client *Client) CreateDBInstanceEndpointAddress(request *CreateDBInstanceEndpointAddressRequest) (_result *CreateDBInstanceEndpointAddressResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateDBInstanceEndpointAddressResponse{}
	_body, _err := client.CreateDBInstanceEndpointAddressWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Supported database engines
 * *   RDS MySQL
 * *   RDS PostgreSQL
 * *   RDS SQL Server
 * *   RDS MariaDB
 * ### References
 * > : Fees are generated if the call is successful. Before you call this operation, carefully read the following documentation:
 * *   [Manage ApsaraDB RDS for MySQL instances in the recycle bin](~~96065~~)
 * *   [Manage ApsaraDB RDS for PostgreSQL instances in the recycle bin](~~96752~~)
 * *   [Manage ApsaraDB RDS for SQL Server instances in the recycle bin](~~95669~~)
 * *   [Manage ApsaraDB RDS for MariaDB instances in the recycle bin](~~97131~~)
 *
 * @param request CreateDBInstanceForRebuildRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDBInstanceForRebuildResponse
 */
func (client *Client) CreateDBInstanceForRebuildWithOptions(request *CreateDBInstanceForRebuildRequest, runtime *util.RuntimeOptions) (_result *CreateDBInstanceForRebuildResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceDescription)) {
		query["DBInstanceDescription"] = request.DBInstanceDescription
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceNetType)) {
		query["DBInstanceNetType"] = request.DBInstanceNetType
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceNetworkType)) {
		query["InstanceNetworkType"] = request.InstanceNetworkType
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PayType)) {
		query["PayType"] = request.PayType
	}

	if !tea.BoolValue(util.IsUnset(request.Period)) {
		query["Period"] = request.Period
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityIPList)) {
		query["SecurityIPList"] = request.SecurityIPList
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	if !tea.BoolValue(util.IsUnset(request.UsedTime)) {
		query["UsedTime"] = request.UsedTime
	}

	if !tea.BoolValue(util.IsUnset(request.VPCId)) {
		query["VPCId"] = request.VPCId
	}

	if !tea.BoolValue(util.IsUnset(request.VSwitchId)) {
		query["VSwitchId"] = request.VSwitchId
	}

	if !tea.BoolValue(util.IsUnset(request.ZoneId)) {
		query["ZoneId"] = request.ZoneId
	}

	if !tea.BoolValue(util.IsUnset(request.ZoneIdSlave1)) {
		query["ZoneIdSlave1"] = request.ZoneIdSlave1
	}

	if !tea.BoolValue(util.IsUnset(request.ZoneIdSlave2)) {
		query["ZoneIdSlave2"] = request.ZoneIdSlave2
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateDBInstanceForRebuild"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateDBInstanceForRebuildResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Supported database engines
 * *   RDS MySQL
 * *   RDS PostgreSQL
 * *   RDS SQL Server
 * *   RDS MariaDB
 * ### References
 * > : Fees are generated if the call is successful. Before you call this operation, carefully read the following documentation:
 * *   [Manage ApsaraDB RDS for MySQL instances in the recycle bin](~~96065~~)
 * *   [Manage ApsaraDB RDS for PostgreSQL instances in the recycle bin](~~96752~~)
 * *   [Manage ApsaraDB RDS for SQL Server instances in the recycle bin](~~95669~~)
 * *   [Manage ApsaraDB RDS for MariaDB instances in the recycle bin](~~97131~~)
 *
 * @param request CreateDBInstanceForRebuildRequest
 * @return CreateDBInstanceForRebuildResponse
 */
func (client *Client) CreateDBInstanceForRebuild(request *CreateDBInstanceForRebuildRequest) (_result *CreateDBInstanceForRebuildResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateDBInstanceForRebuildResponse{}
	_body, _err := client.CreateDBInstanceForRebuildWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Supported database engines
 * MySQL
 * ### References
 * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * [Add a node to an ApsaraDB RDS for MySQL cluster](~~464129~~)
 *
 * @param tmpReq CreateDBNodesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDBNodesResponse
 */
func (client *Client) CreateDBNodesWithOptions(tmpReq *CreateDBNodesRequest, runtime *util.RuntimeOptions) (_result *CreateDBNodesResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &CreateDBNodesShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.DBNode)) {
		request.DBNodeShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.DBNode, tea.String("DBNode"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.DBNodeShrink)) {
		query["DBNode"] = request.DBNodeShrink
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateDBNodes"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateDBNodesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Supported database engines
 * MySQL
 * ### References
 * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * [Add a node to an ApsaraDB RDS for MySQL cluster](~~464129~~)
 *
 * @param request CreateDBNodesRequest
 * @return CreateDBNodesResponse
 */
func (client *Client) CreateDBNodes(request *CreateDBNodesRequest) (_result *CreateDBNodesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateDBNodesResponse{}
	_body, _err := client.CreateDBNodesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   RDS MySQL
 * *   RDS PostgreSQL
 * ### [](#)References
 * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * *   [Configure the dedicated proxy endpoint of an ApsaraDB RDS for MySQL instance](~~184921~~)
 * *   [Configure the dedicated proxy endpoint of an ApsaraDB RDS for PostgreSQL instance](~~418274~~)
 *
 * @param request CreateDBProxyEndpointAddressRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDBProxyEndpointAddressResponse
 */
func (client *Client) CreateDBProxyEndpointAddressWithOptions(request *CreateDBProxyEndpointAddressRequest, runtime *util.RuntimeOptions) (_result *CreateDBProxyEndpointAddressResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ConnectionStringPrefix)) {
		query["ConnectionStringPrefix"] = request.ConnectionStringPrefix
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.DBProxyConnectStringNetType)) {
		query["DBProxyConnectStringNetType"] = request.DBProxyConnectStringNetType
	}

	if !tea.BoolValue(util.IsUnset(request.DBProxyEndpointId)) {
		query["DBProxyEndpointId"] = request.DBProxyEndpointId
	}

	if !tea.BoolValue(util.IsUnset(request.DBProxyEngineType)) {
		query["DBProxyEngineType"] = request.DBProxyEngineType
	}

	if !tea.BoolValue(util.IsUnset(request.DBProxyNewConnectStringPort)) {
		query["DBProxyNewConnectStringPort"] = request.DBProxyNewConnectStringPort
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.VPCId)) {
		query["VPCId"] = request.VPCId
	}

	if !tea.BoolValue(util.IsUnset(request.VSwitchId)) {
		query["VSwitchId"] = request.VSwitchId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateDBProxyEndpointAddress"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateDBProxyEndpointAddressResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   RDS MySQL
 * *   RDS PostgreSQL
 * ### [](#)References
 * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * *   [Configure the dedicated proxy endpoint of an ApsaraDB RDS for MySQL instance](~~184921~~)
 * *   [Configure the dedicated proxy endpoint of an ApsaraDB RDS for PostgreSQL instance](~~418274~~)
 *
 * @param request CreateDBProxyEndpointAddressRequest
 * @return CreateDBProxyEndpointAddressResponse
 */
func (client *Client) CreateDBProxyEndpointAddress(request *CreateDBProxyEndpointAddressRequest) (_result *CreateDBProxyEndpointAddressResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateDBProxyEndpointAddressResponse{}
	_body, _err := client.CreateDBProxyEndpointAddressWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 * ### References
 * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
 * *   [Create a database in an ApsaraDB RDS for MySQL instance](~~96105~~)
 * *   [Create a database in an ApsaraDB RDS for PostgreSQL instance](~~96758~~)
 * *   [Create a database in an ApsaraDB RDS for SQL Server instance](~~95698~~)
 * *   [Create a database in an ApsaraDB RDS for MariaDB instance](~~97136~~)
 *
 * @param request CreateDatabaseRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDatabaseResponse
 */
func (client *Client) CreateDatabaseWithOptions(request *CreateDatabaseRequest, runtime *util.RuntimeOptions) (_result *CreateDatabaseResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CharacterSetName)) {
		query["CharacterSetName"] = request.CharacterSetName
	}

	if !tea.BoolValue(util.IsUnset(request.DBDescription)) {
		query["DBDescription"] = request.DBDescription
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.DBName)) {
		query["DBName"] = request.DBName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateDatabase"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateDatabaseResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 * ### References
 * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
 * *   [Create a database in an ApsaraDB RDS for MySQL instance](~~96105~~)
 * *   [Create a database in an ApsaraDB RDS for PostgreSQL instance](~~96758~~)
 * *   [Create a database in an ApsaraDB RDS for SQL Server instance](~~95698~~)
 * *   [Create a database in an ApsaraDB RDS for MariaDB instance](~~97136~~)
 *
 * @param request CreateDatabaseRequest
 * @return CreateDatabaseResponse
 */
func (client *Client) CreateDatabase(request *CreateDatabaseRequest) (_result *CreateDatabaseResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateDatabaseResponse{}
	_body, _err := client.CreateDatabaseWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * >  Before restoration, you can call the [CheckCreateDdrDBInstance](~~121721~~) operation to check whether a cross-region backup set can be used for cross-region restoration.
 * ### [](#)Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * ### [](#)References
 * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * *   [Use the cross-region backup feature of an ApsaraDB RDS for MySQL instance](~~120824~~)
 * *   [Use the cross-region backup feature for an ApsaraDB RDS for PostgreSQL instance](~~206671~~)
 * *   [Use the cross-region backup feature for an ApsaraDB RDS for SQL Server instance](~~187923~~)
 *
 * @param request CreateDdrInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDdrInstanceResponse
 */
func (client *Client) CreateDdrInstanceWithOptions(request *CreateDdrInstanceRequest, runtime *util.RuntimeOptions) (_result *CreateDdrInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BackupSetId)) {
		query["BackupSetId"] = request.BackupSetId
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.ConnectionMode)) {
		query["ConnectionMode"] = request.ConnectionMode
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceClass)) {
		query["DBInstanceClass"] = request.DBInstanceClass
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceDescription)) {
		query["DBInstanceDescription"] = request.DBInstanceDescription
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceNetType)) {
		query["DBInstanceNetType"] = request.DBInstanceNetType
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceStorage)) {
		query["DBInstanceStorage"] = request.DBInstanceStorage
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceStorageType)) {
		query["DBInstanceStorageType"] = request.DBInstanceStorageType
	}

	if !tea.BoolValue(util.IsUnset(request.Engine)) {
		query["Engine"] = request.Engine
	}

	if !tea.BoolValue(util.IsUnset(request.EngineVersion)) {
		query["EngineVersion"] = request.EngineVersion
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceNetworkType)) {
		query["InstanceNetworkType"] = request.InstanceNetworkType
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PayType)) {
		query["PayType"] = request.PayType
	}

	if !tea.BoolValue(util.IsUnset(request.Period)) {
		query["Period"] = request.Period
	}

	if !tea.BoolValue(util.IsUnset(request.PrivateIpAddress)) {
		query["PrivateIpAddress"] = request.PrivateIpAddress
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RestoreTime)) {
		query["RestoreTime"] = request.RestoreTime
	}

	if !tea.BoolValue(util.IsUnset(request.RestoreType)) {
		query["RestoreType"] = request.RestoreType
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityIPList)) {
		query["SecurityIPList"] = request.SecurityIPList
	}

	if !tea.BoolValue(util.IsUnset(request.SourceDBInstanceName)) {
		query["SourceDBInstanceName"] = request.SourceDBInstanceName
	}

	if !tea.BoolValue(util.IsUnset(request.SourceRegion)) {
		query["SourceRegion"] = request.SourceRegion
	}

	if !tea.BoolValue(util.IsUnset(request.SystemDBCharset)) {
		query["SystemDBCharset"] = request.SystemDBCharset
	}

	if !tea.BoolValue(util.IsUnset(request.UsedTime)) {
		query["UsedTime"] = request.UsedTime
	}

	if !tea.BoolValue(util.IsUnset(request.VPCId)) {
		query["VPCId"] = request.VPCId
	}

	if !tea.BoolValue(util.IsUnset(request.VSwitchId)) {
		query["VSwitchId"] = request.VSwitchId
	}

	if !tea.BoolValue(util.IsUnset(request.ZoneId)) {
		query["ZoneId"] = request.ZoneId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateDdrInstance"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateDdrInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * >  Before restoration, you can call the [CheckCreateDdrDBInstance](~~121721~~) operation to check whether a cross-region backup set can be used for cross-region restoration.
 * ### [](#)Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * ### [](#)References
 * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * *   [Use the cross-region backup feature of an ApsaraDB RDS for MySQL instance](~~120824~~)
 * *   [Use the cross-region backup feature for an ApsaraDB RDS for PostgreSQL instance](~~206671~~)
 * *   [Use the cross-region backup feature for an ApsaraDB RDS for SQL Server instance](~~187923~~)
 *
 * @param request CreateDdrInstanceRequest
 * @return CreateDdrInstanceResponse
 */
func (client *Client) CreateDdrInstance(request *CreateDdrInstanceRequest) (_result *CreateDdrInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateDdrInstanceResponse{}
	_body, _err := client.CreateDdrInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > This operation is no longer maintained. You can use the CreateDiagnosticReport operation of Database Autonomy Service (DAS) to create a diagnostic report.
 * After you call this operation to create a diagnostic report, you can call the DescribeDiagnosticReportList operation to download the diagnostic report.
 *
 * @param request CreateDiagnosticReportRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDiagnosticReportResponse
 */
func (client *Client) CreateDiagnosticReportWithOptions(request *CreateDiagnosticReportRequest, runtime *util.RuntimeOptions) (_result *CreateDiagnosticReportResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateDiagnosticReport"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateDiagnosticReportResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > This operation is no longer maintained. You can use the CreateDiagnosticReport operation of Database Autonomy Service (DAS) to create a diagnostic report.
 * After you call this operation to create a diagnostic report, you can call the DescribeDiagnosticReportList operation to download the diagnostic report.
 *
 * @param request CreateDiagnosticReportRequest
 * @return CreateDiagnosticReportResponse
 */
func (client *Client) CreateDiagnosticReport(request *CreateDiagnosticReportRequest) (_result *CreateDiagnosticReportResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateDiagnosticReportResponse{}
	_body, _err := client.CreateDiagnosticReportWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Prerequisites
 * *   Your Alibaba Cloud account is used.
 * *   The balance in your Alibaba Cloud account is greater than or equal to USD 100.
 * *   A primary ApsaraDB RDS for MySQL instance is created, and the instance is not running as a node in a global active database cluster. You can call the [CreateDBInstance](~~26228~~) operation to create an instance.
 * > You must create a primary ApsaraDB RDS for MySQL instance in one of the following regions: China (Hangzhou), China (Shanghai), China (Qingdao), China (Beijing), China (Zhangjiakou), China (Shenzhen), and China (Chengdu).
 * For more information, see [Create and release an ApsaraDB RDS global active database cluster](~~328592~~).
 *
 * @param request CreateGADInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateGADInstanceResponse
 */
func (client *Client) CreateGADInstanceWithOptions(request *CreateGADInstanceRequest, runtime *util.RuntimeOptions) (_result *CreateGADInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CentralDBInstanceId)) {
		query["CentralDBInstanceId"] = request.CentralDBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.CentralRdsDtsAdminAccount)) {
		query["CentralRdsDtsAdminAccount"] = request.CentralRdsDtsAdminAccount
	}

	if !tea.BoolValue(util.IsUnset(request.CentralRdsDtsAdminPassword)) {
		query["CentralRdsDtsAdminPassword"] = request.CentralRdsDtsAdminPassword
	}

	if !tea.BoolValue(util.IsUnset(request.CentralRegionId)) {
		query["CentralRegionId"] = request.CentralRegionId
	}

	if !tea.BoolValue(util.IsUnset(request.DBList)) {
		query["DBList"] = request.DBList
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	if !tea.BoolValue(util.IsUnset(request.UnitNode)) {
		query["UnitNode"] = request.UnitNode
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateGADInstance"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateGADInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Prerequisites
 * *   Your Alibaba Cloud account is used.
 * *   The balance in your Alibaba Cloud account is greater than or equal to USD 100.
 * *   A primary ApsaraDB RDS for MySQL instance is created, and the instance is not running as a node in a global active database cluster. You can call the [CreateDBInstance](~~26228~~) operation to create an instance.
 * > You must create a primary ApsaraDB RDS for MySQL instance in one of the following regions: China (Hangzhou), China (Shanghai), China (Qingdao), China (Beijing), China (Zhangjiakou), China (Shenzhen), and China (Chengdu).
 * For more information, see [Create and release an ApsaraDB RDS global active database cluster](~~328592~~).
 *
 * @param request CreateGADInstanceRequest
 * @return CreateGADInstanceResponse
 */
func (client *Client) CreateGADInstance(request *CreateGADInstanceRequest) (_result *CreateGADInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateGADInstanceResponse{}
	_body, _err := client.CreateGADInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## [](#)Prerequisites
 * An ApsaraDB RDS global active database cluster is created. You can call the [CreateGADInstance](~~336893~~) operation to create a global active database cluster.
 * For more information, see [Add unit nodes to or move unit nodes from an ApsaraDB RDS global active database cluster](~~331851~~).
 *
 * @param request CreateGadInstanceMemberRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateGadInstanceMemberResponse
 */
func (client *Client) CreateGadInstanceMemberWithOptions(request *CreateGadInstanceMemberRequest, runtime *util.RuntimeOptions) (_result *CreateGadInstanceMemberResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CentralDBInstanceId)) {
		query["CentralDBInstanceId"] = request.CentralDBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.CentralRdsDtsAdminAccount)) {
		query["CentralRdsDtsAdminAccount"] = request.CentralRdsDtsAdminAccount
	}

	if !tea.BoolValue(util.IsUnset(request.CentralRdsDtsAdminPassword)) {
		query["CentralRdsDtsAdminPassword"] = request.CentralRdsDtsAdminPassword
	}

	if !tea.BoolValue(util.IsUnset(request.CentralRegionId)) {
		query["CentralRegionId"] = request.CentralRegionId
	}

	if !tea.BoolValue(util.IsUnset(request.DBList)) {
		query["DBList"] = request.DBList
	}

	if !tea.BoolValue(util.IsUnset(request.GadInstanceId)) {
		query["GadInstanceId"] = request.GadInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.UnitNode)) {
		query["UnitNode"] = request.UnitNode
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateGadInstanceMember"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateGadInstanceMemberResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## [](#)Prerequisites
 * An ApsaraDB RDS global active database cluster is created. You can call the [CreateGADInstance](~~336893~~) operation to create a global active database cluster.
 * For more information, see [Add unit nodes to or move unit nodes from an ApsaraDB RDS global active database cluster](~~331851~~).
 *
 * @param request CreateGadInstanceMemberRequest
 * @return CreateGadInstanceMemberResponse
 */
func (client *Client) CreateGadInstanceMember(request *CreateGadInstanceMemberRequest) (_result *CreateGadInstanceMemberResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateGadInstanceMemberResponse{}
	_body, _err := client.CreateGadInstanceMemberWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * SQL Server
 * ### [](#)References
 * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * [Migrate data from a self-managed SQL Server instance to an ApsaraDB RDS for SQL Server instance](~~100019~~)
 *
 * @param request CreateMigrateTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateMigrateTaskResponse
 */
func (client *Client) CreateMigrateTaskWithOptions(request *CreateMigrateTaskRequest, runtime *util.RuntimeOptions) (_result *CreateMigrateTaskResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BackupMode)) {
		query["BackupMode"] = request.BackupMode
	}

	if !tea.BoolValue(util.IsUnset(request.CheckDBMode)) {
		query["CheckDBMode"] = request.CheckDBMode
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.DBName)) {
		query["DBName"] = request.DBName
	}

	if !tea.BoolValue(util.IsUnset(request.IsOnlineDB)) {
		query["IsOnlineDB"] = request.IsOnlineDB
	}

	if !tea.BoolValue(util.IsUnset(request.MigrateTaskId)) {
		query["MigrateTaskId"] = request.MigrateTaskId
	}

	if !tea.BoolValue(util.IsUnset(request.OSSUrls)) {
		query["OSSUrls"] = request.OSSUrls
	}

	if !tea.BoolValue(util.IsUnset(request.OssObjectPositions)) {
		query["OssObjectPositions"] = request.OssObjectPositions
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateMigrateTask"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateMigrateTaskResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * SQL Server
 * ### [](#)References
 * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * [Migrate data from a self-managed SQL Server instance to an ApsaraDB RDS for SQL Server instance](~~100019~~)
 *
 * @param request CreateMigrateTaskRequest
 * @return CreateMigrateTaskResponse
 */
func (client *Client) CreateMigrateTask(request *CreateMigrateTaskRequest) (_result *CreateMigrateTaskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateMigrateTaskResponse{}
	_body, _err := client.CreateMigrateTaskWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   SQL Server
 * ### [](#)References
 * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * This operation is used to migrate backup data to the cloud. Before you call this operation, make sure that you understand the descriptions in the following topics:
 * *   [Migrate the full backup data of a self-managed SQL Server database to an ApsaraDB RDS instance that runs SQL Server 2008 R2](~~95737~~)
 * *   [Migrate full backup data of SQL Server 2012, 2014, 2016, 2017, or 2019 databases](~~95738~~)
 * *   [Migrate incremental backup data to ApsaraDB RDS for SQL Server 2012, 2014, 2016, 2017, or 2019](~~95736~~)
 *
 * @param request CreateOnlineDatabaseTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateOnlineDatabaseTaskResponse
 */
func (client *Client) CreateOnlineDatabaseTaskWithOptions(request *CreateOnlineDatabaseTaskRequest, runtime *util.RuntimeOptions) (_result *CreateOnlineDatabaseTaskResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CheckDBMode)) {
		query["CheckDBMode"] = request.CheckDBMode
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.DBName)) {
		query["DBName"] = request.DBName
	}

	if !tea.BoolValue(util.IsUnset(request.MigrateTaskId)) {
		query["MigrateTaskId"] = request.MigrateTaskId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateOnlineDatabaseTask"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateOnlineDatabaseTaskResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   SQL Server
 * ### [](#)References
 * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * This operation is used to migrate backup data to the cloud. Before you call this operation, make sure that you understand the descriptions in the following topics:
 * *   [Migrate the full backup data of a self-managed SQL Server database to an ApsaraDB RDS instance that runs SQL Server 2008 R2](~~95737~~)
 * *   [Migrate full backup data of SQL Server 2012, 2014, 2016, 2017, or 2019 databases](~~95738~~)
 * *   [Migrate incremental backup data to ApsaraDB RDS for SQL Server 2012, 2014, 2016, 2017, or 2019](~~95736~~)
 *
 * @param request CreateOnlineDatabaseTaskRequest
 * @return CreateOnlineDatabaseTaskResponse
 */
func (client *Client) CreateOnlineDatabaseTask(request *CreateOnlineDatabaseTaskRequest) (_result *CreateOnlineDatabaseTaskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateOnlineDatabaseTaskResponse{}
	_body, _err := client.CreateOnlineDatabaseTaskWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * MySQL
 * ### [](#)References
 * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * [Add a node to an ApsaraDB RDS for MySQL cluster](~~464129~~)
 *
 * @param tmpReq CreateOrderForCreateDBNodesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateOrderForCreateDBNodesResponse
 */
func (client *Client) CreateOrderForCreateDBNodesWithOptions(tmpReq *CreateOrderForCreateDBNodesRequest, runtime *util.RuntimeOptions) (_result *CreateOrderForCreateDBNodesResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &CreateOrderForCreateDBNodesShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.DBNode)) {
		request.DBNodeShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.DBNode, tea.String("DBNode"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AutoPay)) {
		query["AutoPay"] = request.AutoPay
	}

	if !tea.BoolValue(util.IsUnset(request.BusinessInfo)) {
		query["BusinessInfo"] = request.BusinessInfo
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.CommodityCode)) {
		query["CommodityCode"] = request.CommodityCode
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.DBNodeShrink)) {
		query["DBNode"] = request.DBNodeShrink
	}

	if !tea.BoolValue(util.IsUnset(request.EngineVersion)) {
		query["EngineVersion"] = request.EngineVersion
	}

	if !tea.BoolValue(util.IsUnset(request.NodeType)) {
		query["NodeType"] = request.NodeType
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PromotionCode)) {
		query["PromotionCode"] = request.PromotionCode
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.Resource)) {
		query["Resource"] = request.Resource
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ZoneId)) {
		query["ZoneId"] = request.ZoneId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateOrderForCreateDBNodes"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateOrderForCreateDBNodesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * MySQL
 * ### [](#)References
 * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * [Add a node to an ApsaraDB RDS for MySQL cluster](~~464129~~)
 *
 * @param request CreateOrderForCreateDBNodesRequest
 * @return CreateOrderForCreateDBNodesResponse
 */
func (client *Client) CreateOrderForCreateDBNodes(request *CreateOrderForCreateDBNodesRequest) (_result *CreateOrderForCreateDBNodesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateOrderForCreateDBNodesResponse{}
	_body, _err := client.CreateOrderForCreateDBNodesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * MySQL
 * ### [](#)References
 * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * [Delete a node from an ApsaraDB RDS for MySQL instance that runs RDS Cluster Edition](~~464130~~)
 *
 * @param tmpReq CreateOrderForDeleteDBNodesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateOrderForDeleteDBNodesResponse
 */
func (client *Client) CreateOrderForDeleteDBNodesWithOptions(tmpReq *CreateOrderForDeleteDBNodesRequest, runtime *util.RuntimeOptions) (_result *CreateOrderForDeleteDBNodesResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &CreateOrderForDeleteDBNodesShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.DBNodeId)) {
		request.DBNodeIdShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.DBNodeId, tea.String("DBNodeId"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AutoPay)) {
		query["AutoPay"] = request.AutoPay
	}

	if !tea.BoolValue(util.IsUnset(request.BusinessInfo)) {
		query["BusinessInfo"] = request.BusinessInfo
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.CommodityCode)) {
		query["CommodityCode"] = request.CommodityCode
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.DBNodeIdShrink)) {
		query["DBNodeId"] = request.DBNodeIdShrink
	}

	if !tea.BoolValue(util.IsUnset(request.EngineVersion)) {
		query["EngineVersion"] = request.EngineVersion
	}

	if !tea.BoolValue(util.IsUnset(request.NodeType)) {
		query["NodeType"] = request.NodeType
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PromotionCode)) {
		query["PromotionCode"] = request.PromotionCode
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.Resource)) {
		query["Resource"] = request.Resource
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ZoneId)) {
		query["ZoneId"] = request.ZoneId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateOrderForDeleteDBNodes"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateOrderForDeleteDBNodesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * MySQL
 * ### [](#)References
 * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * [Delete a node from an ApsaraDB RDS for MySQL instance that runs RDS Cluster Edition](~~464130~~)
 *
 * @param request CreateOrderForDeleteDBNodesRequest
 * @return CreateOrderForDeleteDBNodesResponse
 */
func (client *Client) CreateOrderForDeleteDBNodes(request *CreateOrderForDeleteDBNodesRequest) (_result *CreateOrderForDeleteDBNodesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateOrderForDeleteDBNodesResponse{}
	_body, _err := client.CreateOrderForDeleteDBNodesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * ### [](#)References
 * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * *   [Use a parameter template to configure the parameters of ApsaraDB RDS for MySQL instances](~~130565~~)
 * *   [Use a parameter template to configure the parameters of ApsaraDB RDS for PostgreSQL instances](~~457176~~)
 *
 * @param request CreateParameterGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateParameterGroupResponse
 */
func (client *Client) CreateParameterGroupWithOptions(request *CreateParameterGroupRequest, runtime *util.RuntimeOptions) (_result *CreateParameterGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Engine)) {
		query["Engine"] = request.Engine
	}

	if !tea.BoolValue(util.IsUnset(request.EngineVersion)) {
		query["EngineVersion"] = request.EngineVersion
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ParameterGroupDesc)) {
		query["ParameterGroupDesc"] = request.ParameterGroupDesc
	}

	if !tea.BoolValue(util.IsUnset(request.ParameterGroupName)) {
		query["ParameterGroupName"] = request.ParameterGroupName
	}

	if !tea.BoolValue(util.IsUnset(request.Parameters)) {
		query["Parameters"] = request.Parameters
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateParameterGroup"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateParameterGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * ### [](#)References
 * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * *   [Use a parameter template to configure the parameters of ApsaraDB RDS for MySQL instances](~~130565~~)
 * *   [Use a parameter template to configure the parameters of ApsaraDB RDS for PostgreSQL instances](~~457176~~)
 *
 * @param request CreateParameterGroupRequest
 * @return CreateParameterGroupResponse
 */
func (client *Client) CreateParameterGroup(request *CreateParameterGroupRequest) (_result *CreateParameterGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateParameterGroupResponse{}
	_body, _err := client.CreateParameterGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * RDS PostgreSQL
 * ### [](#)References
 * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * [Manage extensions](~~2402409~~)
 * ### [](#)Precautions
 * Install only the plug-ins that are supported by the major engine version of the instance. Otherwise, the installation fails.
 * *   For more information, see [Extensions supported by ApsaraDB RDS for PostgreSQL](~~142340~~).
 * *   You can call the [DescribeDBInstanceAttribute](~~610394~~) operation to query the major engine version of an instance.
 *
 * @param request CreatePostgresExtensionsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreatePostgresExtensionsResponse
 */
func (client *Client) CreatePostgresExtensionsWithOptions(request *CreatePostgresExtensionsRequest, runtime *util.RuntimeOptions) (_result *CreatePostgresExtensionsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AccountName)) {
		query["AccountName"] = request.AccountName
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.DBNames)) {
		query["DBNames"] = request.DBNames
	}

	if !tea.BoolValue(util.IsUnset(request.Extensions)) {
		query["Extensions"] = request.Extensions
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SourceDatabase)) {
		query["SourceDatabase"] = request.SourceDatabase
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreatePostgresExtensions"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreatePostgresExtensionsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * RDS PostgreSQL
 * ### [](#)References
 * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * [Manage extensions](~~2402409~~)
 * ### [](#)Precautions
 * Install only the plug-ins that are supported by the major engine version of the instance. Otherwise, the installation fails.
 * *   For more information, see [Extensions supported by ApsaraDB RDS for PostgreSQL](~~142340~~).
 * *   You can call the [DescribeDBInstanceAttribute](~~610394~~) operation to query the major engine version of an instance.
 *
 * @param request CreatePostgresExtensionsRequest
 * @return CreatePostgresExtensionsResponse
 */
func (client *Client) CreatePostgresExtensions(request *CreatePostgresExtensionsRequest) (_result *CreatePostgresExtensionsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreatePostgresExtensionsResponse{}
	_body, _err := client.CreatePostgresExtensionsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * ### References
 * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
 * *   [Create a read-only ApsaraDB RDS for MySQL instance](~~56991~~)
 * *   [Create a read-only ApsaraDB RDS for PostgreSQL instance](~~108959~~)
 * *   [Create a read-only ApsaraDB RDS for SQL Server instance](~~99005~~)
 *
 * @param request CreateReadOnlyDBInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateReadOnlyDBInstanceResponse
 */
func (client *Client) CreateReadOnlyDBInstanceWithOptions(request *CreateReadOnlyDBInstanceRequest, runtime *util.RuntimeOptions) (_result *CreateReadOnlyDBInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AutoPay)) {
		query["AutoPay"] = request.AutoPay
	}

	if !tea.BoolValue(util.IsUnset(request.AutoRenew)) {
		query["AutoRenew"] = request.AutoRenew
	}

	if !tea.BoolValue(util.IsUnset(request.BpeEnabled)) {
		query["BpeEnabled"] = request.BpeEnabled
	}

	if !tea.BoolValue(util.IsUnset(request.BurstingEnabled)) {
		query["BurstingEnabled"] = request.BurstingEnabled
	}

	if !tea.BoolValue(util.IsUnset(request.Category)) {
		query["Category"] = request.Category
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceClass)) {
		query["DBInstanceClass"] = request.DBInstanceClass
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceDescription)) {
		query["DBInstanceDescription"] = request.DBInstanceDescription
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceStorage)) {
		query["DBInstanceStorage"] = request.DBInstanceStorage
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceStorageType)) {
		query["DBInstanceStorageType"] = request.DBInstanceStorageType
	}

	if !tea.BoolValue(util.IsUnset(request.DedicatedHostGroupId)) {
		query["DedicatedHostGroupId"] = request.DedicatedHostGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.DeletionProtection)) {
		query["DeletionProtection"] = request.DeletionProtection
	}

	if !tea.BoolValue(util.IsUnset(request.EngineVersion)) {
		query["EngineVersion"] = request.EngineVersion
	}

	if !tea.BoolValue(util.IsUnset(request.GdnInstanceName)) {
		query["GdnInstanceName"] = request.GdnInstanceName
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceNetworkType)) {
		query["InstanceNetworkType"] = request.InstanceNetworkType
	}

	if !tea.BoolValue(util.IsUnset(request.InstructionSetArch)) {
		query["InstructionSetArch"] = request.InstructionSetArch
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PayType)) {
		query["PayType"] = request.PayType
	}

	if !tea.BoolValue(util.IsUnset(request.Period)) {
		query["Period"] = request.Period
	}

	if !tea.BoolValue(util.IsUnset(request.Port)) {
		query["Port"] = request.Port
	}

	if !tea.BoolValue(util.IsUnset(request.PrivateIpAddress)) {
		query["PrivateIpAddress"] = request.PrivateIpAddress
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.TargetDedicatedHostIdForMaster)) {
		query["TargetDedicatedHostIdForMaster"] = request.TargetDedicatedHostIdForMaster
	}

	if !tea.BoolValue(util.IsUnset(request.TddlBizType)) {
		query["TddlBizType"] = request.TddlBizType
	}

	if !tea.BoolValue(util.IsUnset(request.TddlRegionConfig)) {
		query["TddlRegionConfig"] = request.TddlRegionConfig
	}

	if !tea.BoolValue(util.IsUnset(request.UsedTime)) {
		query["UsedTime"] = request.UsedTime
	}

	if !tea.BoolValue(util.IsUnset(request.VPCId)) {
		query["VPCId"] = request.VPCId
	}

	if !tea.BoolValue(util.IsUnset(request.VSwitchId)) {
		query["VSwitchId"] = request.VSwitchId
	}

	if !tea.BoolValue(util.IsUnset(request.ZoneId)) {
		query["ZoneId"] = request.ZoneId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateReadOnlyDBInstance"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateReadOnlyDBInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * ### References
 * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
 * *   [Create a read-only ApsaraDB RDS for MySQL instance](~~56991~~)
 * *   [Create a read-only ApsaraDB RDS for PostgreSQL instance](~~108959~~)
 * *   [Create a read-only ApsaraDB RDS for SQL Server instance](~~99005~~)
 *
 * @param request CreateReadOnlyDBInstanceRequest
 * @return CreateReadOnlyDBInstanceResponse
 */
func (client *Client) CreateReadOnlyDBInstance(request *CreateReadOnlyDBInstanceRequest) (_result *CreateReadOnlyDBInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateReadOnlyDBInstanceResponse{}
	_body, _err := client.CreateReadOnlyDBInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateSecretWithOptions(request *CreateSecretRequest, runtime *util.RuntimeOptions) (_result *CreateSecretResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DbInstanceId)) {
		query["DbInstanceId"] = request.DbInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.DbNames)) {
		query["DbNames"] = request.DbNames
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.Engine)) {
		query["Engine"] = request.Engine
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Password)) {
		query["Password"] = request.Password
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecretName)) {
		query["SecretName"] = request.SecretName
	}

	if !tea.BoolValue(util.IsUnset(request.Username)) {
		query["Username"] = request.Username
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateSecret"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateSecretResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateSecret(request *CreateSecretRequest) (_result *CreateSecretResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateSecretResponse{}
	_body, _err := client.CreateSecretWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Supported database engine
 * PostgreSQL
 * ### References
 * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
 * [Service-linked roles](~~342840~~)
 *
 * @param request CreateServiceLinkedRoleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateServiceLinkedRoleResponse
 */
func (client *Client) CreateServiceLinkedRoleWithOptions(request *CreateServiceLinkedRoleRequest, runtime *util.RuntimeOptions) (_result *CreateServiceLinkedRoleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceLinkedRole)) {
		query["ServiceLinkedRole"] = request.ServiceLinkedRole
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateServiceLinkedRole"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateServiceLinkedRoleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Supported database engine
 * PostgreSQL
 * ### References
 * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
 * [Service-linked roles](~~342840~~)
 *
 * @param request CreateServiceLinkedRoleRequest
 * @return CreateServiceLinkedRoleResponse
 */
func (client *Client) CreateServiceLinkedRole(request *CreateServiceLinkedRoleRequest) (_result *CreateServiceLinkedRoleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateServiceLinkedRoleResponse{}
	_body, _err := client.CreateServiceLinkedRoleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * Your RDS instance runs SQL Server 2008 R2 with local disks.
 * ### [](#)Description
 * You can create a temporary instance based on a backup set or a point in time within the past seven days. Before you call this operation, make sure that the following requirements are met:
 * *   Your instance runs SQL Server 2008 R2 with local disks.
 * *   Your instance is in the Running state.
 * *   Your instance does not have ongoing migration tasks.
 * *   The last creation of a backup file is complete.
 * >  After a temporary instance is created, the temporary instance inherits the accounts and databases in the backup set.
 *
 * @param request CreateTempDBInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateTempDBInstanceResponse
 */
func (client *Client) CreateTempDBInstanceWithOptions(request *CreateTempDBInstanceRequest, runtime *util.RuntimeOptions) (_result *CreateTempDBInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BackupId)) {
		query["BackupId"] = request.BackupId
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RestoreTime)) {
		query["RestoreTime"] = request.RestoreTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateTempDBInstance"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateTempDBInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * Your RDS instance runs SQL Server 2008 R2 with local disks.
 * ### [](#)Description
 * You can create a temporary instance based on a backup set or a point in time within the past seven days. Before you call this operation, make sure that the following requirements are met:
 * *   Your instance runs SQL Server 2008 R2 with local disks.
 * *   Your instance is in the Running state.
 * *   Your instance does not have ongoing migration tasks.
 * *   The last creation of a backup file is complete.
 * >  After a temporary instance is created, the temporary instance inherits the accounts and databases in the backup set.
 *
 * @param request CreateTempDBInstanceRequest
 * @return CreateTempDBInstanceResponse
 */
func (client *Client) CreateTempDBInstance(request *CreateTempDBInstanceRequest) (_result *CreateTempDBInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateTempDBInstanceResponse{}
	_body, _err := client.CreateTempDBInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateYouhuiForOrderWithOptions(request *CreateYouhuiForOrderRequest, runtime *util.RuntimeOptions) (_result *CreateYouhuiForOrderResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ActivityId)) {
		query["ActivityId"] = request.ActivityId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PromotionId)) {
		query["PromotionId"] = request.PromotionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateYouhuiForOrder"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateYouhuiForOrderResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateYouhuiForOrder(request *CreateYouhuiForOrderRequest) (_result *CreateYouhuiForOrderResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateYouhuiForOrderResponse{}
	_body, _err := client.CreateYouhuiForOrderWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   SQL Server
 *
 * @param request DeleteADSettingRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteADSettingResponse
 */
func (client *Client) DeleteADSettingWithOptions(request *DeleteADSettingRequest, runtime *util.RuntimeOptions) (_result *DeleteADSettingResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteADSetting"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteADSettingResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   SQL Server
 *
 * @param request DeleteADSettingRequest
 * @return DeleteADSettingResponse
 */
func (client *Client) DeleteADSetting(request *DeleteADSettingRequest) (_result *DeleteADSettingResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteADSettingResponse{}
	_body, _err := client.DeleteADSettingWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 * ### References
 * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
 * *   [Delete a database account from an ApsaraDB RDS for MySQL instance](~~96104~~)
 * *   [Delete a database account from an ApsaraDB RDS for PostgreSQL instance](~~147649~~)
 * *   [Delete a database account from an ApsaraDB RDS for SQL Server instance](~~95694~~)
 * *   [Delete a database account from an ApsaraDB RDS for MariaDB instance](~~97135~~)
 *
 * @param request DeleteAccountRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteAccountResponse
 */
func (client *Client) DeleteAccountWithOptions(request *DeleteAccountRequest, runtime *util.RuntimeOptions) (_result *DeleteAccountResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AccountName)) {
		query["AccountName"] = request.AccountName
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteAccount"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteAccountResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 * ### References
 * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
 * *   [Delete a database account from an ApsaraDB RDS for MySQL instance](~~96104~~)
 * *   [Delete a database account from an ApsaraDB RDS for PostgreSQL instance](~~147649~~)
 * *   [Delete a database account from an ApsaraDB RDS for SQL Server instance](~~95694~~)
 * *   [Delete a database account from an ApsaraDB RDS for MariaDB instance](~~97135~~)
 *
 * @param request DeleteAccountRequest
 * @return DeleteAccountResponse
 */
func (client *Client) DeleteAccount(request *DeleteAccountRequest) (_result *DeleteAccountResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteAccountResponse{}
	_body, _err := client.DeleteAccountWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * > Only instances that run RDS High-availability Edition are supported.
 * ### Description
 * You can call this operation to delete backup sets of the instance itself. Backup sets of the associated instances such as read-only, disaster recovery, and cloned instances are not deleted.
 * ### Precautions
 * Before you call this operation, make sure that the following requirements are met:
 * *   The instance is in the Running state.
 * *   If the log backup feature is disabled, instances cannot be restored by point in time. You can delete data backup sets that are retained for more than seven days.
 * *   If the log backup feature is enabled and the log backup retention period is shorter than the data backup retention period, you can delete the data backup files that are retained for a period longer than the log backup retention period.
 *
 * @param request DeleteBackupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteBackupResponse
 */
func (client *Client) DeleteBackupWithOptions(request *DeleteBackupRequest, runtime *util.RuntimeOptions) (_result *DeleteBackupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BackupId)) {
		query["BackupId"] = request.BackupId
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteBackup"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteBackupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * > Only instances that run RDS High-availability Edition are supported.
 * ### Description
 * You can call this operation to delete backup sets of the instance itself. Backup sets of the associated instances such as read-only, disaster recovery, and cloned instances are not deleted.
 * ### Precautions
 * Before you call this operation, make sure that the following requirements are met:
 * *   The instance is in the Running state.
 * *   If the log backup feature is disabled, instances cannot be restored by point in time. You can delete data backup sets that are retained for more than seven days.
 * *   If the log backup feature is enabled and the log backup retention period is shorter than the data backup retention period, you can delete the data backup files that are retained for a period longer than the log backup retention period.
 *
 * @param request DeleteBackupRequest
 * @return DeleteBackupResponse
 */
func (client *Client) DeleteBackup(request *DeleteBackupRequest) (_result *DeleteBackupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteBackupResponse{}
	_body, _err := client.DeleteBackupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Supported database engine
 * SQL Server
 * ### Usage notes
 * This operation is available for users whose accounts are added to the whitelist. If your account is not added to the whitelist, you can join the Database Backup (DBS) DingTalk group whose ID is 35585947 and contact the on-duty engineer to add your account to the whitelist.
 *
 * @param request DeleteBackupFileRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteBackupFileResponse
 */
func (client *Client) DeleteBackupFileWithOptions(request *DeleteBackupFileRequest, runtime *util.RuntimeOptions) (_result *DeleteBackupFileResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BackupId)) {
		query["BackupId"] = request.BackupId
	}

	if !tea.BoolValue(util.IsUnset(request.BackupTime)) {
		query["BackupTime"] = request.BackupTime
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.DBName)) {
		query["DBName"] = request.DBName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteBackupFile"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteBackupFileResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Supported database engine
 * SQL Server
 * ### Usage notes
 * This operation is available for users whose accounts are added to the whitelist. If your account is not added to the whitelist, you can join the Database Backup (DBS) DingTalk group whose ID is 35585947 and contact the on-duty engineer to add your account to the whitelist.
 *
 * @param request DeleteBackupFileRequest
 * @return DeleteBackupFileResponse
 */
func (client *Client) DeleteBackupFile(request *DeleteBackupFileRequest) (_result *DeleteBackupFileResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteBackupFileResponse{}
	_body, _err := client.DeleteBackupFileWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 * ### References
 * > Note Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
 * *   [Release an ApsaraDB RDS for MySQL instance](~~96057~~)
 * *   [Release an ApsaraDB RDS for PostgreSQL instance](~~96749~~)
 * *   [Release an ApsaraDB RDS for SQL Server instance](~~95662~~)
 * *   [Release an ApsaraDB RDS for MariaDB instance](~~97128~~)
 *
 * @param request DeleteDBInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteDBInstanceResponse
 */
func (client *Client) DeleteDBInstanceWithOptions(request *DeleteDBInstanceRequest, runtime *util.RuntimeOptions) (_result *DeleteDBInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ReleasedKeepPolicy)) {
		query["ReleasedKeepPolicy"] = request.ReleasedKeepPolicy
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteDBInstance"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteDBInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 * ### References
 * > Note Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
 * *   [Release an ApsaraDB RDS for MySQL instance](~~96057~~)
 * *   [Release an ApsaraDB RDS for PostgreSQL instance](~~96749~~)
 * *   [Release an ApsaraDB RDS for SQL Server instance](~~95662~~)
 * *   [Release an ApsaraDB RDS for MariaDB instance](~~97128~~)
 *
 * @param request DeleteDBInstanceRequest
 * @return DeleteDBInstanceResponse
 */
func (client *Client) DeleteDBInstance(request *DeleteDBInstanceRequest) (_result *DeleteDBInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteDBInstanceResponse{}
	_body, _err := client.DeleteDBInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Supported database engine
 * MySQL
 * ### References
 * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
 * [Delete the read-only endpoint of an ApsaraDB RDS for MySQL cluster](~~464133~~)
 *
 * @param request DeleteDBInstanceEndpointRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteDBInstanceEndpointResponse
 */
func (client *Client) DeleteDBInstanceEndpointWithOptions(request *DeleteDBInstanceEndpointRequest, runtime *util.RuntimeOptions) (_result *DeleteDBInstanceEndpointResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceEndpointId)) {
		query["DBInstanceEndpointId"] = request.DBInstanceEndpointId
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteDBInstanceEndpoint"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteDBInstanceEndpointResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Supported database engine
 * MySQL
 * ### References
 * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
 * [Delete the read-only endpoint of an ApsaraDB RDS for MySQL cluster](~~464133~~)
 *
 * @param request DeleteDBInstanceEndpointRequest
 * @return DeleteDBInstanceEndpointResponse
 */
func (client *Client) DeleteDBInstanceEndpoint(request *DeleteDBInstanceEndpointRequest) (_result *DeleteDBInstanceEndpointResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteDBInstanceEndpointResponse{}
	_body, _err := client.DeleteDBInstanceEndpointWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Supported database engine
 * MySQL
 * ### Precautions
 * You can delete only the public endpoint of each endpoint type from the instance. If you want to delete an internal endpoint of any endpoint type, you can delete the type of endpoint.
 *
 * @param request DeleteDBInstanceEndpointAddressRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteDBInstanceEndpointAddressResponse
 */
func (client *Client) DeleteDBInstanceEndpointAddressWithOptions(request *DeleteDBInstanceEndpointAddressRequest, runtime *util.RuntimeOptions) (_result *DeleteDBInstanceEndpointAddressResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ConnectionString)) {
		body["ConnectionString"] = request.ConnectionString
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceEndpointId)) {
		body["DBInstanceEndpointId"] = request.DBInstanceEndpointId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
		Body:  openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteDBInstanceEndpointAddress"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteDBInstanceEndpointAddressResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Supported database engine
 * MySQL
 * ### Precautions
 * You can delete only the public endpoint of each endpoint type from the instance. If you want to delete an internal endpoint of any endpoint type, you can delete the type of endpoint.
 *
 * @param request DeleteDBInstanceEndpointAddressRequest
 * @return DeleteDBInstanceEndpointAddressResponse
 */
func (client *Client) DeleteDBInstanceEndpointAddress(request *DeleteDBInstanceEndpointAddressRequest) (_result *DeleteDBInstanceEndpointAddressResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteDBInstanceEndpointAddressResponse{}
	_body, _err := client.DeleteDBInstanceEndpointAddressWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Supported database engine
 * MySQL
 * ### References
 * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
 * [Delete a node from an ApsaraDB RDS for MySQL instance that runs RDS Cluster Edition](~~464130~~)
 *
 * @param tmpReq DeleteDBNodesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteDBNodesResponse
 */
func (client *Client) DeleteDBNodesWithOptions(tmpReq *DeleteDBNodesRequest, runtime *util.RuntimeOptions) (_result *DeleteDBNodesResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &DeleteDBNodesShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.DBNodeId)) {
		request.DBNodeIdShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.DBNodeId, tea.String("DBNodeId"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.DBNodeIdShrink)) {
		query["DBNodeId"] = request.DBNodeIdShrink
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteDBNodes"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteDBNodesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Supported database engine
 * MySQL
 * ### References
 * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
 * [Delete a node from an ApsaraDB RDS for MySQL instance that runs RDS Cluster Edition](~~464130~~)
 *
 * @param request DeleteDBNodesRequest
 * @return DeleteDBNodesResponse
 */
func (client *Client) DeleteDBNodes(request *DeleteDBNodesRequest) (_result *DeleteDBNodesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteDBNodesResponse{}
	_body, _err := client.DeleteDBNodesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * ### References
 * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * *   [Configure the dedicated proxy endpoint of an ApsaraDB RDS for MySQL instance](~~184921~~)
 * *   [Configure the dedicated proxy endpoint for an ApsaraDB RDS for PostgreSQL instance](~~418274~~)
 *
 * @param request DeleteDBProxyEndpointAddressRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteDBProxyEndpointAddressResponse
 */
func (client *Client) DeleteDBProxyEndpointAddressWithOptions(request *DeleteDBProxyEndpointAddressRequest, runtime *util.RuntimeOptions) (_result *DeleteDBProxyEndpointAddressResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.DBProxyConnectStringNetType)) {
		query["DBProxyConnectStringNetType"] = request.DBProxyConnectStringNetType
	}

	if !tea.BoolValue(util.IsUnset(request.DBProxyEndpointId)) {
		query["DBProxyEndpointId"] = request.DBProxyEndpointId
	}

	if !tea.BoolValue(util.IsUnset(request.DBProxyEngineType)) {
		query["DBProxyEngineType"] = request.DBProxyEngineType
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteDBProxyEndpointAddress"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteDBProxyEndpointAddressResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * ### References
 * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * *   [Configure the dedicated proxy endpoint of an ApsaraDB RDS for MySQL instance](~~184921~~)
 * *   [Configure the dedicated proxy endpoint for an ApsaraDB RDS for PostgreSQL instance](~~418274~~)
 *
 * @param request DeleteDBProxyEndpointAddressRequest
 * @return DeleteDBProxyEndpointAddressResponse
 */
func (client *Client) DeleteDBProxyEndpointAddress(request *DeleteDBProxyEndpointAddressRequest) (_result *DeleteDBProxyEndpointAddressResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteDBProxyEndpointAddressResponse{}
	_body, _err := client.DeleteDBProxyEndpointAddressWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   RDS MySQL
 * *   RDS PostgreSQL
 * *   RDS SQL Server
 * *   RDS MariaDB
 * ### [](#)References
 * > : Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
 * *   [Delete a database from an ApsaraDB RDS for MySQL instance](~~96106~~)
 * *   [Delete a database from an ApsaraDB RDS for PostgreSQL instance](~~96759~~)
 * *   [Delete a database from an ApsaraDB RDS for SQL Server instance](~~95699~~)
 * *   [Delete a database from an ApsaraDB RDS for MariaDB instance](~~97137~~)
 *
 * @param request DeleteDatabaseRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteDatabaseResponse
 */
func (client *Client) DeleteDatabaseWithOptions(request *DeleteDatabaseRequest, runtime *util.RuntimeOptions) (_result *DeleteDatabaseResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.DBName)) {
		query["DBName"] = request.DBName
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteDatabase"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteDatabaseResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   RDS MySQL
 * *   RDS PostgreSQL
 * *   RDS SQL Server
 * *   RDS MariaDB
 * ### [](#)References
 * > : Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
 * *   [Delete a database from an ApsaraDB RDS for MySQL instance](~~96106~~)
 * *   [Delete a database from an ApsaraDB RDS for PostgreSQL instance](~~96759~~)
 * *   [Delete a database from an ApsaraDB RDS for SQL Server instance](~~95699~~)
 * *   [Delete a database from an ApsaraDB RDS for MariaDB instance](~~97137~~)
 *
 * @param request DeleteDatabaseRequest
 * @return DeleteDatabaseResponse
 */
func (client *Client) DeleteDatabase(request *DeleteDatabaseRequest) (_result *DeleteDatabaseResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteDatabaseResponse{}
	_body, _err := client.DeleteDatabaseWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * ### [Usage notes](#)
 * *   A global active database cluster cannot be restored after it is deleted. Proceed with caution.
 * *   If you delete a global active database cluster, the system removes all nodes and Data Transmission Service (DTS) synchronization tasks from the cluster. However, the system does not release the ApsaraDB RDS for MySQL instances that run as nodes in the cluster. If you no longer need the ApsaraDB RDS for MySQL instances, you can call the [DeleteDBInstance](~~26229~~) to release the instances one after another.
 *
 * @param request DeleteGadInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteGadInstanceResponse
 */
func (client *Client) DeleteGadInstanceWithOptions(request *DeleteGadInstanceRequest, runtime *util.RuntimeOptions) (_result *DeleteGadInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.GadInstanceName)) {
		query["GadInstanceName"] = request.GadInstanceName
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteGadInstance"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteGadInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * ### [Usage notes](#)
 * *   A global active database cluster cannot be restored after it is deleted. Proceed with caution.
 * *   If you delete a global active database cluster, the system removes all nodes and Data Transmission Service (DTS) synchronization tasks from the cluster. However, the system does not release the ApsaraDB RDS for MySQL instances that run as nodes in the cluster. If you no longer need the ApsaraDB RDS for MySQL instances, you can call the [DeleteDBInstance](~~26229~~) to release the instances one after another.
 *
 * @param request DeleteGadInstanceRequest
 * @return DeleteGadInstanceResponse
 */
func (client *Client) DeleteGadInstance(request *DeleteGadInstanceRequest) (_result *DeleteGadInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteGadInstanceResponse{}
	_body, _err := client.DeleteGadInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 * ### [](#)References
 * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * *   [Use a parameter template to configure the parameters of ApsaraDB RDS for MySQL instances](~~130565~~)
 * *   [Use a parameter template to configure the parameters of ApsaraDB RDS for PostgreSQL instances](~~457176~~)
 *
 * @param request DeleteParameterGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteParameterGroupResponse
 */
func (client *Client) DeleteParameterGroupWithOptions(request *DeleteParameterGroupRequest, runtime *util.RuntimeOptions) (_result *DeleteParameterGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ParameterGroupId)) {
		query["ParameterGroupId"] = request.ParameterGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteParameterGroup"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteParameterGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 * ### [](#)References
 * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * *   [Use a parameter template to configure the parameters of ApsaraDB RDS for MySQL instances](~~130565~~)
 * *   [Use a parameter template to configure the parameters of ApsaraDB RDS for PostgreSQL instances](~~457176~~)
 *
 * @param request DeleteParameterGroupRequest
 * @return DeleteParameterGroupResponse
 */
func (client *Client) DeleteParameterGroup(request *DeleteParameterGroupRequest) (_result *DeleteParameterGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteParameterGroupResponse{}
	_body, _err := client.DeleteParameterGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Supported database engines
 * RDS PostgreSQL
 * ### References
 * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * [Manage extensions](~~2402409~~)
 *
 * @param request DeletePostgresExtensionsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeletePostgresExtensionsResponse
 */
func (client *Client) DeletePostgresExtensionsWithOptions(request *DeletePostgresExtensionsRequest, runtime *util.RuntimeOptions) (_result *DeletePostgresExtensionsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.DBNames)) {
		query["DBNames"] = request.DBNames
	}

	if !tea.BoolValue(util.IsUnset(request.Extensions)) {
		query["Extensions"] = request.Extensions
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeletePostgresExtensions"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeletePostgresExtensionsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Supported database engines
 * RDS PostgreSQL
 * ### References
 * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * [Manage extensions](~~2402409~~)
 *
 * @param request DeletePostgresExtensionsRequest
 * @return DeletePostgresExtensionsResponse
 */
func (client *Client) DeletePostgresExtensions(request *DeletePostgresExtensionsRequest) (_result *DeletePostgresExtensionsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeletePostgresExtensionsResponse{}
	_body, _err := client.DeletePostgresExtensionsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteSecretWithOptions(request *DeleteSecretRequest, runtime *util.RuntimeOptions) (_result *DeleteSecretResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DbInstanceId)) {
		query["DbInstanceId"] = request.DbInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Engine)) {
		query["Engine"] = request.Engine
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecretArn)) {
		query["SecretArn"] = request.SecretArn
	}

	if !tea.BoolValue(util.IsUnset(request.SecretName)) {
		query["SecretName"] = request.SecretName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteSecret"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteSecretResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteSecret(request *DeleteSecretRequest) (_result *DeleteSecretResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteSecretResponse{}
	_body, _err := client.DeleteSecretWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engine
 * *   PostgreSQL
 * ### [](#)Precautions
 * You can delete a replication slot only when the status of the slot is **INACTIVE**. You can call the DescribeSlots operation to query the status of a replication slot.
 *
 * @param request DeleteSlotRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteSlotResponse
 */
func (client *Client) DeleteSlotWithOptions(request *DeleteSlotRequest, runtime *util.RuntimeOptions) (_result *DeleteSlotResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SlotName)) {
		query["SlotName"] = request.SlotName
	}

	if !tea.BoolValue(util.IsUnset(request.SlotStatus)) {
		query["SlotStatus"] = request.SlotStatus
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteSlot"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteSlotResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engine
 * *   PostgreSQL
 * ### [](#)Precautions
 * You can delete a replication slot only when the status of the slot is **INACTIVE**. You can call the DescribeSlots operation to query the status of a replication slot.
 *
 * @param request DeleteSlotRequest
 * @return DeleteSlotResponse
 */
func (client *Client) DeleteSlot(request *DeleteSlotRequest) (_result *DeleteSlotResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteSlotResponse{}
	_body, _err := client.DeleteSlotWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * ### [](#)Description
 * *   A full backup file contains the data of a self-managed MySQL instance. You can restore the data of a self-managed MySQL instance from a full backup file to an ApsaraDB RDS for MySQL instance. For more information, see [Migrate the data of a self-managed MySQL 5.7 instance to the cloud](~~251779~~).
 * *   This operation deletes full backup files only from the ApsaraDB RDS console. This operation does not affect the full backup files that are stored as objects in Object Storage Service (OSS) buckets. After you call this operation to delete a full backup file, you can call the [ImportUserBackupFile](~~260266~~) operation to import the full backup file again.
 *
 * @param request DeleteUserBackupFileRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteUserBackupFileResponse
 */
func (client *Client) DeleteUserBackupFileWithOptions(request *DeleteUserBackupFileRequest, runtime *util.RuntimeOptions) (_result *DeleteUserBackupFileResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BackupId)) {
		query["BackupId"] = request.BackupId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteUserBackupFile"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteUserBackupFileResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * ### [](#)Description
 * *   A full backup file contains the data of a self-managed MySQL instance. You can restore the data of a self-managed MySQL instance from a full backup file to an ApsaraDB RDS for MySQL instance. For more information, see [Migrate the data of a self-managed MySQL 5.7 instance to the cloud](~~251779~~).
 * *   This operation deletes full backup files only from the ApsaraDB RDS console. This operation does not affect the full backup files that are stored as objects in Object Storage Service (OSS) buckets. After you call this operation to delete a full backup file, you can call the [ImportUserBackupFile](~~260266~~) operation to import the full backup file again.
 *
 * @param request DeleteUserBackupFileRequest
 * @return DeleteUserBackupFileResponse
 */
func (client *Client) DeleteUserBackupFile(request *DeleteUserBackupFileRequest) (_result *DeleteUserBackupFileResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteUserBackupFileResponse{}
	_body, _err := client.DeleteUserBackupFileWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * MySQL
 * ### [](#)References
 * [Migrate data between ApsaraDB RDS for MySQL instances](~~96154~~)
 *
 * @param request DescibeImportsFromDatabaseRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescibeImportsFromDatabaseResponse
 */
func (client *Client) DescibeImportsFromDatabaseWithOptions(request *DescibeImportsFromDatabaseRequest, runtime *util.RuntimeOptions) (_result *DescibeImportsFromDatabaseResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.Engine)) {
		query["Engine"] = request.Engine
	}

	if !tea.BoolValue(util.IsUnset(request.ImportId)) {
		query["ImportId"] = request.ImportId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescibeImportsFromDatabase"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescibeImportsFromDatabaseResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * MySQL
 * ### [](#)References
 * [Migrate data between ApsaraDB RDS for MySQL instances](~~96154~~)
 *
 * @param request DescibeImportsFromDatabaseRequest
 * @return DescibeImportsFromDatabaseResponse
 */
func (client *Client) DescibeImportsFromDatabase(request *DescibeImportsFromDatabaseRequest) (_result *DescibeImportsFromDatabaseResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescibeImportsFromDatabaseResponse{}
	_body, _err := client.DescibeImportsFromDatabaseWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   SQL Server
 *
 * @param request DescribeADInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeADInfoResponse
 */
func (client *Client) DescribeADInfoWithOptions(request *DescribeADInfoRequest, runtime *util.RuntimeOptions) (_result *DescribeADInfoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeADInfo"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeADInfoResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   SQL Server
 *
 * @param request DescribeADInfoRequest
 * @return DescribeADInfoResponse
 */
func (client *Client) DescribeADInfo(request *DescribeADInfoRequest) (_result *DescribeADInfoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeADInfoResponse{}
	_body, _err := client.DescribeADInfoWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   RDS MySQL
 * *   RDS PostgreSQL
 * *   RDS SQL Server
 * *   RDS MariaDB
 *
 * @param request DescribeAccountsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAccountsResponse
 */
func (client *Client) DescribeAccountsWithOptions(request *DescribeAccountsRequest, runtime *util.RuntimeOptions) (_result *DescribeAccountsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AccountName)) {
		query["AccountName"] = request.AccountName
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeAccounts"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeAccountsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   RDS MySQL
 * *   RDS PostgreSQL
 * *   RDS SQL Server
 * *   RDS MariaDB
 *
 * @param request DescribeAccountsRequest
 * @return DescribeAccountsResponse
 */
func (client *Client) DescribeAccounts(request *DescribeAccountsRequest) (_result *DescribeAccountsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeAccountsResponse{}
	_body, _err := client.DescribeAccountsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Supported database engines
 * *   RDS MySQL
 * *   RDS PostgreSQL
 * *   RDS SQL Server
 * *   RDS MariaDB
 *
 * @param request DescribeActionEventPolicyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeActionEventPolicyResponse
 */
func (client *Client) DescribeActionEventPolicyWithOptions(request *DescribeActionEventPolicyRequest, runtime *util.RuntimeOptions) (_result *DescribeActionEventPolicyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeActionEventPolicy"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeActionEventPolicyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Supported database engines
 * *   RDS MySQL
 * *   RDS PostgreSQL
 * *   RDS SQL Server
 * *   RDS MariaDB
 *
 * @param request DescribeActionEventPolicyRequest
 * @return DescribeActionEventPolicyResponse
 */
func (client *Client) DescribeActionEventPolicy(request *DescribeActionEventPolicyRequest) (_result *DescribeActionEventPolicyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeActionEventPolicyResponse{}
	_body, _err := client.DescribeActionEventPolicyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 *
 * @param request DescribeActiveOperationTasksRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeActiveOperationTasksResponse
 */
func (client *Client) DescribeActiveOperationTasksWithOptions(request *DescribeActiveOperationTasksRequest, runtime *util.RuntimeOptions) (_result *DescribeActiveOperationTasksResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AllowCancel)) {
		query["AllowCancel"] = request.AllowCancel
	}

	if !tea.BoolValue(util.IsUnset(request.AllowChange)) {
		query["AllowChange"] = request.AllowChange
	}

	if !tea.BoolValue(util.IsUnset(request.ChangeLevel)) {
		query["ChangeLevel"] = request.ChangeLevel
	}

	if !tea.BoolValue(util.IsUnset(request.DbType)) {
		query["DbType"] = request.DbType
	}

	if !tea.BoolValue(util.IsUnset(request.InsName)) {
		query["InsName"] = request.InsName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ProductId)) {
		query["ProductId"] = request.ProductId
	}

	if !tea.BoolValue(util.IsUnset(request.Region)) {
		query["Region"] = request.Region
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		query["Status"] = request.Status
	}

	if !tea.BoolValue(util.IsUnset(request.TaskType)) {
		query["TaskType"] = request.TaskType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeActiveOperationTasks"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeActiveOperationTasksResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 *
 * @param request DescribeActiveOperationTasksRequest
 * @return DescribeActiveOperationTasksResponse
 */
func (client *Client) DescribeActiveOperationTasks(request *DescribeActiveOperationTasksRequest) (_result *DescribeActiveOperationTasksResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeActiveOperationTasksResponse{}
	_body, _err := client.DescribeActiveOperationTasksWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Supported database engines
 * *   RDS MySQL
 * *   RDS PostgreSQL
 * *   RDS SQL Server
 *
 * @param request DescribeAllWhitelistTemplateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAllWhitelistTemplateResponse
 */
func (client *Client) DescribeAllWhitelistTemplateWithOptions(request *DescribeAllWhitelistTemplateRequest, runtime *util.RuntimeOptions) (_result *DescribeAllWhitelistTemplateResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.FuzzySearch)) {
		query["FuzzySearch"] = request.FuzzySearch
	}

	if !tea.BoolValue(util.IsUnset(request.MaxRecordsPerPage)) {
		query["MaxRecordsPerPage"] = request.MaxRecordsPerPage
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumbers)) {
		query["PageNumbers"] = request.PageNumbers
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.TemplateName)) {
		query["TemplateName"] = request.TemplateName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeAllWhitelistTemplate"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeAllWhitelistTemplateResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Supported database engines
 * *   RDS MySQL
 * *   RDS PostgreSQL
 * *   RDS SQL Server
 *
 * @param request DescribeAllWhitelistTemplateRequest
 * @return DescribeAllWhitelistTemplateResponse
 */
func (client *Client) DescribeAllWhitelistTemplate(request *DescribeAllWhitelistTemplateRequest) (_result *DescribeAllWhitelistTemplateResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeAllWhitelistTemplateResponse{}
	_body, _err := client.DescribeAllWhitelistTemplateWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeAnalyticdbByPrimaryDBInstanceWithOptions(request *DescribeAnalyticdbByPrimaryDBInstanceRequest, runtime *util.RuntimeOptions) (_result *DescribeAnalyticdbByPrimaryDBInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeAnalyticdbByPrimaryDBInstance"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeAnalyticdbByPrimaryDBInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeAnalyticdbByPrimaryDBInstance(request *DescribeAnalyticdbByPrimaryDBInstanceRequest) (_result *DescribeAnalyticdbByPrimaryDBInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeAnalyticdbByPrimaryDBInstanceResponse{}
	_body, _err := client.DescribeAnalyticdbByPrimaryDBInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 *
 * @param request DescribeAvailableClassesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAvailableClassesResponse
 */
func (client *Client) DescribeAvailableClassesWithOptions(request *DescribeAvailableClassesRequest, runtime *util.RuntimeOptions) (_result *DescribeAvailableClassesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Category)) {
		query["Category"] = request.Category
	}

	if !tea.BoolValue(util.IsUnset(request.CommodityCode)) {
		query["CommodityCode"] = request.CommodityCode
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceStorageType)) {
		query["DBInstanceStorageType"] = request.DBInstanceStorageType
	}

	if !tea.BoolValue(util.IsUnset(request.Engine)) {
		query["Engine"] = request.Engine
	}

	if !tea.BoolValue(util.IsUnset(request.EngineVersion)) {
		query["EngineVersion"] = request.EngineVersion
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceChargeType)) {
		query["InstanceChargeType"] = request.InstanceChargeType
	}

	if !tea.BoolValue(util.IsUnset(request.OrderType)) {
		query["OrderType"] = request.OrderType
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ZoneId)) {
		query["ZoneId"] = request.ZoneId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeAvailableClasses"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeAvailableClassesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 *
 * @param request DescribeAvailableClassesRequest
 * @return DescribeAvailableClassesResponse
 */
func (client *Client) DescribeAvailableClasses(request *DescribeAvailableClassesRequest) (_result *DescribeAvailableClassesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeAvailableClassesResponse{}
	_body, _err := client.DescribeAvailableClassesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * ### [](#)References
 * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * *   [Use the cross-region backup feature of an ApsaraDB RDS for MySQL instance](~~120824~~)
 * *   [Use the cross-region backup feature for an ApsaraDB RDS for PostgreSQL instance](~~206671~~)
 * *   [Use the cross-region backup feature for an ApsaraDB RDS for SQL Server instance](~~187923~~)
 *
 * @param request DescribeAvailableCrossRegionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAvailableCrossRegionResponse
 */
func (client *Client) DescribeAvailableCrossRegionWithOptions(request *DescribeAvailableCrossRegionRequest, runtime *util.RuntimeOptions) (_result *DescribeAvailableCrossRegionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeAvailableCrossRegion"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeAvailableCrossRegionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * ### [](#)References
 * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * *   [Use the cross-region backup feature of an ApsaraDB RDS for MySQL instance](~~120824~~)
 * *   [Use the cross-region backup feature for an ApsaraDB RDS for PostgreSQL instance](~~206671~~)
 * *   [Use the cross-region backup feature for an ApsaraDB RDS for SQL Server instance](~~187923~~)
 *
 * @param request DescribeAvailableCrossRegionRequest
 * @return DescribeAvailableCrossRegionResponse
 */
func (client *Client) DescribeAvailableCrossRegion(request *DescribeAvailableCrossRegionRequest) (_result *DescribeAvailableCrossRegionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeAvailableCrossRegionResponse{}
	_body, _err := client.DescribeAvailableCrossRegionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   PostgreSQL
 * ### [](#)References
 * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * [View the Enhanced Monitoring metrics](~~299200~~)
 *
 * @param request DescribeAvailableMetricsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAvailableMetricsResponse
 */
func (client *Client) DescribeAvailableMetricsWithOptions(request *DescribeAvailableMetricsRequest, runtime *util.RuntimeOptions) (_result *DescribeAvailableMetricsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceName)) {
		query["DBInstanceName"] = request.DBInstanceName
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeAvailableMetrics"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeAvailableMetricsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   PostgreSQL
 * ### [](#)References
 * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * [View the Enhanced Monitoring metrics](~~299200~~)
 *
 * @param request DescribeAvailableMetricsRequest
 * @return DescribeAvailableMetricsResponse
 */
func (client *Client) DescribeAvailableMetrics(request *DescribeAvailableMetricsRequest) (_result *DescribeAvailableMetricsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeAvailableMetricsResponse{}
	_body, _err := client.DescribeAvailableMetricsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * >  To view the time range within which you can restore data from a standard backup set, see [DescribeBackups](~~26273~~)
 * ### [](#)Supported database engines
 * MySQL
 * ### [](#)References
 * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * [Use the cross-region backup feature of an ApsaraDB RDS for MySQL instance](~~120824~~)
 *
 * @param request DescribeAvailableRecoveryTimeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAvailableRecoveryTimeResponse
 */
func (client *Client) DescribeAvailableRecoveryTimeWithOptions(request *DescribeAvailableRecoveryTimeRequest, runtime *util.RuntimeOptions) (_result *DescribeAvailableRecoveryTimeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CrossBackupId)) {
		query["CrossBackupId"] = request.CrossBackupId
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeAvailableRecoveryTime"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeAvailableRecoveryTimeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * >  To view the time range within which you can restore data from a standard backup set, see [DescribeBackups](~~26273~~)
 * ### [](#)Supported database engines
 * MySQL
 * ### [](#)References
 * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * [Use the cross-region backup feature of an ApsaraDB RDS for MySQL instance](~~120824~~)
 *
 * @param request DescribeAvailableRecoveryTimeRequest
 * @return DescribeAvailableRecoveryTimeResponse
 */
func (client *Client) DescribeAvailableRecoveryTime(request *DescribeAvailableRecoveryTimeRequest) (_result *DescribeAvailableRecoveryTimeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeAvailableRecoveryTimeResponse{}
	_body, _err := client.DescribeAvailableRecoveryTimeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 *
 * @param request DescribeAvailableZonesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAvailableZonesResponse
 */
func (client *Client) DescribeAvailableZonesWithOptions(request *DescribeAvailableZonesRequest, runtime *util.RuntimeOptions) (_result *DescribeAvailableZonesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Category)) {
		query["Category"] = request.Category
	}

	if !tea.BoolValue(util.IsUnset(request.CommodityCode)) {
		query["CommodityCode"] = request.CommodityCode
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceName)) {
		query["DBInstanceName"] = request.DBInstanceName
	}

	if !tea.BoolValue(util.IsUnset(request.DispenseMode)) {
		query["DispenseMode"] = request.DispenseMode
	}

	if !tea.BoolValue(util.IsUnset(request.Engine)) {
		query["Engine"] = request.Engine
	}

	if !tea.BoolValue(util.IsUnset(request.EngineVersion)) {
		query["EngineVersion"] = request.EngineVersion
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ZoneId)) {
		query["ZoneId"] = request.ZoneId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeAvailableZones"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeAvailableZonesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 *
 * @param request DescribeAvailableZonesRequest
 * @return DescribeAvailableZonesResponse
 */
func (client *Client) DescribeAvailableZones(request *DescribeAvailableZonesRequest) (_result *DescribeAvailableZonesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeAvailableZonesResponse{}
	_body, _err := client.DescribeAvailableZonesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > This operation is phased out.
 *
 * @param request DescribeBackupDatabaseRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeBackupDatabaseResponse
 */
func (client *Client) DescribeBackupDatabaseWithOptions(request *DescribeBackupDatabaseRequest, runtime *util.RuntimeOptions) (_result *DescribeBackupDatabaseResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BackupId)) {
		query["BackupId"] = request.BackupId
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeBackupDatabase"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeBackupDatabaseResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > This operation is phased out.
 *
 * @param request DescribeBackupDatabaseRequest
 * @return DescribeBackupDatabaseResponse
 */
func (client *Client) DescribeBackupDatabase(request *DescribeBackupDatabaseRequest) (_result *DescribeBackupDatabaseResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeBackupDatabaseResponse{}
	_body, _err := client.DescribeBackupDatabaseWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 *
 * @param request DescribeBackupPolicyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeBackupPolicyResponse
 */
func (client *Client) DescribeBackupPolicyWithOptions(request *DescribeBackupPolicyRequest, runtime *util.RuntimeOptions) (_result *DescribeBackupPolicyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BackupPolicyMode)) {
		query["BackupPolicyMode"] = request.BackupPolicyMode
	}

	if !tea.BoolValue(util.IsUnset(request.CompressType)) {
		query["CompressType"] = request.CompressType
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ReleasedKeepPolicy)) {
		query["ReleasedKeepPolicy"] = request.ReleasedKeepPolicy
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeBackupPolicy"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeBackupPolicyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 *
 * @param request DescribeBackupPolicyRequest
 * @return DescribeBackupPolicyResponse
 */
func (client *Client) DescribeBackupPolicy(request *DescribeBackupPolicyRequest) (_result *DescribeBackupPolicyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeBackupPolicyResponse{}
	_body, _err := client.DescribeBackupPolicyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   RDS MySQL
 * *   RDS PostgreSQL
 * *   RDS SQL Server
 * *   RDS MariaDB
 *
 * @param request DescribeBackupTasksRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeBackupTasksResponse
 */
func (client *Client) DescribeBackupTasksWithOptions(request *DescribeBackupTasksRequest, runtime *util.RuntimeOptions) (_result *DescribeBackupTasksResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BackupJobId)) {
		query["BackupJobId"] = request.BackupJobId
	}

	if !tea.BoolValue(util.IsUnset(request.BackupJobStatus)) {
		query["BackupJobStatus"] = request.BackupJobStatus
	}

	if !tea.BoolValue(util.IsUnset(request.BackupMode)) {
		query["BackupMode"] = request.BackupMode
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Flag)) {
		query["Flag"] = request.Flag
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeBackupTasks"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeBackupTasksResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   RDS MySQL
 * *   RDS PostgreSQL
 * *   RDS SQL Server
 * *   RDS MariaDB
 *
 * @param request DescribeBackupTasksRequest
 * @return DescribeBackupTasksResponse
 */
func (client *Client) DescribeBackupTasks(request *DescribeBackupTasksRequest) (_result *DescribeBackupTasksResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeBackupTasksResponse{}
	_body, _err := client.DescribeBackupTasksWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   RDS MySQL
 * *   RDS PostgreSQL
 * *   RDS SQL Server
 * *   RDS MariaDB
 *
 * @param request DescribeBackupsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeBackupsResponse
 */
func (client *Client) DescribeBackupsWithOptions(request *DescribeBackupsRequest, runtime *util.RuntimeOptions) (_result *DescribeBackupsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BackupId)) {
		query["BackupId"] = request.BackupId
	}

	if !tea.BoolValue(util.IsUnset(request.BackupMode)) {
		query["BackupMode"] = request.BackupMode
	}

	if !tea.BoolValue(util.IsUnset(request.BackupStatus)) {
		query["BackupStatus"] = request.BackupStatus
	}

	if !tea.BoolValue(util.IsUnset(request.BackupType)) {
		query["BackupType"] = request.BackupType
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeBackups"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeBackupsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   RDS MySQL
 * *   RDS PostgreSQL
 * *   RDS SQL Server
 * *   RDS MariaDB
 *
 * @param request DescribeBackupsRequest
 * @return DescribeBackupsResponse
 */
func (client *Client) DescribeBackups(request *DescribeBackupsRequest) (_result *DescribeBackupsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeBackupsResponse{}
	_body, _err := client.DescribeBackupsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   MariaDB
 * ### Usage notes
 * *   If the return value of the **DownloadLink** parameter is NULL, ApsaraDB RDS does not provide a download URL.
 * *   If the return value of the **DownloadLink** parameter is not NULL, ApsaraDB RDS provides a URL for you to download backup files. The expiration time of the URL is specified by the **LinkExpiredTime** parameter. You must download the backup files before the expiration time.
 * *   If you use a RAM user to download backup files, you must grant permissions to the RAM user. For more information, see [Grant backup file download permissions to a RAM user with read-only permissions](~~100043~~).
 * *   Each log file that is returned by this operation contains the log entries that are generated over the time range that is specified by the StartTime and EndTime parameters.
 *
 * @param request DescribeBinlogFilesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeBinlogFilesResponse
 */
func (client *Client) DescribeBinlogFilesWithOptions(request *DescribeBinlogFilesRequest, runtime *util.RuntimeOptions) (_result *DescribeBinlogFilesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeBinlogFiles"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeBinlogFilesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   MariaDB
 * ### Usage notes
 * *   If the return value of the **DownloadLink** parameter is NULL, ApsaraDB RDS does not provide a download URL.
 * *   If the return value of the **DownloadLink** parameter is not NULL, ApsaraDB RDS provides a URL for you to download backup files. The expiration time of the URL is specified by the **LinkExpiredTime** parameter. You must download the backup files before the expiration time.
 * *   If you use a RAM user to download backup files, you must grant permissions to the RAM user. For more information, see [Grant backup file download permissions to a RAM user with read-only permissions](~~100043~~).
 * *   Each log file that is returned by this operation contains the log entries that are generated over the time range that is specified by the StartTime and EndTime parameters.
 *
 * @param request DescribeBinlogFilesRequest
 * @return DescribeBinlogFilesResponse
 */
func (client *Client) DescribeBinlogFiles(request *DescribeBinlogFilesRequest) (_result *DescribeBinlogFilesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeBinlogFilesResponse{}
	_body, _err := client.DescribeBinlogFilesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 *
 * @param request DescribeCharacterSetNameRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCharacterSetNameResponse
 */
func (client *Client) DescribeCharacterSetNameWithOptions(request *DescribeCharacterSetNameRequest, runtime *util.RuntimeOptions) (_result *DescribeCharacterSetNameResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Engine)) {
		query["Engine"] = request.Engine
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeCharacterSetName"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeCharacterSetNameResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 *
 * @param request DescribeCharacterSetNameRequest
 * @return DescribeCharacterSetNameResponse
 */
func (client *Client) DescribeCharacterSetName(request *DescribeCharacterSetNameRequest) (_result *DescribeCharacterSetNameResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeCharacterSetNameResponse{}
	_body, _err := client.DescribeCharacterSetNameWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeClassDetailsWithOptions(request *DescribeClassDetailsRequest, runtime *util.RuntimeOptions) (_result *DescribeClassDetailsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClassCode)) {
		query["ClassCode"] = request.ClassCode
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.CommodityCode)) {
		query["CommodityCode"] = request.CommodityCode
	}

	if !tea.BoolValue(util.IsUnset(request.Engine)) {
		query["Engine"] = request.Engine
	}

	if !tea.BoolValue(util.IsUnset(request.EngineVersion)) {
		query["EngineVersion"] = request.EngineVersion
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeClassDetails"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeClassDetailsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeClassDetails(request *DescribeClassDetailsRequest) (_result *DescribeClassDetailsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeClassDetailsResponse{}
	_body, _err := client.DescribeClassDetailsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   PostgreSQL
 *
 * @param request DescribeCloudMigrationPrecheckResultRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCloudMigrationPrecheckResultResponse
 */
func (client *Client) DescribeCloudMigrationPrecheckResultWithOptions(request *DescribeCloudMigrationPrecheckResultRequest, runtime *util.RuntimeOptions) (_result *DescribeCloudMigrationPrecheckResultResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceName)) {
		query["DBInstanceName"] = request.DBInstanceName
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SourceIpAddress)) {
		query["SourceIpAddress"] = request.SourceIpAddress
	}

	if !tea.BoolValue(util.IsUnset(request.SourcePort)) {
		query["SourcePort"] = request.SourcePort
	}

	if !tea.BoolValue(util.IsUnset(request.TaskId)) {
		query["TaskId"] = request.TaskId
	}

	if !tea.BoolValue(util.IsUnset(request.TaskName)) {
		query["TaskName"] = request.TaskName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeCloudMigrationPrecheckResult"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeCloudMigrationPrecheckResultResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   PostgreSQL
 *
 * @param request DescribeCloudMigrationPrecheckResultRequest
 * @return DescribeCloudMigrationPrecheckResultResponse
 */
func (client *Client) DescribeCloudMigrationPrecheckResult(request *DescribeCloudMigrationPrecheckResultRequest) (_result *DescribeCloudMigrationPrecheckResultResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeCloudMigrationPrecheckResultResponse{}
	_body, _err := client.DescribeCloudMigrationPrecheckResultWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   PostgreSQL
 *
 * @param request DescribeCloudMigrationResultRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCloudMigrationResultResponse
 */
func (client *Client) DescribeCloudMigrationResultWithOptions(request *DescribeCloudMigrationResultRequest, runtime *util.RuntimeOptions) (_result *DescribeCloudMigrationResultResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceName)) {
		query["DBInstanceName"] = request.DBInstanceName
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SourceIpAddress)) {
		query["SourceIpAddress"] = request.SourceIpAddress
	}

	if !tea.BoolValue(util.IsUnset(request.SourcePort)) {
		query["SourcePort"] = request.SourcePort
	}

	if !tea.BoolValue(util.IsUnset(request.TaskId)) {
		query["TaskId"] = request.TaskId
	}

	if !tea.BoolValue(util.IsUnset(request.TaskName)) {
		query["TaskName"] = request.TaskName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeCloudMigrationResult"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeCloudMigrationResultResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   PostgreSQL
 *
 * @param request DescribeCloudMigrationResultRequest
 * @return DescribeCloudMigrationResultResponse
 */
func (client *Client) DescribeCloudMigrationResult(request *DescribeCloudMigrationResultRequest) (_result *DescribeCloudMigrationResultResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeCloudMigrationResultResponse{}
	_body, _err := client.DescribeCloudMigrationResultWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Supported database engine
 * SQL Server
 *
 * @param request DescribeCollationTimeZonesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCollationTimeZonesResponse
 */
func (client *Client) DescribeCollationTimeZonesWithOptions(request *DescribeCollationTimeZonesRequest, runtime *util.RuntimeOptions) (_result *DescribeCollationTimeZonesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeCollationTimeZones"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeCollationTimeZonesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Supported database engine
 * SQL Server
 *
 * @param request DescribeCollationTimeZonesRequest
 * @return DescribeCollationTimeZonesResponse
 */
func (client *Client) DescribeCollationTimeZones(request *DescribeCollationTimeZonesRequest) (_result *DescribeCollationTimeZonesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeCollationTimeZonesResponse{}
	_body, _err := client.DescribeCollationTimeZonesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ApsaraDB RDS for MySQL instances support cross-region backup and restoration. For more information, see [Back up an ApsaraDB RDS for MySQL instance across regions](~~120824~~) and [Restore the data of an ApsaraDB RDS for MySQL instance across regions](~~120875~~).
 * Before you call this operation, make sure that the instance runs one of the following database engines:
 * *   MySQL. For more information, see [Back up an ApsaraDB RDS for MySQL instance across regions](~~120824~~).
 * *   SQL Server. For more information, see [Back up an ApsaraDB RDS for SQL Server instance across regions](~~187923~~).
 * *   PostgreSQL. For more information, see [Enable cross-region backups for an ApsaraDB RDS for PostgreSQL instance](~~206671~~).
 *
 * @param request DescribeCrossBackupMetaListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCrossBackupMetaListResponse
 */
func (client *Client) DescribeCrossBackupMetaListWithOptions(request *DescribeCrossBackupMetaListRequest, runtime *util.RuntimeOptions) (_result *DescribeCrossBackupMetaListResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BackupSetId)) {
		query["BackupSetId"] = request.BackupSetId
	}

	if !tea.BoolValue(util.IsUnset(request.GetDbName)) {
		query["GetDbName"] = request.GetDbName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageIndex)) {
		query["PageIndex"] = request.PageIndex
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.Pattern)) {
		query["Pattern"] = request.Pattern
	}

	if !tea.BoolValue(util.IsUnset(request.Region)) {
		query["Region"] = request.Region
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeCrossBackupMetaList"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeCrossBackupMetaListResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ApsaraDB RDS for MySQL instances support cross-region backup and restoration. For more information, see [Back up an ApsaraDB RDS for MySQL instance across regions](~~120824~~) and [Restore the data of an ApsaraDB RDS for MySQL instance across regions](~~120875~~).
 * Before you call this operation, make sure that the instance runs one of the following database engines:
 * *   MySQL. For more information, see [Back up an ApsaraDB RDS for MySQL instance across regions](~~120824~~).
 * *   SQL Server. For more information, see [Back up an ApsaraDB RDS for SQL Server instance across regions](~~187923~~).
 * *   PostgreSQL. For more information, see [Enable cross-region backups for an ApsaraDB RDS for PostgreSQL instance](~~206671~~).
 *
 * @param request DescribeCrossBackupMetaListRequest
 * @return DescribeCrossBackupMetaListResponse
 */
func (client *Client) DescribeCrossBackupMetaList(request *DescribeCrossBackupMetaListRequest) (_result *DescribeCrossBackupMetaListResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeCrossBackupMetaListResponse{}
	_body, _err := client.DescribeCrossBackupMetaListWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Before you call this operation, make sure that the instance runs one of the following database engines:
 * *   MySQL. For more information, see [Back up an ApsaraDB RDS for MySQL instance across regions](~~120824~~).
 * *   SQL Server. For more information, see [Back up an ApsaraDB RDS for SQL Server instance across regions](~~187923~~).
 * *   PostgreSQL. For more information, see [Enable cross-region backups for an ApsaraDB RDS for PostgreSQL instance](~~206671~~).
 *
 * @param request DescribeCrossRegionBackupDBInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCrossRegionBackupDBInstanceResponse
 */
func (client *Client) DescribeCrossRegionBackupDBInstanceWithOptions(request *DescribeCrossRegionBackupDBInstanceRequest, runtime *util.RuntimeOptions) (_result *DescribeCrossRegionBackupDBInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeCrossRegionBackupDBInstance"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeCrossRegionBackupDBInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Before you call this operation, make sure that the instance runs one of the following database engines:
 * *   MySQL. For more information, see [Back up an ApsaraDB RDS for MySQL instance across regions](~~120824~~).
 * *   SQL Server. For more information, see [Back up an ApsaraDB RDS for SQL Server instance across regions](~~187923~~).
 * *   PostgreSQL. For more information, see [Enable cross-region backups for an ApsaraDB RDS for PostgreSQL instance](~~206671~~).
 *
 * @param request DescribeCrossRegionBackupDBInstanceRequest
 * @return DescribeCrossRegionBackupDBInstanceResponse
 */
func (client *Client) DescribeCrossRegionBackupDBInstance(request *DescribeCrossRegionBackupDBInstanceRequest) (_result *DescribeCrossRegionBackupDBInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeCrossRegionBackupDBInstanceResponse{}
	_body, _err := client.DescribeCrossRegionBackupDBInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * ### [](#)References
 * *   [Use the cross-region backup feature for an ApsaraDB RDS for MySQL instance](~~120824~~)
 * *   [Use the cross-region backup feature for an ApsaraDB RDS for SQL Server instance](~~187923~~)
 * *   [Use the cross-region backup feature for an ApsaraDB RDS for PostgreSQL instance](~~206671~~)
 * >  For more information about how to query cross-region log backup files, see [DescribeCrossRegionLogBackupFiles](~~121734~~).
 *
 * @param request DescribeCrossRegionBackupsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCrossRegionBackupsResponse
 */
func (client *Client) DescribeCrossRegionBackupsWithOptions(request *DescribeCrossRegionBackupsRequest, runtime *util.RuntimeOptions) (_result *DescribeCrossRegionBackupsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BackupId)) {
		query["BackupId"] = request.BackupId
	}

	if !tea.BoolValue(util.IsUnset(request.CrossBackupId)) {
		query["CrossBackupId"] = request.CrossBackupId
	}

	if !tea.BoolValue(util.IsUnset(request.CrossBackupRegion)) {
		query["CrossBackupRegion"] = request.CrossBackupRegion
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeCrossRegionBackups"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeCrossRegionBackupsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * ### [](#)References
 * *   [Use the cross-region backup feature for an ApsaraDB RDS for MySQL instance](~~120824~~)
 * *   [Use the cross-region backup feature for an ApsaraDB RDS for SQL Server instance](~~187923~~)
 * *   [Use the cross-region backup feature for an ApsaraDB RDS for PostgreSQL instance](~~206671~~)
 * >  For more information about how to query cross-region log backup files, see [DescribeCrossRegionLogBackupFiles](~~121734~~).
 *
 * @param request DescribeCrossRegionBackupsRequest
 * @return DescribeCrossRegionBackupsResponse
 */
func (client *Client) DescribeCrossRegionBackups(request *DescribeCrossRegionBackupsRequest) (_result *DescribeCrossRegionBackupsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeCrossRegionBackupsResponse{}
	_body, _err := client.DescribeCrossRegionBackupsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * ### [](#)References
 * *   [Use the cross-region backup feature of an ApsaraDB RDS for MySQL instance](~~120824~~)
 * *   [Use the cross-region backup feature for an ApsaraDB RDS for SQL Server instance](~~187923~~)
 * *   [Use the cross-region backup feature for an ApsaraDB RDS for PostgreSQL instance](~~206671~~)
 * >  For more information about how to query cross-region data backup files, see [DescribeCrossRegionBackups](~~121733~~).
 *
 * @param request DescribeCrossRegionLogBackupFilesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCrossRegionLogBackupFilesResponse
 */
func (client *Client) DescribeCrossRegionLogBackupFilesWithOptions(request *DescribeCrossRegionLogBackupFilesRequest, runtime *util.RuntimeOptions) (_result *DescribeCrossRegionLogBackupFilesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CrossBackupRegion)) {
		query["CrossBackupRegion"] = request.CrossBackupRegion
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeCrossRegionLogBackupFiles"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeCrossRegionLogBackupFilesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * ### [](#)References
 * *   [Use the cross-region backup feature of an ApsaraDB RDS for MySQL instance](~~120824~~)
 * *   [Use the cross-region backup feature for an ApsaraDB RDS for SQL Server instance](~~187923~~)
 * *   [Use the cross-region backup feature for an ApsaraDB RDS for PostgreSQL instance](~~206671~~)
 * >  For more information about how to query cross-region data backup files, see [DescribeCrossRegionBackups](~~121733~~).
 *
 * @param request DescribeCrossRegionLogBackupFilesRequest
 * @return DescribeCrossRegionLogBackupFilesResponse
 */
func (client *Client) DescribeCrossRegionLogBackupFiles(request *DescribeCrossRegionLogBackupFilesRequest) (_result *DescribeCrossRegionLogBackupFilesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeCrossRegionLogBackupFilesResponse{}
	_body, _err := client.DescribeCrossRegionLogBackupFilesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeCurrentModifyOrderWithOptions(request *DescribeCurrentModifyOrderRequest, runtime *util.RuntimeOptions) (_result *DescribeCurrentModifyOrderResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DbInstanceId)) {
		query["DbInstanceId"] = request.DbInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeCurrentModifyOrder"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeCurrentModifyOrderResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeCurrentModifyOrder(request *DescribeCurrentModifyOrderRequest) (_result *DescribeCurrentModifyOrderResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeCurrentModifyOrderResponse{}
	_body, _err := client.DescribeCurrentModifyOrderWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeCustinsResourceInfoWithOptions(request *DescribeCustinsResourceInfoRequest, runtime *util.RuntimeOptions) (_result *DescribeCustinsResourceInfoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceIds)) {
		query["DBInstanceIds"] = request.DBInstanceIds
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeCustinsResourceInfo"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeCustinsResourceInfoResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeCustinsResourceInfo(request *DescribeCustinsResourceInfoRequest) (_result *DescribeCustinsResourceInfoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeCustinsResourceInfoResponse{}
	_body, _err := client.DescribeCustinsResourceInfoWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   RDS MySQL
 * *   RDS PostgreSQL
 * *   RDS SQL Server
 * *   RDS MariaDB
 *
 * @param request DescribeDBInstanceAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDBInstanceAttributeResponse
 */
func (client *Client) DescribeDBInstanceAttributeWithOptions(request *DescribeDBInstanceAttributeRequest, runtime *util.RuntimeOptions) (_result *DescribeDBInstanceAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Expired)) {
		query["Expired"] = request.Expired
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDBInstanceAttribute"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDBInstanceAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   RDS MySQL
 * *   RDS PostgreSQL
 * *   RDS SQL Server
 * *   RDS MariaDB
 *
 * @param request DescribeDBInstanceAttributeRequest
 * @return DescribeDBInstanceAttributeResponse
 */
func (client *Client) DescribeDBInstanceAttribute(request *DescribeDBInstanceAttributeRequest) (_result *DescribeDBInstanceAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDBInstanceAttributeResponse{}
	_body, _err := client.DescribeDBInstanceAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 *
 * @param request DescribeDBInstanceByTagsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDBInstanceByTagsResponse
 */
func (client *Client) DescribeDBInstanceByTagsWithOptions(request *DescribeDBInstanceByTagsRequest, runtime *util.RuntimeOptions) (_result *DescribeDBInstanceByTagsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ProxyId)) {
		query["proxyId"] = request.ProxyId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDBInstanceByTags"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDBInstanceByTagsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 *
 * @param request DescribeDBInstanceByTagsRequest
 * @return DescribeDBInstanceByTagsResponse
 */
func (client *Client) DescribeDBInstanceByTags(request *DescribeDBInstanceByTagsRequest) (_result *DescribeDBInstanceByTagsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDBInstanceByTagsResponse{}
	_body, _err := client.DescribeDBInstanceByTagsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeDBInstanceConnectivityWithOptions(request *DescribeDBInstanceConnectivityRequest, runtime *util.RuntimeOptions) (_result *DescribeDBInstanceConnectivityResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDBInstanceConnectivity"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDBInstanceConnectivityResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeDBInstanceConnectivity(request *DescribeDBInstanceConnectivityRequest) (_result *DescribeDBInstanceConnectivityResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDBInstanceConnectivityResponse{}
	_body, _err := client.DescribeDBInstanceConnectivityWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * This operation is phased out.
 *
 * @param request DescribeDBInstanceDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDBInstanceDetailResponse
 */
func (client *Client) DescribeDBInstanceDetailWithOptions(request *DescribeDBInstanceDetailRequest, runtime *util.RuntimeOptions) (_result *DescribeDBInstanceDetailResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDBInstanceDetail"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDBInstanceDetailResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * This operation is phased out.
 *
 * @param request DescribeDBInstanceDetailRequest
 * @return DescribeDBInstanceDetailResponse
 */
func (client *Client) DescribeDBInstanceDetail(request *DescribeDBInstanceDetailRequest) (_result *DescribeDBInstanceDetailResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDBInstanceDetailResponse{}
	_body, _err := client.DescribeDBInstanceDetailWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeDBInstanceEncryptionKeyWithOptions(request *DescribeDBInstanceEncryptionKeyRequest, runtime *util.RuntimeOptions) (_result *DescribeDBInstanceEncryptionKeyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.EncryptionKey)) {
		query["EncryptionKey"] = request.EncryptionKey
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	if !tea.BoolValue(util.IsUnset(request.TargetRegionId)) {
		query["TargetRegionId"] = request.TargetRegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDBInstanceEncryptionKey"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDBInstanceEncryptionKeyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeDBInstanceEncryptionKey(request *DescribeDBInstanceEncryptionKeyRequest) (_result *DescribeDBInstanceEncryptionKeyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDBInstanceEncryptionKeyResponse{}
	_body, _err := client.DescribeDBInstanceEncryptionKeyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * RDS MySQL
 *
 * @param request DescribeDBInstanceEndpointsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDBInstanceEndpointsResponse
 */
func (client *Client) DescribeDBInstanceEndpointsWithOptions(request *DescribeDBInstanceEndpointsRequest, runtime *util.RuntimeOptions) (_result *DescribeDBInstanceEndpointsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceEndpointId)) {
		query["DBInstanceEndpointId"] = request.DBInstanceEndpointId
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDBInstanceEndpoints"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDBInstanceEndpointsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * RDS MySQL
 *
 * @param request DescribeDBInstanceEndpointsRequest
 * @return DescribeDBInstanceEndpointsResponse
 */
func (client *Client) DescribeDBInstanceEndpoints(request *DescribeDBInstanceEndpointsRequest) (_result *DescribeDBInstanceEndpointsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDBInstanceEndpointsResponse{}
	_body, _err := client.DescribeDBInstanceEndpointsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * ### References
 * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * *   [Query the data replication mode of an ApsaraDB RDS for MySQL instance](~~96055~~)
 * *   [Query the data replication mode of an ApsaraDB RDS for PostgreSQL instance](~~151265~~)
 * *   [Query the data replication mode of an ApsaraDB RDS for SQL Server instance](~~415433~~)
 *
 * @param request DescribeDBInstanceHAConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDBInstanceHAConfigResponse
 */
func (client *Client) DescribeDBInstanceHAConfigWithOptions(request *DescribeDBInstanceHAConfigRequest, runtime *util.RuntimeOptions) (_result *DescribeDBInstanceHAConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDBInstanceHAConfig"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDBInstanceHAConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * ### References
 * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * *   [Query the data replication mode of an ApsaraDB RDS for MySQL instance](~~96055~~)
 * *   [Query the data replication mode of an ApsaraDB RDS for PostgreSQL instance](~~151265~~)
 * *   [Query the data replication mode of an ApsaraDB RDS for SQL Server instance](~~415433~~)
 *
 * @param request DescribeDBInstanceHAConfigRequest
 * @return DescribeDBInstanceHAConfigResponse
 */
func (client *Client) DescribeDBInstanceHAConfig(request *DescribeDBInstanceHAConfigRequest) (_result *DescribeDBInstanceHAConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDBInstanceHAConfigResponse{}
	_body, _err := client.DescribeDBInstanceHAConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   RDS MySQL
 * *   RDS PostgreSQL
 * *   RDS SQL Server
 * *   RDS MariaDB
 *
 * @param request DescribeDBInstanceIPArrayListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDBInstanceIPArrayListResponse
 */
func (client *Client) DescribeDBInstanceIPArrayListWithOptions(request *DescribeDBInstanceIPArrayListRequest, runtime *util.RuntimeOptions) (_result *DescribeDBInstanceIPArrayListResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.WhitelistNetworkType)) {
		query["WhitelistNetworkType"] = request.WhitelistNetworkType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDBInstanceIPArrayList"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDBInstanceIPArrayListResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   RDS MySQL
 * *   RDS PostgreSQL
 * *   RDS SQL Server
 * *   RDS MariaDB
 *
 * @param request DescribeDBInstanceIPArrayListRequest
 * @return DescribeDBInstanceIPArrayListResponse
 */
func (client *Client) DescribeDBInstanceIPArrayList(request *DescribeDBInstanceIPArrayListRequest) (_result *DescribeDBInstanceIPArrayListResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDBInstanceIPArrayListResponse{}
	_body, _err := client.DescribeDBInstanceIPArrayListWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * RDS SQL Server
 * ### [](#)Prerequisites
 * *   The RDS instance runs RDS Basic Edition, RDS High-availability Edition, or RDS Cluster Edition. If your RDS instance runs RDS High-availability Edition, make sure that the instance runs SQL Server 2012 or later.
 * *   The RDS instance belongs to a general-purpose or dedicated instance family. The shared instance family is not supported.
 * *   If the RDS instance runs RDS Basic Edition, the instance is created on or after September 02, 2022. You can view the Creation Time
 * ### [](#)References
 * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * [Configure a distributed transaction whitelist](~~124321~~)
 *
 * @param request DescribeDBInstanceIpHostnameRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDBInstanceIpHostnameResponse
 */
func (client *Client) DescribeDBInstanceIpHostnameWithOptions(request *DescribeDBInstanceIpHostnameRequest, runtime *util.RuntimeOptions) (_result *DescribeDBInstanceIpHostnameResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDBInstanceIpHostname"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDBInstanceIpHostnameResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * RDS SQL Server
 * ### [](#)Prerequisites
 * *   The RDS instance runs RDS Basic Edition, RDS High-availability Edition, or RDS Cluster Edition. If your RDS instance runs RDS High-availability Edition, make sure that the instance runs SQL Server 2012 or later.
 * *   The RDS instance belongs to a general-purpose or dedicated instance family. The shared instance family is not supported.
 * *   If the RDS instance runs RDS Basic Edition, the instance is created on or after September 02, 2022. You can view the Creation Time
 * ### [](#)References
 * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * [Configure a distributed transaction whitelist](~~124321~~)
 *
 * @param request DescribeDBInstanceIpHostnameRequest
 * @return DescribeDBInstanceIpHostnameResponse
 */
func (client *Client) DescribeDBInstanceIpHostname(request *DescribeDBInstanceIpHostnameRequest) (_result *DescribeDBInstanceIpHostnameResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDBInstanceIpHostnameResponse{}
	_body, _err := client.DescribeDBInstanceIpHostnameWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   PostgreSQL
 * ### [](#)References
 * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * [View the Enhanced Monitoring metrics](~~299200~~)
 *
 * @param request DescribeDBInstanceMetricsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDBInstanceMetricsResponse
 */
func (client *Client) DescribeDBInstanceMetricsWithOptions(request *DescribeDBInstanceMetricsRequest, runtime *util.RuntimeOptions) (_result *DescribeDBInstanceMetricsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceName)) {
		query["DBInstanceName"] = request.DBInstanceName
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDBInstanceMetrics"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDBInstanceMetricsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   PostgreSQL
 * ### [](#)References
 * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * [View the Enhanced Monitoring metrics](~~299200~~)
 *
 * @param request DescribeDBInstanceMetricsRequest
 * @return DescribeDBInstanceMetricsResponse
 */
func (client *Client) DescribeDBInstanceMetrics(request *DescribeDBInstanceMetricsRequest) (_result *DescribeDBInstanceMetricsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDBInstanceMetricsResponse{}
	_body, _err := client.DescribeDBInstanceMetricsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   SQL Server
 * *   MariaDB
 *
 * @param request DescribeDBInstanceMonitorRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDBInstanceMonitorResponse
 */
func (client *Client) DescribeDBInstanceMonitorWithOptions(request *DescribeDBInstanceMonitorRequest, runtime *util.RuntimeOptions) (_result *DescribeDBInstanceMonitorResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDBInstanceMonitor"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDBInstanceMonitorResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   SQL Server
 * *   MariaDB
 *
 * @param request DescribeDBInstanceMonitorRequest
 * @return DescribeDBInstanceMonitorResponse
 */
func (client *Client) DescribeDBInstanceMonitor(request *DescribeDBInstanceMonitorRequest) (_result *DescribeDBInstanceMonitorResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDBInstanceMonitorResponse{}
	_body, _err := client.DescribeDBInstanceMonitorWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 *
 * @param request DescribeDBInstanceNetInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDBInstanceNetInfoResponse
 */
func (client *Client) DescribeDBInstanceNetInfoWithOptions(request *DescribeDBInstanceNetInfoRequest, runtime *util.RuntimeOptions) (_result *DescribeDBInstanceNetInfoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceNetRWSplitType)) {
		query["DBInstanceNetRWSplitType"] = request.DBInstanceNetRWSplitType
	}

	if !tea.BoolValue(util.IsUnset(request.Flag)) {
		query["Flag"] = request.Flag
	}

	if !tea.BoolValue(util.IsUnset(request.GeneralGroupName)) {
		query["GeneralGroupName"] = request.GeneralGroupName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDBInstanceNetInfo"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDBInstanceNetInfoResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 *
 * @param request DescribeDBInstanceNetInfoRequest
 * @return DescribeDBInstanceNetInfoResponse
 */
func (client *Client) DescribeDBInstanceNetInfo(request *DescribeDBInstanceNetInfoRequest) (_result *DescribeDBInstanceNetInfoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDBInstanceNetInfoResponse{}
	_body, _err := client.DescribeDBInstanceNetInfoWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeDBInstanceNetInfoForChannelWithOptions(request *DescribeDBInstanceNetInfoForChannelRequest, runtime *util.RuntimeOptions) (_result *DescribeDBInstanceNetInfoForChannelResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceNetRWSplitType)) {
		query["DBInstanceNetRWSplitType"] = request.DBInstanceNetRWSplitType
	}

	if !tea.BoolValue(util.IsUnset(request.Flag)) {
		query["Flag"] = request.Flag
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDBInstanceNetInfoForChannel"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDBInstanceNetInfoForChannelResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeDBInstanceNetInfoForChannel(request *DescribeDBInstanceNetInfoForChannelRequest) (_result *DescribeDBInstanceNetInfoForChannelResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDBInstanceNetInfoForChannelResponse{}
	_body, _err := client.DescribeDBInstanceNetInfoForChannelWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 *
 * @param request DescribeDBInstancePerformanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDBInstancePerformanceResponse
 */
func (client *Client) DescribeDBInstancePerformanceWithOptions(request *DescribeDBInstancePerformanceRequest, runtime *util.RuntimeOptions) (_result *DescribeDBInstancePerformanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.Key)) {
		query["Key"] = request.Key
	}

	if !tea.BoolValue(util.IsUnset(request.NodeId)) {
		query["NodeId"] = request.NodeId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDBInstancePerformance"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDBInstancePerformanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 *
 * @param request DescribeDBInstancePerformanceRequest
 * @return DescribeDBInstancePerformanceResponse
 */
func (client *Client) DescribeDBInstancePerformance(request *DescribeDBInstancePerformanceRequest) (_result *DescribeDBInstancePerformanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDBInstancePerformanceResponse{}
	_body, _err := client.DescribeDBInstancePerformanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * @deprecated
 *
 * @param request DescribeDBInstancePromoteActivityRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDBInstancePromoteActivityResponse
 */
// Deprecated
func (client *Client) DescribeDBInstancePromoteActivityWithOptions(request *DescribeDBInstancePromoteActivityRequest, runtime *util.RuntimeOptions) (_result *DescribeDBInstancePromoteActivityResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AliUid)) {
		query["AliUid"] = request.AliUid
	}

	if !tea.BoolValue(util.IsUnset(request.DbInstanceName)) {
		query["DbInstanceName"] = request.DbInstanceName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDBInstancePromoteActivity"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDBInstancePromoteActivityResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * @deprecated
 *
 * @param request DescribeDBInstancePromoteActivityRequest
 * @return DescribeDBInstancePromoteActivityResponse
 */
// Deprecated
func (client *Client) DescribeDBInstancePromoteActivity(request *DescribeDBInstancePromoteActivityRequest) (_result *DescribeDBInstancePromoteActivityResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDBInstancePromoteActivityResponse{}
	_body, _err := client.DescribeDBInstancePromoteActivityWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * This operation is used to query the original settings of shared proxies rather than the latest settings of dedicated proxies. For more information about how to query the settings of dedicated proxies, see [DescribeDBProxy](~~141055~~).
 * Before you call this operation, make sure that the following requirements are met:
 * *   The shared proxy feature must be enabled for the primary instance.
 * *   The read/write splitting feature must be enabled for the primary instance.
 *
 * @param request DescribeDBInstanceProxyConfigurationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDBInstanceProxyConfigurationResponse
 */
func (client *Client) DescribeDBInstanceProxyConfigurationWithOptions(request *DescribeDBInstanceProxyConfigurationRequest, runtime *util.RuntimeOptions) (_result *DescribeDBInstanceProxyConfigurationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDBInstanceProxyConfiguration"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDBInstanceProxyConfigurationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * This operation is used to query the original settings of shared proxies rather than the latest settings of dedicated proxies. For more information about how to query the settings of dedicated proxies, see [DescribeDBProxy](~~141055~~).
 * Before you call this operation, make sure that the following requirements are met:
 * *   The shared proxy feature must be enabled for the primary instance.
 * *   The read/write splitting feature must be enabled for the primary instance.
 *
 * @param request DescribeDBInstanceProxyConfigurationRequest
 * @return DescribeDBInstanceProxyConfigurationResponse
 */
func (client *Client) DescribeDBInstanceProxyConfiguration(request *DescribeDBInstanceProxyConfigurationRequest) (_result *DescribeDBInstanceProxyConfigurationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDBInstanceProxyConfigurationResponse{}
	_body, _err := client.DescribeDBInstanceProxyConfigurationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   RDS MySQL
 * *   RDS PostgreSQL
 * *   RDS SQL Server
 *
 * @param request DescribeDBInstanceSSLRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDBInstanceSSLResponse
 */
func (client *Client) DescribeDBInstanceSSLWithOptions(request *DescribeDBInstanceSSLRequest, runtime *util.RuntimeOptions) (_result *DescribeDBInstanceSSLResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDBInstanceSSL"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDBInstanceSSLResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   RDS MySQL
 * *   RDS PostgreSQL
 * *   RDS SQL Server
 *
 * @param request DescribeDBInstanceSSLRequest
 * @return DescribeDBInstanceSSLResponse
 */
func (client *Client) DescribeDBInstanceSSL(request *DescribeDBInstanceSSLRequest) (_result *DescribeDBInstanceSSLResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDBInstanceSSLResponse{}
	_body, _err := client.DescribeDBInstanceSSLWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 *
 * @param request DescribeDBInstanceTDERequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDBInstanceTDEResponse
 */
func (client *Client) DescribeDBInstanceTDEWithOptions(request *DescribeDBInstanceTDERequest, runtime *util.RuntimeOptions) (_result *DescribeDBInstanceTDEResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDBInstanceTDE"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDBInstanceTDEResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 *
 * @param request DescribeDBInstanceTDERequest
 * @return DescribeDBInstanceTDEResponse
 */
func (client *Client) DescribeDBInstanceTDE(request *DescribeDBInstanceTDERequest) (_result *DescribeDBInstanceTDEResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDBInstanceTDEResponse{}
	_body, _err := client.DescribeDBInstanceTDEWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 *
 * @param request DescribeDBInstancesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDBInstancesResponse
 */
func (client *Client) DescribeDBInstancesWithOptions(request *DescribeDBInstancesRequest, runtime *util.RuntimeOptions) (_result *DescribeDBInstancesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Category)) {
		query["Category"] = request.Category
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.ConnectionMode)) {
		query["ConnectionMode"] = request.ConnectionMode
	}

	if !tea.BoolValue(util.IsUnset(request.ConnectionString)) {
		query["ConnectionString"] = request.ConnectionString
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceClass)) {
		query["DBInstanceClass"] = request.DBInstanceClass
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceStatus)) {
		query["DBInstanceStatus"] = request.DBInstanceStatus
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceType)) {
		query["DBInstanceType"] = request.DBInstanceType
	}

	if !tea.BoolValue(util.IsUnset(request.DedicatedHostGroupId)) {
		query["DedicatedHostGroupId"] = request.DedicatedHostGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.DedicatedHostId)) {
		query["DedicatedHostId"] = request.DedicatedHostId
	}

	if !tea.BoolValue(util.IsUnset(request.Engine)) {
		query["Engine"] = request.Engine
	}

	if !tea.BoolValue(util.IsUnset(request.EngineVersion)) {
		query["EngineVersion"] = request.EngineVersion
	}

	if !tea.BoolValue(util.IsUnset(request.Expired)) {
		query["Expired"] = request.Expired
	}

	if !tea.BoolValue(util.IsUnset(request.Filter)) {
		query["Filter"] = request.Filter
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceLevel)) {
		query["InstanceLevel"] = request.InstanceLevel
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceNetworkType)) {
		query["InstanceNetworkType"] = request.InstanceNetworkType
	}

	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.PayType)) {
		query["PayType"] = request.PayType
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SearchKey)) {
		query["SearchKey"] = request.SearchKey
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	if !tea.BoolValue(util.IsUnset(request.VSwitchId)) {
		query["VSwitchId"] = request.VSwitchId
	}

	if !tea.BoolValue(util.IsUnset(request.VpcId)) {
		query["VpcId"] = request.VpcId
	}

	if !tea.BoolValue(util.IsUnset(request.ZoneId)) {
		query["ZoneId"] = request.ZoneId
	}

	if !tea.BoolValue(util.IsUnset(request.ProxyId)) {
		query["proxyId"] = request.ProxyId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDBInstances"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDBInstancesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 *
 * @param request DescribeDBInstancesRequest
 * @return DescribeDBInstancesResponse
 */
func (client *Client) DescribeDBInstances(request *DescribeDBInstancesRequest) (_result *DescribeDBInstancesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDBInstancesResponse{}
	_body, _err := client.DescribeDBInstancesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * @deprecated : DescribeDBInstancesAsCsv is deprecated, please use Rds::2014-08-15::DescribeDBInstances instead.
 * **
 * **Description:** This operation is phased out. Use the [DescribeDBInstances](~~610396~~) operation instead.
 *
 * @param request DescribeDBInstancesAsCsvRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDBInstancesAsCsvResponse
 */
// Deprecated
func (client *Client) DescribeDBInstancesAsCsvWithOptions(request *DescribeDBInstancesAsCsvRequest, runtime *util.RuntimeOptions) (_result *DescribeDBInstancesAsCsvResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CachedAsync)) {
		query["CachedAsync"] = request.CachedAsync
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ExportKey)) {
		query["ExportKey"] = request.ExportKey
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDBInstancesAsCsv"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDBInstancesAsCsvResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * @deprecated : DescribeDBInstancesAsCsv is deprecated, please use Rds::2014-08-15::DescribeDBInstances instead.
 * **
 * **Description:** This operation is phased out. Use the [DescribeDBInstances](~~610396~~) operation instead.
 *
 * @param request DescribeDBInstancesAsCsvRequest
 * @return DescribeDBInstancesAsCsvResponse
 */
// Deprecated
func (client *Client) DescribeDBInstancesAsCsv(request *DescribeDBInstancesAsCsvRequest) (_result *DescribeDBInstancesAsCsvResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDBInstancesAsCsvResponse{}
	_body, _err := client.DescribeDBInstancesAsCsvWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Supported database engines
 * *   RDS MySQL
 * *   RDS PostgreSQL
 * *   RDS SQL Server
 * *   RDS MariaDB
 *
 * @param request DescribeDBInstancesByExpireTimeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDBInstancesByExpireTimeResponse
 */
func (client *Client) DescribeDBInstancesByExpireTimeWithOptions(request *DescribeDBInstancesByExpireTimeRequest, runtime *util.RuntimeOptions) (_result *DescribeDBInstancesByExpireTimeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ExpirePeriod)) {
		query["ExpirePeriod"] = request.ExpirePeriod
	}

	if !tea.BoolValue(util.IsUnset(request.Expired)) {
		query["Expired"] = request.Expired
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	if !tea.BoolValue(util.IsUnset(request.ProxyId)) {
		query["proxyId"] = request.ProxyId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDBInstancesByExpireTime"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDBInstancesByExpireTimeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Supported database engines
 * *   RDS MySQL
 * *   RDS PostgreSQL
 * *   RDS SQL Server
 * *   RDS MariaDB
 *
 * @param request DescribeDBInstancesByExpireTimeRequest
 * @return DescribeDBInstancesByExpireTimeResponse
 */
func (client *Client) DescribeDBInstancesByExpireTime(request *DescribeDBInstancesByExpireTimeRequest) (_result *DescribeDBInstancesByExpireTimeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDBInstancesByExpireTimeResponse{}
	_body, _err := client.DescribeDBInstancesByExpireTimeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * This operation is phased out.
 *
 * @param request DescribeDBInstancesByPerformanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDBInstancesByPerformanceResponse
 */
func (client *Client) DescribeDBInstancesByPerformanceWithOptions(request *DescribeDBInstancesByPerformanceRequest, runtime *util.RuntimeOptions) (_result *DescribeDBInstancesByPerformanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SortKey)) {
		query["SortKey"] = request.SortKey
	}

	if !tea.BoolValue(util.IsUnset(request.SortMethod)) {
		query["SortMethod"] = request.SortMethod
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	if !tea.BoolValue(util.IsUnset(request.ProxyId)) {
		query["proxyId"] = request.ProxyId
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDBInstancesByPerformance"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDBInstancesByPerformanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * This operation is phased out.
 *
 * @param request DescribeDBInstancesByPerformanceRequest
 * @return DescribeDBInstancesByPerformanceResponse
 */
func (client *Client) DescribeDBInstancesByPerformance(request *DescribeDBInstancesByPerformanceRequest) (_result *DescribeDBInstancesByPerformanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDBInstancesByPerformanceResponse{}
	_body, _err := client.DescribeDBInstancesByPerformanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * This operation is phased out.
 *
 * @param request DescribeDBInstancesForCloneRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDBInstancesForCloneResponse
 */
func (client *Client) DescribeDBInstancesForCloneWithOptions(request *DescribeDBInstancesForCloneRequest, runtime *util.RuntimeOptions) (_result *DescribeDBInstancesForCloneResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.ConnectionMode)) {
		query["ConnectionMode"] = request.ConnectionMode
	}

	if !tea.BoolValue(util.IsUnset(request.CurrentInstanceId)) {
		query["CurrentInstanceId"] = request.CurrentInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceClass)) {
		query["DBInstanceClass"] = request.DBInstanceClass
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceStatus)) {
		query["DBInstanceStatus"] = request.DBInstanceStatus
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceType)) {
		query["DBInstanceType"] = request.DBInstanceType
	}

	if !tea.BoolValue(util.IsUnset(request.Engine)) {
		query["Engine"] = request.Engine
	}

	if !tea.BoolValue(util.IsUnset(request.EngineVersion)) {
		query["EngineVersion"] = request.EngineVersion
	}

	if !tea.BoolValue(util.IsUnset(request.Expired)) {
		query["Expired"] = request.Expired
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceNetworkType)) {
		query["InstanceNetworkType"] = request.InstanceNetworkType
	}

	if !tea.BoolValue(util.IsUnset(request.NodeType)) {
		query["NodeType"] = request.NodeType
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.PayType)) {
		query["PayType"] = request.PayType
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SearchKey)) {
		query["SearchKey"] = request.SearchKey
	}

	if !tea.BoolValue(util.IsUnset(request.VSwitchId)) {
		query["VSwitchId"] = request.VSwitchId
	}

	if !tea.BoolValue(util.IsUnset(request.VpcId)) {
		query["VpcId"] = request.VpcId
	}

	if !tea.BoolValue(util.IsUnset(request.ZoneId)) {
		query["ZoneId"] = request.ZoneId
	}

	if !tea.BoolValue(util.IsUnset(request.ProxyId)) {
		query["proxyId"] = request.ProxyId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDBInstancesForClone"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDBInstancesForCloneResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * This operation is phased out.
 *
 * @param request DescribeDBInstancesForCloneRequest
 * @return DescribeDBInstancesForCloneResponse
 */
func (client *Client) DescribeDBInstancesForClone(request *DescribeDBInstancesForCloneRequest) (_result *DescribeDBInstancesForCloneResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDBInstancesForCloneResponse{}
	_body, _err := client.DescribeDBInstancesForCloneWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Before you purchase or upgrade an instance that runs MySQL or PostgreSQL, you can call the DescribeDBMiniEngineVersions operation to query the minor engine versions that are available for the instance.
 *
 * @param request DescribeDBMiniEngineVersionsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDBMiniEngineVersionsResponse
 */
func (client *Client) DescribeDBMiniEngineVersionsWithOptions(request *DescribeDBMiniEngineVersionsRequest, runtime *util.RuntimeOptions) (_result *DescribeDBMiniEngineVersionsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.DedicatedHostGroupId)) {
		query["DedicatedHostGroupId"] = request.DedicatedHostGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.Engine)) {
		query["Engine"] = request.Engine
	}

	if !tea.BoolValue(util.IsUnset(request.EngineVersion)) {
		query["EngineVersion"] = request.EngineVersion
	}

	if !tea.BoolValue(util.IsUnset(request.MinorVersionTag)) {
		query["MinorVersionTag"] = request.MinorVersionTag
	}

	if !tea.BoolValue(util.IsUnset(request.NodeType)) {
		query["NodeType"] = request.NodeType
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.StorageType)) {
		query["StorageType"] = request.StorageType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDBMiniEngineVersions"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDBMiniEngineVersionsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Before you purchase or upgrade an instance that runs MySQL or PostgreSQL, you can call the DescribeDBMiniEngineVersions operation to query the minor engine versions that are available for the instance.
 *
 * @param request DescribeDBMiniEngineVersionsRequest
 * @return DescribeDBMiniEngineVersionsResponse
 */
func (client *Client) DescribeDBMiniEngineVersions(request *DescribeDBMiniEngineVersionsRequest) (_result *DescribeDBMiniEngineVersionsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDBMiniEngineVersionsResponse{}
	_body, _err := client.DescribeDBMiniEngineVersionsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   RDS MySQL
 * *   RDS PostgreSQL
 *
 * @param request DescribeDBProxyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDBProxyResponse
 */
func (client *Client) DescribeDBProxyWithOptions(request *DescribeDBProxyRequest, runtime *util.RuntimeOptions) (_result *DescribeDBProxyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.DBProxyEngineType)) {
		query["DBProxyEngineType"] = request.DBProxyEngineType
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDBProxy"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDBProxyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   RDS MySQL
 * *   RDS PostgreSQL
 *
 * @param request DescribeDBProxyRequest
 * @return DescribeDBProxyResponse
 */
func (client *Client) DescribeDBProxy(request *DescribeDBProxyRequest) (_result *DescribeDBProxyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDBProxyResponse{}
	_body, _err := client.DescribeDBProxyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   RDS MySQL
 * *   RDS PostgreSQL
 *
 * @param request DescribeDBProxyEndpointRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDBProxyEndpointResponse
 */
func (client *Client) DescribeDBProxyEndpointWithOptions(request *DescribeDBProxyEndpointRequest, runtime *util.RuntimeOptions) (_result *DescribeDBProxyEndpointResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.DBProxyConnectString)) {
		query["DBProxyConnectString"] = request.DBProxyConnectString
	}

	if !tea.BoolValue(util.IsUnset(request.DBProxyEndpointId)) {
		query["DBProxyEndpointId"] = request.DBProxyEndpointId
	}

	if !tea.BoolValue(util.IsUnset(request.DBProxyEngineType)) {
		query["DBProxyEngineType"] = request.DBProxyEngineType
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDBProxyEndpoint"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDBProxyEndpointResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   RDS MySQL
 * *   RDS PostgreSQL
 *
 * @param request DescribeDBProxyEndpointRequest
 * @return DescribeDBProxyEndpointResponse
 */
func (client *Client) DescribeDBProxyEndpoint(request *DescribeDBProxyEndpointRequest) (_result *DescribeDBProxyEndpointResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDBProxyEndpointResponse{}
	_body, _err := client.DescribeDBProxyEndpointWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * >  Starting October 17, 2023, ApsaraDB RDS provides a dedicated proxy free of charge for each ApsaraDB RDS for MySQL instance on RDS Cluster Edition. For more information, see [\\[Special offers/Price changes\\] One proxy is provided free of charge for ApsaraDB RDS for MySQL instances on RDS Cluster Edition](~~2555466~~).
 * ### [](#)References
 * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
 * *   [View the monitoring data of an ApsaraDB RDS for MySQL instance](~~194241~~)
 * *   [View the monitoring data of an ApsaraDB RDS for PostgreSQL instance](~~418275~~)
 *
 * @param request DescribeDBProxyPerformanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDBProxyPerformanceResponse
 */
func (client *Client) DescribeDBProxyPerformanceWithOptions(request *DescribeDBProxyPerformanceRequest, runtime *util.RuntimeOptions) (_result *DescribeDBProxyPerformanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.DBProxyEngineType)) {
		query["DBProxyEngineType"] = request.DBProxyEngineType
	}

	if !tea.BoolValue(util.IsUnset(request.DBProxyInstanceType)) {
		query["DBProxyInstanceType"] = request.DBProxyInstanceType
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.MetricsName)) {
		query["MetricsName"] = request.MetricsName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDBProxyPerformance"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDBProxyPerformanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * >  Starting October 17, 2023, ApsaraDB RDS provides a dedicated proxy free of charge for each ApsaraDB RDS for MySQL instance on RDS Cluster Edition. For more information, see [\\[Special offers/Price changes\\] One proxy is provided free of charge for ApsaraDB RDS for MySQL instances on RDS Cluster Edition](~~2555466~~).
 * ### [](#)References
 * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
 * *   [View the monitoring data of an ApsaraDB RDS for MySQL instance](~~194241~~)
 * *   [View the monitoring data of an ApsaraDB RDS for PostgreSQL instance](~~418275~~)
 *
 * @param request DescribeDBProxyPerformanceRequest
 * @return DescribeDBProxyPerformanceResponse
 */
func (client *Client) DescribeDBProxyPerformance(request *DescribeDBProxyPerformanceRequest) (_result *DescribeDBProxyPerformanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDBProxyPerformanceResponse{}
	_body, _err := client.DescribeDBProxyPerformanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * SQL Server
 * ### [](#)References
 * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * [Configures a distributed transaction whitelist for an ApsaraDB RDS for SQL Server instance](~~124321~~)
 *
 * @param request DescribeDTCSecurityIpHostsForSQLServerRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDTCSecurityIpHostsForSQLServerResponse
 */
func (client *Client) DescribeDTCSecurityIpHostsForSQLServerWithOptions(request *DescribeDTCSecurityIpHostsForSQLServerRequest, runtime *util.RuntimeOptions) (_result *DescribeDTCSecurityIpHostsForSQLServerResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDTCSecurityIpHostsForSQLServer"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDTCSecurityIpHostsForSQLServerResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * SQL Server
 * ### [](#)References
 * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * [Configures a distributed transaction whitelist for an ApsaraDB RDS for SQL Server instance](~~124321~~)
 *
 * @param request DescribeDTCSecurityIpHostsForSQLServerRequest
 * @return DescribeDTCSecurityIpHostsForSQLServerResponse
 */
func (client *Client) DescribeDTCSecurityIpHostsForSQLServer(request *DescribeDTCSecurityIpHostsForSQLServerRequest) (_result *DescribeDTCSecurityIpHostsForSQLServerResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDTCSecurityIpHostsForSQLServerResponse{}
	_body, _err := client.DescribeDTCSecurityIpHostsForSQLServerWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 *
 * @param request DescribeDatabasesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDatabasesResponse
 */
func (client *Client) DescribeDatabasesWithOptions(request *DescribeDatabasesRequest, runtime *util.RuntimeOptions) (_result *DescribeDatabasesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.DBName)) {
		query["DBName"] = request.DBName
	}

	if !tea.BoolValue(util.IsUnset(request.DBStatus)) {
		query["DBStatus"] = request.DBStatus
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDatabases"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDatabasesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 *
 * @param request DescribeDatabasesRequest
 * @return DescribeDatabasesResponse
 */
func (client *Client) DescribeDatabases(request *DescribeDatabasesRequest) (_result *DescribeDatabasesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDatabasesResponse{}
	_body, _err := client.DescribeDatabasesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Dedicated clusters allow you to manage a number of instances in a cluster at a time. You can create multiple dedicated clusters in a single region. Each dedicated cluster consists of multiple hosts. You can create multiple instances on each host. For more information, see [What is ApsaraDB MyBase?](~~141455~~)
 *
 * @param request DescribeDedicatedHostGroupsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDedicatedHostGroupsResponse
 */
func (client *Client) DescribeDedicatedHostGroupsWithOptions(request *DescribeDedicatedHostGroupsRequest, runtime *util.RuntimeOptions) (_result *DescribeDedicatedHostGroupsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DedicatedHostGroupId)) {
		query["DedicatedHostGroupId"] = request.DedicatedHostGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ImageCategory)) {
		query["ImageCategory"] = request.ImageCategory
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDedicatedHostGroups"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDedicatedHostGroupsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Dedicated clusters allow you to manage a number of instances in a cluster at a time. You can create multiple dedicated clusters in a single region. Each dedicated cluster consists of multiple hosts. You can create multiple instances on each host. For more information, see [What is ApsaraDB MyBase?](~~141455~~)
 *
 * @param request DescribeDedicatedHostGroupsRequest
 * @return DescribeDedicatedHostGroupsResponse
 */
func (client *Client) DescribeDedicatedHostGroups(request *DescribeDedicatedHostGroupsRequest) (_result *DescribeDedicatedHostGroupsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDedicatedHostGroupsResponse{}
	_body, _err := client.DescribeDedicatedHostGroupsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Dedicated clusters allow you to manage a number of instances at a time. You can create multiple dedicated clusters in a single region. Each dedicated cluster consists of multiple hosts. You can create multiple instances on each host. For more information, see [What is ApsaraDB MyBase?](~~141455~~)
 *
 * @param request DescribeDedicatedHostsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDedicatedHostsResponse
 */
func (client *Client) DescribeDedicatedHostsWithOptions(request *DescribeDedicatedHostsRequest, runtime *util.RuntimeOptions) (_result *DescribeDedicatedHostsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AllocationStatus)) {
		query["AllocationStatus"] = request.AllocationStatus
	}

	if !tea.BoolValue(util.IsUnset(request.DedicatedHostGroupId)) {
		query["DedicatedHostGroupId"] = request.DedicatedHostGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.DedicatedHostId)) {
		query["DedicatedHostId"] = request.DedicatedHostId
	}

	if !tea.BoolValue(util.IsUnset(request.HostStatus)) {
		query["HostStatus"] = request.HostStatus
	}

	if !tea.BoolValue(util.IsUnset(request.HostType)) {
		query["HostType"] = request.HostType
	}

	if !tea.BoolValue(util.IsUnset(request.OrderId)) {
		query["OrderId"] = request.OrderId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ZoneId)) {
		query["ZoneId"] = request.ZoneId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDedicatedHosts"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDedicatedHostsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Dedicated clusters allow you to manage a number of instances at a time. You can create multiple dedicated clusters in a single region. Each dedicated cluster consists of multiple hosts. You can create multiple instances on each host. For more information, see [What is ApsaraDB MyBase?](~~141455~~)
 *
 * @param request DescribeDedicatedHostsRequest
 * @return DescribeDedicatedHostsResponse
 */
func (client *Client) DescribeDedicatedHosts(request *DescribeDedicatedHostsRequest) (_result *DescribeDedicatedHostsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDedicatedHostsResponse{}
	_body, _err := client.DescribeDedicatedHostsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Supported database engine
 * MySQL
 * > This operation is available only for instances that use local disks.
 * ### References
 * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
 * For more information about how to retain the data backup files of an instance after the instance is released, see [Configure automatic backup](~~98818~~).
 *
 * @param request DescribeDetachedBackupsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDetachedBackupsResponse
 */
func (client *Client) DescribeDetachedBackupsWithOptions(request *DescribeDetachedBackupsRequest, runtime *util.RuntimeOptions) (_result *DescribeDetachedBackupsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BackupId)) {
		query["BackupId"] = request.BackupId
	}

	if !tea.BoolValue(util.IsUnset(request.BackupMode)) {
		query["BackupMode"] = request.BackupMode
	}

	if !tea.BoolValue(util.IsUnset(request.BackupStatus)) {
		query["BackupStatus"] = request.BackupStatus
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.Region)) {
		query["Region"] = request.Region
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDetachedBackups"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDetachedBackupsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Supported database engine
 * MySQL
 * > This operation is available only for instances that use local disks.
 * ### References
 * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
 * For more information about how to retain the data backup files of an instance after the instance is released, see [Configure automatic backup](~~98818~~).
 *
 * @param request DescribeDetachedBackupsRequest
 * @return DescribeDetachedBackupsResponse
 */
func (client *Client) DescribeDetachedBackups(request *DescribeDetachedBackupsRequest) (_result *DescribeDetachedBackupsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDetachedBackupsResponse{}
	_body, _err := client.DescribeDetachedBackupsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * @deprecated
 * >  This operation is phased out.
 *
 * @param request DescribeDiagnosticReportListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDiagnosticReportListResponse
 */
// Deprecated
func (client *Client) DescribeDiagnosticReportListWithOptions(request *DescribeDiagnosticReportListRequest, runtime *util.RuntimeOptions) (_result *DescribeDiagnosticReportListResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDiagnosticReportList"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDiagnosticReportListResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * @deprecated
 * >  This operation is phased out.
 *
 * @param request DescribeDiagnosticReportListRequest
 * @return DescribeDiagnosticReportListResponse
 */
// Deprecated
func (client *Client) DescribeDiagnosticReportList(request *DescribeDiagnosticReportListRequest) (_result *DescribeDiagnosticReportListResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDiagnosticReportListResponse{}
	_body, _err := client.DescribeDiagnosticReportListWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Error logs contain the time when they were generated and the error messages.
 *
 * @param request DescribeErrorLogsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeErrorLogsResponse
 */
func (client *Client) DescribeErrorLogsWithOptions(request *DescribeErrorLogsRequest, runtime *util.RuntimeOptions) (_result *DescribeErrorLogsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeErrorLogs"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeErrorLogsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Error logs contain the time when they were generated and the error messages.
 *
 * @param request DescribeErrorLogsRequest
 * @return DescribeErrorLogsResponse
 */
func (client *Client) DescribeErrorLogs(request *DescribeErrorLogsRequest) (_result *DescribeErrorLogsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeErrorLogsResponse{}
	_body, _err := client.DescribeErrorLogsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The event history feature enables you to view the events that occurred within a region over a specific time range. Historical events include instance creation and parameter modification. For more information, see [View the event history of an ApsaraDB RDS instance](~~129759~~).
 * Before you call this operation, make sure that the event history feature is enabled. Otherwise, this operation fails.
 *
 * @param request DescribeEventsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeEventsResponse
 */
func (client *Client) DescribeEventsWithOptions(request *DescribeEventsRequest, runtime *util.RuntimeOptions) (_result *DescribeEventsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeEvents"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeEventsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The event history feature enables you to view the events that occurred within a region over a specific time range. Historical events include instance creation and parameter modification. For more information, see [View the event history of an ApsaraDB RDS instance](~~129759~~).
 * Before you call this operation, make sure that the event history feature is enabled. Otherwise, this operation fails.
 *
 * @param request DescribeEventsRequest
 * @return DescribeEventsResponse
 */
func (client *Client) DescribeEvents(request *DescribeEventsRequest) (_result *DescribeEventsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeEventsResponse{}
	_body, _err := client.DescribeEventsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 *
 * @param request DescribeGadInstancesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeGadInstancesResponse
 */
func (client *Client) DescribeGadInstancesWithOptions(request *DescribeGadInstancesRequest, runtime *util.RuntimeOptions) (_result *DescribeGadInstancesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.GadInstanceName)) {
		query["GadInstanceName"] = request.GadInstanceName
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeGadInstances"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeGadInstancesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 *
 * @param request DescribeGadInstancesRequest
 * @return DescribeGadInstancesResponse
 */
func (client *Client) DescribeGadInstances(request *DescribeGadInstancesRequest) (_result *DescribeGadInstancesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeGadInstancesResponse{}
	_body, _err := client.DescribeGadInstancesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * By default, Alibaba Cloud uses persistent connections to check the availability of an instance. For more information, see [What is availability detection?](~~207467~~)
 *
 * @param request DescribeHADiagnoseConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeHADiagnoseConfigResponse
 */
func (client *Client) DescribeHADiagnoseConfigWithOptions(request *DescribeHADiagnoseConfigRequest, runtime *util.RuntimeOptions) (_result *DescribeHADiagnoseConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeHADiagnoseConfig"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeHADiagnoseConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * By default, Alibaba Cloud uses persistent connections to check the availability of an instance. For more information, see [What is availability detection?](~~207467~~)
 *
 * @param request DescribeHADiagnoseConfigRequest
 * @return DescribeHADiagnoseConfigResponse
 */
func (client *Client) DescribeHADiagnoseConfig(request *DescribeHADiagnoseConfigRequest) (_result *DescribeHADiagnoseConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeHADiagnoseConfigResponse{}
	_body, _err := client.DescribeHADiagnoseConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * After a primary/secondary switchover is complete, the primary instance is demoted to the secondary instance and the secondary instance is promoted to primary. For more information, see [Switch workloads over between primary and secondary ApsaraDB RDS instances](~~96054~~).
 * When you call this operation, you must make sure that the instance runs RDS High-availability Edition, RDS Enterprise Edition, and RDS Cluster Edition. RDS Cluster Edition is supported for ApsaraDB RDS for MySQL and ApsaraDB RDS for SQL Server.
 *
 * @param request DescribeHASwitchConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeHASwitchConfigResponse
 */
func (client *Client) DescribeHASwitchConfigWithOptions(request *DescribeHASwitchConfigRequest, runtime *util.RuntimeOptions) (_result *DescribeHASwitchConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeHASwitchConfig"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeHASwitchConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * After a primary/secondary switchover is complete, the primary instance is demoted to the secondary instance and the secondary instance is promoted to primary. For more information, see [Switch workloads over between primary and secondary ApsaraDB RDS instances](~~96054~~).
 * When you call this operation, you must make sure that the instance runs RDS High-availability Edition, RDS Enterprise Edition, and RDS Cluster Edition. RDS Cluster Edition is supported for ApsaraDB RDS for MySQL and ApsaraDB RDS for SQL Server.
 *
 * @param request DescribeHASwitchConfigRequest
 * @return DescribeHASwitchConfigResponse
 */
func (client *Client) DescribeHASwitchConfig(request *DescribeHASwitchConfigRequest) (_result *DescribeHASwitchConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeHASwitchConfigResponse{}
	_body, _err := client.DescribeHASwitchConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * ### [](#)References
 * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * *   [Tasks of an ApsaraDB RDS for MySQL instance](~~474275~~)
 * *   [Tasks of an ApsaraDB RDS for PostrgreSQL instance](~~474537~~)
 * *   [Tasks of an ApsaraDB RDS for SQL Server instance](~~614826~~)
 *
 * @param request DescribeHistoryTasksRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeHistoryTasksResponse
 */
func (client *Client) DescribeHistoryTasksWithOptions(request *DescribeHistoryTasksRequest, runtime *util.RuntimeOptions) (_result *DescribeHistoryTasksResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.FromExecTime)) {
		query["FromExecTime"] = request.FromExecTime
	}

	if !tea.BoolValue(util.IsUnset(request.FromStartTime)) {
		query["FromStartTime"] = request.FromStartTime
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceType)) {
		query["InstanceType"] = request.InstanceType
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		query["Status"] = request.Status
	}

	if !tea.BoolValue(util.IsUnset(request.TaskId)) {
		query["TaskId"] = request.TaskId
	}

	if !tea.BoolValue(util.IsUnset(request.TaskType)) {
		query["TaskType"] = request.TaskType
	}

	if !tea.BoolValue(util.IsUnset(request.ToExecTime)) {
		query["ToExecTime"] = request.ToExecTime
	}

	if !tea.BoolValue(util.IsUnset(request.ToStartTime)) {
		query["ToStartTime"] = request.ToStartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeHistoryTasks"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeHistoryTasksResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * ### [](#)References
 * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * *   [Tasks of an ApsaraDB RDS for MySQL instance](~~474275~~)
 * *   [Tasks of an ApsaraDB RDS for PostrgreSQL instance](~~474537~~)
 * *   [Tasks of an ApsaraDB RDS for SQL Server instance](~~614826~~)
 *
 * @param request DescribeHistoryTasksRequest
 * @return DescribeHistoryTasksResponse
 */
func (client *Client) DescribeHistoryTasks(request *DescribeHistoryTasksRequest) (_result *DescribeHistoryTasksResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeHistoryTasksResponse{}
	_body, _err := client.DescribeHistoryTasksWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeHostGroupElasticStrategyParametersWithOptions(request *DescribeHostGroupElasticStrategyParametersRequest, runtime *util.RuntimeOptions) (_result *DescribeHostGroupElasticStrategyParametersResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DedicatedHostGroupName)) {
		query["DedicatedHostGroupName"] = request.DedicatedHostGroupName
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeHostGroupElasticStrategyParameters"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeHostGroupElasticStrategyParametersResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeHostGroupElasticStrategyParameters(request *DescribeHostGroupElasticStrategyParametersRequest) (_result *DescribeHostGroupElasticStrategyParametersResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeHostGroupElasticStrategyParametersResponse{}
	_body, _err := client.DescribeHostGroupElasticStrategyParametersWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * >  This operation is available only for instances that run SQL Server. If you require this operation, contact **Alibaba Cloud technical support**.
 * ### [](#)Prerequisites
 * The instance meets the following requirements:
 * *   The instance resides in a region other than the China (Zhangjiakou) region.
 * *   The instance runs RDS Basic Edition, RDS Cluster Edition, or RDS High-availability Edition. If your instance runs RDS High-availability Edition, make sure that the instance runs SQL Server 2012 or later.
 * *   The instance belongs to the general-purpose or dedicated instance family. The shared instance family is not supported.
 * *   The instance resides in a virtual private cloud (VPC). For more information about how to change the network type of an RDS instance, see [Change the network type](~~95707~~).
 * *   If the instance runs RDS High-availability Edition or RDS Cluster Edition, the instance is created on or after January 1, 2021. If the instance runs RDS Basic Edition, the instance is created on or after September 02, 2022. You can view the **Creation Time** parameter of an instance in the **Status** section of the **Basic Information** page in the ApsaraDB RDS console.
 * Your **Alibaba Cloud account** is used for logons.
 *
 * @param request DescribeHostWebShellRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeHostWebShellResponse
 */
func (client *Client) DescribeHostWebShellWithOptions(request *DescribeHostWebShellRequest, runtime *util.RuntimeOptions) (_result *DescribeHostWebShellResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AccountName)) {
		query["AccountName"] = request.AccountName
	}

	if !tea.BoolValue(util.IsUnset(request.AccountPassword)) {
		query["AccountPassword"] = request.AccountPassword
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.HostName)) {
		query["HostName"] = request.HostName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionID)) {
		query["RegionID"] = request.RegionID
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeHostWebShell"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeHostWebShellResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * >  This operation is available only for instances that run SQL Server. If you require this operation, contact **Alibaba Cloud technical support**.
 * ### [](#)Prerequisites
 * The instance meets the following requirements:
 * *   The instance resides in a region other than the China (Zhangjiakou) region.
 * *   The instance runs RDS Basic Edition, RDS Cluster Edition, or RDS High-availability Edition. If your instance runs RDS High-availability Edition, make sure that the instance runs SQL Server 2012 or later.
 * *   The instance belongs to the general-purpose or dedicated instance family. The shared instance family is not supported.
 * *   The instance resides in a virtual private cloud (VPC). For more information about how to change the network type of an RDS instance, see [Change the network type](~~95707~~).
 * *   If the instance runs RDS High-availability Edition or RDS Cluster Edition, the instance is created on or after January 1, 2021. If the instance runs RDS Basic Edition, the instance is created on or after September 02, 2022. You can view the **Creation Time** parameter of an instance in the **Status** section of the **Basic Information** page in the ApsaraDB RDS console.
 * Your **Alibaba Cloud account** is used for logons.
 *
 * @param request DescribeHostWebShellRequest
 * @return DescribeHostWebShellResponse
 */
func (client *Client) DescribeHostWebShell(request *DescribeHostWebShellRequest) (_result *DescribeHostWebShellResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeHostWebShellResponse{}
	_body, _err := client.DescribeHostWebShellWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeInstanceAutoRenewalAttributeWithOptions(request *DescribeInstanceAutoRenewalAttributeRequest, runtime *util.RuntimeOptions) (_result *DescribeInstanceAutoRenewalAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ProxyId)) {
		query["proxyId"] = request.ProxyId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeInstanceAutoRenewalAttribute"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeInstanceAutoRenewalAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeInstanceAutoRenewalAttribute(request *DescribeInstanceAutoRenewalAttributeRequest) (_result *DescribeInstanceAutoRenewalAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeInstanceAutoRenewalAttributeResponse{}
	_body, _err := client.DescribeInstanceAutoRenewalAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * ### [](#)References
 * *   [Use the cross-region backup feature of an ApsaraDB RDS for MySQL instance](~~120824~~)
 * *   [Use the cross-region backup feature for an ApsaraDB RDS for PostgreSQL instance](~~206671~~)
 * *   [Use the cross-region backup feature for an ApsaraDB RDS for SQL Server instance](~~187923~~)
 *
 * @param request DescribeInstanceCrossBackupPolicyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeInstanceCrossBackupPolicyResponse
 */
func (client *Client) DescribeInstanceCrossBackupPolicyWithOptions(request *DescribeInstanceCrossBackupPolicyRequest, runtime *util.RuntimeOptions) (_result *DescribeInstanceCrossBackupPolicyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeInstanceCrossBackupPolicy"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeInstanceCrossBackupPolicyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * ### [](#)References
 * *   [Use the cross-region backup feature of an ApsaraDB RDS for MySQL instance](~~120824~~)
 * *   [Use the cross-region backup feature for an ApsaraDB RDS for PostgreSQL instance](~~206671~~)
 * *   [Use the cross-region backup feature for an ApsaraDB RDS for SQL Server instance](~~187923~~)
 *
 * @param request DescribeInstanceCrossBackupPolicyRequest
 * @return DescribeInstanceCrossBackupPolicyResponse
 */
func (client *Client) DescribeInstanceCrossBackupPolicy(request *DescribeInstanceCrossBackupPolicyRequest) (_result *DescribeInstanceCrossBackupPolicyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeInstanceCrossBackupPolicyResponse{}
	_body, _err := client.DescribeInstanceCrossBackupPolicyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeInstanceKeywordsWithOptions(request *DescribeInstanceKeywordsRequest, runtime *util.RuntimeOptions) (_result *DescribeInstanceKeywordsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Key)) {
		query["Key"] = request.Key
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeInstanceKeywords"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeInstanceKeywordsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeInstanceKeywords(request *DescribeInstanceKeywordsRequest) (_result *DescribeInstanceKeywordsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeInstanceKeywordsResponse{}
	_body, _err := client.DescribeInstanceKeywordsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Supported database engines
 * *   RDS MySQL
 * *   RDS PostgreSQL
 * *   RDS SQL Server
 *
 * @param request DescribeInstanceLinkedWhitelistTemplateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeInstanceLinkedWhitelistTemplateResponse
 */
func (client *Client) DescribeInstanceLinkedWhitelistTemplateWithOptions(request *DescribeInstanceLinkedWhitelistTemplateRequest, runtime *util.RuntimeOptions) (_result *DescribeInstanceLinkedWhitelistTemplateResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InsName)) {
		query["InsName"] = request.InsName
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeInstanceLinkedWhitelistTemplate"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeInstanceLinkedWhitelistTemplateResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Supported database engines
 * *   RDS MySQL
 * *   RDS PostgreSQL
 * *   RDS SQL Server
 *
 * @param request DescribeInstanceLinkedWhitelistTemplateRequest
 * @return DescribeInstanceLinkedWhitelistTemplateResponse
 */
func (client *Client) DescribeInstanceLinkedWhitelistTemplate(request *DescribeInstanceLinkedWhitelistTemplateRequest) (_result *DescribeInstanceLinkedWhitelistTemplateResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeInstanceLinkedWhitelistTemplateResponse{}
	_body, _err := client.DescribeInstanceLinkedWhitelistTemplateWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   MariaDB
 *
 * @param request DescribeLocalAvailableRecoveryTimeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeLocalAvailableRecoveryTimeResponse
 */
func (client *Client) DescribeLocalAvailableRecoveryTimeWithOptions(request *DescribeLocalAvailableRecoveryTimeRequest, runtime *util.RuntimeOptions) (_result *DescribeLocalAvailableRecoveryTimeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Region)) {
		query["Region"] = request.Region
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeLocalAvailableRecoveryTime"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeLocalAvailableRecoveryTimeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   MariaDB
 *
 * @param request DescribeLocalAvailableRecoveryTimeRequest
 * @return DescribeLocalAvailableRecoveryTimeResponse
 */
func (client *Client) DescribeLocalAvailableRecoveryTime(request *DescribeLocalAvailableRecoveryTimeRequest) (_result *DescribeLocalAvailableRecoveryTimeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeLocalAvailableRecoveryTimeResponse{}
	_body, _err := client.DescribeLocalAvailableRecoveryTimeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * RDS SQL Server
 * >  You can call the [DescribeBinlogFiles](~~610550~~) operation to query the log files of other database engines.
 *
 * @param request DescribeLogBackupFilesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeLogBackupFilesResponse
 */
func (client *Client) DescribeLogBackupFilesWithOptions(request *DescribeLogBackupFilesRequest, runtime *util.RuntimeOptions) (_result *DescribeLogBackupFilesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeLogBackupFiles"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeLogBackupFilesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * RDS SQL Server
 * >  You can call the [DescribeBinlogFiles](~~610550~~) operation to query the log files of other database engines.
 *
 * @param request DescribeLogBackupFilesRequest
 * @return DescribeLogBackupFilesResponse
 */
func (client *Client) DescribeLogBackupFiles(request *DescribeLogBackupFilesRequest) (_result *DescribeLogBackupFilesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeLogBackupFilesResponse{}
	_body, _err := client.DescribeLogBackupFilesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeMarketingActivityWithOptions(request *DescribeMarketingActivityRequest, runtime *util.RuntimeOptions) (_result *DescribeMarketingActivityResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AliUid)) {
		query["AliUid"] = request.AliUid
	}

	if !tea.BoolValue(util.IsUnset(request.Bid)) {
		query["Bid"] = request.Bid
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.UpgradeCode)) {
		query["UpgradeCode"] = request.UpgradeCode
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeMarketingActivity"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeMarketingActivityResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeMarketingActivity(request *DescribeMarketingActivityRequest) (_result *DescribeMarketingActivityResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeMarketingActivityResponse{}
	_body, _err := client.DescribeMarketingActivityWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * MySQL
 * > This operation is available for RDS instances that run MySQL 8.0, MySQL 5.7, and MySQL 5.6 on RDS High-availability Edition with local disks.
 * ### [](#)Description
 * Before you call the [RestoreTable](~~131510~~) operation to restore individual databases or tables of an ApsaraDB RDS for MySQL instance, you can call this operation to query the information about the databases and tables that can be restored. For more information, see [Restore individual databases and tables of an ApsaraDB RDS for MySQL instance](~~103175~~).
 *
 * @param request DescribeMetaListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeMetaListResponse
 */
func (client *Client) DescribeMetaListWithOptions(request *DescribeMetaListRequest, runtime *util.RuntimeOptions) (_result *DescribeMetaListResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BackupSetID)) {
		query["BackupSetID"] = request.BackupSetID
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.GetDbName)) {
		query["GetDbName"] = request.GetDbName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageIndex)) {
		query["PageIndex"] = request.PageIndex
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.Pattern)) {
		query["Pattern"] = request.Pattern
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RestoreTime)) {
		query["RestoreTime"] = request.RestoreTime
	}

	if !tea.BoolValue(util.IsUnset(request.RestoreType)) {
		query["RestoreType"] = request.RestoreType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeMetaList"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeMetaListResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * MySQL
 * > This operation is available for RDS instances that run MySQL 8.0, MySQL 5.7, and MySQL 5.6 on RDS High-availability Edition with local disks.
 * ### [](#)Description
 * Before you call the [RestoreTable](~~131510~~) operation to restore individual databases or tables of an ApsaraDB RDS for MySQL instance, you can call this operation to query the information about the databases and tables that can be restored. For more information, see [Restore individual databases and tables of an ApsaraDB RDS for MySQL instance](~~103175~~).
 *
 * @param request DescribeMetaListRequest
 * @return DescribeMetaListResponse
 */
func (client *Client) DescribeMetaList(request *DescribeMetaListRequest) (_result *DescribeMetaListResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeMetaListResponse{}
	_body, _err := client.DescribeMetaListWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   SQL Server
 *
 * @param request DescribeMigrateTaskByIdRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeMigrateTaskByIdResponse
 */
func (client *Client) DescribeMigrateTaskByIdWithOptions(request *DescribeMigrateTaskByIdRequest, runtime *util.RuntimeOptions) (_result *DescribeMigrateTaskByIdResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.MigrateTaskId)) {
		query["MigrateTaskId"] = request.MigrateTaskId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeMigrateTaskById"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeMigrateTaskByIdResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   SQL Server
 *
 * @param request DescribeMigrateTaskByIdRequest
 * @return DescribeMigrateTaskByIdResponse
 */
func (client *Client) DescribeMigrateTaskById(request *DescribeMigrateTaskByIdRequest) (_result *DescribeMigrateTaskByIdResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeMigrateTaskByIdResponse{}
	_body, _err := client.DescribeMigrateTaskByIdWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * This operation allows you to query the migration tasks that are created for the instance over the last week.
 * >
 * *   This operation is supported only for migration tasks that are created to migrate full backup files.
 * *   This operation is not supported for instances that run SQL Server 2017 on RDS Cluster Edition.
 *
 * @param request DescribeMigrateTasksRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeMigrateTasksResponse
 */
func (client *Client) DescribeMigrateTasksWithOptions(request *DescribeMigrateTasksRequest, runtime *util.RuntimeOptions) (_result *DescribeMigrateTasksResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeMigrateTasks"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeMigrateTasksResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * This operation allows you to query the migration tasks that are created for the instance over the last week.
 * >
 * *   This operation is supported only for migration tasks that are created to migrate full backup files.
 * *   This operation is not supported for instances that run SQL Server 2017 on RDS Cluster Edition.
 *
 * @param request DescribeMigrateTasksRequest
 * @return DescribeMigrateTasksResponse
 */
func (client *Client) DescribeMigrateTasks(request *DescribeMigrateTasksRequest) (_result *DescribeMigrateTasksResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeMigrateTasksResponse{}
	_body, _err := client.DescribeMigrateTasksWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * RDS PostgreSQL
 *
 * @param request DescribeModifyPGHbaConfigLogRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeModifyPGHbaConfigLogResponse
 */
func (client *Client) DescribeModifyPGHbaConfigLogWithOptions(request *DescribeModifyPGHbaConfigLogRequest, runtime *util.RuntimeOptions) (_result *DescribeModifyPGHbaConfigLogResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeModifyPGHbaConfigLog"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeModifyPGHbaConfigLogResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * RDS PostgreSQL
 *
 * @param request DescribeModifyPGHbaConfigLogRequest
 * @return DescribeModifyPGHbaConfigLogResponse
 */
func (client *Client) DescribeModifyPGHbaConfigLog(request *DescribeModifyPGHbaConfigLogRequest) (_result *DescribeModifyPGHbaConfigLogResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeModifyPGHbaConfigLogResponse{}
	_body, _err := client.DescribeModifyPGHbaConfigLogWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 *
 * @param request DescribeModifyParameterLogRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeModifyParameterLogResponse
 */
func (client *Client) DescribeModifyParameterLogWithOptions(request *DescribeModifyParameterLogRequest, runtime *util.RuntimeOptions) (_result *DescribeModifyParameterLogResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeModifyParameterLog"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeModifyParameterLogResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 *
 * @param request DescribeModifyParameterLogRequest
 * @return DescribeModifyParameterLogResponse
 */
func (client *Client) DescribeModifyParameterLog(request *DescribeModifyParameterLogRequest) (_result *DescribeModifyParameterLogResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeModifyParameterLogResponse{}
	_body, _err := client.DescribeModifyParameterLogWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   SQL Server
 * ### [Usage notes](#)
 * This operation is not supported for instances that run SQL Server 2017 EE or SQL Server 2019 EE.
 *
 * @param request DescribeOssDownloadsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeOssDownloadsResponse
 */
func (client *Client) DescribeOssDownloadsWithOptions(request *DescribeOssDownloadsRequest, runtime *util.RuntimeOptions) (_result *DescribeOssDownloadsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.MigrateTaskId)) {
		query["MigrateTaskId"] = request.MigrateTaskId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeOssDownloads"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeOssDownloadsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   SQL Server
 * ### [Usage notes](#)
 * This operation is not supported for instances that run SQL Server 2017 EE or SQL Server 2019 EE.
 *
 * @param request DescribeOssDownloadsRequest
 * @return DescribeOssDownloadsResponse
 */
func (client *Client) DescribeOssDownloads(request *DescribeOssDownloadsRequest) (_result *DescribeOssDownloadsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeOssDownloadsResponse{}
	_body, _err := client.DescribeOssDownloadsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * RDS PostgreSQL
 *
 * @param request DescribePGHbaConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePGHbaConfigResponse
 */
func (client *Client) DescribePGHbaConfigWithOptions(request *DescribePGHbaConfigRequest, runtime *util.RuntimeOptions) (_result *DescribePGHbaConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribePGHbaConfig"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribePGHbaConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * RDS PostgreSQL
 *
 * @param request DescribePGHbaConfigRequest
 * @return DescribePGHbaConfigResponse
 */
func (client *Client) DescribePGHbaConfig(request *DescribePGHbaConfigRequest) (_result *DescribePGHbaConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribePGHbaConfigResponse{}
	_body, _err := client.DescribePGHbaConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * ### [](#)References
 * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * *   [Use a parameter template for an ApsaraDB RDS for MySQL instance](~~130565~~)
 * *   [Use a parameter template for an ApsaraDB RDS for PostgreSQL instance](~~457176~~)
 *
 * @param request DescribeParameterGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeParameterGroupResponse
 */
func (client *Client) DescribeParameterGroupWithOptions(request *DescribeParameterGroupRequest, runtime *util.RuntimeOptions) (_result *DescribeParameterGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ParameterGroupId)) {
		query["ParameterGroupId"] = request.ParameterGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeParameterGroup"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeParameterGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * ### [](#)References
 * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * *   [Use a parameter template for an ApsaraDB RDS for MySQL instance](~~130565~~)
 * *   [Use a parameter template for an ApsaraDB RDS for PostgreSQL instance](~~457176~~)
 *
 * @param request DescribeParameterGroupRequest
 * @return DescribeParameterGroupResponse
 */
func (client *Client) DescribeParameterGroup(request *DescribeParameterGroupRequest) (_result *DescribeParameterGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeParameterGroupResponse{}
	_body, _err := client.DescribeParameterGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 * ### [](#)References
 * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * *   [Use a parameter template to configure the parameters of ApsaraDB RDS for MySQL instances](~~130565~~)
 * *   [Use a parameter template to configure the parameters of ApsaraDB RDS for PostgreSQL instances](~~457176~~)
 *
 * @param request DescribeParameterGroupsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeParameterGroupsResponse
 */
func (client *Client) DescribeParameterGroupsWithOptions(request *DescribeParameterGroupsRequest, runtime *util.RuntimeOptions) (_result *DescribeParameterGroupsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeParameterGroups"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeParameterGroupsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 * ### [](#)References
 * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * *   [Use a parameter template to configure the parameters of ApsaraDB RDS for MySQL instances](~~130565~~)
 * *   [Use a parameter template to configure the parameters of ApsaraDB RDS for PostgreSQL instances](~~457176~~)
 *
 * @param request DescribeParameterGroupsRequest
 * @return DescribeParameterGroupsResponse
 */
func (client *Client) DescribeParameterGroups(request *DescribeParameterGroupsRequest) (_result *DescribeParameterGroupsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeParameterGroupsResponse{}
	_body, _err := client.DescribeParameterGroupsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 *
 * @param request DescribeParameterTemplatesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeParameterTemplatesResponse
 */
func (client *Client) DescribeParameterTemplatesWithOptions(request *DescribeParameterTemplatesRequest, runtime *util.RuntimeOptions) (_result *DescribeParameterTemplatesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Category)) {
		query["Category"] = request.Category
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Engine)) {
		query["Engine"] = request.Engine
	}

	if !tea.BoolValue(util.IsUnset(request.EngineVersion)) {
		query["EngineVersion"] = request.EngineVersion
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeParameterTemplates"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeParameterTemplatesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 *
 * @param request DescribeParameterTemplatesRequest
 * @return DescribeParameterTemplatesResponse
 */
func (client *Client) DescribeParameterTemplates(request *DescribeParameterTemplatesRequest) (_result *DescribeParameterTemplatesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeParameterTemplatesResponse{}
	_body, _err := client.DescribeParameterTemplatesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Applicable engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 *
 * @param request DescribeParametersRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeParametersResponse
 */
func (client *Client) DescribeParametersWithOptions(request *DescribeParametersRequest, runtime *util.RuntimeOptions) (_result *DescribeParametersResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeParameters"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeParametersResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Applicable engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 *
 * @param request DescribeParametersRequest
 * @return DescribeParametersResponse
 */
func (client *Client) DescribeParameters(request *DescribeParametersRequest) (_result *DescribeParametersResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeParametersResponse{}
	_body, _err := client.DescribeParametersWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Supported database engines
 * RDS PostgreSQL
 * ### References
 * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * [Manage extensions](~~2402409~~)
 *
 * @param request DescribePostgresExtensionsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePostgresExtensionsResponse
 */
func (client *Client) DescribePostgresExtensionsWithOptions(request *DescribePostgresExtensionsRequest, runtime *util.RuntimeOptions) (_result *DescribePostgresExtensionsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.DBName)) {
		query["DBName"] = request.DBName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribePostgresExtensions"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribePostgresExtensionsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Supported database engines
 * RDS PostgreSQL
 * ### References
 * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * [Manage extensions](~~2402409~~)
 *
 * @param request DescribePostgresExtensionsRequest
 * @return DescribePostgresExtensionsResponse
 */
func (client *Client) DescribePostgresExtensions(request *DescribePostgresExtensionsRequest) (_result *DescribePostgresExtensionsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribePostgresExtensionsResponse{}
	_body, _err := client.DescribePostgresExtensionsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 *
 * @param tmpReq DescribePriceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePriceResponse
 */
func (client *Client) DescribePriceWithOptions(tmpReq *DescribePriceRequest, runtime *util.RuntimeOptions) (_result *DescribePriceResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &DescribePriceShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.DBNode)) {
		request.DBNodeShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.DBNode, tea.String("DBNode"), tea.String("json"))
	}

	if !tea.BoolValue(util.IsUnset(tmpReq.ServerlessConfig)) {
		request.ServerlessConfigShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.ServerlessConfig, tea.String("ServerlessConfig"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.CommodityCode)) {
		query["CommodityCode"] = request.CommodityCode
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceClass)) {
		query["DBInstanceClass"] = request.DBInstanceClass
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceStorage)) {
		query["DBInstanceStorage"] = request.DBInstanceStorage
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceStorageType)) {
		query["DBInstanceStorageType"] = request.DBInstanceStorageType
	}

	if !tea.BoolValue(util.IsUnset(request.DBNodeShrink)) {
		query["DBNode"] = request.DBNodeShrink
	}

	if !tea.BoolValue(util.IsUnset(request.Engine)) {
		query["Engine"] = request.Engine
	}

	if !tea.BoolValue(util.IsUnset(request.EngineVersion)) {
		query["EngineVersion"] = request.EngineVersion
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceUsedType)) {
		query["InstanceUsedType"] = request.InstanceUsedType
	}

	if !tea.BoolValue(util.IsUnset(request.OrderType)) {
		query["OrderType"] = request.OrderType
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PayType)) {
		query["PayType"] = request.PayType
	}

	if !tea.BoolValue(util.IsUnset(request.Quantity)) {
		query["Quantity"] = request.Quantity
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ServerlessConfigShrink)) {
		query["ServerlessConfig"] = request.ServerlessConfigShrink
	}

	if !tea.BoolValue(util.IsUnset(request.TimeType)) {
		query["TimeType"] = request.TimeType
	}

	if !tea.BoolValue(util.IsUnset(request.UsedTime)) {
		query["UsedTime"] = request.UsedTime
	}

	if !tea.BoolValue(util.IsUnset(request.ZoneId)) {
		query["ZoneId"] = request.ZoneId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribePrice"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribePriceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 *
 * @param request DescribePriceRequest
 * @return DescribePriceResponse
 */
func (client *Client) DescribePrice(request *DescribePriceRequest) (_result *DescribePriceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribePriceResponse{}
	_body, _err := client.DescribePriceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeQuickSaleConfigWithOptions(request *DescribeQuickSaleConfigRequest, runtime *util.RuntimeOptions) (_result *DescribeQuickSaleConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Commodity)) {
		query["Commodity"] = request.Commodity
	}

	if !tea.BoolValue(util.IsUnset(request.Engine)) {
		query["Engine"] = request.Engine
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeQuickSaleConfig"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeQuickSaleConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeQuickSaleConfig(request *DescribeQuickSaleConfigRequest) (_result *DescribeQuickSaleConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeQuickSaleConfigResponse{}
	_body, _err := client.DescribeQuickSaleConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * @deprecated
 *
 * @param request DescribeRdsResourceSettingsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeRdsResourceSettingsResponse
 */
// Deprecated
func (client *Client) DescribeRdsResourceSettingsWithOptions(request *DescribeRdsResourceSettingsRequest, runtime *util.RuntimeOptions) (_result *DescribeRdsResourceSettingsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceNiche)) {
		query["ResourceNiche"] = request.ResourceNiche
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeRdsResourceSettings"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeRdsResourceSettingsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * @deprecated
 *
 * @param request DescribeRdsResourceSettingsRequest
 * @return DescribeRdsResourceSettingsResponse
 */
// Deprecated
func (client *Client) DescribeRdsResourceSettings(request *DescribeRdsResourceSettingsRequest) (_result *DescribeRdsResourceSettingsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeRdsResourceSettingsResponse{}
	_body, _err := client.DescribeRdsResourceSettingsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Before you call this operation, make sure that the following requirements are met:
 * *   The primary instance must run the MySQL or PostgreSQL database engine.
 * *   The primary instance must be attached with a read-only instance.
 *
 * @param request DescribeReadDBInstanceDelayRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeReadDBInstanceDelayResponse
 */
func (client *Client) DescribeReadDBInstanceDelayWithOptions(request *DescribeReadDBInstanceDelayRequest, runtime *util.RuntimeOptions) (_result *DescribeReadDBInstanceDelayResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ReadInstanceId)) {
		query["ReadInstanceId"] = request.ReadInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeReadDBInstanceDelay"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeReadDBInstanceDelayResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Before you call this operation, make sure that the following requirements are met:
 * *   The primary instance must run the MySQL or PostgreSQL database engine.
 * *   The primary instance must be attached with a read-only instance.
 *
 * @param request DescribeReadDBInstanceDelayRequest
 * @return DescribeReadDBInstanceDelayResponse
 */
func (client *Client) DescribeReadDBInstanceDelay(request *DescribeReadDBInstanceDelayRequest) (_result *DescribeReadDBInstanceDelayResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeReadDBInstanceDelayResponse{}
	_body, _err := client.DescribeReadDBInstanceDelayWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 *
 * @param request DescribeRegionInfosRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeRegionInfosResponse
 */
func (client *Client) DescribeRegionInfosWithOptions(request *DescribeRegionInfosRequest, runtime *util.RuntimeOptions) (_result *DescribeRegionInfosResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeRegionInfos"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeRegionInfosResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 *
 * @param request DescribeRegionInfosRequest
 * @return DescribeRegionInfosResponse
 */
func (client *Client) DescribeRegionInfos(request *DescribeRegionInfosRequest) (_result *DescribeRegionInfosResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeRegionInfosResponse{}
	_body, _err := client.DescribeRegionInfosWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Before you call the [CreateDBInstance](~~26228~~) operation to create an RDS instance, you can call the DescribeRegions operation to query the available regions and zones.
 * >  If a zone supports the multi-zone deployment method, the value of the ZoneId parameter for the zone contains an MAZ part. Examples: cn-hangzhou-MAZ6(b,f) and cn-hangzhou-MAZ5(b,e,f).
 *
 * @param request DescribeRegionsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeRegionsResponse
 */
func (client *Client) DescribeRegionsWithOptions(request *DescribeRegionsRequest, runtime *util.RuntimeOptions) (_result *DescribeRegionsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeRegions"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeRegionsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Before you call the [CreateDBInstance](~~26228~~) operation to create an RDS instance, you can call the DescribeRegions operation to query the available regions and zones.
 * >  If a zone supports the multi-zone deployment method, the value of the ZoneId parameter for the zone contains an MAZ part. Examples: cn-hangzhou-MAZ6(b,f) and cn-hangzhou-MAZ5(b,e,f).
 *
 * @param request DescribeRegionsRequest
 * @return DescribeRegionsResponse
 */
func (client *Client) DescribeRegions(request *DescribeRegionsRequest) (_result *DescribeRegionsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeRegionsResponse{}
	_body, _err := client.DescribeRegionsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 *
 * @param request DescribeRenewalPriceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeRenewalPriceResponse
 */
func (client *Client) DescribeRenewalPriceWithOptions(request *DescribeRenewalPriceRequest, runtime *util.RuntimeOptions) (_result *DescribeRenewalPriceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BusinessInfo)) {
		query["BusinessInfo"] = request.BusinessInfo
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceClass)) {
		query["DBInstanceClass"] = request.DBInstanceClass
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OrderType)) {
		query["OrderType"] = request.OrderType
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PayType)) {
		query["PayType"] = request.PayType
	}

	if !tea.BoolValue(util.IsUnset(request.Quantity)) {
		query["Quantity"] = request.Quantity
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.TimeType)) {
		query["TimeType"] = request.TimeType
	}

	if !tea.BoolValue(util.IsUnset(request.UsedTime)) {
		query["UsedTime"] = request.UsedTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeRenewalPrice"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeRenewalPriceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 *
 * @param request DescribeRenewalPriceRequest
 * @return DescribeRenewalPriceResponse
 */
func (client *Client) DescribeRenewalPrice(request *DescribeRenewalPriceRequest) (_result *DescribeRenewalPriceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeRenewalPriceResponse{}
	_body, _err := client.DescribeRenewalPriceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeResourceDetailsWithOptions(request *DescribeResourceDetailsRequest, runtime *util.RuntimeOptions) (_result *DescribeResourceDetailsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeResourceDetails"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeResourceDetailsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeResourceDetails(request *DescribeResourceDetailsRequest) (_result *DescribeResourceDetailsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeResourceDetailsResponse{}
	_body, _err := client.DescribeResourceDetailsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 *
 * @param request DescribeResourceUsageRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeResourceUsageResponse
 */
func (client *Client) DescribeResourceUsageWithOptions(request *DescribeResourceUsageRequest, runtime *util.RuntimeOptions) (_result *DescribeResourceUsageResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeResourceUsage"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeResourceUsageResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 *
 * @param request DescribeResourceUsageRequest
 * @return DescribeResourceUsageResponse
 */
func (client *Client) DescribeResourceUsage(request *DescribeResourceUsageRequest) (_result *DescribeResourceUsageResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeResourceUsageResponse{}
	_body, _err := client.DescribeResourceUsageWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * This operation is applicable to the following database engine versions:
 * *   MySQL
 * *   SQL Server 2008 R2
 * *   PostgreSQL
 *
 * @param request DescribeSQLCollectorPolicyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSQLCollectorPolicyResponse
 */
func (client *Client) DescribeSQLCollectorPolicyWithOptions(request *DescribeSQLCollectorPolicyRequest, runtime *util.RuntimeOptions) (_result *DescribeSQLCollectorPolicyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeSQLCollectorPolicy"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeSQLCollectorPolicyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * This operation is applicable to the following database engine versions:
 * *   MySQL
 * *   SQL Server 2008 R2
 * *   PostgreSQL
 *
 * @param request DescribeSQLCollectorPolicyRequest
 * @return DescribeSQLCollectorPolicyResponse
 */
func (client *Client) DescribeSQLCollectorPolicy(request *DescribeSQLCollectorPolicyRequest) (_result *DescribeSQLCollectorPolicyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeSQLCollectorPolicyResponse{}
	_body, _err := client.DescribeSQLCollectorPolicyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The SQL explorer feature must be enabled for the instance.
 * The instance must run MySQL. For more information, see [SQL Explorer](~~96123~~).
 *
 * @param request DescribeSQLCollectorRetentionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSQLCollectorRetentionResponse
 */
func (client *Client) DescribeSQLCollectorRetentionWithOptions(request *DescribeSQLCollectorRetentionRequest, runtime *util.RuntimeOptions) (_result *DescribeSQLCollectorRetentionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeSQLCollectorRetention"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeSQLCollectorRetentionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The SQL explorer feature must be enabled for the instance.
 * The instance must run MySQL. For more information, see [SQL Explorer](~~96123~~).
 *
 * @param request DescribeSQLCollectorRetentionRequest
 * @return DescribeSQLCollectorRetentionResponse
 */
func (client *Client) DescribeSQLCollectorRetention(request *DescribeSQLCollectorRetentionRequest) (_result *DescribeSQLCollectorRetentionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeSQLCollectorRetentionResponse{}
	_body, _err := client.DescribeSQLCollectorRetentionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Before you call this operation, make sure that the instance runs one of the following database engines:
 * *   MySQL
 * *   SQL Server 2008 R2
 * *   PostgreSQL
 * >
 * *   The DescribeSQLLogFiles operation cannot be called to query the log files that are generated by SQL Explorer Trial Edition for an ApsaraDB RDS for MySQL instance.
 * *   The DescribeSQLLogFiles operation cannot be called to query the log files that are generated by the SQL Explorer feature and manually exported from the ApsaraDB RDS console. The DescribeSQLLogFiles operation can be called to query the SQL Explorer log files that are generated by calling the [DescribeSQLLogRecords](~~610533~~) operation with the request parameter **Form** set to **File**.
 *
 * @param request DescribeSQLLogFilesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSQLLogFilesResponse
 */
func (client *Client) DescribeSQLLogFilesWithOptions(request *DescribeSQLLogFilesRequest, runtime *util.RuntimeOptions) (_result *DescribeSQLLogFilesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.FileName)) {
		query["FileName"] = request.FileName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeSQLLogFiles"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeSQLLogFilesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Before you call this operation, make sure that the instance runs one of the following database engines:
 * *   MySQL
 * *   SQL Server 2008 R2
 * *   PostgreSQL
 * >
 * *   The DescribeSQLLogFiles operation cannot be called to query the log files that are generated by SQL Explorer Trial Edition for an ApsaraDB RDS for MySQL instance.
 * *   The DescribeSQLLogFiles operation cannot be called to query the log files that are generated by the SQL Explorer feature and manually exported from the ApsaraDB RDS console. The DescribeSQLLogFiles operation can be called to query the SQL Explorer log files that are generated by calling the [DescribeSQLLogRecords](~~610533~~) operation with the request parameter **Form** set to **File**.
 *
 * @param request DescribeSQLLogFilesRequest
 * @return DescribeSQLLogFilesResponse
 */
func (client *Client) DescribeSQLLogFiles(request *DescribeSQLLogFilesRequest) (_result *DescribeSQLLogFilesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeSQLLogFilesResponse{}
	_body, _err := client.DescribeSQLLogFilesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Before you call this operation, make sure that the instance runs one of the following database engines:
 * *   MySQL
 * *   SQL Server
 * *   PostgreSQL
 * >
 * *   You can call this operation up to 1,000 times per minute per account. The calls initiated by using both your Alibaba Cloud account and RAM users within your Alibaba Cloud account are counted.
 * *   This operation cannot be used to query the logs that are generated by SQL Explorer Trial Edition for an ApsaraDB RDS for MySQL instance.
 * *   When you call this operation and set the **Form** parameter to **File** to generate an audit file, a maximum of 1 million log entries can be recorded in the audit file, and you cannot filter log entries by keyword.
 *
 * @param request DescribeSQLLogRecordsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSQLLogRecordsResponse
 */
func (client *Client) DescribeSQLLogRecordsWithOptions(request *DescribeSQLLogRecordsRequest, runtime *util.RuntimeOptions) (_result *DescribeSQLLogRecordsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Database)) {
		query["Database"] = request.Database
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.Form)) {
		query["Form"] = request.Form
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.QueryKeywords)) {
		query["QueryKeywords"] = request.QueryKeywords
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SQLId)) {
		query["SQLId"] = request.SQLId
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	if !tea.BoolValue(util.IsUnset(request.User)) {
		query["User"] = request.User
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeSQLLogRecords"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeSQLLogRecordsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Before you call this operation, make sure that the instance runs one of the following database engines:
 * *   MySQL
 * *   SQL Server
 * *   PostgreSQL
 * >
 * *   You can call this operation up to 1,000 times per minute per account. The calls initiated by using both your Alibaba Cloud account and RAM users within your Alibaba Cloud account are counted.
 * *   This operation cannot be used to query the logs that are generated by SQL Explorer Trial Edition for an ApsaraDB RDS for MySQL instance.
 * *   When you call this operation and set the **Form** parameter to **File** to generate an audit file, a maximum of 1 million log entries can be recorded in the audit file, and you cannot filter log entries by keyword.
 *
 * @param request DescribeSQLLogRecordsRequest
 * @return DescribeSQLLogRecordsResponse
 */
func (client *Client) DescribeSQLLogRecords(request *DescribeSQLLogRecordsRequest) (_result *DescribeSQLLogRecordsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeSQLLogRecordsResponse{}
	_body, _err := client.DescribeSQLLogRecordsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeSQLLogReportListWithOptions(request *DescribeSQLLogReportListRequest, runtime *util.RuntimeOptions) (_result *DescribeSQLLogReportListResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeSQLLogReportList"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeSQLLogReportListResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeSQLLogReportList(request *DescribeSQLLogReportListRequest) (_result *DescribeSQLLogReportListResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeSQLLogReportListResponse{}
	_body, _err := client.DescribeSQLLogReportListWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engine
 * *   MySQL
 *
 * @param request DescribeSecretsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSecretsResponse
 */
func (client *Client) DescribeSecretsWithOptions(request *DescribeSecretsRequest, runtime *util.RuntimeOptions) (_result *DescribeSecretsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DbInstanceId)) {
		query["DbInstanceId"] = request.DbInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Engine)) {
		query["Engine"] = request.Engine
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeSecrets"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeSecretsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engine
 * *   MySQL
 *
 * @param request DescribeSecretsRequest
 * @return DescribeSecretsResponse
 */
func (client *Client) DescribeSecrets(request *DescribeSecretsRequest) (_result *DescribeSecretsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeSecretsResponse{}
	_body, _err := client.DescribeSecretsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * After an RDS instance is added to an ECS security group, all ECS instances in the security group can access the RDS instance. For more information, see [Configure a whitelist for an RDS instance](~~96118~~).
 *
 * @param request DescribeSecurityGroupConfigurationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSecurityGroupConfigurationResponse
 */
func (client *Client) DescribeSecurityGroupConfigurationWithOptions(request *DescribeSecurityGroupConfigurationRequest, runtime *util.RuntimeOptions) (_result *DescribeSecurityGroupConfigurationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeSecurityGroupConfiguration"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeSecurityGroupConfigurationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * After an RDS instance is added to an ECS security group, all ECS instances in the security group can access the RDS instance. For more information, see [Configure a whitelist for an RDS instance](~~96118~~).
 *
 * @param request DescribeSecurityGroupConfigurationRequest
 * @return DescribeSecurityGroupConfigurationResponse
 */
func (client *Client) DescribeSecurityGroupConfiguration(request *DescribeSecurityGroupConfigurationRequest) (_result *DescribeSecurityGroupConfigurationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeSecurityGroupConfigurationResponse{}
	_body, _err := client.DescribeSecurityGroupConfigurationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * This operation is available only for ApsaraDB RDS for PostgreSQL instances.
 *
 * @param request DescribeSlotsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSlotsResponse
 */
func (client *Client) DescribeSlotsWithOptions(request *DescribeSlotsRequest, runtime *util.RuntimeOptions) (_result *DescribeSlotsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeSlots"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeSlotsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * This operation is available only for ApsaraDB RDS for PostgreSQL instances.
 *
 * @param request DescribeSlotsRequest
 * @return DescribeSlotsResponse
 */
func (client *Client) DescribeSlots(request *DescribeSlotsRequest) (_result *DescribeSlotsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeSlotsResponse{}
	_body, _err := client.DescribeSlotsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 * ### Precautions
 * The response parameters returned by this operation are updated every minute.
 *
 * @param request DescribeSlowLogRecordsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSlowLogRecordsResponse
 */
func (client *Client) DescribeSlowLogRecordsWithOptions(request *DescribeSlowLogRecordsRequest, runtime *util.RuntimeOptions) (_result *DescribeSlowLogRecordsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.DBName)) {
		query["DBName"] = request.DBName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.NodeId)) {
		query["NodeId"] = request.NodeId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SQLHASH)) {
		query["SQLHASH"] = request.SQLHASH
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeSlowLogRecords"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeSlowLogRecordsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 * ### Precautions
 * The response parameters returned by this operation are updated every minute.
 *
 * @param request DescribeSlowLogRecordsRequest
 * @return DescribeSlowLogRecordsResponse
 */
func (client *Client) DescribeSlowLogRecords(request *DescribeSlowLogRecordsRequest) (_result *DescribeSlowLogRecordsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeSlowLogRecordsResponse{}
	_body, _err := client.DescribeSlowLogRecordsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 *     **
 *     **Note**MySQL 5.7 on RDS Basic Edition is not supported.
 * *   SQL Server
 *     **
 *     **Note**Only SQL Server 2008 R2 is supported.
 * *   MariaDB
 * ### Usage notes
 * Slow query logs are not collected in real time and may show a latency of 6 hours to 8 hours.
 *
 * @param request DescribeSlowLogsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSlowLogsResponse
 */
func (client *Client) DescribeSlowLogsWithOptions(request *DescribeSlowLogsRequest, runtime *util.RuntimeOptions) (_result *DescribeSlowLogsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.DBName)) {
		query["DBName"] = request.DBName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SortKey)) {
		query["SortKey"] = request.SortKey
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeSlowLogs"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeSlowLogsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 *     **
 *     **Note**MySQL 5.7 on RDS Basic Edition is not supported.
 * *   SQL Server
 *     **
 *     **Note**Only SQL Server 2008 R2 is supported.
 * *   MariaDB
 * ### Usage notes
 * Slow query logs are not collected in real time and may show a latency of 6 hours to 8 hours.
 *
 * @param request DescribeSlowLogsRequest
 * @return DescribeSlowLogsResponse
 */
func (client *Client) DescribeSlowLogs(request *DescribeSlowLogsRequest) (_result *DescribeSlowLogsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeSlowLogsResponse{}
	_body, _err := client.DescribeSlowLogsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Supported database engine
 * SQL Server
 *
 * @param request DescribeSupportOnlineResizeDiskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSupportOnlineResizeDiskResponse
 */
func (client *Client) DescribeSupportOnlineResizeDiskWithOptions(request *DescribeSupportOnlineResizeDiskRequest, runtime *util.RuntimeOptions) (_result *DescribeSupportOnlineResizeDiskResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeSupportOnlineResizeDisk"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeSupportOnlineResizeDiskResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Supported database engine
 * SQL Server
 *
 * @param request DescribeSupportOnlineResizeDiskRequest
 * @return DescribeSupportOnlineResizeDiskResponse
 */
func (client *Client) DescribeSupportOnlineResizeDisk(request *DescribeSupportOnlineResizeDiskRequest) (_result *DescribeSupportOnlineResizeDiskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeSupportOnlineResizeDiskResponse{}
	_body, _err := client.DescribeSupportOnlineResizeDiskWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 * ### [Usage notes](#)
 * *   If an instance ID is specified, all tags that are added to this instance are queried, and other filter conditions are invalid.
 * *   If you specify only TagKey, the results that match the specified TagKey are returned. If you specify both TagKey and TagValue, the results that match both the specified TagKey and TagValue are returned.
 *
 * @param request DescribeTagsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeTagsResponse
 */
func (client *Client) DescribeTagsWithOptions(request *DescribeTagsRequest, runtime *util.RuntimeOptions) (_result *DescribeTagsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	if !tea.BoolValue(util.IsUnset(request.ProxyId)) {
		query["proxyId"] = request.ProxyId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeTags"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeTagsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 * ### [Usage notes](#)
 * *   If an instance ID is specified, all tags that are added to this instance are queried, and other filter conditions are invalid.
 * *   If you specify only TagKey, the results that match the specified TagKey are returned. If you specify both TagKey and TagValue, the results that match both the specified TagKey and TagValue are returned.
 *
 * @param request DescribeTagsRequest
 * @return DescribeTagsResponse
 */
func (client *Client) DescribeTags(request *DescribeTagsRequest) (_result *DescribeTagsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeTagsResponse{}
	_body, _err := client.DescribeTagsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * This operation is phased out.
 *
 * @param request DescribeTasksRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeTasksResponse
 */
func (client *Client) DescribeTasksWithOptions(request *DescribeTasksRequest, runtime *util.RuntimeOptions) (_result *DescribeTasksResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		query["Status"] = request.Status
	}

	if !tea.BoolValue(util.IsUnset(request.TaskAction)) {
		query["TaskAction"] = request.TaskAction
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeTasks"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeTasksResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * This operation is phased out.
 *
 * @param request DescribeTasksRequest
 * @return DescribeTasksResponse
 */
func (client *Client) DescribeTasks(request *DescribeTasksRequest) (_result *DescribeTasksResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeTasksResponse{}
	_body, _err := client.DescribeTasksWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Before you upgrade the major engine version of an ApsaraDB RDS for PostgreSQL instance, you must perform an upgrade check and make sure that the check result is **Success**. You can call this operation to query the upgrade check report.
 * If the check result is **Fail**, you must handle the errors that occurred. For more information about how to handle common errors, see [Introduction to the check report for a major engine version upgrade to an ApsaraDB RDS for PostgreSQL instance](https://www.alibabacloud.com/help/en/apsaradb-for-rds/latest/introduction-to-the-check-report-of-a-major-engine-version-upgrade-for-an-apsaradb-rds-for-postgresql-instance).
 *
 * @param request DescribeUpgradeMajorVersionPrecheckTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeUpgradeMajorVersionPrecheckTaskResponse
 */
func (client *Client) DescribeUpgradeMajorVersionPrecheckTaskWithOptions(request *DescribeUpgradeMajorVersionPrecheckTaskRequest, runtime *util.RuntimeOptions) (_result *DescribeUpgradeMajorVersionPrecheckTaskResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.TargetMajorVersion)) {
		query["TargetMajorVersion"] = request.TargetMajorVersion
	}

	if !tea.BoolValue(util.IsUnset(request.TaskId)) {
		query["TaskId"] = request.TaskId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeUpgradeMajorVersionPrecheckTask"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeUpgradeMajorVersionPrecheckTaskResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Before you upgrade the major engine version of an ApsaraDB RDS for PostgreSQL instance, you must perform an upgrade check and make sure that the check result is **Success**. You can call this operation to query the upgrade check report.
 * If the check result is **Fail**, you must handle the errors that occurred. For more information about how to handle common errors, see [Introduction to the check report for a major engine version upgrade to an ApsaraDB RDS for PostgreSQL instance](https://www.alibabacloud.com/help/en/apsaradb-for-rds/latest/introduction-to-the-check-report-of-a-major-engine-version-upgrade-for-an-apsaradb-rds-for-postgresql-instance).
 *
 * @param request DescribeUpgradeMajorVersionPrecheckTaskRequest
 * @return DescribeUpgradeMajorVersionPrecheckTaskResponse
 */
func (client *Client) DescribeUpgradeMajorVersionPrecheckTask(request *DescribeUpgradeMajorVersionPrecheckTaskRequest) (_result *DescribeUpgradeMajorVersionPrecheckTaskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeUpgradeMajorVersionPrecheckTaskResponse{}
	_body, _err := client.DescribeUpgradeMajorVersionPrecheckTaskWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeUpgradeMajorVersionTasksWithOptions(request *DescribeUpgradeMajorVersionTasksRequest, runtime *util.RuntimeOptions) (_result *DescribeUpgradeMajorVersionTasksResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.TargetMajorVersion)) {
		query["TargetMajorVersion"] = request.TargetMajorVersion
	}

	if !tea.BoolValue(util.IsUnset(request.TaskId)) {
		query["TaskId"] = request.TaskId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeUpgradeMajorVersionTasks"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeUpgradeMajorVersionTasksResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeUpgradeMajorVersionTasks(request *DescribeUpgradeMajorVersionTasksRequest) (_result *DescribeUpgradeMajorVersionTasksResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeUpgradeMajorVersionTasksResponse{}
	_body, _err := client.DescribeUpgradeMajorVersionTasksWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 *
 * @param request DescribeVSwitchesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeVSwitchesResponse
 */
func (client *Client) DescribeVSwitchesWithOptions(request *DescribeVSwitchesRequest, runtime *util.RuntimeOptions) (_result *DescribeVSwitchesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DedicatedHostGroupId)) {
		query["DedicatedHostGroupId"] = request.DedicatedHostGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	if !tea.BoolValue(util.IsUnset(request.VpcId)) {
		query["VpcId"] = request.VpcId
	}

	if !tea.BoolValue(util.IsUnset(request.ZoneId)) {
		query["ZoneId"] = request.ZoneId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeVSwitches"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeVSwitchesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 *
 * @param request DescribeVSwitchesRequest
 * @return DescribeVSwitchesResponse
 */
func (client *Client) DescribeVSwitches(request *DescribeVSwitchesRequest) (_result *DescribeVSwitchesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeVSwitchesResponse{}
	_body, _err := client.DescribeVSwitchesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Supported database engines
 * *   RDS MySQL
 * *   RDS PostgreSQL
 * *   RDS SQL Server
 *
 * @param request DescribeWhitelistTemplateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeWhitelistTemplateResponse
 */
func (client *Client) DescribeWhitelistTemplateWithOptions(request *DescribeWhitelistTemplateRequest, runtime *util.RuntimeOptions) (_result *DescribeWhitelistTemplateResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.TemplateId)) {
		query["TemplateId"] = request.TemplateId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeWhitelistTemplate"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeWhitelistTemplateResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Supported database engines
 * *   RDS MySQL
 * *   RDS PostgreSQL
 * *   RDS SQL Server
 *
 * @param request DescribeWhitelistTemplateRequest
 * @return DescribeWhitelistTemplateResponse
 */
func (client *Client) DescribeWhitelistTemplate(request *DescribeWhitelistTemplateRequest) (_result *DescribeWhitelistTemplateResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeWhitelistTemplateResponse{}
	_body, _err := client.DescribeWhitelistTemplateWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Supported database engines
 * *   RDS MySQL
 * *   RDS PostgreSQL
 * *   RDS SQL Server
 *
 * @param request DescribeWhitelistTemplateLinkedInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeWhitelistTemplateLinkedInstanceResponse
 */
func (client *Client) DescribeWhitelistTemplateLinkedInstanceWithOptions(request *DescribeWhitelistTemplateLinkedInstanceRequest, runtime *util.RuntimeOptions) (_result *DescribeWhitelistTemplateLinkedInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.TemplateId)) {
		body["TemplateId"] = request.TemplateId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
		Body:  openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeWhitelistTemplateLinkedInstance"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeWhitelistTemplateLinkedInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Supported database engines
 * *   RDS MySQL
 * *   RDS PostgreSQL
 * *   RDS SQL Server
 *
 * @param request DescribeWhitelistTemplateLinkedInstanceRequest
 * @return DescribeWhitelistTemplateLinkedInstanceResponse
 */
func (client *Client) DescribeWhitelistTemplateLinkedInstance(request *DescribeWhitelistTemplateLinkedInstanceRequest) (_result *DescribeWhitelistTemplateLinkedInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeWhitelistTemplateLinkedInstanceResponse{}
	_body, _err := client.DescribeWhitelistTemplateLinkedInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The DestroyDBInstance operation is phased out.
 *
 * @param request DestroyDBInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DestroyDBInstanceResponse
 */
func (client *Client) DestroyDBInstanceWithOptions(request *DestroyDBInstanceRequest, runtime *util.RuntimeOptions) (_result *DestroyDBInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DestroyDBInstance"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DestroyDBInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The DestroyDBInstance operation is phased out.
 *
 * @param request DestroyDBInstanceRequest
 * @return DestroyDBInstanceResponse
 */
func (client *Client) DestroyDBInstance(request *DestroyDBInstanceRequest) (_result *DestroyDBInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DestroyDBInstanceResponse{}
	_body, _err := client.DestroyDBInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * ### [Usage notes](#)
 * This operation can be used to remove only unit nodes.
 *
 * @param request DetachGadInstanceMemberRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DetachGadInstanceMemberResponse
 */
func (client *Client) DetachGadInstanceMemberWithOptions(request *DetachGadInstanceMemberRequest, runtime *util.RuntimeOptions) (_result *DetachGadInstanceMemberResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.GadInstanceName)) {
		query["GadInstanceName"] = request.GadInstanceName
	}

	if !tea.BoolValue(util.IsUnset(request.MemberInstanceName)) {
		query["MemberInstanceName"] = request.MemberInstanceName
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DetachGadInstanceMember"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DetachGadInstanceMemberResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * ### [Usage notes](#)
 * This operation can be used to remove only unit nodes.
 *
 * @param request DetachGadInstanceMemberRequest
 * @return DetachGadInstanceMemberResponse
 */
func (client *Client) DetachGadInstanceMember(request *DetachGadInstanceMemberRequest) (_result *DetachGadInstanceMemberResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DetachGadInstanceMemberResponse{}
	_body, _err := client.DetachGadInstanceMemberWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Supported database engines
 * *   RDS MySQL
 * *   RDS PostgreSQL
 * *   RDS SQL Server
 *
 * @param request DetachWhitelistTemplateToInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DetachWhitelistTemplateToInstanceResponse
 */
func (client *Client) DetachWhitelistTemplateToInstanceWithOptions(request *DetachWhitelistTemplateToInstanceRequest, runtime *util.RuntimeOptions) (_result *DetachWhitelistTemplateToInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InsName)) {
		query["InsName"] = request.InsName
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.TemplateId)) {
		query["TemplateId"] = request.TemplateId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DetachWhitelistTemplateToInstance"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DetachWhitelistTemplateToInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Supported database engines
 * *   RDS MySQL
 * *   RDS PostgreSQL
 * *   RDS SQL Server
 *
 * @param request DetachWhitelistTemplateToInstanceRequest
 * @return DetachWhitelistTemplateToInstanceResponse
 */
func (client *Client) DetachWhitelistTemplateToInstance(request *DetachWhitelistTemplateToInstanceRequest) (_result *DetachWhitelistTemplateToInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DetachWhitelistTemplateToInstanceResponse{}
	_body, _err := client.DetachWhitelistTemplateToInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) EvaluateLocalExtendDiskWithOptions(request *EvaluateLocalExtendDiskRequest, runtime *util.RuntimeOptions) (_result *EvaluateLocalExtendDiskResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceName)) {
		query["DBInstanceName"] = request.DBInstanceName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Storage)) {
		query["Storage"] = request.Storage
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("EvaluateLocalExtendDisk"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &EvaluateLocalExtendDiskResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) EvaluateLocalExtendDisk(request *EvaluateLocalExtendDiskRequest) (_result *EvaluateLocalExtendDiskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &EvaluateLocalExtendDiskResponse{}
	_body, _err := client.EvaluateLocalExtendDiskWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Supported database engines
 * *   RDS MySQL
 * *   RDS PostgreSQL
 * *   RDS SQL Server
 * *   RDS MariaDB
 *
 * @param request GetDBInstanceTopologyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetDBInstanceTopologyResponse
 */
func (client *Client) GetDBInstanceTopologyWithOptions(request *GetDBInstanceTopologyRequest, runtime *util.RuntimeOptions) (_result *GetDBInstanceTopologyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetDBInstanceTopology"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetDBInstanceTopologyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Supported database engines
 * *   RDS MySQL
 * *   RDS PostgreSQL
 * *   RDS SQL Server
 * *   RDS MariaDB
 *
 * @param request GetDBInstanceTopologyRequest
 * @return GetDBInstanceTopologyResponse
 */
func (client *Client) GetDBInstanceTopology(request *GetDBInstanceTopologyRequest) (_result *GetDBInstanceTopologyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetDBInstanceTopologyResponse{}
	_body, _err := client.GetDBInstanceTopologyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * RDS MySQL
 *
 * @param request GetDbProxyInstanceSslRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetDbProxyInstanceSslResponse
 */
func (client *Client) GetDbProxyInstanceSslWithOptions(request *GetDbProxyInstanceSslRequest, runtime *util.RuntimeOptions) (_result *GetDbProxyInstanceSslResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBProxyEngineType)) {
		query["DBProxyEngineType"] = request.DBProxyEngineType
	}

	if !tea.BoolValue(util.IsUnset(request.DbInstanceId)) {
		query["DbInstanceId"] = request.DbInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.DbInstanceId)) {
		query["DbInstanceId"] = request.DbInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetDbProxyInstanceSsl"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetDbProxyInstanceSslResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * RDS MySQL
 *
 * @param request GetDbProxyInstanceSslRequest
 * @return GetDbProxyInstanceSslResponse
 */
func (client *Client) GetDbProxyInstanceSsl(request *GetDbProxyInstanceSslRequest) (_result *GetDbProxyInstanceSslResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetDbProxyInstanceSslResponse{}
	_body, _err := client.GetDbProxyInstanceSslWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Each account can be granted permissions on one or more databases. Before you call this operation, make sure that the instance is in the Running state.
 * > This operation is not supported for instances that run SQL Server 2017 on RDS Cluster Edition or run PostgreSQL with local disks.
 *
 * @param request GrantAccountPrivilegeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GrantAccountPrivilegeResponse
 */
func (client *Client) GrantAccountPrivilegeWithOptions(request *GrantAccountPrivilegeRequest, runtime *util.RuntimeOptions) (_result *GrantAccountPrivilegeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AccountName)) {
		query["AccountName"] = request.AccountName
	}

	if !tea.BoolValue(util.IsUnset(request.AccountPrivilege)) {
		query["AccountPrivilege"] = request.AccountPrivilege
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.DBName)) {
		query["DBName"] = request.DBName
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GrantAccountPrivilege"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GrantAccountPrivilegeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Each account can be granted permissions on one or more databases. Before you call this operation, make sure that the instance is in the Running state.
 * > This operation is not supported for instances that run SQL Server 2017 on RDS Cluster Edition or run PostgreSQL with local disks.
 *
 * @param request GrantAccountPrivilegeRequest
 * @return GrantAccountPrivilegeResponse
 */
func (client *Client) GrantAccountPrivilege(request *GrantAccountPrivilegeRequest) (_result *GrantAccountPrivilegeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GrantAccountPrivilegeResponse{}
	_body, _err := client.GrantAccountPrivilegeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   SQL Server
 * ### [](#)References
 * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
 * *   [Grant permissions to the service account of an ApsaraDB RDS for MySQL instance](~~96102~~)
 * *   [Grant permissions to the service account of an ApsaraDB RDS for SQL Server instance](~~95693~~)
 *
 * @param request GrantOperatorPermissionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GrantOperatorPermissionResponse
 */
func (client *Client) GrantOperatorPermissionWithOptions(request *GrantOperatorPermissionRequest, runtime *util.RuntimeOptions) (_result *GrantOperatorPermissionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ExpiredTime)) {
		query["ExpiredTime"] = request.ExpiredTime
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Privileges)) {
		query["Privileges"] = request.Privileges
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GrantOperatorPermission"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GrantOperatorPermissionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   SQL Server
 * ### [](#)References
 * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
 * *   [Grant permissions to the service account of an ApsaraDB RDS for MySQL instance](~~96102~~)
 * *   [Grant permissions to the service account of an ApsaraDB RDS for SQL Server instance](~~95693~~)
 *
 * @param request GrantOperatorPermissionRequest
 * @return GrantOperatorPermissionResponse
 */
func (client *Client) GrantOperatorPermission(request *GrantOperatorPermissionRequest) (_result *GrantOperatorPermissionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GrantOperatorPermissionResponse{}
	_body, _err := client.GrantOperatorPermissionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engine
 * *   SQL Server
 * ### [](#)Description
 * We recommend that you use Data Transmission Service (DTS). DTS provides data migration, subscription, and synchronization features that allow you to establish stable, secure transmission links. For more information, see [DTS API overview](~~49456~~).
 * ### [](#)Precautions
 * *   During the migration, the source instance is in the **Migrating** state, and the destination instance is in the **Importing** state.
 * *   Before you call this operation, make sure that the following requirements are met:
 *     *   The source and destination instances must run SQL Server and belong to the dedicated or dedicated host instance family. For more information about the supported instance types, see [Primary instance types](~~26312~~).
 *     *   The source and destination instances must be created by using the same user credentials.
 *     *   The instance is in the Running state.
 *     *   The source and destination databases must be in the Running state.
 *     *   The remaining storage of the destination instance must be greater than the storage capacity of the source instance.
 * >
 * *   This operation is not supported for instances that run SQL Server 2017 on RDS Cluster Edition.
 * *   You can migrate the data of multiple databases at a time.
 *
 * @param request ImportDatabaseBetweenInstancesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ImportDatabaseBetweenInstancesResponse
 */
func (client *Client) ImportDatabaseBetweenInstancesWithOptions(request *ImportDatabaseBetweenInstancesRequest, runtime *util.RuntimeOptions) (_result *ImportDatabaseBetweenInstancesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInfo)) {
		query["DBInfo"] = request.DBInfo
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SourceDBInstanceId)) {
		query["SourceDBInstanceId"] = request.SourceDBInstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ImportDatabaseBetweenInstances"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ImportDatabaseBetweenInstancesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engine
 * *   SQL Server
 * ### [](#)Description
 * We recommend that you use Data Transmission Service (DTS). DTS provides data migration, subscription, and synchronization features that allow you to establish stable, secure transmission links. For more information, see [DTS API overview](~~49456~~).
 * ### [](#)Precautions
 * *   During the migration, the source instance is in the **Migrating** state, and the destination instance is in the **Importing** state.
 * *   Before you call this operation, make sure that the following requirements are met:
 *     *   The source and destination instances must run SQL Server and belong to the dedicated or dedicated host instance family. For more information about the supported instance types, see [Primary instance types](~~26312~~).
 *     *   The source and destination instances must be created by using the same user credentials.
 *     *   The instance is in the Running state.
 *     *   The source and destination databases must be in the Running state.
 *     *   The remaining storage of the destination instance must be greater than the storage capacity of the source instance.
 * >
 * *   This operation is not supported for instances that run SQL Server 2017 on RDS Cluster Edition.
 * *   You can migrate the data of multiple databases at a time.
 *
 * @param request ImportDatabaseBetweenInstancesRequest
 * @return ImportDatabaseBetweenInstancesResponse
 */
func (client *Client) ImportDatabaseBetweenInstances(request *ImportDatabaseBetweenInstancesRequest) (_result *ImportDatabaseBetweenInstancesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ImportDatabaseBetweenInstancesResponse{}
	_body, _err := client.ImportDatabaseBetweenInstancesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * ### [](#)Description
 * A full backup file contains the data of a self-managed MySQL instance. You can restore the data of a self-managed MySQL instance from a full backup file to an ApsaraDB RDS for MySQL instance.
 * ### [](#)Usage notes
 * Before you call this operation, make sure that the following requirements are met:
 * *   The self-managed MySQL instance runs MySQL 5.7 and is backed up by using XtraBackup. The name of the backup file ends with `_qp.xb`. For more information, see [Migrate the data of a self-managed MySQL 5.7 instance to the cloud](~~251779~~).
 * *   The full backup file of the self-managed MySQL instance is uploaded to an Object Storage Service (OSS) bucket in the region of the ApsaraDB RDS for MySQL instance. For more information, see [Migrate the data of a self-managed MySQL 5.7 instance to the cloud](~~251779~~).
 * >  This operation is supported only for MySQL 5.7.
 *
 * @param request ImportUserBackupFileRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ImportUserBackupFileResponse
 */
func (client *Client) ImportUserBackupFileWithOptions(request *ImportUserBackupFileRequest, runtime *util.RuntimeOptions) (_result *ImportUserBackupFileResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BackupFile)) {
		query["BackupFile"] = request.BackupFile
	}

	if !tea.BoolValue(util.IsUnset(request.BucketRegion)) {
		query["BucketRegion"] = request.BucketRegion
	}

	if !tea.BoolValue(util.IsUnset(request.Comment)) {
		query["Comment"] = request.Comment
	}

	if !tea.BoolValue(util.IsUnset(request.EngineVersion)) {
		query["EngineVersion"] = request.EngineVersion
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RestoreSize)) {
		query["RestoreSize"] = request.RestoreSize
	}

	if !tea.BoolValue(util.IsUnset(request.Retention)) {
		query["Retention"] = request.Retention
	}

	if !tea.BoolValue(util.IsUnset(request.ZoneId)) {
		query["ZoneId"] = request.ZoneId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ImportUserBackupFile"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ImportUserBackupFileResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * ### [](#)Description
 * A full backup file contains the data of a self-managed MySQL instance. You can restore the data of a self-managed MySQL instance from a full backup file to an ApsaraDB RDS for MySQL instance.
 * ### [](#)Usage notes
 * Before you call this operation, make sure that the following requirements are met:
 * *   The self-managed MySQL instance runs MySQL 5.7 and is backed up by using XtraBackup. The name of the backup file ends with `_qp.xb`. For more information, see [Migrate the data of a self-managed MySQL 5.7 instance to the cloud](~~251779~~).
 * *   The full backup file of the self-managed MySQL instance is uploaded to an Object Storage Service (OSS) bucket in the region of the ApsaraDB RDS for MySQL instance. For more information, see [Migrate the data of a self-managed MySQL 5.7 instance to the cloud](~~251779~~).
 * >  This operation is supported only for MySQL 5.7.
 *
 * @param request ImportUserBackupFileRequest
 * @return ImportUserBackupFileResponse
 */
func (client *Client) ImportUserBackupFile(request *ImportUserBackupFileRequest) (_result *ImportUserBackupFileResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ImportUserBackupFileResponse{}
	_body, _err := client.ImportUserBackupFileWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 *
 * @param request ListClassesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListClassesResponse
 */
func (client *Client) ListClassesWithOptions(request *ListClassesRequest, runtime *util.RuntimeOptions) (_result *ListClassesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.CommodityCode)) {
		query["CommodityCode"] = request.CommodityCode
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OrderType)) {
		query["OrderType"] = request.OrderType
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListClasses"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListClassesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 *
 * @param request ListClassesRequest
 * @return ListClassesResponse
 */
func (client *Client) ListClasses(request *ListClassesRequest) (_result *ListClassesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListClassesResponse{}
	_body, _err := client.ListClassesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 *
 * @param request ListTagResourcesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListTagResourcesResponse
 */
func (client *Client) ListTagResourcesWithOptions(request *ListTagResourcesRequest, runtime *util.RuntimeOptions) (_result *ListTagResourcesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceId)) {
		query["ResourceId"] = request.ResourceId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListTagResources"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListTagResourcesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 *
 * @param request ListTagResourcesRequest
 * @return ListTagResourcesResponse
 */
func (client *Client) ListTagResources(request *ListTagResourcesRequest) (_result *ListTagResourcesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListTagResourcesResponse{}
	_body, _err := client.ListTagResourcesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * >
 * *   A full backup file contains the data of a self-managed MySQL database. You can restore the data of a self-managed MySQL database from a full backup file to an ApsaraDB RDS for MySQL instance. For more information, see [Migrate the data of a self-managed MySQL 5.7 instance to the cloud](~~251779~~).
 * *   Before you call the [CreateDBInstance](~~26228~~) operation to create an ApsaraDB RDS for MySQL instance into which you want to import full backup files, you can call this operation to query the IDs of full backup files.
 * *   You can call the [ImportUserBackupFile](~~260266~~) operation to import a full backup file into an ApsaraDB RDS for MySQL instance.
 *
 * @param request ListUserBackupFilesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListUserBackupFilesResponse
 */
func (client *Client) ListUserBackupFilesWithOptions(request *ListUserBackupFilesRequest, runtime *util.RuntimeOptions) (_result *ListUserBackupFilesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BackupId)) {
		query["BackupId"] = request.BackupId
	}

	if !tea.BoolValue(util.IsUnset(request.Comment)) {
		query["Comment"] = request.Comment
	}

	if !tea.BoolValue(util.IsUnset(request.OssUrl)) {
		query["OssUrl"] = request.OssUrl
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		query["Status"] = request.Status
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListUserBackupFiles"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListUserBackupFilesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * >
 * *   A full backup file contains the data of a self-managed MySQL database. You can restore the data of a self-managed MySQL database from a full backup file to an ApsaraDB RDS for MySQL instance. For more information, see [Migrate the data of a self-managed MySQL 5.7 instance to the cloud](~~251779~~).
 * *   Before you call the [CreateDBInstance](~~26228~~) operation to create an ApsaraDB RDS for MySQL instance into which you want to import full backup files, you can call this operation to query the IDs of full backup files.
 * *   You can call the [ImportUserBackupFile](~~260266~~) operation to import a full backup file into an ApsaraDB RDS for MySQL instance.
 *
 * @param request ListUserBackupFilesRequest
 * @return ListUserBackupFilesResponse
 */
func (client *Client) ListUserBackupFiles(request *ListUserBackupFilesRequest) (_result *ListUserBackupFilesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListUserBackupFilesResponse{}
	_body, _err := client.ListUserBackupFilesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You cannot use a locked account to log on to the corresponding instance. You must first unlock the account. For more information, see [Lock and delete an account](~~147649~~).
 *
 * @param request LockAccountRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return LockAccountResponse
 */
func (client *Client) LockAccountWithOptions(request *LockAccountRequest, runtime *util.RuntimeOptions) (_result *LockAccountResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AccountName)) {
		query["AccountName"] = request.AccountName
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("LockAccount"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &LockAccountResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You cannot use a locked account to log on to the corresponding instance. You must first unlock the account. For more information, see [Lock and delete an account](~~147649~~).
 *
 * @param request LockAccountRequest
 * @return LockAccountResponse
 */
func (client *Client) LockAccount(request *LockAccountRequest) (_result *LockAccountResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &LockAccountResponse{}
	_body, _err := client.LockAccountWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * ### [](#)References
 * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
 * *   [Migrate an ApsaraDB RDS for MySQL instance across zones in the same region](~~96746~~)
 * *   [Migrate an ApsaraDB RDS for PostgreSQL instance across zones in the same region](~~96746~~)
 * *   [Migrate an ApsaraDB RDS for SQL Server instance across zones in the same region](~~95658~~)
 *
 * @param request MigrateConnectionToOtherZoneRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return MigrateConnectionToOtherZoneResponse
 */
func (client *Client) MigrateConnectionToOtherZoneWithOptions(request *MigrateConnectionToOtherZoneRequest, runtime *util.RuntimeOptions) (_result *MigrateConnectionToOtherZoneResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ConnectionString)) {
		query["ConnectionString"] = request.ConnectionString
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ZoneId)) {
		query["ZoneId"] = request.ZoneId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("MigrateConnectionToOtherZone"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &MigrateConnectionToOtherZoneResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * ### [](#)References
 * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
 * *   [Migrate an ApsaraDB RDS for MySQL instance across zones in the same region](~~96746~~)
 * *   [Migrate an ApsaraDB RDS for PostgreSQL instance across zones in the same region](~~96746~~)
 * *   [Migrate an ApsaraDB RDS for SQL Server instance across zones in the same region](~~95658~~)
 *
 * @param request MigrateConnectionToOtherZoneRequest
 * @return MigrateConnectionToOtherZoneResponse
 */
func (client *Client) MigrateConnectionToOtherZone(request *MigrateConnectionToOtherZoneRequest) (_result *MigrateConnectionToOtherZoneResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &MigrateConnectionToOtherZoneResponse{}
	_body, _err := client.MigrateConnectionToOtherZoneWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Dedicated clusters allow you to manage a number of instances at a time. You can create multiple dedicated clusters in a single region. Each dedicated cluster consists of multiple hosts. You can create multiple instances on each host. For more information, see [What is ApsaraDB MyBase?](~~141455~~)
 *
 * @param request MigrateDBInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return MigrateDBInstanceResponse
 */
func (client *Client) MigrateDBInstanceWithOptions(request *MigrateDBInstanceRequest, runtime *util.RuntimeOptions) (_result *MigrateDBInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.DedicatedHostGroupId)) {
		query["DedicatedHostGroupId"] = request.DedicatedHostGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.EffectiveTime)) {
		query["EffectiveTime"] = request.EffectiveTime
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SpecifiedTime)) {
		query["SpecifiedTime"] = request.SpecifiedTime
	}

	if !tea.BoolValue(util.IsUnset(request.TargetDedicatedHostIdForMaster)) {
		query["TargetDedicatedHostIdForMaster"] = request.TargetDedicatedHostIdForMaster
	}

	if !tea.BoolValue(util.IsUnset(request.TargetDedicatedHostIdForSlave)) {
		query["TargetDedicatedHostIdForSlave"] = request.TargetDedicatedHostIdForSlave
	}

	if !tea.BoolValue(util.IsUnset(request.ZoneIdForFollower)) {
		query["ZoneIdForFollower"] = request.ZoneIdForFollower
	}

	if !tea.BoolValue(util.IsUnset(request.ZoneIdForLog)) {
		query["ZoneIdForLog"] = request.ZoneIdForLog
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("MigrateDBInstance"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &MigrateDBInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Dedicated clusters allow you to manage a number of instances at a time. You can create multiple dedicated clusters in a single region. Each dedicated cluster consists of multiple hosts. You can create multiple instances on each host. For more information, see [What is ApsaraDB MyBase?](~~141455~~)
 *
 * @param request MigrateDBInstanceRequest
 * @return MigrateDBInstanceResponse
 */
func (client *Client) MigrateDBInstance(request *MigrateDBInstanceRequest) (_result *MigrateDBInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &MigrateDBInstanceResponse{}
	_body, _err := client.MigrateDBInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   In standard whitelist mode, IP addresses in the whitelist apply to both the classic network and VPCs. To minimize security risks, we recommend that you use the enhanced whitelist mode.
 * *   In enhanced whitelist mode, IP addresses in the whitelist are divided into VPC IP addresses and IP addresses of the classic network and Internet.
 * >
 * *   You cannot change the whitelist mode from the enhanced whitelist mode to the standard whitelist mode.
 * *   This operation is not supported for instances that run SQL Server and MariaDB.
 *
 * @param request MigrateSecurityIPModeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return MigrateSecurityIPModeResponse
 */
func (client *Client) MigrateSecurityIPModeWithOptions(request *MigrateSecurityIPModeRequest, runtime *util.RuntimeOptions) (_result *MigrateSecurityIPModeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("MigrateSecurityIPMode"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &MigrateSecurityIPModeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   In standard whitelist mode, IP addresses in the whitelist apply to both the classic network and VPCs. To minimize security risks, we recommend that you use the enhanced whitelist mode.
 * *   In enhanced whitelist mode, IP addresses in the whitelist are divided into VPC IP addresses and IP addresses of the classic network and Internet.
 * >
 * *   You cannot change the whitelist mode from the enhanced whitelist mode to the standard whitelist mode.
 * *   This operation is not supported for instances that run SQL Server and MariaDB.
 *
 * @param request MigrateSecurityIPModeRequest
 * @return MigrateSecurityIPModeResponse
 */
func (client *Client) MigrateSecurityIPMode(request *MigrateSecurityIPModeRequest) (_result *MigrateSecurityIPModeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &MigrateSecurityIPModeResponse{}
	_body, _err := client.MigrateSecurityIPModeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   RDS MySQL
 * *   RDS PostgreSQL
 * *   RDS SQL Server
 * ### [](#)References
 * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * *   [Migrate an ApsaraDB RDS for MySQL instance across zones in the same region](~~96053~~)
 * *   [Migrate an ApsaraDB RDS for PostgreSQL instance across zones in the same region](~~96746~~)
 * *   [Migrate an ApsaraDB RDS for SQL Server instance across zones in the same region](~~95658~~)
 *
 * @param request MigrateToOtherZoneRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return MigrateToOtherZoneResponse
 */
func (client *Client) MigrateToOtherZoneWithOptions(request *MigrateToOtherZoneRequest, runtime *util.RuntimeOptions) (_result *MigrateToOtherZoneResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Category)) {
		query["Category"] = request.Category
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceClass)) {
		query["DBInstanceClass"] = request.DBInstanceClass
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceStorage)) {
		query["DBInstanceStorage"] = request.DBInstanceStorage
	}

	if !tea.BoolValue(util.IsUnset(request.EffectiveTime)) {
		query["EffectiveTime"] = request.EffectiveTime
	}

	if !tea.BoolValue(util.IsUnset(request.IsModifySpec)) {
		query["IsModifySpec"] = request.IsModifySpec
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SwitchTime)) {
		query["SwitchTime"] = request.SwitchTime
	}

	if !tea.BoolValue(util.IsUnset(request.VPCId)) {
		query["VPCId"] = request.VPCId
	}

	if !tea.BoolValue(util.IsUnset(request.VSwitchId)) {
		query["VSwitchId"] = request.VSwitchId
	}

	if !tea.BoolValue(util.IsUnset(request.ZoneId)) {
		query["ZoneId"] = request.ZoneId
	}

	if !tea.BoolValue(util.IsUnset(request.ZoneIdSlave1)) {
		query["ZoneIdSlave1"] = request.ZoneIdSlave1
	}

	if !tea.BoolValue(util.IsUnset(request.ZoneIdSlave2)) {
		query["ZoneIdSlave2"] = request.ZoneIdSlave2
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("MigrateToOtherZone"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &MigrateToOtherZoneResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   RDS MySQL
 * *   RDS PostgreSQL
 * *   RDS SQL Server
 * ### [](#)References
 * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * *   [Migrate an ApsaraDB RDS for MySQL instance across zones in the same region](~~96053~~)
 * *   [Migrate an ApsaraDB RDS for PostgreSQL instance across zones in the same region](~~96746~~)
 * *   [Migrate an ApsaraDB RDS for SQL Server instance across zones in the same region](~~95658~~)
 *
 * @param request MigrateToOtherZoneRequest
 * @return MigrateToOtherZoneResponse
 */
func (client *Client) MigrateToOtherZone(request *MigrateToOtherZoneRequest) (_result *MigrateToOtherZoneResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &MigrateToOtherZoneResponse{}
	_body, _err := client.MigrateToOtherZoneWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engine
 * *   SQL Server
 * ### [](#)References
 * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
 * *   [Connect an RDS instance to a self-managed domain](~~170734~~)
 *
 * @param request ModifyADInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyADInfoResponse
 */
func (client *Client) ModifyADInfoWithOptions(request *ModifyADInfoRequest, runtime *util.RuntimeOptions) (_result *ModifyADInfoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ADAccountName)) {
		query["ADAccountName"] = request.ADAccountName
	}

	if !tea.BoolValue(util.IsUnset(request.ADDNS)) {
		query["ADDNS"] = request.ADDNS
	}

	if !tea.BoolValue(util.IsUnset(request.ADPassword)) {
		query["ADPassword"] = request.ADPassword
	}

	if !tea.BoolValue(util.IsUnset(request.ADServerIpAddress)) {
		query["ADServerIpAddress"] = request.ADServerIpAddress
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyADInfo"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyADInfoResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engine
 * *   SQL Server
 * ### [](#)References
 * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
 * *   [Connect an RDS instance to a self-managed domain](~~170734~~)
 *
 * @param request ModifyADInfoRequest
 * @return ModifyADInfoResponse
 */
func (client *Client) ModifyADInfo(request *ModifyADInfoRequest) (_result *ModifyADInfoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyADInfoResponse{}
	_body, _err := client.ModifyADInfoWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   RDS MySQL
 * *   RDS PostgreSQL
 * *   RDS SQL Server
 * *   RDS MariaDB
 *
 * @param request ModifyAccountDescriptionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyAccountDescriptionResponse
 */
func (client *Client) ModifyAccountDescriptionWithOptions(request *ModifyAccountDescriptionRequest, runtime *util.RuntimeOptions) (_result *ModifyAccountDescriptionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AccountDescription)) {
		query["AccountDescription"] = request.AccountDescription
	}

	if !tea.BoolValue(util.IsUnset(request.AccountName)) {
		query["AccountName"] = request.AccountName
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyAccountDescription"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyAccountDescriptionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   RDS MySQL
 * *   RDS PostgreSQL
 * *   RDS SQL Server
 * *   RDS MariaDB
 *
 * @param request ModifyAccountDescriptionRequest
 * @return ModifyAccountDescriptionResponse
 */
func (client *Client) ModifyAccountDescription(request *ModifyAccountDescriptionRequest) (_result *ModifyAccountDescriptionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyAccountDescriptionResponse{}
	_body, _err := client.ModifyAccountDescriptionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The event history feature enables you to view historical events that occurred in a region over a specific time range. These events include instance creation and parameter reconfiguration. For more information, see [Event history](~~129759~~).
 *
 * @param request ModifyActionEventPolicyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyActionEventPolicyResponse
 */
func (client *Client) ModifyActionEventPolicyWithOptions(request *ModifyActionEventPolicyRequest, runtime *util.RuntimeOptions) (_result *ModifyActionEventPolicyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EnableEventLog)) {
		query["EnableEventLog"] = request.EnableEventLog
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyActionEventPolicy"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyActionEventPolicyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The event history feature enables you to view historical events that occurred in a region over a specific time range. These events include instance creation and parameter reconfiguration. For more information, see [Event history](~~129759~~).
 *
 * @param request ModifyActionEventPolicyRequest
 * @return ModifyActionEventPolicyResponse
 */
func (client *Client) ModifyActionEventPolicy(request *ModifyActionEventPolicyRequest) (_result *ModifyActionEventPolicyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyActionEventPolicyResponse{}
	_body, _err := client.ModifyActionEventPolicyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 * ### [](#)References
 * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * *   [Scheduled events for ApsaraDB RDS for MySQL instances](~~104183~~)
 * *   [Scheduled events for ApsaraDB RDS for PostgreSQL instances](~~104452~~)
 * *   [Scheduled events for ApsaraDB RDS for SQL Server instances](~~104451~~)
 * *   [Scheduled events for ApsaraDB RDS for MariaDB instances](~~104454~~)
 *
 * @param request ModifyActiveOperationTasksRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyActiveOperationTasksResponse
 */
func (client *Client) ModifyActiveOperationTasksWithOptions(request *ModifyActiveOperationTasksRequest, runtime *util.RuntimeOptions) (_result *ModifyActiveOperationTasksResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Ids)) {
		query["Ids"] = request.Ids
	}

	if !tea.BoolValue(util.IsUnset(request.ImmediateStart)) {
		query["ImmediateStart"] = request.ImmediateStart
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	if !tea.BoolValue(util.IsUnset(request.SwitchTime)) {
		query["SwitchTime"] = request.SwitchTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyActiveOperationTasks"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyActiveOperationTasksResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 * ### [](#)References
 * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * *   [Scheduled events for ApsaraDB RDS for MySQL instances](~~104183~~)
 * *   [Scheduled events for ApsaraDB RDS for PostgreSQL instances](~~104452~~)
 * *   [Scheduled events for ApsaraDB RDS for SQL Server instances](~~104451~~)
 * *   [Scheduled events for ApsaraDB RDS for MariaDB instances](~~104454~~)
 *
 * @param request ModifyActiveOperationTasksRequest
 * @return ModifyActiveOperationTasksResponse
 */
func (client *Client) ModifyActiveOperationTasks(request *ModifyActiveOperationTasksRequest) (_result *ModifyActiveOperationTasksResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyActiveOperationTasksResponse{}
	_body, _err := client.ModifyActiveOperationTasksWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 * ### References
 * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
 * *   [Configure an automatic backup policy for an ApsaraDB RDS for MySQL instance](~~98818~~)
 * *   [Configure an automatic backup policy for an ApsaraDB RDS for PostgreSQL instance](~~96772~~)
 * *   [Configure an automatic backup policy for an ApsaraDB RDS for SQL Server instance](~~95717~~)
 * *   [Configure an automatic backup policy for an ApsaraDB RDS for MariaDB instance](~~97147~~)
 *
 * @param request ModifyBackupPolicyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyBackupPolicyResponse
 */
func (client *Client) ModifyBackupPolicyWithOptions(request *ModifyBackupPolicyRequest, runtime *util.RuntimeOptions) (_result *ModifyBackupPolicyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ArchiveBackupKeepCount)) {
		query["ArchiveBackupKeepCount"] = request.ArchiveBackupKeepCount
	}

	if !tea.BoolValue(util.IsUnset(request.ArchiveBackupKeepPolicy)) {
		query["ArchiveBackupKeepPolicy"] = request.ArchiveBackupKeepPolicy
	}

	if !tea.BoolValue(util.IsUnset(request.ArchiveBackupRetentionPeriod)) {
		query["ArchiveBackupRetentionPeriod"] = request.ArchiveBackupRetentionPeriod
	}

	if !tea.BoolValue(util.IsUnset(request.BackupInterval)) {
		query["BackupInterval"] = request.BackupInterval
	}

	if !tea.BoolValue(util.IsUnset(request.BackupLog)) {
		query["BackupLog"] = request.BackupLog
	}

	if !tea.BoolValue(util.IsUnset(request.BackupMethod)) {
		query["BackupMethod"] = request.BackupMethod
	}

	if !tea.BoolValue(util.IsUnset(request.BackupPolicyMode)) {
		query["BackupPolicyMode"] = request.BackupPolicyMode
	}

	if !tea.BoolValue(util.IsUnset(request.BackupPriority)) {
		query["BackupPriority"] = request.BackupPriority
	}

	if !tea.BoolValue(util.IsUnset(request.BackupRetentionPeriod)) {
		query["BackupRetentionPeriod"] = request.BackupRetentionPeriod
	}

	if !tea.BoolValue(util.IsUnset(request.Category)) {
		query["Category"] = request.Category
	}

	if !tea.BoolValue(util.IsUnset(request.CompressType)) {
		query["CompressType"] = request.CompressType
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.EnableBackupLog)) {
		query["EnableBackupLog"] = request.EnableBackupLog
	}

	if !tea.BoolValue(util.IsUnset(request.EnableIncrementDataBackup)) {
		query["EnableIncrementDataBackup"] = request.EnableIncrementDataBackup
	}

	if !tea.BoolValue(util.IsUnset(request.HighSpaceUsageProtection)) {
		query["HighSpaceUsageProtection"] = request.HighSpaceUsageProtection
	}

	if !tea.BoolValue(util.IsUnset(request.LocalLogRetentionHours)) {
		query["LocalLogRetentionHours"] = request.LocalLogRetentionHours
	}

	if !tea.BoolValue(util.IsUnset(request.LocalLogRetentionSpace)) {
		query["LocalLogRetentionSpace"] = request.LocalLogRetentionSpace
	}

	if !tea.BoolValue(util.IsUnset(request.LogBackupFrequency)) {
		query["LogBackupFrequency"] = request.LogBackupFrequency
	}

	if !tea.BoolValue(util.IsUnset(request.LogBackupLocalRetentionNumber)) {
		query["LogBackupLocalRetentionNumber"] = request.LogBackupLocalRetentionNumber
	}

	if !tea.BoolValue(util.IsUnset(request.LogBackupRetentionPeriod)) {
		query["LogBackupRetentionPeriod"] = request.LogBackupRetentionPeriod
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PreferredBackupPeriod)) {
		query["PreferredBackupPeriod"] = request.PreferredBackupPeriod
	}

	if !tea.BoolValue(util.IsUnset(request.PreferredBackupTime)) {
		query["PreferredBackupTime"] = request.PreferredBackupTime
	}

	if !tea.BoolValue(util.IsUnset(request.ReleasedKeepPolicy)) {
		query["ReleasedKeepPolicy"] = request.ReleasedKeepPolicy
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyBackupPolicy"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyBackupPolicyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 * ### References
 * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
 * *   [Configure an automatic backup policy for an ApsaraDB RDS for MySQL instance](~~98818~~)
 * *   [Configure an automatic backup policy for an ApsaraDB RDS for PostgreSQL instance](~~96772~~)
 * *   [Configure an automatic backup policy for an ApsaraDB RDS for SQL Server instance](~~95717~~)
 * *   [Configure an automatic backup policy for an ApsaraDB RDS for MariaDB instance](~~97147~~)
 *
 * @param request ModifyBackupPolicyRequest
 * @return ModifyBackupPolicyResponse
 */
func (client *Client) ModifyBackupPolicy(request *ModifyBackupPolicyRequest) (_result *ModifyBackupPolicyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyBackupPolicyResponse{}
	_body, _err := client.ModifyBackupPolicyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > This operation is phased out.
 *
 * @param request ModifyCollationTimeZoneRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyCollationTimeZoneResponse
 */
func (client *Client) ModifyCollationTimeZoneWithOptions(request *ModifyCollationTimeZoneRequest, runtime *util.RuntimeOptions) (_result *ModifyCollationTimeZoneResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Collation)) {
		query["Collation"] = request.Collation
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Timezone)) {
		query["Timezone"] = request.Timezone
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyCollationTimeZone"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyCollationTimeZoneResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > This operation is phased out.
 *
 * @param request ModifyCollationTimeZoneRequest
 * @return ModifyCollationTimeZoneResponse
 */
func (client *Client) ModifyCollationTimeZone(request *ModifyCollationTimeZoneRequest) (_result *ModifyCollationTimeZoneResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyCollationTimeZoneResponse{}
	_body, _err := client.ModifyCollationTimeZoneWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifyCustinsResourceWithOptions(request *ModifyCustinsResourceRequest, runtime *util.RuntimeOptions) (_result *ModifyCustinsResourceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AdjustDeadline)) {
		query["AdjustDeadline"] = request.AdjustDeadline
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.IncreaseRatio)) {
		query["IncreaseRatio"] = request.IncreaseRatio
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.RestoreOriginalSpecification)) {
		query["RestoreOriginalSpecification"] = request.RestoreOriginalSpecification
	}

	if !tea.BoolValue(util.IsUnset(request.TargetValue)) {
		query["TargetValue"] = request.TargetValue
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyCustinsResource"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyCustinsResourceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifyCustinsResource(request *ModifyCustinsResourceRequest) (_result *ModifyCustinsResourceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyCustinsResourceResponse{}
	_body, _err := client.ModifyCustinsResourceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   RDS MySQL
 * *   RDS PostgreSQL
 * *   RDS SQL Server
 * *   RDS MariaDB
 *
 * @param request ModifyDBDescriptionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyDBDescriptionResponse
 */
func (client *Client) ModifyDBDescriptionWithOptions(request *ModifyDBDescriptionRequest, runtime *util.RuntimeOptions) (_result *ModifyDBDescriptionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBDescription)) {
		query["DBDescription"] = request.DBDescription
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.DBName)) {
		query["DBName"] = request.DBName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyDBDescription"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyDBDescriptionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   RDS MySQL
 * *   RDS PostgreSQL
 * *   RDS SQL Server
 * *   RDS MariaDB
 *
 * @param request ModifyDBDescriptionRequest
 * @return ModifyDBDescriptionResponse
 */
func (client *Client) ModifyDBDescription(request *ModifyDBDescriptionRequest) (_result *ModifyDBDescriptionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyDBDescriptionResponse{}
	_body, _err := client.ModifyDBDescriptionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * This operation is supported only for instances that run MySQL.
 *
 * @param request ModifyDBInstanceAutoUpgradeMinorVersionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyDBInstanceAutoUpgradeMinorVersionResponse
 */
func (client *Client) ModifyDBInstanceAutoUpgradeMinorVersionWithOptions(request *ModifyDBInstanceAutoUpgradeMinorVersionRequest, runtime *util.RuntimeOptions) (_result *ModifyDBInstanceAutoUpgradeMinorVersionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AutoUpgradeMinorVersion)) {
		query["AutoUpgradeMinorVersion"] = request.AutoUpgradeMinorVersion
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyDBInstanceAutoUpgradeMinorVersion"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyDBInstanceAutoUpgradeMinorVersionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * This operation is supported only for instances that run MySQL.
 *
 * @param request ModifyDBInstanceAutoUpgradeMinorVersionRequest
 * @return ModifyDBInstanceAutoUpgradeMinorVersionResponse
 */
func (client *Client) ModifyDBInstanceAutoUpgradeMinorVersion(request *ModifyDBInstanceAutoUpgradeMinorVersionRequest) (_result *ModifyDBInstanceAutoUpgradeMinorVersionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyDBInstanceAutoUpgradeMinorVersionResponse{}
	_body, _err := client.ModifyDBInstanceAutoUpgradeMinorVersionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Supported database engines
 * *   RDS MySQL
 * *   RDS PostgreSQL
 * *   RDS SQL Server
 * *   RDS MariaDB
 * > : The configuration item that is supported is [PgBouncer](~~2398301~~) of ApsaraDB RDS for PostgreSQL instances.
 *
 * @param request ModifyDBInstanceConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyDBInstanceConfigResponse
 */
func (client *Client) ModifyDBInstanceConfigWithOptions(request *ModifyDBInstanceConfigRequest, runtime *util.RuntimeOptions) (_result *ModifyDBInstanceConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.ConfigName)) {
		query["ConfigName"] = request.ConfigName
	}

	if !tea.BoolValue(util.IsUnset(request.ConfigValue)) {
		query["ConfigValue"] = request.ConfigValue
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyDBInstanceConfig"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyDBInstanceConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Supported database engines
 * *   RDS MySQL
 * *   RDS PostgreSQL
 * *   RDS SQL Server
 * *   RDS MariaDB
 * > : The configuration item that is supported is [PgBouncer](~~2398301~~) of ApsaraDB RDS for PostgreSQL instances.
 *
 * @param request ModifyDBInstanceConfigRequest
 * @return ModifyDBInstanceConfigResponse
 */
func (client *Client) ModifyDBInstanceConfig(request *ModifyDBInstanceConfigRequest) (_result *ModifyDBInstanceConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyDBInstanceConfigResponse{}
	_body, _err := client.ModifyDBInstanceConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > The API has been taken offline
 *
 * @param request ModifyDBInstanceConnectionModeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyDBInstanceConnectionModeResponse
 */
func (client *Client) ModifyDBInstanceConnectionModeWithOptions(request *ModifyDBInstanceConnectionModeRequest, runtime *util.RuntimeOptions) (_result *ModifyDBInstanceConnectionModeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ConnectionMode)) {
		query["ConnectionMode"] = request.ConnectionMode
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyDBInstanceConnectionMode"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyDBInstanceConnectionModeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > The API has been taken offline
 *
 * @param request ModifyDBInstanceConnectionModeRequest
 * @return ModifyDBInstanceConnectionModeResponse
 */
func (client *Client) ModifyDBInstanceConnectionMode(request *ModifyDBInstanceConnectionModeRequest) (_result *ModifyDBInstanceConnectionModeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyDBInstanceConnectionModeResponse{}
	_body, _err := client.ModifyDBInstanceConnectionModeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 * ### References
 * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation:
 * *   [Change the endpoint and port number of an ApsaraDB RDS for MySQL instance](~~96163~~)
 * *   [Change the endpoint and port number of an ApsaraDB RDS for PostgreSQL instance](~~96788~~)
 * *   [Change the endpoint and port number of an ApsaraDB RDS for SQL Server instance](~~95740~~)
 * *   [Change the endpoint and port number of an ApsaraDB RDS for MariaDB instance](~~97157~~)
 *
 * @param request ModifyDBInstanceConnectionStringRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyDBInstanceConnectionStringResponse
 */
func (client *Client) ModifyDBInstanceConnectionStringWithOptions(request *ModifyDBInstanceConnectionStringRequest, runtime *util.RuntimeOptions) (_result *ModifyDBInstanceConnectionStringResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BabelfishPort)) {
		query["BabelfishPort"] = request.BabelfishPort
	}

	if !tea.BoolValue(util.IsUnset(request.ConnectionStringPrefix)) {
		query["ConnectionStringPrefix"] = request.ConnectionStringPrefix
	}

	if !tea.BoolValue(util.IsUnset(request.CurrentConnectionString)) {
		query["CurrentConnectionString"] = request.CurrentConnectionString
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.GeneralGroupName)) {
		query["GeneralGroupName"] = request.GeneralGroupName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PGBouncerPort)) {
		query["PGBouncerPort"] = request.PGBouncerPort
	}

	if !tea.BoolValue(util.IsUnset(request.Port)) {
		query["Port"] = request.Port
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyDBInstanceConnectionString"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyDBInstanceConnectionStringResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 * ### References
 * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation:
 * *   [Change the endpoint and port number of an ApsaraDB RDS for MySQL instance](~~96163~~)
 * *   [Change the endpoint and port number of an ApsaraDB RDS for PostgreSQL instance](~~96788~~)
 * *   [Change the endpoint and port number of an ApsaraDB RDS for SQL Server instance](~~95740~~)
 * *   [Change the endpoint and port number of an ApsaraDB RDS for MariaDB instance](~~97157~~)
 *
 * @param request ModifyDBInstanceConnectionStringRequest
 * @return ModifyDBInstanceConnectionStringResponse
 */
func (client *Client) ModifyDBInstanceConnectionString(request *ModifyDBInstanceConnectionStringRequest) (_result *ModifyDBInstanceConnectionStringResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyDBInstanceConnectionStringResponse{}
	_body, _err := client.ModifyDBInstanceConnectionStringWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifyDBInstanceDelayedReplicationTimeWithOptions(request *ModifyDBInstanceDelayedReplicationTimeRequest, runtime *util.RuntimeOptions) (_result *ModifyDBInstanceDelayedReplicationTimeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ReadSQLReplicationTime)) {
		query["ReadSQLReplicationTime"] = request.ReadSQLReplicationTime
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyDBInstanceDelayedReplicationTime"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyDBInstanceDelayedReplicationTimeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifyDBInstanceDelayedReplicationTime(request *ModifyDBInstanceDelayedReplicationTimeRequest) (_result *ModifyDBInstanceDelayedReplicationTimeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyDBInstanceDelayedReplicationTimeResponse{}
	_body, _err := client.ModifyDBInstanceDelayedReplicationTimeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * For more information, see [Enable or disable the release protection feature for an ApsaraDB RDS for MySQL instance](~~414512~~).
 *
 * @param request ModifyDBInstanceDeletionProtectionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyDBInstanceDeletionProtectionResponse
 */
func (client *Client) ModifyDBInstanceDeletionProtectionWithOptions(request *ModifyDBInstanceDeletionProtectionRequest, runtime *util.RuntimeOptions) (_result *ModifyDBInstanceDeletionProtectionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.DeletionProtection)) {
		query["DeletionProtection"] = request.DeletionProtection
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyDBInstanceDeletionProtection"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyDBInstanceDeletionProtectionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * For more information, see [Enable or disable the release protection feature for an ApsaraDB RDS for MySQL instance](~~414512~~).
 *
 * @param request ModifyDBInstanceDeletionProtectionRequest
 * @return ModifyDBInstanceDeletionProtectionResponse
 */
func (client *Client) ModifyDBInstanceDeletionProtection(request *ModifyDBInstanceDeletionProtectionRequest) (_result *ModifyDBInstanceDeletionProtectionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyDBInstanceDeletionProtectionResponse{}
	_body, _err := client.ModifyDBInstanceDeletionProtectionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifyDBInstanceDescriptionWithOptions(request *ModifyDBInstanceDescriptionRequest, runtime *util.RuntimeOptions) (_result *ModifyDBInstanceDescriptionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceDescription)) {
		query["DBInstanceDescription"] = request.DBInstanceDescription
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyDBInstanceDescription"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyDBInstanceDescriptionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifyDBInstanceDescription(request *ModifyDBInstanceDescriptionRequest) (_result *ModifyDBInstanceDescriptionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyDBInstanceDescriptionResponse{}
	_body, _err := client.ModifyDBInstanceDescriptionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * RDS MySQL
 *
 * @param tmpReq ModifyDBInstanceEndpointRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyDBInstanceEndpointResponse
 */
func (client *Client) ModifyDBInstanceEndpointWithOptions(tmpReq *ModifyDBInstanceEndpointRequest, runtime *util.RuntimeOptions) (_result *ModifyDBInstanceEndpointResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &ModifyDBInstanceEndpointShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.NodeItems)) {
		request.NodeItemsShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.NodeItems, tea.String("NodeItems"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceEndpointDescription)) {
		query["DBInstanceEndpointDescription"] = request.DBInstanceEndpointDescription
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceEndpointId)) {
		query["DBInstanceEndpointId"] = request.DBInstanceEndpointId
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.NodeItemsShrink)) {
		query["NodeItems"] = request.NodeItemsShrink
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyDBInstanceEndpoint"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyDBInstanceEndpointResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * RDS MySQL
 *
 * @param request ModifyDBInstanceEndpointRequest
 * @return ModifyDBInstanceEndpointResponse
 */
func (client *Client) ModifyDBInstanceEndpoint(request *ModifyDBInstanceEndpointRequest) (_result *ModifyDBInstanceEndpointResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyDBInstanceEndpointResponse{}
	_body, _err := client.ModifyDBInstanceEndpointWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * RDS MySQL
 * ### [](#)Precautions
 * *   You can modify the following information about the endpoint of an instance: the public and internal endpoints, the public and internal ports, and the virtual private cloud (VPC), vSwitch, and IP address of the internal endpoint.
 * *   The VPC and vSwitch must be modified at the same time. If you specify the VPC, vSwitch, and IP address of the internal endpoint, you do not need to specify the endpoint and port. If you specify the endpoint and port, you do not need to specify the VPC, vSwitch, and IP address of the internal endpoint.
 *
 * @param request ModifyDBInstanceEndpointAddressRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyDBInstanceEndpointAddressResponse
 */
func (client *Client) ModifyDBInstanceEndpointAddressWithOptions(request *ModifyDBInstanceEndpointAddressRequest, runtime *util.RuntimeOptions) (_result *ModifyDBInstanceEndpointAddressResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.ConnectionString)) {
		query["ConnectionString"] = request.ConnectionString
	}

	if !tea.BoolValue(util.IsUnset(request.ConnectionStringPrefix)) {
		query["ConnectionStringPrefix"] = request.ConnectionStringPrefix
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceEndpointId)) {
		query["DBInstanceEndpointId"] = request.DBInstanceEndpointId
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Port)) {
		query["Port"] = request.Port
	}

	if !tea.BoolValue(util.IsUnset(request.PrivateIpAddress)) {
		query["PrivateIpAddress"] = request.PrivateIpAddress
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.VSwitchId)) {
		query["VSwitchId"] = request.VSwitchId
	}

	if !tea.BoolValue(util.IsUnset(request.VpcId)) {
		query["VpcId"] = request.VpcId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyDBInstanceEndpointAddress"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyDBInstanceEndpointAddressResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * RDS MySQL
 * ### [](#)Precautions
 * *   You can modify the following information about the endpoint of an instance: the public and internal endpoints, the public and internal ports, and the virtual private cloud (VPC), vSwitch, and IP address of the internal endpoint.
 * *   The VPC and vSwitch must be modified at the same time. If you specify the VPC, vSwitch, and IP address of the internal endpoint, you do not need to specify the endpoint and port. If you specify the endpoint and port, you do not need to specify the VPC, vSwitch, and IP address of the internal endpoint.
 *
 * @param request ModifyDBInstanceEndpointAddressRequest
 * @return ModifyDBInstanceEndpointAddressResponse
 */
func (client *Client) ModifyDBInstanceEndpointAddress(request *ModifyDBInstanceEndpointAddressRequest) (_result *ModifyDBInstanceEndpointAddressResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyDBInstanceEndpointAddressResponse{}
	_body, _err := client.ModifyDBInstanceEndpointAddressWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifyDBInstanceHAConfigWithOptions(request *ModifyDBInstanceHAConfigRequest, runtime *util.RuntimeOptions) (_result *ModifyDBInstanceHAConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DbInstanceId)) {
		query["DbInstanceId"] = request.DbInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.HAMode)) {
		query["HAMode"] = request.HAMode
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SyncMode)) {
		query["SyncMode"] = request.SyncMode
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyDBInstanceHAConfig"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyDBInstanceHAConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifyDBInstanceHAConfig(request *ModifyDBInstanceHAConfigRequest) (_result *ModifyDBInstanceHAConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyDBInstanceHAConfigResponse{}
	_body, _err := client.ModifyDBInstanceHAConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can set the maintenance time to a period of time during off-peak hours. Alibaba Cloud performs routine maintenance within the maintenance time to minimize impacts on your business.
 *
 * @param request ModifyDBInstanceMaintainTimeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyDBInstanceMaintainTimeResponse
 */
func (client *Client) ModifyDBInstanceMaintainTimeWithOptions(request *ModifyDBInstanceMaintainTimeRequest, runtime *util.RuntimeOptions) (_result *ModifyDBInstanceMaintainTimeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.MaintainTime)) {
		query["MaintainTime"] = request.MaintainTime
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyDBInstanceMaintainTime"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyDBInstanceMaintainTimeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can set the maintenance time to a period of time during off-peak hours. Alibaba Cloud performs routine maintenance within the maintenance time to minimize impacts on your business.
 *
 * @param request ModifyDBInstanceMaintainTimeRequest
 * @return ModifyDBInstanceMaintainTimeResponse
 */
func (client *Client) ModifyDBInstanceMaintainTime(request *ModifyDBInstanceMaintainTimeRequest) (_result *ModifyDBInstanceMaintainTimeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyDBInstanceMaintainTimeResponse{}
	_body, _err := client.ModifyDBInstanceMaintainTimeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   PostgreSQL
 * ### [](#)References
 * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * [View the Enhanced Monitoring metrics](~~299200~~)
 *
 * @param request ModifyDBInstanceMetricsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyDBInstanceMetricsResponse
 */
func (client *Client) ModifyDBInstanceMetricsWithOptions(request *ModifyDBInstanceMetricsRequest, runtime *util.RuntimeOptions) (_result *ModifyDBInstanceMetricsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceName)) {
		query["DBInstanceName"] = request.DBInstanceName
	}

	if !tea.BoolValue(util.IsUnset(request.MetricsConfig)) {
		query["MetricsConfig"] = request.MetricsConfig
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Scope)) {
		query["Scope"] = request.Scope
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyDBInstanceMetrics"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyDBInstanceMetricsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   PostgreSQL
 * ### [](#)References
 * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * [View the Enhanced Monitoring metrics](~~299200~~)
 *
 * @param request ModifyDBInstanceMetricsRequest
 * @return ModifyDBInstanceMetricsResponse
 */
func (client *Client) ModifyDBInstanceMetrics(request *ModifyDBInstanceMetricsRequest) (_result *ModifyDBInstanceMetricsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyDBInstanceMetricsResponse{}
	_body, _err := client.ModifyDBInstanceMetricsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   SQL Server
 * ### [](#)Usage notes
 * If you use the Every 5 Seconds monitoring frequency, you are charged additional fees. Before you call this operation, make sure that you understand the [billing methods and pricing](~~45020~~) of ApsaraDB RDS.
 * ### [](#)References
 * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * *   [Configure the monitoring frequency for an ApsaraDB RDS for MySQL instance](~~96112~~)
 * *   [Configure the monitoring frequency for an ApsaraDB RDS for SQL Server instance](~~95710~~)
 *
 * @param request ModifyDBInstanceMonitorRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyDBInstanceMonitorResponse
 */
func (client *Client) ModifyDBInstanceMonitorWithOptions(request *ModifyDBInstanceMonitorRequest, runtime *util.RuntimeOptions) (_result *ModifyDBInstanceMonitorResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Period)) {
		query["Period"] = request.Period
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyDBInstanceMonitor"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyDBInstanceMonitorResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   SQL Server
 * ### [](#)Usage notes
 * If you use the Every 5 Seconds monitoring frequency, you are charged additional fees. Before you call this operation, make sure that you understand the [billing methods and pricing](~~45020~~) of ApsaraDB RDS.
 * ### [](#)References
 * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * *   [Configure the monitoring frequency for an ApsaraDB RDS for MySQL instance](~~96112~~)
 * *   [Configure the monitoring frequency for an ApsaraDB RDS for SQL Server instance](~~95710~~)
 *
 * @param request ModifyDBInstanceMonitorRequest
 * @return ModifyDBInstanceMonitorResponse
 */
func (client *Client) ModifyDBInstanceMonitor(request *ModifyDBInstanceMonitorRequest) (_result *ModifyDBInstanceMonitorResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyDBInstanceMonitorResponse{}
	_body, _err := client.ModifyDBInstanceMonitorWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * When an ApsaraDB for RDS instance is in the hybrid access mode, which uses both a VPC endpoint and a classic network endpoint, this operation is used to extend the expiration time of the classic network endpoint.
 *
 * @param request ModifyDBInstanceNetworkExpireTimeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyDBInstanceNetworkExpireTimeResponse
 */
func (client *Client) ModifyDBInstanceNetworkExpireTimeWithOptions(request *ModifyDBInstanceNetworkExpireTimeRequest, runtime *util.RuntimeOptions) (_result *ModifyDBInstanceNetworkExpireTimeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClassicExpiredDays)) {
		query["ClassicExpiredDays"] = request.ClassicExpiredDays
	}

	if !tea.BoolValue(util.IsUnset(request.ConnectionString)) {
		query["ConnectionString"] = request.ConnectionString
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyDBInstanceNetworkExpireTime"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyDBInstanceNetworkExpireTimeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * When an ApsaraDB for RDS instance is in the hybrid access mode, which uses both a VPC endpoint and a classic network endpoint, this operation is used to extend the expiration time of the classic network endpoint.
 *
 * @param request ModifyDBInstanceNetworkExpireTimeRequest
 * @return ModifyDBInstanceNetworkExpireTimeResponse
 */
func (client *Client) ModifyDBInstanceNetworkExpireTime(request *ModifyDBInstanceNetworkExpireTimeRequest) (_result *ModifyDBInstanceNetworkExpireTimeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyDBInstanceNetworkExpireTimeResponse{}
	_body, _err := client.ModifyDBInstanceNetworkExpireTimeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   RDS MySQL
 * *   RDS PostgreSQL
 * *   RDS SQL Server
 * ### [](#)References
 * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * *   [Change the network type of an ApsaraDB RDS for MySQL instance](~~96109~~)
 * *   [Change the network type of an ApsaraDB RDS for PostgreSQL instance](~~96761~~)
 * *   [Change the network type of an ApsaraDB RDS for SQL Server instance](~~95707~~)
 *
 * @param request ModifyDBInstanceNetworkTypeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyDBInstanceNetworkTypeResponse
 */
func (client *Client) ModifyDBInstanceNetworkTypeWithOptions(request *ModifyDBInstanceNetworkTypeRequest, runtime *util.RuntimeOptions) (_result *ModifyDBInstanceNetworkTypeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClassicExpiredDays)) {
		query["ClassicExpiredDays"] = request.ClassicExpiredDays
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceNetworkType)) {
		query["InstanceNetworkType"] = request.InstanceNetworkType
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PrivateIpAddress)) {
		query["PrivateIpAddress"] = request.PrivateIpAddress
	}

	if !tea.BoolValue(util.IsUnset(request.ReadWriteSplittingClassicExpiredDays)) {
		query["ReadWriteSplittingClassicExpiredDays"] = request.ReadWriteSplittingClassicExpiredDays
	}

	if !tea.BoolValue(util.IsUnset(request.ReadWriteSplittingPrivateIpAddress)) {
		query["ReadWriteSplittingPrivateIpAddress"] = request.ReadWriteSplittingPrivateIpAddress
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RetainClassic)) {
		query["RetainClassic"] = request.RetainClassic
	}

	if !tea.BoolValue(util.IsUnset(request.VPCId)) {
		query["VPCId"] = request.VPCId
	}

	if !tea.BoolValue(util.IsUnset(request.VSwitchId)) {
		query["VSwitchId"] = request.VSwitchId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyDBInstanceNetworkType"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyDBInstanceNetworkTypeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   RDS MySQL
 * *   RDS PostgreSQL
 * *   RDS SQL Server
 * ### [](#)References
 * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * *   [Change the network type of an ApsaraDB RDS for MySQL instance](~~96109~~)
 * *   [Change the network type of an ApsaraDB RDS for PostgreSQL instance](~~96761~~)
 * *   [Change the network type of an ApsaraDB RDS for SQL Server instance](~~95707~~)
 *
 * @param request ModifyDBInstanceNetworkTypeRequest
 * @return ModifyDBInstanceNetworkTypeResponse
 */
func (client *Client) ModifyDBInstanceNetworkType(request *ModifyDBInstanceNetworkTypeRequest) (_result *ModifyDBInstanceNetworkTypeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyDBInstanceNetworkTypeResponse{}
	_body, _err := client.ModifyDBInstanceNetworkTypeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * This operation is used to change only the billing method of an instance from pay-as-you-go to subscription.
 * The following requirements must be met:
 * *   The instance belongs to the current account.
 * *   The instance uses one of the most recent instance types. For more information, see [Instance types](~~26312~~).
 *     **
 *     **Note**You cannot change the billing method of an instance that uses a phased-out instance type from pay-as-you-go to subscription. If you want to change the billing method of an instance that uses a phased-out instance type from pay-as-you-go to subscription, you must change the instance type of the instance to one of the most recent instance types. Then, you can change the billing method of the instance from pay-as-you-go to subscription. To change the instance type of an instance, you can change the instance specifications of the instance. For more information, see [Change the specifications of an ApsaraDB RDS instance](~~96061~~).
 * *   The instance uses the pay-as-you-go billing method and is in the Running state.
 * *   Your Alibaba Cloud account has no unpaid orders for the instance for which you want to change the billing method.
 *
 * @param request ModifyDBInstancePayTypeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyDBInstancePayTypeResponse
 */
func (client *Client) ModifyDBInstancePayTypeWithOptions(request *ModifyDBInstancePayTypeRequest, runtime *util.RuntimeOptions) (_result *ModifyDBInstancePayTypeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.PayType)) {
		query["PayType"] = request.PayType
	}

	if !tea.BoolValue(util.IsUnset(request.Period)) {
		query["Period"] = request.Period
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.UsedTime)) {
		query["UsedTime"] = request.UsedTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyDBInstancePayType"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyDBInstancePayTypeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * This operation is used to change only the billing method of an instance from pay-as-you-go to subscription.
 * The following requirements must be met:
 * *   The instance belongs to the current account.
 * *   The instance uses one of the most recent instance types. For more information, see [Instance types](~~26312~~).
 *     **
 *     **Note**You cannot change the billing method of an instance that uses a phased-out instance type from pay-as-you-go to subscription. If you want to change the billing method of an instance that uses a phased-out instance type from pay-as-you-go to subscription, you must change the instance type of the instance to one of the most recent instance types. Then, you can change the billing method of the instance from pay-as-you-go to subscription. To change the instance type of an instance, you can change the instance specifications of the instance. For more information, see [Change the specifications of an ApsaraDB RDS instance](~~96061~~).
 * *   The instance uses the pay-as-you-go billing method and is in the Running state.
 * *   Your Alibaba Cloud account has no unpaid orders for the instance for which you want to change the billing method.
 *
 * @param request ModifyDBInstancePayTypeRequest
 * @return ModifyDBInstancePayTypeResponse
 */
func (client *Client) ModifyDBInstancePayType(request *ModifyDBInstancePayTypeRequest) (_result *ModifyDBInstancePayTypeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyDBInstancePayTypeResponse{}
	_body, _err := client.ModifyDBInstancePayTypeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > This operation is phased out.
 *
 * @param request ModifyDBInstanceProxyConfigurationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyDBInstanceProxyConfigurationResponse
 */
func (client *Client) ModifyDBInstanceProxyConfigurationWithOptions(request *ModifyDBInstanceProxyConfigurationRequest, runtime *util.RuntimeOptions) (_result *ModifyDBInstanceProxyConfigurationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ProxyConfigurationKey)) {
		query["ProxyConfigurationKey"] = request.ProxyConfigurationKey
	}

	if !tea.BoolValue(util.IsUnset(request.ProxyConfigurationValue)) {
		query["ProxyConfigurationValue"] = request.ProxyConfigurationValue
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyDBInstanceProxyConfiguration"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyDBInstanceProxyConfigurationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > This operation is phased out.
 *
 * @param request ModifyDBInstanceProxyConfigurationRequest
 * @return ModifyDBInstanceProxyConfigurationResponse
 */
func (client *Client) ModifyDBInstanceProxyConfiguration(request *ModifyDBInstanceProxyConfigurationRequest) (_result *ModifyDBInstanceProxyConfigurationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyDBInstanceProxyConfigurationResponse{}
	_body, _err := client.ModifyDBInstanceProxyConfigurationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * ### [](#)References
 * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
 * *   [Use the SSL encryption feature for an ApsaraDB RDS for MySQL instance](~~96120~~)
 * *   [Use the SSL encryption feature for an ApsaraDB RDS for PostgreSQL instance](~~229517~~)
 * *   [Use the SSL encryption feature for an ApsaraDB RDS for SQL Server instance](~~95715~~)
 *
 * @param request ModifyDBInstanceSSLRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyDBInstanceSSLResponse
 */
func (client *Client) ModifyDBInstanceSSLWithOptions(request *ModifyDBInstanceSSLRequest, runtime *util.RuntimeOptions) (_result *ModifyDBInstanceSSLResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ACL)) {
		query["ACL"] = request.ACL
	}

	if !tea.BoolValue(util.IsUnset(request.CAType)) {
		query["CAType"] = request.CAType
	}

	if !tea.BoolValue(util.IsUnset(request.ClientCACert)) {
		query["ClientCACert"] = request.ClientCACert
	}

	if !tea.BoolValue(util.IsUnset(request.ClientCAEnabled)) {
		query["ClientCAEnabled"] = request.ClientCAEnabled
	}

	if !tea.BoolValue(util.IsUnset(request.ClientCertRevocationList)) {
		query["ClientCertRevocationList"] = request.ClientCertRevocationList
	}

	if !tea.BoolValue(util.IsUnset(request.ClientCrlEnabled)) {
		query["ClientCrlEnabled"] = request.ClientCrlEnabled
	}

	if !tea.BoolValue(util.IsUnset(request.ConnectionString)) {
		query["ConnectionString"] = request.ConnectionString
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ReplicationACL)) {
		query["ReplicationACL"] = request.ReplicationACL
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SSLEnabled)) {
		query["SSLEnabled"] = request.SSLEnabled
	}

	if !tea.BoolValue(util.IsUnset(request.ServerCert)) {
		query["ServerCert"] = request.ServerCert
	}

	if !tea.BoolValue(util.IsUnset(request.ServerKey)) {
		query["ServerKey"] = request.ServerKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyDBInstanceSSL"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyDBInstanceSSLResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * ### [](#)References
 * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
 * *   [Use the SSL encryption feature for an ApsaraDB RDS for MySQL instance](~~96120~~)
 * *   [Use the SSL encryption feature for an ApsaraDB RDS for PostgreSQL instance](~~229517~~)
 * *   [Use the SSL encryption feature for an ApsaraDB RDS for SQL Server instance](~~95715~~)
 *
 * @param request ModifyDBInstanceSSLRequest
 * @return ModifyDBInstanceSSLResponse
 */
func (client *Client) ModifyDBInstanceSSL(request *ModifyDBInstanceSSLRequest) (_result *ModifyDBInstanceSSLResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyDBInstanceSSLResponse{}
	_body, _err := client.ModifyDBInstanceSSLWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 * ### References
 * > Fees are generated if the call is successful. Before you call this operation, carefully read the following documentation:
 * *   [Change the specifications of an ApsaraDB RDS for MySQL instance](~~96061~~)
 * *   [Change the specifications of an ApsaraDB RDS for PostgreSQL instance](~~96750~~)
 * *   [Change the specifications of an ApsaraDB RDS for SQL Server instance](~~95665~~)
 * *   [Change the specifications of an ApsaraDB RDS for MariaDB instance](~~97129~~)
 *
 * @param tmpReq ModifyDBInstanceSpecRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyDBInstanceSpecResponse
 */
func (client *Client) ModifyDBInstanceSpecWithOptions(tmpReq *ModifyDBInstanceSpecRequest, runtime *util.RuntimeOptions) (_result *ModifyDBInstanceSpecResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &ModifyDBInstanceSpecShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.ServerlessConfiguration)) {
		request.ServerlessConfigurationShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.ServerlessConfiguration, tea.String("ServerlessConfiguration"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AutoUseCoupon)) {
		query["AutoUseCoupon"] = request.AutoUseCoupon
	}

	if !tea.BoolValue(util.IsUnset(request.BurstingEnabled)) {
		query["BurstingEnabled"] = request.BurstingEnabled
	}

	if !tea.BoolValue(util.IsUnset(request.Category)) {
		query["Category"] = request.Category
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceClass)) {
		query["DBInstanceClass"] = request.DBInstanceClass
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceStorage)) {
		query["DBInstanceStorage"] = request.DBInstanceStorage
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceStorageType)) {
		query["DBInstanceStorageType"] = request.DBInstanceStorageType
	}

	if !tea.BoolValue(util.IsUnset(request.DedicatedHostGroupId)) {
		query["DedicatedHostGroupId"] = request.DedicatedHostGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.Direction)) {
		query["Direction"] = request.Direction
	}

	if !tea.BoolValue(util.IsUnset(request.EffectiveTime)) {
		query["EffectiveTime"] = request.EffectiveTime
	}

	if !tea.BoolValue(util.IsUnset(request.EngineVersion)) {
		query["EngineVersion"] = request.EngineVersion
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PayType)) {
		query["PayType"] = request.PayType
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ServerlessConfigurationShrink)) {
		query["ServerlessConfiguration"] = request.ServerlessConfigurationShrink
	}

	if !tea.BoolValue(util.IsUnset(request.SourceBiz)) {
		query["SourceBiz"] = request.SourceBiz
	}

	if !tea.BoolValue(util.IsUnset(request.SwitchTime)) {
		query["SwitchTime"] = request.SwitchTime
	}

	if !tea.BoolValue(util.IsUnset(request.TargetMinorVersion)) {
		query["TargetMinorVersion"] = request.TargetMinorVersion
	}

	if !tea.BoolValue(util.IsUnset(request.UsedTime)) {
		query["UsedTime"] = request.UsedTime
	}

	if !tea.BoolValue(util.IsUnset(request.ZoneId)) {
		query["ZoneId"] = request.ZoneId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyDBInstanceSpec"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyDBInstanceSpecResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 * ### References
 * > Fees are generated if the call is successful. Before you call this operation, carefully read the following documentation:
 * *   [Change the specifications of an ApsaraDB RDS for MySQL instance](~~96061~~)
 * *   [Change the specifications of an ApsaraDB RDS for PostgreSQL instance](~~96750~~)
 * *   [Change the specifications of an ApsaraDB RDS for SQL Server instance](~~95665~~)
 * *   [Change the specifications of an ApsaraDB RDS for MariaDB instance](~~97129~~)
 *
 * @param request ModifyDBInstanceSpecRequest
 * @return ModifyDBInstanceSpecResponse
 */
func (client *Client) ModifyDBInstanceSpec(request *ModifyDBInstanceSpecRequest) (_result *ModifyDBInstanceSpecResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyDBInstanceSpecResponse{}
	_body, _err := client.ModifyDBInstanceSpecWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * ### References
 * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
 * *   [Configure TDE for an ApsaraDB RDS for MySQL instance](~~96121~~)
 * *   [Configure TDE for an ApsaraDB RDS for PostgreSQL instance](~~465652~~)
 * *   [Configure TDE for an ApsaraDB RDS for SQL Server instance](~~95716~~)
 *
 * @param request ModifyDBInstanceTDERequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyDBInstanceTDEResponse
 */
func (client *Client) ModifyDBInstanceTDEWithOptions(request *ModifyDBInstanceTDERequest, runtime *util.RuntimeOptions) (_result *ModifyDBInstanceTDEResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Certificate)) {
		query["Certificate"] = request.Certificate
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.DBName)) {
		query["DBName"] = request.DBName
	}

	if !tea.BoolValue(util.IsUnset(request.EncryptionKey)) {
		query["EncryptionKey"] = request.EncryptionKey
	}

	if !tea.BoolValue(util.IsUnset(request.IsRotate)) {
		query["IsRotate"] = request.IsRotate
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PassWord)) {
		query["PassWord"] = request.PassWord
	}

	if !tea.BoolValue(util.IsUnset(request.PrivateKey)) {
		query["PrivateKey"] = request.PrivateKey
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RoleArn)) {
		query["RoleArn"] = request.RoleArn
	}

	if !tea.BoolValue(util.IsUnset(request.TDEStatus)) {
		query["TDEStatus"] = request.TDEStatus
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyDBInstanceTDE"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyDBInstanceTDEResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * ### References
 * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
 * *   [Configure TDE for an ApsaraDB RDS for MySQL instance](~~96121~~)
 * *   [Configure TDE for an ApsaraDB RDS for PostgreSQL instance](~~465652~~)
 * *   [Configure TDE for an ApsaraDB RDS for SQL Server instance](~~95716~~)
 *
 * @param request ModifyDBInstanceTDERequest
 * @return ModifyDBInstanceTDEResponse
 */
func (client *Client) ModifyDBInstanceTDE(request *ModifyDBInstanceTDERequest) (_result *ModifyDBInstanceTDEResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyDBInstanceTDEResponse{}
	_body, _err := client.ModifyDBInstanceTDEWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * ### [](#)References
 * > Fees are generated if the call is successful. Before you call this operation, carefully read the following topics:
 * *   [Change the specifications of an ApsaraDB RDS for MySQL instance](~~96061~~)
 *
 * @param tmpReq ModifyDBNodeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyDBNodeResponse
 */
func (client *Client) ModifyDBNodeWithOptions(tmpReq *ModifyDBNodeRequest, runtime *util.RuntimeOptions) (_result *ModifyDBNodeResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &ModifyDBNodeShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.DBNode)) {
		request.DBNodeShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.DBNode, tea.String("DBNode"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AutoPay)) {
		query["AutoPay"] = request.AutoPay
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceStorage)) {
		query["DBInstanceStorage"] = request.DBInstanceStorage
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceStorageType)) {
		query["DBInstanceStorageType"] = request.DBInstanceStorageType
	}

	if !tea.BoolValue(util.IsUnset(request.DBNodeShrink)) {
		query["DBNode"] = request.DBNodeShrink
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ProduceAsync)) {
		query["ProduceAsync"] = request.ProduceAsync
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyDBNode"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyDBNodeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * ### [](#)References
 * > Fees are generated if the call is successful. Before you call this operation, carefully read the following topics:
 * *   [Change the specifications of an ApsaraDB RDS for MySQL instance](~~96061~~)
 *
 * @param request ModifyDBNodeRequest
 * @return ModifyDBNodeResponse
 */
func (client *Client) ModifyDBNode(request *ModifyDBNodeRequest) (_result *ModifyDBNodeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyDBNodeResponse{}
	_body, _err := client.ModifyDBNodeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * >  Starting October 17, 2023, ApsaraDB RDS provides a dedicated proxy free of charge for each ApsaraDB RDS for MySQL instance on RDS Cluster Edition. For more information, see [\\[Special offers/Price changes\\] One proxy is provided free of charge for ApsaraDB RDS for MySQL instances on RDS Cluster Edition](~~2555466~~).
 * ### [](#)References
 * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
 * *   [Enable and configure the dedicated proxy feature for an ApsaraDB RDS for MySQL instance](~~197456~~)
 * *   [Enable and configure the dedicated proxy feature for an ApsaraDB RDS for PostgreSQL instance](~~418272~~)
 *
 * @param request ModifyDBProxyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyDBProxyResponse
 */
func (client *Client) ModifyDBProxyWithOptions(request *ModifyDBProxyRequest, runtime *util.RuntimeOptions) (_result *ModifyDBProxyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ConfigDBProxyService)) {
		query["ConfigDBProxyService"] = request.ConfigDBProxyService
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.DBProxyEngineType)) {
		query["DBProxyEngineType"] = request.DBProxyEngineType
	}

	if !tea.BoolValue(util.IsUnset(request.DBProxyInstanceNum)) {
		query["DBProxyInstanceNum"] = request.DBProxyInstanceNum
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceNetworkType)) {
		query["InstanceNetworkType"] = request.InstanceNetworkType
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.VPCId)) {
		query["VPCId"] = request.VPCId
	}

	if !tea.BoolValue(util.IsUnset(request.VSwitchId)) {
		query["VSwitchId"] = request.VSwitchId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyDBProxy"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyDBProxyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * >  Starting October 17, 2023, ApsaraDB RDS provides a dedicated proxy free of charge for each ApsaraDB RDS for MySQL instance on RDS Cluster Edition. For more information, see [\\[Special offers/Price changes\\] One proxy is provided free of charge for ApsaraDB RDS for MySQL instances on RDS Cluster Edition](~~2555466~~).
 * ### [](#)References
 * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
 * *   [Enable and configure the dedicated proxy feature for an ApsaraDB RDS for MySQL instance](~~197456~~)
 * *   [Enable and configure the dedicated proxy feature for an ApsaraDB RDS for PostgreSQL instance](~~418272~~)
 *
 * @param request ModifyDBProxyRequest
 * @return ModifyDBProxyResponse
 */
func (client *Client) ModifyDBProxy(request *ModifyDBProxyRequest) (_result *ModifyDBProxyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyDBProxyResponse{}
	_body, _err := client.ModifyDBProxyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   RDS MySQL
 * *   RDS PostgreSQL
 * ### [](#)References
 * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * *   [Enable and configure the dedicated proxy feature](~~197456~~)
 * *   [Create a database proxy terminal for an ApsaraDB RDS for PostgreSQL instance](~~418273~~)
 *
 * @param request ModifyDBProxyEndpointRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyDBProxyEndpointResponse
 */
func (client *Client) ModifyDBProxyEndpointWithOptions(request *ModifyDBProxyEndpointRequest, runtime *util.RuntimeOptions) (_result *ModifyDBProxyEndpointResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ConfigDBProxyFeatures)) {
		query["ConfigDBProxyFeatures"] = request.ConfigDBProxyFeatures
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.DBProxyEndpointId)) {
		query["DBProxyEndpointId"] = request.DBProxyEndpointId
	}

	if !tea.BoolValue(util.IsUnset(request.DBProxyEngineType)) {
		query["DBProxyEngineType"] = request.DBProxyEngineType
	}

	if !tea.BoolValue(util.IsUnset(request.DbEndpointAliases)) {
		query["DbEndpointAliases"] = request.DbEndpointAliases
	}

	if !tea.BoolValue(util.IsUnset(request.DbEndpointOperator)) {
		query["DbEndpointOperator"] = request.DbEndpointOperator
	}

	if !tea.BoolValue(util.IsUnset(request.DbEndpointReadWriteMode)) {
		query["DbEndpointReadWriteMode"] = request.DbEndpointReadWriteMode
	}

	if !tea.BoolValue(util.IsUnset(request.DbEndpointType)) {
		query["DbEndpointType"] = request.DbEndpointType
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ReadOnlyInstanceDistributionType)) {
		query["ReadOnlyInstanceDistributionType"] = request.ReadOnlyInstanceDistributionType
	}

	if !tea.BoolValue(util.IsUnset(request.ReadOnlyInstanceMaxDelayTime)) {
		query["ReadOnlyInstanceMaxDelayTime"] = request.ReadOnlyInstanceMaxDelayTime
	}

	if !tea.BoolValue(util.IsUnset(request.ReadOnlyInstanceWeight)) {
		query["ReadOnlyInstanceWeight"] = request.ReadOnlyInstanceWeight
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyDBProxyEndpoint"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyDBProxyEndpointResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   RDS MySQL
 * *   RDS PostgreSQL
 * ### [](#)References
 * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * *   [Enable and configure the dedicated proxy feature](~~197456~~)
 * *   [Create a database proxy terminal for an ApsaraDB RDS for PostgreSQL instance](~~418273~~)
 *
 * @param request ModifyDBProxyEndpointRequest
 * @return ModifyDBProxyEndpointResponse
 */
func (client *Client) ModifyDBProxyEndpoint(request *ModifyDBProxyEndpointRequest) (_result *ModifyDBProxyEndpointResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyDBProxyEndpointResponse{}
	_body, _err := client.ModifyDBProxyEndpointWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * ### References
 * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
 * *   [Configure the dedicated proxy endpoint of an ApsaraDB RDS for MySQL instance](~~184921~~)
 * *   [Configure the dedicated proxy endpoint of an ApsaraDB RDS for PostgreSQL instance](~~418274~~)
 *
 * @param request ModifyDBProxyEndpointAddressRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyDBProxyEndpointAddressResponse
 */
func (client *Client) ModifyDBProxyEndpointAddressWithOptions(request *ModifyDBProxyEndpointAddressRequest, runtime *util.RuntimeOptions) (_result *ModifyDBProxyEndpointAddressResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.DBProxyConnectStringNetType)) {
		query["DBProxyConnectStringNetType"] = request.DBProxyConnectStringNetType
	}

	if !tea.BoolValue(util.IsUnset(request.DBProxyEndpointId)) {
		query["DBProxyEndpointId"] = request.DBProxyEndpointId
	}

	if !tea.BoolValue(util.IsUnset(request.DBProxyEngineType)) {
		query["DBProxyEngineType"] = request.DBProxyEngineType
	}

	if !tea.BoolValue(util.IsUnset(request.DBProxyNewConnectString)) {
		query["DBProxyNewConnectString"] = request.DBProxyNewConnectString
	}

	if !tea.BoolValue(util.IsUnset(request.DBProxyNewConnectStringPort)) {
		query["DBProxyNewConnectStringPort"] = request.DBProxyNewConnectStringPort
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyDBProxyEndpointAddress"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyDBProxyEndpointAddressResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * ### References
 * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
 * *   [Configure the dedicated proxy endpoint of an ApsaraDB RDS for MySQL instance](~~184921~~)
 * *   [Configure the dedicated proxy endpoint of an ApsaraDB RDS for PostgreSQL instance](~~418274~~)
 *
 * @param request ModifyDBProxyEndpointAddressRequest
 * @return ModifyDBProxyEndpointAddressResponse
 */
func (client *Client) ModifyDBProxyEndpointAddress(request *ModifyDBProxyEndpointAddressRequest) (_result *ModifyDBProxyEndpointAddressResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyDBProxyEndpointAddressResponse{}
	_body, _err := client.ModifyDBProxyEndpointAddressWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Before you call the ModifyDBProxyInstance operation, make sure that the [ModifyDBProxy](~~141054~~) operation is called to enable the database proxy feature for the instance.
 * *   The dedicated proxy feature of ApsaraDB RDS for MySQL provides capabilities such as read/write splitting and short-lived connection optimization. For more information, see [What are database proxies?](~~138705~~)
 * *   The database proxy feature of ApsaraDB RDS for PostgreSQL supports read/write splitting. For more information, see [What are database proxies?](~~412194~~)
 *
 * @param request ModifyDBProxyInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyDBProxyInstanceResponse
 */
func (client *Client) ModifyDBProxyInstanceWithOptions(request *ModifyDBProxyInstanceRequest, runtime *util.RuntimeOptions) (_result *ModifyDBProxyInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.DBProxyEngineType)) {
		query["DBProxyEngineType"] = request.DBProxyEngineType
	}

	if !tea.BoolValue(util.IsUnset(request.DBProxyInstanceNum)) {
		query["DBProxyInstanceNum"] = request.DBProxyInstanceNum
	}

	if !tea.BoolValue(util.IsUnset(request.DBProxyInstanceType)) {
		query["DBProxyInstanceType"] = request.DBProxyInstanceType
	}

	if !tea.BoolValue(util.IsUnset(request.EffectiveSpecificTime)) {
		query["EffectiveSpecificTime"] = request.EffectiveSpecificTime
	}

	if !tea.BoolValue(util.IsUnset(request.EffectiveTime)) {
		query["EffectiveTime"] = request.EffectiveTime
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyDBProxyInstance"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyDBProxyInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Before you call the ModifyDBProxyInstance operation, make sure that the [ModifyDBProxy](~~141054~~) operation is called to enable the database proxy feature for the instance.
 * *   The dedicated proxy feature of ApsaraDB RDS for MySQL provides capabilities such as read/write splitting and short-lived connection optimization. For more information, see [What are database proxies?](~~138705~~)
 * *   The database proxy feature of ApsaraDB RDS for PostgreSQL supports read/write splitting. For more information, see [What are database proxies?](~~412194~~)
 *
 * @param request ModifyDBProxyInstanceRequest
 * @return ModifyDBProxyInstanceResponse
 */
func (client *Client) ModifyDBProxyInstance(request *ModifyDBProxyInstanceRequest) (_result *ModifyDBProxyInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyDBProxyInstanceResponse{}
	_body, _err := client.ModifyDBProxyInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Distributed transaction whitelists allow for distributed transactions between an Elastic Compute Service (ECS) instance and an RDS instance. For more information, see [Configure a distributed transaction whitelist](~~124321~~).
 * This operation is applicable to instances that run one of the following SQL Server versions in the RDS High-Availability Edition: 2012 SE, 2012 EE, 2014 SE, 2016 SE, 2016 EE, and 2017 SE.
 *
 * @param request ModifyDTCSecurityIpHostsForSQLServerRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyDTCSecurityIpHostsForSQLServerResponse
 */
func (client *Client) ModifyDTCSecurityIpHostsForSQLServerWithOptions(request *ModifyDTCSecurityIpHostsForSQLServerRequest, runtime *util.RuntimeOptions) (_result *ModifyDTCSecurityIpHostsForSQLServerResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityIpHosts)) {
		query["SecurityIpHosts"] = request.SecurityIpHosts
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	if !tea.BoolValue(util.IsUnset(request.WhiteListGroupName)) {
		query["WhiteListGroupName"] = request.WhiteListGroupName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyDTCSecurityIpHostsForSQLServer"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyDTCSecurityIpHostsForSQLServerResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Distributed transaction whitelists allow for distributed transactions between an Elastic Compute Service (ECS) instance and an RDS instance. For more information, see [Configure a distributed transaction whitelist](~~124321~~).
 * This operation is applicable to instances that run one of the following SQL Server versions in the RDS High-Availability Edition: 2012 SE, 2012 EE, 2014 SE, 2016 SE, 2016 EE, and 2017 SE.
 *
 * @param request ModifyDTCSecurityIpHostsForSQLServerRequest
 * @return ModifyDTCSecurityIpHostsForSQLServerResponse
 */
func (client *Client) ModifyDTCSecurityIpHostsForSQLServer(request *ModifyDTCSecurityIpHostsForSQLServerRequest) (_result *ModifyDTCSecurityIpHostsForSQLServerResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyDTCSecurityIpHostsForSQLServerResponse{}
	_body, _err := client.ModifyDTCSecurityIpHostsForSQLServerWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * ### [](#)References
 * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * *   [Configure automatic storage expansion for ApsaraDB RDS for MySQL](~~173826~~)
 * *   [Configure automatic storage expansion for ApsaraDB RDS for PostgreSQL](~~432496~~)
 *
 * @param request ModifyDasInstanceConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyDasInstanceConfigResponse
 */
func (client *Client) ModifyDasInstanceConfigWithOptions(request *ModifyDasInstanceConfigRequest, runtime *util.RuntimeOptions) (_result *ModifyDasInstanceConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.StorageAutoScale)) {
		query["StorageAutoScale"] = request.StorageAutoScale
	}

	if !tea.BoolValue(util.IsUnset(request.StorageThreshold)) {
		query["StorageThreshold"] = request.StorageThreshold
	}

	if !tea.BoolValue(util.IsUnset(request.StorageUpperBound)) {
		query["StorageUpperBound"] = request.StorageUpperBound
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyDasInstanceConfig"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyDasInstanceConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * ### [](#)References
 * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * *   [Configure automatic storage expansion for ApsaraDB RDS for MySQL](~~173826~~)
 * *   [Configure automatic storage expansion for ApsaraDB RDS for PostgreSQL](~~432496~~)
 *
 * @param request ModifyDasInstanceConfigRequest
 * @return ModifyDasInstanceConfigResponse
 */
func (client *Client) ModifyDasInstanceConfig(request *ModifyDasInstanceConfigRequest) (_result *ModifyDasInstanceConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyDasInstanceConfigResponse{}
	_body, _err := client.ModifyDasInstanceConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engine
 * *   SQL Server
 *
 * @param request ModifyDatabaseConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyDatabaseConfigResponse
 */
func (client *Client) ModifyDatabaseConfigWithOptions(request *ModifyDatabaseConfigRequest, runtime *util.RuntimeOptions) (_result *ModifyDatabaseConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.DBName)) {
		query["DBName"] = request.DBName
	}

	if !tea.BoolValue(util.IsUnset(request.DatabasePropertyName)) {
		query["DatabasePropertyName"] = request.DatabasePropertyName
	}

	if !tea.BoolValue(util.IsUnset(request.DatabasePropertyValue)) {
		query["DatabasePropertyValue"] = request.DatabasePropertyValue
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyDatabaseConfig"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyDatabaseConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engine
 * *   SQL Server
 *
 * @param request ModifyDatabaseConfigRequest
 * @return ModifyDatabaseConfigResponse
 */
func (client *Client) ModifyDatabaseConfig(request *ModifyDatabaseConfigRequest) (_result *ModifyDatabaseConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyDatabaseConfigResponse{}
	_body, _err := client.ModifyDatabaseConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * RDS MySQL
 * ### [](#)References
 * > : Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation:
 * [Configure SSL encryption for a proxy endpoint](~~188164~~)
 *
 * @param request ModifyDbProxyInstanceSslRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyDbProxyInstanceSslResponse
 */
func (client *Client) ModifyDbProxyInstanceSslWithOptions(request *ModifyDbProxyInstanceSslRequest, runtime *util.RuntimeOptions) (_result *ModifyDbProxyInstanceSslResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBProxyEngineType)) {
		query["DBProxyEngineType"] = request.DBProxyEngineType
	}

	if !tea.BoolValue(util.IsUnset(request.DbInstanceId)) {
		query["DbInstanceId"] = request.DbInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.DbInstanceId)) {
		query["DbInstanceId"] = request.DbInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.DbProxyConnectString)) {
		query["DbProxyConnectString"] = request.DbProxyConnectString
	}

	if !tea.BoolValue(util.IsUnset(request.DbProxyEndpointId)) {
		query["DbProxyEndpointId"] = request.DbProxyEndpointId
	}

	if !tea.BoolValue(util.IsUnset(request.DbProxySslEnabled)) {
		query["DbProxySslEnabled"] = request.DbProxySslEnabled
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyDbProxyInstanceSsl"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyDbProxyInstanceSslResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * RDS MySQL
 * ### [](#)References
 * > : Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation:
 * [Configure SSL encryption for a proxy endpoint](~~188164~~)
 *
 * @param request ModifyDbProxyInstanceSslRequest
 * @return ModifyDbProxyInstanceSslResponse
 */
func (client *Client) ModifyDbProxyInstanceSsl(request *ModifyDbProxyInstanceSslRequest) (_result *ModifyDbProxyInstanceSslResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyDbProxyInstanceSslResponse{}
	_body, _err := client.ModifyDbProxyInstanceSslWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * By default, Alibaba Cloud uses persistent connections to check the availability of an instance. For more information, see [What is availability detection?](~~207467~~)
 *
 * @param request ModifyHADiagnoseConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyHADiagnoseConfigResponse
 */
func (client *Client) ModifyHADiagnoseConfigWithOptions(request *ModifyHADiagnoseConfigRequest, runtime *util.RuntimeOptions) (_result *ModifyHADiagnoseConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.TcpConnectionType)) {
		query["TcpConnectionType"] = request.TcpConnectionType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyHADiagnoseConfig"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyHADiagnoseConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * By default, Alibaba Cloud uses persistent connections to check the availability of an instance. For more information, see [What is availability detection?](~~207467~~)
 *
 * @param request ModifyHADiagnoseConfigRequest
 * @return ModifyHADiagnoseConfigResponse
 */
func (client *Client) ModifyHADiagnoseConfig(request *ModifyHADiagnoseConfigRequest) (_result *ModifyHADiagnoseConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyHADiagnoseConfigResponse{}
	_body, _err := client.ModifyHADiagnoseConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 * ### [](#)References
 * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
 * *   [Use the automatic primary/secondary switchover feature for an ApsaraDB RDS for MySQL instance](~~96054~~)
 * *   [Use the automatic primary/secondary switchover feature for an ApsaraDB RDS for PostgreSQL instance](~~96747~~)
 * *   [Use the automatic primary/secondary switchover feature for an ApsaraDB RDS for SQL Server instance](~~95659~~)
 * *   [Use the automatic primary/secondary switchover feature for an ApsaraDB RDS for MariaDB instance](~~97127~~)
 *
 * @param request ModifyHASwitchConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyHASwitchConfigResponse
 */
func (client *Client) ModifyHASwitchConfigWithOptions(request *ModifyHASwitchConfigRequest, runtime *util.RuntimeOptions) (_result *ModifyHASwitchConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.HAConfig)) {
		query["HAConfig"] = request.HAConfig
	}

	if !tea.BoolValue(util.IsUnset(request.ManualHATime)) {
		query["ManualHATime"] = request.ManualHATime
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyHASwitchConfig"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyHASwitchConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 * ### [](#)References
 * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
 * *   [Use the automatic primary/secondary switchover feature for an ApsaraDB RDS for MySQL instance](~~96054~~)
 * *   [Use the automatic primary/secondary switchover feature for an ApsaraDB RDS for PostgreSQL instance](~~96747~~)
 * *   [Use the automatic primary/secondary switchover feature for an ApsaraDB RDS for SQL Server instance](~~95659~~)
 * *   [Use the automatic primary/secondary switchover feature for an ApsaraDB RDS for MariaDB instance](~~97127~~)
 *
 * @param request ModifyHASwitchConfigRequest
 * @return ModifyHASwitchConfigResponse
 */
func (client *Client) ModifyHASwitchConfig(request *ModifyHASwitchConfigRequest) (_result *ModifyHASwitchConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyHASwitchConfigResponse{}
	_body, _err := client.ModifyHASwitchConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * If you enable auto-renewal for your instance, you do not need to manually renew your subscription or be concerned about business interruptions caused by subscription expiration. For more information, see [Configure auto-renewal](~~96049~~).
 *
 * @param request ModifyInstanceAutoRenewalAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyInstanceAutoRenewalAttributeResponse
 */
func (client *Client) ModifyInstanceAutoRenewalAttributeWithOptions(request *ModifyInstanceAutoRenewalAttributeRequest, runtime *util.RuntimeOptions) (_result *ModifyInstanceAutoRenewalAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AutoRenew)) {
		query["AutoRenew"] = request.AutoRenew
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Duration)) {
		query["Duration"] = request.Duration
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyInstanceAutoRenewalAttribute"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyInstanceAutoRenewalAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * If you enable auto-renewal for your instance, you do not need to manually renew your subscription or be concerned about business interruptions caused by subscription expiration. For more information, see [Configure auto-renewal](~~96049~~).
 *
 * @param request ModifyInstanceAutoRenewalAttributeRequest
 * @return ModifyInstanceAutoRenewalAttributeResponse
 */
func (client *Client) ModifyInstanceAutoRenewalAttribute(request *ModifyInstanceAutoRenewalAttributeRequest) (_result *ModifyInstanceAutoRenewalAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyInstanceAutoRenewalAttributeResponse{}
	_body, _err := client.ModifyInstanceAutoRenewalAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * ### [](#)References
 * *   [Use the cross-region backup feature of an ApsaraDB RDS for MySQL instance](~~120824~~)
 * *   [Use the cross-region backup feature for an ApsaraDB RDS for PostgreSQL instance](~~206671~~)
 * *   [Use the cross-region backup feature for an ApsaraDB RDS for SQL Server instance](~~187923~~)
 *
 * @param request ModifyInstanceCrossBackupPolicyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyInstanceCrossBackupPolicyResponse
 */
func (client *Client) ModifyInstanceCrossBackupPolicyWithOptions(request *ModifyInstanceCrossBackupPolicyRequest, runtime *util.RuntimeOptions) (_result *ModifyInstanceCrossBackupPolicyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BackupEnabled)) {
		query["BackupEnabled"] = request.BackupEnabled
	}

	if !tea.BoolValue(util.IsUnset(request.CrossBackupRegion)) {
		query["CrossBackupRegion"] = request.CrossBackupRegion
	}

	if !tea.BoolValue(util.IsUnset(request.CrossBackupType)) {
		query["CrossBackupType"] = request.CrossBackupType
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.LogBackupEnabled)) {
		query["LogBackupEnabled"] = request.LogBackupEnabled
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RetentType)) {
		query["RetentType"] = request.RetentType
	}

	if !tea.BoolValue(util.IsUnset(request.Retention)) {
		query["Retention"] = request.Retention
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyInstanceCrossBackupPolicy"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyInstanceCrossBackupPolicyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * ### [](#)References
 * *   [Use the cross-region backup feature of an ApsaraDB RDS for MySQL instance](~~120824~~)
 * *   [Use the cross-region backup feature for an ApsaraDB RDS for PostgreSQL instance](~~206671~~)
 * *   [Use the cross-region backup feature for an ApsaraDB RDS for SQL Server instance](~~187923~~)
 *
 * @param request ModifyInstanceCrossBackupPolicyRequest
 * @return ModifyInstanceCrossBackupPolicyResponse
 */
func (client *Client) ModifyInstanceCrossBackupPolicy(request *ModifyInstanceCrossBackupPolicyRequest) (_result *ModifyInstanceCrossBackupPolicyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyInstanceCrossBackupPolicyResponse{}
	_body, _err := client.ModifyInstanceCrossBackupPolicyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * RDS PostgreSQL
 * ### [](#)References
 * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * *   [Connect an ApsaraDB RDS for PostgreSQL instance to a self-managed AD domain](~~349288~~)
 * *   [The pg_hba.conf File](https://www.postgresql.org/docs/11/auth-pg-hba-conf.html)
 *
 * @param request ModifyPGHbaConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyPGHbaConfigResponse
 */
func (client *Client) ModifyPGHbaConfigWithOptions(request *ModifyPGHbaConfigRequest, runtime *util.RuntimeOptions) (_result *ModifyPGHbaConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.HbaItem)) {
		query["HbaItem"] = request.HbaItem
	}

	if !tea.BoolValue(util.IsUnset(request.OpsType)) {
		query["OpsType"] = request.OpsType
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyPGHbaConfig"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyPGHbaConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * RDS PostgreSQL
 * ### [](#)References
 * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * *   [Connect an ApsaraDB RDS for PostgreSQL instance to a self-managed AD domain](~~349288~~)
 * *   [The pg_hba.conf File](https://www.postgresql.org/docs/11/auth-pg-hba-conf.html)
 *
 * @param request ModifyPGHbaConfigRequest
 * @return ModifyPGHbaConfigResponse
 */
func (client *Client) ModifyPGHbaConfig(request *ModifyPGHbaConfigRequest) (_result *ModifyPGHbaConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyPGHbaConfigResponse{}
	_body, _err := client.ModifyPGHbaConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can modify the parameters directly or by using a parameter template. After you submit the parameter modification request, ApsaraDB RDS starts a task to apply the new parameter values to the instance. If a new parameter value takes effect only after the instance restarts, ApsaraDB RDS restarts the instance. For information about configurable parameters, see [Configure the parameters of an ApsaraDB RDS for MySQL instance](~~96063~~).
 * > Before the system runs a parameter modification task, the system checks whether the parameters exist, whether they are configurable, and whether the new parameter values are valid.
 *
 * @param request ModifyParameterRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyParameterResponse
 */
func (client *Client) ModifyParameterWithOptions(request *ModifyParameterRequest, runtime *util.RuntimeOptions) (_result *ModifyParameterResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Forcerestart)) {
		query["Forcerestart"] = request.Forcerestart
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ParameterGroupId)) {
		query["ParameterGroupId"] = request.ParameterGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.Parameters)) {
		query["Parameters"] = request.Parameters
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SwitchTime)) {
		query["SwitchTime"] = request.SwitchTime
	}

	if !tea.BoolValue(util.IsUnset(request.SwitchTimeMode)) {
		query["SwitchTimeMode"] = request.SwitchTimeMode
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyParameter"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyParameterResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can modify the parameters directly or by using a parameter template. After you submit the parameter modification request, ApsaraDB RDS starts a task to apply the new parameter values to the instance. If a new parameter value takes effect only after the instance restarts, ApsaraDB RDS restarts the instance. For information about configurable parameters, see [Configure the parameters of an ApsaraDB RDS for MySQL instance](~~96063~~).
 * > Before the system runs a parameter modification task, the system checks whether the parameters exist, whether they are configurable, and whether the new parameter values are valid.
 *
 * @param request ModifyParameterRequest
 * @return ModifyParameterResponse
 */
func (client *Client) ModifyParameter(request *ModifyParameterRequest) (_result *ModifyParameterResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyParameterResponse{}
	_body, _err := client.ModifyParameterWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * ### [](#)References
 * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * *   [Use a parameter template to configure the parameters of ApsaraDB RDS for MySQL instances](~~130565~~)
 * *   [Use a parameter template to configure the parameters of ApsaraDB RDS for PostgreSQL instances](~~457176~~)
 *
 * @param request ModifyParameterGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyParameterGroupResponse
 */
func (client *Client) ModifyParameterGroupWithOptions(request *ModifyParameterGroupRequest, runtime *util.RuntimeOptions) (_result *ModifyParameterGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ModifyMode)) {
		query["ModifyMode"] = request.ModifyMode
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ParameterGroupDesc)) {
		query["ParameterGroupDesc"] = request.ParameterGroupDesc
	}

	if !tea.BoolValue(util.IsUnset(request.ParameterGroupId)) {
		query["ParameterGroupId"] = request.ParameterGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ParameterGroupName)) {
		query["ParameterGroupName"] = request.ParameterGroupName
	}

	if !tea.BoolValue(util.IsUnset(request.Parameters)) {
		query["Parameters"] = request.Parameters
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyParameterGroup"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyParameterGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * ### [](#)References
 * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * *   [Use a parameter template to configure the parameters of ApsaraDB RDS for MySQL instances](~~130565~~)
 * *   [Use a parameter template to configure the parameters of ApsaraDB RDS for PostgreSQL instances](~~457176~~)
 *
 * @param request ModifyParameterGroupRequest
 * @return ModifyParameterGroupResponse
 */
func (client *Client) ModifyParameterGroup(request *ModifyParameterGroupRequest) (_result *ModifyParameterGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyParameterGroupResponse{}
	_body, _err := client.ModifyParameterGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   SQL Server
 * ### [](#)Prerequisites
 * Before you call this operation, make sure that the following requirements are met:
 * *   The shared proxy feature is enabled for your ApsaraDB RDS for MySQL instance.
 * *   The read/write splitting feature is enabled for your ApsaraDB RDS for MySQL instance.
 * *   The instance must run one of the following database engine versions and RDS editions:
 *     *   MySQL 5.7 on RDS High-availability Edition with local disks
 *     *   MySQL 5.6
 *     *   SQL Server on RDS Cluster Edition
 *
 * @param request ModifyReadWriteSplittingConnectionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyReadWriteSplittingConnectionResponse
 */
func (client *Client) ModifyReadWriteSplittingConnectionWithOptions(request *ModifyReadWriteSplittingConnectionRequest, runtime *util.RuntimeOptions) (_result *ModifyReadWriteSplittingConnectionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ConnectionStringPrefix)) {
		query["ConnectionStringPrefix"] = request.ConnectionStringPrefix
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.DistributionType)) {
		query["DistributionType"] = request.DistributionType
	}

	if !tea.BoolValue(util.IsUnset(request.MaxDelayTime)) {
		query["MaxDelayTime"] = request.MaxDelayTime
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Port)) {
		query["Port"] = request.Port
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Weight)) {
		query["Weight"] = request.Weight
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyReadWriteSplittingConnection"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyReadWriteSplittingConnectionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   SQL Server
 * ### [](#)Prerequisites
 * Before you call this operation, make sure that the following requirements are met:
 * *   The shared proxy feature is enabled for your ApsaraDB RDS for MySQL instance.
 * *   The read/write splitting feature is enabled for your ApsaraDB RDS for MySQL instance.
 * *   The instance must run one of the following database engine versions and RDS editions:
 *     *   MySQL 5.7 on RDS High-availability Edition with local disks
 *     *   MySQL 5.6
 *     *   SQL Server on RDS Cluster Edition
 *
 * @param request ModifyReadWriteSplittingConnectionRequest
 * @return ModifyReadWriteSplittingConnectionResponse
 */
func (client *Client) ModifyReadWriteSplittingConnection(request *ModifyReadWriteSplittingConnectionRequest) (_result *ModifyReadWriteSplittingConnectionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyReadWriteSplittingConnectionResponse{}
	_body, _err := client.ModifyReadWriteSplittingConnectionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Supported database engines
 * RDS MySQL
 * ### References
 * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * [Set the data replication latency of a read-only ApsaraDB RDS for MySQL instance](~~96056~~)
 *
 * @param request ModifyReadonlyInstanceDelayReplicationTimeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyReadonlyInstanceDelayReplicationTimeResponse
 */
func (client *Client) ModifyReadonlyInstanceDelayReplicationTimeWithOptions(request *ModifyReadonlyInstanceDelayReplicationTimeRequest, runtime *util.RuntimeOptions) (_result *ModifyReadonlyInstanceDelayReplicationTimeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ReadSQLReplicationTime)) {
		query["ReadSQLReplicationTime"] = request.ReadSQLReplicationTime
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyReadonlyInstanceDelayReplicationTime"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyReadonlyInstanceDelayReplicationTimeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Supported database engines
 * RDS MySQL
 * ### References
 * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * [Set the data replication latency of a read-only ApsaraDB RDS for MySQL instance](~~96056~~)
 *
 * @param request ModifyReadonlyInstanceDelayReplicationTimeRequest
 * @return ModifyReadonlyInstanceDelayReplicationTimeResponse
 */
func (client *Client) ModifyReadonlyInstanceDelayReplicationTime(request *ModifyReadonlyInstanceDelayReplicationTimeRequest) (_result *ModifyReadonlyInstanceDelayReplicationTimeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyReadonlyInstanceDelayReplicationTimeResponse{}
	_body, _err := client.ModifyReadonlyInstanceDelayReplicationTimeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 * ### References
 * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
 * [Transfer resources across resource groups](~~94487~~)
 *
 * @param request ModifyResourceGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyResourceGroupResponse
 */
func (client *Client) ModifyResourceGroupWithOptions(request *ModifyResourceGroupRequest, runtime *util.RuntimeOptions) (_result *ModifyResourceGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyResourceGroup"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyResourceGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 * ### References
 * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
 * [Transfer resources across resource groups](~~94487~~)
 *
 * @param request ModifyResourceGroupRequest
 * @return ModifyResourceGroupResponse
 */
func (client *Client) ModifyResourceGroup(request *ModifyResourceGroupRequest) (_result *ModifyResourceGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyResourceGroupResponse{}
	_body, _err := client.ModifyResourceGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * ### References
 * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
 * *   [Use the SQL Explorer and Audit feature for an ApsaraDB RDS for MySQL instance](~~476574~~)
 * *   [Use the SQL Audit feature for an ApsaraDB RDS for PostgreSQL instance](~~96766~~)
 * *   [Use the SQL Audit feature for an ApsaraDB RDS for SQL Server instance](~~95712~~)
 *
 * @param request ModifySQLCollectorPolicyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifySQLCollectorPolicyResponse
 */
func (client *Client) ModifySQLCollectorPolicyWithOptions(request *ModifySQLCollectorPolicyRequest, runtime *util.RuntimeOptions) (_result *ModifySQLCollectorPolicyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SQLCollectorStatus)) {
		query["SQLCollectorStatus"] = request.SQLCollectorStatus
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifySQLCollectorPolicy"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifySQLCollectorPolicyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * ### References
 * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
 * *   [Use the SQL Explorer and Audit feature for an ApsaraDB RDS for MySQL instance](~~476574~~)
 * *   [Use the SQL Audit feature for an ApsaraDB RDS for PostgreSQL instance](~~96766~~)
 * *   [Use the SQL Audit feature for an ApsaraDB RDS for SQL Server instance](~~95712~~)
 *
 * @param request ModifySQLCollectorPolicyRequest
 * @return ModifySQLCollectorPolicyResponse
 */
func (client *Client) ModifySQLCollectorPolicy(request *ModifySQLCollectorPolicyRequest) (_result *ModifySQLCollectorPolicyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifySQLCollectorPolicyResponse{}
	_body, _err := client.ModifySQLCollectorPolicyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Supported database engines
 * RDS MySQL
 * ### Precautions
 * After you shorten the log backup retention period, log backup files that are stored longer than the specified log backup retention period are immediately deleted.
 * ### References
 * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * [Use the SQL Explorer and Audit feature](~~476574~~)
 *
 * @param request ModifySQLCollectorRetentionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifySQLCollectorRetentionResponse
 */
func (client *Client) ModifySQLCollectorRetentionWithOptions(request *ModifySQLCollectorRetentionRequest, runtime *util.RuntimeOptions) (_result *ModifySQLCollectorRetentionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ConfigValue)) {
		query["ConfigValue"] = request.ConfigValue
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifySQLCollectorRetention"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifySQLCollectorRetentionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Supported database engines
 * RDS MySQL
 * ### Precautions
 * After you shorten the log backup retention period, log backup files that are stored longer than the specified log backup retention period are immediately deleted.
 * ### References
 * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * [Use the SQL Explorer and Audit feature](~~476574~~)
 *
 * @param request ModifySQLCollectorRetentionRequest
 * @return ModifySQLCollectorRetentionResponse
 */
func (client *Client) ModifySQLCollectorRetention(request *ModifySQLCollectorRetentionRequest) (_result *ModifySQLCollectorRetentionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifySQLCollectorRetentionResponse{}
	_body, _err := client.ModifySQLCollectorRetentionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * After an RDS instance is added to an ECS security group, all ECS instances in the security group can access the RDS instance. For more information, see [Configure a whitelist for an RDS instance](~~96118~~).
 *
 * @param request ModifySecurityGroupConfigurationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifySecurityGroupConfigurationResponse
 */
func (client *Client) ModifySecurityGroupConfigurationWithOptions(request *ModifySecurityGroupConfigurationRequest, runtime *util.RuntimeOptions) (_result *ModifySecurityGroupConfigurationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityGroupId)) {
		query["SecurityGroupId"] = request.SecurityGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifySecurityGroupConfiguration"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifySecurityGroupConfigurationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * After an RDS instance is added to an ECS security group, all ECS instances in the security group can access the RDS instance. For more information, see [Configure a whitelist for an RDS instance](~~96118~~).
 *
 * @param request ModifySecurityGroupConfigurationRequest
 * @return ModifySecurityGroupConfigurationResponse
 */
func (client *Client) ModifySecurityGroupConfiguration(request *ModifySecurityGroupConfigurationRequest) (_result *ModifySecurityGroupConfigurationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifySecurityGroupConfigurationResponse{}
	_body, _err := client.ModifySecurityGroupConfigurationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 * ### References
 * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
 * *   [Configure an IP address whitelist for an ApsaraDB RDS for MySQL instance](~~96118~~)
 * *   [Configure an IP address whitelist for an ApsaraDB RDS for PostgreSQL instance](~~43187~~)
 * *   [Configure an IP address whitelist for an ApsaraDB RDS for SQL Server instance](~~43186~~)
 * *   [Configure an IP address whitelist for an ApsaraDB RDS for MariaDB instance](~~90336~~)
 *
 * @param request ModifySecurityIpsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifySecurityIpsResponse
 */
func (client *Client) ModifySecurityIpsWithOptions(request *ModifySecurityIpsRequest, runtime *util.RuntimeOptions) (_result *ModifySecurityIpsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceIPArrayAttribute)) {
		query["DBInstanceIPArrayAttribute"] = request.DBInstanceIPArrayAttribute
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceIPArrayName)) {
		query["DBInstanceIPArrayName"] = request.DBInstanceIPArrayName
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.FreshWhiteListReadins)) {
		query["FreshWhiteListReadins"] = request.FreshWhiteListReadins
	}

	if !tea.BoolValue(util.IsUnset(request.ModifyMode)) {
		query["ModifyMode"] = request.ModifyMode
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityIPType)) {
		query["SecurityIPType"] = request.SecurityIPType
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityIps)) {
		query["SecurityIps"] = request.SecurityIps
	}

	if !tea.BoolValue(util.IsUnset(request.WhitelistNetworkType)) {
		query["WhitelistNetworkType"] = request.WhitelistNetworkType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifySecurityIps"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifySecurityIpsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 * ### References
 * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
 * *   [Configure an IP address whitelist for an ApsaraDB RDS for MySQL instance](~~96118~~)
 * *   [Configure an IP address whitelist for an ApsaraDB RDS for PostgreSQL instance](~~43187~~)
 * *   [Configure an IP address whitelist for an ApsaraDB RDS for SQL Server instance](~~43186~~)
 * *   [Configure an IP address whitelist for an ApsaraDB RDS for MariaDB instance](~~90336~~)
 *
 * @param request ModifySecurityIpsRequest
 * @return ModifySecurityIpsResponse
 */
func (client *Client) ModifySecurityIps(request *ModifySecurityIpsRequest) (_result *ModifySecurityIpsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifySecurityIpsResponse{}
	_body, _err := client.ModifySecurityIpsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Supported database engines
 * *   RDS MySQL
 * *   RDS PostgreSQL
 * *   RDS SQL Server
 *
 * @param request ModifyWhitelistTemplateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyWhitelistTemplateResponse
 */
func (client *Client) ModifyWhitelistTemplateWithOptions(request *ModifyWhitelistTemplateRequest, runtime *util.RuntimeOptions) (_result *ModifyWhitelistTemplateResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IpWhitelist)) {
		query["IpWhitelist"] = request.IpWhitelist
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.TemplateId)) {
		query["TemplateId"] = request.TemplateId
	}

	if !tea.BoolValue(util.IsUnset(request.TemplateName)) {
		query["TemplateName"] = request.TemplateName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyWhitelistTemplate"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyWhitelistTemplateResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Supported database engines
 * *   RDS MySQL
 * *   RDS PostgreSQL
 * *   RDS SQL Server
 *
 * @param request ModifyWhitelistTemplateRequest
 * @return ModifyWhitelistTemplateResponse
 */
func (client *Client) ModifyWhitelistTemplate(request *ModifyWhitelistTemplateRequest) (_result *ModifyWhitelistTemplateResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyWhitelistTemplateResponse{}
	_body, _err := client.ModifyWhitelistTemplateWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) PreCheckCreateOrderForCreateDBNodesWithOptions(tmpReq *PreCheckCreateOrderForCreateDBNodesRequest, runtime *util.RuntimeOptions) (_result *PreCheckCreateOrderForCreateDBNodesResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &PreCheckCreateOrderForCreateDBNodesShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.DBNode)) {
		request.DBNodeShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.DBNode, tea.String("DBNode"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AutoPay)) {
		query["AutoPay"] = request.AutoPay
	}

	if !tea.BoolValue(util.IsUnset(request.BusinessInfo)) {
		query["BusinessInfo"] = request.BusinessInfo
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.CommodityCode)) {
		query["CommodityCode"] = request.CommodityCode
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.DBNodeShrink)) {
		query["DBNode"] = request.DBNodeShrink
	}

	if !tea.BoolValue(util.IsUnset(request.EngineVersion)) {
		query["EngineVersion"] = request.EngineVersion
	}

	if !tea.BoolValue(util.IsUnset(request.NodeType)) {
		query["NodeType"] = request.NodeType
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PromotionCode)) {
		query["PromotionCode"] = request.PromotionCode
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.Resource)) {
		query["Resource"] = request.Resource
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ZoneId)) {
		query["ZoneId"] = request.ZoneId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("PreCheckCreateOrderForCreateDBNodes"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &PreCheckCreateOrderForCreateDBNodesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) PreCheckCreateOrderForCreateDBNodes(request *PreCheckCreateOrderForCreateDBNodesRequest) (_result *PreCheckCreateOrderForCreateDBNodesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &PreCheckCreateOrderForCreateDBNodesResponse{}
	_body, _err := client.PreCheckCreateOrderForCreateDBNodesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) PreCheckCreateOrderForDeleteDBNodesWithOptions(tmpReq *PreCheckCreateOrderForDeleteDBNodesRequest, runtime *util.RuntimeOptions) (_result *PreCheckCreateOrderForDeleteDBNodesResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &PreCheckCreateOrderForDeleteDBNodesShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.DBNodeId)) {
		request.DBNodeIdShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.DBNodeId, tea.String("DBNodeId"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AutoPay)) {
		query["AutoPay"] = request.AutoPay
	}

	if !tea.BoolValue(util.IsUnset(request.BusinessInfo)) {
		query["BusinessInfo"] = request.BusinessInfo
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.CommodityCode)) {
		query["CommodityCode"] = request.CommodityCode
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.DBNodeIdShrink)) {
		query["DBNodeId"] = request.DBNodeIdShrink
	}

	if !tea.BoolValue(util.IsUnset(request.EngineVersion)) {
		query["EngineVersion"] = request.EngineVersion
	}

	if !tea.BoolValue(util.IsUnset(request.NodeType)) {
		query["NodeType"] = request.NodeType
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PromotionCode)) {
		query["PromotionCode"] = request.PromotionCode
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.Resource)) {
		query["Resource"] = request.Resource
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ZoneId)) {
		query["ZoneId"] = request.ZoneId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("PreCheckCreateOrderForDeleteDBNodes"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &PreCheckCreateOrderForDeleteDBNodesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) PreCheckCreateOrderForDeleteDBNodes(request *PreCheckCreateOrderForDeleteDBNodesRequest) (_result *PreCheckCreateOrderForDeleteDBNodesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &PreCheckCreateOrderForDeleteDBNodesResponse{}
	_body, _err := client.PreCheckCreateOrderForDeleteDBNodesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   SQL Server
 * ### Description
 * The system automatically uploads log backup files to Object Storage Service (OSS) buckets. If the remaining storage of an instance is insufficient, you can call this operation to upload the log backup files of the instance to OSS buckets. After the upload is complete, the system deletes these files from the instance to release storage. This operation is called to upload log backup files from an instance to OSS buckets and then delete these files from the instance. If the instance runs SQL Server, transaction log backup files are compressed before they are uploaded.
 * ### Precautions
 * *   When you upload log backup files, the data restoration feature is not affected.
 * *   This operation is called to release storage. The backup storage usage is not reduced.
 * *   The OSS buckets to which log backup files are uploaded are provided by the system. You do not need to purchase these OSS buckets. In addition, you cannot access these OSS buckets.
 *
 * @param request PurgeDBInstanceLogRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return PurgeDBInstanceLogResponse
 */
func (client *Client) PurgeDBInstanceLogWithOptions(request *PurgeDBInstanceLogRequest, runtime *util.RuntimeOptions) (_result *PurgeDBInstanceLogResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("PurgeDBInstanceLog"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &PurgeDBInstanceLogResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   SQL Server
 * ### Description
 * The system automatically uploads log backup files to Object Storage Service (OSS) buckets. If the remaining storage of an instance is insufficient, you can call this operation to upload the log backup files of the instance to OSS buckets. After the upload is complete, the system deletes these files from the instance to release storage. This operation is called to upload log backup files from an instance to OSS buckets and then delete these files from the instance. If the instance runs SQL Server, transaction log backup files are compressed before they are uploaded.
 * ### Precautions
 * *   When you upload log backup files, the data restoration feature is not affected.
 * *   This operation is called to release storage. The backup storage usage is not reduced.
 * *   The OSS buckets to which log backup files are uploaded are provided by the system. You do not need to purchase these OSS buckets. In addition, you cannot access these OSS buckets.
 *
 * @param request PurgeDBInstanceLogRequest
 * @return PurgeDBInstanceLogResponse
 */
func (client *Client) PurgeDBInstanceLog(request *PurgeDBInstanceLogRequest) (_result *PurgeDBInstanceLogResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &PurgeDBInstanceLogResponse{}
	_body, _err := client.PurgeDBInstanceLogWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 * ### Feature description
 * The notifications are highlighted at the top of the ApsaraDB RDS console. The notifications include renewal reminders and reminders of instance creation failures.
 * After you call this operation to query notifications, you can call the [ConfirmNotify](~~610444~~) operation to mark the notifications as confirmed, which means that you understand the content of the notifications.
 *
 * @param request QueryNotifyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryNotifyResponse
 */
func (client *Client) QueryNotifyWithOptions(request *QueryNotifyRequest, runtime *util.RuntimeOptions) (_result *QueryNotifyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.From)) {
		body["From"] = request.From
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		body["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		body["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.To)) {
		body["To"] = request.To
	}

	if !tea.BoolValue(util.IsUnset(request.WithConfirmed)) {
		body["WithConfirmed"] = request.WithConfirmed
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryNotify"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryNotifyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 * ### Feature description
 * The notifications are highlighted at the top of the ApsaraDB RDS console. The notifications include renewal reminders and reminders of instance creation failures.
 * After you call this operation to query notifications, you can call the [ConfirmNotify](~~610444~~) operation to mark the notifications as confirmed, which means that you understand the content of the notifications.
 *
 * @param request QueryNotifyRequest
 * @return QueryNotifyResponse
 */
func (client *Client) QueryNotify(request *QueryNotifyRequest) (_result *QueryNotifyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryNotifyResponse{}
	_body, _err := client.QueryNotifyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QueryRecommendByCodeWithOptions(request *QueryRecommendByCodeRequest, runtime *util.RuntimeOptions) (_result *QueryRecommendByCodeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Code)) {
		query["Code"] = request.Code
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryRecommendByCode"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryRecommendByCodeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QueryRecommendByCode(request *QueryRecommendByCodeRequest) (_result *QueryRecommendByCodeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryRecommendByCodeResponse{}
	_body, _err := client.QueryRecommendByCodeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Dedicated clusters allow you to manage a number of instances at a time. You can create multiple dedicated clusters in a single region. Each dedicated cluster consists of multiple hosts. You can create multiple instances on each host. For more information, see [What is ApsaraDB MyBase?](~~141455~~)
 *
 * @param request RebuildDBInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RebuildDBInstanceResponse
 */
func (client *Client) RebuildDBInstanceWithOptions(request *RebuildDBInstanceRequest, runtime *util.RuntimeOptions) (_result *RebuildDBInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.DedicatedHostGroupId)) {
		query["DedicatedHostGroupId"] = request.DedicatedHostGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.DedicatedHostId)) {
		query["DedicatedHostId"] = request.DedicatedHostId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RebuildNodeType)) {
		query["RebuildNodeType"] = request.RebuildNodeType
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RebuildDBInstance"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RebuildDBInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Dedicated clusters allow you to manage a number of instances at a time. You can create multiple dedicated clusters in a single region. Each dedicated cluster consists of multiple hosts. You can create multiple instances on each host. For more information, see [What is ApsaraDB MyBase?](~~141455~~)
 *
 * @param request RebuildDBInstanceRequest
 * @return RebuildDBInstanceResponse
 */
func (client *Client) RebuildDBInstance(request *RebuildDBInstanceRequest) (_result *RebuildDBInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RebuildDBInstanceResponse{}
	_body, _err := client.RebuildDBInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The operation is phased out.
 *
 * @param request ReceiveDBInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ReceiveDBInstanceResponse
 */
func (client *Client) ReceiveDBInstanceWithOptions(request *ReceiveDBInstanceRequest, runtime *util.RuntimeOptions) (_result *ReceiveDBInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.GuardDBInstanceId)) {
		query["GuardDBInstanceId"] = request.GuardDBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ReceiveDBInstance"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ReceiveDBInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The operation is phased out.
 *
 * @param request ReceiveDBInstanceRequest
 * @return ReceiveDBInstanceResponse
 */
func (client *Client) ReceiveDBInstance(request *ReceiveDBInstanceRequest) (_result *ReceiveDBInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ReceiveDBInstanceResponse{}
	_body, _err := client.ReceiveDBInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call this operation to restore databases to a new instance or an existing instance. If you want to restore databases to an existing instance, we recommend that you call the [Copy databases](~~88810~~) operation.
 * If you want to restore databases to a new instance, you must create an instance and then restore specific or all databases to the new instance.
 * *   If you specify the name of a database, only the specified database is restored to the new instance.
 * *   If you do not specify the name of a database, all databases are restored to the new instance.
 * > This operation is supported only for instances that run SQL Server 2012 or later.
 *
 * @param request RecoveryDBInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RecoveryDBInstanceResponse
 */
func (client *Client) RecoveryDBInstanceWithOptions(request *RecoveryDBInstanceRequest, runtime *util.RuntimeOptions) (_result *RecoveryDBInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BackupId)) {
		query["BackupId"] = request.BackupId
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceClass)) {
		query["DBInstanceClass"] = request.DBInstanceClass
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceStorage)) {
		query["DBInstanceStorage"] = request.DBInstanceStorage
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceStorageType)) {
		query["DBInstanceStorageType"] = request.DBInstanceStorageType
	}

	if !tea.BoolValue(util.IsUnset(request.DbNames)) {
		query["DbNames"] = request.DbNames
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceNetworkType)) {
		query["InstanceNetworkType"] = request.InstanceNetworkType
	}

	if !tea.BoolValue(util.IsUnset(request.PayType)) {
		query["PayType"] = request.PayType
	}

	if !tea.BoolValue(util.IsUnset(request.Period)) {
		query["Period"] = request.Period
	}

	if !tea.BoolValue(util.IsUnset(request.PrivateIpAddress)) {
		query["PrivateIpAddress"] = request.PrivateIpAddress
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RestoreTime)) {
		query["RestoreTime"] = request.RestoreTime
	}

	if !tea.BoolValue(util.IsUnset(request.TargetDBInstanceId)) {
		query["TargetDBInstanceId"] = request.TargetDBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.UsedTime)) {
		query["UsedTime"] = request.UsedTime
	}

	if !tea.BoolValue(util.IsUnset(request.VPCId)) {
		query["VPCId"] = request.VPCId
	}

	if !tea.BoolValue(util.IsUnset(request.VSwitchId)) {
		query["VSwitchId"] = request.VSwitchId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RecoveryDBInstance"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RecoveryDBInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call this operation to restore databases to a new instance or an existing instance. If you want to restore databases to an existing instance, we recommend that you call the [Copy databases](~~88810~~) operation.
 * If you want to restore databases to a new instance, you must create an instance and then restore specific or all databases to the new instance.
 * *   If you specify the name of a database, only the specified database is restored to the new instance.
 * *   If you do not specify the name of a database, all databases are restored to the new instance.
 * > This operation is supported only for instances that run SQL Server 2012 or later.
 *
 * @param request RecoveryDBInstanceRequest
 * @return RecoveryDBInstanceResponse
 */
func (client *Client) RecoveryDBInstance(request *RecoveryDBInstanceRequest) (_result *RecoveryDBInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RecoveryDBInstanceResponse{}
	_body, _err := client.RecoveryDBInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 * ### References
 * *   [Release the public endpoint of an ApsaraDB RDS for MySQL instance](~~26128~~)
 * *   [Release the public endpoint of an ApsaraDB RDS for PostgreSQL instance](~~97738~~)
 * *   [Release the public endpoint of an ApsaraDB RDS for SQL Server instance](~~97736~~)
 * *   [Release the public endpoint of an ApsaraDB RDS for MariaDB instance](~~97740~~)
 *
 * @param request ReleaseInstanceConnectionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ReleaseInstanceConnectionResponse
 */
func (client *Client) ReleaseInstanceConnectionWithOptions(request *ReleaseInstanceConnectionRequest, runtime *util.RuntimeOptions) (_result *ReleaseInstanceConnectionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CurrentConnectionString)) {
		query["CurrentConnectionString"] = request.CurrentConnectionString
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceNetworkType)) {
		query["InstanceNetworkType"] = request.InstanceNetworkType
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ReleaseInstanceConnection"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ReleaseInstanceConnectionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 * ### References
 * *   [Release the public endpoint of an ApsaraDB RDS for MySQL instance](~~26128~~)
 * *   [Release the public endpoint of an ApsaraDB RDS for PostgreSQL instance](~~97738~~)
 * *   [Release the public endpoint of an ApsaraDB RDS for SQL Server instance](~~97736~~)
 * *   [Release the public endpoint of an ApsaraDB RDS for MariaDB instance](~~97740~~)
 *
 * @param request ReleaseInstanceConnectionRequest
 * @return ReleaseInstanceConnectionResponse
 */
func (client *Client) ReleaseInstanceConnection(request *ReleaseInstanceConnectionRequest) (_result *ReleaseInstanceConnectionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ReleaseInstanceConnectionResponse{}
	_body, _err := client.ReleaseInstanceConnectionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * To ensure data security, you can release the public endpoint when you do not need to access the database from the Internet.
 *
 * @param request ReleaseInstancePublicConnectionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ReleaseInstancePublicConnectionResponse
 */
func (client *Client) ReleaseInstancePublicConnectionWithOptions(request *ReleaseInstancePublicConnectionRequest, runtime *util.RuntimeOptions) (_result *ReleaseInstancePublicConnectionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CurrentConnectionString)) {
		query["CurrentConnectionString"] = request.CurrentConnectionString
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ReleaseInstancePublicConnection"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ReleaseInstancePublicConnectionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * To ensure data security, you can release the public endpoint when you do not need to access the database from the Internet.
 *
 * @param request ReleaseInstancePublicConnectionRequest
 * @return ReleaseInstancePublicConnectionResponse
 */
func (client *Client) ReleaseInstancePublicConnection(request *ReleaseInstancePublicConnectionRequest) (_result *ReleaseInstancePublicConnectionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ReleaseInstancePublicConnectionResponse{}
	_body, _err := client.ReleaseInstancePublicConnectionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   SQL Server
 * ### Prerequisites
 * Before you call this operation, make sure that the following requirements are met:
 * *   The shared proxy feature is enabled for your ApsaraDB RDS for MySQL instance.
 * *   The read/write splitting feature is enabled for the instance.
 * *   The instance must run one of the following database engine versions and RDS editions:
 *     *   MySQL 5.7 on RDS High-availability Edition (with local disks)
 *     *   MySQL 5.6
 *     *   SQL Server on RDS Cluster Edition
 *
 * @param request ReleaseReadWriteSplittingConnectionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ReleaseReadWriteSplittingConnectionResponse
 */
func (client *Client) ReleaseReadWriteSplittingConnectionWithOptions(request *ReleaseReadWriteSplittingConnectionRequest, runtime *util.RuntimeOptions) (_result *ReleaseReadWriteSplittingConnectionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ReleaseReadWriteSplittingConnection"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ReleaseReadWriteSplittingConnectionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   SQL Server
 * ### Prerequisites
 * Before you call this operation, make sure that the following requirements are met:
 * *   The shared proxy feature is enabled for your ApsaraDB RDS for MySQL instance.
 * *   The read/write splitting feature is enabled for the instance.
 * *   The instance must run one of the following database engine versions and RDS editions:
 *     *   MySQL 5.7 on RDS High-availability Edition (with local disks)
 *     *   MySQL 5.6
 *     *   SQL Server on RDS Cluster Edition
 *
 * @param request ReleaseReadWriteSplittingConnectionRequest
 * @return ReleaseReadWriteSplittingConnectionResponse
 */
func (client *Client) ReleaseReadWriteSplittingConnection(request *ReleaseReadWriteSplittingConnectionRequest) (_result *ReleaseReadWriteSplittingConnectionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ReleaseReadWriteSplittingConnectionResponse{}
	_body, _err := client.ReleaseReadWriteSplittingConnectionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 * ### [](#)Usage notes
 * *   A maximum of 10 tags can be removed in a single request.
 * *   If a tag is removed from all instances to which the tag is added, the tag is automatically deleted.
 * *   If you specify only TagKey, all tags that match the TagKey condition are removed.
 * *   You must specify at least TagKey or a pair of TagKey and TagValue.
 *
 * @param request RemoveTagsFromResourceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RemoveTagsFromResourceResponse
 */
func (client *Client) RemoveTagsFromResourceWithOptions(request *RemoveTagsFromResourceRequest, runtime *util.RuntimeOptions) (_result *RemoveTagsFromResourceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	if !tea.BoolValue(util.IsUnset(request.ProxyId)) {
		query["proxyId"] = request.ProxyId
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RemoveTagsFromResource"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RemoveTagsFromResourceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 * ### [](#)Usage notes
 * *   A maximum of 10 tags can be removed in a single request.
 * *   If a tag is removed from all instances to which the tag is added, the tag is automatically deleted.
 * *   If you specify only TagKey, all tags that match the TagKey condition are removed.
 * *   You must specify at least TagKey or a pair of TagKey and TagValue.
 *
 * @param request RemoveTagsFromResourceRequest
 * @return RemoveTagsFromResourceResponse
 */
func (client *Client) RemoveTagsFromResource(request *RemoveTagsFromResourceRequest) (_result *RemoveTagsFromResourceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RemoveTagsFromResourceResponse{}
	_body, _err := client.RemoveTagsFromResourceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Before you call this operation, make sure that you understand the billing methods and pricing of ApsaraDB RDS. For more information, see [Billable items, billing methods, and pricing](~~45020~~).
 * Before you call this operation, make sure that the following requirements are met:
 * *   The instance is a subscription instance.
 * *   Your account supports credit card payments or balance payments.
 *     **
 *     **Note**By default, coupons available for your account are preferentially used for payment.
 *
 * @param request RenewInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RenewInstanceResponse
 */
func (client *Client) RenewInstanceWithOptions(request *RenewInstanceRequest, runtime *util.RuntimeOptions) (_result *RenewInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AutoPay)) {
		query["AutoPay"] = request.AutoPay
	}

	if !tea.BoolValue(util.IsUnset(request.AutoRenew)) {
		query["AutoRenew"] = request.AutoRenew
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Period)) {
		query["Period"] = request.Period
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RenewInstance"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RenewInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Before you call this operation, make sure that you understand the billing methods and pricing of ApsaraDB RDS. For more information, see [Billable items, billing methods, and pricing](~~45020~~).
 * Before you call this operation, make sure that the following requirements are met:
 * *   The instance is a subscription instance.
 * *   Your account supports credit card payments or balance payments.
 *     **
 *     **Note**By default, coupons available for your account are preferentially used for payment.
 *
 * @param request RenewInstanceRequest
 * @return RenewInstanceResponse
 */
func (client *Client) RenewInstance(request *RenewInstanceRequest) (_result *RenewInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RenewInstanceResponse{}
	_body, _err := client.RenewInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   SQL Server
 * *   MariaDB
 * ### References
 * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
 * [Reset of the permissions of privileged accounts](~~140724~~)
 *
 * @param request ResetAccountRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ResetAccountResponse
 */
func (client *Client) ResetAccountWithOptions(request *ResetAccountRequest, runtime *util.RuntimeOptions) (_result *ResetAccountResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AccountName)) {
		query["AccountName"] = request.AccountName
	}

	if !tea.BoolValue(util.IsUnset(request.AccountPassword)) {
		query["AccountPassword"] = request.AccountPassword
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ResetAccount"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ResetAccountResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   SQL Server
 * *   MariaDB
 * ### References
 * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
 * [Reset of the permissions of privileged accounts](~~140724~~)
 *
 * @param request ResetAccountRequest
 * @return ResetAccountResponse
 */
func (client *Client) ResetAccount(request *ResetAccountRequest) (_result *ResetAccountResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ResetAccountResponse{}
	_body, _err := client.ResetAccountWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 * ### References
 * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
 * *   [Reset the password of an ApsaraDB RDS for MySQL instance](~~96100~~)
 * *   [Reset the password of an ApsaraDB RDS for PostgreSQL instance](~~96814~~)
 * *   [Reset the password of an ApsaraDB RDS for SQL Server instance](~~95691~~)
 * *   [Reset the password of an ApsaraDB RDS for MariaDB instance](~~97133~~)
 *
 * @param request ResetAccountPasswordRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ResetAccountPasswordResponse
 */
func (client *Client) ResetAccountPasswordWithOptions(request *ResetAccountPasswordRequest, runtime *util.RuntimeOptions) (_result *ResetAccountPasswordResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AccountName)) {
		query["AccountName"] = request.AccountName
	}

	if !tea.BoolValue(util.IsUnset(request.AccountPassword)) {
		query["AccountPassword"] = request.AccountPassword
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ResetAccountPassword"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ResetAccountPasswordResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 * ### References
 * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
 * *   [Reset the password of an ApsaraDB RDS for MySQL instance](~~96100~~)
 * *   [Reset the password of an ApsaraDB RDS for PostgreSQL instance](~~96814~~)
 * *   [Reset the password of an ApsaraDB RDS for SQL Server instance](~~95691~~)
 * *   [Reset the password of an ApsaraDB RDS for MariaDB instance](~~97133~~)
 *
 * @param request ResetAccountPasswordRequest
 * @return ResetAccountPasswordResponse
 */
func (client *Client) ResetAccountPassword(request *ResetAccountPasswordRequest) (_result *ResetAccountPasswordResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ResetAccountPasswordResponse{}
	_body, _err := client.ResetAccountPasswordWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Supported database engines
 * *   RDS MySQL
 * *   RDS PostgreSQL
 * *   RDS SQL Server
 * *   RDS MariaDB
 * ### References
 * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * *   [Restart an ApsaraDB RDS for MySQL instance](~~96051~~)
 * *   [Restart an ApsaraDB RDS for PostgreSQL instance](~~96798~~)
 * *   [Restart an ApsaraDB RDS for SQL Server instance](~~95656~~)
 * *   [Restart an ApsaraDB RDS for MariaDB instance](~~97472~~)
 *
 * @param request RestartDBInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RestartDBInstanceResponse
 */
func (client *Client) RestartDBInstanceWithOptions(request *RestartDBInstanceRequest, runtime *util.RuntimeOptions) (_result *RestartDBInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.NodeId)) {
		query["NodeId"] = request.NodeId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RestartDBInstance"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RestartDBInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Supported database engines
 * *   RDS MySQL
 * *   RDS PostgreSQL
 * *   RDS SQL Server
 * *   RDS MariaDB
 * ### References
 * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * *   [Restart an ApsaraDB RDS for MySQL instance](~~96051~~)
 * *   [Restart an ApsaraDB RDS for PostgreSQL instance](~~96798~~)
 * *   [Restart an ApsaraDB RDS for SQL Server instance](~~95656~~)
 * *   [Restart an ApsaraDB RDS for MariaDB instance](~~97472~~)
 *
 * @param request RestartDBInstanceRequest
 * @return RestartDBInstanceResponse
 */
func (client *Client) RestartDBInstance(request *RestartDBInstanceRequest) (_result *RestartDBInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RestartDBInstanceResponse{}
	_body, _err := client.RestartDBInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) RestoreDdrTableWithOptions(request *RestoreDdrTableRequest, runtime *util.RuntimeOptions) (_result *RestoreDdrTableResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BackupId)) {
		query["BackupId"] = request.BackupId
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RestoreTime)) {
		query["RestoreTime"] = request.RestoreTime
	}

	if !tea.BoolValue(util.IsUnset(request.RestoreType)) {
		query["RestoreType"] = request.RestoreType
	}

	if !tea.BoolValue(util.IsUnset(request.SourceDBInstanceName)) {
		query["SourceDBInstanceName"] = request.SourceDBInstanceName
	}

	if !tea.BoolValue(util.IsUnset(request.SourceRegion)) {
		query["SourceRegion"] = request.SourceRegion
	}

	if !tea.BoolValue(util.IsUnset(request.TableMeta)) {
		query["TableMeta"] = request.TableMeta
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RestoreDdrTable"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RestoreDdrTableResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) RestoreDdrTable(request *RestoreDdrTableRequest) (_result *RestoreDdrTableResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RestoreDdrTableResponse{}
	_body, _err := client.RestoreDdrTableWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * MySQL
 * ### [](#)Description
 * ApsaraDB RDS for MySQL supports the restoration of individual databases and tables. If you delete databases or tables from an instance, you can restore the databases or tables by using a backup file. For more information, see [Restore individual databases and tables of an ApsaraDB RDS for MySQL instance](~~103175~~). Before you call this operation, make sure that the following requirements are met:
 * *   The instance is in the Running state.
 * *   The instance does not have ongoing migration tasks.
 * *   If you want to restore data to a specific point in time, make sure that the log backup feature is enabled for the instance. For more information, see [Back up an ApsaraDB RDS for MySQL instance](~~98818~~).
 * *   The restoration of individual databases or tables is enabled, and new backups are created. For more information, see [Restore individual databases and tables of an ApsaraDB RDS for MySQL instance](~~103175~~).
 * *   The names that you want to use for the restored tables do not exist in the instance.
 *
 * @param request RestoreTableRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RestoreTableResponse
 */
func (client *Client) RestoreTableWithOptions(request *RestoreTableRequest, runtime *util.RuntimeOptions) (_result *RestoreTableResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BackupId)) {
		query["BackupId"] = request.BackupId
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.InstantRecovery)) {
		query["InstantRecovery"] = request.InstantRecovery
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RestoreTime)) {
		query["RestoreTime"] = request.RestoreTime
	}

	if !tea.BoolValue(util.IsUnset(request.TableMeta)) {
		query["TableMeta"] = request.TableMeta
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RestoreTable"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RestoreTableResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * MySQL
 * ### [](#)Description
 * ApsaraDB RDS for MySQL supports the restoration of individual databases and tables. If you delete databases or tables from an instance, you can restore the databases or tables by using a backup file. For more information, see [Restore individual databases and tables of an ApsaraDB RDS for MySQL instance](~~103175~~). Before you call this operation, make sure that the following requirements are met:
 * *   The instance is in the Running state.
 * *   The instance does not have ongoing migration tasks.
 * *   If you want to restore data to a specific point in time, make sure that the log backup feature is enabled for the instance. For more information, see [Back up an ApsaraDB RDS for MySQL instance](~~98818~~).
 * *   The restoration of individual databases or tables is enabled, and new backups are created. For more information, see [Restore individual databases and tables of an ApsaraDB RDS for MySQL instance](~~103175~~).
 * *   The names that you want to use for the restored tables do not exist in the instance.
 *
 * @param request RestoreTableRequest
 * @return RestoreTableResponse
 */
func (client *Client) RestoreTable(request *RestoreTableRequest) (_result *RestoreTableResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RestoreTableResponse{}
	_body, _err := client.RestoreTableWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   SQL Server
 * *   MariaDB
 * ### [](#)Prerequisites
 * *   The instance is in the Running state.
 * *   The database is in the Running state.
 * ### [](#)Precautions
 * *   The permissions that can be revoked include SELECT, INSERT, UPDATE, DELETE, CREATE, DROP, REFERENCES, INDEX, ALTER, CREATE TEMPORARY TABLES, LOCK TABLES, EXECUTE, CREATE VIEW, SHOW VIEW, CREATE ROUTINE, ALTER ROUTINE, EVENT, and TRIGGER.
 * *   This operation is not supported for instances that run SQL Server 2017 on RDS Cluster Edition and run PostgreSQL.
 *
 * @param request RevokeAccountPrivilegeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RevokeAccountPrivilegeResponse
 */
func (client *Client) RevokeAccountPrivilegeWithOptions(request *RevokeAccountPrivilegeRequest, runtime *util.RuntimeOptions) (_result *RevokeAccountPrivilegeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AccountName)) {
		query["AccountName"] = request.AccountName
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.DBName)) {
		query["DBName"] = request.DBName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RevokeAccountPrivilege"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RevokeAccountPrivilegeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   SQL Server
 * *   MariaDB
 * ### [](#)Prerequisites
 * *   The instance is in the Running state.
 * *   The database is in the Running state.
 * ### [](#)Precautions
 * *   The permissions that can be revoked include SELECT, INSERT, UPDATE, DELETE, CREATE, DROP, REFERENCES, INDEX, ALTER, CREATE TEMPORARY TABLES, LOCK TABLES, EXECUTE, CREATE VIEW, SHOW VIEW, CREATE ROUTINE, ALTER ROUTINE, EVENT, and TRIGGER.
 * *   This operation is not supported for instances that run SQL Server 2017 on RDS Cluster Edition and run PostgreSQL.
 *
 * @param request RevokeAccountPrivilegeRequest
 * @return RevokeAccountPrivilegeResponse
 */
func (client *Client) RevokeAccountPrivilege(request *RevokeAccountPrivilegeRequest) (_result *RevokeAccountPrivilegeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RevokeAccountPrivilegeResponse{}
	_body, _err := client.RevokeAccountPrivilegeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * ### References
 * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
 * *   [Grant permissions to the service account of an ApsaraDB RDS for MySQL instance](~~96102~~)
 * *   [Grant permissions to the service account of an ApsaraDB RDS for PostgreSQL instance](~~146887~~)
 * *   [Grant permissions to the service account of an ApsaraDB RDS for SQL Server instance](~~95693~~)
 *
 * @param request RevokeOperatorPermissionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RevokeOperatorPermissionResponse
 */
func (client *Client) RevokeOperatorPermissionWithOptions(request *RevokeOperatorPermissionRequest, runtime *util.RuntimeOptions) (_result *RevokeOperatorPermissionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RevokeOperatorPermission"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RevokeOperatorPermissionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * ### References
 * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
 * *   [Grant permissions to the service account of an ApsaraDB RDS for MySQL instance](~~96102~~)
 * *   [Grant permissions to the service account of an ApsaraDB RDS for PostgreSQL instance](~~146887~~)
 * *   [Grant permissions to the service account of an ApsaraDB RDS for SQL Server instance](~~95693~~)
 *
 * @param request RevokeOperatorPermissionRequest
 * @return RevokeOperatorPermissionResponse
 */
func (client *Client) RevokeOperatorPermission(request *RevokeOperatorPermissionRequest) (_result *RevokeOperatorPermissionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RevokeOperatorPermissionResponse{}
	_body, _err := client.RevokeOperatorPermissionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * ### References
 * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation:
 * *   [Resume an ApsaraDB RDS for MySQL instance](~~427093~~)
 * *   [Resume an ApsaraDB RDS for PostgreSQL instance](~~452314~~)
 * *   [Resume an ApsaraDB RDS for SQL Server instance](~~462504~~)
 *
 * @param request StartDBInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return StartDBInstanceResponse
 */
func (client *Client) StartDBInstanceWithOptions(request *StartDBInstanceRequest, runtime *util.RuntimeOptions) (_result *StartDBInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceTransType)) {
		query["DBInstanceTransType"] = request.DBInstanceTransType
	}

	if !tea.BoolValue(util.IsUnset(request.DedicatedHostGroupId)) {
		query["DedicatedHostGroupId"] = request.DedicatedHostGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.EffectiveTime)) {
		query["EffectiveTime"] = request.EffectiveTime
	}

	if !tea.BoolValue(util.IsUnset(request.EngineVersion)) {
		query["EngineVersion"] = request.EngineVersion
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SpecifiedTime)) {
		query["SpecifiedTime"] = request.SpecifiedTime
	}

	if !tea.BoolValue(util.IsUnset(request.Storage)) {
		query["Storage"] = request.Storage
	}

	if !tea.BoolValue(util.IsUnset(request.TargetDBInstanceClass)) {
		query["TargetDBInstanceClass"] = request.TargetDBInstanceClass
	}

	if !tea.BoolValue(util.IsUnset(request.TargetDedicatedHostIdForLog)) {
		query["TargetDedicatedHostIdForLog"] = request.TargetDedicatedHostIdForLog
	}

	if !tea.BoolValue(util.IsUnset(request.TargetDedicatedHostIdForMaster)) {
		query["TargetDedicatedHostIdForMaster"] = request.TargetDedicatedHostIdForMaster
	}

	if !tea.BoolValue(util.IsUnset(request.TargetDedicatedHostIdForSlave)) {
		query["TargetDedicatedHostIdForSlave"] = request.TargetDedicatedHostIdForSlave
	}

	if !tea.BoolValue(util.IsUnset(request.VSwitchId)) {
		query["VSwitchId"] = request.VSwitchId
	}

	if !tea.BoolValue(util.IsUnset(request.ZoneId)) {
		query["ZoneId"] = request.ZoneId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("StartDBInstance"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &StartDBInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * ### References
 * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation:
 * *   [Resume an ApsaraDB RDS for MySQL instance](~~427093~~)
 * *   [Resume an ApsaraDB RDS for PostgreSQL instance](~~452314~~)
 * *   [Resume an ApsaraDB RDS for SQL Server instance](~~462504~~)
 *
 * @param request StartDBInstanceRequest
 * @return StartDBInstanceResponse
 */
func (client *Client) StartDBInstance(request *StartDBInstanceRequest) (_result *StartDBInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &StartDBInstanceResponse{}
	_body, _err := client.StartDBInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * ### References
 * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
 * *   [Suspend an ApsaraDB RDS for MySQL instance](~~427093~~)
 * *   [Suspend an ApsaraDB RDS for PostgreSQL instance](~~452314~~)
 * *   [Suspend an ApsaraDB RDS for SQL Server instance](~~462504~~)
 *
 * @param request StopDBInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return StopDBInstanceResponse
 */
func (client *Client) StopDBInstanceWithOptions(request *StopDBInstanceRequest, runtime *util.RuntimeOptions) (_result *StopDBInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("StopDBInstance"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &StopDBInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * ### References
 * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
 * *   [Suspend an ApsaraDB RDS for MySQL instance](~~427093~~)
 * *   [Suspend an ApsaraDB RDS for PostgreSQL instance](~~452314~~)
 * *   [Suspend an ApsaraDB RDS for SQL Server instance](~~462504~~)
 *
 * @param request StopDBInstanceRequest
 * @return StopDBInstanceResponse
 */
func (client *Client) StopDBInstance(request *StopDBInstanceRequest) (_result *StopDBInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &StopDBInstanceResponse{}
	_body, _err := client.StopDBInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 * ### References
 * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
 * *   [Switch workloads between primary and secondary ApsaraDB RDS for MySQL instances](~~96054~~)
 * *   [Switch workloads between primary and secondary ApsaraDB RDS for PostgreSQL instances](~~96747~~)
 * *   [Switch workloads between primary and secondary ApsaraDB RDS for SQL Server instances](~~95659~~)
 * *   [Switch workloads between primary and secondary ApsaraDB RDS for MariaDB instances](~~97127~~)
 *
 * @param request SwitchDBInstanceHARequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SwitchDBInstanceHAResponse
 */
func (client *Client) SwitchDBInstanceHAWithOptions(request *SwitchDBInstanceHARequest, runtime *util.RuntimeOptions) (_result *SwitchDBInstanceHAResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.EffectiveTime)) {
		query["EffectiveTime"] = request.EffectiveTime
	}

	if !tea.BoolValue(util.IsUnset(request.Force)) {
		query["Force"] = request.Force
	}

	if !tea.BoolValue(util.IsUnset(request.NodeId)) {
		query["NodeId"] = request.NodeId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SwitchDBInstanceHA"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SwitchDBInstanceHAResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 * ### References
 * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
 * *   [Switch workloads between primary and secondary ApsaraDB RDS for MySQL instances](~~96054~~)
 * *   [Switch workloads between primary and secondary ApsaraDB RDS for PostgreSQL instances](~~96747~~)
 * *   [Switch workloads between primary and secondary ApsaraDB RDS for SQL Server instances](~~95659~~)
 * *   [Switch workloads between primary and secondary ApsaraDB RDS for MariaDB instances](~~97127~~)
 *
 * @param request SwitchDBInstanceHARequest
 * @return SwitchDBInstanceHAResponse
 */
func (client *Client) SwitchDBInstanceHA(request *SwitchDBInstanceHARequest) (_result *SwitchDBInstanceHAResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SwitchDBInstanceHAResponse{}
	_body, _err := client.SwitchDBInstanceHAWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   SQL Server
 * ### Prerequisites
 * *   The instance is connected by using its internal or public endpoint.
 * *   The instance is in the Running state.
 * *   The number of times that you have switched the instance between its internal and public endpoints within the last 24 hours does not reach 20.
 * *   The instance resides in the classic network.
 * ### Usage notes
 * After the endpoint that is used to connect to the instance is changed, you must update the endpoint information in the code of your application and restart the application.
 *
 * @param request SwitchDBInstanceNetTypeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SwitchDBInstanceNetTypeResponse
 */
func (client *Client) SwitchDBInstanceNetTypeWithOptions(request *SwitchDBInstanceNetTypeRequest, runtime *util.RuntimeOptions) (_result *SwitchDBInstanceNetTypeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.ConnectionStringPrefix)) {
		query["ConnectionStringPrefix"] = request.ConnectionStringPrefix
	}

	if !tea.BoolValue(util.IsUnset(request.ConnectionStringType)) {
		query["ConnectionStringType"] = request.ConnectionStringType
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Port)) {
		query["Port"] = request.Port
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SwitchDBInstanceNetType"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SwitchDBInstanceNetTypeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   SQL Server
 * ### Prerequisites
 * *   The instance is connected by using its internal or public endpoint.
 * *   The instance is in the Running state.
 * *   The number of times that you have switched the instance between its internal and public endpoints within the last 24 hours does not reach 20.
 * *   The instance resides in the classic network.
 * ### Usage notes
 * After the endpoint that is used to connect to the instance is changed, you must update the endpoint information in the code of your application and restart the application.
 *
 * @param request SwitchDBInstanceNetTypeRequest
 * @return SwitchDBInstanceNetTypeResponse
 */
func (client *Client) SwitchDBInstanceNetType(request *SwitchDBInstanceNetTypeRequest) (_result *SwitchDBInstanceNetTypeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SwitchDBInstanceNetTypeResponse{}
	_body, _err := client.SwitchDBInstanceNetTypeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * ### References
 * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
 * *   [Change the VPC and vSwitch for an ApsaraDB RDS for MySQL instance](~~137567~~)
 * *   [Change the vSwitch for an ApsaraDB RDS for PostgreSQL instance](~~146885~~)
 * *   [Change the VPC and vSwitch for an ApsaraDB RDS for SQL Server instance](~~347675~~)
 *
 * @param request SwitchDBInstanceVpcRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SwitchDBInstanceVpcResponse
 */
func (client *Client) SwitchDBInstanceVpcWithOptions(request *SwitchDBInstanceVpcRequest, runtime *util.RuntimeOptions) (_result *SwitchDBInstanceVpcResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.PrivateIpAddress)) {
		query["PrivateIpAddress"] = request.PrivateIpAddress
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.VPCId)) {
		query["VPCId"] = request.VPCId
	}

	if !tea.BoolValue(util.IsUnset(request.VSwitchId)) {
		query["VSwitchId"] = request.VSwitchId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SwitchDBInstanceVpc"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SwitchDBInstanceVpcResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * ### References
 * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
 * *   [Change the VPC and vSwitch for an ApsaraDB RDS for MySQL instance](~~137567~~)
 * *   [Change the vSwitch for an ApsaraDB RDS for PostgreSQL instance](~~146885~~)
 * *   [Change the VPC and vSwitch for an ApsaraDB RDS for SQL Server instance](~~347675~~)
 *
 * @param request SwitchDBInstanceVpcRequest
 * @return SwitchDBInstanceVpcResponse
 */
func (client *Client) SwitchDBInstanceVpc(request *SwitchDBInstanceVpcRequest) (_result *SwitchDBInstanceVpcResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SwitchDBInstanceVpcResponse{}
	_body, _err := client.SwitchDBInstanceVpcWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * This operation is phased out.
 *
 * @param request SwitchGuardToMasterInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SwitchGuardToMasterInstanceResponse
 */
func (client *Client) SwitchGuardToMasterInstanceWithOptions(request *SwitchGuardToMasterInstanceRequest, runtime *util.RuntimeOptions) (_result *SwitchGuardToMasterInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SwitchGuardToMasterInstance"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SwitchGuardToMasterInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * This operation is phased out.
 *
 * @param request SwitchGuardToMasterInstanceRequest
 * @return SwitchGuardToMasterInstanceResponse
 */
func (client *Client) SwitchGuardToMasterInstance(request *SwitchGuardToMasterInstanceRequest) (_result *SwitchGuardToMasterInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SwitchGuardToMasterInstanceResponse{}
	_body, _err := client.SwitchGuardToMasterInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 * ### [](#)References
 * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * *   [Create tags for an ApsaraDB RDS for MySQL instance](~~96149~~)
 * *   [Create tags for an ApsaraDB RDS for PostgreSQL instance](~~96777~~)
 * *   [Create tags for an ApsaraDB RDS for SQL Server instance](~~95726~~)
 * *   [Create tags for an ApsaraDB RDS for MariaDB instance](~~97152~~)
 *
 * @param request TagResourcesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return TagResourcesResponse
 */
func (client *Client) TagResourcesWithOptions(request *TagResourcesRequest, runtime *util.RuntimeOptions) (_result *TagResourcesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceId)) {
		query["ResourceId"] = request.ResourceId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("TagResources"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &TagResourcesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 * ### [](#)References
 * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * *   [Create tags for an ApsaraDB RDS for MySQL instance](~~96149~~)
 * *   [Create tags for an ApsaraDB RDS for PostgreSQL instance](~~96777~~)
 * *   [Create tags for an ApsaraDB RDS for SQL Server instance](~~95726~~)
 * *   [Create tags for an ApsaraDB RDS for MariaDB instance](~~97152~~)
 *
 * @param request TagResourcesRequest
 * @return TagResourcesResponse
 */
func (client *Client) TagResources(request *TagResourcesRequest) (_result *TagResourcesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &TagResourcesResponse{}
	_body, _err := client.TagResourcesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   SQL Server
 *
 * @param request TerminateMigrateTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return TerminateMigrateTaskResponse
 */
func (client *Client) TerminateMigrateTaskWithOptions(request *TerminateMigrateTaskRequest, runtime *util.RuntimeOptions) (_result *TerminateMigrateTaskResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.MigrateTaskId)) {
		query["MigrateTaskId"] = request.MigrateTaskId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("TerminateMigrateTask"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &TerminateMigrateTaskResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   SQL Server
 *
 * @param request TerminateMigrateTaskRequest
 * @return TerminateMigrateTaskResponse
 */
func (client *Client) TerminateMigrateTask(request *TerminateMigrateTaskRequest) (_result *TerminateMigrateTaskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &TerminateMigrateTaskResponse{}
	_body, _err := client.TerminateMigrateTaskWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 * ### References
 * > Fees are generated if the call is successful. Before you call this operation, you must read the following documentation.
 * *   [Change the billing method of an ApsaraDB RDS for MySQL instance from pay-as-you-go to subscription](~~96048~~) or [Change the billing method of an ApsaraDB RDS for MySQL instance from subscription to pay-as-you-go](~~161875~~)
 * *   [Change the billing method of an ApsaraDB RDS for PostgreSQL instance from pay-as-you-go to subscription](~~96743~~) or [Change the billing method of an ApsaraDB RDS for PostgreSQL instance from subscription to pay-as-you-go](~~162756~~)
 * *   [Change the billing method of an ApsaraDB RDS for SQL Server instance from pay-as-you-go to subscription](~~95631~~) or [Change the billing method of an ApsaraDB RDS for SQL Server instance from subscription to pay-as-you-go](~~162755~~)
 * *   [Change the billing method of an ApsaraDB RDS for MariaDB instance from pay-as-you-go to subscription](~~97120~~) or [Change the billing method of an ApsaraDB RDS for MariaDB instance from subscription to pay-as-you-go](~~169252~~)
 *
 * @param request TransformDBInstancePayTypeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return TransformDBInstancePayTypeResponse
 */
func (client *Client) TransformDBInstancePayTypeWithOptions(request *TransformDBInstancePayTypeRequest, runtime *util.RuntimeOptions) (_result *TransformDBInstancePayTypeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AutoRenew)) {
		query["AutoRenew"] = request.AutoRenew
	}

	if !tea.BoolValue(util.IsUnset(request.BusinessInfo)) {
		query["BusinessInfo"] = request.BusinessInfo
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PayType)) {
		query["PayType"] = request.PayType
	}

	if !tea.BoolValue(util.IsUnset(request.Period)) {
		query["Period"] = request.Period
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.UsedTime)) {
		query["UsedTime"] = request.UsedTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("TransformDBInstancePayType"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &TransformDBInstancePayTypeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 * ### References
 * > Fees are generated if the call is successful. Before you call this operation, you must read the following documentation.
 * *   [Change the billing method of an ApsaraDB RDS for MySQL instance from pay-as-you-go to subscription](~~96048~~) or [Change the billing method of an ApsaraDB RDS for MySQL instance from subscription to pay-as-you-go](~~161875~~)
 * *   [Change the billing method of an ApsaraDB RDS for PostgreSQL instance from pay-as-you-go to subscription](~~96743~~) or [Change the billing method of an ApsaraDB RDS for PostgreSQL instance from subscription to pay-as-you-go](~~162756~~)
 * *   [Change the billing method of an ApsaraDB RDS for SQL Server instance from pay-as-you-go to subscription](~~95631~~) or [Change the billing method of an ApsaraDB RDS for SQL Server instance from subscription to pay-as-you-go](~~162755~~)
 * *   [Change the billing method of an ApsaraDB RDS for MariaDB instance from pay-as-you-go to subscription](~~97120~~) or [Change the billing method of an ApsaraDB RDS for MariaDB instance from subscription to pay-as-you-go](~~169252~~)
 *
 * @param request TransformDBInstancePayTypeRequest
 * @return TransformDBInstancePayTypeResponse
 */
func (client *Client) TransformDBInstancePayType(request *TransformDBInstancePayTypeRequest) (_result *TransformDBInstancePayTypeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &TransformDBInstancePayTypeResponse{}
	_body, _err := client.TransformDBInstancePayTypeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Supported database engine
 * PostgreSQL
 * ### References
 * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
 * [Lock an account of an ApsaraDB RDS for PostgreSQL instance](~~147649~~)
 *
 * @param request UnlockAccountRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UnlockAccountResponse
 */
func (client *Client) UnlockAccountWithOptions(request *UnlockAccountRequest, runtime *util.RuntimeOptions) (_result *UnlockAccountResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AccountName)) {
		query["AccountName"] = request.AccountName
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UnlockAccount"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UnlockAccountResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Supported database engine
 * PostgreSQL
 * ### References
 * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
 * [Lock an account of an ApsaraDB RDS for PostgreSQL instance](~~147649~~)
 *
 * @param request UnlockAccountRequest
 * @return UnlockAccountResponse
 */
func (client *Client) UnlockAccount(request *UnlockAccountRequest) (_result *UnlockAccountResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UnlockAccountResponse{}
	_body, _err := client.UnlockAccountWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 * ### [](#)Usage notes
 * *   You can remove up to 20 tags at a time.
 * *   If a tag is removed from an instance and is not added to other instances, the tag is automatically deleted.
 *
 * @param request UntagResourcesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UntagResourcesResponse
 */
func (client *Client) UntagResourcesWithOptions(request *UntagResourcesRequest, runtime *util.RuntimeOptions) (_result *UntagResourcesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.All)) {
		query["All"] = request.All
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceId)) {
		query["ResourceId"] = request.ResourceId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.TagKey)) {
		query["TagKey"] = request.TagKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UntagResources"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UntagResourcesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### [](#)Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * *   MariaDB
 * ### [](#)Usage notes
 * *   You can remove up to 20 tags at a time.
 * *   If a tag is removed from an instance and is not added to other instances, the tag is automatically deleted.
 *
 * @param request UntagResourcesRequest
 * @return UntagResourcesResponse
 */
func (client *Client) UntagResources(request *UntagResourcesRequest) (_result *UntagResourcesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UntagResourcesResponse{}
	_body, _err := client.UntagResourcesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Supported database engines
 * RDS PostgreSQL
 * ### References
 * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * [Manage extensions](~~2402409~~)
 *
 * @param request UpdatePostgresExtensionsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdatePostgresExtensionsResponse
 */
func (client *Client) UpdatePostgresExtensionsWithOptions(request *UpdatePostgresExtensionsRequest, runtime *util.RuntimeOptions) (_result *UpdatePostgresExtensionsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.DBNames)) {
		query["DBNames"] = request.DBNames
	}

	if !tea.BoolValue(util.IsUnset(request.Extensions)) {
		query["Extensions"] = request.Extensions
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdatePostgresExtensions"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdatePostgresExtensionsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Supported database engines
 * RDS PostgreSQL
 * ### References
 * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * [Manage extensions](~~2402409~~)
 *
 * @param request UpdatePostgresExtensionsRequest
 * @return UpdatePostgresExtensionsResponse
 */
func (client *Client) UpdatePostgresExtensions(request *UpdatePostgresExtensionsRequest) (_result *UpdatePostgresExtensionsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdatePostgresExtensionsResponse{}
	_body, _err := client.UpdatePostgresExtensionsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Supported database engines
 * RDS MySQL
 * ### References
 * A full backup file contains the data of a self-managed MySQL database. You can restore the data of a self-managed MySQL database from a full backup file to an ApsaraDB RDS for MySQL instance. For more information, see [Migrate the data of a self-managed MySQL 5.7 or MySQL 8.0 instance to an ApsaraDB RDS for MySQL instance](~~251779~~).
 * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 *
 * @param request UpdateUserBackupFileRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateUserBackupFileResponse
 */
func (client *Client) UpdateUserBackupFileWithOptions(request *UpdateUserBackupFileRequest, runtime *util.RuntimeOptions) (_result *UpdateUserBackupFileResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BackupId)) {
		query["BackupId"] = request.BackupId
	}

	if !tea.BoolValue(util.IsUnset(request.Comment)) {
		query["Comment"] = request.Comment
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Retention)) {
		query["Retention"] = request.Retention
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateUserBackupFile"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateUserBackupFileResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Supported database engines
 * RDS MySQL
 * ### References
 * A full backup file contains the data of a self-managed MySQL database. You can restore the data of a self-managed MySQL database from a full backup file to an ApsaraDB RDS for MySQL instance. For more information, see [Migrate the data of a self-managed MySQL 5.7 or MySQL 8.0 instance to an ApsaraDB RDS for MySQL instance](~~251779~~).
 * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 *
 * @param request UpdateUserBackupFileRequest
 * @return UpdateUserBackupFileResponse
 */
func (client *Client) UpdateUserBackupFile(request *UpdateUserBackupFileRequest) (_result *UpdateUserBackupFileResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateUserBackupFileResponse{}
	_body, _err := client.UpdateUserBackupFileWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Supported database engine
 * MySQL
 * ### References
 * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
 * [Upgrade the major engine version of an ApsaraDB RDS for MySQL instance](~~96058~~)
 *
 * @param request UpgradeDBInstanceEngineVersionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpgradeDBInstanceEngineVersionResponse
 */
func (client *Client) UpgradeDBInstanceEngineVersionWithOptions(request *UpgradeDBInstanceEngineVersionRequest, runtime *util.RuntimeOptions) (_result *UpgradeDBInstanceEngineVersionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.EffectiveTime)) {
		query["EffectiveTime"] = request.EffectiveTime
	}

	if !tea.BoolValue(util.IsUnset(request.EngineVersion)) {
		query["EngineVersion"] = request.EngineVersion
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpgradeDBInstanceEngineVersion"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpgradeDBInstanceEngineVersionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Supported database engine
 * MySQL
 * ### References
 * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
 * [Upgrade the major engine version of an ApsaraDB RDS for MySQL instance](~~96058~~)
 *
 * @param request UpgradeDBInstanceEngineVersionRequest
 * @return UpgradeDBInstanceEngineVersionResponse
 */
func (client *Client) UpgradeDBInstanceEngineVersion(request *UpgradeDBInstanceEngineVersionRequest) (_result *UpgradeDBInstanceEngineVersionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpgradeDBInstanceEngineVersionResponse{}
	_body, _err := client.UpgradeDBInstanceEngineVersionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * ### References
 * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
 * *   [Update the minor engine version of an ApsaraDB RDS for MySQL instance](~~96059~~)
 * *   [Update the minor engine version of an ApsaraDB RDS for PostgreSQL instance](~~146895~~)
 * *   [Update the minor engine version of an ApsaraDB RDS for SQL Server instance](~~213582~~)
 *
 * @param request UpgradeDBInstanceKernelVersionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpgradeDBInstanceKernelVersionResponse
 */
func (client *Client) UpgradeDBInstanceKernelVersionWithOptions(request *UpgradeDBInstanceKernelVersionRequest, runtime *util.RuntimeOptions) (_result *UpgradeDBInstanceKernelVersionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SwitchTime)) {
		query["SwitchTime"] = request.SwitchTime
	}

	if !tea.BoolValue(util.IsUnset(request.TargetMinorVersion)) {
		query["TargetMinorVersion"] = request.TargetMinorVersion
	}

	if !tea.BoolValue(util.IsUnset(request.UpgradeTime)) {
		query["UpgradeTime"] = request.UpgradeTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpgradeDBInstanceKernelVersion"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpgradeDBInstanceKernelVersionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * *   SQL Server
 * ### References
 * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
 * *   [Update the minor engine version of an ApsaraDB RDS for MySQL instance](~~96059~~)
 * *   [Update the minor engine version of an ApsaraDB RDS for PostgreSQL instance](~~146895~~)
 * *   [Update the minor engine version of an ApsaraDB RDS for SQL Server instance](~~213582~~)
 *
 * @param request UpgradeDBInstanceKernelVersionRequest
 * @return UpgradeDBInstanceKernelVersionResponse
 */
func (client *Client) UpgradeDBInstanceKernelVersion(request *UpgradeDBInstanceKernelVersionRequest) (_result *UpgradeDBInstanceKernelVersionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpgradeDBInstanceKernelVersionResponse{}
	_body, _err := client.UpgradeDBInstanceKernelVersionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Supported database engine
 * PostgreSQL
 * ### References
 * Fees are generated if the call is successful. Before you call this operation, read the following documentation and make sure that you fully understand the billing rules, prerequisites, and impacts of this operation.
 * [Upgrade the major engine version of an ApsaraDB RDS for PostgreSQL instance](~~203309~~)
 *
 * @param request UpgradeDBInstanceMajorVersionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpgradeDBInstanceMajorVersionResponse
 */
func (client *Client) UpgradeDBInstanceMajorVersionWithOptions(request *UpgradeDBInstanceMajorVersionRequest, runtime *util.RuntimeOptions) (_result *UpgradeDBInstanceMajorVersionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CollectStatMode)) {
		query["CollectStatMode"] = request.CollectStatMode
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceClass)) {
		query["DBInstanceClass"] = request.DBInstanceClass
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceStorage)) {
		query["DBInstanceStorage"] = request.DBInstanceStorage
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceStorageType)) {
		query["DBInstanceStorageType"] = request.DBInstanceStorageType
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceNetworkType)) {
		query["InstanceNetworkType"] = request.InstanceNetworkType
	}

	if !tea.BoolValue(util.IsUnset(request.PayType)) {
		query["PayType"] = request.PayType
	}

	if !tea.BoolValue(util.IsUnset(request.Period)) {
		query["Period"] = request.Period
	}

	if !tea.BoolValue(util.IsUnset(request.PrivateIpAddress)) {
		query["PrivateIpAddress"] = request.PrivateIpAddress
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SwitchOver)) {
		query["SwitchOver"] = request.SwitchOver
	}

	if !tea.BoolValue(util.IsUnset(request.SwitchTime)) {
		query["SwitchTime"] = request.SwitchTime
	}

	if !tea.BoolValue(util.IsUnset(request.SwitchTimeMode)) {
		query["SwitchTimeMode"] = request.SwitchTimeMode
	}

	if !tea.BoolValue(util.IsUnset(request.TargetMajorVersion)) {
		query["TargetMajorVersion"] = request.TargetMajorVersion
	}

	if !tea.BoolValue(util.IsUnset(request.UsedTime)) {
		query["UsedTime"] = request.UsedTime
	}

	if !tea.BoolValue(util.IsUnset(request.VPCId)) {
		query["VPCId"] = request.VPCId
	}

	if !tea.BoolValue(util.IsUnset(request.VSwitchId)) {
		query["VSwitchId"] = request.VSwitchId
	}

	if !tea.BoolValue(util.IsUnset(request.ZoneId)) {
		query["ZoneId"] = request.ZoneId
	}

	if !tea.BoolValue(util.IsUnset(request.ZoneIdSlave1)) {
		query["ZoneIdSlave1"] = request.ZoneIdSlave1
	}

	if !tea.BoolValue(util.IsUnset(request.ZoneIdSlave2)) {
		query["ZoneIdSlave2"] = request.ZoneIdSlave2
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpgradeDBInstanceMajorVersion"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpgradeDBInstanceMajorVersionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Supported database engine
 * PostgreSQL
 * ### References
 * Fees are generated if the call is successful. Before you call this operation, read the following documentation and make sure that you fully understand the billing rules, prerequisites, and impacts of this operation.
 * [Upgrade the major engine version of an ApsaraDB RDS for PostgreSQL instance](~~203309~~)
 *
 * @param request UpgradeDBInstanceMajorVersionRequest
 * @return UpgradeDBInstanceMajorVersionResponse
 */
func (client *Client) UpgradeDBInstanceMajorVersion(request *UpgradeDBInstanceMajorVersionRequest) (_result *UpgradeDBInstanceMajorVersionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpgradeDBInstanceMajorVersionResponse{}
	_body, _err := client.UpgradeDBInstanceMajorVersionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Supported database engine
 * PostgreSQL
 * ### References
 * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * [Upgrade the major engine version of an ApsaraDB RDS for PostgreSQL instance](~~203309~~)
 *
 * @param request UpgradeDBInstanceMajorVersionPrecheckRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpgradeDBInstanceMajorVersionPrecheckResponse
 */
func (client *Client) UpgradeDBInstanceMajorVersionPrecheckWithOptions(request *UpgradeDBInstanceMajorVersionPrecheckRequest, runtime *util.RuntimeOptions) (_result *UpgradeDBInstanceMajorVersionPrecheckResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.TargetMajorVersion)) {
		query["TargetMajorVersion"] = request.TargetMajorVersion
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpgradeDBInstanceMajorVersionPrecheck"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpgradeDBInstanceMajorVersionPrecheckResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Supported database engine
 * PostgreSQL
 * ### References
 * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
 * [Upgrade the major engine version of an ApsaraDB RDS for PostgreSQL instance](~~203309~~)
 *
 * @param request UpgradeDBInstanceMajorVersionPrecheckRequest
 * @return UpgradeDBInstanceMajorVersionPrecheckResponse
 */
func (client *Client) UpgradeDBInstanceMajorVersionPrecheck(request *UpgradeDBInstanceMajorVersionPrecheckRequest) (_result *UpgradeDBInstanceMajorVersionPrecheckResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpgradeDBInstanceMajorVersionPrecheckResponse{}
	_body, _err := client.UpgradeDBInstanceMajorVersionPrecheckWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * ### References
 * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
 * *   [Upgrade the dedicated proxy version of an ApsaraDB RDS for MySQL instance](~~197465~~)
 * *   [Upgrade the dedicated proxy version of an ApsaraDB RDS for PostgreSQL instance](~~418469~~)
 *
 * @param request UpgradeDBProxyInstanceKernelVersionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpgradeDBProxyInstanceKernelVersionResponse
 */
func (client *Client) UpgradeDBProxyInstanceKernelVersionWithOptions(request *UpgradeDBProxyInstanceKernelVersionRequest, runtime *util.RuntimeOptions) (_result *UpgradeDBProxyInstanceKernelVersionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBInstanceId)) {
		query["DBInstanceId"] = request.DBInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.DBProxyEngineType)) {
		query["DBProxyEngineType"] = request.DBProxyEngineType
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SwitchTime)) {
		query["SwitchTime"] = request.SwitchTime
	}

	if !tea.BoolValue(util.IsUnset(request.UpgradeTime)) {
		query["UpgradeTime"] = request.UpgradeTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpgradeDBProxyInstanceKernelVersion"),
		Version:     tea.String("2014-08-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpgradeDBProxyInstanceKernelVersionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Supported database engines
 * *   MySQL
 * *   PostgreSQL
 * ### References
 * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
 * *   [Upgrade the dedicated proxy version of an ApsaraDB RDS for MySQL instance](~~197465~~)
 * *   [Upgrade the dedicated proxy version of an ApsaraDB RDS for PostgreSQL instance](~~418469~~)
 *
 * @param request UpgradeDBProxyInstanceKernelVersionRequest
 * @return UpgradeDBProxyInstanceKernelVersionResponse
 */
func (client *Client) UpgradeDBProxyInstanceKernelVersion(request *UpgradeDBProxyInstanceKernelVersionRequest) (_result *UpgradeDBProxyInstanceKernelVersionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpgradeDBProxyInstanceKernelVersionResponse{}
	_body, _err := client.UpgradeDBProxyInstanceKernelVersionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}
