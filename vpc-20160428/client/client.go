// This file is auto-generated, don't edit it. Thanks.
package client

import (
	openapi "github.com/alibabacloud-go/darabonba-openapi/v2/client"
	openapiutil "github.com/alibabacloud-go/darabonba-openapi/v2/utils"
	"github.com/alibabacloud-go/tea/dara"
)

type Client struct {
	openapi.Client
	DisableSDKError *bool
}

func NewClient(config *openapiutil.Config) (*Client, error) {
	client := new(Client)
	err := client.Init(config)
	return client, err
}

func (client *Client) Init(config *openapiutil.Config) (_err error) {
	_err = client.Client.Init(config)
	if _err != nil {
		return _err
	}
	client.EndpointRule = dara.String("regional")
	client.EndpointMap = map[string]*string{
		"cn-hangzhou":                 dara.String("vpc.aliyuncs.com"),
		"cn-shanghai-finance-1":       dara.String("vpc.aliyuncs.com"),
		"cn-shenzhen-finance-1":       dara.String("vpc.aliyuncs.com"),
		"cn-north-2-gov-1":            dara.String("vpc.aliyuncs.com"),
		"ap-northeast-2-pop":          dara.String("vpc.aliyuncs.com"),
		"cn-beijing-finance-pop":      dara.String("vpc.aliyuncs.com"),
		"cn-beijing-gov-1":            dara.String("vpc.aliyuncs.com"),
		"cn-beijing-nu16-b01":         dara.String("vpc.aliyuncs.com"),
		"cn-edge-1":                   dara.String("vpc-nebula.cn-qingdao-nebula.aliyuncs.com"),
		"cn-fujian":                   dara.String("vpc.aliyuncs.com"),
		"cn-haidian-cm12-c01":         dara.String("vpc.aliyuncs.com"),
		"cn-hangzhou-bj-b01":          dara.String("vpc.aliyuncs.com"),
		"cn-hangzhou-finance":         dara.String("vpc.aliyuncs.com"),
		"cn-hangzhou-internal-prod-1": dara.String("vpc.aliyuncs.com"),
		"cn-hangzhou-internal-test-1": dara.String("vpc-pre.cn-hangzhou.aliyuncs.com"),
		"cn-hangzhou-internal-test-2": dara.String("vpc-inner-pre.cn-hangzhou.aliyuncs.com"),
		"cn-hangzhou-internal-test-3": dara.String("vpc-pre.cn-hangzhou.aliyuncs.com"),
		"cn-hangzhou-test-306":        dara.String("vpc-pre.cn-hangzhou.aliyuncs.com"),
		"cn-hongkong-finance-pop":     dara.String("vpc.aliyuncs.com"),
		"cn-huhehaote-nebula-1":       dara.String("vpc-nebula.cn-qingdao-nebula.aliyuncs.com"),
		"cn-qingdao-nebula":           dara.String("vpc-nebula.cn-qingdao-nebula.aliyuncs.com"),
		"cn-shanghai-et15-b01":        dara.String("vpc-pre.cn-hangzhou.aliyuncs.com"),
		"cn-shanghai-et2-b01":         dara.String("vpc.aliyuncs.com"),
		"cn-shanghai-inner":           dara.String("vpc.aliyuncs.com"),
		"cn-shanghai-internal-test-1": dara.String("vpc-pre.cn-hangzhou.aliyuncs.com"),
		"cn-shenzhen-inner":           dara.String("vpc.aliyuncs.com"),
		"cn-shenzhen-st4-d01":         dara.String("vpc.aliyuncs.com"),
		"cn-shenzhen-su18-b01":        dara.String("vpc.aliyuncs.com"),
		"cn-wuhan":                    dara.String("vpc.aliyuncs.com"),
		"cn-yushanfang":               dara.String("vpc.aliyuncs.com"),
		"cn-zhangbei":                 dara.String("vpc.aliyuncs.com"),
		"cn-zhangbei-na61-b01":        dara.String("vpc.aliyuncs.com"),
		"cn-zhangjiakou-na62-a01":     dara.String("vpc.cn-zhangjiakou.aliyuncs.com"),
		"cn-zhengzhou-nebula-1":       dara.String("vpc-nebula.cn-qingdao-nebula.aliyuncs.com"),
		"eu-west-1-oxs":               dara.String("vpc-nebula.cn-shenzhen-cloudstone.aliyuncs.com"),
		"rus-west-1-pop":              dara.String("vpc.aliyuncs.com"),
	}
	_err = client.CheckConfig(config)
	if _err != nil {
		return _err
	}
	client.Endpoint, _err = client.GetEndpoint(dara.String("vpc"), client.RegionId, client.EndpointRule, client.Network, client.Suffix, client.EndpointMap, client.Endpoint)
	if _err != nil {
		return _err
	}

	return nil
}

func (client *Client) GetEndpoint(productId *string, regionId *string, endpointRule *string, network *string, suffix *string, endpointMap map[string]*string, endpoint *string) (_result *string, _err error) {
	if !dara.IsNil(endpoint) {
		_result = endpoint
		return _result, _err
	}

	if !dara.IsNil(endpointMap) && !dara.IsNil(endpointMap[dara.StringValue(regionId)]) {
		_result = endpointMap[dara.StringValue(regionId)]
		return _result, _err
	}

	_body, _err := openapiutil.GetEndpointRules(productId, regionId, endpointRule, network, suffix)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Activates a router interface that is in the Inactive state.
//
// Description:
//
// After you call this operation, the router interface enters the **Activating*	- state. After the router interface is activated, it enters the **Active*	- state.
//
// >  You cannot activate a router interface that has overdue payments.
//
// @param request - ActivateRouterInterfaceRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ActivateRouterInterfaceResponse
func (client *Client) ActivateRouterInterfaceWithOptions(request *ActivateRouterInterfaceRequest, runtime *dara.RuntimeOptions) (_result *ActivateRouterInterfaceResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.RouterInterfaceId) {
		query["RouterInterfaceId"] = request.RouterInterfaceId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ActivateRouterInterface"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ActivateRouterInterfaceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Activates a router interface that is in the Inactive state.
//
// Description:
//
// After you call this operation, the router interface enters the **Activating*	- state. After the router interface is activated, it enters the **Active*	- state.
//
// >  You cannot activate a router interface that has overdue payments.
//
// @param request - ActivateRouterInterfaceRequest
//
// @return ActivateRouterInterfaceResponse
func (client *Client) ActivateRouterInterface(request *ActivateRouterInterfaceRequest) (_result *ActivateRouterInterfaceResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ActivateRouterInterfaceResponse{}
	_body, _err := client.ActivateRouterInterfaceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Enables a flow log. After the flow log is enabled, traffic information about a resource is captured.
//
// Description:
//
//	  The **ActiveFlowLog*	- operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeFlowLogs](https://help.aliyun.com/document_detail/87923.html) operation to query the status of a flow log:
//
//	    	- If the flow log is in the **Activating*	- state, the flow log is being started.
//
//	    	- If the flow log is in the **Active*	- state, the flow log is started.
//
//		- You cannot repeatedly call the **ActiveFlowLog*	- operation to start a flow log within the specified period of time.
//
// @param request - ActiveFlowLogRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ActiveFlowLogResponse
func (client *Client) ActiveFlowLogWithOptions(request *ActiveFlowLogRequest, runtime *dara.RuntimeOptions) (_result *ActiveFlowLogResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.FlowLogId) {
		query["FlowLogId"] = request.FlowLogId
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ActiveFlowLog"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ActiveFlowLogResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Enables a flow log. After the flow log is enabled, traffic information about a resource is captured.
//
// Description:
//
//	  The **ActiveFlowLog*	- operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeFlowLogs](https://help.aliyun.com/document_detail/87923.html) operation to query the status of a flow log:
//
//	    	- If the flow log is in the **Activating*	- state, the flow log is being started.
//
//	    	- If the flow log is in the **Active*	- state, the flow log is started.
//
//		- You cannot repeatedly call the **ActiveFlowLog*	- operation to start a flow log within the specified period of time.
//
// @param request - ActiveFlowLogRequest
//
// @return ActiveFlowLogResponse
func (client *Client) ActiveFlowLog(request *ActiveFlowLogRequest) (_result *ActiveFlowLogResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ActiveFlowLogResponse{}
	_body, _err := client.ActiveFlowLogWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Advertises a Border Gateway Protocol (BGP) network.
//
// @param request - AddBgpNetworkRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return AddBgpNetworkResponse
func (client *Client) AddBgpNetworkWithOptions(request *AddBgpNetworkRequest, runtime *dara.RuntimeOptions) (_result *AddBgpNetworkResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DstCidrBlock) {
		query["DstCidrBlock"] = request.DstCidrBlock
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.RouterId) {
		query["RouterId"] = request.RouterId
	}

	if !dara.IsNil(request.VpcId) {
		query["VpcId"] = request.VpcId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("AddBgpNetwork"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &AddBgpNetworkResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Advertises a Border Gateway Protocol (BGP) network.
//
// @param request - AddBgpNetworkRequest
//
// @return AddBgpNetworkResponse
func (client *Client) AddBgpNetwork(request *AddBgpNetworkRequest) (_result *AddBgpNetworkResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &AddBgpNetworkResponse{}
	_body, _err := client.AddBgpNetworkWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Associates an elastic IP address (EIP) with an Internet Shared Bandwidth instance.
//
// Description:
//
// Before you call this operation, take note of the following items:
//
//   - When you call this operation to associate an EIP with an Internet Shared Bandwidth instance, make sure that the EIP meets the following requirements:
//
//   - The EIP uses the pay-as-you-go billing method.
//
//   - The EIP and the Internet Shared Bandwidth instance belong to the same region.
//
//   - The line type of the EIPs is the same as that of the Internet Shared Bandwidth instance.
//
//   - **AddCommonBandwidthPackageIp*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeCommonBandwidthPackages](https://help.aliyun.com/document_detail/120309.html) operation to query the status of the operation.
//
//   - If the Internet Shared Bandwidth instance is in the **BINDING*	- state, the EIP is being associated with the Internet Shared Bandwidth instance. In this state, you can only query the Internet Shared Bandwidth instance and cannot perform other operations.
//
//   - If the Internet Shared Bandwidth instance is in the **BINDED*	- state, the EIP is associated with the Internet Shared Bandwidth instance.
//
// @param request - AddCommonBandwidthPackageIpRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return AddCommonBandwidthPackageIpResponse
func (client *Client) AddCommonBandwidthPackageIpWithOptions(request *AddCommonBandwidthPackageIpRequest, runtime *dara.RuntimeOptions) (_result *AddCommonBandwidthPackageIpResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.BandwidthPackageId) {
		query["BandwidthPackageId"] = request.BandwidthPackageId
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.IpInstanceId) {
		query["IpInstanceId"] = request.IpInstanceId
	}

	if !dara.IsNil(request.IpType) {
		query["IpType"] = request.IpType
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("AddCommonBandwidthPackageIp"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &AddCommonBandwidthPackageIpResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Associates an elastic IP address (EIP) with an Internet Shared Bandwidth instance.
//
// Description:
//
// Before you call this operation, take note of the following items:
//
//   - When you call this operation to associate an EIP with an Internet Shared Bandwidth instance, make sure that the EIP meets the following requirements:
//
//   - The EIP uses the pay-as-you-go billing method.
//
//   - The EIP and the Internet Shared Bandwidth instance belong to the same region.
//
//   - The line type of the EIPs is the same as that of the Internet Shared Bandwidth instance.
//
//   - **AddCommonBandwidthPackageIp*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeCommonBandwidthPackages](https://help.aliyun.com/document_detail/120309.html) operation to query the status of the operation.
//
//   - If the Internet Shared Bandwidth instance is in the **BINDING*	- state, the EIP is being associated with the Internet Shared Bandwidth instance. In this state, you can only query the Internet Shared Bandwidth instance and cannot perform other operations.
//
//   - If the Internet Shared Bandwidth instance is in the **BINDED*	- state, the EIP is associated with the Internet Shared Bandwidth instance.
//
// @param request - AddCommonBandwidthPackageIpRequest
//
// @return AddCommonBandwidthPackageIpResponse
func (client *Client) AddCommonBandwidthPackageIp(request *AddCommonBandwidthPackageIpRequest) (_result *AddCommonBandwidthPackageIpResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &AddCommonBandwidthPackageIpResponse{}
	_body, _err := client.AddCommonBandwidthPackageIpWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Associates multiple elastic IP addresses (EIPs) with an Internet Shared Bandwidth instance.
//
// Description:
//
//	  When you call this operation to associate EIPs with an Internet Shared Bandwidth instance, make sure that the EIPs meet the following requirements:
//
//	    	- The EIPs use the pay-as-you-go billing method.
//
//	    	- The EIP and the Internet Shared Bandwidth instance belong to the same region.
//
//	    	- The line type of the EIPs is the same as that of the Internet Shared Bandwidth instance.
//
//		- **AddCommonBandwidthPackageIps*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeCommonBandwidthPackages](~~DescribeCommonBandwidthPackages~~) operation to query the status of the task.
//
//	    	- If the Internet Shared Bandwidth instance is in the **BINDING*	- state, the EIP is being associated with the Internet Shared Bandwidth instance. In this state, you can only query the Internet Shared Bandwidth instance and cannot perform other operations.
//
//	    	- If the Internet Shared Bandwidth instance is in the **BINDED*	- state, the EIP is associated with the Internet Shared Bandwidth instance.
//
// @param request - AddCommonBandwidthPackageIpsRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return AddCommonBandwidthPackageIpsResponse
func (client *Client) AddCommonBandwidthPackageIpsWithOptions(request *AddCommonBandwidthPackageIpsRequest, runtime *dara.RuntimeOptions) (_result *AddCommonBandwidthPackageIpsResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.BandwidthPackageId) {
		query["BandwidthPackageId"] = request.BandwidthPackageId
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.IpInstanceIds) {
		query["IpInstanceIds"] = request.IpInstanceIds
	}

	if !dara.IsNil(request.IpType) {
		query["IpType"] = request.IpType
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("AddCommonBandwidthPackageIps"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &AddCommonBandwidthPackageIpsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Associates multiple elastic IP addresses (EIPs) with an Internet Shared Bandwidth instance.
//
// Description:
//
//	  When you call this operation to associate EIPs with an Internet Shared Bandwidth instance, make sure that the EIPs meet the following requirements:
//
//	    	- The EIPs use the pay-as-you-go billing method.
//
//	    	- The EIP and the Internet Shared Bandwidth instance belong to the same region.
//
//	    	- The line type of the EIPs is the same as that of the Internet Shared Bandwidth instance.
//
//		- **AddCommonBandwidthPackageIps*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeCommonBandwidthPackages](~~DescribeCommonBandwidthPackages~~) operation to query the status of the task.
//
//	    	- If the Internet Shared Bandwidth instance is in the **BINDING*	- state, the EIP is being associated with the Internet Shared Bandwidth instance. In this state, you can only query the Internet Shared Bandwidth instance and cannot perform other operations.
//
//	    	- If the Internet Shared Bandwidth instance is in the **BINDED*	- state, the EIP is associated with the Internet Shared Bandwidth instance.
//
// @param request - AddCommonBandwidthPackageIpsRequest
//
// @return AddCommonBandwidthPackageIpsResponse
func (client *Client) AddCommonBandwidthPackageIps(request *AddCommonBandwidthPackageIpsRequest) (_result *AddCommonBandwidthPackageIpsResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &AddCommonBandwidthPackageIpsResponse{}
	_body, _err := client.AddCommonBandwidthPackageIpsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Associates an elastic IP address (EIP) with a shared-bandwidth Global Accelerator (GA) instance.
//
// @param request - AddGlobalAccelerationInstanceIpRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return AddGlobalAccelerationInstanceIpResponse
func (client *Client) AddGlobalAccelerationInstanceIpWithOptions(request *AddGlobalAccelerationInstanceIpRequest, runtime *dara.RuntimeOptions) (_result *AddGlobalAccelerationInstanceIpResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.GlobalAccelerationInstanceId) {
		query["GlobalAccelerationInstanceId"] = request.GlobalAccelerationInstanceId
	}

	if !dara.IsNil(request.IpInstanceId) {
		query["IpInstanceId"] = request.IpInstanceId
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("AddGlobalAccelerationInstanceIp"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &AddGlobalAccelerationInstanceIpResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Associates an elastic IP address (EIP) with a shared-bandwidth Global Accelerator (GA) instance.
//
// @param request - AddGlobalAccelerationInstanceIpRequest
//
// @return AddGlobalAccelerationInstanceIpResponse
func (client *Client) AddGlobalAccelerationInstanceIp(request *AddGlobalAccelerationInstanceIpRequest) (_result *AddGlobalAccelerationInstanceIpResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &AddGlobalAccelerationInstanceIpResponse{}
	_body, _err := client.AddGlobalAccelerationInstanceIpWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Deprecated: OpenAPI AddIPv6TranslatorAclListEntry is deprecated
//
// Summary:
//
// Adds an IP entry to an access control list (ACL).
//
// @param request - AddIPv6TranslatorAclListEntryRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return AddIPv6TranslatorAclListEntryResponse
func (client *Client) AddIPv6TranslatorAclListEntryWithOptions(request *AddIPv6TranslatorAclListEntryRequest, runtime *dara.RuntimeOptions) (_result *AddIPv6TranslatorAclListEntryResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.AclEntryComment) {
		query["AclEntryComment"] = request.AclEntryComment
	}

	if !dara.IsNil(request.AclEntryIp) {
		query["AclEntryIp"] = request.AclEntryIp
	}

	if !dara.IsNil(request.AclId) {
		query["AclId"] = request.AclId
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("AddIPv6TranslatorAclListEntry"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &AddIPv6TranslatorAclListEntryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Deprecated: OpenAPI AddIPv6TranslatorAclListEntry is deprecated
//
// Summary:
//
// Adds an IP entry to an access control list (ACL).
//
// @param request - AddIPv6TranslatorAclListEntryRequest
//
// @return AddIPv6TranslatorAclListEntryResponse
// Deprecated
func (client *Client) AddIPv6TranslatorAclListEntry(request *AddIPv6TranslatorAclListEntryRequest) (_result *AddIPv6TranslatorAclListEntryResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &AddIPv6TranslatorAclListEntryResponse{}
	_body, _err := client.AddIPv6TranslatorAclListEntryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Adds a CIDR block to an IP address pool.
//
// Description:
//
// Before you call this operation, take note of the following limits:
//
//   - The CIDR block and the IP address pool must belong to the same region.
//
//   - The CIDR block and the IP address pool must use the same line type.
//
//   - **AddPublicIpAddressPoolCidrBlock*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListPublicIpAddressPoolCidrBlocks](https://help.aliyun.com/document_detail/429436.html) operation to query the status of the task.
//
//   - If the CIDR block is in the **Modifying*	- state, the CIDR block is being added. In this state, you can only query the CIDR block and cannot perform other operations.
//
//   - If the CIDR block is in the **Created*	- state, the CIDR block is added.
//
//   - You cannot repeatedly call the **AddPublicIpAddressPoolCidrBlock*	- operation to add a CIDR block to an IP address pool within the specified period of time.
//
// @param request - AddPublicIpAddressPoolCidrBlockRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return AddPublicIpAddressPoolCidrBlockResponse
func (client *Client) AddPublicIpAddressPoolCidrBlockWithOptions(request *AddPublicIpAddressPoolCidrBlockRequest, runtime *dara.RuntimeOptions) (_result *AddPublicIpAddressPoolCidrBlockResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.CidrBlock) {
		query["CidrBlock"] = request.CidrBlock
	}

	if !dara.IsNil(request.CidrMask) {
		query["CidrMask"] = request.CidrMask
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PublicIpAddressPoolId) {
		query["PublicIpAddressPoolId"] = request.PublicIpAddressPoolId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("AddPublicIpAddressPoolCidrBlock"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &AddPublicIpAddressPoolCidrBlockResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Adds a CIDR block to an IP address pool.
//
// Description:
//
// Before you call this operation, take note of the following limits:
//
//   - The CIDR block and the IP address pool must belong to the same region.
//
//   - The CIDR block and the IP address pool must use the same line type.
//
//   - **AddPublicIpAddressPoolCidrBlock*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListPublicIpAddressPoolCidrBlocks](https://help.aliyun.com/document_detail/429436.html) operation to query the status of the task.
//
//   - If the CIDR block is in the **Modifying*	- state, the CIDR block is being added. In this state, you can only query the CIDR block and cannot perform other operations.
//
//   - If the CIDR block is in the **Created*	- state, the CIDR block is added.
//
//   - You cannot repeatedly call the **AddPublicIpAddressPoolCidrBlock*	- operation to add a CIDR block to an IP address pool within the specified period of time.
//
// @param request - AddPublicIpAddressPoolCidrBlockRequest
//
// @return AddPublicIpAddressPoolCidrBlockResponse
func (client *Client) AddPublicIpAddressPoolCidrBlock(request *AddPublicIpAddressPoolCidrBlockRequest) (_result *AddPublicIpAddressPoolCidrBlockResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &AddPublicIpAddressPoolCidrBlockResponse{}
	_body, _err := client.AddPublicIpAddressPoolCidrBlockWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Adds a traffic mirror source to a traffic mirror session.
//
// Description:
//
//	  **AddSourcesToTrafficMirrorSession*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListTrafficMirrorSessions](https://help.aliyun.com/document_detail/261367.html) operation to query the status of the task.
//
//	    	- If the traffic mirror session is in the **Modifying*	- state, the traffic mirror source is being added to the traffic mirror session.
//
//	    	- If the traffic mirror session is in the **Created*	- state, the traffic mirror source is added to the traffic mirror session.
//
//		- You cannot repeatedly call the **AddSourcesToTrafficMirrorSession*	- operation to add a traffic mirror source to a traffic mirror session within the specified period of time.
//
// @param request - AddSourcesToTrafficMirrorSessionRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return AddSourcesToTrafficMirrorSessionResponse
func (client *Client) AddSourcesToTrafficMirrorSessionWithOptions(request *AddSourcesToTrafficMirrorSessionRequest, runtime *dara.RuntimeOptions) (_result *AddSourcesToTrafficMirrorSessionResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.TrafficMirrorSessionId) {
		query["TrafficMirrorSessionId"] = request.TrafficMirrorSessionId
	}

	if !dara.IsNil(request.TrafficMirrorSourceIds) {
		query["TrafficMirrorSourceIds"] = request.TrafficMirrorSourceIds
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("AddSourcesToTrafficMirrorSession"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &AddSourcesToTrafficMirrorSessionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Adds a traffic mirror source to a traffic mirror session.
//
// Description:
//
//	  **AddSourcesToTrafficMirrorSession*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListTrafficMirrorSessions](https://help.aliyun.com/document_detail/261367.html) operation to query the status of the task.
//
//	    	- If the traffic mirror session is in the **Modifying*	- state, the traffic mirror source is being added to the traffic mirror session.
//
//	    	- If the traffic mirror session is in the **Created*	- state, the traffic mirror source is added to the traffic mirror session.
//
//		- You cannot repeatedly call the **AddSourcesToTrafficMirrorSession*	- operation to add a traffic mirror source to a traffic mirror session within the specified period of time.
//
// @param request - AddSourcesToTrafficMirrorSessionRequest
//
// @return AddSourcesToTrafficMirrorSessionResponse
func (client *Client) AddSourcesToTrafficMirrorSession(request *AddSourcesToTrafficMirrorSessionRequest) (_result *AddSourcesToTrafficMirrorSessionResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &AddSourcesToTrafficMirrorSessionResponse{}
	_body, _err := client.AddSourcesToTrafficMirrorSessionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Applies for an elastic IP address (EIP).
//
// Description:
//
// Before you call this operation, make sure that you are familiar with the billing methods and pricing of EIPs. For more information, see [Billing overview](https://help.aliyun.com/document_detail/122035.html).
//
// After you call this operation, the system randomly allocates an EIP that is in the **Available*	- state in the specified region. EIPs support only the ICMP, TCP, and UDP transport layer protocols. The IGMP and SCTP protocols are not supported.
//
// @param request - AllocateEipAddressRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return AllocateEipAddressResponse
func (client *Client) AllocateEipAddressWithOptions(request *AllocateEipAddressRequest, runtime *dara.RuntimeOptions) (_result *AllocateEipAddressResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ActivityId) {
		query["ActivityId"] = request.ActivityId
	}

	if !dara.IsNil(request.AutoPay) {
		query["AutoPay"] = request.AutoPay
	}

	if !dara.IsNil(request.Bandwidth) {
		query["Bandwidth"] = request.Bandwidth
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.Description) {
		query["Description"] = request.Description
	}

	if !dara.IsNil(request.ISP) {
		query["ISP"] = request.ISP
	}

	if !dara.IsNil(request.InstanceChargeType) {
		query["InstanceChargeType"] = request.InstanceChargeType
	}

	if !dara.IsNil(request.InstanceId) {
		query["InstanceId"] = request.InstanceId
	}

	if !dara.IsNil(request.InternetChargeType) {
		query["InternetChargeType"] = request.InternetChargeType
	}

	if !dara.IsNil(request.IpAddress) {
		query["IpAddress"] = request.IpAddress
	}

	if !dara.IsNil(request.Name) {
		query["Name"] = request.Name
	}

	if !dara.IsNil(request.Netmode) {
		query["Netmode"] = request.Netmode
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.Period) {
		query["Period"] = request.Period
	}

	if !dara.IsNil(request.PricingCycle) {
		query["PricingCycle"] = request.PricingCycle
	}

	if !dara.IsNil(request.PublicIpAddressPoolId) {
		query["PublicIpAddressPoolId"] = request.PublicIpAddressPoolId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceGroupId) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.SecurityProtectionTypes) {
		query["SecurityProtectionTypes"] = request.SecurityProtectionTypes
	}

	if !dara.IsNil(request.Tag) {
		query["Tag"] = request.Tag
	}

	if !dara.IsNil(request.Zone) {
		query["Zone"] = request.Zone
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("AllocateEipAddress"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &AllocateEipAddressResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Applies for an elastic IP address (EIP).
//
// Description:
//
// Before you call this operation, make sure that you are familiar with the billing methods and pricing of EIPs. For more information, see [Billing overview](https://help.aliyun.com/document_detail/122035.html).
//
// After you call this operation, the system randomly allocates an EIP that is in the **Available*	- state in the specified region. EIPs support only the ICMP, TCP, and UDP transport layer protocols. The IGMP and SCTP protocols are not supported.
//
// @param request - AllocateEipAddressRequest
//
// @return AllocateEipAddressResponse
func (client *Client) AllocateEipAddress(request *AllocateEipAddressRequest) (_result *AllocateEipAddressResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &AllocateEipAddressResponse{}
	_body, _err := client.AllocateEipAddressWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Requests a specified elastic IP address (EIP).
//
// @param request - AllocateEipAddressProRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return AllocateEipAddressProResponse
func (client *Client) AllocateEipAddressProWithOptions(request *AllocateEipAddressProRequest, runtime *dara.RuntimeOptions) (_result *AllocateEipAddressProResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.AutoPay) {
		query["AutoPay"] = request.AutoPay
	}

	if !dara.IsNil(request.Bandwidth) {
		query["Bandwidth"] = request.Bandwidth
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.ISP) {
		query["ISP"] = request.ISP
	}

	if !dara.IsNil(request.InstanceChargeType) {
		query["InstanceChargeType"] = request.InstanceChargeType
	}

	if !dara.IsNil(request.InstanceId) {
		query["InstanceId"] = request.InstanceId
	}

	if !dara.IsNil(request.InternetChargeType) {
		query["InternetChargeType"] = request.InternetChargeType
	}

	if !dara.IsNil(request.IpAddress) {
		query["IpAddress"] = request.IpAddress
	}

	if !dara.IsNil(request.Netmode) {
		query["Netmode"] = request.Netmode
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.Period) {
		query["Period"] = request.Period
	}

	if !dara.IsNil(request.PricingCycle) {
		query["PricingCycle"] = request.PricingCycle
	}

	if !dara.IsNil(request.PublicIpAddressPoolId) {
		query["PublicIpAddressPoolId"] = request.PublicIpAddressPoolId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceGroupId) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.SecurityProtectionTypes) {
		query["SecurityProtectionTypes"] = request.SecurityProtectionTypes
	}

	if !dara.IsNil(request.Tag) {
		query["Tag"] = request.Tag
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("AllocateEipAddressPro"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &AllocateEipAddressProResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Requests a specified elastic IP address (EIP).
//
// @param request - AllocateEipAddressProRequest
//
// @return AllocateEipAddressProResponse
func (client *Client) AllocateEipAddressPro(request *AllocateEipAddressProRequest) (_result *AllocateEipAddressProResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &AllocateEipAddressProResponse{}
	_body, _err := client.AllocateEipAddressProWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Deprecated: OpenAPI AllocateEipSegmentAddress is deprecated
//
// Summary:
//
// Applies for contiguous elastic IP addresses (EIPs).
//
// Description:
//
// *AllocateEipSegmentAddress*	- is an asynchronous operation. After a request is sent, the system returns the ID of a contiguous EIP group and runs the task in the background. You can call the [DescribeEipSegment](https://help.aliyun.com/document_detail/156063.html) operation to query the status of the task.
//
//   - If the contiguous EIP group is in the **Allocating*	- state, the EIPs are being allocated. In this case, you can only perform the query operation and cannot perform other operations.
//
//   - If the contiguous EIP group is in the **Allocated*	- state, the EIPs are allocated.
//
// @param request - AllocateEipSegmentAddressRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return AllocateEipSegmentAddressResponse
func (client *Client) AllocateEipSegmentAddressWithOptions(request *AllocateEipSegmentAddressRequest, runtime *dara.RuntimeOptions) (_result *AllocateEipSegmentAddressResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.Bandwidth) {
		query["Bandwidth"] = request.Bandwidth
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.EipMask) {
		query["EipMask"] = request.EipMask
	}

	if !dara.IsNil(request.InternetChargeType) {
		query["InternetChargeType"] = request.InternetChargeType
	}

	if !dara.IsNil(request.Isp) {
		query["Isp"] = request.Isp
	}

	if !dara.IsNil(request.Netmode) {
		query["Netmode"] = request.Netmode
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceGroupId) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.Zone) {
		query["Zone"] = request.Zone
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("AllocateEipSegmentAddress"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &AllocateEipSegmentAddressResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Deprecated: OpenAPI AllocateEipSegmentAddress is deprecated
//
// Summary:
//
// Applies for contiguous elastic IP addresses (EIPs).
//
// Description:
//
// *AllocateEipSegmentAddress*	- is an asynchronous operation. After a request is sent, the system returns the ID of a contiguous EIP group and runs the task in the background. You can call the [DescribeEipSegment](https://help.aliyun.com/document_detail/156063.html) operation to query the status of the task.
//
//   - If the contiguous EIP group is in the **Allocating*	- state, the EIPs are being allocated. In this case, you can only perform the query operation and cannot perform other operations.
//
//   - If the contiguous EIP group is in the **Allocated*	- state, the EIPs are allocated.
//
// @param request - AllocateEipSegmentAddressRequest
//
// @return AllocateEipSegmentAddressResponse
// Deprecated
func (client *Client) AllocateEipSegmentAddress(request *AllocateEipSegmentAddressRequest) (_result *AllocateEipSegmentAddressResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &AllocateEipSegmentAddressResponse{}
	_body, _err := client.AllocateEipSegmentAddressWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Assigns an IPv6 address.
//
// @param request - AllocateIpv6AddressRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return AllocateIpv6AddressResponse
func (client *Client) AllocateIpv6AddressWithOptions(request *AllocateIpv6AddressRequest, runtime *dara.RuntimeOptions) (_result *AllocateIpv6AddressResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.AddressType) {
		query["AddressType"] = request.AddressType
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.Ipv6Address) {
		query["Ipv6Address"] = request.Ipv6Address
	}

	if !dara.IsNil(request.Ipv6AddressDescription) {
		query["Ipv6AddressDescription"] = request.Ipv6AddressDescription
	}

	if !dara.IsNil(request.Ipv6AddressName) {
		query["Ipv6AddressName"] = request.Ipv6AddressName
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceGroupId) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.Tag) {
		query["Tag"] = request.Tag
	}

	if !dara.IsNil(request.VSwitchId) {
		query["VSwitchId"] = request.VSwitchId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("AllocateIpv6Address"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &AllocateIpv6AddressResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Assigns an IPv6 address.
//
// @param request - AllocateIpv6AddressRequest
//
// @return AllocateIpv6AddressResponse
func (client *Client) AllocateIpv6Address(request *AllocateIpv6AddressRequest) (_result *AllocateIpv6AddressResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &AllocateIpv6AddressResponse{}
	_body, _err := client.AllocateIpv6AddressWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Default IPv6 gateways support only private communication. You can call the AllocateIpv6InternetBandwidth operation to purchase Internet bandwidth resources for an IPv6 address. This way, ECS instances in a VPC can access the Internet through the IPv6 address. IPv6 clients can also access the ECS instances over the Internet.
//
// Description:
//
//	  Before you call this operation, make sure that an ECS instance that supports IPv6 is created in a VPC that has an IPv6 CIDR block. For more information, see [Create a VPC with an IPv6 CIDR block](https://help.aliyun.com/document_detail/100540.html).
//
//		- You cannot repeatedly call **AllocateIpv6InternetBandwidth*	- within the specified period of time.
//
// @param request - AllocateIpv6InternetBandwidthRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return AllocateIpv6InternetBandwidthResponse
func (client *Client) AllocateIpv6InternetBandwidthWithOptions(request *AllocateIpv6InternetBandwidthRequest, runtime *dara.RuntimeOptions) (_result *AllocateIpv6InternetBandwidthResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.Bandwidth) {
		query["Bandwidth"] = request.Bandwidth
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.InternetChargeType) {
		query["InternetChargeType"] = request.InternetChargeType
	}

	if !dara.IsNil(request.Ipv6AddressId) {
		query["Ipv6AddressId"] = request.Ipv6AddressId
	}

	if !dara.IsNil(request.Ipv6GatewayId) {
		query["Ipv6GatewayId"] = request.Ipv6GatewayId
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("AllocateIpv6InternetBandwidth"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &AllocateIpv6InternetBandwidthResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Default IPv6 gateways support only private communication. You can call the AllocateIpv6InternetBandwidth operation to purchase Internet bandwidth resources for an IPv6 address. This way, ECS instances in a VPC can access the Internet through the IPv6 address. IPv6 clients can also access the ECS instances over the Internet.
//
// Description:
//
//	  Before you call this operation, make sure that an ECS instance that supports IPv6 is created in a VPC that has an IPv6 CIDR block. For more information, see [Create a VPC with an IPv6 CIDR block](https://help.aliyun.com/document_detail/100540.html).
//
//		- You cannot repeatedly call **AllocateIpv6InternetBandwidth*	- within the specified period of time.
//
// @param request - AllocateIpv6InternetBandwidthRequest
//
// @return AllocateIpv6InternetBandwidthResponse
func (client *Client) AllocateIpv6InternetBandwidth(request *AllocateIpv6InternetBandwidthRequest) (_result *AllocateIpv6InternetBandwidthResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &AllocateIpv6InternetBandwidthResponse{}
	_body, _err := client.AllocateIpv6InternetBandwidthWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Reserves an IPv6 CIDR block.
//
// Description:
//
// # [](#)
//
// The following section describes how to allocate an IPv6 CIDR block to a virtual private cloud (VPC):
//
// 1.  Call the AllocateVpcIpv6Cidr operation to reserve the IPv6 CIDR block.
//
// 2.  To allocate an IPv6 CIDR block to an existing VPC, call the [AssociateVpcCidrBlock](https://help.aliyun.com/document_detail/146745.html) operation. Set **RegionId**, **VpcId**, and **IPv6CidrBlock*	- to the IPv6 CIDR bock, and set **IpVersion*	- to **ipv6**. To allocate an IPv6 CIDR block when you create a VPC, call the [CreateVpc](https://help.aliyun.com/document_detail/35737.html) operation. Set **RegionId*	- and **Ipv6CidrBlock*	- to the IPv6 CIDR block, and set **EnableIpv6*	- to **true**.
//
// @param request - AllocateVpcIpv6CidrRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return AllocateVpcIpv6CidrResponse
func (client *Client) AllocateVpcIpv6CidrWithOptions(request *AllocateVpcIpv6CidrRequest, runtime *dara.RuntimeOptions) (_result *AllocateVpcIpv6CidrResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.AddressPoolType) {
		query["AddressPoolType"] = request.AddressPoolType
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.Ipv6CidrBlock) {
		query["Ipv6CidrBlock"] = request.Ipv6CidrBlock
	}

	if !dara.IsNil(request.Ipv6Isp) {
		query["Ipv6Isp"] = request.Ipv6Isp
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("AllocateVpcIpv6Cidr"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &AllocateVpcIpv6CidrResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Reserves an IPv6 CIDR block.
//
// Description:
//
// # [](#)
//
// The following section describes how to allocate an IPv6 CIDR block to a virtual private cloud (VPC):
//
// 1.  Call the AllocateVpcIpv6Cidr operation to reserve the IPv6 CIDR block.
//
// 2.  To allocate an IPv6 CIDR block to an existing VPC, call the [AssociateVpcCidrBlock](https://help.aliyun.com/document_detail/146745.html) operation. Set **RegionId**, **VpcId**, and **IPv6CidrBlock*	- to the IPv6 CIDR bock, and set **IpVersion*	- to **ipv6**. To allocate an IPv6 CIDR block when you create a VPC, call the [CreateVpc](https://help.aliyun.com/document_detail/35737.html) operation. Set **RegionId*	- and **Ipv6CidrBlock*	- to the IPv6 CIDR block, and set **EnableIpv6*	- to **true**.
//
// @param request - AllocateVpcIpv6CidrRequest
//
// @return AllocateVpcIpv6CidrResponse
func (client *Client) AllocateVpcIpv6Cidr(request *AllocateVpcIpv6CidrRequest) (_result *AllocateVpcIpv6CidrResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &AllocateVpcIpv6CidrResponse{}
	_body, _err := client.AllocateVpcIpv6CidrWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Applies for a Letter of Authorization (LOA) for an Express Connect circuit.
//
// @param request - ApplyPhysicalConnectionLOARequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ApplyPhysicalConnectionLOAResponse
func (client *Client) ApplyPhysicalConnectionLOAWithOptions(request *ApplyPhysicalConnectionLOARequest, runtime *dara.RuntimeOptions) (_result *ApplyPhysicalConnectionLOAResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.Bandwidth) {
		query["Bandwidth"] = request.Bandwidth
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.CompanyName) {
		query["CompanyName"] = request.CompanyName
	}

	if !dara.IsNil(request.ConstructionTime) {
		query["ConstructionTime"] = request.ConstructionTime
	}

	if !dara.IsNil(request.InstanceId) {
		query["InstanceId"] = request.InstanceId
	}

	if !dara.IsNil(request.LineType) {
		query["LineType"] = request.LineType
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PMInfo) {
		query["PMInfo"] = request.PMInfo
	}

	if !dara.IsNil(request.PeerLocation) {
		query["PeerLocation"] = request.PeerLocation
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.Si) {
		query["Si"] = request.Si
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ApplyPhysicalConnectionLOA"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ApplyPhysicalConnectionLOAResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Applies for a Letter of Authorization (LOA) for an Express Connect circuit.
//
// @param request - ApplyPhysicalConnectionLOARequest
//
// @return ApplyPhysicalConnectionLOAResponse
func (client *Client) ApplyPhysicalConnectionLOA(request *ApplyPhysicalConnectionLOARequest) (_result *ApplyPhysicalConnectionLOAResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ApplyPhysicalConnectionLOAResponse{}
	_body, _err := client.ApplyPhysicalConnectionLOAWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Associates an elastic IP address (EIP) with an instance in the same region.
//
// Description:
//
//	  You can associate an EIP with an Elastic Compute Service (ECS) instance, a Classic Load Balancer (CLB) instance, a secondary elastic network interface (ENI), a NAT gateway, or a high-availability virtual IP address (HAVIP) in the same region. The ECS instance and CLB instance must be deployed in a virtual private cloud (VPC).
//
//		- **AssociateEipAddress*	- is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeEipAddresses](https://help.aliyun.com/document_detail/120193.html) operation to query the status of the task.
//
//	    	- If the EIP is in the **Associating*	- state, the EIP is being associated. In this state, you can only query the EIP and cannot perform other operations.
//
//	    	- If the EIP is in the **InUse*	- state, the EIP is associated.
//
//		- You cannot call the **AssociateEipAddress*	- operation to associate an EIP with multiple instances at a time.
//
// @param request - AssociateEipAddressRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return AssociateEipAddressResponse
func (client *Client) AssociateEipAddressWithOptions(request *AssociateEipAddressRequest, runtime *dara.RuntimeOptions) (_result *AssociateEipAddressResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.AllocationId) {
		query["AllocationId"] = request.AllocationId
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.InstanceId) {
		query["InstanceId"] = request.InstanceId
	}

	if !dara.IsNil(request.InstanceRegionId) {
		query["InstanceRegionId"] = request.InstanceRegionId
	}

	if !dara.IsNil(request.InstanceType) {
		query["InstanceType"] = request.InstanceType
	}

	if !dara.IsNil(request.Mode) {
		query["Mode"] = request.Mode
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PrivateIpAddress) {
		query["PrivateIpAddress"] = request.PrivateIpAddress
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.VpcId) {
		query["VpcId"] = request.VpcId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("AssociateEipAddress"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &AssociateEipAddressResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Associates an elastic IP address (EIP) with an instance in the same region.
//
// Description:
//
//	  You can associate an EIP with an Elastic Compute Service (ECS) instance, a Classic Load Balancer (CLB) instance, a secondary elastic network interface (ENI), a NAT gateway, or a high-availability virtual IP address (HAVIP) in the same region. The ECS instance and CLB instance must be deployed in a virtual private cloud (VPC).
//
//		- **AssociateEipAddress*	- is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeEipAddresses](https://help.aliyun.com/document_detail/120193.html) operation to query the status of the task.
//
//	    	- If the EIP is in the **Associating*	- state, the EIP is being associated. In this state, you can only query the EIP and cannot perform other operations.
//
//	    	- If the EIP is in the **InUse*	- state, the EIP is associated.
//
//		- You cannot call the **AssociateEipAddress*	- operation to associate an EIP with multiple instances at a time.
//
// @param request - AssociateEipAddressRequest
//
// @return AssociateEipAddressResponse
func (client *Client) AssociateEipAddress(request *AssociateEipAddressRequest) (_result *AssociateEipAddressResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &AssociateEipAddressResponse{}
	_body, _err := client.AssociateEipAddressWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Associates multiple elastic IP addresses (EIPs) with an instance in the same region.
//
// Description:
//
//	  You can call the **AssociateEipAddressBatch*	- operation to associate EIPs with an instance in the same region. The instance must be a NAT gateway or a secondary elastic network interface (ENI). For more information about how to associate EIPs with other instances, see [AssociateEipAddress](https://help.aliyun.com/document_detail/120195.html).
//
//		- **AssociateEipAddressBatch*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeEipAddresses](https://help.aliyun.com/document_detail/120193.html) operation to query the status of the task.
//
//	    	- If the EIP is in the **Associating*	- state, the EIP is being associated. You can only query the EIP and cannot perform other operations.
//
//	    	- If the EIP is in the **InUse*	- state, the EIP is associated.
//
//		- You cannot call the **AssociateEipAddressBatch*	- operation to associate an EIP with multiple instances at a time.
//
// @param request - AssociateEipAddressBatchRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return AssociateEipAddressBatchResponse
func (client *Client) AssociateEipAddressBatchWithOptions(request *AssociateEipAddressBatchRequest, runtime *dara.RuntimeOptions) (_result *AssociateEipAddressBatchResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.BindedInstanceId) {
		query["BindedInstanceId"] = request.BindedInstanceId
	}

	if !dara.IsNil(request.BindedInstanceType) {
		query["BindedInstanceType"] = request.BindedInstanceType
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.InstanceIds) {
		query["InstanceIds"] = request.InstanceIds
	}

	if !dara.IsNil(request.Mode) {
		query["Mode"] = request.Mode
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("AssociateEipAddressBatch"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &AssociateEipAddressBatchResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Associates multiple elastic IP addresses (EIPs) with an instance in the same region.
//
// Description:
//
//	  You can call the **AssociateEipAddressBatch*	- operation to associate EIPs with an instance in the same region. The instance must be a NAT gateway or a secondary elastic network interface (ENI). For more information about how to associate EIPs with other instances, see [AssociateEipAddress](https://help.aliyun.com/document_detail/120195.html).
//
//		- **AssociateEipAddressBatch*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeEipAddresses](https://help.aliyun.com/document_detail/120193.html) operation to query the status of the task.
//
//	    	- If the EIP is in the **Associating*	- state, the EIP is being associated. You can only query the EIP and cannot perform other operations.
//
//	    	- If the EIP is in the **InUse*	- state, the EIP is associated.
//
//		- You cannot call the **AssociateEipAddressBatch*	- operation to associate an EIP with multiple instances at a time.
//
// @param request - AssociateEipAddressBatchRequest
//
// @return AssociateEipAddressBatchResponse
func (client *Client) AssociateEipAddressBatch(request *AssociateEipAddressBatchRequest) (_result *AssociateEipAddressBatchResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &AssociateEipAddressBatchResponse{}
	_body, _err := client.AssociateEipAddressBatchWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Associates a high-availability virtual IP address (HaVip) with an Elastic Compute Service (ECS) instance or an elastic network interface (ENI).
//
// Description:
//
// When you call this operation, take note of the following limits:
//
//   - An HaVip immediately takes effect after it is associated. You do not need to restart the ECS instance. However, you must associate the HaVip with the ENI of the ECS instance.
//
//   - The HaVip and ECS instance must belong to the same vSwitch.
//
//   - You can associate an HaVip with at most two ECS instances.
//
//   - The ECS instance must be in the **Running*	- or **Stopped*	- state.
//
//   - The HaVip must be in the **Available*	- or **InUse*	- state.
//
//   - The **AssociateHaVip*	- operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeHaVips](https://help.aliyun.com/document_detail/114611.html) operation to query the status of an HaVip:
//
//   - If the HaVip is in the **Associating*	- state, the HaVip is being associated.
//
//   - If the HaVip is in the **InUse*	- state, the HaVip is associated.
//
//   - You cannot repeatedly call the **AssociateHaVip*	- operation to associate an HaVip within the specified period of time.
//
// @param request - AssociateHaVipRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return AssociateHaVipResponse
func (client *Client) AssociateHaVipWithOptions(request *AssociateHaVipRequest, runtime *dara.RuntimeOptions) (_result *AssociateHaVipResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.HaVipId) {
		query["HaVipId"] = request.HaVipId
	}

	if !dara.IsNil(request.InstanceId) {
		query["InstanceId"] = request.InstanceId
	}

	if !dara.IsNil(request.InstanceType) {
		query["InstanceType"] = request.InstanceType
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("AssociateHaVip"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &AssociateHaVipResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Associates a high-availability virtual IP address (HaVip) with an Elastic Compute Service (ECS) instance or an elastic network interface (ENI).
//
// Description:
//
// When you call this operation, take note of the following limits:
//
//   - An HaVip immediately takes effect after it is associated. You do not need to restart the ECS instance. However, you must associate the HaVip with the ENI of the ECS instance.
//
//   - The HaVip and ECS instance must belong to the same vSwitch.
//
//   - You can associate an HaVip with at most two ECS instances.
//
//   - The ECS instance must be in the **Running*	- or **Stopped*	- state.
//
//   - The HaVip must be in the **Available*	- or **InUse*	- state.
//
//   - The **AssociateHaVip*	- operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeHaVips](https://help.aliyun.com/document_detail/114611.html) operation to query the status of an HaVip:
//
//   - If the HaVip is in the **Associating*	- state, the HaVip is being associated.
//
//   - If the HaVip is in the **InUse*	- state, the HaVip is associated.
//
//   - You cannot repeatedly call the **AssociateHaVip*	- operation to associate an HaVip within the specified period of time.
//
// @param request - AssociateHaVipRequest
//
// @return AssociateHaVipResponse
func (client *Client) AssociateHaVip(request *AssociateHaVipRequest) (_result *AssociateHaVipResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &AssociateHaVipResponse{}
	_body, _err := client.AssociateHaVipWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Associates a network access control list (ACL) with a vSwitch.
//
// Description:
//
// ## [](#)Description
//
//   - **AssociateNetworkAcl*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeNetworkAclAttributes](https://help.aliyun.com/document_detail/116542.html) operation to query the status of the task.
//
//   - If the network ACL is in the **BINDING*	- state, the network ACL is being associated.
//
//   - If the network ACL is in the **BINDED*	- state, the network ACL is associated.
//
//   - You cannot repeatedly call the **AssociateNetworkAcl*	- operation to associate a network ACL within the specified period of time.
//
// @param request - AssociateNetworkAclRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return AssociateNetworkAclResponse
func (client *Client) AssociateNetworkAclWithOptions(request *AssociateNetworkAclRequest, runtime *dara.RuntimeOptions) (_result *AssociateNetworkAclResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.NetworkAclId) {
		query["NetworkAclId"] = request.NetworkAclId
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.Resource) {
		query["Resource"] = request.Resource
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("AssociateNetworkAcl"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &AssociateNetworkAclResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Associates a network access control list (ACL) with a vSwitch.
//
// Description:
//
// ## [](#)Description
//
//   - **AssociateNetworkAcl*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeNetworkAclAttributes](https://help.aliyun.com/document_detail/116542.html) operation to query the status of the task.
//
//   - If the network ACL is in the **BINDING*	- state, the network ACL is being associated.
//
//   - If the network ACL is in the **BINDED*	- state, the network ACL is associated.
//
//   - You cannot repeatedly call the **AssociateNetworkAcl*	- operation to associate a network ACL within the specified period of time.
//
// @param request - AssociateNetworkAclRequest
//
// @return AssociateNetworkAclResponse
func (client *Client) AssociateNetworkAcl(request *AssociateNetworkAclRequest) (_result *AssociateNetworkAclResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &AssociateNetworkAclResponse{}
	_body, _err := client.AssociateNetworkAclWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Associates a virtual border router (VBR) with a specified Express Connect circuit.
//
// @param request - AssociatePhysicalConnectionToVirtualBorderRouterRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return AssociatePhysicalConnectionToVirtualBorderRouterResponse
func (client *Client) AssociatePhysicalConnectionToVirtualBorderRouterWithOptions(request *AssociatePhysicalConnectionToVirtualBorderRouterRequest, runtime *dara.RuntimeOptions) (_result *AssociatePhysicalConnectionToVirtualBorderRouterResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.CircuitCode) {
		query["CircuitCode"] = request.CircuitCode
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.EnableIpv6) {
		query["EnableIpv6"] = request.EnableIpv6
	}

	if !dara.IsNil(request.LocalGatewayIp) {
		query["LocalGatewayIp"] = request.LocalGatewayIp
	}

	if !dara.IsNil(request.LocalIpv6GatewayIp) {
		query["LocalIpv6GatewayIp"] = request.LocalIpv6GatewayIp
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PeerGatewayIp) {
		query["PeerGatewayIp"] = request.PeerGatewayIp
	}

	if !dara.IsNil(request.PeerIpv6GatewayIp) {
		query["PeerIpv6GatewayIp"] = request.PeerIpv6GatewayIp
	}

	if !dara.IsNil(request.PeeringIpv6SubnetMask) {
		query["PeeringIpv6SubnetMask"] = request.PeeringIpv6SubnetMask
	}

	if !dara.IsNil(request.PeeringSubnetMask) {
		query["PeeringSubnetMask"] = request.PeeringSubnetMask
	}

	if !dara.IsNil(request.PhysicalConnectionId) {
		query["PhysicalConnectionId"] = request.PhysicalConnectionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.VbrId) {
		query["VbrId"] = request.VbrId
	}

	if !dara.IsNil(request.VlanId) {
		query["VlanId"] = request.VlanId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("AssociatePhysicalConnectionToVirtualBorderRouter"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &AssociatePhysicalConnectionToVirtualBorderRouterResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Associates a virtual border router (VBR) with a specified Express Connect circuit.
//
// @param request - AssociatePhysicalConnectionToVirtualBorderRouterRequest
//
// @return AssociatePhysicalConnectionToVirtualBorderRouterResponse
func (client *Client) AssociatePhysicalConnectionToVirtualBorderRouter(request *AssociatePhysicalConnectionToVirtualBorderRouterRequest) (_result *AssociatePhysicalConnectionToVirtualBorderRouterResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &AssociatePhysicalConnectionToVirtualBorderRouterResponse{}
	_body, _err := client.AssociatePhysicalConnectionToVirtualBorderRouterWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Associates a custom route table with a vSwitch in the same VPC.
//
// Description:
//
// *AssociateRouteTable*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVSwitchAttributes](https://help.aliyun.com/document_detail/94567.html) operation to query the status of the task:
//
//   - If the vSwitch is in the **Pending*	- state, the route table is being associated with the vSwitch.
//
//   - If the vSwitch is in the **Available*	- state, the route table is associated with the vSwitch.
//
// @param request - AssociateRouteTableRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return AssociateRouteTableResponse
func (client *Client) AssociateRouteTableWithOptions(request *AssociateRouteTableRequest, runtime *dara.RuntimeOptions) (_result *AssociateRouteTableResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.RouteTableId) {
		query["RouteTableId"] = request.RouteTableId
	}

	if !dara.IsNil(request.VSwitchId) {
		query["VSwitchId"] = request.VSwitchId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("AssociateRouteTable"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &AssociateRouteTableResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Associates a custom route table with a vSwitch in the same VPC.
//
// Description:
//
// *AssociateRouteTable*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVSwitchAttributes](https://help.aliyun.com/document_detail/94567.html) operation to query the status of the task:
//
//   - If the vSwitch is in the **Pending*	- state, the route table is being associated with the vSwitch.
//
//   - If the vSwitch is in the **Available*	- state, the route table is associated with the vSwitch.
//
// @param request - AssociateRouteTableRequest
//
// @return AssociateRouteTableResponse
func (client *Client) AssociateRouteTable(request *AssociateRouteTableRequest) (_result *AssociateRouteTableResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &AssociateRouteTableResponse{}
	_body, _err := client.AssociateRouteTableWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Associates a gateway route table with an IPv4 gateway in the same virtual private cloud (VPC).
//
// @param request - AssociateRouteTableWithGatewayRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return AssociateRouteTableWithGatewayResponse
func (client *Client) AssociateRouteTableWithGatewayWithOptions(request *AssociateRouteTableWithGatewayRequest, runtime *dara.RuntimeOptions) (_result *AssociateRouteTableWithGatewayResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.GatewayId) {
		query["GatewayId"] = request.GatewayId
	}

	if !dara.IsNil(request.GatewayType) {
		query["GatewayType"] = request.GatewayType
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.RouteTableId) {
		query["RouteTableId"] = request.RouteTableId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("AssociateRouteTableWithGateway"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &AssociateRouteTableWithGatewayResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Associates a gateway route table with an IPv4 gateway in the same virtual private cloud (VPC).
//
// @param request - AssociateRouteTableWithGatewayRequest
//
// @return AssociateRouteTableWithGatewayResponse
func (client *Client) AssociateRouteTableWithGateway(request *AssociateRouteTableWithGatewayRequest) (_result *AssociateRouteTableWithGatewayResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &AssociateRouteTableWithGatewayResponse{}
	_body, _err := client.AssociateRouteTableWithGatewayWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Associates a route table with a gateway endpoint.
//
// Description:
//
// When you call this operation, take note of the following limits:
//
//   - The gateway endpoint to be associated with the route table cannot be in one of the following states: **Creating**, **Modifying**, **Associating**, **Dissociating**, or **Deleting**.
//
//   - The route table cannot be in one of the following states: **Creating**, **Modifying**, **Associating**, **Dissociating**, or **Deleting**.
//
//   - The gateway endpoint and route table must belong to the same virtual private cloud (VPC).
//
//   - The route table cannot be shared.
//
//   - You cannot associate a gateway endpoint with a virtual border router (VBR) route table.
//
//   - You can associate a gateway endpoint with at most 20 route tables at a time.
//
//   - **AssociateRouteTablesWithVpcGatewayEndpoint*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [GetVpcGatewayEndpointAttribute](https://help.aliyun.com/document_detail/311017.html) operation to query whether a route table is associated with a gateway endpoint.
//
//   - If the **Associating*	- status is returned, the route table is being associated with the gateway endpoint.
//
//   - If the **Created*	- status is returned, the route table is associated with the gateway endpoint.
//
//   - You cannot repeatedly call the **AssociateRouteTablesWithVpcGatewayEndpoint*	- operation within a specific period of time.
//
// @param request - AssociateRouteTablesWithVpcGatewayEndpointRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return AssociateRouteTablesWithVpcGatewayEndpointResponse
func (client *Client) AssociateRouteTablesWithVpcGatewayEndpointWithOptions(request *AssociateRouteTablesWithVpcGatewayEndpointRequest, runtime *dara.RuntimeOptions) (_result *AssociateRouteTablesWithVpcGatewayEndpointResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.EndpointId) {
		query["EndpointId"] = request.EndpointId
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.RouteTableIds) {
		query["RouteTableIds"] = request.RouteTableIds
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("AssociateRouteTablesWithVpcGatewayEndpoint"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &AssociateRouteTablesWithVpcGatewayEndpointResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Associates a route table with a gateway endpoint.
//
// Description:
//
// When you call this operation, take note of the following limits:
//
//   - The gateway endpoint to be associated with the route table cannot be in one of the following states: **Creating**, **Modifying**, **Associating**, **Dissociating**, or **Deleting**.
//
//   - The route table cannot be in one of the following states: **Creating**, **Modifying**, **Associating**, **Dissociating**, or **Deleting**.
//
//   - The gateway endpoint and route table must belong to the same virtual private cloud (VPC).
//
//   - The route table cannot be shared.
//
//   - You cannot associate a gateway endpoint with a virtual border router (VBR) route table.
//
//   - You can associate a gateway endpoint with at most 20 route tables at a time.
//
//   - **AssociateRouteTablesWithVpcGatewayEndpoint*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [GetVpcGatewayEndpointAttribute](https://help.aliyun.com/document_detail/311017.html) operation to query whether a route table is associated with a gateway endpoint.
//
//   - If the **Associating*	- status is returned, the route table is being associated with the gateway endpoint.
//
//   - If the **Created*	- status is returned, the route table is associated with the gateway endpoint.
//
//   - You cannot repeatedly call the **AssociateRouteTablesWithVpcGatewayEndpoint*	- operation within a specific period of time.
//
// @param request - AssociateRouteTablesWithVpcGatewayEndpointRequest
//
// @return AssociateRouteTablesWithVpcGatewayEndpointResponse
func (client *Client) AssociateRouteTablesWithVpcGatewayEndpoint(request *AssociateRouteTablesWithVpcGatewayEndpointRequest) (_result *AssociateRouteTablesWithVpcGatewayEndpointResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &AssociateRouteTablesWithVpcGatewayEndpointResponse{}
	_body, _err := client.AssociateRouteTablesWithVpcGatewayEndpointWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Adds a secondary CIDR block to a virtual private cloud (VPC).
//
// Description:
//
// ## [](#)
//
//   - Take note of the following limits:
//
//   - Each VPC can contain up to five secondary IPv4 CIDR blocks.
//
//   - Each VPC can contain up to five secondary IPv6 CIDR blocks.
//
//   - You cannot repeatedly call the **AssociateVpcCidrBlock*	- operation to add secondary CIDR blocks to a VPC within the specified period of time.
//
// @param request - AssociateVpcCidrBlockRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return AssociateVpcCidrBlockResponse
func (client *Client) AssociateVpcCidrBlockWithOptions(request *AssociateVpcCidrBlockRequest, runtime *dara.RuntimeOptions) (_result *AssociateVpcCidrBlockResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.IPv6CidrBlock) {
		query["IPv6CidrBlock"] = request.IPv6CidrBlock
	}

	if !dara.IsNil(request.IpVersion) {
		query["IpVersion"] = request.IpVersion
	}

	if !dara.IsNil(request.IpamPoolId) {
		query["IpamPoolId"] = request.IpamPoolId
	}

	if !dara.IsNil(request.Ipv6CidrMask) {
		query["Ipv6CidrMask"] = request.Ipv6CidrMask
	}

	if !dara.IsNil(request.Ipv6Isp) {
		query["Ipv6Isp"] = request.Ipv6Isp
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.SecondaryCidrBlock) {
		query["SecondaryCidrBlock"] = request.SecondaryCidrBlock
	}

	if !dara.IsNil(request.SecondaryCidrMask) {
		query["SecondaryCidrMask"] = request.SecondaryCidrMask
	}

	if !dara.IsNil(request.VpcId) {
		query["VpcId"] = request.VpcId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("AssociateVpcCidrBlock"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &AssociateVpcCidrBlockResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Adds a secondary CIDR block to a virtual private cloud (VPC).
//
// Description:
//
// ## [](#)
//
//   - Take note of the following limits:
//
//   - Each VPC can contain up to five secondary IPv4 CIDR blocks.
//
//   - Each VPC can contain up to five secondary IPv6 CIDR blocks.
//
//   - You cannot repeatedly call the **AssociateVpcCidrBlock*	- operation to add secondary CIDR blocks to a VPC within the specified period of time.
//
// @param request - AssociateVpcCidrBlockRequest
//
// @return AssociateVpcCidrBlockResponse
func (client *Client) AssociateVpcCidrBlock(request *AssociateVpcCidrBlockRequest) (_result *AssociateVpcCidrBlockResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &AssociateVpcCidrBlockResponse{}
	_body, _err := client.AssociateVpcCidrBlockWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Associates a VPN gateway with a certificate.
//
// Description:
//
// Before you associate a VPN gateway with an SSL certificate, take note of the following items:
//
//   - You can associate only VPN gateways of the ShangMi (SM) type with SSL certificates. You need to associate a VPN gateway of the SM type with two SSL certificates, one as the encryption certificate and the other as the signature certificate.
//
//   - The SSL certificates must use the SM algorithm.
//
//   - You cannot specify one SSL certificate as both the encryption certificate and signature certificate for one VPN gateway.
//
//   - **AssociateVpnGatewayWithCertificate*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) operation to query the status of the task.
//
//   - If the VPN gateway is in the **updating*	- state, the SSL certificate is being associated.
//
//   - If the VPN gateway is in the **active*	- state, the SSL certificate is being associated.
//
//   - You cannot call **AssociateVpnGatewayWithCertificate*	- within a specific period of time.
//
// ### [](#)Prerequisites
//
// Make sure that you have two SSL certificates that use the SM algorithm in the Certificate Management Service console. For more information about SSL certificates, see [What is Certificate Management Service?](https://help.aliyun.com/document_detail/28535.html).
//
// @param request - AssociateVpnGatewayWithCertificateRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return AssociateVpnGatewayWithCertificateResponse
func (client *Client) AssociateVpnGatewayWithCertificateWithOptions(request *AssociateVpnGatewayWithCertificateRequest, runtime *dara.RuntimeOptions) (_result *AssociateVpnGatewayWithCertificateResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.CertificateId) {
		query["CertificateId"] = request.CertificateId
	}

	if !dara.IsNil(request.CertificateType) {
		query["CertificateType"] = request.CertificateType
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.VpnGatewayId) {
		query["VpnGatewayId"] = request.VpnGatewayId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("AssociateVpnGatewayWithCertificate"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &AssociateVpnGatewayWithCertificateResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Associates a VPN gateway with a certificate.
//
// Description:
//
// Before you associate a VPN gateway with an SSL certificate, take note of the following items:
//
//   - You can associate only VPN gateways of the ShangMi (SM) type with SSL certificates. You need to associate a VPN gateway of the SM type with two SSL certificates, one as the encryption certificate and the other as the signature certificate.
//
//   - The SSL certificates must use the SM algorithm.
//
//   - You cannot specify one SSL certificate as both the encryption certificate and signature certificate for one VPN gateway.
//
//   - **AssociateVpnGatewayWithCertificate*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) operation to query the status of the task.
//
//   - If the VPN gateway is in the **updating*	- state, the SSL certificate is being associated.
//
//   - If the VPN gateway is in the **active*	- state, the SSL certificate is being associated.
//
//   - You cannot call **AssociateVpnGatewayWithCertificate*	- within a specific period of time.
//
// ### [](#)Prerequisites
//
// Make sure that you have two SSL certificates that use the SM algorithm in the Certificate Management Service console. For more information about SSL certificates, see [What is Certificate Management Service?](https://help.aliyun.com/document_detail/28535.html).
//
// @param request - AssociateVpnGatewayWithCertificateRequest
//
// @return AssociateVpnGatewayWithCertificateResponse
func (client *Client) AssociateVpnGatewayWithCertificate(request *AssociateVpnGatewayWithCertificateRequest) (_result *AssociateVpnGatewayWithCertificateResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &AssociateVpnGatewayWithCertificateResponse{}
	_body, _err := client.AssociateVpnGatewayWithCertificateWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Description:
//
//	  The **AttachDhcpOptionsSetToVpc*	- operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeVpcAttribute](https://help.aliyun.com/document_detail/94565.html) operation to query the status of a DHCP options set:
//
//	    	- If the DHCP options set is in the **Pending*	- state, the DHCP options set is being associated.
//
//	    	- If the DHCP options set is in the **InUse*	- state, the DHCP options set is associated.
//
//		- You cannot repeatedly call the **AttachDhcpOptionsSetToVpc*	- operation to associate DHCP options sets with a VPC within the specified period of time.
//
// @param request - AttachDhcpOptionsSetToVpcRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return AttachDhcpOptionsSetToVpcResponse
func (client *Client) AttachDhcpOptionsSetToVpcWithOptions(request *AttachDhcpOptionsSetToVpcRequest, runtime *dara.RuntimeOptions) (_result *AttachDhcpOptionsSetToVpcResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DhcpOptionsSetId) {
		query["DhcpOptionsSetId"] = request.DhcpOptionsSetId
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.VpcId) {
		query["VpcId"] = request.VpcId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("AttachDhcpOptionsSetToVpc"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &AttachDhcpOptionsSetToVpcResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Description:
//
//	  The **AttachDhcpOptionsSetToVpc*	- operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeVpcAttribute](https://help.aliyun.com/document_detail/94565.html) operation to query the status of a DHCP options set:
//
//	    	- If the DHCP options set is in the **Pending*	- state, the DHCP options set is being associated.
//
//	    	- If the DHCP options set is in the **InUse*	- state, the DHCP options set is associated.
//
//		- You cannot repeatedly call the **AttachDhcpOptionsSetToVpc*	- operation to associate DHCP options sets with a VPC within the specified period of time.
//
// @param request - AttachDhcpOptionsSetToVpcRequest
//
// @return AttachDhcpOptionsSetToVpcResponse
func (client *Client) AttachDhcpOptionsSetToVpc(request *AttachDhcpOptionsSetToVpcRequest) (_result *AttachDhcpOptionsSetToVpcResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &AttachDhcpOptionsSetToVpcResponse{}
	_body, _err := client.AttachDhcpOptionsSetToVpcWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Associates a virtual border router (VBR) with a hosted connection.
//
// @param request - AttachVbrToVpconnRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return AttachVbrToVpconnResponse
func (client *Client) AttachVbrToVpconnWithOptions(request *AttachVbrToVpconnRequest, runtime *dara.RuntimeOptions) (_result *AttachVbrToVpconnResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.Token) {
		query["Token"] = request.Token
	}

	if !dara.IsNil(request.VbrId) {
		query["VbrId"] = request.VbrId
	}

	if !dara.IsNil(request.VpconnId) {
		query["VpconnId"] = request.VpconnId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("AttachVbrToVpconn"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &AttachVbrToVpconnResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Associates a virtual border router (VBR) with a hosted connection.
//
// @param request - AttachVbrToVpconnRequest
//
// @return AttachVbrToVpconnResponse
func (client *Client) AttachVbrToVpconn(request *AttachVbrToVpconnRequest) (_result *AttachVbrToVpconnResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &AttachVbrToVpconnResponse{}
	_body, _err := client.AttachVbrToVpconnWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Cancels the maximum bandwidth configured for an elastic IP address (EIP) that is associated with an Internet Shared Bandwidth instance.
//
// Description:
//
// Before you call this operation, take note of the following items:
//
//   - After this operation is performed, the maximum bandwidth of the EIP equals that of the Internet Shared Bandwidth instance.
//
//   - You cannot repeatedly call the **CancelCommonBandwidthPackageIpBandwidth*	- operation within a specific time period.
//
// @param request - CancelCommonBandwidthPackageIpBandwidthRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CancelCommonBandwidthPackageIpBandwidthResponse
func (client *Client) CancelCommonBandwidthPackageIpBandwidthWithOptions(request *CancelCommonBandwidthPackageIpBandwidthRequest, runtime *dara.RuntimeOptions) (_result *CancelCommonBandwidthPackageIpBandwidthResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.BandwidthPackageId) {
		query["BandwidthPackageId"] = request.BandwidthPackageId
	}

	if !dara.IsNil(request.EipId) {
		query["EipId"] = request.EipId
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CancelCommonBandwidthPackageIpBandwidth"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &CancelCommonBandwidthPackageIpBandwidthResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Cancels the maximum bandwidth configured for an elastic IP address (EIP) that is associated with an Internet Shared Bandwidth instance.
//
// Description:
//
// Before you call this operation, take note of the following items:
//
//   - After this operation is performed, the maximum bandwidth of the EIP equals that of the Internet Shared Bandwidth instance.
//
//   - You cannot repeatedly call the **CancelCommonBandwidthPackageIpBandwidth*	- operation within a specific time period.
//
// @param request - CancelCommonBandwidthPackageIpBandwidthRequest
//
// @return CancelCommonBandwidthPackageIpBandwidthResponse
func (client *Client) CancelCommonBandwidthPackageIpBandwidth(request *CancelCommonBandwidthPackageIpBandwidthRequest) (_result *CancelCommonBandwidthPackageIpBandwidthResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &CancelCommonBandwidthPackageIpBandwidthResponse{}
	_body, _err := client.CancelCommonBandwidthPackageIpBandwidthWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Cancels an Express Connect circuit before it is enabled. After you perform this operation, the Express Connect circuit enters the Canceled state.
//
// Description:
//
// You can cancel only an Express Connect circuit that is in the **Initial**, **Approved**, **Allocated**, or **Confirmed*	- state.
//
// @param request - CancelPhysicalConnectionRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CancelPhysicalConnectionResponse
func (client *Client) CancelPhysicalConnectionWithOptions(request *CancelPhysicalConnectionRequest, runtime *dara.RuntimeOptions) (_result *CancelPhysicalConnectionResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PhysicalConnectionId) {
		query["PhysicalConnectionId"] = request.PhysicalConnectionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CancelPhysicalConnection"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &CancelPhysicalConnectionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Cancels an Express Connect circuit before it is enabled. After you perform this operation, the Express Connect circuit enters the Canceled state.
//
// Description:
//
// You can cancel only an Express Connect circuit that is in the **Initial**, **Approved**, **Allocated**, or **Confirmed*	- state.
//
// @param request - CancelPhysicalConnectionRequest
//
// @return CancelPhysicalConnectionResponse
func (client *Client) CancelPhysicalConnection(request *CancelPhysicalConnectionRequest) (_result *CancelPhysicalConnectionResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &CancelPhysicalConnectionResponse{}
	_body, _err := client.CancelPhysicalConnectionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Moves an Express Connect circuit to a new resource group.
//
// Description:
//
// ## [](#)
//
// You cannot repeatedly call the **ChangeResourceGroup*	- operation to modify the resource group of the same Express Connect circuit.
//
// @param request - ChangeResourceGroupRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ChangeResourceGroupResponse
func (client *Client) ChangeResourceGroupWithOptions(request *ChangeResourceGroupRequest, runtime *dara.RuntimeOptions) (_result *ChangeResourceGroupResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.NewResourceGroupId) {
		query["NewResourceGroupId"] = request.NewResourceGroupId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceId) {
		query["ResourceId"] = request.ResourceId
	}

	if !dara.IsNil(request.ResourceType) {
		query["ResourceType"] = request.ResourceType
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ChangeResourceGroup"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ChangeResourceGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Moves an Express Connect circuit to a new resource group.
//
// Description:
//
// ## [](#)
//
// You cannot repeatedly call the **ChangeResourceGroup*	- operation to modify the resource group of the same Express Connect circuit.
//
// @param request - ChangeResourceGroupRequest
//
// @return ChangeResourceGroupResponse
func (client *Client) ChangeResourceGroup(request *ChangeResourceGroupRequest) (_result *ChangeResourceGroupResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ChangeResourceGroupResponse{}
	_body, _err := client.ChangeResourceGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Checks whether a private IP address in a specified vSwitch is available.
//
// @param request - CheckCanAllocateVpcPrivateIpAddressRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CheckCanAllocateVpcPrivateIpAddressResponse
func (client *Client) CheckCanAllocateVpcPrivateIpAddressWithOptions(request *CheckCanAllocateVpcPrivateIpAddressRequest, runtime *dara.RuntimeOptions) (_result *CheckCanAllocateVpcPrivateIpAddressResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.IpVersion) {
		query["IpVersion"] = request.IpVersion
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PrivateIpAddress) {
		query["PrivateIpAddress"] = request.PrivateIpAddress
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.VSwitchId) {
		query["VSwitchId"] = request.VSwitchId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CheckCanAllocateVpcPrivateIpAddress"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &CheckCanAllocateVpcPrivateIpAddressResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Checks whether a private IP address in a specified vSwitch is available.
//
// @param request - CheckCanAllocateVpcPrivateIpAddressRequest
//
// @return CheckCanAllocateVpcPrivateIpAddressResponse
func (client *Client) CheckCanAllocateVpcPrivateIpAddress(request *CheckCanAllocateVpcPrivateIpAddressRequest) (_result *CheckCanAllocateVpcPrivateIpAddressResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &CheckCanAllocateVpcPrivateIpAddressResponse{}
	_body, _err := client.CheckCanAllocateVpcPrivateIpAddressWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Checks whether the region of an IPsec-VPN connection supports BGP.
//
// @param request - CheckVpnBgpEnabledRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CheckVpnBgpEnabledResponse
func (client *Client) CheckVpnBgpEnabledWithOptions(request *CheckVpnBgpEnabledRequest, runtime *dara.RuntimeOptions) (_result *CheckVpnBgpEnabledResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CheckVpnBgpEnabled"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &CheckVpnBgpEnabledResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Checks whether the region of an IPsec-VPN connection supports BGP.
//
// @param request - CheckVpnBgpEnabledRequest
//
// @return CheckVpnBgpEnabledResponse
func (client *Client) CheckVpnBgpEnabled(request *CheckVpnBgpEnabledRequest) (_result *CheckVpnBgpEnabledResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &CheckVpnBgpEnabledResponse{}
	_body, _err := client.CheckVpnBgpEnabledWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Generates a report for an installed Express Connect circuit.
//
// @param request - CompletePhysicalConnectionLOARequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CompletePhysicalConnectionLOAResponse
func (client *Client) CompletePhysicalConnectionLOAWithOptions(request *CompletePhysicalConnectionLOARequest, runtime *dara.RuntimeOptions) (_result *CompletePhysicalConnectionLOAResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.FinishWork) {
		query["FinishWork"] = request.FinishWork
	}

	if !dara.IsNil(request.InstanceId) {
		query["InstanceId"] = request.InstanceId
	}

	if !dara.IsNil(request.LineCode) {
		query["LineCode"] = request.LineCode
	}

	if !dara.IsNil(request.LineLabel) {
		query["LineLabel"] = request.LineLabel
	}

	if !dara.IsNil(request.LineSPContactInfo) {
		query["LineSPContactInfo"] = request.LineSPContactInfo
	}

	if !dara.IsNil(request.LineServiceProvider) {
		query["LineServiceProvider"] = request.LineServiceProvider
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CompletePhysicalConnectionLOA"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &CompletePhysicalConnectionLOAResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Generates a report for an installed Express Connect circuit.
//
// @param request - CompletePhysicalConnectionLOARequest
//
// @return CompletePhysicalConnectionLOAResponse
func (client *Client) CompletePhysicalConnectionLOA(request *CompletePhysicalConnectionLOARequest) (_result *CompletePhysicalConnectionLOAResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &CompletePhysicalConnectionLOAResponse{}
	_body, _err := client.CompletePhysicalConnectionLOAWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Changes the status of an Express Connect circuit to Confirmed.
//
// @param request - ConfirmPhysicalConnectionRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ConfirmPhysicalConnectionResponse
func (client *Client) ConfirmPhysicalConnectionWithOptions(request *ConfirmPhysicalConnectionRequest, runtime *dara.RuntimeOptions) (_result *ConfirmPhysicalConnectionResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PhysicalConnectionId) {
		query["PhysicalConnectionId"] = request.PhysicalConnectionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ConfirmPhysicalConnection"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ConfirmPhysicalConnectionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Changes the status of an Express Connect circuit to Confirmed.
//
// @param request - ConfirmPhysicalConnectionRequest
//
// @return ConfirmPhysicalConnectionResponse
func (client *Client) ConfirmPhysicalConnection(request *ConfirmPhysicalConnectionRequest) (_result *ConfirmPhysicalConnectionResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ConfirmPhysicalConnectionResponse{}
	_body, _err := client.ConfirmPhysicalConnectionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Initiates a connection from the router interface of an initiator to the router interface of an accepter.
//
// Description:
//
// After you call this operation, the router interface enters the **Connecting*	- state. When the connection is established, it enters the **Active*	- state.
//
// When you call this operation, take note of the following items:
//
//   - Only an initiator router interface in the **Idle*	- state can initiate a connection.
//
//   - You can create only one pair of connected router interfaces between two routers.
//
//   - You cannot initiate a connection if your Alibaba Cloud account has a router interface with overdue payments.
//
// @param request - ConnectRouterInterfaceRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ConnectRouterInterfaceResponse
func (client *Client) ConnectRouterInterfaceWithOptions(request *ConnectRouterInterfaceRequest, runtime *dara.RuntimeOptions) (_result *ConnectRouterInterfaceResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.RouterInterfaceId) {
		query["RouterInterfaceId"] = request.RouterInterfaceId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ConnectRouterInterface"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ConnectRouterInterfaceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Initiates a connection from the router interface of an initiator to the router interface of an accepter.
//
// Description:
//
// After you call this operation, the router interface enters the **Connecting*	- state. When the connection is established, it enters the **Active*	- state.
//
// When you call this operation, take note of the following items:
//
//   - Only an initiator router interface in the **Idle*	- state can initiate a connection.
//
//   - You can create only one pair of connected router interfaces between two routers.
//
//   - You cannot initiate a connection if your Alibaba Cloud account has a router interface with overdue payments.
//
// @param request - ConnectRouterInterfaceRequest
//
// @return ConnectRouterInterfaceResponse
func (client *Client) ConnectRouterInterface(request *ConnectRouterInterfaceRequest) (_result *ConnectRouterInterfaceResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ConnectRouterInterfaceResponse{}
	_body, _err := client.ConnectRouterInterfaceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Deprecated: OpenAPI ConvertBandwidthPackage is deprecated
//
// Summary:
//
// Converts a NAT service plan to an Internet Shared Bandwidth instance.
//
// Description:
//
// Before you convert a NAT service plan to an Internet Shared Bandwidth instance, take note of the following limits:
//
//   - You are not charged for the conversion.
//
//   - When you convert a NAT service plan to an Internet Shared Bandwidth instance, you can continue to use the SNAT and DNAT features of the NAT gateway, and your workloads are not affected. However, we recommend that you convert your NAT service plan during off-peak hours.
//
//   - After the NAT service plan is converted to an Internet Shared Bandwidth instance, the public IP addresses in the NAT service plan are converted to elastic IP addresses (EIPs). The maximum bandwidth and billing method of the Internet Shared Bandwidth instance are the same as those of the NAT service plan.
//
// @param request - ConvertBandwidthPackageRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ConvertBandwidthPackageResponse
func (client *Client) ConvertBandwidthPackageWithOptions(request *ConvertBandwidthPackageRequest, runtime *dara.RuntimeOptions) (_result *ConvertBandwidthPackageResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.BandwidthPackageId) {
		query["BandwidthPackageId"] = request.BandwidthPackageId
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ConvertBandwidthPackage"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ConvertBandwidthPackageResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Deprecated: OpenAPI ConvertBandwidthPackage is deprecated
//
// Summary:
//
// Converts a NAT service plan to an Internet Shared Bandwidth instance.
//
// Description:
//
// Before you convert a NAT service plan to an Internet Shared Bandwidth instance, take note of the following limits:
//
//   - You are not charged for the conversion.
//
//   - When you convert a NAT service plan to an Internet Shared Bandwidth instance, you can continue to use the SNAT and DNAT features of the NAT gateway, and your workloads are not affected. However, we recommend that you convert your NAT service plan during off-peak hours.
//
//   - After the NAT service plan is converted to an Internet Shared Bandwidth instance, the public IP addresses in the NAT service plan are converted to elastic IP addresses (EIPs). The maximum bandwidth and billing method of the Internet Shared Bandwidth instance are the same as those of the NAT service plan.
//
// @param request - ConvertBandwidthPackageRequest
//
// @return ConvertBandwidthPackageResponse
// Deprecated
func (client *Client) ConvertBandwidthPackage(request *ConvertBandwidthPackageRequest) (_result *ConvertBandwidthPackageResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ConvertBandwidthPackageResponse{}
	_body, _err := client.ConvertBandwidthPackageWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Copies rules of a network access control list (ACL).
//
// Description:
//
// ## [](#)Description
//
//   - **CopyNetworkAclEntries*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeNetworkAclAttributes](https://help.aliyun.com/document_detail/116542.html) operation to query the status of the task.
//
//   - If the network ACL is in the **Modifying*	- state, the rules of the network ACL are being copied.
//
//   - If the network ACL is in the **Available*	- state, the rules of the network ACL are copied.
//
//   - You cannot repeatedly call the **CopyNetworkAclEntries*	- operation within the specified period of time.
//
// @param request - CopyNetworkAclEntriesRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CopyNetworkAclEntriesResponse
func (client *Client) CopyNetworkAclEntriesWithOptions(request *CopyNetworkAclEntriesRequest, runtime *dara.RuntimeOptions) (_result *CopyNetworkAclEntriesResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.NetworkAclId) {
		query["NetworkAclId"] = request.NetworkAclId
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.SourceNetworkAclId) {
		query["SourceNetworkAclId"] = request.SourceNetworkAclId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CopyNetworkAclEntries"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &CopyNetworkAclEntriesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Copies rules of a network access control list (ACL).
//
// Description:
//
// ## [](#)Description
//
//   - **CopyNetworkAclEntries*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeNetworkAclAttributes](https://help.aliyun.com/document_detail/116542.html) operation to query the status of the task.
//
//   - If the network ACL is in the **Modifying*	- state, the rules of the network ACL are being copied.
//
//   - If the network ACL is in the **Available*	- state, the rules of the network ACL are copied.
//
//   - You cannot repeatedly call the **CopyNetworkAclEntries*	- operation within the specified period of time.
//
// @param request - CopyNetworkAclEntriesRequest
//
// @return CopyNetworkAclEntriesResponse
func (client *Client) CopyNetworkAclEntries(request *CopyNetworkAclEntriesRequest) (_result *CopyNetworkAclEntriesResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &CopyNetworkAclEntriesResponse{}
	_body, _err := client.CopyNetworkAclEntriesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates a BGP group for a virtual border router (VBR).
//
// Description:
//
// You can connect a VBR to a data center through BGP. Each BGP group is associated with a VBR. You can add a BGP peer that needs to communicate with a VBR to a BGP group and advertise the BGP network in the VBR.
//
// BGP groups are used to simplify BGP configurations. You can add BGP peers that use the same configurations to one BGP group. Before you start, you must create a BGP group with the requested autonomous system number (ASN).
//
// When you call this operation, take note of the following limits:
//
//   - You can specify only the data center that is connected to the VBR through an Express Connect circuit as a BGP peer.
//
//   - VBRs support only BGP-4.
//
//   - You can create at most eight BGP peers for each VBR.
//
//   - Each BGP peer supports at most 110 dynamic routes.
//
//   - The ASN of Alibaba Cloud is 45104. You can specify a 2-byte or 4-byte ASN for the data center.
//
// @param request - CreateBgpGroupRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateBgpGroupResponse
func (client *Client) CreateBgpGroupWithOptions(request *CreateBgpGroupRequest, runtime *dara.RuntimeOptions) (_result *CreateBgpGroupResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.AuthKey) {
		query["AuthKey"] = request.AuthKey
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.Description) {
		query["Description"] = request.Description
	}

	if !dara.IsNil(request.IpVersion) {
		query["IpVersion"] = request.IpVersion
	}

	if !dara.IsNil(request.IsFakeAsn) {
		query["IsFakeAsn"] = request.IsFakeAsn
	}

	if !dara.IsNil(request.LocalAsn) {
		query["LocalAsn"] = request.LocalAsn
	}

	if !dara.IsNil(request.Name) {
		query["Name"] = request.Name
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PeerAsn) {
		query["PeerAsn"] = request.PeerAsn
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.RouteQuota) {
		query["RouteQuota"] = request.RouteQuota
	}

	if !dara.IsNil(request.RouterId) {
		query["RouterId"] = request.RouterId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CreateBgpGroup"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &CreateBgpGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Creates a BGP group for a virtual border router (VBR).
//
// Description:
//
// You can connect a VBR to a data center through BGP. Each BGP group is associated with a VBR. You can add a BGP peer that needs to communicate with a VBR to a BGP group and advertise the BGP network in the VBR.
//
// BGP groups are used to simplify BGP configurations. You can add BGP peers that use the same configurations to one BGP group. Before you start, you must create a BGP group with the requested autonomous system number (ASN).
//
// When you call this operation, take note of the following limits:
//
//   - You can specify only the data center that is connected to the VBR through an Express Connect circuit as a BGP peer.
//
//   - VBRs support only BGP-4.
//
//   - You can create at most eight BGP peers for each VBR.
//
//   - Each BGP peer supports at most 110 dynamic routes.
//
//   - The ASN of Alibaba Cloud is 45104. You can specify a 2-byte or 4-byte ASN for the data center.
//
// @param request - CreateBgpGroupRequest
//
// @return CreateBgpGroupResponse
func (client *Client) CreateBgpGroup(request *CreateBgpGroupRequest) (_result *CreateBgpGroupResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &CreateBgpGroupResponse{}
	_body, _err := client.CreateBgpGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Adds a Border Gateway Protocol (BGP) peer to a BGP group.
//
// @param request - CreateBgpPeerRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateBgpPeerResponse
func (client *Client) CreateBgpPeerWithOptions(request *CreateBgpPeerRequest, runtime *dara.RuntimeOptions) (_result *CreateBgpPeerResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.BfdMultiHop) {
		query["BfdMultiHop"] = request.BfdMultiHop
	}

	if !dara.IsNil(request.BgpGroupId) {
		query["BgpGroupId"] = request.BgpGroupId
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.EnableBfd) {
		query["EnableBfd"] = request.EnableBfd
	}

	if !dara.IsNil(request.IpVersion) {
		query["IpVersion"] = request.IpVersion
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PeerIpAddress) {
		query["PeerIpAddress"] = request.PeerIpAddress
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CreateBgpPeer"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &CreateBgpPeerResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Adds a Border Gateway Protocol (BGP) peer to a BGP group.
//
// @param request - CreateBgpPeerRequest
//
// @return CreateBgpPeerResponse
func (client *Client) CreateBgpPeer(request *CreateBgpPeerRequest) (_result *CreateBgpPeerResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &CreateBgpPeerResponse{}
	_body, _err := client.CreateBgpPeerWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates an Internet Shared Bandwidth instance.
//
// @param request - CreateCommonBandwidthPackageRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateCommonBandwidthPackageResponse
func (client *Client) CreateCommonBandwidthPackageWithOptions(request *CreateCommonBandwidthPackageRequest, runtime *dara.RuntimeOptions) (_result *CreateCommonBandwidthPackageResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.Bandwidth) {
		query["Bandwidth"] = request.Bandwidth
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.Description) {
		query["Description"] = request.Description
	}

	if !dara.IsNil(request.ISP) {
		query["ISP"] = request.ISP
	}

	if !dara.IsNil(request.InternetChargeType) {
		query["InternetChargeType"] = request.InternetChargeType
	}

	if !dara.IsNil(request.Name) {
		query["Name"] = request.Name
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.Ratio) {
		query["Ratio"] = request.Ratio
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceGroupId) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.SecurityProtectionTypes) {
		query["SecurityProtectionTypes"] = request.SecurityProtectionTypes
	}

	if !dara.IsNil(request.Tag) {
		query["Tag"] = request.Tag
	}

	if !dara.IsNil(request.Zone) {
		query["Zone"] = request.Zone
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CreateCommonBandwidthPackage"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &CreateCommonBandwidthPackageResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Creates an Internet Shared Bandwidth instance.
//
// @param request - CreateCommonBandwidthPackageRequest
//
// @return CreateCommonBandwidthPackageResponse
func (client *Client) CreateCommonBandwidthPackage(request *CreateCommonBandwidthPackageRequest) (_result *CreateCommonBandwidthPackageResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &CreateCommonBandwidthPackageResponse{}
	_body, _err := client.CreateCommonBandwidthPackageWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates a customer gateway.
//
// @param request - CreateCustomerGatewayRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateCustomerGatewayResponse
func (client *Client) CreateCustomerGatewayWithOptions(request *CreateCustomerGatewayRequest, runtime *dara.RuntimeOptions) (_result *CreateCustomerGatewayResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.Asn) {
		query["Asn"] = request.Asn
	}

	if !dara.IsNil(request.AuthKey) {
		query["AuthKey"] = request.AuthKey
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.Description) {
		query["Description"] = request.Description
	}

	if !dara.IsNil(request.IpAddress) {
		query["IpAddress"] = request.IpAddress
	}

	if !dara.IsNil(request.Name) {
		query["Name"] = request.Name
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceGroupId) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.Tags) {
		query["Tags"] = request.Tags
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CreateCustomerGateway"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &CreateCustomerGatewayResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Creates a customer gateway.
//
// @param request - CreateCustomerGatewayRequest
//
// @return CreateCustomerGatewayResponse
func (client *Client) CreateCustomerGateway(request *CreateCustomerGatewayRequest) (_result *CreateCustomerGatewayResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &CreateCustomerGatewayResponse{}
	_body, _err := client.CreateCustomerGatewayWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates a default vSwitch.
//
// Description:
//
// When you call this operation, take note of the following limits:
//
//   - The first IP address and last three IP addresses of a vSwitch CIDR block are reserved. For example, if the CIDR block of a vSwitch is 192.168.1.0/24, the IP addresses 192.168.1.0, 192.168.1.253, 192.168.1.254, and 192.168.1.255 are reserved.
//
//   - The number of instances in the default vSwitch cannot exceed the remaining number of instances supported by the VPC (15,000 minus the number of existing instances).
//
//   - Default vSwitches do not support multicasting or broadcasting.
//
//   - After you create a default vSwitch, you cannot modify its CIDR block.
//
//   - **CreateDefaultVSwitch*	- is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeVSwitchAttributes](https://help.aliyun.com/document_detail/94567.html) operation to query the status of a default vSwitch:
//
//   - If a default vSwitch is in the **Pending*	- state, it is being configured.
//
//   - If a default vSwitch is in the **Available*	- state, it is available.
//
//   - If a default vSwitch already exists in a region, you cannot call this operation to create a default vSwitch in this region.
//
//   - Before you create a default vSwitch, make sure that a default VPC is created. You can call the [CreateDefaultVpc](https://help.aliyun.com/document_detail/609152.html) operation to create a default VPC.
//
// @param request - CreateDefaultVSwitchRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateDefaultVSwitchResponse
func (client *Client) CreateDefaultVSwitchWithOptions(request *CreateDefaultVSwitchRequest, runtime *dara.RuntimeOptions) (_result *CreateDefaultVSwitchResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.Ipv6CidrBlock) {
		query["Ipv6CidrBlock"] = request.Ipv6CidrBlock
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.ZoneId) {
		query["ZoneId"] = request.ZoneId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CreateDefaultVSwitch"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &CreateDefaultVSwitchResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Creates a default vSwitch.
//
// Description:
//
// When you call this operation, take note of the following limits:
//
//   - The first IP address and last three IP addresses of a vSwitch CIDR block are reserved. For example, if the CIDR block of a vSwitch is 192.168.1.0/24, the IP addresses 192.168.1.0, 192.168.1.253, 192.168.1.254, and 192.168.1.255 are reserved.
//
//   - The number of instances in the default vSwitch cannot exceed the remaining number of instances supported by the VPC (15,000 minus the number of existing instances).
//
//   - Default vSwitches do not support multicasting or broadcasting.
//
//   - After you create a default vSwitch, you cannot modify its CIDR block.
//
//   - **CreateDefaultVSwitch*	- is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeVSwitchAttributes](https://help.aliyun.com/document_detail/94567.html) operation to query the status of a default vSwitch:
//
//   - If a default vSwitch is in the **Pending*	- state, it is being configured.
//
//   - If a default vSwitch is in the **Available*	- state, it is available.
//
//   - If a default vSwitch already exists in a region, you cannot call this operation to create a default vSwitch in this region.
//
//   - Before you create a default vSwitch, make sure that a default VPC is created. You can call the [CreateDefaultVpc](https://help.aliyun.com/document_detail/609152.html) operation to create a default VPC.
//
// @param request - CreateDefaultVSwitchRequest
//
// @return CreateDefaultVSwitchResponse
func (client *Client) CreateDefaultVSwitch(request *CreateDefaultVSwitchRequest) (_result *CreateDefaultVSwitchResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &CreateDefaultVSwitchResponse{}
	_body, _err := client.CreateDefaultVSwitchWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates a default virtual private cloud (VPC).
//
// Description:
//
// ## Usage notes
//
// When you call this operation, take note of the following items:
//
//   - After you create a default VPC, you cannot change its CIDR block. However, you can add secondary IPv4 CIDR blocks to it.
//
//   - In each default VPC, cloud services can use a maximum of 60,000 private IP addresses. You cannot increase the quota.
//
//   - After you create a default VPC, a vRouter and a route table are automatically created for the VPC.
//
//   - At most three user CIDR blocks can be added to a VPC. If a user CIDR block includes another user CIDR block, the one with the shorter subnet mask takes effect. For example, if 10.0.0.0/8 and 10.1.0.0/16 are specified, only 10.0.0.0/8 takes effect.
//
//   - **CreateDefaultVpc*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpcAttribute](https://help.aliyun.com/document_detail/94565.html) operation to query the status of the task:
//
//   - If the default VPC is in the **Pending*	- state, the VPC is being configured.
//
//   - If the default VPC is in the **Available*	- state, the VPC is available.
//
//   - You cannot repeatedly call the **CreateDefaultVpc*	- operation within a specific time period.
//
//   - You can create only one default VPC in each region.
//
// @param request - CreateDefaultVpcRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateDefaultVpcResponse
func (client *Client) CreateDefaultVpcWithOptions(request *CreateDefaultVpcRequest, runtime *dara.RuntimeOptions) (_result *CreateDefaultVpcResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.EnableIpv6) {
		query["EnableIpv6"] = request.EnableIpv6
	}

	if !dara.IsNil(request.Ipv6CidrBlock) {
		query["Ipv6CidrBlock"] = request.Ipv6CidrBlock
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceGroupId) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CreateDefaultVpc"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &CreateDefaultVpcResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Creates a default virtual private cloud (VPC).
//
// Description:
//
// ## Usage notes
//
// When you call this operation, take note of the following items:
//
//   - After you create a default VPC, you cannot change its CIDR block. However, you can add secondary IPv4 CIDR blocks to it.
//
//   - In each default VPC, cloud services can use a maximum of 60,000 private IP addresses. You cannot increase the quota.
//
//   - After you create a default VPC, a vRouter and a route table are automatically created for the VPC.
//
//   - At most three user CIDR blocks can be added to a VPC. If a user CIDR block includes another user CIDR block, the one with the shorter subnet mask takes effect. For example, if 10.0.0.0/8 and 10.1.0.0/16 are specified, only 10.0.0.0/8 takes effect.
//
//   - **CreateDefaultVpc*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpcAttribute](https://help.aliyun.com/document_detail/94565.html) operation to query the status of the task:
//
//   - If the default VPC is in the **Pending*	- state, the VPC is being configured.
//
//   - If the default VPC is in the **Available*	- state, the VPC is available.
//
//   - You cannot repeatedly call the **CreateDefaultVpc*	- operation within a specific time period.
//
//   - You can create only one default VPC in each region.
//
// @param request - CreateDefaultVpcRequest
//
// @return CreateDefaultVpcResponse
func (client *Client) CreateDefaultVpc(request *CreateDefaultVpcRequest) (_result *CreateDefaultVpcResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &CreateDefaultVpcResponse{}
	_body, _err := client.CreateDefaultVpcWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates a DHCP options set.
//
// Description:
//
//	**CreateDhcpOptionsSet*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [GetDhcpOptionsSet](https://help.aliyun.com/document_detail/448820.html) to query the status of the task.
//
//	  	- If the vSwitch is in the **Pending*	- state, the DHCP options set is being configured.
//
//	  	- If the vSwitch is in the **Available*	- state, the DHCP options set is available.
//
// @param request - CreateDhcpOptionsSetRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateDhcpOptionsSetResponse
func (client *Client) CreateDhcpOptionsSetWithOptions(request *CreateDhcpOptionsSetRequest, runtime *dara.RuntimeOptions) (_result *CreateDhcpOptionsSetResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DhcpOptionsSetDescription) {
		query["DhcpOptionsSetDescription"] = request.DhcpOptionsSetDescription
	}

	if !dara.IsNil(request.DhcpOptionsSetName) {
		query["DhcpOptionsSetName"] = request.DhcpOptionsSetName
	}

	if !dara.IsNil(request.DomainName) {
		query["DomainName"] = request.DomainName
	}

	if !dara.IsNil(request.DomainNameServers) {
		query["DomainNameServers"] = request.DomainNameServers
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.Ipv6LeaseTime) {
		query["Ipv6LeaseTime"] = request.Ipv6LeaseTime
	}

	if !dara.IsNil(request.LeaseTime) {
		query["LeaseTime"] = request.LeaseTime
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceGroupId) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.Tag) {
		query["Tag"] = request.Tag
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CreateDhcpOptionsSet"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &CreateDhcpOptionsSetResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Creates a DHCP options set.
//
// Description:
//
//	**CreateDhcpOptionsSet*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [GetDhcpOptionsSet](https://help.aliyun.com/document_detail/448820.html) to query the status of the task.
//
//	  	- If the vSwitch is in the **Pending*	- state, the DHCP options set is being configured.
//
//	  	- If the vSwitch is in the **Available*	- state, the DHCP options set is available.
//
// @param request - CreateDhcpOptionsSetRequest
//
// @return CreateDhcpOptionsSetResponse
func (client *Client) CreateDhcpOptionsSet(request *CreateDhcpOptionsSetRequest) (_result *CreateDhcpOptionsSetResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &CreateDhcpOptionsSetResponse{}
	_body, _err := client.CreateDhcpOptionsSetWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates an Express Cloud Connect (ECC) instance.
//
// @param request - CreateExpressCloudConnectionRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateExpressCloudConnectionResponse
func (client *Client) CreateExpressCloudConnectionWithOptions(request *CreateExpressCloudConnectionRequest, runtime *dara.RuntimeOptions) (_result *CreateExpressCloudConnectionResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.Bandwidth) {
		query["Bandwidth"] = request.Bandwidth
	}

	if !dara.IsNil(request.ContactMail) {
		query["ContactMail"] = request.ContactMail
	}

	if !dara.IsNil(request.ContactTel) {
		query["ContactTel"] = request.ContactTel
	}

	if !dara.IsNil(request.Description) {
		query["Description"] = request.Description
	}

	if !dara.IsNil(request.IDCardNo) {
		query["IDCardNo"] = request.IDCardNo
	}

	if !dara.IsNil(request.IdcSP) {
		query["IdcSP"] = request.IdcSP
	}

	if !dara.IsNil(request.Name) {
		query["Name"] = request.Name
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PeerCity) {
		query["PeerCity"] = request.PeerCity
	}

	if !dara.IsNil(request.PeerLocation) {
		query["PeerLocation"] = request.PeerLocation
	}

	if !dara.IsNil(request.PortType) {
		query["PortType"] = request.PortType
	}

	if !dara.IsNil(request.RedundantEccId) {
		query["RedundantEccId"] = request.RedundantEccId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CreateExpressCloudConnection"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &CreateExpressCloudConnectionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Creates an Express Cloud Connect (ECC) instance.
//
// @param request - CreateExpressCloudConnectionRequest
//
// @return CreateExpressCloudConnectionResponse
func (client *Client) CreateExpressCloudConnection(request *CreateExpressCloudConnectionRequest) (_result *CreateExpressCloudConnectionResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &CreateExpressCloudConnectionResponse{}
	_body, _err := client.CreateExpressCloudConnectionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates a quality of service (QoS) policy.
//
// @param request - CreateExpressConnectTrafficQosRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateExpressConnectTrafficQosResponse
func (client *Client) CreateExpressConnectTrafficQosWithOptions(request *CreateExpressConnectTrafficQosRequest, runtime *dara.RuntimeOptions) (_result *CreateExpressConnectTrafficQosResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.QosDescription) {
		query["QosDescription"] = request.QosDescription
	}

	if !dara.IsNil(request.QosName) {
		query["QosName"] = request.QosName
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceGroupId) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.Tags) {
		query["Tags"] = request.Tags
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CreateExpressConnectTrafficQos"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &CreateExpressConnectTrafficQosResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Creates a quality of service (QoS) policy.
//
// @param request - CreateExpressConnectTrafficQosRequest
//
// @return CreateExpressConnectTrafficQosResponse
func (client *Client) CreateExpressConnectTrafficQos(request *CreateExpressConnectTrafficQosRequest) (_result *CreateExpressConnectTrafficQosResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &CreateExpressConnectTrafficQosResponse{}
	_body, _err := client.CreateExpressConnectTrafficQosWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates a quality of service (QoS) queue.
//
// @param request - CreateExpressConnectTrafficQosQueueRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateExpressConnectTrafficQosQueueResponse
func (client *Client) CreateExpressConnectTrafficQosQueueWithOptions(request *CreateExpressConnectTrafficQosQueueRequest, runtime *dara.RuntimeOptions) (_result *CreateExpressConnectTrafficQosQueueResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.BandwidthPercent) {
		query["BandwidthPercent"] = request.BandwidthPercent
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.QosId) {
		query["QosId"] = request.QosId
	}

	if !dara.IsNil(request.QueueDescription) {
		query["QueueDescription"] = request.QueueDescription
	}

	if !dara.IsNil(request.QueueName) {
		query["QueueName"] = request.QueueName
	}

	if !dara.IsNil(request.QueueType) {
		query["QueueType"] = request.QueueType
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CreateExpressConnectTrafficQosQueue"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &CreateExpressConnectTrafficQosQueueResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Creates a quality of service (QoS) queue.
//
// @param request - CreateExpressConnectTrafficQosQueueRequest
//
// @return CreateExpressConnectTrafficQosQueueResponse
func (client *Client) CreateExpressConnectTrafficQosQueue(request *CreateExpressConnectTrafficQosQueueRequest) (_result *CreateExpressConnectTrafficQosQueueResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &CreateExpressConnectTrafficQosQueueResponse{}
	_body, _err := client.CreateExpressConnectTrafficQosQueueWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates a quality of service (QoS) rule.
//
// @param request - CreateExpressConnectTrafficQosRuleRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateExpressConnectTrafficQosRuleResponse
func (client *Client) CreateExpressConnectTrafficQosRuleWithOptions(request *CreateExpressConnectTrafficQosRuleRequest, runtime *dara.RuntimeOptions) (_result *CreateExpressConnectTrafficQosRuleResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DstCidr) {
		query["DstCidr"] = request.DstCidr
	}

	if !dara.IsNil(request.DstIPv6Cidr) {
		query["DstIPv6Cidr"] = request.DstIPv6Cidr
	}

	if !dara.IsNil(request.DstPortRange) {
		query["DstPortRange"] = request.DstPortRange
	}

	if !dara.IsNil(request.MatchDscp) {
		query["MatchDscp"] = request.MatchDscp
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.Priority) {
		query["Priority"] = request.Priority
	}

	if !dara.IsNil(request.Protocol) {
		query["Protocol"] = request.Protocol
	}

	if !dara.IsNil(request.QosId) {
		query["QosId"] = request.QosId
	}

	if !dara.IsNil(request.QueueId) {
		query["QueueId"] = request.QueueId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.RemarkingDscp) {
		query["RemarkingDscp"] = request.RemarkingDscp
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.RuleDescription) {
		query["RuleDescription"] = request.RuleDescription
	}

	if !dara.IsNil(request.RuleName) {
		query["RuleName"] = request.RuleName
	}

	if !dara.IsNil(request.SrcCidr) {
		query["SrcCidr"] = request.SrcCidr
	}

	if !dara.IsNil(request.SrcIPv6Cidr) {
		query["SrcIPv6Cidr"] = request.SrcIPv6Cidr
	}

	if !dara.IsNil(request.SrcPortRange) {
		query["SrcPortRange"] = request.SrcPortRange
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CreateExpressConnectTrafficQosRule"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &CreateExpressConnectTrafficQosRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Creates a quality of service (QoS) rule.
//
// @param request - CreateExpressConnectTrafficQosRuleRequest
//
// @return CreateExpressConnectTrafficQosRuleResponse
func (client *Client) CreateExpressConnectTrafficQosRule(request *CreateExpressConnectTrafficQosRuleRequest) (_result *CreateExpressConnectTrafficQosRuleResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &CreateExpressConnectTrafficQosRuleResponse{}
	_body, _err := client.CreateExpressConnectTrafficQosRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates a failover test.
//
// Description:
//
// You cannot create a failover test in the following scenarios:
//
//   - You have created a failover test in the region and its type is StartNow.
//
//   - The Express Connect circuit or hosted connection has pending orders or overdue payments.
//
//   - A failover test is already performed on the Express Connect circuit or hosted connection.
//
//   - More than one hosted connection is created over the Express Connect circuit.
//
//   - More than one cross-account VBR is created on the Express Connect circuit.
//
//   - No VBR is associated with the hosted connection.
//
//   - The VLAN ID of the hosted connection is set to 0.
//
// @param request - CreateFailoverTestJobRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateFailoverTestJobResponse
func (client *Client) CreateFailoverTestJobWithOptions(request *CreateFailoverTestJobRequest, runtime *dara.RuntimeOptions) (_result *CreateFailoverTestJobResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.Description) {
		query["Description"] = request.Description
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.JobDuration) {
		query["JobDuration"] = request.JobDuration
	}

	if !dara.IsNil(request.JobType) {
		query["JobType"] = request.JobType
	}

	if !dara.IsNil(request.Name) {
		query["Name"] = request.Name
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceId) {
		query["ResourceId"] = request.ResourceId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceType) {
		query["ResourceType"] = request.ResourceType
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CreateFailoverTestJob"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &CreateFailoverTestJobResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Creates a failover test.
//
// Description:
//
// You cannot create a failover test in the following scenarios:
//
//   - You have created a failover test in the region and its type is StartNow.
//
//   - The Express Connect circuit or hosted connection has pending orders or overdue payments.
//
//   - A failover test is already performed on the Express Connect circuit or hosted connection.
//
//   - More than one hosted connection is created over the Express Connect circuit.
//
//   - More than one cross-account VBR is created on the Express Connect circuit.
//
//   - No VBR is associated with the hosted connection.
//
//   - The VLAN ID of the hosted connection is set to 0.
//
// @param request - CreateFailoverTestJobRequest
//
// @return CreateFailoverTestJobResponse
func (client *Client) CreateFailoverTestJob(request *CreateFailoverTestJobRequest) (_result *CreateFailoverTestJobResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &CreateFailoverTestJobResponse{}
	_body, _err := client.CreateFailoverTestJobWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates a flow log.
//
// Description:
//
// *CreateFlowLog*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeFlowLogs](https://help.aliyun.com/document_detail/87923.html) operation to query the status of the flow log.
//
//   - If the flow log is in the **Activating*	- state, the flow log is being created.
//
//   - If the flow log is in the **Active*	- state, the flow log is created and started.
//
// @param request - CreateFlowLogRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateFlowLogResponse
func (client *Client) CreateFlowLogWithOptions(request *CreateFlowLogRequest, runtime *dara.RuntimeOptions) (_result *CreateFlowLogResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.AggregationInterval) {
		query["AggregationInterval"] = request.AggregationInterval
	}

	if !dara.IsNil(request.Description) {
		query["Description"] = request.Description
	}

	if !dara.IsNil(request.FlowLogName) {
		query["FlowLogName"] = request.FlowLogName
	}

	if !dara.IsNil(request.IpVersion) {
		query["IpVersion"] = request.IpVersion
	}

	if !dara.IsNil(request.LogStoreName) {
		query["LogStoreName"] = request.LogStoreName
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.ProjectName) {
		query["ProjectName"] = request.ProjectName
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceGroupId) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !dara.IsNil(request.ResourceId) {
		query["ResourceId"] = request.ResourceId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.ResourceType) {
		query["ResourceType"] = request.ResourceType
	}

	if !dara.IsNil(request.Tag) {
		query["Tag"] = request.Tag
	}

	if !dara.IsNil(request.TrafficPath) {
		query["TrafficPath"] = request.TrafficPath
	}

	if !dara.IsNil(request.TrafficType) {
		query["TrafficType"] = request.TrafficType
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CreateFlowLog"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &CreateFlowLogResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Creates a flow log.
//
// Description:
//
// *CreateFlowLog*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeFlowLogs](https://help.aliyun.com/document_detail/87923.html) operation to query the status of the flow log.
//
//   - If the flow log is in the **Activating*	- state, the flow log is being created.
//
//   - If the flow log is in the **Active*	- state, the flow log is created and started.
//
// @param request - CreateFlowLogRequest
//
// @return CreateFlowLogResponse
func (client *Client) CreateFlowLog(request *CreateFlowLogRequest) (_result *CreateFlowLogResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &CreateFlowLogResponse{}
	_body, _err := client.CreateFlowLogWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Adds a DNAT entry to a DNAT table.
//
// Description:
//
// ## [](#)
//
// Each DNAT entry consists of the following parameters: **ExternalIp**, **ExternalPort**, **IpProtocol**, **InternalIp**, and **InternalPort**. After you add a DNAT entry, the NAT gateway forwards packets over the specified protocol from **ExternalIp:ExternalPort*	- to **InternalIp:InternalPort*	- and sends responses back through the same route.
//
// When you call this operation, take note of the following limits:
//
//   - **CreateForwardEntry*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeForwardTableEntries](https://help.aliyun.com/document_detail/36053.html) operation to query the status of the task.
//
//   - If the DNAT entry is in the **Pending*	- state, the system is adding the DNAT entry. You can only query the DNAT entry, but cannot perform other operations.
//
//   - If the DNAT entry is in the **Available*	- state, the DNAT entry is added.
//
//   - You cannot repeatedly call the **CreateForwardEntry*	- operation to add a DNAT entry within a specific period of time.
//
//   - All combinations of **ExternalIp**, **ExternalPort**, and **IpProtocol*	- used in DNAT entries must be unique. You cannot distribute requests to more than one Elastic Compute Service (ECS) instance if these requests are initiated from the same source IP address, received on the same port, and use the same protocol.
//
//   - The combinations of **IpProtocol**, **InternalIp**, and **InternalPort*	- must be unique.
//
//   - If one or more DNAT entries in the DNAT table are in the **Pending*	- or **Modifying*	- state, you cannot add DNAT entries to the DNAT table.
//
//   - You can add at most 100 DNAT entries to a DNAT table.
//
//   - For an elastic IP address (EIP) used by an Internet NAT gateway or a NAT IP address used by a Virtual Private Cloud (VPC) NAT gateway, take note of the following limit: If the IP address has IP mapping enabled and is specified in a DNAT entry, the IP address cannot be used by another DNAT or SNAT entry.
//
// @param request - CreateForwardEntryRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateForwardEntryResponse
func (client *Client) CreateForwardEntryWithOptions(request *CreateForwardEntryRequest, runtime *dara.RuntimeOptions) (_result *CreateForwardEntryResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.ExternalIp) {
		query["ExternalIp"] = request.ExternalIp
	}

	if !dara.IsNil(request.ExternalPort) {
		query["ExternalPort"] = request.ExternalPort
	}

	if !dara.IsNil(request.ForwardEntryName) {
		query["ForwardEntryName"] = request.ForwardEntryName
	}

	if !dara.IsNil(request.ForwardTableId) {
		query["ForwardTableId"] = request.ForwardTableId
	}

	if !dara.IsNil(request.InternalIp) {
		query["InternalIp"] = request.InternalIp
	}

	if !dara.IsNil(request.InternalPort) {
		query["InternalPort"] = request.InternalPort
	}

	if !dara.IsNil(request.IpProtocol) {
		query["IpProtocol"] = request.IpProtocol
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PortBreak) {
		query["PortBreak"] = request.PortBreak
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CreateForwardEntry"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &CreateForwardEntryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Adds a DNAT entry to a DNAT table.
//
// Description:
//
// ## [](#)
//
// Each DNAT entry consists of the following parameters: **ExternalIp**, **ExternalPort**, **IpProtocol**, **InternalIp**, and **InternalPort**. After you add a DNAT entry, the NAT gateway forwards packets over the specified protocol from **ExternalIp:ExternalPort*	- to **InternalIp:InternalPort*	- and sends responses back through the same route.
//
// When you call this operation, take note of the following limits:
//
//   - **CreateForwardEntry*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeForwardTableEntries](https://help.aliyun.com/document_detail/36053.html) operation to query the status of the task.
//
//   - If the DNAT entry is in the **Pending*	- state, the system is adding the DNAT entry. You can only query the DNAT entry, but cannot perform other operations.
//
//   - If the DNAT entry is in the **Available*	- state, the DNAT entry is added.
//
//   - You cannot repeatedly call the **CreateForwardEntry*	- operation to add a DNAT entry within a specific period of time.
//
//   - All combinations of **ExternalIp**, **ExternalPort**, and **IpProtocol*	- used in DNAT entries must be unique. You cannot distribute requests to more than one Elastic Compute Service (ECS) instance if these requests are initiated from the same source IP address, received on the same port, and use the same protocol.
//
//   - The combinations of **IpProtocol**, **InternalIp**, and **InternalPort*	- must be unique.
//
//   - If one or more DNAT entries in the DNAT table are in the **Pending*	- or **Modifying*	- state, you cannot add DNAT entries to the DNAT table.
//
//   - You can add at most 100 DNAT entries to a DNAT table.
//
//   - For an elastic IP address (EIP) used by an Internet NAT gateway or a NAT IP address used by a Virtual Private Cloud (VPC) NAT gateway, take note of the following limit: If the IP address has IP mapping enabled and is specified in a DNAT entry, the IP address cannot be used by another DNAT or SNAT entry.
//
// @param request - CreateForwardEntryRequest
//
// @return CreateForwardEntryResponse
func (client *Client) CreateForwardEntry(request *CreateForwardEntryRequest) (_result *CreateForwardEntryResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &CreateForwardEntryResponse{}
	_body, _err := client.CreateForwardEntryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Adds a FULLNAT entry to the FULLNAT table.
//
// Description:
//
//	  **CreateFullNatEntry*	- is an asynchronous operation. After you send a request to call this operation, the system returns a FULLNAT entry and the FULLNAT entry is being added in the backend. You can call the [ListFullNatEntries](https://help.aliyun.com/document_detail/348779.html) operation to query the status of a FULLNAT entry.
//
//	    	- If the FULLNAT entry is in the **Creating*	- state, the system is adding the FULLNAT entry. You can only query the status of the FULLNAT entry, but cannot perform other operations.
//
//	    	- If the FULLNAT entry is in the **Available*	- state, the FULLNAT entry is added.
//
//		- You cannot repeatedly call the **CreateFullNatEntry*	- operation for the same VPN gateway within the specified period of time.
//
// @param request - CreateFullNatEntryRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateFullNatEntryResponse
func (client *Client) CreateFullNatEntryWithOptions(request *CreateFullNatEntryRequest, runtime *dara.RuntimeOptions) (_result *CreateFullNatEntryResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.AccessIp) {
		query["AccessIp"] = request.AccessIp
	}

	if !dara.IsNil(request.AccessPort) {
		query["AccessPort"] = request.AccessPort
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.FullNatEntryDescription) {
		query["FullNatEntryDescription"] = request.FullNatEntryDescription
	}

	if !dara.IsNil(request.FullNatEntryName) {
		query["FullNatEntryName"] = request.FullNatEntryName
	}

	if !dara.IsNil(request.FullNatTableId) {
		query["FullNatTableId"] = request.FullNatTableId
	}

	if !dara.IsNil(request.IpProtocol) {
		query["IpProtocol"] = request.IpProtocol
	}

	if !dara.IsNil(request.NatIp) {
		query["NatIp"] = request.NatIp
	}

	if !dara.IsNil(request.NatIpPort) {
		query["NatIpPort"] = request.NatIpPort
	}

	if !dara.IsNil(request.NetworkInterfaceId) {
		query["NetworkInterfaceId"] = request.NetworkInterfaceId
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CreateFullNatEntry"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &CreateFullNatEntryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Adds a FULLNAT entry to the FULLNAT table.
//
// Description:
//
//	  **CreateFullNatEntry*	- is an asynchronous operation. After you send a request to call this operation, the system returns a FULLNAT entry and the FULLNAT entry is being added in the backend. You can call the [ListFullNatEntries](https://help.aliyun.com/document_detail/348779.html) operation to query the status of a FULLNAT entry.
//
//	    	- If the FULLNAT entry is in the **Creating*	- state, the system is adding the FULLNAT entry. You can only query the status of the FULLNAT entry, but cannot perform other operations.
//
//	    	- If the FULLNAT entry is in the **Available*	- state, the FULLNAT entry is added.
//
//		- You cannot repeatedly call the **CreateFullNatEntry*	- operation for the same VPN gateway within the specified period of time.
//
// @param request - CreateFullNatEntryRequest
//
// @return CreateFullNatEntryResponse
func (client *Client) CreateFullNatEntry(request *CreateFullNatEntryRequest) (_result *CreateFullNatEntryResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &CreateFullNatEntryResponse{}
	_body, _err := client.CreateFullNatEntryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Deprecated: OpenAPI CreateGlobalAccelerationInstance is deprecated
//
// Summary:
//
// Creates a Global Accelerator (GA) instance.
//
// Description:
//
// ## Usage notes
//
// You can call this operation to create only pay-as-you-go GA instances.
//
// @param request - CreateGlobalAccelerationInstanceRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateGlobalAccelerationInstanceResponse
func (client *Client) CreateGlobalAccelerationInstanceWithOptions(request *CreateGlobalAccelerationInstanceRequest, runtime *dara.RuntimeOptions) (_result *CreateGlobalAccelerationInstanceResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.Bandwidth) {
		query["Bandwidth"] = request.Bandwidth
	}

	if !dara.IsNil(request.BandwidthType) {
		query["BandwidthType"] = request.BandwidthType
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.Description) {
		query["Description"] = request.Description
	}

	if !dara.IsNil(request.Name) {
		query["Name"] = request.Name
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.ServiceLocation) {
		query["ServiceLocation"] = request.ServiceLocation
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CreateGlobalAccelerationInstance"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &CreateGlobalAccelerationInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Deprecated: OpenAPI CreateGlobalAccelerationInstance is deprecated
//
// Summary:
//
// Creates a Global Accelerator (GA) instance.
//
// Description:
//
// ## Usage notes
//
// You can call this operation to create only pay-as-you-go GA instances.
//
// @param request - CreateGlobalAccelerationInstanceRequest
//
// @return CreateGlobalAccelerationInstanceResponse
// Deprecated
func (client *Client) CreateGlobalAccelerationInstance(request *CreateGlobalAccelerationInstanceRequest) (_result *CreateGlobalAccelerationInstanceResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &CreateGlobalAccelerationInstanceResponse{}
	_body, _err := client.CreateGlobalAccelerationInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates a high-availability virtual IP address (HaVip).
//
// Description:
//
// *CreateHaVip*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeHaVips](https://help.aliyun.com/document_detail/114611.html) operation to query the status of the task:
//
//   - If the HaVip is in the **Creating*	- state, the HaVip is being created.
//
//   - If the HaVip is in the **Available*	- state, the HaVip is created.
//
// @param request - CreateHaVipRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateHaVipResponse
func (client *Client) CreateHaVipWithOptions(request *CreateHaVipRequest, runtime *dara.RuntimeOptions) (_result *CreateHaVipResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.Description) {
		query["Description"] = request.Description
	}

	if !dara.IsNil(request.IpAddress) {
		query["IpAddress"] = request.IpAddress
	}

	if !dara.IsNil(request.Name) {
		query["Name"] = request.Name
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceGroupId) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.Tag) {
		query["Tag"] = request.Tag
	}

	if !dara.IsNil(request.VSwitchId) {
		query["VSwitchId"] = request.VSwitchId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CreateHaVip"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &CreateHaVipResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Creates a high-availability virtual IP address (HaVip).
//
// Description:
//
// *CreateHaVip*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeHaVips](https://help.aliyun.com/document_detail/114611.html) operation to query the status of the task:
//
//   - If the HaVip is in the **Creating*	- state, the HaVip is being created.
//
//   - If the HaVip is in the **Available*	- state, the HaVip is created.
//
// @param request - CreateHaVipRequest
//
// @return CreateHaVipResponse
func (client *Client) CreateHaVip(request *CreateHaVipRequest) (_result *CreateHaVipResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &CreateHaVipResponse{}
	_body, _err := client.CreateHaVipWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates Express Connect circuits in high reliability mode. This improves the stability of multiple Express Connect circuits and prevents service interruptions caused by single points of failures (SPOFs).
//
// @param request - CreateHighReliablePhysicalConnectionRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateHighReliablePhysicalConnectionResponse
func (client *Client) CreateHighReliablePhysicalConnectionWithOptions(request *CreateHighReliablePhysicalConnectionRequest, runtime *dara.RuntimeOptions) (_result *CreateHighReliablePhysicalConnectionResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.AcceptLanguage) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !dara.IsNil(request.ApList) {
		query["ApList"] = request.ApList
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DeviceAdvancedCapacity) {
		query["DeviceAdvancedCapacity"] = request.DeviceAdvancedCapacity
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.HighReliableType) {
		query["HighReliableType"] = request.HighReliableType
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PortType) {
		query["PortType"] = request.PortType
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceGroupId) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.Tag) {
		query["Tag"] = request.Tag
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CreateHighReliablePhysicalConnection"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &CreateHighReliablePhysicalConnectionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Creates Express Connect circuits in high reliability mode. This improves the stability of multiple Express Connect circuits and prevents service interruptions caused by single points of failures (SPOFs).
//
// @param request - CreateHighReliablePhysicalConnectionRequest
//
// @return CreateHighReliablePhysicalConnectionResponse
func (client *Client) CreateHighReliablePhysicalConnection(request *CreateHighReliablePhysicalConnectionRequest) (_result *CreateHighReliablePhysicalConnectionResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &CreateHighReliablePhysicalConnectionResponse{}
	_body, _err := client.CreateHighReliablePhysicalConnectionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Deprecated: OpenAPI CreateIPv6Translator is deprecated
//
// Summary:
//
// Creates an IPv6 Translation Service instance.
//
// @param request - CreateIPv6TranslatorRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateIPv6TranslatorResponse
func (client *Client) CreateIPv6TranslatorWithOptions(request *CreateIPv6TranslatorRequest, runtime *dara.RuntimeOptions) (_result *CreateIPv6TranslatorResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.AutoPay) {
		query["AutoPay"] = request.AutoPay
	}

	if !dara.IsNil(request.Bandwidth) {
		query["Bandwidth"] = request.Bandwidth
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.Duration) {
		query["Duration"] = request.Duration
	}

	if !dara.IsNil(request.Name) {
		query["Name"] = request.Name
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PayType) {
		query["PayType"] = request.PayType
	}

	if !dara.IsNil(request.PricingCycle) {
		query["PricingCycle"] = request.PricingCycle
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.Spec) {
		query["Spec"] = request.Spec
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CreateIPv6Translator"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &CreateIPv6TranslatorResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Deprecated: OpenAPI CreateIPv6Translator is deprecated
//
// Summary:
//
// Creates an IPv6 Translation Service instance.
//
// @param request - CreateIPv6TranslatorRequest
//
// @return CreateIPv6TranslatorResponse
// Deprecated
func (client *Client) CreateIPv6Translator(request *CreateIPv6TranslatorRequest) (_result *CreateIPv6TranslatorResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &CreateIPv6TranslatorResponse{}
	_body, _err := client.CreateIPv6TranslatorWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Deprecated: OpenAPI CreateIPv6TranslatorAclList is deprecated
//
// Summary:
//
// Creates an access control list (ACL).
//
// @param request - CreateIPv6TranslatorAclListRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateIPv6TranslatorAclListResponse
func (client *Client) CreateIPv6TranslatorAclListWithOptions(request *CreateIPv6TranslatorAclListRequest, runtime *dara.RuntimeOptions) (_result *CreateIPv6TranslatorAclListResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.AclName) {
		query["AclName"] = request.AclName
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CreateIPv6TranslatorAclList"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &CreateIPv6TranslatorAclListResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Deprecated: OpenAPI CreateIPv6TranslatorAclList is deprecated
//
// Summary:
//
// Creates an access control list (ACL).
//
// @param request - CreateIPv6TranslatorAclListRequest
//
// @return CreateIPv6TranslatorAclListResponse
// Deprecated
func (client *Client) CreateIPv6TranslatorAclList(request *CreateIPv6TranslatorAclListRequest) (_result *CreateIPv6TranslatorAclListResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &CreateIPv6TranslatorAclListResponse{}
	_body, _err := client.CreateIPv6TranslatorAclListWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Deprecated: OpenAPI CreateIPv6TranslatorEntry is deprecated
//
// Summary:
//
// Adds an IPv6 mapping entry to an IPv6 Translation Service instance.
//
// @param request - CreateIPv6TranslatorEntryRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateIPv6TranslatorEntryResponse
func (client *Client) CreateIPv6TranslatorEntryWithOptions(request *CreateIPv6TranslatorEntryRequest, runtime *dara.RuntimeOptions) (_result *CreateIPv6TranslatorEntryResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.AclId) {
		query["AclId"] = request.AclId
	}

	if !dara.IsNil(request.AclStatus) {
		query["AclStatus"] = request.AclStatus
	}

	if !dara.IsNil(request.AclType) {
		query["AclType"] = request.AclType
	}

	if !dara.IsNil(request.AllocateIpv6Port) {
		query["AllocateIpv6Port"] = request.AllocateIpv6Port
	}

	if !dara.IsNil(request.BackendIpv4Addr) {
		query["BackendIpv4Addr"] = request.BackendIpv4Addr
	}

	if !dara.IsNil(request.BackendIpv4Port) {
		query["BackendIpv4Port"] = request.BackendIpv4Port
	}

	if !dara.IsNil(request.EntryBandwidth) {
		query["EntryBandwidth"] = request.EntryBandwidth
	}

	if !dara.IsNil(request.EntryDescription) {
		query["EntryDescription"] = request.EntryDescription
	}

	if !dara.IsNil(request.EntryName) {
		query["EntryName"] = request.EntryName
	}

	if !dara.IsNil(request.Ipv6TranslatorId) {
		query["Ipv6TranslatorId"] = request.Ipv6TranslatorId
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.TransProtocol) {
		query["TransProtocol"] = request.TransProtocol
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CreateIPv6TranslatorEntry"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &CreateIPv6TranslatorEntryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Deprecated: OpenAPI CreateIPv6TranslatorEntry is deprecated
//
// Summary:
//
// Adds an IPv6 mapping entry to an IPv6 Translation Service instance.
//
// @param request - CreateIPv6TranslatorEntryRequest
//
// @return CreateIPv6TranslatorEntryResponse
// Deprecated
func (client *Client) CreateIPv6TranslatorEntry(request *CreateIPv6TranslatorEntryRequest) (_result *CreateIPv6TranslatorEntryResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &CreateIPv6TranslatorEntryResponse{}
	_body, _err := client.CreateIPv6TranslatorEntryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates an IPsec server.
//
// Description:
//
//	  Before you create an IPsec server, you must create a VPN gateway and enable the SSL-VPN feature for the VPN gateway. For more information, see [CreateVpnGateway](https://help.aliyun.com/document_detail/2794049.html).
//
//		- Before you create an IPsec server, make sure that no IPsec-VPN connection exists on the VPN gateway. For more information, see [DeleteVpnConnection](https://help.aliyun.com/document_detail/2526948.html).
//
//		- **CreateIpsecServer*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) to query the status of the task.
//
//	    	- If the VPN gateway is in the **updating*	- state, the IPsec server is being created.
//
//	    	- If the VPN gateway is in the **active*	- state, the IPsec server is created.
//
//		- You cannot repeatedly call **CreateIpsecServer*	- within the specified period of time.
//
// @param request - CreateIpsecServerRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateIpsecServerResponse
func (client *Client) CreateIpsecServerWithOptions(request *CreateIpsecServerRequest, runtime *dara.RuntimeOptions) (_result *CreateIpsecServerResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientIpPool) {
		query["ClientIpPool"] = request.ClientIpPool
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.EffectImmediately) {
		query["EffectImmediately"] = request.EffectImmediately
	}

	if !dara.IsNil(request.IkeConfig) {
		query["IkeConfig"] = request.IkeConfig
	}

	if !dara.IsNil(request.IpSecServerName) {
		query["IpSecServerName"] = request.IpSecServerName
	}

	if !dara.IsNil(request.IpsecConfig) {
		query["IpsecConfig"] = request.IpsecConfig
	}

	if !dara.IsNil(request.LocalSubnet) {
		query["LocalSubnet"] = request.LocalSubnet
	}

	if !dara.IsNil(request.Psk) {
		query["Psk"] = request.Psk
	}

	if !dara.IsNil(request.PskEnabled) {
		query["PskEnabled"] = request.PskEnabled
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.VpnGatewayId) {
		query["VpnGatewayId"] = request.VpnGatewayId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CreateIpsecServer"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &CreateIpsecServerResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Creates an IPsec server.
//
// Description:
//
//	  Before you create an IPsec server, you must create a VPN gateway and enable the SSL-VPN feature for the VPN gateway. For more information, see [CreateVpnGateway](https://help.aliyun.com/document_detail/2794049.html).
//
//		- Before you create an IPsec server, make sure that no IPsec-VPN connection exists on the VPN gateway. For more information, see [DeleteVpnConnection](https://help.aliyun.com/document_detail/2526948.html).
//
//		- **CreateIpsecServer*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) to query the status of the task.
//
//	    	- If the VPN gateway is in the **updating*	- state, the IPsec server is being created.
//
//	    	- If the VPN gateway is in the **active*	- state, the IPsec server is created.
//
//		- You cannot repeatedly call **CreateIpsecServer*	- within the specified period of time.
//
// @param request - CreateIpsecServerRequest
//
// @return CreateIpsecServerResponse
func (client *Client) CreateIpsecServer(request *CreateIpsecServerRequest) (_result *CreateIpsecServerResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &CreateIpsecServerResponse{}
	_body, _err := client.CreateIpsecServerWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// IPv4
//
// Description:
//
//	  **CreateIpv4Gateway*	- is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [GetIpv4GatewayAttribute](https://help.aliyun.com/document_detail/407670.html) operation to query the status of an IPv4 gateway:
//
//	    	- If the IPv4 gateway is in the **Creating*	- state, the IPv4 gateway is being created.
//
//	    	- If the IPv4 gateway is in the **Created*	- state, the IPv4 gateway is created.
//
//		- You cannot repeatedly call the **CreateIpv4Gateway*	- operation to create IPv4 gateways in a virtual private cloud (VPC) within the specified period of time.
//
// @param request - CreateIpv4GatewayRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateIpv4GatewayResponse
func (client *Client) CreateIpv4GatewayWithOptions(request *CreateIpv4GatewayRequest, runtime *dara.RuntimeOptions) (_result *CreateIpv4GatewayResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.Ipv4GatewayDescription) {
		query["Ipv4GatewayDescription"] = request.Ipv4GatewayDescription
	}

	if !dara.IsNil(request.Ipv4GatewayName) {
		query["Ipv4GatewayName"] = request.Ipv4GatewayName
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceGroupId) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.Tag) {
		query["Tag"] = request.Tag
	}

	if !dara.IsNil(request.VpcId) {
		query["VpcId"] = request.VpcId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CreateIpv4Gateway"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &CreateIpv4GatewayResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// IPv4
//
// Description:
//
//	  **CreateIpv4Gateway*	- is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [GetIpv4GatewayAttribute](https://help.aliyun.com/document_detail/407670.html) operation to query the status of an IPv4 gateway:
//
//	    	- If the IPv4 gateway is in the **Creating*	- state, the IPv4 gateway is being created.
//
//	    	- If the IPv4 gateway is in the **Created*	- state, the IPv4 gateway is created.
//
//		- You cannot repeatedly call the **CreateIpv4Gateway*	- operation to create IPv4 gateways in a virtual private cloud (VPC) within the specified period of time.
//
// @param request - CreateIpv4GatewayRequest
//
// @return CreateIpv4GatewayResponse
func (client *Client) CreateIpv4Gateway(request *CreateIpv4GatewayRequest) (_result *CreateIpv4GatewayResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &CreateIpv4GatewayResponse{}
	_body, _err := client.CreateIpv4GatewayWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// You can call CreateIpv6EgressOnlyRule to create egress-only rules to enable ECS instances in VPCs that have IPv6 enabled to access IPv6 clients. However, IPv6 clients cannot access the ECS instances over the Internet.
//
// Description:
//
//	  **CreateIpv6EgressOnlyRule*	- is an asynchronous operation. After a request is sent, the system returns a request ID and creates the rule in the background. You can call the [DescribeIpv6EgressOnlyRules](https://help.aliyun.com/document_detail/102208.html) operation to query the status of the task.
//
//	    	- If the egress-only rule is in the **Creating*	- state, the egress-only rule is being created.
//
//	    	- If the egress-only rule is in the **Created*	- state, the egress-only rule is created.
//
//		- You cannot repeatedly call the **CreateIpv6EgressOnlyRule*	- operation to add egress-only rules for an IPv6 address within the specified period of time.
//
// @param request - CreateIpv6EgressOnlyRuleRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateIpv6EgressOnlyRuleResponse
func (client *Client) CreateIpv6EgressOnlyRuleWithOptions(request *CreateIpv6EgressOnlyRuleRequest, runtime *dara.RuntimeOptions) (_result *CreateIpv6EgressOnlyRuleResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.Description) {
		query["Description"] = request.Description
	}

	if !dara.IsNil(request.InstanceId) {
		query["InstanceId"] = request.InstanceId
	}

	if !dara.IsNil(request.InstanceType) {
		query["InstanceType"] = request.InstanceType
	}

	if !dara.IsNil(request.Ipv6GatewayId) {
		query["Ipv6GatewayId"] = request.Ipv6GatewayId
	}

	if !dara.IsNil(request.Name) {
		query["Name"] = request.Name
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CreateIpv6EgressOnlyRule"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &CreateIpv6EgressOnlyRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// You can call CreateIpv6EgressOnlyRule to create egress-only rules to enable ECS instances in VPCs that have IPv6 enabled to access IPv6 clients. However, IPv6 clients cannot access the ECS instances over the Internet.
//
// Description:
//
//	  **CreateIpv6EgressOnlyRule*	- is an asynchronous operation. After a request is sent, the system returns a request ID and creates the rule in the background. You can call the [DescribeIpv6EgressOnlyRules](https://help.aliyun.com/document_detail/102208.html) operation to query the status of the task.
//
//	    	- If the egress-only rule is in the **Creating*	- state, the egress-only rule is being created.
//
//	    	- If the egress-only rule is in the **Created*	- state, the egress-only rule is created.
//
//		- You cannot repeatedly call the **CreateIpv6EgressOnlyRule*	- operation to add egress-only rules for an IPv6 address within the specified period of time.
//
// @param request - CreateIpv6EgressOnlyRuleRequest
//
// @return CreateIpv6EgressOnlyRuleResponse
func (client *Client) CreateIpv6EgressOnlyRule(request *CreateIpv6EgressOnlyRuleRequest) (_result *CreateIpv6EgressOnlyRuleResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &CreateIpv6EgressOnlyRuleResponse{}
	_body, _err := client.CreateIpv6EgressOnlyRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// IPv6 gateways are used to control the IPv6 traffic of virtual private clouds (VPCs). You can call the CreateIpv6Gateway operation to create IPv6 gateways.
//
// Description:
//
//	  **CreateIpv6Gateway*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeIpv6GatewayAttribute](https://help.aliyun.com/document_detail/102226.html) operation to query the status of the task.
//
//	    	- If the IPv6 gateway is in the **Creating*	- state, the IPv6 gateway is being created.
//
//	    	- If the IPv6 gateway is in the **Created*	- state, the IPv6 gateway is created.
//
//		- You cannot repeatedly call the **CreateIpv6Gateway*	- operation within a specific time period.
//
// @param request - CreateIpv6GatewayRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateIpv6GatewayResponse
func (client *Client) CreateIpv6GatewayWithOptions(request *CreateIpv6GatewayRequest, runtime *dara.RuntimeOptions) (_result *CreateIpv6GatewayResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.Description) {
		query["Description"] = request.Description
	}

	if !dara.IsNil(request.Name) {
		query["Name"] = request.Name
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceGroupId) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.Tag) {
		query["Tag"] = request.Tag
	}

	if !dara.IsNil(request.VpcId) {
		query["VpcId"] = request.VpcId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CreateIpv6Gateway"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &CreateIpv6GatewayResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// IPv6 gateways are used to control the IPv6 traffic of virtual private clouds (VPCs). You can call the CreateIpv6Gateway operation to create IPv6 gateways.
//
// Description:
//
//	  **CreateIpv6Gateway*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeIpv6GatewayAttribute](https://help.aliyun.com/document_detail/102226.html) operation to query the status of the task.
//
//	    	- If the IPv6 gateway is in the **Creating*	- state, the IPv6 gateway is being created.
//
//	    	- If the IPv6 gateway is in the **Created*	- state, the IPv6 gateway is created.
//
//		- You cannot repeatedly call the **CreateIpv6Gateway*	- operation within a specific time period.
//
// @param request - CreateIpv6GatewayRequest
//
// @return CreateIpv6GatewayResponse
func (client *Client) CreateIpv6Gateway(request *CreateIpv6GatewayRequest) (_result *CreateIpv6GatewayResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &CreateIpv6GatewayResponse{}
	_body, _err := client.CreateIpv6GatewayWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates an enhanced Internet NAT gateway or a Virtual Private Cloud (VPC) NAT gateway.
//
// Description:
//
// ## Usage notes
//
// Before you call this operation, take note of the following items:
//
//   - When you create an enhanced NAT gateway for the first time, the system automatically creates the service-linked role AliyunServiceRoleForNatgw. Then, the system attaches the permission policy AliyunServiceRolePolicyForNatgw to the role. This allows the NAT gateway to access other resources on Alibaba Cloud. For more information, see [Service-linked roles](https://help.aliyun.com/document_detail/174251.html).
//
//   - After you create an enhanced Internet NAT gateway, a route entry is automatically added to the route table of the VPC. The destination CIDR block of the route entry is 0.0.0.0/0 and the next hop is the NAT gateway. This ensures that traffic is routed to the NAT gateway.
//
//   - **CreateNatGateway*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeNatGateways](https://help.aliyun.com/document_detail/36054.html) operation to query the status of the task.
//
//   - If a NAT gateway is in the **Creating*	- state, the NAT gateway is being created. In this case, you can query the NAT gateway but cannot perform other operations.
//
//   - If a NAT gateway is in the **Available*	- state, the NAT gateway is created.
//
// It takes 1 to 3 minutes to create a NAT gateway.
//
// @param tmpReq - CreateNatGatewayRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateNatGatewayResponse
func (client *Client) CreateNatGatewayWithOptions(tmpReq *CreateNatGatewayRequest, runtime *dara.RuntimeOptions) (_result *CreateNatGatewayResponse, _err error) {
	_err = tmpReq.Validate()
	if _err != nil {
		return _result, _err
	}
	request := &CreateNatGatewayShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !dara.IsNil(tmpReq.AccessMode) {
		request.AccessModeShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.AccessMode, dara.String("AccessMode"), dara.String("json"))
	}

	query := map[string]interface{}{}
	if !dara.IsNil(request.AccessModeShrink) {
		query["AccessMode"] = request.AccessModeShrink
	}

	if !dara.IsNil(request.AutoPay) {
		query["AutoPay"] = request.AutoPay
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.Description) {
		query["Description"] = request.Description
	}

	if !dara.IsNil(request.Duration) {
		query["Duration"] = request.Duration
	}

	if !dara.IsNil(request.EipBindMode) {
		query["EipBindMode"] = request.EipBindMode
	}

	if !dara.IsNil(request.IcmpReplyEnabled) {
		query["IcmpReplyEnabled"] = request.IcmpReplyEnabled
	}

	if !dara.IsNil(request.InstanceChargeType) {
		query["InstanceChargeType"] = request.InstanceChargeType
	}

	if !dara.IsNil(request.InternetChargeType) {
		query["InternetChargeType"] = request.InternetChargeType
	}

	if !dara.IsNil(request.Ipv4Prefix) {
		query["Ipv4Prefix"] = request.Ipv4Prefix
	}

	if !dara.IsNil(request.Name) {
		query["Name"] = request.Name
	}

	if !dara.IsNil(request.NatIp) {
		query["NatIp"] = request.NatIp
	}

	if !dara.IsNil(request.NatType) {
		query["NatType"] = request.NatType
	}

	if !dara.IsNil(request.NetworkType) {
		query["NetworkType"] = request.NetworkType
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PricingCycle) {
		query["PricingCycle"] = request.PricingCycle
	}

	if !dara.IsNil(request.PrivateLinkEnabled) {
		query["PrivateLinkEnabled"] = request.PrivateLinkEnabled
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.SecurityProtectionEnabled) {
		query["SecurityProtectionEnabled"] = request.SecurityProtectionEnabled
	}

	if !dara.IsNil(request.Spec) {
		query["Spec"] = request.Spec
	}

	if !dara.IsNil(request.Tag) {
		query["Tag"] = request.Tag
	}

	if !dara.IsNil(request.VSwitchId) {
		query["VSwitchId"] = request.VSwitchId
	}

	if !dara.IsNil(request.VpcId) {
		query["VpcId"] = request.VpcId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CreateNatGateway"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &CreateNatGatewayResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Creates an enhanced Internet NAT gateway or a Virtual Private Cloud (VPC) NAT gateway.
//
// Description:
//
// ## Usage notes
//
// Before you call this operation, take note of the following items:
//
//   - When you create an enhanced NAT gateway for the first time, the system automatically creates the service-linked role AliyunServiceRoleForNatgw. Then, the system attaches the permission policy AliyunServiceRolePolicyForNatgw to the role. This allows the NAT gateway to access other resources on Alibaba Cloud. For more information, see [Service-linked roles](https://help.aliyun.com/document_detail/174251.html).
//
//   - After you create an enhanced Internet NAT gateway, a route entry is automatically added to the route table of the VPC. The destination CIDR block of the route entry is 0.0.0.0/0 and the next hop is the NAT gateway. This ensures that traffic is routed to the NAT gateway.
//
//   - **CreateNatGateway*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeNatGateways](https://help.aliyun.com/document_detail/36054.html) operation to query the status of the task.
//
//   - If a NAT gateway is in the **Creating*	- state, the NAT gateway is being created. In this case, you can query the NAT gateway but cannot perform other operations.
//
//   - If a NAT gateway is in the **Available*	- state, the NAT gateway is created.
//
// It takes 1 to 3 minutes to create a NAT gateway.
//
// @param request - CreateNatGatewayRequest
//
// @return CreateNatGatewayResponse
func (client *Client) CreateNatGateway(request *CreateNatGatewayRequest) (_result *CreateNatGatewayResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &CreateNatGatewayResponse{}
	_body, _err := client.CreateNatGatewayWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates a NAT IP address.
//
// Description:
//
// ## [](#)
//
// **CreateNatIp*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListNatIps](https://help.aliyun.com/document_detail/287000.html) operation to query the status of the task.
//
//   - If a NAT IP address is in the **Creating*	- state, the NAT IP address is being created. In this case, you can only query the NAT IP address and cannot perform other operations.
//
//   - If a NAT IP address is in the **Available*	- state, the NAT IP address is created.
//
// You cannot repeatedly call the **CreateNatIp*	- operation to create a NAT IP address within a specific period of time.
//
// @param request - CreateNatIpRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateNatIpResponse
func (client *Client) CreateNatIpWithOptions(request *CreateNatIpRequest, runtime *dara.RuntimeOptions) (_result *CreateNatIpResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.Ipv4Prefix) {
		query["Ipv4Prefix"] = request.Ipv4Prefix
	}

	if !dara.IsNil(request.Ipv4PrefixCount) {
		query["Ipv4PrefixCount"] = request.Ipv4PrefixCount
	}

	if !dara.IsNil(request.NatGatewayId) {
		query["NatGatewayId"] = request.NatGatewayId
	}

	if !dara.IsNil(request.NatIp) {
		query["NatIp"] = request.NatIp
	}

	if !dara.IsNil(request.NatIpCidr) {
		query["NatIpCidr"] = request.NatIpCidr
	}

	if !dara.IsNil(request.NatIpDescription) {
		query["NatIpDescription"] = request.NatIpDescription
	}

	if !dara.IsNil(request.NatIpName) {
		query["NatIpName"] = request.NatIpName
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CreateNatIp"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &CreateNatIpResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Creates a NAT IP address.
//
// Description:
//
// ## [](#)
//
// **CreateNatIp*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListNatIps](https://help.aliyun.com/document_detail/287000.html) operation to query the status of the task.
//
//   - If a NAT IP address is in the **Creating*	- state, the NAT IP address is being created. In this case, you can only query the NAT IP address and cannot perform other operations.
//
//   - If a NAT IP address is in the **Available*	- state, the NAT IP address is created.
//
// You cannot repeatedly call the **CreateNatIp*	- operation to create a NAT IP address within a specific period of time.
//
// @param request - CreateNatIpRequest
//
// @return CreateNatIpResponse
func (client *Client) CreateNatIp(request *CreateNatIpRequest) (_result *CreateNatIpResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &CreateNatIpResponse{}
	_body, _err := client.CreateNatIpWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates a NAT CIDR block.
//
// Description:
//
// ## [](#)Description
//
// You cannot repeatedly call the **CreateNatIpCidr*	- operation to create a NAT CIDR block within the specified period of time.
//
// @param request - CreateNatIpCidrRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateNatIpCidrResponse
func (client *Client) CreateNatIpCidrWithOptions(request *CreateNatIpCidrRequest, runtime *dara.RuntimeOptions) (_result *CreateNatIpCidrResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.NatGatewayId) {
		query["NatGatewayId"] = request.NatGatewayId
	}

	if !dara.IsNil(request.NatIpCidr) {
		query["NatIpCidr"] = request.NatIpCidr
	}

	if !dara.IsNil(request.NatIpCidrDescription) {
		query["NatIpCidrDescription"] = request.NatIpCidrDescription
	}

	if !dara.IsNil(request.NatIpCidrName) {
		query["NatIpCidrName"] = request.NatIpCidrName
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CreateNatIpCidr"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &CreateNatIpCidrResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Creates a NAT CIDR block.
//
// Description:
//
// ## [](#)Description
//
// You cannot repeatedly call the **CreateNatIpCidr*	- operation to create a NAT CIDR block within the specified period of time.
//
// @param request - CreateNatIpCidrRequest
//
// @return CreateNatIpCidrResponse
func (client *Client) CreateNatIpCidr(request *CreateNatIpCidrRequest) (_result *CreateNatIpCidrResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &CreateNatIpCidrResponse{}
	_body, _err := client.CreateNatIpCidrWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates a network ACL.
//
// @param request - CreateNetworkAclRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateNetworkAclResponse
func (client *Client) CreateNetworkAclWithOptions(request *CreateNetworkAclRequest, runtime *dara.RuntimeOptions) (_result *CreateNetworkAclResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.Description) {
		query["Description"] = request.Description
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.NetworkAclName) {
		query["NetworkAclName"] = request.NetworkAclName
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.Tag) {
		query["Tag"] = request.Tag
	}

	if !dara.IsNil(request.VpcId) {
		query["VpcId"] = request.VpcId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CreateNetworkAcl"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &CreateNetworkAclResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Creates a network ACL.
//
// @param request - CreateNetworkAclRequest
//
// @return CreateNetworkAclResponse
func (client *Client) CreateNetworkAcl(request *CreateNetworkAclRequest) (_result *CreateNetworkAclResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &CreateNetworkAclResponse{}
	_body, _err := client.CreateNetworkAclWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Applies for an Express Connect circuit.
//
// Description:
//
// You can apply for a dedicated Express Connect circuit for yourself or create a hosted connection for a tenant. After your application is approved, the Express Connect circuit changes to the **Initial*	- state. You can contact the connectivity provider to start construction.
//
// When you call this operation, take note of the following limits:
//
//   - If your Alibaba Cloud account has more than five Express Connect circuits that are not in the **Enabled*	- state, you cannot apply for another Express Connect circuit.
//
//   - If your Alibaba Cloud account has an Express Connect circuit with overdue payments, you cannot apply for another Express Connect circuit.
//
// @param request - CreatePhysicalConnectionRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreatePhysicalConnectionResponse
func (client *Client) CreatePhysicalConnectionWithOptions(request *CreatePhysicalConnectionRequest, runtime *dara.RuntimeOptions) (_result *CreatePhysicalConnectionResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.AccessPointId) {
		query["AccessPointId"] = request.AccessPointId
	}

	if !dara.IsNil(request.CircuitCode) {
		query["CircuitCode"] = request.CircuitCode
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.Description) {
		query["Description"] = request.Description
	}

	if !dara.IsNil(request.DeviceAdvancedCapacity) {
		query["DeviceAdvancedCapacity"] = request.DeviceAdvancedCapacity
	}

	if !dara.IsNil(request.LineOperator) {
		query["LineOperator"] = request.LineOperator
	}

	if !dara.IsNil(request.Name) {
		query["Name"] = request.Name
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PeerLocation) {
		query["PeerLocation"] = request.PeerLocation
	}

	if !dara.IsNil(request.PortType) {
		query["PortType"] = request.PortType
	}

	if !dara.IsNil(request.RedundantPhysicalConnectionId) {
		query["RedundantPhysicalConnectionId"] = request.RedundantPhysicalConnectionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceGroupId) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.Tag) {
		query["Tag"] = request.Tag
	}

	if !dara.IsNil(request.Type) {
		query["Type"] = request.Type
	}

	if !dara.IsNil(request.Bandwidth) {
		query["bandwidth"] = request.Bandwidth
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CreatePhysicalConnection"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &CreatePhysicalConnectionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Applies for an Express Connect circuit.
//
// Description:
//
// You can apply for a dedicated Express Connect circuit for yourself or create a hosted connection for a tenant. After your application is approved, the Express Connect circuit changes to the **Initial*	- state. You can contact the connectivity provider to start construction.
//
// When you call this operation, take note of the following limits:
//
//   - If your Alibaba Cloud account has more than five Express Connect circuits that are not in the **Enabled*	- state, you cannot apply for another Express Connect circuit.
//
//   - If your Alibaba Cloud account has an Express Connect circuit with overdue payments, you cannot apply for another Express Connect circuit.
//
// @param request - CreatePhysicalConnectionRequest
//
// @return CreatePhysicalConnectionResponse
func (client *Client) CreatePhysicalConnection(request *CreatePhysicalConnectionRequest) (_result *CreatePhysicalConnectionResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &CreatePhysicalConnectionResponse{}
	_body, _err := client.CreatePhysicalConnectionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates an order for resource occupation of an Express Connect circuit.
//
// Description:
//
// >  You can call this operation only when the Express Connect circuit is in the **Complete*	- state.
//
// @param request - CreatePhysicalConnectionOccupancyOrderRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreatePhysicalConnectionOccupancyOrderResponse
func (client *Client) CreatePhysicalConnectionOccupancyOrderWithOptions(request *CreatePhysicalConnectionOccupancyOrderRequest, runtime *dara.RuntimeOptions) (_result *CreatePhysicalConnectionOccupancyOrderResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.AutoPay) {
		query["AutoPay"] = request.AutoPay
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.InstanceChargeType) {
		query["InstanceChargeType"] = request.InstanceChargeType
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.Period) {
		query["Period"] = request.Period
	}

	if !dara.IsNil(request.PhysicalConnectionId) {
		query["PhysicalConnectionId"] = request.PhysicalConnectionId
	}

	if !dara.IsNil(request.PricingCycle) {
		query["PricingCycle"] = request.PricingCycle
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CreatePhysicalConnectionOccupancyOrder"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &CreatePhysicalConnectionOccupancyOrderResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Creates an order for resource occupation of an Express Connect circuit.
//
// Description:
//
// >  You can call this operation only when the Express Connect circuit is in the **Complete*	- state.
//
// @param request - CreatePhysicalConnectionOccupancyOrderRequest
//
// @return CreatePhysicalConnectionOccupancyOrderResponse
func (client *Client) CreatePhysicalConnectionOccupancyOrder(request *CreatePhysicalConnectionOccupancyOrderRequest) (_result *CreatePhysicalConnectionOccupancyOrderResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &CreatePhysicalConnectionOccupancyOrderResponse{}
	_body, _err := client.CreatePhysicalConnectionOccupancyOrderWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates an order for initial installation of an Express Connect circuit.
//
// @param request - CreatePhysicalConnectionSetupOrderRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreatePhysicalConnectionSetupOrderResponse
func (client *Client) CreatePhysicalConnectionSetupOrderWithOptions(request *CreatePhysicalConnectionSetupOrderRequest, runtime *dara.RuntimeOptions) (_result *CreatePhysicalConnectionSetupOrderResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.AccessPointId) {
		query["AccessPointId"] = request.AccessPointId
	}

	if !dara.IsNil(request.AutoPay) {
		query["AutoPay"] = request.AutoPay
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.LineOperator) {
		query["LineOperator"] = request.LineOperator
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PortType) {
		query["PortType"] = request.PortType
	}

	if !dara.IsNil(request.RedundantPhysicalConnectionId) {
		query["RedundantPhysicalConnectionId"] = request.RedundantPhysicalConnectionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CreatePhysicalConnectionSetupOrder"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &CreatePhysicalConnectionSetupOrderResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Creates an order for initial installation of an Express Connect circuit.
//
// @param request - CreatePhysicalConnectionSetupOrderRequest
//
// @return CreatePhysicalConnectionSetupOrderResponse
func (client *Client) CreatePhysicalConnectionSetupOrder(request *CreatePhysicalConnectionSetupOrderRequest) (_result *CreatePhysicalConnectionSetupOrderResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &CreatePhysicalConnectionSetupOrderResponse{}
	_body, _err := client.CreatePhysicalConnectionSetupOrderWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates an IP address pool.
//
// Description:
//
// By default, the IP address pool feature is unavailable. You can apply for the privilege to use the **IP address pool feature*	- in the Quota Center console. For more information, see the "Request a quota increase in the Quota Center console" section in the [Manage EIP quotas](https://help.aliyun.com/document_detail/108213.html) topic.
//
// @param request - CreatePublicIpAddressPoolRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreatePublicIpAddressPoolResponse
func (client *Client) CreatePublicIpAddressPoolWithOptions(request *CreatePublicIpAddressPoolRequest, runtime *dara.RuntimeOptions) (_result *CreatePublicIpAddressPoolResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.BizType) {
		query["BizType"] = request.BizType
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.Description) {
		query["Description"] = request.Description
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.Isp) {
		query["Isp"] = request.Isp
	}

	if !dara.IsNil(request.Name) {
		query["Name"] = request.Name
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceGroupId) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.SecurityProtectionTypes) {
		query["SecurityProtectionTypes"] = request.SecurityProtectionTypes
	}

	if !dara.IsNil(request.Tag) {
		query["Tag"] = request.Tag
	}

	if !dara.IsNil(request.Zones) {
		query["Zones"] = request.Zones
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CreatePublicIpAddressPool"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &CreatePublicIpAddressPoolResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Creates an IP address pool.
//
// Description:
//
// By default, the IP address pool feature is unavailable. You can apply for the privilege to use the **IP address pool feature*	- in the Quota Center console. For more information, see the "Request a quota increase in the Quota Center console" section in the [Manage EIP quotas](https://help.aliyun.com/document_detail/108213.html) topic.
//
// @param request - CreatePublicIpAddressPoolRequest
//
// @return CreatePublicIpAddressPoolResponse
func (client *Client) CreatePublicIpAddressPool(request *CreatePublicIpAddressPoolRequest) (_result *CreatePublicIpAddressPoolResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &CreatePublicIpAddressPoolResponse{}
	_body, _err := client.CreatePublicIpAddressPoolWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Adds custom route entries to the route table of a vRouter in a virtual private cloud (VPC).
//
// Description:
//
// ## [](#)References
//
//   - **CreateRouteEntries*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeRouteEntryList](https://help.aliyun.com/document_detail/138148.html) operation to query the status of the task.
//
//   - If the route entry is in the **Creating*	- state, the route entry is being created.
//
//   - If the route entry is in the **Created*	- state, the route entry is created.
//
//   - You cannot repeatedly call the **CreateRouteEntries*	- operation to create the same route entry within the specified period of time.
//
// **When you call this operation to add custom route entries to the route table of a vRouter, take note of the following items:**
//
//   - A route table can contain up to 200 custom route entries.
//
//   - The destination CIDR block (**DstCidrBlock**) of a custom route entry cannot be the same as or overlap with the CIDR block of a vSwitch in the VPC.
//
//   - The destination CIDR block (**DstCidrBlock**) of a custom route entry cannot be 100.64.0.0/10 or its subnets.
//
//   - The destination CIDR blocks (**DstCidrBlock**) of route entries in the same route table must be unique.
//
//   - If you do not include the mask length when you specify the destination CIDR block (**DstCidrBlock**), the destination CIDR block is considered a host IP address whose mask length is 32 bits.
//
//   - Multiple custom route entries can point to the same next hop (**NextHop**).
//
//   - The next hop (**NextHop**) of a custom route entry must belong to the same VPC as the route table.
//
// @param request - CreateRouteEntriesRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateRouteEntriesResponse
func (client *Client) CreateRouteEntriesWithOptions(request *CreateRouteEntriesRequest, runtime *dara.RuntimeOptions) (_result *CreateRouteEntriesResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.RouteEntries) {
		query["RouteEntries"] = request.RouteEntries
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CreateRouteEntries"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &CreateRouteEntriesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Adds custom route entries to the route table of a vRouter in a virtual private cloud (VPC).
//
// Description:
//
// ## [](#)References
//
//   - **CreateRouteEntries*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeRouteEntryList](https://help.aliyun.com/document_detail/138148.html) operation to query the status of the task.
//
//   - If the route entry is in the **Creating*	- state, the route entry is being created.
//
//   - If the route entry is in the **Created*	- state, the route entry is created.
//
//   - You cannot repeatedly call the **CreateRouteEntries*	- operation to create the same route entry within the specified period of time.
//
// **When you call this operation to add custom route entries to the route table of a vRouter, take note of the following items:**
//
//   - A route table can contain up to 200 custom route entries.
//
//   - The destination CIDR block (**DstCidrBlock**) of a custom route entry cannot be the same as or overlap with the CIDR block of a vSwitch in the VPC.
//
//   - The destination CIDR block (**DstCidrBlock**) of a custom route entry cannot be 100.64.0.0/10 or its subnets.
//
//   - The destination CIDR blocks (**DstCidrBlock**) of route entries in the same route table must be unique.
//
//   - If you do not include the mask length when you specify the destination CIDR block (**DstCidrBlock**), the destination CIDR block is considered a host IP address whose mask length is 32 bits.
//
//   - Multiple custom route entries can point to the same next hop (**NextHop**).
//
//   - The next hop (**NextHop**) of a custom route entry must belong to the same VPC as the route table.
//
// @param request - CreateRouteEntriesRequest
//
// @return CreateRouteEntriesResponse
func (client *Client) CreateRouteEntries(request *CreateRouteEntriesRequest) (_result *CreateRouteEntriesResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &CreateRouteEntriesResponse{}
	_body, _err := client.CreateRouteEntriesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates a custom route entry in the route table of a VRouter or virtual border router (VBR).
//
// Description:
//
//	  **CreateRouteEntry*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeRouteEntryList](https://help.aliyun.com/document_detail/138148.html) operation to query the status of the task:
//
//	    	- If a route is in the **Creating*	- state, the route is being added.
//
//	    	- If a route is in the **Created*	- state, the route is added.
//
//		- You cannot repeatedly call **CreateRouteEntry*	- within a specific period of time.
//
// **When you call this operation to add a custom route entry to the route table of a vRouter, take note of the following limits:**
//
// >  When you add a route entry from a prefix list, the quota usage is calculated by adding the number of existing route entries and the maximum number of route entries of the prefix list.
//
//   - A route table can contain up to 200 custom route entries.
//
//   - The destination CIDR block (**DestinationCidrBlock**) of a custom route entry cannot be the same as or be a subset of the CIDR block of a vSwitch in the virtual private cloud (VPC). The destination CIDR block can contain the CIDR block of a vSwitch.
//
//   - The destination CIDR block (**DestinationCidrBlock**) of a custom route entry cannot be 100.64.0.0/10 or a subset of it.
//
//   - The destination CIDR blocks (**DestinationCidrBlock**) of route entries in the same route table must be unique.
//
//   - If you do not include the mask length when you specify the destination CIDR block (**DestinationCidrBlock**), the destination CIDR block is considered a host IP address whose mask length is 32 bits.
//
//   - Multiple custom route entries can point to the same next hop (**NextHopId**).
//
//   - The next hop (**NextHopId**) of a custom route entry must in the same VPC as the route table.
//
//   - Equal-cost multi-path (ECMP) routing can be configured by specifying the **NextHopList*	- parameter.
//
//   - When you add non-ECMP route entries, you must specify **DestinationCidrBlock**, **NextHopType**, and **NextHopId**, and you must not specify **NextHopList**.
//
//   - When you add route entries for ECMP routing, you must specify **DestinationCidrBlock*	- and **NextHopList**, and you must not specify **NextHopType*	- or **NextHopId**.
//
// **When you call this operation to add a custom route entry to the route table of a VBR, take note of the following limits:**
//
//   - A route table can contain up to 200 custom route entries.
//
//   - **NextHopList*	- is not supported.
//
//   - The destination CIDR block (**DestinationCidrBlock**) of a custom route entry cannot be 100.64.0.0/10 or a subset of it.
//
//   - The destination CIDR blocks (**DestinationCidrBlock**) of route entries in the same route table must be unique.
//
//   - If you do not include the mask length when you specify the destination CIDR block (**DestinationCidrBlock**), the destination CIDR block is considered a host IP address whose mask length is 32 bits.
//
//   - Multiple custom route entries can point to the same next hop (**NextHopId**).
//
//   - The next hop (**NextHopId**) of a custom route entry must be a router interface associated with the VBR.
//
//   - You can add route entries only when the VBR is in the **Active*	- state, and the Express Connect circuit associated with the VBR is in the **Enabled*	- state and is not locked due to overdue payments.
//
//   - Only non-ECMP route entries are supported. When you add non-ECMP route entries, you must specify **DestinationCidrBlock**, **NextHopType**, and **NextHopId**, and you cannot specify **NextHopList**.
//
// @param request - CreateRouteEntryRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateRouteEntryResponse
func (client *Client) CreateRouteEntryWithOptions(request *CreateRouteEntryRequest, runtime *dara.RuntimeOptions) (_result *CreateRouteEntryResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.Description) {
		query["Description"] = request.Description
	}

	if !dara.IsNil(request.DestinationCidrBlock) {
		query["DestinationCidrBlock"] = request.DestinationCidrBlock
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.NextHopId) {
		query["NextHopId"] = request.NextHopId
	}

	if !dara.IsNil(request.NextHopList) {
		query["NextHopList"] = request.NextHopList
	}

	if !dara.IsNil(request.NextHopType) {
		query["NextHopType"] = request.NextHopType
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.RouteEntryName) {
		query["RouteEntryName"] = request.RouteEntryName
	}

	if !dara.IsNil(request.RouteTableId) {
		query["RouteTableId"] = request.RouteTableId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CreateRouteEntry"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &CreateRouteEntryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Creates a custom route entry in the route table of a VRouter or virtual border router (VBR).
//
// Description:
//
//	  **CreateRouteEntry*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeRouteEntryList](https://help.aliyun.com/document_detail/138148.html) operation to query the status of the task:
//
//	    	- If a route is in the **Creating*	- state, the route is being added.
//
//	    	- If a route is in the **Created*	- state, the route is added.
//
//		- You cannot repeatedly call **CreateRouteEntry*	- within a specific period of time.
//
// **When you call this operation to add a custom route entry to the route table of a vRouter, take note of the following limits:**
//
// >  When you add a route entry from a prefix list, the quota usage is calculated by adding the number of existing route entries and the maximum number of route entries of the prefix list.
//
//   - A route table can contain up to 200 custom route entries.
//
//   - The destination CIDR block (**DestinationCidrBlock**) of a custom route entry cannot be the same as or be a subset of the CIDR block of a vSwitch in the virtual private cloud (VPC). The destination CIDR block can contain the CIDR block of a vSwitch.
//
//   - The destination CIDR block (**DestinationCidrBlock**) of a custom route entry cannot be 100.64.0.0/10 or a subset of it.
//
//   - The destination CIDR blocks (**DestinationCidrBlock**) of route entries in the same route table must be unique.
//
//   - If you do not include the mask length when you specify the destination CIDR block (**DestinationCidrBlock**), the destination CIDR block is considered a host IP address whose mask length is 32 bits.
//
//   - Multiple custom route entries can point to the same next hop (**NextHopId**).
//
//   - The next hop (**NextHopId**) of a custom route entry must in the same VPC as the route table.
//
//   - Equal-cost multi-path (ECMP) routing can be configured by specifying the **NextHopList*	- parameter.
//
//   - When you add non-ECMP route entries, you must specify **DestinationCidrBlock**, **NextHopType**, and **NextHopId**, and you must not specify **NextHopList**.
//
//   - When you add route entries for ECMP routing, you must specify **DestinationCidrBlock*	- and **NextHopList**, and you must not specify **NextHopType*	- or **NextHopId**.
//
// **When you call this operation to add a custom route entry to the route table of a VBR, take note of the following limits:**
//
//   - A route table can contain up to 200 custom route entries.
//
//   - **NextHopList*	- is not supported.
//
//   - The destination CIDR block (**DestinationCidrBlock**) of a custom route entry cannot be 100.64.0.0/10 or a subset of it.
//
//   - The destination CIDR blocks (**DestinationCidrBlock**) of route entries in the same route table must be unique.
//
//   - If you do not include the mask length when you specify the destination CIDR block (**DestinationCidrBlock**), the destination CIDR block is considered a host IP address whose mask length is 32 bits.
//
//   - Multiple custom route entries can point to the same next hop (**NextHopId**).
//
//   - The next hop (**NextHopId**) of a custom route entry must be a router interface associated with the VBR.
//
//   - You can add route entries only when the VBR is in the **Active*	- state, and the Express Connect circuit associated with the VBR is in the **Enabled*	- state and is not locked due to overdue payments.
//
//   - Only non-ECMP route entries are supported. When you add non-ECMP route entries, you must specify **DestinationCidrBlock**, **NextHopType**, and **NextHopId**, and you cannot specify **NextHopList**.
//
// @param request - CreateRouteEntryRequest
//
// @return CreateRouteEntryResponse
func (client *Client) CreateRouteEntry(request *CreateRouteEntryRequest) (_result *CreateRouteEntryResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &CreateRouteEntryResponse{}
	_body, _err := client.CreateRouteEntryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates a custom route table.
//
// Description:
//
//	  **CreateRouteTable*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the operation in the background. You can call the [DescribeRouteTableList](https://help.aliyun.com/document_detail/87602.html) operation to query the status of the task.
//
//	    	- If the custom route table is in the **Creating*	- state, the custom route table is being created.
//
//	    	- If the custom route table is in the **Created*	- state, the custom route table is created.
//
//		- You cannot repeatedly call the **CreateRouteTable*	- operation within the specified period of time.
//
// @param request - CreateRouteTableRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateRouteTableResponse
func (client *Client) CreateRouteTableWithOptions(request *CreateRouteTableRequest, runtime *dara.RuntimeOptions) (_result *CreateRouteTableResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.AssociateType) {
		query["AssociateType"] = request.AssociateType
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.Description) {
		query["Description"] = request.Description
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.RouteTableName) {
		query["RouteTableName"] = request.RouteTableName
	}

	if !dara.IsNil(request.Tag) {
		query["Tag"] = request.Tag
	}

	if !dara.IsNil(request.VpcId) {
		query["VpcId"] = request.VpcId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CreateRouteTable"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &CreateRouteTableResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Creates a custom route table.
//
// Description:
//
//	  **CreateRouteTable*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the operation in the background. You can call the [DescribeRouteTableList](https://help.aliyun.com/document_detail/87602.html) operation to query the status of the task.
//
//	    	- If the custom route table is in the **Creating*	- state, the custom route table is being created.
//
//	    	- If the custom route table is in the **Created*	- state, the custom route table is created.
//
//		- You cannot repeatedly call the **CreateRouteTable*	- operation within the specified period of time.
//
// @param request - CreateRouteTableRequest
//
// @return CreateRouteTableResponse
func (client *Client) CreateRouteTable(request *CreateRouteTableRequest) (_result *CreateRouteTableResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &CreateRouteTableResponse{}
	_body, _err := client.CreateRouteTableWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates a router interface.
//
// Description:
//
// When you call this operation, take note of the following limits:
//
//   - You can create only one pair of interfaces to be connected between two routers.
//
//   - You can create a maximum of five router interfaces for a router.
//
//   - If your Alibaba Cloud account has a router interface with overdue payments, you cannot create new router interfaces.
//
//   - Each destination CIDR block of route entries in the same route table must be unique.
//
//   - A virtual border router (VBR) can serve only as a requester. The VBR must be in the Activated state.
//
//   - You can call this operation to create subscription and pay-as-you-go router interfaces.
//
// @param request - CreateRouterInterfaceRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateRouterInterfaceResponse
func (client *Client) CreateRouterInterfaceWithOptions(request *CreateRouterInterfaceRequest, runtime *dara.RuntimeOptions) (_result *CreateRouterInterfaceResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.AccessPointId) {
		query["AccessPointId"] = request.AccessPointId
	}

	if !dara.IsNil(request.AutoPay) {
		query["AutoPay"] = request.AutoPay
	}

	if !dara.IsNil(request.AutoRenew) {
		query["AutoRenew"] = request.AutoRenew
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.Description) {
		query["Description"] = request.Description
	}

	if !dara.IsNil(request.FastLinkMode) {
		query["FastLinkMode"] = request.FastLinkMode
	}

	if !dara.IsNil(request.HealthCheckSourceIp) {
		query["HealthCheckSourceIp"] = request.HealthCheckSourceIp
	}

	if !dara.IsNil(request.HealthCheckTargetIp) {
		query["HealthCheckTargetIp"] = request.HealthCheckTargetIp
	}

	if !dara.IsNil(request.InstanceChargeType) {
		query["InstanceChargeType"] = request.InstanceChargeType
	}

	if !dara.IsNil(request.Name) {
		query["Name"] = request.Name
	}

	if !dara.IsNil(request.OppositeAccessPointId) {
		query["OppositeAccessPointId"] = request.OppositeAccessPointId
	}

	if !dara.IsNil(request.OppositeInterfaceId) {
		query["OppositeInterfaceId"] = request.OppositeInterfaceId
	}

	if !dara.IsNil(request.OppositeInterfaceOwnerId) {
		query["OppositeInterfaceOwnerId"] = request.OppositeInterfaceOwnerId
	}

	if !dara.IsNil(request.OppositeRegionId) {
		query["OppositeRegionId"] = request.OppositeRegionId
	}

	if !dara.IsNil(request.OppositeRouterId) {
		query["OppositeRouterId"] = request.OppositeRouterId
	}

	if !dara.IsNil(request.OppositeRouterType) {
		query["OppositeRouterType"] = request.OppositeRouterType
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.Period) {
		query["Period"] = request.Period
	}

	if !dara.IsNil(request.PricingCycle) {
		query["PricingCycle"] = request.PricingCycle
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceGroupId) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.Role) {
		query["Role"] = request.Role
	}

	if !dara.IsNil(request.RouterId) {
		query["RouterId"] = request.RouterId
	}

	if !dara.IsNil(request.RouterType) {
		query["RouterType"] = request.RouterType
	}

	if !dara.IsNil(request.Spec) {
		query["Spec"] = request.Spec
	}

	if !dara.IsNil(request.Tags) {
		query["Tags"] = request.Tags
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CreateRouterInterface"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &CreateRouterInterfaceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Creates a router interface.
//
// Description:
//
// When you call this operation, take note of the following limits:
//
//   - You can create only one pair of interfaces to be connected between two routers.
//
//   - You can create a maximum of five router interfaces for a router.
//
//   - If your Alibaba Cloud account has a router interface with overdue payments, you cannot create new router interfaces.
//
//   - Each destination CIDR block of route entries in the same route table must be unique.
//
//   - A virtual border router (VBR) can serve only as a requester. The VBR must be in the Activated state.
//
//   - You can call this operation to create subscription and pay-as-you-go router interfaces.
//
// @param request - CreateRouterInterfaceRequest
//
// @return CreateRouterInterfaceResponse
func (client *Client) CreateRouterInterface(request *CreateRouterInterfaceRequest) (_result *CreateRouterInterfaceResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &CreateRouterInterfaceResponse{}
	_body, _err := client.CreateRouterInterfaceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Adds an SNAT entry to an SNAT table.
//
// Description:
//
// You can call this operation to add SNAT entries to Internet NAT gateways and Virtual Private Cloud (VPC) NAT gateways. In this topic, a **NAT*	- gateway refers to both gateway types.
//
// Before you call this operation, take note of the following limits:
//
//   - **CreateSnatEntry*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeSnatTableEntries](https://help.aliyun.com/document_detail/42677.html) operation to query the status of the task.
//
//   - If the SNAT entry is in the **Pending*	- state, the system is adding the SNAT entry. You can only query the status of the SNAT entry, and cannot perform other operations.
//
//   - If the SNAT entry is in the **Available*	- state, the SNAT entry is added.
//
//   - You cannot repeatedly call the **CreateSnatEntry*	- operation to add an SNAT entry to an SNAT table within the specified period of time.
//
//   - The vSwitch and Elastic Compute Service (ECS) instance specified in an SNAT entry must be created in the VPC where the NAT gateway is deployed.
//
//   - Each vSwitch or ECS instance can be specified in only one SNAT entry.
//
//   - If a high-availability virtual IP address (HAVIP) exists in a vSwitch, you cannot create SNAT entries.
//
// @param request - CreateSnatEntryRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateSnatEntryResponse
func (client *Client) CreateSnatEntryWithOptions(request *CreateSnatEntryRequest, runtime *dara.RuntimeOptions) (_result *CreateSnatEntryResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.EipAffinity) {
		query["EipAffinity"] = request.EipAffinity
	}

	if !dara.IsNil(request.NetworkInterfaceId) {
		query["NetworkInterfaceId"] = request.NetworkInterfaceId
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.SnatEntryName) {
		query["SnatEntryName"] = request.SnatEntryName
	}

	if !dara.IsNil(request.SnatIp) {
		query["SnatIp"] = request.SnatIp
	}

	if !dara.IsNil(request.SnatTableId) {
		query["SnatTableId"] = request.SnatTableId
	}

	if !dara.IsNil(request.SourceCIDR) {
		query["SourceCIDR"] = request.SourceCIDR
	}

	if !dara.IsNil(request.SourceVSwitchId) {
		query["SourceVSwitchId"] = request.SourceVSwitchId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CreateSnatEntry"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &CreateSnatEntryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Adds an SNAT entry to an SNAT table.
//
// Description:
//
// You can call this operation to add SNAT entries to Internet NAT gateways and Virtual Private Cloud (VPC) NAT gateways. In this topic, a **NAT*	- gateway refers to both gateway types.
//
// Before you call this operation, take note of the following limits:
//
//   - **CreateSnatEntry*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeSnatTableEntries](https://help.aliyun.com/document_detail/42677.html) operation to query the status of the task.
//
//   - If the SNAT entry is in the **Pending*	- state, the system is adding the SNAT entry. You can only query the status of the SNAT entry, and cannot perform other operations.
//
//   - If the SNAT entry is in the **Available*	- state, the SNAT entry is added.
//
//   - You cannot repeatedly call the **CreateSnatEntry*	- operation to add an SNAT entry to an SNAT table within the specified period of time.
//
//   - The vSwitch and Elastic Compute Service (ECS) instance specified in an SNAT entry must be created in the VPC where the NAT gateway is deployed.
//
//   - Each vSwitch or ECS instance can be specified in only one SNAT entry.
//
//   - If a high-availability virtual IP address (HAVIP) exists in a vSwitch, you cannot create SNAT entries.
//
// @param request - CreateSnatEntryRequest
//
// @return CreateSnatEntryResponse
func (client *Client) CreateSnatEntry(request *CreateSnatEntryRequest) (_result *CreateSnatEntryResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &CreateSnatEntryResponse{}
	_body, _err := client.CreateSnatEntryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates an SSL client certificate.
//
// Description:
//
// Before you create an SSL client certificate, make sure that an SSL server is created on the VPN gateway. For more information, see [CreateSslVpnServer](https://help.aliyun.com/document_detail/2794075.html).
//
// @param request - CreateSslVpnClientCertRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateSslVpnClientCertResponse
func (client *Client) CreateSslVpnClientCertWithOptions(request *CreateSslVpnClientCertRequest, runtime *dara.RuntimeOptions) (_result *CreateSslVpnClientCertResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.Name) {
		query["Name"] = request.Name
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.SslVpnServerId) {
		query["SslVpnServerId"] = request.SslVpnServerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CreateSslVpnClientCert"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &CreateSslVpnClientCertResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Creates an SSL client certificate.
//
// Description:
//
// Before you create an SSL client certificate, make sure that an SSL server is created on the VPN gateway. For more information, see [CreateSslVpnServer](https://help.aliyun.com/document_detail/2794075.html).
//
// @param request - CreateSslVpnClientCertRequest
//
// @return CreateSslVpnClientCertResponse
func (client *Client) CreateSslVpnClientCert(request *CreateSslVpnClientCertRequest) (_result *CreateSslVpnClientCertResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &CreateSslVpnClientCertResponse{}
	_body, _err := client.CreateSslVpnClientCertWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates an SSL server.
//
// Description:
//
//	  **CreateSslVpnServer*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) operation to query the status of the task.
//
//	    	- If the VPN gateway is in the **updating*	- state, the SSL server is being created.
//
//	    	- If the VPN gateway is in the **active*	- state, the SSL server is created.
//
//		- You cannot repeatedly call the **CreateSslVpnServer*	- operation within the specified period of time.
//
// ### [](#)Prerequisite
//
//   - A VPN gateway is created, and the SSL-VPN feature is enabled for the VPN gateway. For more information, see [CreateVpnGateway](https://help.aliyun.com/document_detail/2794049.html).
//
//   - If you want to enable two-factor authentication for the SSL server, make sure that the VPN gateway supports two-factor authentication. You may need to upgrade the VPN gateway. For more information, see [Two-factor authentication supports IDaaS EIAM 2.0](https://help.aliyun.com/document_detail/2785320.html).
//
// @param request - CreateSslVpnServerRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateSslVpnServerResponse
func (client *Client) CreateSslVpnServerWithOptions(request *CreateSslVpnServerRequest, runtime *dara.RuntimeOptions) (_result *CreateSslVpnServerResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.Cipher) {
		query["Cipher"] = request.Cipher
	}

	if !dara.IsNil(request.ClientIpPool) {
		query["ClientIpPool"] = request.ClientIpPool
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.Compress) {
		query["Compress"] = request.Compress
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.EnableMultiFactorAuth) {
		query["EnableMultiFactorAuth"] = request.EnableMultiFactorAuth
	}

	if !dara.IsNil(request.IDaaSApplicationId) {
		query["IDaaSApplicationId"] = request.IDaaSApplicationId
	}

	if !dara.IsNil(request.IDaaSInstanceId) {
		query["IDaaSInstanceId"] = request.IDaaSInstanceId
	}

	if !dara.IsNil(request.IDaaSRegionId) {
		query["IDaaSRegionId"] = request.IDaaSRegionId
	}

	if !dara.IsNil(request.LocalSubnet) {
		query["LocalSubnet"] = request.LocalSubnet
	}

	if !dara.IsNil(request.Name) {
		query["Name"] = request.Name
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.Port) {
		query["Port"] = request.Port
	}

	if !dara.IsNil(request.Proto) {
		query["Proto"] = request.Proto
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.VpnGatewayId) {
		query["VpnGatewayId"] = request.VpnGatewayId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CreateSslVpnServer"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &CreateSslVpnServerResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Creates an SSL server.
//
// Description:
//
//	  **CreateSslVpnServer*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) operation to query the status of the task.
//
//	    	- If the VPN gateway is in the **updating*	- state, the SSL server is being created.
//
//	    	- If the VPN gateway is in the **active*	- state, the SSL server is created.
//
//		- You cannot repeatedly call the **CreateSslVpnServer*	- operation within the specified period of time.
//
// ### [](#)Prerequisite
//
//   - A VPN gateway is created, and the SSL-VPN feature is enabled for the VPN gateway. For more information, see [CreateVpnGateway](https://help.aliyun.com/document_detail/2794049.html).
//
//   - If you want to enable two-factor authentication for the SSL server, make sure that the VPN gateway supports two-factor authentication. You may need to upgrade the VPN gateway. For more information, see [Two-factor authentication supports IDaaS EIAM 2.0](https://help.aliyun.com/document_detail/2785320.html).
//
// @param request - CreateSslVpnServerRequest
//
// @return CreateSslVpnServerResponse
func (client *Client) CreateSslVpnServer(request *CreateSslVpnServerRequest) (_result *CreateSslVpnServerResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &CreateSslVpnServerResponse{}
	_body, _err := client.CreateSslVpnServerWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates a filter for traffic mirror.
//
// Description:
//
// *CreateTrafficMirrorFilter*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListTrafficMirrorFilters](https://help.aliyun.com/document_detail/261353.html) operation to query the status of the task.
//
//   - If the filter is in the **Creating*	- state, the filter is being created.
//
//   - If the filter is in the **Created*	- state, the filter is created.
//
// @param request - CreateTrafficMirrorFilterRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateTrafficMirrorFilterResponse
func (client *Client) CreateTrafficMirrorFilterWithOptions(request *CreateTrafficMirrorFilterRequest, runtime *dara.RuntimeOptions) (_result *CreateTrafficMirrorFilterResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.EgressRules) {
		query["EgressRules"] = request.EgressRules
	}

	if !dara.IsNil(request.IngressRules) {
		query["IngressRules"] = request.IngressRules
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceGroupId) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.Tag) {
		query["Tag"] = request.Tag
	}

	if !dara.IsNil(request.TrafficMirrorFilterDescription) {
		query["TrafficMirrorFilterDescription"] = request.TrafficMirrorFilterDescription
	}

	if !dara.IsNil(request.TrafficMirrorFilterName) {
		query["TrafficMirrorFilterName"] = request.TrafficMirrorFilterName
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CreateTrafficMirrorFilter"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &CreateTrafficMirrorFilterResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Creates a filter for traffic mirror.
//
// Description:
//
// *CreateTrafficMirrorFilter*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListTrafficMirrorFilters](https://help.aliyun.com/document_detail/261353.html) operation to query the status of the task.
//
//   - If the filter is in the **Creating*	- state, the filter is being created.
//
//   - If the filter is in the **Created*	- state, the filter is created.
//
// @param request - CreateTrafficMirrorFilterRequest
//
// @return CreateTrafficMirrorFilterResponse
func (client *Client) CreateTrafficMirrorFilter(request *CreateTrafficMirrorFilterRequest) (_result *CreateTrafficMirrorFilterResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &CreateTrafficMirrorFilterResponse{}
	_body, _err := client.CreateTrafficMirrorFilterWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates an inbound or outbound rule for traffic mirror.
//
// Description:
//
//	  **CreateTrafficMirrorFilterRules*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [ListTrafficMirrorFilters](https://help.aliyun.com/document_detail/261353.html) to query the status of the task.
//
//	    	- If the inbound or outbound rule is in the **Creating*	- state, the rule is being created.
//
//	    	- If the inbound or outbound rule is in the **Created*	- state, the rule is created.
//
//		- You cannot call **CreateTrafficMirrorFilterRules*	- within the specified period of time.
//
// @param request - CreateTrafficMirrorFilterRulesRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateTrafficMirrorFilterRulesResponse
func (client *Client) CreateTrafficMirrorFilterRulesWithOptions(request *CreateTrafficMirrorFilterRulesRequest, runtime *dara.RuntimeOptions) (_result *CreateTrafficMirrorFilterRulesResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.EgressRules) {
		query["EgressRules"] = request.EgressRules
	}

	if !dara.IsNil(request.IngressRules) {
		query["IngressRules"] = request.IngressRules
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.TrafficMirrorFilterId) {
		query["TrafficMirrorFilterId"] = request.TrafficMirrorFilterId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CreateTrafficMirrorFilterRules"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &CreateTrafficMirrorFilterRulesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Creates an inbound or outbound rule for traffic mirror.
//
// Description:
//
//	  **CreateTrafficMirrorFilterRules*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [ListTrafficMirrorFilters](https://help.aliyun.com/document_detail/261353.html) to query the status of the task.
//
//	    	- If the inbound or outbound rule is in the **Creating*	- state, the rule is being created.
//
//	    	- If the inbound or outbound rule is in the **Created*	- state, the rule is created.
//
//		- You cannot call **CreateTrafficMirrorFilterRules*	- within the specified period of time.
//
// @param request - CreateTrafficMirrorFilterRulesRequest
//
// @return CreateTrafficMirrorFilterRulesResponse
func (client *Client) CreateTrafficMirrorFilterRules(request *CreateTrafficMirrorFilterRulesRequest) (_result *CreateTrafficMirrorFilterRulesResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &CreateTrafficMirrorFilterRulesResponse{}
	_body, _err := client.CreateTrafficMirrorFilterRulesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates a traffic mirror session.
//
// Description:
//
// *CreateTrafficMirrorSession*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [ListTrafficMirrorSessions](https://help.aliyun.com/document_detail/261367.html) to query the status of the task.
//
//   - If the traffic mirror session is in the **Creating*	- state, it is being created.
//
//   - If the traffic mirror session is in the **Created*	- state, it is created.
//
// @param request - CreateTrafficMirrorSessionRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateTrafficMirrorSessionResponse
func (client *Client) CreateTrafficMirrorSessionWithOptions(request *CreateTrafficMirrorSessionRequest, runtime *dara.RuntimeOptions) (_result *CreateTrafficMirrorSessionResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.Enabled) {
		query["Enabled"] = request.Enabled
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PacketLength) {
		query["PacketLength"] = request.PacketLength
	}

	if !dara.IsNil(request.Priority) {
		query["Priority"] = request.Priority
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceGroupId) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.Tag) {
		query["Tag"] = request.Tag
	}

	if !dara.IsNil(request.TrafficMirrorFilterId) {
		query["TrafficMirrorFilterId"] = request.TrafficMirrorFilterId
	}

	if !dara.IsNil(request.TrafficMirrorSessionDescription) {
		query["TrafficMirrorSessionDescription"] = request.TrafficMirrorSessionDescription
	}

	if !dara.IsNil(request.TrafficMirrorSessionName) {
		query["TrafficMirrorSessionName"] = request.TrafficMirrorSessionName
	}

	if !dara.IsNil(request.TrafficMirrorSourceIds) {
		query["TrafficMirrorSourceIds"] = request.TrafficMirrorSourceIds
	}

	if !dara.IsNil(request.TrafficMirrorTargetId) {
		query["TrafficMirrorTargetId"] = request.TrafficMirrorTargetId
	}

	if !dara.IsNil(request.TrafficMirrorTargetType) {
		query["TrafficMirrorTargetType"] = request.TrafficMirrorTargetType
	}

	if !dara.IsNil(request.VirtualNetworkId) {
		query["VirtualNetworkId"] = request.VirtualNetworkId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CreateTrafficMirrorSession"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &CreateTrafficMirrorSessionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Creates a traffic mirror session.
//
// Description:
//
// *CreateTrafficMirrorSession*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [ListTrafficMirrorSessions](https://help.aliyun.com/document_detail/261367.html) to query the status of the task.
//
//   - If the traffic mirror session is in the **Creating*	- state, it is being created.
//
//   - If the traffic mirror session is in the **Created*	- state, it is created.
//
// @param request - CreateTrafficMirrorSessionRequest
//
// @return CreateTrafficMirrorSessionResponse
func (client *Client) CreateTrafficMirrorSession(request *CreateTrafficMirrorSessionRequest) (_result *CreateTrafficMirrorSessionResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &CreateTrafficMirrorSessionResponse{}
	_body, _err := client.CreateTrafficMirrorSessionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// 
//
// Description:
//
// When you call this operation, take note of the following limits:
//
//   - You can create at most 150 vSwitches in a virtual private cloud (VPC).
//
//   - The first IP address and last three IP addresses of each vSwitch CIDR block are reserved. For example, if the CIDR block of a vSwitch is 192.168.1.0/24, the IP addresses 192.168.1.0, 192.168.1.253, 192.168.1.254, and 192.168.1.255 are reserved.
//
//   - The number of instances in a vSwitch cannot exceed the remaining capacity of the VPC. The remaining capacity is the difference between 15,000 and the current number of instances.
//
//   - Each instance can belong to only one vSwitch.
//
//   - vSwitches do not support multicast or broadcast.
//
//   - After you create a vSwitch, you cannot modify its CIDR block.
//
//   - **CreateVSwitch*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVSwitchAttributes](https://help.aliyun.com/document_detail/94567.html) to query the status of the task.
//
//   - If the vSwitch is in the **Pending*	- state, the vSwitch is being configured.
//
//   - If the vSwitch is in the **Available*	- state, the vSwitch is available.
//
//   - You cannot repeatedly call the **CreateVSwitch*	- operation to create a vSwitch in a VPC within the specified period of time.
//
// @param request - CreateVSwitchRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateVSwitchResponse
func (client *Client) CreateVSwitchWithOptions(request *CreateVSwitchRequest, runtime *dara.RuntimeOptions) (_result *CreateVSwitchResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.CidrBlock) {
		query["CidrBlock"] = request.CidrBlock
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.Description) {
		query["Description"] = request.Description
	}

	if !dara.IsNil(request.Ipv6CidrBlock) {
		query["Ipv6CidrBlock"] = request.Ipv6CidrBlock
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.Tag) {
		query["Tag"] = request.Tag
	}

	if !dara.IsNil(request.VSwitchName) {
		query["VSwitchName"] = request.VSwitchName
	}

	if !dara.IsNil(request.VpcId) {
		query["VpcId"] = request.VpcId
	}

	if !dara.IsNil(request.VpcIpv6CidrBlock) {
		query["VpcIpv6CidrBlock"] = request.VpcIpv6CidrBlock
	}

	if !dara.IsNil(request.ZoneId) {
		query["ZoneId"] = request.ZoneId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CreateVSwitch"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &CreateVSwitchResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// 
//
// Description:
//
// When you call this operation, take note of the following limits:
//
//   - You can create at most 150 vSwitches in a virtual private cloud (VPC).
//
//   - The first IP address and last three IP addresses of each vSwitch CIDR block are reserved. For example, if the CIDR block of a vSwitch is 192.168.1.0/24, the IP addresses 192.168.1.0, 192.168.1.253, 192.168.1.254, and 192.168.1.255 are reserved.
//
//   - The number of instances in a vSwitch cannot exceed the remaining capacity of the VPC. The remaining capacity is the difference between 15,000 and the current number of instances.
//
//   - Each instance can belong to only one vSwitch.
//
//   - vSwitches do not support multicast or broadcast.
//
//   - After you create a vSwitch, you cannot modify its CIDR block.
//
//   - **CreateVSwitch*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVSwitchAttributes](https://help.aliyun.com/document_detail/94567.html) to query the status of the task.
//
//   - If the vSwitch is in the **Pending*	- state, the vSwitch is being configured.
//
//   - If the vSwitch is in the **Available*	- state, the vSwitch is available.
//
//   - You cannot repeatedly call the **CreateVSwitch*	- operation to create a vSwitch in a VPC within the specified period of time.
//
// @param request - CreateVSwitchRequest
//
// @return CreateVSwitchResponse
func (client *Client) CreateVSwitch(request *CreateVSwitchRequest) (_result *CreateVSwitchResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &CreateVSwitchResponse{}
	_body, _err := client.CreateVSwitchWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates a reserved CIDR block for a vSwitch.
//
// Description:
//
// ## [](#)Description
//
// Take note of the following items:
//
//   - You can create at most 10 reserved IPv4 CIDR blocks and 10 reserved IPv6 CIDR blocks for each vSwitch in a virtual private cloud (VPC).
//
//   - After you create a reserved CIDR block for a vSwitch, the CIDR block cannot contain the IP address of the subnet gateway of the VPC to which the vSwitch belongs.
//
//   - **CreateVSwitchCidrReservation*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [ListVSwitchCidrReservations](https://help.aliyun.com/document_detail/610155.html) to query the status of the task:
//
//   - If the vSwitch is in the **Assigning*	- state, the reserved CIDR block is being created.
//
//   - If the vSwitch is in the **Assigned*	- state, the reserved CIDR block is created.
//
//   - When you create a reserved IPv4 CIDR block for a vSwitch, the first IP address and the last three IP addresses of the vSwitch are reserved by the system. The four IP addresses will not be allocated.
//
//   - When you create a reserved IPv6 CIDR block for a vSwitch, the first IP address and the last nine IP addresses of the vSwitch are reserved by the system. The 10 IP addresses will not be allocated. For example, if you create a reserved IPv4 CIDR block for a vSwitch whose CIDR block is 192.168.1.0/24, the reserved CIDR block cannot contain the following IP addresses: 192.168.1.0, 192.168.1.253, 192.168.1.254, and 192.168.1.255.
//
// @param request - CreateVSwitchCidrReservationRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateVSwitchCidrReservationResponse
func (client *Client) CreateVSwitchCidrReservationWithOptions(request *CreateVSwitchCidrReservationRequest, runtime *dara.RuntimeOptions) (_result *CreateVSwitchCidrReservationResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.IpVersion) {
		query["IpVersion"] = request.IpVersion
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.Tag) {
		query["Tag"] = request.Tag
	}

	if !dara.IsNil(request.VSwitchCidrReservationCidr) {
		query["VSwitchCidrReservationCidr"] = request.VSwitchCidrReservationCidr
	}

	if !dara.IsNil(request.VSwitchCidrReservationDescription) {
		query["VSwitchCidrReservationDescription"] = request.VSwitchCidrReservationDescription
	}

	if !dara.IsNil(request.VSwitchCidrReservationMask) {
		query["VSwitchCidrReservationMask"] = request.VSwitchCidrReservationMask
	}

	if !dara.IsNil(request.VSwitchCidrReservationName) {
		query["VSwitchCidrReservationName"] = request.VSwitchCidrReservationName
	}

	if !dara.IsNil(request.VSwitchCidrReservationType) {
		query["VSwitchCidrReservationType"] = request.VSwitchCidrReservationType
	}

	if !dara.IsNil(request.VSwitchId) {
		query["VSwitchId"] = request.VSwitchId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CreateVSwitchCidrReservation"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &CreateVSwitchCidrReservationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Creates a reserved CIDR block for a vSwitch.
//
// Description:
//
// ## [](#)Description
//
// Take note of the following items:
//
//   - You can create at most 10 reserved IPv4 CIDR blocks and 10 reserved IPv6 CIDR blocks for each vSwitch in a virtual private cloud (VPC).
//
//   - After you create a reserved CIDR block for a vSwitch, the CIDR block cannot contain the IP address of the subnet gateway of the VPC to which the vSwitch belongs.
//
//   - **CreateVSwitchCidrReservation*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [ListVSwitchCidrReservations](https://help.aliyun.com/document_detail/610155.html) to query the status of the task:
//
//   - If the vSwitch is in the **Assigning*	- state, the reserved CIDR block is being created.
//
//   - If the vSwitch is in the **Assigned*	- state, the reserved CIDR block is created.
//
//   - When you create a reserved IPv4 CIDR block for a vSwitch, the first IP address and the last three IP addresses of the vSwitch are reserved by the system. The four IP addresses will not be allocated.
//
//   - When you create a reserved IPv6 CIDR block for a vSwitch, the first IP address and the last nine IP addresses of the vSwitch are reserved by the system. The 10 IP addresses will not be allocated. For example, if you create a reserved IPv4 CIDR block for a vSwitch whose CIDR block is 192.168.1.0/24, the reserved CIDR block cannot contain the following IP addresses: 192.168.1.0, 192.168.1.253, 192.168.1.254, and 192.168.1.255.
//
// @param request - CreateVSwitchCidrReservationRequest
//
// @return CreateVSwitchCidrReservationResponse
func (client *Client) CreateVSwitchCidrReservation(request *CreateVSwitchCidrReservationRequest) (_result *CreateVSwitchCidrReservationResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &CreateVSwitchCidrReservationResponse{}
	_body, _err := client.CreateVSwitchCidrReservationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates a virtual border router (VBR) failover group.
//
// @param request - CreateVbrHaRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateVbrHaResponse
func (client *Client) CreateVbrHaWithOptions(request *CreateVbrHaRequest, runtime *dara.RuntimeOptions) (_result *CreateVbrHaResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.Description) {
		query["Description"] = request.Description
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.Name) {
		query["Name"] = request.Name
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PeerVbrId) {
		query["PeerVbrId"] = request.PeerVbrId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.VbrId) {
		query["VbrId"] = request.VbrId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CreateVbrHa"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &CreateVbrHaResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Creates a virtual border router (VBR) failover group.
//
// @param request - CreateVbrHaRequest
//
// @return CreateVbrHaResponse
func (client *Client) CreateVbrHa(request *CreateVbrHaRequest) (_result *CreateVbrHaResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &CreateVbrHaResponse{}
	_body, _err := client.CreateVbrHaWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Adds a destination-based route for an IPsec-VPN connection.
//
// Description:
//
//	  The IPsec-VPN connection must be associated with a transit router. For more information, see [CreateTransitRouterVpnAttachment](https://help.aliyun.com/document_detail/468249.html).
//
//		- You cannot create a destination-based route whose destination CIDR block is 0.0.0.0/0.
//
//		- Do not add a destination-based route whose destination CIDR block is 100.64.0.0/10, or a CIDR block that contains 100.64.0.0/10 or belongs to 100.64.0.0/10. Such a route will make the console fail to display the status of the IPsec-VPN connection or cause IPsec negotiation failures.
//
//		- **CreateVcoRouteEntry*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnConnection](https://help.aliyun.com/document_detail/53046.html) to query the status of the task.
//
//	    	- If the IPsec-VPN connection is in the **updating*	- state, the destination-based route is being created.
//
//	    	- If the IPsec-VPN connection is in the **attached*	- state, the destination-based route is created.
//
//		- You cannot repeatedly call **CreateVcoRouteEntry*	- within the specified period of time.
//
// @param request - CreateVcoRouteEntryRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateVcoRouteEntryResponse
func (client *Client) CreateVcoRouteEntryWithOptions(request *CreateVcoRouteEntryRequest, runtime *dara.RuntimeOptions) (_result *CreateVcoRouteEntryResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.Description) {
		query["Description"] = request.Description
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.NextHop) {
		query["NextHop"] = request.NextHop
	}

	if !dara.IsNil(request.OverlayMode) {
		query["OverlayMode"] = request.OverlayMode
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.RouteDest) {
		query["RouteDest"] = request.RouteDest
	}

	if !dara.IsNil(request.VpnConnectionId) {
		query["VpnConnectionId"] = request.VpnConnectionId
	}

	if !dara.IsNil(request.Weight) {
		query["Weight"] = request.Weight
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CreateVcoRouteEntry"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &CreateVcoRouteEntryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Adds a destination-based route for an IPsec-VPN connection.
//
// Description:
//
//	  The IPsec-VPN connection must be associated with a transit router. For more information, see [CreateTransitRouterVpnAttachment](https://help.aliyun.com/document_detail/468249.html).
//
//		- You cannot create a destination-based route whose destination CIDR block is 0.0.0.0/0.
//
//		- Do not add a destination-based route whose destination CIDR block is 100.64.0.0/10, or a CIDR block that contains 100.64.0.0/10 or belongs to 100.64.0.0/10. Such a route will make the console fail to display the status of the IPsec-VPN connection or cause IPsec negotiation failures.
//
//		- **CreateVcoRouteEntry*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnConnection](https://help.aliyun.com/document_detail/53046.html) to query the status of the task.
//
//	    	- If the IPsec-VPN connection is in the **updating*	- state, the destination-based route is being created.
//
//	    	- If the IPsec-VPN connection is in the **attached*	- state, the destination-based route is created.
//
//		- You cannot repeatedly call **CreateVcoRouteEntry*	- within the specified period of time.
//
// @param request - CreateVcoRouteEntryRequest
//
// @return CreateVcoRouteEntryResponse
func (client *Client) CreateVcoRouteEntry(request *CreateVcoRouteEntryRequest) (_result *CreateVcoRouteEntryResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &CreateVcoRouteEntryResponse{}
	_body, _err := client.CreateVcoRouteEntryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates a virtual border router (VBR).
//
// Description:
//
// After you create a VBR, the VBR is in the **active*	- state.
//
// @param request - CreateVirtualBorderRouterRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateVirtualBorderRouterResponse
func (client *Client) CreateVirtualBorderRouterWithOptions(request *CreateVirtualBorderRouterRequest, runtime *dara.RuntimeOptions) (_result *CreateVirtualBorderRouterResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.Bandwidth) {
		query["Bandwidth"] = request.Bandwidth
	}

	if !dara.IsNil(request.CircuitCode) {
		query["CircuitCode"] = request.CircuitCode
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.Description) {
		query["Description"] = request.Description
	}

	if !dara.IsNil(request.EnableIpv6) {
		query["EnableIpv6"] = request.EnableIpv6
	}

	if !dara.IsNil(request.LocalGatewayIp) {
		query["LocalGatewayIp"] = request.LocalGatewayIp
	}

	if !dara.IsNil(request.LocalIpv6GatewayIp) {
		query["LocalIpv6GatewayIp"] = request.LocalIpv6GatewayIp
	}

	if !dara.IsNil(request.Name) {
		query["Name"] = request.Name
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PeerGatewayIp) {
		query["PeerGatewayIp"] = request.PeerGatewayIp
	}

	if !dara.IsNil(request.PeerIpv6GatewayIp) {
		query["PeerIpv6GatewayIp"] = request.PeerIpv6GatewayIp
	}

	if !dara.IsNil(request.PeeringIpv6SubnetMask) {
		query["PeeringIpv6SubnetMask"] = request.PeeringIpv6SubnetMask
	}

	if !dara.IsNil(request.PeeringSubnetMask) {
		query["PeeringSubnetMask"] = request.PeeringSubnetMask
	}

	if !dara.IsNil(request.PhysicalConnectionId) {
		query["PhysicalConnectionId"] = request.PhysicalConnectionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceGroupId) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.Tags) {
		query["Tags"] = request.Tags
	}

	if !dara.IsNil(request.VbrOwnerId) {
		query["VbrOwnerId"] = request.VbrOwnerId
	}

	if !dara.IsNil(request.VlanId) {
		query["VlanId"] = request.VlanId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CreateVirtualBorderRouter"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &CreateVirtualBorderRouterResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Creates a virtual border router (VBR).
//
// Description:
//
// After you create a VBR, the VBR is in the **active*	- state.
//
// @param request - CreateVirtualBorderRouterRequest
//
// @return CreateVirtualBorderRouterResponse
func (client *Client) CreateVirtualBorderRouter(request *CreateVirtualBorderRouterRequest) (_result *CreateVirtualBorderRouterResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &CreateVirtualBorderRouterResponse{}
	_body, _err := client.CreateVirtualBorderRouterWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates a hosted connection over Express Connect circuit.
//
// Description:
//
// # [](#)Description
//
// Before you call this operation, we recommend that you learn about the workflow for creating a hosted connection and the environment requirements. For more information, see [Overview of hosted connections](https://help.aliyun.com/document_detail/146571.html) and [Operations performed by Express Connect partners](https://help.aliyun.com/document_detail/155987.html).
//
// @param request - CreateVirtualPhysicalConnectionRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateVirtualPhysicalConnectionResponse
func (client *Client) CreateVirtualPhysicalConnectionWithOptions(request *CreateVirtualPhysicalConnectionRequest, runtime *dara.RuntimeOptions) (_result *CreateVirtualPhysicalConnectionResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.Description) {
		query["Description"] = request.Description
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.Name) {
		query["Name"] = request.Name
	}

	if !dara.IsNil(request.OrderMode) {
		query["OrderMode"] = request.OrderMode
	}

	if !dara.IsNil(request.PhysicalConnectionId) {
		query["PhysicalConnectionId"] = request.PhysicalConnectionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceGroupId) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !dara.IsNil(request.Spec) {
		query["Spec"] = request.Spec
	}

	if !dara.IsNil(request.Tag) {
		query["Tag"] = request.Tag
	}

	if !dara.IsNil(request.Token) {
		query["Token"] = request.Token
	}

	if !dara.IsNil(request.VlanId) {
		query["VlanId"] = request.VlanId
	}

	if !dara.IsNil(request.VpconnAliUid) {
		query["VpconnAliUid"] = request.VpconnAliUid
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CreateVirtualPhysicalConnection"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &CreateVirtualPhysicalConnectionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Creates a hosted connection over Express Connect circuit.
//
// Description:
//
// # [](#)Description
//
// Before you call this operation, we recommend that you learn about the workflow for creating a hosted connection and the environment requirements. For more information, see [Overview of hosted connections](https://help.aliyun.com/document_detail/146571.html) and [Operations performed by Express Connect partners](https://help.aliyun.com/document_detail/155987.html).
//
// @param request - CreateVirtualPhysicalConnectionRequest
//
// @return CreateVirtualPhysicalConnectionResponse
func (client *Client) CreateVirtualPhysicalConnection(request *CreateVirtualPhysicalConnectionRequest) (_result *CreateVirtualPhysicalConnectionResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &CreateVirtualPhysicalConnectionResponse{}
	_body, _err := client.CreateVirtualPhysicalConnectionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates a virtual private cloud (VPC).
//
// Description:
//
// When you call this operation, take note of the following items:
//
//   - You can specify only one CIDR block for each VPC.
//
//   - After you create a VPC, you cannot change its CIDR block. However, you can add secondary IPv4 CIDR blocks to the VPC.
//
//   - In each VPC, cloud services can use a maximum of 60,000 private IP addresses. You cannot increase the quota.
//
//   - After you create a VPC, a vRouter and a route table are automatically created.
//
//   - At most three user CIDR blocks can be added to a VPC. If a user CIDR block includes another user CIDR block, the one with the shorter subnet mask takes effect. For example, if both 10.0.0.0/8 and 10.1.0.0/16 are specified, only 10.0.0.0/8 takes effect.
//
//   - **CreateVpc*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpcAttribute](https://help.aliyun.com/document_detail/94565.html) operation to query the status of the task:
//
//   - If the VPC is in the **Creating*	- state, the VPC is being created.
//
//   - If the VPC is in the **Created*	- state, the VPC is created.
//
//   - You cannot repeatedly call the **DeleteRouteEntry*	- operation to create default VPCs within a specific time period. However, you can repeatedly call this operation to create custom VPCs within a specific time period.
//
// @param request - CreateVpcRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateVpcResponse
func (client *Client) CreateVpcWithOptions(request *CreateVpcRequest, runtime *dara.RuntimeOptions) (_result *CreateVpcResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.CidrBlock) {
		query["CidrBlock"] = request.CidrBlock
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.Description) {
		query["Description"] = request.Description
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.EnableDnsHostname) {
		query["EnableDnsHostname"] = request.EnableDnsHostname
	}

	if !dara.IsNil(request.EnableIpv6) {
		query["EnableIpv6"] = request.EnableIpv6
	}

	if !dara.IsNil(request.Ipv4CidrMask) {
		query["Ipv4CidrMask"] = request.Ipv4CidrMask
	}

	if !dara.IsNil(request.Ipv4IpamPoolId) {
		query["Ipv4IpamPoolId"] = request.Ipv4IpamPoolId
	}

	if !dara.IsNil(request.Ipv6CidrBlock) {
		query["Ipv6CidrBlock"] = request.Ipv6CidrBlock
	}

	if !dara.IsNil(request.Ipv6CidrMask) {
		query["Ipv6CidrMask"] = request.Ipv6CidrMask
	}

	if !dara.IsNil(request.Ipv6IpamPoolId) {
		query["Ipv6IpamPoolId"] = request.Ipv6IpamPoolId
	}

	if !dara.IsNil(request.Ipv6Isp) {
		query["Ipv6Isp"] = request.Ipv6Isp
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceGroupId) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.Tag) {
		query["Tag"] = request.Tag
	}

	if !dara.IsNil(request.UserCidr) {
		query["UserCidr"] = request.UserCidr
	}

	if !dara.IsNil(request.VpcName) {
		query["VpcName"] = request.VpcName
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CreateVpc"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &CreateVpcResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Creates a virtual private cloud (VPC).
//
// Description:
//
// When you call this operation, take note of the following items:
//
//   - You can specify only one CIDR block for each VPC.
//
//   - After you create a VPC, you cannot change its CIDR block. However, you can add secondary IPv4 CIDR blocks to the VPC.
//
//   - In each VPC, cloud services can use a maximum of 60,000 private IP addresses. You cannot increase the quota.
//
//   - After you create a VPC, a vRouter and a route table are automatically created.
//
//   - At most three user CIDR blocks can be added to a VPC. If a user CIDR block includes another user CIDR block, the one with the shorter subnet mask takes effect. For example, if both 10.0.0.0/8 and 10.1.0.0/16 are specified, only 10.0.0.0/8 takes effect.
//
//   - **CreateVpc*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpcAttribute](https://help.aliyun.com/document_detail/94565.html) operation to query the status of the task:
//
//   - If the VPC is in the **Creating*	- state, the VPC is being created.
//
//   - If the VPC is in the **Created*	- state, the VPC is created.
//
//   - You cannot repeatedly call the **DeleteRouteEntry*	- operation to create default VPCs within a specific time period. However, you can repeatedly call this operation to create custom VPCs within a specific time period.
//
// @param request - CreateVpcRequest
//
// @return CreateVpcResponse
func (client *Client) CreateVpc(request *CreateVpcRequest) (_result *CreateVpcResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &CreateVpcResponse{}
	_body, _err := client.CreateVpcWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates a gateway endpoint.
//
// Description:
//
//	  **CreateVpcGatewayEndpoint*	- is an asynchronous operation. After a request is sent, the system returns an **EndpointId*	- and runs the task in the background. You can call the [ListVpcGatewayEndpoints](https://help.aliyun.com/document_detail/448682.html) operation to query the status of the task.
//
//	    	- If the gateway endpoint is in the **Creating*	- state, the gateway endpoint is being created.
//
//	    	- If the gateway endpoint is in the **Created*	- state, the gateway endpoint is created.
//
//		- You cannot repeatedly call the **CreateVpcGatewayEndpoint*	- operation for the same endpoint service within the specified period of time.
//
// @param request - CreateVpcGatewayEndpointRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateVpcGatewayEndpointResponse
func (client *Client) CreateVpcGatewayEndpointWithOptions(request *CreateVpcGatewayEndpointRequest, runtime *dara.RuntimeOptions) (_result *CreateVpcGatewayEndpointResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.EndpointDescription) {
		query["EndpointDescription"] = request.EndpointDescription
	}

	if !dara.IsNil(request.EndpointName) {
		query["EndpointName"] = request.EndpointName
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PolicyDocument) {
		query["PolicyDocument"] = request.PolicyDocument
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceGroupId) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.ServiceName) {
		query["ServiceName"] = request.ServiceName
	}

	if !dara.IsNil(request.Tag) {
		query["Tag"] = request.Tag
	}

	if !dara.IsNil(request.VpcId) {
		query["VpcId"] = request.VpcId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CreateVpcGatewayEndpoint"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &CreateVpcGatewayEndpointResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Creates a gateway endpoint.
//
// Description:
//
//	  **CreateVpcGatewayEndpoint*	- is an asynchronous operation. After a request is sent, the system returns an **EndpointId*	- and runs the task in the background. You can call the [ListVpcGatewayEndpoints](https://help.aliyun.com/document_detail/448682.html) operation to query the status of the task.
//
//	    	- If the gateway endpoint is in the **Creating*	- state, the gateway endpoint is being created.
//
//	    	- If the gateway endpoint is in the **Created*	- state, the gateway endpoint is created.
//
//		- You cannot repeatedly call the **CreateVpcGatewayEndpoint*	- operation for the same endpoint service within the specified period of time.
//
// @param request - CreateVpcGatewayEndpointRequest
//
// @return CreateVpcGatewayEndpointResponse
func (client *Client) CreateVpcGatewayEndpoint(request *CreateVpcGatewayEndpointRequest) (_result *CreateVpcGatewayEndpointResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &CreateVpcGatewayEndpointResponse{}
	_body, _err := client.CreateVpcGatewayEndpointWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates a prefix list.
//
// Description:
//
// You cannot repeatedly call the **CreateVpcPrefixList*	- operation within the specified period of time.
//
// @param request - CreateVpcPrefixListRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateVpcPrefixListResponse
func (client *Client) CreateVpcPrefixListWithOptions(request *CreateVpcPrefixListRequest, runtime *dara.RuntimeOptions) (_result *CreateVpcPrefixListResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.IpVersion) {
		query["IpVersion"] = request.IpVersion
	}

	if !dara.IsNil(request.MaxEntries) {
		query["MaxEntries"] = request.MaxEntries
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PrefixListDescription) {
		query["PrefixListDescription"] = request.PrefixListDescription
	}

	if !dara.IsNil(request.PrefixListEntries) {
		query["PrefixListEntries"] = request.PrefixListEntries
	}

	if !dara.IsNil(request.PrefixListName) {
		query["PrefixListName"] = request.PrefixListName
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceGroupId) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.Tag) {
		query["Tag"] = request.Tag
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CreateVpcPrefixList"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &CreateVpcPrefixListResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Creates a prefix list.
//
// Description:
//
// You cannot repeatedly call the **CreateVpcPrefixList*	- operation within the specified period of time.
//
// @param request - CreateVpcPrefixListRequest
//
// @return CreateVpcPrefixListResponse
func (client *Client) CreateVpcPrefixList(request *CreateVpcPrefixListRequest) (_result *CreateVpcPrefixListResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &CreateVpcPrefixListResponse{}
	_body, _err := client.CreateVpcPrefixListWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Adds a shared port to a hosted connection.
//
// Description:
//
// If an Express Connect partner has created a virtual border router (VBR) for a tenant before, the Express Connect partner can push the Express Connect circuit that is associated with the VBR to the tenant account by adding a shared port for the tenant account. The service of the tenant is not interrupted in this process.
//
// Preparations:
//
// Before the Express Connect partner performs the operation, the Express Connect partner must notify the tenant and request the tenant to enable outbound data transfer billing. For more information, see [Enable outbound data transfer billing](https://help.aliyun.com/document_detail/274385.html).
//
// What to do next:
//
// 1.  After the Express Connect partner performs the operation, a shared port is added for the tenant account. The tenant must call the [ConfirmPhysicalConnection](https://help.aliyun.com/document_detail/324198.html) operation to accept the shared port.
//
// 2.  Then, the Express Connect partner must call the [AttachVbrToVpconn](https://help.aliyun.com/document_detail/324191.html) operation to associate the VBR with the newly added shared port that belongs to the tenant account.
//
// @param request - CreateVpconnFromVbrRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateVpconnFromVbrResponse
func (client *Client) CreateVpconnFromVbrWithOptions(request *CreateVpconnFromVbrRequest, runtime *dara.RuntimeOptions) (_result *CreateVpconnFromVbrResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.OrderMode) {
		query["OrderMode"] = request.OrderMode
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.Token) {
		query["Token"] = request.Token
	}

	if !dara.IsNil(request.VbrId) {
		query["VbrId"] = request.VbrId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CreateVpconnFromVbr"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &CreateVpconnFromVbrResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Adds a shared port to a hosted connection.
//
// Description:
//
// If an Express Connect partner has created a virtual border router (VBR) for a tenant before, the Express Connect partner can push the Express Connect circuit that is associated with the VBR to the tenant account by adding a shared port for the tenant account. The service of the tenant is not interrupted in this process.
//
// Preparations:
//
// Before the Express Connect partner performs the operation, the Express Connect partner must notify the tenant and request the tenant to enable outbound data transfer billing. For more information, see [Enable outbound data transfer billing](https://help.aliyun.com/document_detail/274385.html).
//
// What to do next:
//
// 1.  After the Express Connect partner performs the operation, a shared port is added for the tenant account. The tenant must call the [ConfirmPhysicalConnection](https://help.aliyun.com/document_detail/324198.html) operation to accept the shared port.
//
// 2.  Then, the Express Connect partner must call the [AttachVbrToVpconn](https://help.aliyun.com/document_detail/324191.html) operation to associate the VBR with the newly added shared port that belongs to the tenant account.
//
// @param request - CreateVpconnFromVbrRequest
//
// @return CreateVpconnFromVbrResponse
func (client *Client) CreateVpconnFromVbr(request *CreateVpconnFromVbrRequest) (_result *CreateVpconnFromVbrResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &CreateVpconnFromVbrResponse{}
	_body, _err := client.CreateVpconnFromVbrWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates an IPsec-VPN connection. After you create the IPsec-VPN connection, you can associate the IPsec-VPN connection with a transit router.
//
// Description:
//
//	  By default, the IPsec-VPN connection created by calling the `CreateVpnAttachment` operation is not bound to any resources. You can call the [CreateTransitRouterVpnAttachment](https://help.aliyun.com/document_detail/443993.html) operation to bind the IPsec-VPN connection to a transit router.
//
//		- If you want to associate an IPsec-VPN connection with a transit router, you can create a dual-tunnel connection in some regions. For more information, see [Dual-tunnel IPsec-VPN connections](https://help.aliyun.com/document_detail/2853535.html).
//
//	    	- When you create a IPsec-VPN connection in dual tunnel mode, you can configure the following request parameters in addition to the required parameters: **ClientToken**, **Name**, **NetworkType**, **EffectImmediately**, **AutoConfigRoute**, **Tags*	- array, **ResourceGroupId**, **TunnelOptionsSpecification*	- array, and **EnableTunnelsBgp**.
//
//	    	- When you create a IPsec-VPN connection in single tunnel mode, you can configure the following request parameters in addition to the required parameters: **ClientToken**, **CustomerGatewayId**, **NetworkType**, **Name**, **EffectImmediately**, **IkeConfig**, **IpsecConfig**, **HealthCheckConfig**, **AutoConfigRoute**, **EnableDpd**, **EnableNatTraversal**, **BgpConfig**, **Tags*	- array, and **ResourceGroupId**.
//
// ### [](#)Prerequisites
//
// Before you create an IPsec-VPN connection, you must create a customer gateway in the region where you want to create the IPsec-VPN connection. For more information, see [CreateCustomerGateway](https://help.aliyun.com/document_detail/120368.html).
//
// If you want to add BGP configurations to an IPsec-VPN connection, make sure that an autonomous system number (ASN) is assigned to the customer gateway.
//
// @param request - CreateVpnAttachmentRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateVpnAttachmentResponse
func (client *Client) CreateVpnAttachmentWithOptions(request *CreateVpnAttachmentRequest, runtime *dara.RuntimeOptions) (_result *CreateVpnAttachmentResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.AutoConfigRoute) {
		query["AutoConfigRoute"] = request.AutoConfigRoute
	}

	if !dara.IsNil(request.BgpConfig) {
		query["BgpConfig"] = request.BgpConfig
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.CustomerGatewayId) {
		query["CustomerGatewayId"] = request.CustomerGatewayId
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.EffectImmediately) {
		query["EffectImmediately"] = request.EffectImmediately
	}

	if !dara.IsNil(request.EnableDpd) {
		query["EnableDpd"] = request.EnableDpd
	}

	if !dara.IsNil(request.EnableNatTraversal) {
		query["EnableNatTraversal"] = request.EnableNatTraversal
	}

	if !dara.IsNil(request.EnableTunnelsBgp) {
		query["EnableTunnelsBgp"] = request.EnableTunnelsBgp
	}

	if !dara.IsNil(request.HealthCheckConfig) {
		query["HealthCheckConfig"] = request.HealthCheckConfig
	}

	if !dara.IsNil(request.IkeConfig) {
		query["IkeConfig"] = request.IkeConfig
	}

	if !dara.IsNil(request.IpsecConfig) {
		query["IpsecConfig"] = request.IpsecConfig
	}

	if !dara.IsNil(request.LocalSubnet) {
		query["LocalSubnet"] = request.LocalSubnet
	}

	if !dara.IsNil(request.Name) {
		query["Name"] = request.Name
	}

	if !dara.IsNil(request.NetworkType) {
		query["NetworkType"] = request.NetworkType
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.RemoteCaCert) {
		query["RemoteCaCert"] = request.RemoteCaCert
	}

	if !dara.IsNil(request.RemoteSubnet) {
		query["RemoteSubnet"] = request.RemoteSubnet
	}

	if !dara.IsNil(request.ResourceGroupId) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.Tags) {
		query["Tags"] = request.Tags
	}

	body := map[string]interface{}{}
	bodyFlat := map[string]interface{}{}
	if !dara.IsNil(request.TunnelOptionsSpecification) {
		bodyFlat["TunnelOptionsSpecification"] = request.TunnelOptionsSpecification
	}

	body = dara.ToMap(body,
		openapiutil.Query(bodyFlat))
	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
		Body:  openapiutil.ParseToMap(body),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CreateVpnAttachment"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &CreateVpnAttachmentResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Creates an IPsec-VPN connection. After you create the IPsec-VPN connection, you can associate the IPsec-VPN connection with a transit router.
//
// Description:
//
//	  By default, the IPsec-VPN connection created by calling the `CreateVpnAttachment` operation is not bound to any resources. You can call the [CreateTransitRouterVpnAttachment](https://help.aliyun.com/document_detail/443993.html) operation to bind the IPsec-VPN connection to a transit router.
//
//		- If you want to associate an IPsec-VPN connection with a transit router, you can create a dual-tunnel connection in some regions. For more information, see [Dual-tunnel IPsec-VPN connections](https://help.aliyun.com/document_detail/2853535.html).
//
//	    	- When you create a IPsec-VPN connection in dual tunnel mode, you can configure the following request parameters in addition to the required parameters: **ClientToken**, **Name**, **NetworkType**, **EffectImmediately**, **AutoConfigRoute**, **Tags*	- array, **ResourceGroupId**, **TunnelOptionsSpecification*	- array, and **EnableTunnelsBgp**.
//
//	    	- When you create a IPsec-VPN connection in single tunnel mode, you can configure the following request parameters in addition to the required parameters: **ClientToken**, **CustomerGatewayId**, **NetworkType**, **Name**, **EffectImmediately**, **IkeConfig**, **IpsecConfig**, **HealthCheckConfig**, **AutoConfigRoute**, **EnableDpd**, **EnableNatTraversal**, **BgpConfig**, **Tags*	- array, and **ResourceGroupId**.
//
// ### [](#)Prerequisites
//
// Before you create an IPsec-VPN connection, you must create a customer gateway in the region where you want to create the IPsec-VPN connection. For more information, see [CreateCustomerGateway](https://help.aliyun.com/document_detail/120368.html).
//
// If you want to add BGP configurations to an IPsec-VPN connection, make sure that an autonomous system number (ASN) is assigned to the customer gateway.
//
// @param request - CreateVpnAttachmentRequest
//
// @return CreateVpnAttachmentResponse
func (client *Client) CreateVpnAttachment(request *CreateVpnAttachmentRequest) (_result *CreateVpnAttachmentResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &CreateVpnAttachmentResponse{}
	_body, _err := client.CreateVpnAttachmentWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates an IPsec-VPN connection.
//
// Description:
//
//	  If the VPN gateway supports the dual-tunnel mode, you can specify the following parameters in addition to the required parameters when you call `CreateVpnConnection`:
//
//	    **ClientToken**, **Name**, **EffectImmediately**, **AutoConfigRoute**, **Tags*	- array, **TunnelOptionsSpecification*	- array, and **EnableTunnelsBgp**.
//
//	    For more information about the regions and zones that support the dual-tunnel mode, see [IPsec-VPN connections support the dual-tunnel mode](https://help.aliyun.com/document_detail/2358946.html).
//
//		- If the VPN gateway supports only the dual-tunnel mode, you can specify the following parameters in addition to the required parameters when you call `CreateVpnConnection`:
//
//	    **ClientToken**, **CustomerGatewayId**, **Name**, **EffectImmediately**, **IkeConfig**, **IpsecConfig**, **HealthCheckConfig**, **AutoConfigRoute**, **EnableDpd**, **EnableNatTraversal**, **BgpConfig**, **RemoteCaCertificate**, and **Tags*	- array.
//
//		- **CreateVpnConnection*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
//
//	    	- If the VPN gateway is in the **updating*	- state, the IPsec-VPN connection is being created.
//
//	    	- If the VPN gateway is in the **active*	- state, the IPsec-VPN connection is created.
//
//		- You cannot call **CreateVpnConnection*	- to create multiple IPsec-VPN connections associated with a VPN gateway at the same time.
//
// @param request - CreateVpnConnectionRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateVpnConnectionResponse
func (client *Client) CreateVpnConnectionWithOptions(request *CreateVpnConnectionRequest, runtime *dara.RuntimeOptions) (_result *CreateVpnConnectionResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.AutoConfigRoute) {
		query["AutoConfigRoute"] = request.AutoConfigRoute
	}

	if !dara.IsNil(request.BgpConfig) {
		query["BgpConfig"] = request.BgpConfig
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.CustomerGatewayId) {
		query["CustomerGatewayId"] = request.CustomerGatewayId
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.EffectImmediately) {
		query["EffectImmediately"] = request.EffectImmediately
	}

	if !dara.IsNil(request.EnableDpd) {
		query["EnableDpd"] = request.EnableDpd
	}

	if !dara.IsNil(request.EnableNatTraversal) {
		query["EnableNatTraversal"] = request.EnableNatTraversal
	}

	if !dara.IsNil(request.EnableTunnelsBgp) {
		query["EnableTunnelsBgp"] = request.EnableTunnelsBgp
	}

	if !dara.IsNil(request.HealthCheckConfig) {
		query["HealthCheckConfig"] = request.HealthCheckConfig
	}

	if !dara.IsNil(request.IkeConfig) {
		query["IkeConfig"] = request.IkeConfig
	}

	if !dara.IsNil(request.IpsecConfig) {
		query["IpsecConfig"] = request.IpsecConfig
	}

	if !dara.IsNil(request.LocalSubnet) {
		query["LocalSubnet"] = request.LocalSubnet
	}

	if !dara.IsNil(request.Name) {
		query["Name"] = request.Name
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.RemoteCaCertificate) {
		query["RemoteCaCertificate"] = request.RemoteCaCertificate
	}

	if !dara.IsNil(request.RemoteSubnet) {
		query["RemoteSubnet"] = request.RemoteSubnet
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.Tags) {
		query["Tags"] = request.Tags
	}

	if !dara.IsNil(request.VpnGatewayId) {
		query["VpnGatewayId"] = request.VpnGatewayId
	}

	body := map[string]interface{}{}
	bodyFlat := map[string]interface{}{}
	if !dara.IsNil(request.TunnelOptionsSpecification) {
		bodyFlat["TunnelOptionsSpecification"] = request.TunnelOptionsSpecification
	}

	body = dara.ToMap(body,
		openapiutil.Query(bodyFlat))
	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
		Body:  openapiutil.ParseToMap(body),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CreateVpnConnection"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &CreateVpnConnectionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Creates an IPsec-VPN connection.
//
// Description:
//
//	  If the VPN gateway supports the dual-tunnel mode, you can specify the following parameters in addition to the required parameters when you call `CreateVpnConnection`:
//
//	    **ClientToken**, **Name**, **EffectImmediately**, **AutoConfigRoute**, **Tags*	- array, **TunnelOptionsSpecification*	- array, and **EnableTunnelsBgp**.
//
//	    For more information about the regions and zones that support the dual-tunnel mode, see [IPsec-VPN connections support the dual-tunnel mode](https://help.aliyun.com/document_detail/2358946.html).
//
//		- If the VPN gateway supports only the dual-tunnel mode, you can specify the following parameters in addition to the required parameters when you call `CreateVpnConnection`:
//
//	    **ClientToken**, **CustomerGatewayId**, **Name**, **EffectImmediately**, **IkeConfig**, **IpsecConfig**, **HealthCheckConfig**, **AutoConfigRoute**, **EnableDpd**, **EnableNatTraversal**, **BgpConfig**, **RemoteCaCertificate**, and **Tags*	- array.
//
//		- **CreateVpnConnection*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
//
//	    	- If the VPN gateway is in the **updating*	- state, the IPsec-VPN connection is being created.
//
//	    	- If the VPN gateway is in the **active*	- state, the IPsec-VPN connection is created.
//
//		- You cannot call **CreateVpnConnection*	- to create multiple IPsec-VPN connections associated with a VPN gateway at the same time.
//
// @param request - CreateVpnConnectionRequest
//
// @return CreateVpnConnectionResponse
func (client *Client) CreateVpnConnection(request *CreateVpnConnectionRequest) (_result *CreateVpnConnectionResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &CreateVpnConnectionResponse{}
	_body, _err := client.CreateVpnConnectionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates a VPN gateway.
//
// Description:
//
//	  Before you create a VPN gateway, we recommend that you know more about the limits of VPN gateways. For more information, see the [Limits](https://help.aliyun.com/document_detail/65290.html) section in the "Create and manage a VPN gateway" topic.
//
//		- VPN gateways in some regions support only IPsec-VPN connections in dual-tunnel mode. If you call `CreateVpnGateway` in these regions, you must specify **VSwitchId*	- and **DisasterRecoveryVSwitchId*	- in addition to the required parameters. For more information about the regions and zones that support the IPsec-VPN connections in dual-tunnel mode, see [IPsec-VPN connections support the dual-tunnel mode](https://help.aliyun.com/document_detail/2358946.html).
//
//		- **CreateVpnGateway*	- is an asynchronous operation. After you send a request to call this operation, the system returns a request ID and the endpoint service is being created in the backend. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of a VPN gateway.
//
//	    	- If the VPN gateway is in the **provisioning*	- state, the VPN gateway is being created.
//
//	    	- If the VPN gateway is in the **active*	- state, the VPN gateway is created.
//
// @param request - CreateVpnGatewayRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateVpnGatewayResponse
func (client *Client) CreateVpnGatewayWithOptions(request *CreateVpnGatewayRequest, runtime *dara.RuntimeOptions) (_result *CreateVpnGatewayResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.AutoPay) {
		query["AutoPay"] = request.AutoPay
	}

	if !dara.IsNil(request.Bandwidth) {
		query["Bandwidth"] = request.Bandwidth
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DisasterRecoveryVSwitchId) {
		query["DisasterRecoveryVSwitchId"] = request.DisasterRecoveryVSwitchId
	}

	if !dara.IsNil(request.EnableIpsec) {
		query["EnableIpsec"] = request.EnableIpsec
	}

	if !dara.IsNil(request.EnableSsl) {
		query["EnableSsl"] = request.EnableSsl
	}

	if !dara.IsNil(request.InstanceChargeType) {
		query["InstanceChargeType"] = request.InstanceChargeType
	}

	if !dara.IsNil(request.Name) {
		query["Name"] = request.Name
	}

	if !dara.IsNil(request.NetworkType) {
		query["NetworkType"] = request.NetworkType
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.Period) {
		query["Period"] = request.Period
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceGroupId) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.SslConnections) {
		query["SslConnections"] = request.SslConnections
	}

	if !dara.IsNil(request.VSwitchId) {
		query["VSwitchId"] = request.VSwitchId
	}

	if !dara.IsNil(request.VpcId) {
		query["VpcId"] = request.VpcId
	}

	if !dara.IsNil(request.VpnType) {
		query["VpnType"] = request.VpnType
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CreateVpnGateway"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &CreateVpnGatewayResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Creates a VPN gateway.
//
// Description:
//
//	  Before you create a VPN gateway, we recommend that you know more about the limits of VPN gateways. For more information, see the [Limits](https://help.aliyun.com/document_detail/65290.html) section in the "Create and manage a VPN gateway" topic.
//
//		- VPN gateways in some regions support only IPsec-VPN connections in dual-tunnel mode. If you call `CreateVpnGateway` in these regions, you must specify **VSwitchId*	- and **DisasterRecoveryVSwitchId*	- in addition to the required parameters. For more information about the regions and zones that support the IPsec-VPN connections in dual-tunnel mode, see [IPsec-VPN connections support the dual-tunnel mode](https://help.aliyun.com/document_detail/2358946.html).
//
//		- **CreateVpnGateway*	- is an asynchronous operation. After you send a request to call this operation, the system returns a request ID and the endpoint service is being created in the backend. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of a VPN gateway.
//
//	    	- If the VPN gateway is in the **provisioning*	- state, the VPN gateway is being created.
//
//	    	- If the VPN gateway is in the **active*	- state, the VPN gateway is created.
//
// @param request - CreateVpnGatewayRequest
//
// @return CreateVpnGatewayResponse
func (client *Client) CreateVpnGateway(request *CreateVpnGatewayRequest) (_result *CreateVpnGatewayResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &CreateVpnGatewayResponse{}
	_body, _err := client.CreateVpnGatewayWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates a policy-based route for a VPN gateway.
//
// Description:
//
//	  Before you call this operation, make sure that you are familiar with the match rules of and limits on policy-based routes. For more information, see [Manage policy-based routes](https://help.aliyun.com/document_detail/110777.html).
//
//		- Before you create a policy-based route, make sure that an IPsec-VPN connection is created. For more information, see [CreateVpnConnection](https://help.aliyun.com/document_detail/120391.html).
//
//		- **CreateVpnPbrRouteEntry*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) operation to query the status of the VPN gateway.
//
//	    	- If the VPN gateway is in the **updating*	- state, the policy-based route is being created.
//
//	    	- If the VPN gateway is in the **active*	- state, the policy-based route is created.
//
//		- You cannot call the **CreateVpnPbrRouteEntry*	- operation to create multiple policy-based routes for a VPN gateway at a time.
//
// @param request - CreateVpnPbrRouteEntryRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateVpnPbrRouteEntryResponse
func (client *Client) CreateVpnPbrRouteEntryWithOptions(request *CreateVpnPbrRouteEntryRequest, runtime *dara.RuntimeOptions) (_result *CreateVpnPbrRouteEntryResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.Description) {
		query["Description"] = request.Description
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.NextHop) {
		query["NextHop"] = request.NextHop
	}

	if !dara.IsNil(request.OverlayMode) {
		query["OverlayMode"] = request.OverlayMode
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.Priority) {
		query["Priority"] = request.Priority
	}

	if !dara.IsNil(request.PublishVpc) {
		query["PublishVpc"] = request.PublishVpc
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.RouteDest) {
		query["RouteDest"] = request.RouteDest
	}

	if !dara.IsNil(request.RouteSource) {
		query["RouteSource"] = request.RouteSource
	}

	if !dara.IsNil(request.VpnGatewayId) {
		query["VpnGatewayId"] = request.VpnGatewayId
	}

	if !dara.IsNil(request.Weight) {
		query["Weight"] = request.Weight
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CreateVpnPbrRouteEntry"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &CreateVpnPbrRouteEntryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Creates a policy-based route for a VPN gateway.
//
// Description:
//
//	  Before you call this operation, make sure that you are familiar with the match rules of and limits on policy-based routes. For more information, see [Manage policy-based routes](https://help.aliyun.com/document_detail/110777.html).
//
//		- Before you create a policy-based route, make sure that an IPsec-VPN connection is created. For more information, see [CreateVpnConnection](https://help.aliyun.com/document_detail/120391.html).
//
//		- **CreateVpnPbrRouteEntry*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) operation to query the status of the VPN gateway.
//
//	    	- If the VPN gateway is in the **updating*	- state, the policy-based route is being created.
//
//	    	- If the VPN gateway is in the **active*	- state, the policy-based route is created.
//
//		- You cannot call the **CreateVpnPbrRouteEntry*	- operation to create multiple policy-based routes for a VPN gateway at a time.
//
// @param request - CreateVpnPbrRouteEntryRequest
//
// @return CreateVpnPbrRouteEntryResponse
func (client *Client) CreateVpnPbrRouteEntry(request *CreateVpnPbrRouteEntryRequest) (_result *CreateVpnPbrRouteEntryResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &CreateVpnPbrRouteEntryResponse{}
	_body, _err := client.CreateVpnPbrRouteEntryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates a destination-based route entry for a VPN gateway.
//
// Description:
//
//	  **CreateVpnRouteEntry*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
//
//	    	- If a VPN gateway is in the **updating*	- state, the destination-based route entry is being created.
//
//	    	- If a VPN gateway is in the **active*	- state, the destination-based route entry has been created.
//
//		- You cannot repeatedly call **CreateVpnRouteEntry*	- to create a destination-based route entry for a VPN gateway within the specified period of time.
//
// @param request - CreateVpnRouteEntryRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateVpnRouteEntryResponse
func (client *Client) CreateVpnRouteEntryWithOptions(request *CreateVpnRouteEntryRequest, runtime *dara.RuntimeOptions) (_result *CreateVpnRouteEntryResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.Description) {
		query["Description"] = request.Description
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.NextHop) {
		query["NextHop"] = request.NextHop
	}

	if !dara.IsNil(request.OverlayMode) {
		query["OverlayMode"] = request.OverlayMode
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PublishVpc) {
		query["PublishVpc"] = request.PublishVpc
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.RouteDest) {
		query["RouteDest"] = request.RouteDest
	}

	if !dara.IsNil(request.VpnGatewayId) {
		query["VpnGatewayId"] = request.VpnGatewayId
	}

	if !dara.IsNil(request.Weight) {
		query["Weight"] = request.Weight
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CreateVpnRouteEntry"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &CreateVpnRouteEntryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Creates a destination-based route entry for a VPN gateway.
//
// Description:
//
//	  **CreateVpnRouteEntry*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
//
//	    	- If a VPN gateway is in the **updating*	- state, the destination-based route entry is being created.
//
//	    	- If a VPN gateway is in the **active*	- state, the destination-based route entry has been created.
//
//		- You cannot repeatedly call **CreateVpnRouteEntry*	- to create a destination-based route entry for a VPN gateway within the specified period of time.
//
// @param request - CreateVpnRouteEntryRequest
//
// @return CreateVpnRouteEntryResponse
func (client *Client) CreateVpnRouteEntry(request *CreateVpnRouteEntryRequest) (_result *CreateVpnRouteEntryResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &CreateVpnRouteEntryResponse{}
	_body, _err := client.CreateVpnRouteEntryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// 
//
// @param request - DeactivateRouterInterfaceRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeactivateRouterInterfaceResponse
func (client *Client) DeactivateRouterInterfaceWithOptions(request *DeactivateRouterInterfaceRequest, runtime *dara.RuntimeOptions) (_result *DeactivateRouterInterfaceResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.RouterInterfaceId) {
		query["RouterInterfaceId"] = request.RouterInterfaceId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DeactivateRouterInterface"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DeactivateRouterInterfaceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// 
//
// @param request - DeactivateRouterInterfaceRequest
//
// @return DeactivateRouterInterfaceResponse
func (client *Client) DeactivateRouterInterface(request *DeactivateRouterInterfaceRequest) (_result *DeactivateRouterInterfaceResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DeactivateRouterInterfaceResponse{}
	_body, _err := client.DeactivateRouterInterfaceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Disables a flow log. After a flow log is disabled, the system no longer captures the traffic information about a resource.
//
// Description:
//
//	  The **DeactiveFlowLog*	- operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeFlowLogs](https://help.aliyun.com/document_detail/87923.html) operation to query the status of a flow log:
//
//	    	- If the flow log is in the **Deactivating*	- state, the flow log is being disabled.
//
//	    	- If the flow log is in the **Inactive*	- state, the flow log is disabled.
//
//		- You cannot repeatedly call the **DeactiveFlowLog*	- operation to disable a flow log within the specified period of time.
//
// @param request - DeactiveFlowLogRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeactiveFlowLogResponse
func (client *Client) DeactiveFlowLogWithOptions(request *DeactiveFlowLogRequest, runtime *dara.RuntimeOptions) (_result *DeactiveFlowLogResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.FlowLogId) {
		query["FlowLogId"] = request.FlowLogId
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DeactiveFlowLog"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DeactiveFlowLogResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Disables a flow log. After a flow log is disabled, the system no longer captures the traffic information about a resource.
//
// Description:
//
//	  The **DeactiveFlowLog*	- operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeFlowLogs](https://help.aliyun.com/document_detail/87923.html) operation to query the status of a flow log:
//
//	    	- If the flow log is in the **Deactivating*	- state, the flow log is being disabled.
//
//	    	- If the flow log is in the **Inactive*	- state, the flow log is disabled.
//
//		- You cannot repeatedly call the **DeactiveFlowLog*	- operation to disable a flow log within the specified period of time.
//
// @param request - DeactiveFlowLogRequest
//
// @return DeactiveFlowLogResponse
func (client *Client) DeactiveFlowLog(request *DeactiveFlowLogRequest) (_result *DeactiveFlowLogResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DeactiveFlowLogResponse{}
	_body, _err := client.DeactiveFlowLogWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes a Border Gateway Protocol (BGP) group.
//
// @param request - DeleteBgpGroupRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteBgpGroupResponse
func (client *Client) DeleteBgpGroupWithOptions(request *DeleteBgpGroupRequest, runtime *dara.RuntimeOptions) (_result *DeleteBgpGroupResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.BgpGroupId) {
		query["BgpGroupId"] = request.BgpGroupId
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DeleteBgpGroup"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DeleteBgpGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Deletes a Border Gateway Protocol (BGP) group.
//
// @param request - DeleteBgpGroupRequest
//
// @return DeleteBgpGroupResponse
func (client *Client) DeleteBgpGroup(request *DeleteBgpGroupRequest) (_result *DeleteBgpGroupResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DeleteBgpGroupResponse{}
	_body, _err := client.DeleteBgpGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes an advertised Border Gateway Protocol (BGP) network.
//
// @param request - DeleteBgpNetworkRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteBgpNetworkResponse
func (client *Client) DeleteBgpNetworkWithOptions(request *DeleteBgpNetworkRequest, runtime *dara.RuntimeOptions) (_result *DeleteBgpNetworkResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DstCidrBlock) {
		query["DstCidrBlock"] = request.DstCidrBlock
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.RouterId) {
		query["RouterId"] = request.RouterId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DeleteBgpNetwork"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DeleteBgpNetworkResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Deletes an advertised Border Gateway Protocol (BGP) network.
//
// @param request - DeleteBgpNetworkRequest
//
// @return DeleteBgpNetworkResponse
func (client *Client) DeleteBgpNetwork(request *DeleteBgpNetworkRequest) (_result *DeleteBgpNetworkResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DeleteBgpNetworkResponse{}
	_body, _err := client.DeleteBgpNetworkWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes a Border Gateway Protocol (BGP) peer.
//
// @param request - DeleteBgpPeerRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteBgpPeerResponse
func (client *Client) DeleteBgpPeerWithOptions(request *DeleteBgpPeerRequest, runtime *dara.RuntimeOptions) (_result *DeleteBgpPeerResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.BgpPeerId) {
		query["BgpPeerId"] = request.BgpPeerId
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DeleteBgpPeer"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DeleteBgpPeerResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Deletes a Border Gateway Protocol (BGP) peer.
//
// @param request - DeleteBgpPeerRequest
//
// @return DeleteBgpPeerResponse
func (client *Client) DeleteBgpPeer(request *DeleteBgpPeerRequest) (_result *DeleteBgpPeerResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DeleteBgpPeerResponse{}
	_body, _err := client.DeleteBgpPeerWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes an Internet Shared Bandwidth instance.
//
// Description:
//
// You cannot repeatedly call the **DeleteCommonBandwidthPackage*	- operation to delete an Internet Shared Bandwidth instance within the specified period of time.
//
// @param request - DeleteCommonBandwidthPackageRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteCommonBandwidthPackageResponse
func (client *Client) DeleteCommonBandwidthPackageWithOptions(request *DeleteCommonBandwidthPackageRequest, runtime *dara.RuntimeOptions) (_result *DeleteCommonBandwidthPackageResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.BandwidthPackageId) {
		query["BandwidthPackageId"] = request.BandwidthPackageId
	}

	if !dara.IsNil(request.Force) {
		query["Force"] = request.Force
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DeleteCommonBandwidthPackage"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DeleteCommonBandwidthPackageResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Deletes an Internet Shared Bandwidth instance.
//
// Description:
//
// You cannot repeatedly call the **DeleteCommonBandwidthPackage*	- operation to delete an Internet Shared Bandwidth instance within the specified period of time.
//
// @param request - DeleteCommonBandwidthPackageRequest
//
// @return DeleteCommonBandwidthPackageResponse
func (client *Client) DeleteCommonBandwidthPackage(request *DeleteCommonBandwidthPackageRequest) (_result *DeleteCommonBandwidthPackageResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DeleteCommonBandwidthPackageResponse{}
	_body, _err := client.DeleteCommonBandwidthPackageWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes a customer gateway.
//
// Description:
//
// Before you delete a customer gateway, make sure that no IPsec-VPN connection is associated with the customer gateway. For more information about how to delete an IPsec-VPN connection, see [DeleteVpnAttachment](https://help.aliyun.com/document_detail/2526938.html) or [DeleteVpnConnection](https://help.aliyun.com/document_detail/2526948.html).
//
// @param request - DeleteCustomerGatewayRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteCustomerGatewayResponse
func (client *Client) DeleteCustomerGatewayWithOptions(request *DeleteCustomerGatewayRequest, runtime *dara.RuntimeOptions) (_result *DeleteCustomerGatewayResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.CustomerGatewayId) {
		query["CustomerGatewayId"] = request.CustomerGatewayId
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DeleteCustomerGateway"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DeleteCustomerGatewayResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Deletes a customer gateway.
//
// Description:
//
// Before you delete a customer gateway, make sure that no IPsec-VPN connection is associated with the customer gateway. For more information about how to delete an IPsec-VPN connection, see [DeleteVpnAttachment](https://help.aliyun.com/document_detail/2526938.html) or [DeleteVpnConnection](https://help.aliyun.com/document_detail/2526948.html).
//
// @param request - DeleteCustomerGatewayRequest
//
// @return DeleteCustomerGatewayResponse
func (client *Client) DeleteCustomerGateway(request *DeleteCustomerGatewayRequest) (_result *DeleteCustomerGatewayResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DeleteCustomerGatewayResponse{}
	_body, _err := client.DeleteCustomerGatewayWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes a DHCP options set.
//
// Description:
//
// ## [](#)Description
//
//   - **DeleteDhcpOptionsSet*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [GetDhcpOptionsSet](https://help.aliyun.com/document_detail/189208.html) operation to query the status of the task.
//
//   - If the DHCP options set is in the **Deleting*	- state, the DHCP options set is being deleted.
//
//   - If you cannot query the DHCP options set, the DHCP options set is deleted.
//
//   - You cannot repeatedly call the **DeleteDhcpOptionsSet*	- operation to delete a DHCP options set within the specified period of time.
//
// @param request - DeleteDhcpOptionsSetRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteDhcpOptionsSetResponse
func (client *Client) DeleteDhcpOptionsSetWithOptions(request *DeleteDhcpOptionsSetRequest, runtime *dara.RuntimeOptions) (_result *DeleteDhcpOptionsSetResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DhcpOptionsSetId) {
		query["DhcpOptionsSetId"] = request.DhcpOptionsSetId
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DeleteDhcpOptionsSet"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DeleteDhcpOptionsSetResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Deletes a DHCP options set.
//
// Description:
//
// ## [](#)Description
//
//   - **DeleteDhcpOptionsSet*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [GetDhcpOptionsSet](https://help.aliyun.com/document_detail/189208.html) operation to query the status of the task.
//
//   - If the DHCP options set is in the **Deleting*	- state, the DHCP options set is being deleted.
//
//   - If you cannot query the DHCP options set, the DHCP options set is deleted.
//
//   - You cannot repeatedly call the **DeleteDhcpOptionsSet*	- operation to delete a DHCP options set within the specified period of time.
//
// @param request - DeleteDhcpOptionsSetRequest
//
// @return DeleteDhcpOptionsSetResponse
func (client *Client) DeleteDhcpOptionsSet(request *DeleteDhcpOptionsSetRequest) (_result *DeleteDhcpOptionsSetResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DeleteDhcpOptionsSetResponse{}
	_body, _err := client.DeleteDhcpOptionsSetWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes a quality of service (QoS) policy.
//
// @param request - DeleteExpressConnectTrafficQosRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteExpressConnectTrafficQosResponse
func (client *Client) DeleteExpressConnectTrafficQosWithOptions(request *DeleteExpressConnectTrafficQosRequest, runtime *dara.RuntimeOptions) (_result *DeleteExpressConnectTrafficQosResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.QosId) {
		query["QosId"] = request.QosId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DeleteExpressConnectTrafficQos"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DeleteExpressConnectTrafficQosResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Deletes a quality of service (QoS) policy.
//
// @param request - DeleteExpressConnectTrafficQosRequest
//
// @return DeleteExpressConnectTrafficQosResponse
func (client *Client) DeleteExpressConnectTrafficQos(request *DeleteExpressConnectTrafficQosRequest) (_result *DeleteExpressConnectTrafficQosResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DeleteExpressConnectTrafficQosResponse{}
	_body, _err := client.DeleteExpressConnectTrafficQosWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes a quality of service (QoS) queue.
//
// @param request - DeleteExpressConnectTrafficQosQueueRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteExpressConnectTrafficQosQueueResponse
func (client *Client) DeleteExpressConnectTrafficQosQueueWithOptions(request *DeleteExpressConnectTrafficQosQueueRequest, runtime *dara.RuntimeOptions) (_result *DeleteExpressConnectTrafficQosQueueResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.QosId) {
		query["QosId"] = request.QosId
	}

	if !dara.IsNil(request.QueueId) {
		query["QueueId"] = request.QueueId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DeleteExpressConnectTrafficQosQueue"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DeleteExpressConnectTrafficQosQueueResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Deletes a quality of service (QoS) queue.
//
// @param request - DeleteExpressConnectTrafficQosQueueRequest
//
// @return DeleteExpressConnectTrafficQosQueueResponse
func (client *Client) DeleteExpressConnectTrafficQosQueue(request *DeleteExpressConnectTrafficQosQueueRequest) (_result *DeleteExpressConnectTrafficQosQueueResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DeleteExpressConnectTrafficQosQueueResponse{}
	_body, _err := client.DeleteExpressConnectTrafficQosQueueWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes a quality of service (QoS) rule.
//
// @param request - DeleteExpressConnectTrafficQosRuleRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteExpressConnectTrafficQosRuleResponse
func (client *Client) DeleteExpressConnectTrafficQosRuleWithOptions(request *DeleteExpressConnectTrafficQosRuleRequest, runtime *dara.RuntimeOptions) (_result *DeleteExpressConnectTrafficQosRuleResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.QosId) {
		query["QosId"] = request.QosId
	}

	if !dara.IsNil(request.QueueId) {
		query["QueueId"] = request.QueueId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.RuleId) {
		query["RuleId"] = request.RuleId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DeleteExpressConnectTrafficQosRule"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DeleteExpressConnectTrafficQosRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Deletes a quality of service (QoS) rule.
//
// @param request - DeleteExpressConnectTrafficQosRuleRequest
//
// @return DeleteExpressConnectTrafficQosRuleResponse
func (client *Client) DeleteExpressConnectTrafficQosRule(request *DeleteExpressConnectTrafficQosRuleRequest) (_result *DeleteExpressConnectTrafficQosRuleResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DeleteExpressConnectTrafficQosRuleResponse{}
	_body, _err := client.DeleteExpressConnectTrafficQosRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes a failover test.
//
// Description:
//
// You can delete only failover tests that are in the **Pending*	- or **Complete*	- state.
//
// @param request - DeleteFailoverTestJobRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteFailoverTestJobResponse
func (client *Client) DeleteFailoverTestJobWithOptions(request *DeleteFailoverTestJobRequest, runtime *dara.RuntimeOptions) (_result *DeleteFailoverTestJobResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.JobId) {
		query["JobId"] = request.JobId
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DeleteFailoverTestJob"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DeleteFailoverTestJobResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Deletes a failover test.
//
// Description:
//
// You can delete only failover tests that are in the **Pending*	- or **Complete*	- state.
//
// @param request - DeleteFailoverTestJobRequest
//
// @return DeleteFailoverTestJobResponse
func (client *Client) DeleteFailoverTestJob(request *DeleteFailoverTestJobRequest) (_result *DeleteFailoverTestJobResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DeleteFailoverTestJobResponse{}
	_body, _err := client.DeleteFailoverTestJobWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes a flow log.
//
// Description:
//
//	  The **DeleteFlowLog*	- operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeFlowLogs](https://help.aliyun.com/document_detail/87923.html) operation to query the status of a flow log:
//
//	    	- If the flow log is in the **Deleting*	- state, the flow log is being deleted.
//
//	    	- If you cannot query the flow log, the flow log is deleted.
//
//		- You cannot repeatedly call the **DeleteFlowLog*	- operation to delete a flow log within the specified period of time.
//
// @param request - DeleteFlowLogRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteFlowLogResponse
func (client *Client) DeleteFlowLogWithOptions(request *DeleteFlowLogRequest, runtime *dara.RuntimeOptions) (_result *DeleteFlowLogResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.FlowLogId) {
		query["FlowLogId"] = request.FlowLogId
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DeleteFlowLog"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DeleteFlowLogResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Deletes a flow log.
//
// Description:
//
//	  The **DeleteFlowLog*	- operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeFlowLogs](https://help.aliyun.com/document_detail/87923.html) operation to query the status of a flow log:
//
//	    	- If the flow log is in the **Deleting*	- state, the flow log is being deleted.
//
//	    	- If you cannot query the flow log, the flow log is deleted.
//
//		- You cannot repeatedly call the **DeleteFlowLog*	- operation to delete a flow log within the specified period of time.
//
// @param request - DeleteFlowLogRequest
//
// @return DeleteFlowLogResponse
func (client *Client) DeleteFlowLog(request *DeleteFlowLogRequest) (_result *DeleteFlowLogResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DeleteFlowLogResponse{}
	_body, _err := client.DeleteFlowLogWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes a DNAT entry.
//
// Description:
//
// ## [](#)Description
//
//   - **DeleteForwardEntry*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeForwardTableEntries](https://help.aliyun.com/document_detail/36053.html) operation to query the status of the task.
//
//   - If the DNAT entry is in the **Deleting*	- state, the system is deleting the DNAT entry. In this case, you can only query the status of the DNAT entry, but cannot perform other operations.
//
//   - If the DNAT entry cannot be found, it is deleted.
//
// >  If a DNAT table has DNAT entries in the **Pending*	- state, you cannot delete the DNAT entries.
//
//   - You cannot repeatedly call the **DeleteForwardEntry*	- operation to delete a DNAT entry within the specified period of time.
//
// @param request - DeleteForwardEntryRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteForwardEntryResponse
func (client *Client) DeleteForwardEntryWithOptions(request *DeleteForwardEntryRequest, runtime *dara.RuntimeOptions) (_result *DeleteForwardEntryResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.ForwardEntryId) {
		query["ForwardEntryId"] = request.ForwardEntryId
	}

	if !dara.IsNil(request.ForwardTableId) {
		query["ForwardTableId"] = request.ForwardTableId
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DeleteForwardEntry"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DeleteForwardEntryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Deletes a DNAT entry.
//
// Description:
//
// ## [](#)Description
//
//   - **DeleteForwardEntry*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeForwardTableEntries](https://help.aliyun.com/document_detail/36053.html) operation to query the status of the task.
//
//   - If the DNAT entry is in the **Deleting*	- state, the system is deleting the DNAT entry. In this case, you can only query the status of the DNAT entry, but cannot perform other operations.
//
//   - If the DNAT entry cannot be found, it is deleted.
//
// >  If a DNAT table has DNAT entries in the **Pending*	- state, you cannot delete the DNAT entries.
//
//   - You cannot repeatedly call the **DeleteForwardEntry*	- operation to delete a DNAT entry within the specified period of time.
//
// @param request - DeleteForwardEntryRequest
//
// @return DeleteForwardEntryResponse
func (client *Client) DeleteForwardEntry(request *DeleteForwardEntryRequest) (_result *DeleteForwardEntryResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DeleteForwardEntryResponse{}
	_body, _err := client.DeleteForwardEntryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes a FULLNAT entry.
//
// Description:
//
// ## [](#)Description
//
// **DeleteFullNatEntry*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListFullNatEntries](https://help.aliyun.com/document_detail/348779.html) operation to query the status of a FULLNAT entry.
//
//   - If the FULLNAT entry is in the **Deleting*	- state, the system is deleting the FULLNAT entry. In this case, you can query the status of the FULLNAT entry, but cannot perform other operations.
//
//   - If the FULLNAT entry cannot be found, the FULLNAT entry is deleted.
//
// You cannot repeatedly call the **DeleteFullNatEntry*	- operation to delete a FULLNAT entry within the specified period of time.
//
// @param request - DeleteFullNatEntryRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteFullNatEntryResponse
func (client *Client) DeleteFullNatEntryWithOptions(request *DeleteFullNatEntryRequest, runtime *dara.RuntimeOptions) (_result *DeleteFullNatEntryResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.FullNatEntryId) {
		query["FullNatEntryId"] = request.FullNatEntryId
	}

	if !dara.IsNil(request.FullNatTableId) {
		query["FullNatTableId"] = request.FullNatTableId
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DeleteFullNatEntry"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DeleteFullNatEntryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Deletes a FULLNAT entry.
//
// Description:
//
// ## [](#)Description
//
// **DeleteFullNatEntry*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListFullNatEntries](https://help.aliyun.com/document_detail/348779.html) operation to query the status of a FULLNAT entry.
//
//   - If the FULLNAT entry is in the **Deleting*	- state, the system is deleting the FULLNAT entry. In this case, you can query the status of the FULLNAT entry, but cannot perform other operations.
//
//   - If the FULLNAT entry cannot be found, the FULLNAT entry is deleted.
//
// You cannot repeatedly call the **DeleteFullNatEntry*	- operation to delete a FULLNAT entry within the specified period of time.
//
// @param request - DeleteFullNatEntryRequest
//
// @return DeleteFullNatEntryResponse
func (client *Client) DeleteFullNatEntry(request *DeleteFullNatEntryRequest) (_result *DeleteFullNatEntryResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DeleteFullNatEntryResponse{}
	_body, _err := client.DeleteFullNatEntryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes a Global Accelerator (GA) instance.
//
// Description:
//
// When you call this operation, take note of the following items:
//
//   - You can delete only pay-as-you-go instances.
//
//   - Before you can delete a dedicated instance, disassociate the backend server from the instance first.
//
//   - Before you can delete a shared instance, disassociate the elastic IP address (EIP) from the instance first.
//
// @param request - DeleteGlobalAccelerationInstanceRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteGlobalAccelerationInstanceResponse
func (client *Client) DeleteGlobalAccelerationInstanceWithOptions(request *DeleteGlobalAccelerationInstanceRequest, runtime *dara.RuntimeOptions) (_result *DeleteGlobalAccelerationInstanceResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.GlobalAccelerationInstanceId) {
		query["GlobalAccelerationInstanceId"] = request.GlobalAccelerationInstanceId
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DeleteGlobalAccelerationInstance"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DeleteGlobalAccelerationInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Deletes a Global Accelerator (GA) instance.
//
// Description:
//
// When you call this operation, take note of the following items:
//
//   - You can delete only pay-as-you-go instances.
//
//   - Before you can delete a dedicated instance, disassociate the backend server from the instance first.
//
//   - Before you can delete a shared instance, disassociate the elastic IP address (EIP) from the instance first.
//
// @param request - DeleteGlobalAccelerationInstanceRequest
//
// @return DeleteGlobalAccelerationInstanceResponse
func (client *Client) DeleteGlobalAccelerationInstance(request *DeleteGlobalAccelerationInstanceRequest) (_result *DeleteGlobalAccelerationInstanceResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DeleteGlobalAccelerationInstanceResponse{}
	_body, _err := client.DeleteGlobalAccelerationInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes a high-availability virtual IP address (HaVip).
//
// Description:
//
// When you call this operation, take note of the following rules:
//
//   - The HaVip must be in the available state before it can be deleted.
//
//   - Make sure that no routes are destined for the HaVip.
//
//   - Make sure that no elastic IP addresses (EIPs) are associated with the HaVip.
//
//   - **DeleteHaVip*	- is an asynchronous operation. After a request is sent, the system returns a request ID while deleting the HaVip in the background. Call the [DescribeHaVips](https://help.aliyun.com/document_detail/114611.html) operation to query the status of an HaVip:
//
//   - The **Deleting*	- state indicates the HaVip is being deleted.
//
//   - If no HaVip is found, the HaVip is deleted.
//
//   - You cannot repeatedly call the **DeleteHaVip*	- operation to delete the same HaVip.
//
// @param request - DeleteHaVipRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteHaVipResponse
func (client *Client) DeleteHaVipWithOptions(request *DeleteHaVipRequest, runtime *dara.RuntimeOptions) (_result *DeleteHaVipResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.HaVipId) {
		query["HaVipId"] = request.HaVipId
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DeleteHaVip"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DeleteHaVipResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Deletes a high-availability virtual IP address (HaVip).
//
// Description:
//
// When you call this operation, take note of the following rules:
//
//   - The HaVip must be in the available state before it can be deleted.
//
//   - Make sure that no routes are destined for the HaVip.
//
//   - Make sure that no elastic IP addresses (EIPs) are associated with the HaVip.
//
//   - **DeleteHaVip*	- is an asynchronous operation. After a request is sent, the system returns a request ID while deleting the HaVip in the background. Call the [DescribeHaVips](https://help.aliyun.com/document_detail/114611.html) operation to query the status of an HaVip:
//
//   - The **Deleting*	- state indicates the HaVip is being deleted.
//
//   - If no HaVip is found, the HaVip is deleted.
//
//   - You cannot repeatedly call the **DeleteHaVip*	- operation to delete the same HaVip.
//
// @param request - DeleteHaVipRequest
//
// @return DeleteHaVipResponse
func (client *Client) DeleteHaVip(request *DeleteHaVipRequest) (_result *DeleteHaVipResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DeleteHaVipResponse{}
	_body, _err := client.DeleteHaVipWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes an IPv6 Translation Service instance.
//
// @param request - DeleteIPv6TranslatorRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteIPv6TranslatorResponse
func (client *Client) DeleteIPv6TranslatorWithOptions(request *DeleteIPv6TranslatorRequest, runtime *dara.RuntimeOptions) (_result *DeleteIPv6TranslatorResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.Ipv6TranslatorId) {
		query["Ipv6TranslatorId"] = request.Ipv6TranslatorId
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DeleteIPv6Translator"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DeleteIPv6TranslatorResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Deletes an IPv6 Translation Service instance.
//
// @param request - DeleteIPv6TranslatorRequest
//
// @return DeleteIPv6TranslatorResponse
func (client *Client) DeleteIPv6Translator(request *DeleteIPv6TranslatorRequest) (_result *DeleteIPv6TranslatorResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DeleteIPv6TranslatorResponse{}
	_body, _err := client.DeleteIPv6TranslatorWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Deprecated: OpenAPI DeleteIPv6TranslatorAclList is deprecated
//
// Summary:
//
// Deletes an access control list (ACL). You can delete an ACL only when the ACL is not associated with IPv6 translation mappings.
//
// @param request - DeleteIPv6TranslatorAclListRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteIPv6TranslatorAclListResponse
func (client *Client) DeleteIPv6TranslatorAclListWithOptions(request *DeleteIPv6TranslatorAclListRequest, runtime *dara.RuntimeOptions) (_result *DeleteIPv6TranslatorAclListResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.AclId) {
		query["AclId"] = request.AclId
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DeleteIPv6TranslatorAclList"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DeleteIPv6TranslatorAclListResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Deprecated: OpenAPI DeleteIPv6TranslatorAclList is deprecated
//
// Summary:
//
// Deletes an access control list (ACL). You can delete an ACL only when the ACL is not associated with IPv6 translation mappings.
//
// @param request - DeleteIPv6TranslatorAclListRequest
//
// @return DeleteIPv6TranslatorAclListResponse
// Deprecated
func (client *Client) DeleteIPv6TranslatorAclList(request *DeleteIPv6TranslatorAclListRequest) (_result *DeleteIPv6TranslatorAclListResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DeleteIPv6TranslatorAclListResponse{}
	_body, _err := client.DeleteIPv6TranslatorAclListWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Deprecated: OpenAPI DeleteIPv6TranslatorEntry is deprecated
//
// Summary:
//
// Deletes an IPv6 mapping entry.
//
// @param request - DeleteIPv6TranslatorEntryRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteIPv6TranslatorEntryResponse
func (client *Client) DeleteIPv6TranslatorEntryWithOptions(request *DeleteIPv6TranslatorEntryRequest, runtime *dara.RuntimeOptions) (_result *DeleteIPv6TranslatorEntryResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.Ipv6TranslatorEntryId) {
		query["Ipv6TranslatorEntryId"] = request.Ipv6TranslatorEntryId
	}

	if !dara.IsNil(request.Ipv6TranslatorId) {
		query["Ipv6TranslatorId"] = request.Ipv6TranslatorId
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DeleteIPv6TranslatorEntry"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DeleteIPv6TranslatorEntryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Deprecated: OpenAPI DeleteIPv6TranslatorEntry is deprecated
//
// Summary:
//
// Deletes an IPv6 mapping entry.
//
// @param request - DeleteIPv6TranslatorEntryRequest
//
// @return DeleteIPv6TranslatorEntryResponse
// Deprecated
func (client *Client) DeleteIPv6TranslatorEntry(request *DeleteIPv6TranslatorEntryRequest) (_result *DeleteIPv6TranslatorEntryResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DeleteIPv6TranslatorEntryResponse{}
	_body, _err := client.DeleteIPv6TranslatorEntryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes an IPsec server.
//
// Description:
//
//	  **DeleteIpsecServer*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) to query the status of the task.
//
//	    	- If the VPN gateway is in the **updating*	- state, the IPsec server is being deleted.
//
//	    	- If the VPN gateway is in the **active*	- state, the IPsec server is deleted.
//
//		- You cannot call **DeleteIpsecServer*	- within the specified period of time.
//
// @param request - DeleteIpsecServerRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteIpsecServerResponse
func (client *Client) DeleteIpsecServerWithOptions(request *DeleteIpsecServerRequest, runtime *dara.RuntimeOptions) (_result *DeleteIpsecServerResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.IpsecServerId) {
		query["IpsecServerId"] = request.IpsecServerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DeleteIpsecServer"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DeleteIpsecServerResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Deletes an IPsec server.
//
// Description:
//
//	  **DeleteIpsecServer*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) to query the status of the task.
//
//	    	- If the VPN gateway is in the **updating*	- state, the IPsec server is being deleted.
//
//	    	- If the VPN gateway is in the **active*	- state, the IPsec server is deleted.
//
//		- You cannot call **DeleteIpsecServer*	- within the specified period of time.
//
// @param request - DeleteIpsecServerRequest
//
// @return DeleteIpsecServerResponse
func (client *Client) DeleteIpsecServer(request *DeleteIpsecServerRequest) (_result *DeleteIpsecServerResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DeleteIpsecServerResponse{}
	_body, _err := client.DeleteIpsecServerWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes an IPv4 gateway.
//
// Description:
//
// ### [](#)Description
//
//   - Before you delete an IPv4 gateway, make sure that no route tables are associated with the IPv4 gateway.
//
//   - **DeleteIpv4Gateway*	- is an asynchronous operation. After a request is sent, the system returns a **request ID*	- and runs the task in the background. You can call the [GetIpv4GatewayAttribute](https://help.aliyun.com/document_detail/407670.html) operation to query the status of the task.
//
//   - If the IPv4 gateway is in the **Deleting*	- state, the IPv4 gateway is being deleted.
//
//   - If the IPv4 gateway cannot be queried, the IPv4 gateway is deleted.
//
//   - After you call the **DeleteIpv4Gateway*	- operation to delete an IPv4 gateway, you cannot call the operation again to delete the IPv4 gateway until the deletion task is complete.
//
// @param request - DeleteIpv4GatewayRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteIpv4GatewayResponse
func (client *Client) DeleteIpv4GatewayWithOptions(request *DeleteIpv4GatewayRequest, runtime *dara.RuntimeOptions) (_result *DeleteIpv4GatewayResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.InternetMode) {
		query["InternetMode"] = request.InternetMode
	}

	if !dara.IsNil(request.Ipv4GatewayId) {
		query["Ipv4GatewayId"] = request.Ipv4GatewayId
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DeleteIpv4Gateway"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DeleteIpv4GatewayResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Deletes an IPv4 gateway.
//
// Description:
//
// ### [](#)Description
//
//   - Before you delete an IPv4 gateway, make sure that no route tables are associated with the IPv4 gateway.
//
//   - **DeleteIpv4Gateway*	- is an asynchronous operation. After a request is sent, the system returns a **request ID*	- and runs the task in the background. You can call the [GetIpv4GatewayAttribute](https://help.aliyun.com/document_detail/407670.html) operation to query the status of the task.
//
//   - If the IPv4 gateway is in the **Deleting*	- state, the IPv4 gateway is being deleted.
//
//   - If the IPv4 gateway cannot be queried, the IPv4 gateway is deleted.
//
//   - After you call the **DeleteIpv4Gateway*	- operation to delete an IPv4 gateway, you cannot call the operation again to delete the IPv4 gateway until the deletion task is complete.
//
// @param request - DeleteIpv4GatewayRequest
//
// @return DeleteIpv4GatewayResponse
func (client *Client) DeleteIpv4Gateway(request *DeleteIpv4GatewayRequest) (_result *DeleteIpv4GatewayResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DeleteIpv4GatewayResponse{}
	_body, _err := client.DeleteIpv4GatewayWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes an egress-only rule.
//
// Description:
//
//	  **DeleteIpv6EgressOnlyRule*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeIpv6EgressOnlyRules](https://help.aliyun.com/document_detail/102208.html) operation to query the status of the task.
//
//	    	- If the egress-only rule is in the **Deleting*	- state, the egress-only rule is being deleted.
//
//	    	- If you cannot query the egress-only rule, the egress-only rule is deleted.
//
//		- You cannot call the **DeleteIpv6EgressOnlyRule*	- within the specified period of time.
//
// @param request - DeleteIpv6EgressOnlyRuleRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteIpv6EgressOnlyRuleResponse
func (client *Client) DeleteIpv6EgressOnlyRuleWithOptions(request *DeleteIpv6EgressOnlyRuleRequest, runtime *dara.RuntimeOptions) (_result *DeleteIpv6EgressOnlyRuleResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.Ipv6EgressOnlyRuleId) {
		query["Ipv6EgressOnlyRuleId"] = request.Ipv6EgressOnlyRuleId
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DeleteIpv6EgressOnlyRule"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DeleteIpv6EgressOnlyRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Deletes an egress-only rule.
//
// Description:
//
//	  **DeleteIpv6EgressOnlyRule*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeIpv6EgressOnlyRules](https://help.aliyun.com/document_detail/102208.html) operation to query the status of the task.
//
//	    	- If the egress-only rule is in the **Deleting*	- state, the egress-only rule is being deleted.
//
//	    	- If you cannot query the egress-only rule, the egress-only rule is deleted.
//
//		- You cannot call the **DeleteIpv6EgressOnlyRule*	- within the specified period of time.
//
// @param request - DeleteIpv6EgressOnlyRuleRequest
//
// @return DeleteIpv6EgressOnlyRuleResponse
func (client *Client) DeleteIpv6EgressOnlyRule(request *DeleteIpv6EgressOnlyRuleRequest) (_result *DeleteIpv6EgressOnlyRuleResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DeleteIpv6EgressOnlyRuleResponse{}
	_body, _err := client.DeleteIpv6EgressOnlyRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes an IPv6 gateway.
//
// Description:
//
// Before you delete an IPv6 gateway, you must delete the egress-only rules of the IPv6 gateway. For more information, see [DeleteIpv6EgressOnlyRule](https://help.aliyun.com/document_detail/102201.html).
//
//   - **DeleteIpv6Gateway*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeIpv6GatewayAttribute](https://help.aliyun.com/document_detail/102226.html) operation to query the status of the task:
//
//   - If the IPv6 gateway is in the **Deleting*	- state, the IPv6 gateway is being deleted.
//
//   - If you cannot query the IPv6 gateway, the IPv6 gateway is deleted.
//
//   - You cannot repeatedly call the **DeleteIpv6Gateway*	- operation to delete an IPv6 gateway within the specified period of time.
//
// @param request - DeleteIpv6GatewayRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteIpv6GatewayResponse
func (client *Client) DeleteIpv6GatewayWithOptions(request *DeleteIpv6GatewayRequest, runtime *dara.RuntimeOptions) (_result *DeleteIpv6GatewayResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.Ipv6GatewayId) {
		query["Ipv6GatewayId"] = request.Ipv6GatewayId
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DeleteIpv6Gateway"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DeleteIpv6GatewayResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Deletes an IPv6 gateway.
//
// Description:
//
// Before you delete an IPv6 gateway, you must delete the egress-only rules of the IPv6 gateway. For more information, see [DeleteIpv6EgressOnlyRule](https://help.aliyun.com/document_detail/102201.html).
//
//   - **DeleteIpv6Gateway*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeIpv6GatewayAttribute](https://help.aliyun.com/document_detail/102226.html) operation to query the status of the task:
//
//   - If the IPv6 gateway is in the **Deleting*	- state, the IPv6 gateway is being deleted.
//
//   - If you cannot query the IPv6 gateway, the IPv6 gateway is deleted.
//
//   - You cannot repeatedly call the **DeleteIpv6Gateway*	- operation to delete an IPv6 gateway within the specified period of time.
//
// @param request - DeleteIpv6GatewayRequest
//
// @return DeleteIpv6GatewayResponse
func (client *Client) DeleteIpv6Gateway(request *DeleteIpv6GatewayRequest) (_result *DeleteIpv6GatewayResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DeleteIpv6GatewayResponse{}
	_body, _err := client.DeleteIpv6GatewayWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes Internet bandwidth.
//
// Description:
//
// You cannot call the **DeleteIpv6InternetBandwidth*	- operation within the specified period of time.
//
// @param request - DeleteIpv6InternetBandwidthRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteIpv6InternetBandwidthResponse
func (client *Client) DeleteIpv6InternetBandwidthWithOptions(request *DeleteIpv6InternetBandwidthRequest, runtime *dara.RuntimeOptions) (_result *DeleteIpv6InternetBandwidthResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.Ipv6AddressId) {
		query["Ipv6AddressId"] = request.Ipv6AddressId
	}

	if !dara.IsNil(request.Ipv6InternetBandwidthId) {
		query["Ipv6InternetBandwidthId"] = request.Ipv6InternetBandwidthId
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DeleteIpv6InternetBandwidth"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DeleteIpv6InternetBandwidthResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Deletes Internet bandwidth.
//
// Description:
//
// You cannot call the **DeleteIpv6InternetBandwidth*	- operation within the specified period of time.
//
// @param request - DeleteIpv6InternetBandwidthRequest
//
// @return DeleteIpv6InternetBandwidthResponse
func (client *Client) DeleteIpv6InternetBandwidth(request *DeleteIpv6InternetBandwidthRequest) (_result *DeleteIpv6InternetBandwidthResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DeleteIpv6InternetBandwidthResponse{}
	_body, _err := client.DeleteIpv6InternetBandwidthWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes a specified Internet NAT gateway.
//
// Description:
//
// ## [](#)Description
//
//   - **DeleteNatGateway*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeNatGateways](https://help.aliyun.com/document_detail/36054.html) to query the status of the task.
//
//   - If a NAT gateway is in the **Deleting*	- state, the NAT gateway is being deleted. In this case, you can query the NAT gateway but you cannot perform other operations.
//
//   - If the NAT gateway cannot be found, the NAT gateway is deleted.
//
//     After you delete a NAT gateway, you cannot restore the NAT gateway. Proceed with caution.
//
//   - You cannot repeatedly call the **DeleteNatGateway*	- operation to delete a NAT gateway within the specified period of time.
//
// @param request - DeleteNatGatewayRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteNatGatewayResponse
func (client *Client) DeleteNatGatewayWithOptions(request *DeleteNatGatewayRequest, runtime *dara.RuntimeOptions) (_result *DeleteNatGatewayResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.Force) {
		query["Force"] = request.Force
	}

	if !dara.IsNil(request.NatGatewayId) {
		query["NatGatewayId"] = request.NatGatewayId
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DeleteNatGateway"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DeleteNatGatewayResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Deletes a specified Internet NAT gateway.
//
// Description:
//
// ## [](#)Description
//
//   - **DeleteNatGateway*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeNatGateways](https://help.aliyun.com/document_detail/36054.html) to query the status of the task.
//
//   - If a NAT gateway is in the **Deleting*	- state, the NAT gateway is being deleted. In this case, you can query the NAT gateway but you cannot perform other operations.
//
//   - If the NAT gateway cannot be found, the NAT gateway is deleted.
//
//     After you delete a NAT gateway, you cannot restore the NAT gateway. Proceed with caution.
//
//   - You cannot repeatedly call the **DeleteNatGateway*	- operation to delete a NAT gateway within the specified period of time.
//
// @param request - DeleteNatGatewayRequest
//
// @return DeleteNatGatewayResponse
func (client *Client) DeleteNatGateway(request *DeleteNatGatewayRequest) (_result *DeleteNatGatewayResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DeleteNatGatewayResponse{}
	_body, _err := client.DeleteNatGatewayWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes a NAT IP address.
//
// Description:
//
// ## [](#)Description
//
//   - **DeleteNatIp*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListNatIps](https://help.aliyun.com/document_detail/281979.html) operation to query the status of the task.
//
//   - If the NAT IP address is in the **Deleting*	- state, the NAT IP address is being deleted. In this case, you can only query the NAT IP address but cannot perform other operations.
//
//   - If the NAT IP address cannot be found, it is deleted.
//
//   - You cannot repeatedly call the **DeleteNatIp*	- operation to delete a NAT IP address within the specified period of time.
//
// @param request - DeleteNatIpRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteNatIpResponse
func (client *Client) DeleteNatIpWithOptions(request *DeleteNatIpRequest, runtime *dara.RuntimeOptions) (_result *DeleteNatIpResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.Ipv4Prefix) {
		query["Ipv4Prefix"] = request.Ipv4Prefix
	}

	if !dara.IsNil(request.NatGatewayId) {
		query["NatGatewayId"] = request.NatGatewayId
	}

	if !dara.IsNil(request.NatIpId) {
		query["NatIpId"] = request.NatIpId
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DeleteNatIp"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DeleteNatIpResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Deletes a NAT IP address.
//
// Description:
//
// ## [](#)Description
//
//   - **DeleteNatIp*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListNatIps](https://help.aliyun.com/document_detail/281979.html) operation to query the status of the task.
//
//   - If the NAT IP address is in the **Deleting*	- state, the NAT IP address is being deleted. In this case, you can only query the NAT IP address but cannot perform other operations.
//
//   - If the NAT IP address cannot be found, it is deleted.
//
//   - You cannot repeatedly call the **DeleteNatIp*	- operation to delete a NAT IP address within the specified period of time.
//
// @param request - DeleteNatIpRequest
//
// @return DeleteNatIpResponse
func (client *Client) DeleteNatIp(request *DeleteNatIpRequest) (_result *DeleteNatIpResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DeleteNatIpResponse{}
	_body, _err := client.DeleteNatIpWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes a NAT CIDR block.
//
// Description:
//
// ## [](#)Description
//
// You cannot repeatedly call the **DeleteNatIpCidr*	- operation to delete a NAT CIDR block within the specified period of time.
//
// @param request - DeleteNatIpCidrRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteNatIpCidrResponse
func (client *Client) DeleteNatIpCidrWithOptions(request *DeleteNatIpCidrRequest, runtime *dara.RuntimeOptions) (_result *DeleteNatIpCidrResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.NatGatewayId) {
		query["NatGatewayId"] = request.NatGatewayId
	}

	if !dara.IsNil(request.NatIpCidr) {
		query["NatIpCidr"] = request.NatIpCidr
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DeleteNatIpCidr"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DeleteNatIpCidrResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Deletes a NAT CIDR block.
//
// Description:
//
// ## [](#)Description
//
// You cannot repeatedly call the **DeleteNatIpCidr*	- operation to delete a NAT CIDR block within the specified period of time.
//
// @param request - DeleteNatIpCidrRequest
//
// @return DeleteNatIpCidrResponse
func (client *Client) DeleteNatIpCidr(request *DeleteNatIpCidrRequest) (_result *DeleteNatIpCidrResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DeleteNatIpCidrResponse{}
	_body, _err := client.DeleteNatIpCidrWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes a network access control list (ACL).
//
// Description:
//
// ## [](#)Description
//
// You cannot repeatedly call the **DeleteNetworkAcl*	- operation within the specified period of time.
//
// @param request - DeleteNetworkAclRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteNetworkAclResponse
func (client *Client) DeleteNetworkAclWithOptions(request *DeleteNetworkAclRequest, runtime *dara.RuntimeOptions) (_result *DeleteNetworkAclResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.NetworkAclId) {
		query["NetworkAclId"] = request.NetworkAclId
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DeleteNetworkAcl"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DeleteNetworkAclResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Deletes a network access control list (ACL).
//
// Description:
//
// ## [](#)Description
//
// You cannot repeatedly call the **DeleteNetworkAcl*	- operation within the specified period of time.
//
// @param request - DeleteNetworkAclRequest
//
// @return DeleteNetworkAclResponse
func (client *Client) DeleteNetworkAcl(request *DeleteNetworkAclRequest) (_result *DeleteNetworkAclResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DeleteNetworkAclResponse{}
	_body, _err := client.DeleteNetworkAclWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes a connection over an Express Connect circuit.
//
// Description:
//
// You can only delete a connection over an Express Connect circuit that is in the **Allocated**, **Confirmed**, **Rejected**, **Canceled**, **AllocationFailed**, and **Terminated*	- states.
//
// @param request - DeletePhysicalConnectionRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeletePhysicalConnectionResponse
func (client *Client) DeletePhysicalConnectionWithOptions(request *DeletePhysicalConnectionRequest, runtime *dara.RuntimeOptions) (_result *DeletePhysicalConnectionResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PhysicalConnectionId) {
		query["PhysicalConnectionId"] = request.PhysicalConnectionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DeletePhysicalConnection"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DeletePhysicalConnectionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Deletes a connection over an Express Connect circuit.
//
// Description:
//
// You can only delete a connection over an Express Connect circuit that is in the **Allocated**, **Confirmed**, **Rejected**, **Canceled**, **AllocationFailed**, and **Terminated*	- states.
//
// @param request - DeletePhysicalConnectionRequest
//
// @return DeletePhysicalConnectionResponse
func (client *Client) DeletePhysicalConnection(request *DeletePhysicalConnectionRequest) (_result *DeletePhysicalConnectionResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DeletePhysicalConnectionResponse{}
	_body, _err := client.DeletePhysicalConnectionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes an IP address pool.
//
// Description:
//
// Before you call this operation, take note of the following items:
//
//   - Before you delete an IP address pool, make sure that no IP address in the pool is being used.
//
//   - **DeletePublicIpAddressPool*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListPublicIpAddressPools](https://help.aliyun.com/document_detail/429433.html) operation to query the status of the task.
//
//   - If the IP address pool is in the **Deleting*	- state, the IP address pool is being deleted. In this state. you can only query the IP address pool and cannot perform other operations.
//
//   - If you cannot query the IP address pool, the IP address pool is deleted.
//
//   - You cannot repeatedly call the **DeletePublicIpAddressPool*	- operation to delete an IP address pool within the specified period of time.
//
// @param request - DeletePublicIpAddressPoolRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeletePublicIpAddressPoolResponse
func (client *Client) DeletePublicIpAddressPoolWithOptions(request *DeletePublicIpAddressPoolRequest, runtime *dara.RuntimeOptions) (_result *DeletePublicIpAddressPoolResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PublicIpAddressPoolId) {
		query["PublicIpAddressPoolId"] = request.PublicIpAddressPoolId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DeletePublicIpAddressPool"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DeletePublicIpAddressPoolResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Deletes an IP address pool.
//
// Description:
//
// Before you call this operation, take note of the following items:
//
//   - Before you delete an IP address pool, make sure that no IP address in the pool is being used.
//
//   - **DeletePublicIpAddressPool*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListPublicIpAddressPools](https://help.aliyun.com/document_detail/429433.html) operation to query the status of the task.
//
//   - If the IP address pool is in the **Deleting*	- state, the IP address pool is being deleted. In this state. you can only query the IP address pool and cannot perform other operations.
//
//   - If you cannot query the IP address pool, the IP address pool is deleted.
//
//   - You cannot repeatedly call the **DeletePublicIpAddressPool*	- operation to delete an IP address pool within the specified period of time.
//
// @param request - DeletePublicIpAddressPoolRequest
//
// @return DeletePublicIpAddressPoolResponse
func (client *Client) DeletePublicIpAddressPool(request *DeletePublicIpAddressPoolRequest) (_result *DeletePublicIpAddressPoolResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DeletePublicIpAddressPoolResponse{}
	_body, _err := client.DeletePublicIpAddressPoolWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes a CIDR block from an IP address pool.
//
// Description:
//
// Before you call this operation, take note of the following items:
//
//   - Before you delete a CIDR block, make sure that it is not being used.
//
//   - **DeletePublicIpAddressPoolCidrBlock*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListPublicIpAddressPoolCidrBlocks](https://help.aliyun.com/document_detail/429436.html) operation to query the status of the task.
//
//   - If the CIDR block is in the **Deleting*	- state, the CIDR block is being deleted. In this state, you can only query the CIDR block and cannot perform other operations.
//
//   - If you cannot query the CIDR block, the CIDR block is deleted.
//
//   - You cannot repeatedly call the **DeletePublicIpAddressPoolCidrBlock*	- operation to delete a CIDR block within the specified period of time.
//
// @param request - DeletePublicIpAddressPoolCidrBlockRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeletePublicIpAddressPoolCidrBlockResponse
func (client *Client) DeletePublicIpAddressPoolCidrBlockWithOptions(request *DeletePublicIpAddressPoolCidrBlockRequest, runtime *dara.RuntimeOptions) (_result *DeletePublicIpAddressPoolCidrBlockResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.CidrBlock) {
		query["CidrBlock"] = request.CidrBlock
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PublicIpAddressPoolId) {
		query["PublicIpAddressPoolId"] = request.PublicIpAddressPoolId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DeletePublicIpAddressPoolCidrBlock"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DeletePublicIpAddressPoolCidrBlockResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Deletes a CIDR block from an IP address pool.
//
// Description:
//
// Before you call this operation, take note of the following items:
//
//   - Before you delete a CIDR block, make sure that it is not being used.
//
//   - **DeletePublicIpAddressPoolCidrBlock*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListPublicIpAddressPoolCidrBlocks](https://help.aliyun.com/document_detail/429436.html) operation to query the status of the task.
//
//   - If the CIDR block is in the **Deleting*	- state, the CIDR block is being deleted. In this state, you can only query the CIDR block and cannot perform other operations.
//
//   - If you cannot query the CIDR block, the CIDR block is deleted.
//
//   - You cannot repeatedly call the **DeletePublicIpAddressPoolCidrBlock*	- operation to delete a CIDR block within the specified period of time.
//
// @param request - DeletePublicIpAddressPoolCidrBlockRequest
//
// @return DeletePublicIpAddressPoolCidrBlockResponse
func (client *Client) DeletePublicIpAddressPoolCidrBlock(request *DeletePublicIpAddressPoolCidrBlockRequest) (_result *DeletePublicIpAddressPoolCidrBlockResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DeletePublicIpAddressPoolCidrBlockResponse{}
	_body, _err := client.DeletePublicIpAddressPoolCidrBlockWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes multiple custom route entries at a time.
//
// Description:
//
// When you call this operation, take note of the following items:
//
//   - You can delete only routes that are in the **Available*	- state.
//
//   - You cannot delete a route of a virtual private cloud (VPC) in which a vSwitch or another route is being created or deleted.
//
//   - **DeleteRouteEntries*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeRouteEntryList](https://help.aliyun.com/document_detail/138148.html) operation to query the status of the task.
//
//   - If the route is in the **Deleting*	- state, the route is being deleted.
//
//   - If you cannot query the route, the route is deleted.
//
//   - You cannot repeatedly call **DeleteRouteEntries*	- within a specific period of time.
//
// @param request - DeleteRouteEntriesRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteRouteEntriesResponse
func (client *Client) DeleteRouteEntriesWithOptions(request *DeleteRouteEntriesRequest, runtime *dara.RuntimeOptions) (_result *DeleteRouteEntriesResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.RouteEntries) {
		query["RouteEntries"] = request.RouteEntries
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DeleteRouteEntries"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DeleteRouteEntriesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Deletes multiple custom route entries at a time.
//
// Description:
//
// When you call this operation, take note of the following items:
//
//   - You can delete only routes that are in the **Available*	- state.
//
//   - You cannot delete a route of a virtual private cloud (VPC) in which a vSwitch or another route is being created or deleted.
//
//   - **DeleteRouteEntries*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeRouteEntryList](https://help.aliyun.com/document_detail/138148.html) operation to query the status of the task.
//
//   - If the route is in the **Deleting*	- state, the route is being deleted.
//
//   - If you cannot query the route, the route is deleted.
//
//   - You cannot repeatedly call **DeleteRouteEntries*	- within a specific period of time.
//
// @param request - DeleteRouteEntriesRequest
//
// @return DeleteRouteEntriesResponse
func (client *Client) DeleteRouteEntries(request *DeleteRouteEntriesRequest) (_result *DeleteRouteEntriesResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DeleteRouteEntriesResponse{}
	_body, _err := client.DeleteRouteEntriesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes a route entry from a route table of a VRouter or virtual border router (VBR).
//
// Description:
//
// When you call this operation, take note of the following items:
//
//   - You can delete only routes that are in the **Available*	- state.
//
//   - You cannot delete a route entry of a virtual private cloud (VPC) in which a vSwitch or another route entry is being created or deleted.
//
//   - Before you call this operation to delete a route of a VBR route table, call the [DescribeRouteEntryList](https://help.aliyun.com/document_detail/138148.html) operation to query the **NextHopId*	- of the route first.
//
//   - **DeleteRouteEntry*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeRouteEntryList](https://help.aliyun.com/document_detail/138148.html) operation to query the status of the task.
//
//   - If the route is in the **Deleting*	- state, the route is being deleted.
//
//   - If you cannot query the route entry, the route entry is deleted.
//
//   - You cannot repeatedly call the **DeleteRouteEntry*	- operation to delete a route from the route table of a vRouter or a VBR within the specified period of time.
//
// @param request - DeleteRouteEntryRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteRouteEntryResponse
func (client *Client) DeleteRouteEntryWithOptions(request *DeleteRouteEntryRequest, runtime *dara.RuntimeOptions) (_result *DeleteRouteEntryResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.DestinationCidrBlock) {
		query["DestinationCidrBlock"] = request.DestinationCidrBlock
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.NextHopId) {
		query["NextHopId"] = request.NextHopId
	}

	if !dara.IsNil(request.NextHopList) {
		query["NextHopList"] = request.NextHopList
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.RouteEntryId) {
		query["RouteEntryId"] = request.RouteEntryId
	}

	if !dara.IsNil(request.RouteTableId) {
		query["RouteTableId"] = request.RouteTableId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DeleteRouteEntry"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DeleteRouteEntryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Deletes a route entry from a route table of a VRouter or virtual border router (VBR).
//
// Description:
//
// When you call this operation, take note of the following items:
//
//   - You can delete only routes that are in the **Available*	- state.
//
//   - You cannot delete a route entry of a virtual private cloud (VPC) in which a vSwitch or another route entry is being created or deleted.
//
//   - Before you call this operation to delete a route of a VBR route table, call the [DescribeRouteEntryList](https://help.aliyun.com/document_detail/138148.html) operation to query the **NextHopId*	- of the route first.
//
//   - **DeleteRouteEntry*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeRouteEntryList](https://help.aliyun.com/document_detail/138148.html) operation to query the status of the task.
//
//   - If the route is in the **Deleting*	- state, the route is being deleted.
//
//   - If you cannot query the route entry, the route entry is deleted.
//
//   - You cannot repeatedly call the **DeleteRouteEntry*	- operation to delete a route from the route table of a vRouter or a VBR within the specified period of time.
//
// @param request - DeleteRouteEntryRequest
//
// @return DeleteRouteEntryResponse
func (client *Client) DeleteRouteEntry(request *DeleteRouteEntryRequest) (_result *DeleteRouteEntryResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DeleteRouteEntryResponse{}
	_body, _err := client.DeleteRouteEntryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes a custom route table.
//
// Description:
//
// ## [](#)Description
//
//   - **DeleteRouteTable*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeRouteTableList](https://help.aliyun.com/document_detail/87602.html) operation to query the status of the task.
//
//   - If the custom route table is in the **Deleting*	- state, the custom route table is being deleted.
//
//   - If you cannot query the custom route table, the custom route table is deleted.
//
//   - You cannot repeatedly call the **DeleteRouteTable*	- operation to delete a custom route table within the specified period of time.
//
// @param request - DeleteRouteTableRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteRouteTableResponse
func (client *Client) DeleteRouteTableWithOptions(request *DeleteRouteTableRequest, runtime *dara.RuntimeOptions) (_result *DeleteRouteTableResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.RouteTableId) {
		query["RouteTableId"] = request.RouteTableId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DeleteRouteTable"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DeleteRouteTableResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Deletes a custom route table.
//
// Description:
//
// ## [](#)Description
//
//   - **DeleteRouteTable*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeRouteTableList](https://help.aliyun.com/document_detail/87602.html) operation to query the status of the task.
//
//   - If the custom route table is in the **Deleting*	- state, the custom route table is being deleted.
//
//   - If you cannot query the custom route table, the custom route table is deleted.
//
//   - You cannot repeatedly call the **DeleteRouteTable*	- operation to delete a custom route table within the specified period of time.
//
// @param request - DeleteRouteTableRequest
//
// @return DeleteRouteTableResponse
func (client *Client) DeleteRouteTable(request *DeleteRouteTableRequest) (_result *DeleteRouteTableResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DeleteRouteTableResponse{}
	_body, _err := client.DeleteRouteTableWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes a router interface.
//
// Description:
//
// When you call this operation, take note of the following limits:
//
//   - You can delete only a router interface that is in the **Idle*	- or **Inactive*	- state.
//
//   - Before you delete a router interface, you must delete all custom route entries destined for the router interface.
//
// @param request - DeleteRouterInterfaceRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteRouterInterfaceResponse
func (client *Client) DeleteRouterInterfaceWithOptions(request *DeleteRouterInterfaceRequest, runtime *dara.RuntimeOptions) (_result *DeleteRouterInterfaceResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.RouterInterfaceId) {
		query["RouterInterfaceId"] = request.RouterInterfaceId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DeleteRouterInterface"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DeleteRouterInterfaceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Deletes a router interface.
//
// Description:
//
// When you call this operation, take note of the following limits:
//
//   - You can delete only a router interface that is in the **Idle*	- or **Inactive*	- state.
//
//   - Before you delete a router interface, you must delete all custom route entries destined for the router interface.
//
// @param request - DeleteRouterInterfaceRequest
//
// @return DeleteRouterInterfaceResponse
func (client *Client) DeleteRouterInterface(request *DeleteRouterInterfaceRequest) (_result *DeleteRouterInterfaceResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DeleteRouterInterfaceResponse{}
	_body, _err := client.DeleteRouterInterfaceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes an SNAT entry.
//
// Description:
//
// DeleteSnatEntry is an asynchronous operation. After you make a request, the ID of the request is returned but the specified SNAT entry is not deleted. The system deletes the SNAT entry in the background. You can call the [DescribeSnatTableEntries](https://help.aliyun.com/document_detail/42677.html) operation to query the status of SNAT entries.
//
//   - If the SNAT entries are in the **Deleting*	- state, the system is deleting the SNAT entries. In this case, you can only query the status of the SNAT entries, and cannot perform other operations.
//
//   - If no SNAT entry is returned in the response, the SNAT entry is deleted.
//
// If some SNAT entries are in the **Pending*	- state, you cannot delete these SNAT entries.
//
// @param request - DeleteSnatEntryRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteSnatEntryResponse
func (client *Client) DeleteSnatEntryWithOptions(request *DeleteSnatEntryRequest, runtime *dara.RuntimeOptions) (_result *DeleteSnatEntryResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.SnatEntryId) {
		query["SnatEntryId"] = request.SnatEntryId
	}

	if !dara.IsNil(request.SnatTableId) {
		query["SnatTableId"] = request.SnatTableId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DeleteSnatEntry"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DeleteSnatEntryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Deletes an SNAT entry.
//
// Description:
//
// DeleteSnatEntry is an asynchronous operation. After you make a request, the ID of the request is returned but the specified SNAT entry is not deleted. The system deletes the SNAT entry in the background. You can call the [DescribeSnatTableEntries](https://help.aliyun.com/document_detail/42677.html) operation to query the status of SNAT entries.
//
//   - If the SNAT entries are in the **Deleting*	- state, the system is deleting the SNAT entries. In this case, you can only query the status of the SNAT entries, and cannot perform other operations.
//
//   - If no SNAT entry is returned in the response, the SNAT entry is deleted.
//
// If some SNAT entries are in the **Pending*	- state, you cannot delete these SNAT entries.
//
// @param request - DeleteSnatEntryRequest
//
// @return DeleteSnatEntryResponse
func (client *Client) DeleteSnatEntry(request *DeleteSnatEntryRequest) (_result *DeleteSnatEntryResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DeleteSnatEntryResponse{}
	_body, _err := client.DeleteSnatEntryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes an SSL client certificate.
//
// Description:
//
//	  If you delete an SSL client certificate, all SSL-VPN client connections to the SSL server are disconnected. You need to reinitiate connections from SSL clients.
//
//	    For example, SSL client certificate 1 and SSL client certificate 2 are created on an SSL server. After you delete certificate 1, all client connections associated with certificate 1 and certificate 2 are disconnected from the SSL server.
//
//	    	- If clients associated with certificate 1 require SSL-VPN connections, you need to install other certificates on the clients and reinitiate connections from the clients.
//
//	    	- If clients associated with certificate 2 require SSL-VPN connections, you can directly reinitiate connections from the clients.
//
//		- **DeleteSslVpnClientCert*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) operation to query the status of the task.
//
//	    	- If the VPN gateway is in the **updating*	- state, the SSL client certificate is being deleted.
//
//	    	- If the VPN gateway is in the **active*	- state, the SSL client certificate is deleted.
//
//		- You cannot call **DeleteSslVpnClientCert*	- within the specified period of time.
//
// @param request - DeleteSslVpnClientCertRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteSslVpnClientCertResponse
func (client *Client) DeleteSslVpnClientCertWithOptions(request *DeleteSslVpnClientCertRequest, runtime *dara.RuntimeOptions) (_result *DeleteSslVpnClientCertResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.SslVpnClientCertId) {
		query["SslVpnClientCertId"] = request.SslVpnClientCertId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DeleteSslVpnClientCert"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DeleteSslVpnClientCertResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Deletes an SSL client certificate.
//
// Description:
//
//	  If you delete an SSL client certificate, all SSL-VPN client connections to the SSL server are disconnected. You need to reinitiate connections from SSL clients.
//
//	    For example, SSL client certificate 1 and SSL client certificate 2 are created on an SSL server. After you delete certificate 1, all client connections associated with certificate 1 and certificate 2 are disconnected from the SSL server.
//
//	    	- If clients associated with certificate 1 require SSL-VPN connections, you need to install other certificates on the clients and reinitiate connections from the clients.
//
//	    	- If clients associated with certificate 2 require SSL-VPN connections, you can directly reinitiate connections from the clients.
//
//		- **DeleteSslVpnClientCert*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) operation to query the status of the task.
//
//	    	- If the VPN gateway is in the **updating*	- state, the SSL client certificate is being deleted.
//
//	    	- If the VPN gateway is in the **active*	- state, the SSL client certificate is deleted.
//
//		- You cannot call **DeleteSslVpnClientCert*	- within the specified period of time.
//
// @param request - DeleteSslVpnClientCertRequest
//
// @return DeleteSslVpnClientCertResponse
func (client *Client) DeleteSslVpnClientCert(request *DeleteSslVpnClientCertRequest) (_result *DeleteSslVpnClientCertResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DeleteSslVpnClientCertResponse{}
	_body, _err := client.DeleteSslVpnClientCertWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes an SSL server.
//
// Description:
//
//	  **DeleteSslVpnServer*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) operation to query the status of the task.
//
//	    	- If the VPN gateway is in the **updating*	- state, the SSL server is being deleted.
//
//	    	- If the VPN gateway is in the **active*	- state, the SSL server is deleted.
//
//		- You cannot repeatedly call the **DeleteSslVpnServer*	- operation to delete an SSL server from the same VPN gateway within the specified period of time.
//
// @param request - DeleteSslVpnServerRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteSslVpnServerResponse
func (client *Client) DeleteSslVpnServerWithOptions(request *DeleteSslVpnServerRequest, runtime *dara.RuntimeOptions) (_result *DeleteSslVpnServerResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.SslVpnServerId) {
		query["SslVpnServerId"] = request.SslVpnServerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DeleteSslVpnServer"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DeleteSslVpnServerResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Deletes an SSL server.
//
// Description:
//
//	  **DeleteSslVpnServer*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) operation to query the status of the task.
//
//	    	- If the VPN gateway is in the **updating*	- state, the SSL server is being deleted.
//
//	    	- If the VPN gateway is in the **active*	- state, the SSL server is deleted.
//
//		- You cannot repeatedly call the **DeleteSslVpnServer*	- operation to delete an SSL server from the same VPN gateway within the specified period of time.
//
// @param request - DeleteSslVpnServerRequest
//
// @return DeleteSslVpnServerResponse
func (client *Client) DeleteSslVpnServer(request *DeleteSslVpnServerRequest) (_result *DeleteSslVpnServerResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DeleteSslVpnServerResponse{}
	_body, _err := client.DeleteSslVpnServerWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes a filter of traffic mirror.
//
// Description:
//
//	  The **DeleteTrafficMirrorFilter*	- operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [ListTrafficMirrorFilters](https://help.aliyun.com/document_detail/261353.html) operation to query the status of a filter:
//
//	    	- If the filter is in the **Deleting*	- state, the filter is being deleted.
//
//	    	- If you cannot query the filter, the filter is deleted.
//
//		- You cannot repeatedly call the **DeleteTrafficMirrorFilter*	- operation to delete a filter within the specified period of time.
//
// @param request - DeleteTrafficMirrorFilterRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteTrafficMirrorFilterResponse
func (client *Client) DeleteTrafficMirrorFilterWithOptions(request *DeleteTrafficMirrorFilterRequest, runtime *dara.RuntimeOptions) (_result *DeleteTrafficMirrorFilterResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.TrafficMirrorFilterId) {
		query["TrafficMirrorFilterId"] = request.TrafficMirrorFilterId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DeleteTrafficMirrorFilter"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DeleteTrafficMirrorFilterResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Deletes a filter of traffic mirror.
//
// Description:
//
//	  The **DeleteTrafficMirrorFilter*	- operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [ListTrafficMirrorFilters](https://help.aliyun.com/document_detail/261353.html) operation to query the status of a filter:
//
//	    	- If the filter is in the **Deleting*	- state, the filter is being deleted.
//
//	    	- If you cannot query the filter, the filter is deleted.
//
//		- You cannot repeatedly call the **DeleteTrafficMirrorFilter*	- operation to delete a filter within the specified period of time.
//
// @param request - DeleteTrafficMirrorFilterRequest
//
// @return DeleteTrafficMirrorFilterResponse
func (client *Client) DeleteTrafficMirrorFilter(request *DeleteTrafficMirrorFilterRequest) (_result *DeleteTrafficMirrorFilterResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DeleteTrafficMirrorFilterResponse{}
	_body, _err := client.DeleteTrafficMirrorFilterWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes an inbound or outbound rule of a filter for traffic mirror.
//
// Description:
//
//	  **DeleteTrafficMirrorFilterRules*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [ListTrafficMirrorFilters](https://help.aliyun.com/document_detail/261353.html) to query the status of the task.
//
//	    	- If the inbound or outbound rule is in the **Deleting*	- state, the rule is being deleted.
//
//	    	- If you cannot query the rule, the rule is deleted.
//
//		- You cannot repeatedly call **DeleteTrafficMirrorFilterRules*	- within the specified period of time.
//
// @param request - DeleteTrafficMirrorFilterRulesRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteTrafficMirrorFilterRulesResponse
func (client *Client) DeleteTrafficMirrorFilterRulesWithOptions(request *DeleteTrafficMirrorFilterRulesRequest, runtime *dara.RuntimeOptions) (_result *DeleteTrafficMirrorFilterRulesResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.TrafficMirrorFilterId) {
		query["TrafficMirrorFilterId"] = request.TrafficMirrorFilterId
	}

	if !dara.IsNil(request.TrafficMirrorFilterRuleIds) {
		query["TrafficMirrorFilterRuleIds"] = request.TrafficMirrorFilterRuleIds
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DeleteTrafficMirrorFilterRules"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DeleteTrafficMirrorFilterRulesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Deletes an inbound or outbound rule of a filter for traffic mirror.
//
// Description:
//
//	  **DeleteTrafficMirrorFilterRules*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [ListTrafficMirrorFilters](https://help.aliyun.com/document_detail/261353.html) to query the status of the task.
//
//	    	- If the inbound or outbound rule is in the **Deleting*	- state, the rule is being deleted.
//
//	    	- If you cannot query the rule, the rule is deleted.
//
//		- You cannot repeatedly call **DeleteTrafficMirrorFilterRules*	- within the specified period of time.
//
// @param request - DeleteTrafficMirrorFilterRulesRequest
//
// @return DeleteTrafficMirrorFilterRulesResponse
func (client *Client) DeleteTrafficMirrorFilterRules(request *DeleteTrafficMirrorFilterRulesRequest) (_result *DeleteTrafficMirrorFilterRulesResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DeleteTrafficMirrorFilterRulesResponse{}
	_body, _err := client.DeleteTrafficMirrorFilterRulesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes a traffic mirror session.
//
// Description:
//
//	  **DeleteTrafficMirrorSession*	- is an asynchronous operation. After you send the request, the system returns a request ID and runs the task in the background. You can call the [ListTrafficMirrorSessions](https://help.aliyun.com/document_detail/261367.html) operation to query the status of a traffic mirror session.
//
//	    	- If the traffic mirror session is in the **Deleting*	- state, the traffic mirror session is being deleted.
//
//	    	- If you cannot query the traffic mirror session, the traffic mirror session is deleted.
//
//		- You cannot repeatedly call the **DeleteTrafficMirrorSession*	- operation to delete a traffic mirror session within the specified period of time.
//
// @param request - DeleteTrafficMirrorSessionRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteTrafficMirrorSessionResponse
func (client *Client) DeleteTrafficMirrorSessionWithOptions(request *DeleteTrafficMirrorSessionRequest, runtime *dara.RuntimeOptions) (_result *DeleteTrafficMirrorSessionResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.TrafficMirrorSessionId) {
		query["TrafficMirrorSessionId"] = request.TrafficMirrorSessionId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DeleteTrafficMirrorSession"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DeleteTrafficMirrorSessionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Deletes a traffic mirror session.
//
// Description:
//
//	  **DeleteTrafficMirrorSession*	- is an asynchronous operation. After you send the request, the system returns a request ID and runs the task in the background. You can call the [ListTrafficMirrorSessions](https://help.aliyun.com/document_detail/261367.html) operation to query the status of a traffic mirror session.
//
//	    	- If the traffic mirror session is in the **Deleting*	- state, the traffic mirror session is being deleted.
//
//	    	- If you cannot query the traffic mirror session, the traffic mirror session is deleted.
//
//		- You cannot repeatedly call the **DeleteTrafficMirrorSession*	- operation to delete a traffic mirror session within the specified period of time.
//
// @param request - DeleteTrafficMirrorSessionRequest
//
// @return DeleteTrafficMirrorSessionResponse
func (client *Client) DeleteTrafficMirrorSession(request *DeleteTrafficMirrorSessionRequest) (_result *DeleteTrafficMirrorSessionResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DeleteTrafficMirrorSessionResponse{}
	_body, _err := client.DeleteTrafficMirrorSessionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes a vSwitch.
//
// Description:
//
// When you call this operation, take note of the following limits:
//
//   - Before you delete a vSwitch, you must first release or remove all virtual private cloud (VPC) resources, including vSwitches, instances, router interfaces, and high-availability virtual IP addresses (HaVips).
//
//   - You can delete only vSwitches that are in the **Available*	- state.
//
//   - You cannot delete a vSwitch from a VPC where a vSwitch or a route is being created or deleted.
//
//   - **DeleteVSwitch*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVSwitchAttributes](https://help.aliyun.com/document_detail/94567.html) operation to query the status of the task:
//
//   - If the vSwitch is in the **Pending*	- state, the vSwitch is being deleted.
//
//   - If you cannot query the vSwitch, the vSwitch is deleted.
//
//   - You cannot repeatedly call the **DeleteVSwitch*	- operation to delete a vSwitch within the specified period of time.
//
// @param request - DeleteVSwitchRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteVSwitchResponse
func (client *Client) DeleteVSwitchWithOptions(request *DeleteVSwitchRequest, runtime *dara.RuntimeOptions) (_result *DeleteVSwitchResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.VSwitchId) {
		query["VSwitchId"] = request.VSwitchId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DeleteVSwitch"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DeleteVSwitchResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Deletes a vSwitch.
//
// Description:
//
// When you call this operation, take note of the following limits:
//
//   - Before you delete a vSwitch, you must first release or remove all virtual private cloud (VPC) resources, including vSwitches, instances, router interfaces, and high-availability virtual IP addresses (HaVips).
//
//   - You can delete only vSwitches that are in the **Available*	- state.
//
//   - You cannot delete a vSwitch from a VPC where a vSwitch or a route is being created or deleted.
//
//   - **DeleteVSwitch*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVSwitchAttributes](https://help.aliyun.com/document_detail/94567.html) operation to query the status of the task:
//
//   - If the vSwitch is in the **Pending*	- state, the vSwitch is being deleted.
//
//   - If you cannot query the vSwitch, the vSwitch is deleted.
//
//   - You cannot repeatedly call the **DeleteVSwitch*	- operation to delete a vSwitch within the specified period of time.
//
// @param request - DeleteVSwitchRequest
//
// @return DeleteVSwitchResponse
func (client *Client) DeleteVSwitch(request *DeleteVSwitchRequest) (_result *DeleteVSwitchResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DeleteVSwitchResponse{}
	_body, _err := client.DeleteVSwitchWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes a reserved CIDR block of a vSwitch.
//
// Description:
//
// ## [](#)Description
//
//   - Before you call this operation, make sure that the IP address allocated to an elastic network interface (ENI) from the reserved CIDR block is deleted. If the IP address of the ENI is not deleted, call [UnassignPrivateIpAddresses](https://help.aliyun.com/document_detail/85919.html) or [UnassignIpv6Addresses](https://help.aliyun.com/document_detail/98611.html) to delete the IPv4 or IPv6 address.
//
//   - **DeleteVSwitchCidrReservation*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [ListVSwitchCidrReservations](https://help.aliyun.com/document_detail/610155.html) to query the status of the task:
//
//   - If the reserved CIDR block is in the **Releasing*	- state, it is being released.
//
//   - If the reserved CIDR block is in the **Released*	- state, it is released.
//
// @param request - DeleteVSwitchCidrReservationRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteVSwitchCidrReservationResponse
func (client *Client) DeleteVSwitchCidrReservationWithOptions(request *DeleteVSwitchCidrReservationRequest, runtime *dara.RuntimeOptions) (_result *DeleteVSwitchCidrReservationResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.VSwitchCidrReservationId) {
		query["VSwitchCidrReservationId"] = request.VSwitchCidrReservationId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DeleteVSwitchCidrReservation"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DeleteVSwitchCidrReservationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Deletes a reserved CIDR block of a vSwitch.
//
// Description:
//
// ## [](#)Description
//
//   - Before you call this operation, make sure that the IP address allocated to an elastic network interface (ENI) from the reserved CIDR block is deleted. If the IP address of the ENI is not deleted, call [UnassignPrivateIpAddresses](https://help.aliyun.com/document_detail/85919.html) or [UnassignIpv6Addresses](https://help.aliyun.com/document_detail/98611.html) to delete the IPv4 or IPv6 address.
//
//   - **DeleteVSwitchCidrReservation*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [ListVSwitchCidrReservations](https://help.aliyun.com/document_detail/610155.html) to query the status of the task:
//
//   - If the reserved CIDR block is in the **Releasing*	- state, it is being released.
//
//   - If the reserved CIDR block is in the **Released*	- state, it is released.
//
// @param request - DeleteVSwitchCidrReservationRequest
//
// @return DeleteVSwitchCidrReservationResponse
func (client *Client) DeleteVSwitchCidrReservation(request *DeleteVSwitchCidrReservationRequest) (_result *DeleteVSwitchCidrReservationResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DeleteVSwitchCidrReservationResponse{}
	_body, _err := client.DeleteVSwitchCidrReservationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes a virtual border router (VBR) failover group.
//
// @param request - DeleteVbrHaRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteVbrHaResponse
func (client *Client) DeleteVbrHaWithOptions(request *DeleteVbrHaRequest, runtime *dara.RuntimeOptions) (_result *DeleteVbrHaResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.InstanceId) {
		query["InstanceId"] = request.InstanceId
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DeleteVbrHa"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DeleteVbrHaResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Deletes a virtual border router (VBR) failover group.
//
// @param request - DeleteVbrHaRequest
//
// @return DeleteVbrHaResponse
func (client *Client) DeleteVbrHa(request *DeleteVbrHaRequest) (_result *DeleteVbrHaResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DeleteVbrHaResponse{}
	_body, _err := client.DeleteVbrHaWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes a destination-based route from an IPsec-VPN connection.
//
// Description:
//
//	  **DeleteVcoRouteEntry*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnConnection](https://help.aliyun.com/document_detail/53046.html) operation to query the status of the task.
//
//	    	- If the IPsec-VPN connection is in the **updating*	- state, the route is being deleted.
//
//	    	- If the IPsec-VPN connection is in the **attached*	- state, the route is deleted.
//
//		- You cannot repeatedly call the **DeleteVcoRouteEntry*	- operation within a specific time period.
//
// @param request - DeleteVcoRouteEntryRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteVcoRouteEntryResponse
func (client *Client) DeleteVcoRouteEntryWithOptions(request *DeleteVcoRouteEntryRequest, runtime *dara.RuntimeOptions) (_result *DeleteVcoRouteEntryResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.NextHop) {
		query["NextHop"] = request.NextHop
	}

	if !dara.IsNil(request.OverlayMode) {
		query["OverlayMode"] = request.OverlayMode
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.RouteDest) {
		query["RouteDest"] = request.RouteDest
	}

	if !dara.IsNil(request.VpnConnectionId) {
		query["VpnConnectionId"] = request.VpnConnectionId
	}

	if !dara.IsNil(request.Weight) {
		query["Weight"] = request.Weight
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DeleteVcoRouteEntry"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DeleteVcoRouteEntryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Deletes a destination-based route from an IPsec-VPN connection.
//
// Description:
//
//	  **DeleteVcoRouteEntry*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnConnection](https://help.aliyun.com/document_detail/53046.html) operation to query the status of the task.
//
//	    	- If the IPsec-VPN connection is in the **updating*	- state, the route is being deleted.
//
//	    	- If the IPsec-VPN connection is in the **attached*	- state, the route is deleted.
//
//		- You cannot repeatedly call the **DeleteVcoRouteEntry*	- operation within a specific time period.
//
// @param request - DeleteVcoRouteEntryRequest
//
// @return DeleteVcoRouteEntryResponse
func (client *Client) DeleteVcoRouteEntry(request *DeleteVcoRouteEntryRequest) (_result *DeleteVcoRouteEntryResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DeleteVcoRouteEntryResponse{}
	_body, _err := client.DeleteVcoRouteEntryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes a virtual border router (VBR).
//
// Description:
//
// Before you call this operation, take note of the following limits:
//
//   - Before you delete a VBR, you must delete all router interfaces of the VBR.
//
//   - You can delete only a VBR in the **unconfirmed**, **active**, or **terminated*	- state.
//
//   - The owner of an Express Connect circuit can delete a VBR that belongs to another account only if the VBR is in the **unconfirmed*	- state.
//
// @param request - DeleteVirtualBorderRouterRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteVirtualBorderRouterResponse
func (client *Client) DeleteVirtualBorderRouterWithOptions(request *DeleteVirtualBorderRouterRequest, runtime *dara.RuntimeOptions) (_result *DeleteVirtualBorderRouterResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.VbrId) {
		query["VbrId"] = request.VbrId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DeleteVirtualBorderRouter"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DeleteVirtualBorderRouterResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Deletes a virtual border router (VBR).
//
// Description:
//
// Before you call this operation, take note of the following limits:
//
//   - Before you delete a VBR, you must delete all router interfaces of the VBR.
//
//   - You can delete only a VBR in the **unconfirmed**, **active**, or **terminated*	- state.
//
//   - The owner of an Express Connect circuit can delete a VBR that belongs to another account only if the VBR is in the **unconfirmed*	- state.
//
// @param request - DeleteVirtualBorderRouterRequest
//
// @return DeleteVirtualBorderRouterResponse
func (client *Client) DeleteVirtualBorderRouter(request *DeleteVirtualBorderRouterRequest) (_result *DeleteVirtualBorderRouterResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DeleteVirtualBorderRouterResponse{}
	_body, _err := client.DeleteVirtualBorderRouterWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes a virtual private cloud (VPC).
//
// Description:
//
// When you call this operation, take note of the following limits:
//
//   - Before you delete a VPC, make sure that all resources deployed in the VPC are released or removed, such as vSwitches, instances, and high-availability virtual IP addresses (HaVips).
//
//   - You can delete only a VPC that is in the **Available*	- state.
//
//   - The **DeleteVpc*	- operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeVpcAttribute](https://help.aliyun.com/document_detail/94565.html) operation to query the status of a VPC:
//
//   - If the VPC is in the **Deleting*	- state, the VPC is being deleted.
//
//   - If you cannot query the VPC, the VPC is deleted.
//
//   - You cannot repeatedly call the **DeleteVpc*	- operation to delete a VPC within the specified period of time.
//
// @param request - DeleteVpcRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteVpcResponse
func (client *Client) DeleteVpcWithOptions(request *DeleteVpcRequest, runtime *dara.RuntimeOptions) (_result *DeleteVpcResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.ForceDelete) {
		query["ForceDelete"] = request.ForceDelete
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.VpcId) {
		query["VpcId"] = request.VpcId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DeleteVpc"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DeleteVpcResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Deletes a virtual private cloud (VPC).
//
// Description:
//
// When you call this operation, take note of the following limits:
//
//   - Before you delete a VPC, make sure that all resources deployed in the VPC are released or removed, such as vSwitches, instances, and high-availability virtual IP addresses (HaVips).
//
//   - You can delete only a VPC that is in the **Available*	- state.
//
//   - The **DeleteVpc*	- operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeVpcAttribute](https://help.aliyun.com/document_detail/94565.html) operation to query the status of a VPC:
//
//   - If the VPC is in the **Deleting*	- state, the VPC is being deleted.
//
//   - If you cannot query the VPC, the VPC is deleted.
//
//   - You cannot repeatedly call the **DeleteVpc*	- operation to delete a VPC within the specified period of time.
//
// @param request - DeleteVpcRequest
//
// @return DeleteVpcResponse
func (client *Client) DeleteVpc(request *DeleteVpcRequest) (_result *DeleteVpcResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DeleteVpcResponse{}
	_body, _err := client.DeleteVpcWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes a gateway endpoint.
//
// @param request - DeleteVpcGatewayEndpointRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteVpcGatewayEndpointResponse
func (client *Client) DeleteVpcGatewayEndpointWithOptions(request *DeleteVpcGatewayEndpointRequest, runtime *dara.RuntimeOptions) (_result *DeleteVpcGatewayEndpointResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.EndpointId) {
		query["EndpointId"] = request.EndpointId
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DeleteVpcGatewayEndpoint"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DeleteVpcGatewayEndpointResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Deletes a gateway endpoint.
//
// @param request - DeleteVpcGatewayEndpointRequest
//
// @return DeleteVpcGatewayEndpointResponse
func (client *Client) DeleteVpcGatewayEndpoint(request *DeleteVpcGatewayEndpointRequest) (_result *DeleteVpcGatewayEndpointResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DeleteVpcGatewayEndpointResponse{}
	_body, _err := client.DeleteVpcGatewayEndpointWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes a prefix list.
//
// Description:
//
// You cannot repeatedly call the **DeleteDhcpOptionsSet*	- operation to delete a prefix list within the specified period of time.
//
// @param request - DeleteVpcPrefixListRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteVpcPrefixListResponse
func (client *Client) DeleteVpcPrefixListWithOptions(request *DeleteVpcPrefixListRequest, runtime *dara.RuntimeOptions) (_result *DeleteVpcPrefixListResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PrefixListId) {
		query["PrefixListId"] = request.PrefixListId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DeleteVpcPrefixList"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DeleteVpcPrefixListResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Deletes a prefix list.
//
// Description:
//
// You cannot repeatedly call the **DeleteDhcpOptionsSet*	- operation to delete a prefix list within the specified period of time.
//
// @param request - DeleteVpcPrefixListRequest
//
// @return DeleteVpcPrefixListResponse
func (client *Client) DeleteVpcPrefixList(request *DeleteVpcPrefixListRequest) (_result *DeleteVpcPrefixListResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DeleteVpcPrefixListResponse{}
	_body, _err := client.DeleteVpcPrefixListWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes an IPsec-VPN connection.
//
// Description:
//
//	  If an IPsec-VPN connection is associated with a transit router, you must disassociate the transit router from the IPsec-VPN connection before you delete the IPsec-VPN connection. For more information, see [DeleteTransitRouterVpnAttachment](https://help.aliyun.com/document_detail/468251.html).
//
//		- If an IPsec-VPN connection is not associated with a resource, you can call `DeleteVpnAttachment` to directly delete the IPsec-VPN connection.
//
// @param request - DeleteVpnAttachmentRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteVpnAttachmentResponse
func (client *Client) DeleteVpnAttachmentWithOptions(request *DeleteVpnAttachmentRequest, runtime *dara.RuntimeOptions) (_result *DeleteVpnAttachmentResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.VpnConnectionId) {
		query["VpnConnectionId"] = request.VpnConnectionId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DeleteVpnAttachment"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DeleteVpnAttachmentResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Deletes an IPsec-VPN connection.
//
// Description:
//
//	  If an IPsec-VPN connection is associated with a transit router, you must disassociate the transit router from the IPsec-VPN connection before you delete the IPsec-VPN connection. For more information, see [DeleteTransitRouterVpnAttachment](https://help.aliyun.com/document_detail/468251.html).
//
//		- If an IPsec-VPN connection is not associated with a resource, you can call `DeleteVpnAttachment` to directly delete the IPsec-VPN connection.
//
// @param request - DeleteVpnAttachmentRequest
//
// @return DeleteVpnAttachmentResponse
func (client *Client) DeleteVpnAttachment(request *DeleteVpnAttachmentRequest) (_result *DeleteVpnAttachmentResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DeleteVpnAttachmentResponse{}
	_body, _err := client.DeleteVpnAttachmentWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes an IPsec-VPN connection.
//
// Description:
//
//	  **DeleteVpnConnection*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) operation to query the status of a VPN gateway.
//
//	    	- If a VPN gateway is in the **updating*	- state, the IPsec-VPN connection is being deleted.
//
//	    	- If a VPN gateway is in the **active*	- state, the IPsec-VPN connection has been deleted.
//
//		- You cannot call the **DeleteVpnConnection*	- operation to delete multiple IPsec-VPN connections for a VPN gateway at a time.
//
// >  After an IPsec-VPN connection between a data center and Alibaba Cloud is deleted, the connection between the data center and Alibaba Cloud is closed.
//
// @param request - DeleteVpnConnectionRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteVpnConnectionResponse
func (client *Client) DeleteVpnConnectionWithOptions(request *DeleteVpnConnectionRequest, runtime *dara.RuntimeOptions) (_result *DeleteVpnConnectionResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.VpnConnectionId) {
		query["VpnConnectionId"] = request.VpnConnectionId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DeleteVpnConnection"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DeleteVpnConnectionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Deletes an IPsec-VPN connection.
//
// Description:
//
//	  **DeleteVpnConnection*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) operation to query the status of a VPN gateway.
//
//	    	- If a VPN gateway is in the **updating*	- state, the IPsec-VPN connection is being deleted.
//
//	    	- If a VPN gateway is in the **active*	- state, the IPsec-VPN connection has been deleted.
//
//		- You cannot call the **DeleteVpnConnection*	- operation to delete multiple IPsec-VPN connections for a VPN gateway at a time.
//
// >  After an IPsec-VPN connection between a data center and Alibaba Cloud is deleted, the connection between the data center and Alibaba Cloud is closed.
//
// @param request - DeleteVpnConnectionRequest
//
// @return DeleteVpnConnectionResponse
func (client *Client) DeleteVpnConnection(request *DeleteVpnConnectionRequest) (_result *DeleteVpnConnectionResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DeleteVpnConnectionResponse{}
	_body, _err := client.DeleteVpnConnectionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes a VPN gateway.
//
// Description:
//
// >  You cannot delete a VPN gateway associated with existing IPsec-VPN connections.
//
// @param request - DeleteVpnGatewayRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteVpnGatewayResponse
func (client *Client) DeleteVpnGatewayWithOptions(request *DeleteVpnGatewayRequest, runtime *dara.RuntimeOptions) (_result *DeleteVpnGatewayResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.VpnGatewayId) {
		query["VpnGatewayId"] = request.VpnGatewayId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DeleteVpnGateway"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DeleteVpnGatewayResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Deletes a VPN gateway.
//
// Description:
//
// >  You cannot delete a VPN gateway associated with existing IPsec-VPN connections.
//
// @param request - DeleteVpnGatewayRequest
//
// @return DeleteVpnGatewayResponse
func (client *Client) DeleteVpnGateway(request *DeleteVpnGatewayRequest) (_result *DeleteVpnGatewayResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DeleteVpnGatewayResponse{}
	_body, _err := client.DeleteVpnGatewayWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes a policy-based route from a VPN gateway.
//
// Description:
//
//	  **DeleteVpnPbrRouteEntry*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
//
//	    	- If a VPN gateway is in the **updating*	- state, the policy-based route is being deleted.
//
//	    	- If a VPN gateway is in the **active*	- state, the policy-based route has been deleted.
//
//		- You cannot repeatedly call **DeleteVpnPbrRouteEntry*	- to delete a policy-based route within the specified period of time.
//
// @param request - DeleteVpnPbrRouteEntryRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteVpnPbrRouteEntryResponse
func (client *Client) DeleteVpnPbrRouteEntryWithOptions(request *DeleteVpnPbrRouteEntryRequest, runtime *dara.RuntimeOptions) (_result *DeleteVpnPbrRouteEntryResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.NextHop) {
		query["NextHop"] = request.NextHop
	}

	if !dara.IsNil(request.OverlayMode) {
		query["OverlayMode"] = request.OverlayMode
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.Priority) {
		query["Priority"] = request.Priority
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.RouteDest) {
		query["RouteDest"] = request.RouteDest
	}

	if !dara.IsNil(request.RouteSource) {
		query["RouteSource"] = request.RouteSource
	}

	if !dara.IsNil(request.VpnGatewayId) {
		query["VpnGatewayId"] = request.VpnGatewayId
	}

	if !dara.IsNil(request.Weight) {
		query["Weight"] = request.Weight
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DeleteVpnPbrRouteEntry"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DeleteVpnPbrRouteEntryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Deletes a policy-based route from a VPN gateway.
//
// Description:
//
//	  **DeleteVpnPbrRouteEntry*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
//
//	    	- If a VPN gateway is in the **updating*	- state, the policy-based route is being deleted.
//
//	    	- If a VPN gateway is in the **active*	- state, the policy-based route has been deleted.
//
//		- You cannot repeatedly call **DeleteVpnPbrRouteEntry*	- to delete a policy-based route within the specified period of time.
//
// @param request - DeleteVpnPbrRouteEntryRequest
//
// @return DeleteVpnPbrRouteEntryResponse
func (client *Client) DeleteVpnPbrRouteEntry(request *DeleteVpnPbrRouteEntryRequest) (_result *DeleteVpnPbrRouteEntryResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DeleteVpnPbrRouteEntryResponse{}
	_body, _err := client.DeleteVpnPbrRouteEntryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes a destination-based route from a VPN gateway.
//
// Description:
//
//	  **DeleteVpnRouteEntry*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
//
//	    	- If a VPN gateway is in the **updating*	- state, the destination-based route is being deleted.
//
//	    	- If the VPN gateway is in the **active*	- state, the destination-based route is deleted.
//
//		- You cannot repeatedly call **DeleteVpnRouteEntry*	- to delete a destination-based route from a VPN gateway within the specified period of time.
//
// @param request - DeleteVpnRouteEntryRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteVpnRouteEntryResponse
func (client *Client) DeleteVpnRouteEntryWithOptions(request *DeleteVpnRouteEntryRequest, runtime *dara.RuntimeOptions) (_result *DeleteVpnRouteEntryResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.NextHop) {
		query["NextHop"] = request.NextHop
	}

	if !dara.IsNil(request.OverlayMode) {
		query["OverlayMode"] = request.OverlayMode
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.RouteDest) {
		query["RouteDest"] = request.RouteDest
	}

	if !dara.IsNil(request.VpnGatewayId) {
		query["VpnGatewayId"] = request.VpnGatewayId
	}

	if !dara.IsNil(request.Weight) {
		query["Weight"] = request.Weight
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DeleteVpnRouteEntry"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DeleteVpnRouteEntryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Deletes a destination-based route from a VPN gateway.
//
// Description:
//
//	  **DeleteVpnRouteEntry*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
//
//	    	- If a VPN gateway is in the **updating*	- state, the destination-based route is being deleted.
//
//	    	- If the VPN gateway is in the **active*	- state, the destination-based route is deleted.
//
//		- You cannot repeatedly call **DeleteVpnRouteEntry*	- to delete a destination-based route from a VPN gateway within the specified period of time.
//
// @param request - DeleteVpnRouteEntryRequest
//
// @return DeleteVpnRouteEntryResponse
func (client *Client) DeleteVpnRouteEntry(request *DeleteVpnRouteEntryRequest) (_result *DeleteVpnRouteEntryResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DeleteVpnRouteEntryResponse{}
	_body, _err := client.DeleteVpnRouteEntryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// 
//
// Description:
//
// After you enable deletion protection for an instance, you cannot delete the instance. You must disable deletion protection before you can delete the instance.
//
// @param request - DeletionProtectionRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeletionProtectionResponse
func (client *Client) DeletionProtectionWithOptions(request *DeletionProtectionRequest, runtime *dara.RuntimeOptions) (_result *DeletionProtectionResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.InstanceId) {
		query["InstanceId"] = request.InstanceId
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.ProtectionEnable) {
		query["ProtectionEnable"] = request.ProtectionEnable
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.Type) {
		query["Type"] = request.Type
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DeletionProtection"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DeletionProtectionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// 
//
// Description:
//
// After you enable deletion protection for an instance, you cannot delete the instance. You must disable deletion protection before you can delete the instance.
//
// @param request - DeletionProtectionRequest
//
// @return DeletionProtectionResponse
func (client *Client) DeletionProtection(request *DeletionProtectionRequest) (_result *DeletionProtectionResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DeletionProtectionResponse{}
	_body, _err := client.DeletionProtectionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries traffic data of a pay-by-enhanced-95th-percentile Internet Shared Bandwidth instance.
//
// @param request - Describe95TrafficRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return Describe95TrafficResponse
func (client *Client) Describe95TrafficWithOptions(request *Describe95TrafficRequest, runtime *dara.RuntimeOptions) (_result *Describe95TrafficResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.Day) {
		query["Day"] = request.Day
	}

	if !dara.IsNil(request.InstanceId) {
		query["InstanceId"] = request.InstanceId
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.ResourceType) {
		query["ResourceType"] = request.ResourceType
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("Describe95Traffic"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &Describe95TrafficResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries traffic data of a pay-by-enhanced-95th-percentile Internet Shared Bandwidth instance.
//
// @param request - Describe95TrafficRequest
//
// @return Describe95TrafficResponse
func (client *Client) Describe95Traffic(request *Describe95TrafficRequest) (_result *Describe95TrafficResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &Describe95TrafficResponse{}
	_body, _err := client.Describe95TrafficWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the access points of Express Connect circuits in a region.
//
// @param request - DescribeAccessPointsRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeAccessPointsResponse
func (client *Client) DescribeAccessPointsWithOptions(request *DescribeAccessPointsRequest, runtime *dara.RuntimeOptions) (_result *DescribeAccessPointsResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.AcceptLanguage) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PageNumber) {
		query["PageNumber"] = request.PageNumber
	}

	if !dara.IsNil(request.PageSize) {
		query["PageSize"] = request.PageSize
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeAccessPoints"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DescribeAccessPointsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the access points of Express Connect circuits in a region.
//
// @param request - DescribeAccessPointsRequest
//
// @return DescribeAccessPointsResponse
func (client *Client) DescribeAccessPoints(request *DescribeAccessPointsRequest) (_result *DescribeAccessPointsResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DescribeAccessPointsResponse{}
	_body, _err := client.DescribeAccessPointsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries Border Gateway Protocol (BGP) groups in a region.
//
// @param request - DescribeBgpGroupsRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeBgpGroupsResponse
func (client *Client) DescribeBgpGroupsWithOptions(request *DescribeBgpGroupsRequest, runtime *dara.RuntimeOptions) (_result *DescribeBgpGroupsResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.BgpGroupId) {
		query["BgpGroupId"] = request.BgpGroupId
	}

	if !dara.IsNil(request.IsDefault) {
		query["IsDefault"] = request.IsDefault
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PageNumber) {
		query["PageNumber"] = request.PageNumber
	}

	if !dara.IsNil(request.PageSize) {
		query["PageSize"] = request.PageSize
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.RouterId) {
		query["RouterId"] = request.RouterId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeBgpGroups"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DescribeBgpGroupsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries Border Gateway Protocol (BGP) groups in a region.
//
// @param request - DescribeBgpGroupsRequest
//
// @return DescribeBgpGroupsResponse
func (client *Client) DescribeBgpGroups(request *DescribeBgpGroupsRequest) (_result *DescribeBgpGroupsResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DescribeBgpGroupsResponse{}
	_body, _err := client.DescribeBgpGroupsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries advertised Border Gateway Protocol (BGP) networks.
//
// @param request - DescribeBgpNetworksRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeBgpNetworksResponse
func (client *Client) DescribeBgpNetworksWithOptions(request *DescribeBgpNetworksRequest, runtime *dara.RuntimeOptions) (_result *DescribeBgpNetworksResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PageNumber) {
		query["PageNumber"] = request.PageNumber
	}

	if !dara.IsNil(request.PageSize) {
		query["PageSize"] = request.PageSize
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.RouterId) {
		query["RouterId"] = request.RouterId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeBgpNetworks"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DescribeBgpNetworksResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries advertised Border Gateway Protocol (BGP) networks.
//
// @param request - DescribeBgpNetworksRequest
//
// @return DescribeBgpNetworksResponse
func (client *Client) DescribeBgpNetworks(request *DescribeBgpNetworksRequest) (_result *DescribeBgpNetworksResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DescribeBgpNetworksResponse{}
	_body, _err := client.DescribeBgpNetworksWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries Border Gateway Protocol (BGP) peers in a region.
//
// @param request - DescribeBgpPeersRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeBgpPeersResponse
func (client *Client) DescribeBgpPeersWithOptions(request *DescribeBgpPeersRequest, runtime *dara.RuntimeOptions) (_result *DescribeBgpPeersResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.BgpGroupId) {
		query["BgpGroupId"] = request.BgpGroupId
	}

	if !dara.IsNil(request.BgpPeerId) {
		query["BgpPeerId"] = request.BgpPeerId
	}

	if !dara.IsNil(request.IsDefault) {
		query["IsDefault"] = request.IsDefault
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PageNumber) {
		query["PageNumber"] = request.PageNumber
	}

	if !dara.IsNil(request.PageSize) {
		query["PageSize"] = request.PageSize
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.RouterId) {
		query["RouterId"] = request.RouterId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeBgpPeers"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DescribeBgpPeersResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries Border Gateway Protocol (BGP) peers in a region.
//
// @param request - DescribeBgpPeersRequest
//
// @return DescribeBgpPeersResponse
func (client *Client) DescribeBgpPeers(request *DescribeBgpPeersRequest) (_result *DescribeBgpPeersResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DescribeBgpPeersResponse{}
	_body, _err := client.DescribeBgpPeersWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries a list of Internet Shared Bandwidth instances in a region.
//
// @param request - DescribeCommonBandwidthPackagesRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeCommonBandwidthPackagesResponse
func (client *Client) DescribeCommonBandwidthPackagesWithOptions(request *DescribeCommonBandwidthPackagesRequest, runtime *dara.RuntimeOptions) (_result *DescribeCommonBandwidthPackagesResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.BandwidthPackageId) {
		query["BandwidthPackageId"] = request.BandwidthPackageId
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.IncludeReservationData) {
		query["IncludeReservationData"] = request.IncludeReservationData
	}

	if !dara.IsNil(request.Name) {
		query["Name"] = request.Name
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PageNumber) {
		query["PageNumber"] = request.PageNumber
	}

	if !dara.IsNil(request.PageSize) {
		query["PageSize"] = request.PageSize
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceGroupId) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.SecurityProtectionEnabled) {
		query["SecurityProtectionEnabled"] = request.SecurityProtectionEnabled
	}

	if !dara.IsNil(request.Tag) {
		query["Tag"] = request.Tag
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeCommonBandwidthPackages"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DescribeCommonBandwidthPackagesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries a list of Internet Shared Bandwidth instances in a region.
//
// @param request - DescribeCommonBandwidthPackagesRequest
//
// @return DescribeCommonBandwidthPackagesResponse
func (client *Client) DescribeCommonBandwidthPackages(request *DescribeCommonBandwidthPackagesRequest) (_result *DescribeCommonBandwidthPackagesResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DescribeCommonBandwidthPackagesResponse{}
	_body, _err := client.DescribeCommonBandwidthPackagesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries details of a customer gateway.
//
// @param request - DescribeCustomerGatewayRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeCustomerGatewayResponse
func (client *Client) DescribeCustomerGatewayWithOptions(request *DescribeCustomerGatewayRequest, runtime *dara.RuntimeOptions) (_result *DescribeCustomerGatewayResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.CustomerGatewayId) {
		query["CustomerGatewayId"] = request.CustomerGatewayId
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeCustomerGateway"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DescribeCustomerGatewayResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries details of a customer gateway.
//
// @param request - DescribeCustomerGatewayRequest
//
// @return DescribeCustomerGatewayResponse
func (client *Client) DescribeCustomerGateway(request *DescribeCustomerGatewayRequest) (_result *DescribeCustomerGatewayResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DescribeCustomerGatewayResponse{}
	_body, _err := client.DescribeCustomerGatewayWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries customer gateways.
//
// @param request - DescribeCustomerGatewaysRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeCustomerGatewaysResponse
func (client *Client) DescribeCustomerGatewaysWithOptions(request *DescribeCustomerGatewaysRequest, runtime *dara.RuntimeOptions) (_result *DescribeCustomerGatewaysResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.CustomerGatewayId) {
		query["CustomerGatewayId"] = request.CustomerGatewayId
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PageNumber) {
		query["PageNumber"] = request.PageNumber
	}

	if !dara.IsNil(request.PageSize) {
		query["PageSize"] = request.PageSize
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceGroupId) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.Tag) {
		query["Tag"] = request.Tag
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeCustomerGateways"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DescribeCustomerGatewaysResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries customer gateways.
//
// @param request - DescribeCustomerGatewaysRequest
//
// @return DescribeCustomerGatewaysResponse
func (client *Client) DescribeCustomerGateways(request *DescribeCustomerGatewaysRequest) (_result *DescribeCustomerGatewaysResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DescribeCustomerGatewaysResponse{}
	_body, _err := client.DescribeCustomerGatewaysWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries whether permissions on a virtual private cloud (VPC) are granted to a virtual border router (VBR).
//
// @param request - DescribeEcGrantRelationRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeEcGrantRelationResponse
func (client *Client) DescribeEcGrantRelationWithOptions(request *DescribeEcGrantRelationRequest, runtime *dara.RuntimeOptions) (_result *DescribeEcGrantRelationResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.InstanceId) {
		query["InstanceId"] = request.InstanceId
	}

	if !dara.IsNil(request.InstanceType) {
		query["InstanceType"] = request.InstanceType
	}

	if !dara.IsNil(request.PageNumber) {
		query["PageNumber"] = request.PageNumber
	}

	if !dara.IsNil(request.PageSize) {
		query["PageSize"] = request.PageSize
	}

	if !dara.IsNil(request.VbrRegionNo) {
		query["VbrRegionNo"] = request.VbrRegionNo
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeEcGrantRelation"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DescribeEcGrantRelationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries whether permissions on a virtual private cloud (VPC) are granted to a virtual border router (VBR).
//
// @param request - DescribeEcGrantRelationRequest
//
// @return DescribeEcGrantRelationResponse
func (client *Client) DescribeEcGrantRelation(request *DescribeEcGrantRelationRequest) (_result *DescribeEcGrantRelationResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DescribeEcGrantRelationResponse{}
	_body, _err := client.DescribeEcGrantRelationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries elastic IP addresses (EIPs) created in a region.
//
// Description:
//
// You can call this operation to query information about EIPs in a region, including maximum bandwidth, billing methods, and associated instances.
//
// @param request - DescribeEipAddressesRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeEipAddressesResponse
func (client *Client) DescribeEipAddressesWithOptions(request *DescribeEipAddressesRequest, runtime *dara.RuntimeOptions) (_result *DescribeEipAddressesResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.AllocationId) {
		query["AllocationId"] = request.AllocationId
	}

	if !dara.IsNil(request.AssociatedInstanceId) {
		query["AssociatedInstanceId"] = request.AssociatedInstanceId
	}

	if !dara.IsNil(request.AssociatedInstanceType) {
		query["AssociatedInstanceType"] = request.AssociatedInstanceType
	}

	if !dara.IsNil(request.ChargeType) {
		query["ChargeType"] = request.ChargeType
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.EipAddress) {
		query["EipAddress"] = request.EipAddress
	}

	if !dara.IsNil(request.EipName) {
		query["EipName"] = request.EipName
	}

	if !dara.IsNil(request.ISP) {
		query["ISP"] = request.ISP
	}

	if !dara.IsNil(request.IncludeReservationData) {
		query["IncludeReservationData"] = request.IncludeReservationData
	}

	if !dara.IsNil(request.LockReason) {
		query["LockReason"] = request.LockReason
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PageNumber) {
		query["PageNumber"] = request.PageNumber
	}

	if !dara.IsNil(request.PageSize) {
		query["PageSize"] = request.PageSize
	}

	if !dara.IsNil(request.PublicIpAddressPoolId) {
		query["PublicIpAddressPoolId"] = request.PublicIpAddressPoolId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceGroupId) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.SecurityProtectionEnabled) {
		query["SecurityProtectionEnabled"] = request.SecurityProtectionEnabled
	}

	if !dara.IsNil(request.SegmentInstanceId) {
		query["SegmentInstanceId"] = request.SegmentInstanceId
	}

	if !dara.IsNil(request.ServiceManaged) {
		query["ServiceManaged"] = request.ServiceManaged
	}

	if !dara.IsNil(request.Status) {
		query["Status"] = request.Status
	}

	if !dara.IsNil(request.Tag) {
		query["Tag"] = request.Tag
	}

	if !dara.IsNil(request.Filter) {
		query["Filter"] = request.Filter
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeEipAddresses"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DescribeEipAddressesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries elastic IP addresses (EIPs) created in a region.
//
// Description:
//
// You can call this operation to query information about EIPs in a region, including maximum bandwidth, billing methods, and associated instances.
//
// @param request - DescribeEipAddressesRequest
//
// @return DescribeEipAddressesResponse
func (client *Client) DescribeEipAddresses(request *DescribeEipAddressesRequest) (_result *DescribeEipAddressesResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DescribeEipAddressesResponse{}
	_body, _err := client.DescribeEipAddressesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the gateway and subnet mask of an elastic IP address (EIP).
//
// Description:
//
// You can query only EIPs that are associated with secondary elastic network interfaces (ENIs) in multi-EIP-to-ENI mode.
//
// @param request - DescribeEipGatewayInfoRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeEipGatewayInfoResponse
func (client *Client) DescribeEipGatewayInfoWithOptions(request *DescribeEipGatewayInfoRequest, runtime *dara.RuntimeOptions) (_result *DescribeEipGatewayInfoResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.InstanceId) {
		query["InstanceId"] = request.InstanceId
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeEipGatewayInfo"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DescribeEipGatewayInfoResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the gateway and subnet mask of an elastic IP address (EIP).
//
// Description:
//
// You can query only EIPs that are associated with secondary elastic network interfaces (ENIs) in multi-EIP-to-ENI mode.
//
// @param request - DescribeEipGatewayInfoRequest
//
// @return DescribeEipGatewayInfoResponse
func (client *Client) DescribeEipGatewayInfo(request *DescribeEipGatewayInfoRequest) (_result *DescribeEipGatewayInfoResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DescribeEipGatewayInfoResponse{}
	_body, _err := client.DescribeEipGatewayInfoWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the monitoring data of an elastic IP address (EIP). You can query monitoring data within the last 30 days, and obtain up to 400 data points in each request.
//
// Description:
//
// To improve user experience in querying monitoring data, we recommend that you call the DescribeMetricList API operation provided by CloudMonitor to query EIP monitoring data. For more information, see [DescribeMetricList](https://help.aliyun.com/document_detail/51936.html) and [EIP monitoring data](https://help.aliyun.com/document_detail/162874.html).
//
// @param request - DescribeEipMonitorDataRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeEipMonitorDataResponse
func (client *Client) DescribeEipMonitorDataWithOptions(request *DescribeEipMonitorDataRequest, runtime *dara.RuntimeOptions) (_result *DescribeEipMonitorDataResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.AllocationId) {
		query["AllocationId"] = request.AllocationId
	}

	if !dara.IsNil(request.EndTime) {
		query["EndTime"] = request.EndTime
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.Period) {
		query["Period"] = request.Period
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.StartTime) {
		query["StartTime"] = request.StartTime
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeEipMonitorData"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DescribeEipMonitorDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the monitoring data of an elastic IP address (EIP). You can query monitoring data within the last 30 days, and obtain up to 400 data points in each request.
//
// Description:
//
// To improve user experience in querying monitoring data, we recommend that you call the DescribeMetricList API operation provided by CloudMonitor to query EIP monitoring data. For more information, see [DescribeMetricList](https://help.aliyun.com/document_detail/51936.html) and [EIP monitoring data](https://help.aliyun.com/document_detail/162874.html).
//
// @param request - DescribeEipMonitorDataRequest
//
// @return DescribeEipMonitorDataResponse
func (client *Client) DescribeEipMonitorData(request *DescribeEipMonitorDataRequest) (_result *DescribeEipMonitorDataResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DescribeEipMonitorDataResponse{}
	_body, _err := client.DescribeEipMonitorDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries contiguous elastic IP address (EIP) groups.
//
// @param request - DescribeEipSegmentRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeEipSegmentResponse
func (client *Client) DescribeEipSegmentWithOptions(request *DescribeEipSegmentRequest, runtime *dara.RuntimeOptions) (_result *DescribeEipSegmentResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PageNumber) {
		query["PageNumber"] = request.PageNumber
	}

	if !dara.IsNil(request.PageSize) {
		query["PageSize"] = request.PageSize
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.SegmentInstanceId) {
		query["SegmentInstanceId"] = request.SegmentInstanceId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeEipSegment"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DescribeEipSegmentResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries contiguous elastic IP address (EIP) groups.
//
// @param request - DescribeEipSegmentRequest
//
// @return DescribeEipSegmentResponse
func (client *Client) DescribeEipSegment(request *DescribeEipSegmentRequest) (_result *DescribeEipSegmentResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DescribeEipSegmentResponse{}
	_body, _err := client.DescribeEipSegmentWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the quality of service (QoS) policies of Express Connect. The response can be displayed by page.
//
// @param request - DescribeExpressConnectTrafficQosRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeExpressConnectTrafficQosResponse
func (client *Client) DescribeExpressConnectTrafficQosWithOptions(request *DescribeExpressConnectTrafficQosRequest, runtime *dara.RuntimeOptions) (_result *DescribeExpressConnectTrafficQosResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.MaxResults) {
		query["MaxResults"] = request.MaxResults
	}

	if !dara.IsNil(request.NextToken) {
		query["NextToken"] = request.NextToken
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.QosIdList) {
		query["QosIdList"] = request.QosIdList
	}

	if !dara.IsNil(request.QosNameList) {
		query["QosNameList"] = request.QosNameList
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceGroupId) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.Tags) {
		query["Tags"] = request.Tags
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeExpressConnectTrafficQos"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DescribeExpressConnectTrafficQosResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the quality of service (QoS) policies of Express Connect. The response can be displayed by page.
//
// @param request - DescribeExpressConnectTrafficQosRequest
//
// @return DescribeExpressConnectTrafficQosResponse
func (client *Client) DescribeExpressConnectTrafficQos(request *DescribeExpressConnectTrafficQosRequest) (_result *DescribeExpressConnectTrafficQosResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DescribeExpressConnectTrafficQosResponse{}
	_body, _err := client.DescribeExpressConnectTrafficQosWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the information about the quality of service (QoS) queues of the Express Connect circuit.
//
// @param request - DescribeExpressConnectTrafficQosQueueRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeExpressConnectTrafficQosQueueResponse
func (client *Client) DescribeExpressConnectTrafficQosQueueWithOptions(request *DescribeExpressConnectTrafficQosQueueRequest, runtime *dara.RuntimeOptions) (_result *DescribeExpressConnectTrafficQosQueueResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.QosId) {
		query["QosId"] = request.QosId
	}

	if !dara.IsNil(request.QueueIdList) {
		query["QueueIdList"] = request.QueueIdList
	}

	if !dara.IsNil(request.QueueNameList) {
		query["QueueNameList"] = request.QueueNameList
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeExpressConnectTrafficQosQueue"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DescribeExpressConnectTrafficQosQueueResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the information about the quality of service (QoS) queues of the Express Connect circuit.
//
// @param request - DescribeExpressConnectTrafficQosQueueRequest
//
// @return DescribeExpressConnectTrafficQosQueueResponse
func (client *Client) DescribeExpressConnectTrafficQosQueue(request *DescribeExpressConnectTrafficQosQueueRequest) (_result *DescribeExpressConnectTrafficQosQueueResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DescribeExpressConnectTrafficQosQueueResponse{}
	_body, _err := client.DescribeExpressConnectTrafficQosQueueWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries quality of service (QoS) rules. Paging parameters are not supported.
//
// @param request - DescribeExpressConnectTrafficQosRuleRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeExpressConnectTrafficQosRuleResponse
func (client *Client) DescribeExpressConnectTrafficQosRuleWithOptions(request *DescribeExpressConnectTrafficQosRuleRequest, runtime *dara.RuntimeOptions) (_result *DescribeExpressConnectTrafficQosRuleResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.QosId) {
		query["QosId"] = request.QosId
	}

	if !dara.IsNil(request.QueueId) {
		query["QueueId"] = request.QueueId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.RuleIdList) {
		query["RuleIdList"] = request.RuleIdList
	}

	if !dara.IsNil(request.RuleNameList) {
		query["RuleNameList"] = request.RuleNameList
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeExpressConnectTrafficQosRule"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DescribeExpressConnectTrafficQosRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries quality of service (QoS) rules. Paging parameters are not supported.
//
// @param request - DescribeExpressConnectTrafficQosRuleRequest
//
// @return DescribeExpressConnectTrafficQosRuleResponse
func (client *Client) DescribeExpressConnectTrafficQosRule(request *DescribeExpressConnectTrafficQosRuleRequest) (_result *DescribeExpressConnectTrafficQosRuleResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DescribeExpressConnectTrafficQosRuleResponse{}
	_body, _err := client.DescribeExpressConnectTrafficQosRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries failover tests.
//
// @param request - DescribeFailoverTestJobRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeFailoverTestJobResponse
func (client *Client) DescribeFailoverTestJobWithOptions(request *DescribeFailoverTestJobRequest, runtime *dara.RuntimeOptions) (_result *DescribeFailoverTestJobResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.JobId) {
		query["JobId"] = request.JobId
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeFailoverTestJob"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DescribeFailoverTestJobResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries failover tests.
//
// @param request - DescribeFailoverTestJobRequest
//
// @return DescribeFailoverTestJobResponse
func (client *Client) DescribeFailoverTestJob(request *DescribeFailoverTestJobRequest) (_result *DescribeFailoverTestJobResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DescribeFailoverTestJobResponse{}
	_body, _err := client.DescribeFailoverTestJobWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries failover tests for Express Connect.
//
// @param request - DescribeFailoverTestJobsRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeFailoverTestJobsResponse
func (client *Client) DescribeFailoverTestJobsWithOptions(request *DescribeFailoverTestJobsRequest, runtime *dara.RuntimeOptions) (_result *DescribeFailoverTestJobsResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.Filter) {
		query["Filter"] = request.Filter
	}

	if !dara.IsNil(request.MaxResults) {
		query["MaxResults"] = request.MaxResults
	}

	if !dara.IsNil(request.NextToken) {
		query["NextToken"] = request.NextToken
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeFailoverTestJobs"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DescribeFailoverTestJobsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries failover tests for Express Connect.
//
// @param request - DescribeFailoverTestJobsRequest
//
// @return DescribeFailoverTestJobsResponse
func (client *Client) DescribeFailoverTestJobs(request *DescribeFailoverTestJobsRequest) (_result *DescribeFailoverTestJobsResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DescribeFailoverTestJobsResponse{}
	_body, _err := client.DescribeFailoverTestJobsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Query flow logs.
//
// @param request - DescribeFlowLogsRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeFlowLogsResponse
func (client *Client) DescribeFlowLogsWithOptions(request *DescribeFlowLogsRequest, runtime *dara.RuntimeOptions) (_result *DescribeFlowLogsResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.Description) {
		query["Description"] = request.Description
	}

	if !dara.IsNil(request.FlowLogId) {
		query["FlowLogId"] = request.FlowLogId
	}

	if !dara.IsNil(request.FlowLogName) {
		query["FlowLogName"] = request.FlowLogName
	}

	if !dara.IsNil(request.LogStoreName) {
		query["LogStoreName"] = request.LogStoreName
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PageNumber) {
		query["PageNumber"] = request.PageNumber
	}

	if !dara.IsNil(request.PageSize) {
		query["PageSize"] = request.PageSize
	}

	if !dara.IsNil(request.ProjectName) {
		query["ProjectName"] = request.ProjectName
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceGroupId) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !dara.IsNil(request.ResourceId) {
		query["ResourceId"] = request.ResourceId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.ResourceType) {
		query["ResourceType"] = request.ResourceType
	}

	if !dara.IsNil(request.Status) {
		query["Status"] = request.Status
	}

	if !dara.IsNil(request.Tags) {
		query["Tags"] = request.Tags
	}

	if !dara.IsNil(request.TrafficType) {
		query["TrafficType"] = request.TrafficType
	}

	if !dara.IsNil(request.VpcId) {
		query["VpcId"] = request.VpcId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeFlowLogs"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DescribeFlowLogsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Query flow logs.
//
// @param request - DescribeFlowLogsRequest
//
// @return DescribeFlowLogsResponse
func (client *Client) DescribeFlowLogs(request *DescribeFlowLogsRequest) (_result *DescribeFlowLogsResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DescribeFlowLogsResponse{}
	_body, _err := client.DescribeFlowLogsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries DNAT entries.
//
// @param request - DescribeForwardTableEntriesRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeForwardTableEntriesResponse
func (client *Client) DescribeForwardTableEntriesWithOptions(request *DescribeForwardTableEntriesRequest, runtime *dara.RuntimeOptions) (_result *DescribeForwardTableEntriesResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ExternalIp) {
		query["ExternalIp"] = request.ExternalIp
	}

	if !dara.IsNil(request.ExternalPort) {
		query["ExternalPort"] = request.ExternalPort
	}

	if !dara.IsNil(request.ForwardEntryId) {
		query["ForwardEntryId"] = request.ForwardEntryId
	}

	if !dara.IsNil(request.ForwardEntryName) {
		query["ForwardEntryName"] = request.ForwardEntryName
	}

	if !dara.IsNil(request.ForwardTableId) {
		query["ForwardTableId"] = request.ForwardTableId
	}

	if !dara.IsNil(request.InternalIp) {
		query["InternalIp"] = request.InternalIp
	}

	if !dara.IsNil(request.InternalPort) {
		query["InternalPort"] = request.InternalPort
	}

	if !dara.IsNil(request.IpProtocol) {
		query["IpProtocol"] = request.IpProtocol
	}

	if !dara.IsNil(request.NatGatewayId) {
		query["NatGatewayId"] = request.NatGatewayId
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PageNumber) {
		query["PageNumber"] = request.PageNumber
	}

	if !dara.IsNil(request.PageSize) {
		query["PageSize"] = request.PageSize
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeForwardTableEntries"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DescribeForwardTableEntriesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries DNAT entries.
//
// @param request - DescribeForwardTableEntriesRequest
//
// @return DescribeForwardTableEntriesResponse
func (client *Client) DescribeForwardTableEntries(request *DescribeForwardTableEntriesRequest) (_result *DescribeForwardTableEntriesResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DescribeForwardTableEntriesResponse{}
	_body, _err := client.DescribeForwardTableEntriesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries Global Accelerator (GA) instances.
//
// @param request - DescribeGlobalAccelerationInstancesRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeGlobalAccelerationInstancesResponse
func (client *Client) DescribeGlobalAccelerationInstancesWithOptions(request *DescribeGlobalAccelerationInstancesRequest, runtime *dara.RuntimeOptions) (_result *DescribeGlobalAccelerationInstancesResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.BandwidthType) {
		query["BandwidthType"] = request.BandwidthType
	}

	if !dara.IsNil(request.GlobalAccelerationInstanceId) {
		query["GlobalAccelerationInstanceId"] = request.GlobalAccelerationInstanceId
	}

	if !dara.IsNil(request.IncludeReservationData) {
		query["IncludeReservationData"] = request.IncludeReservationData
	}

	if !dara.IsNil(request.IpAddress) {
		query["IpAddress"] = request.IpAddress
	}

	if !dara.IsNil(request.Name) {
		query["Name"] = request.Name
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PageNumber) {
		query["PageNumber"] = request.PageNumber
	}

	if !dara.IsNil(request.PageSize) {
		query["PageSize"] = request.PageSize
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.ServerId) {
		query["ServerId"] = request.ServerId
	}

	if !dara.IsNil(request.ServiceLocation) {
		query["ServiceLocation"] = request.ServiceLocation
	}

	if !dara.IsNil(request.Status) {
		query["Status"] = request.Status
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeGlobalAccelerationInstances"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DescribeGlobalAccelerationInstancesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries Global Accelerator (GA) instances.
//
// @param request - DescribeGlobalAccelerationInstancesRequest
//
// @return DescribeGlobalAccelerationInstancesResponse
func (client *Client) DescribeGlobalAccelerationInstances(request *DescribeGlobalAccelerationInstancesRequest) (_result *DescribeGlobalAccelerationInstancesResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DescribeGlobalAccelerationInstancesResponse{}
	_body, _err := client.DescribeGlobalAccelerationInstancesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// VPCVBR
//
// @param request - DescribeGrantRulesToCenRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeGrantRulesToCenResponse
func (client *Client) DescribeGrantRulesToCenWithOptions(request *DescribeGrantRulesToCenRequest, runtime *dara.RuntimeOptions) (_result *DescribeGrantRulesToCenResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.InstanceId) {
		query["InstanceId"] = request.InstanceId
	}

	if !dara.IsNil(request.InstanceType) {
		query["InstanceType"] = request.InstanceType
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PageNumber) {
		query["PageNumber"] = request.PageNumber
	}

	if !dara.IsNil(request.PageSize) {
		query["PageSize"] = request.PageSize
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceGroupId) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeGrantRulesToCen"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DescribeGrantRulesToCenResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// VPCVBR
//
// @param request - DescribeGrantRulesToCenRequest
//
// @return DescribeGrantRulesToCenResponse
func (client *Client) DescribeGrantRulesToCen(request *DescribeGrantRulesToCenRequest) (_result *DescribeGrantRulesToCenResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DescribeGrantRulesToCenResponse{}
	_body, _err := client.DescribeGrantRulesToCenWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries HaVips in a region.
//
// @param request - DescribeHaVipsRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeHaVipsResponse
func (client *Client) DescribeHaVipsWithOptions(request *DescribeHaVipsRequest, runtime *dara.RuntimeOptions) (_result *DescribeHaVipsResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.Filter) {
		query["Filter"] = request.Filter
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PageNumber) {
		query["PageNumber"] = request.PageNumber
	}

	if !dara.IsNil(request.PageSize) {
		query["PageSize"] = request.PageSize
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceGroupId) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.Tags) {
		query["Tags"] = request.Tags
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeHaVips"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DescribeHaVipsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries HaVips in a region.
//
// @param request - DescribeHaVipsRequest
//
// @return DescribeHaVipsResponse
func (client *Client) DescribeHaVips(request *DescribeHaVipsRequest) (_result *DescribeHaVipsResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DescribeHaVipsResponse{}
	_body, _err := client.DescribeHaVipsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries configurations about the fine-grained monitoring feature of an elastic IP address (EIP).
//
// @param request - DescribeHighDefinitionMonitorLogAttributeRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeHighDefinitionMonitorLogAttributeResponse
func (client *Client) DescribeHighDefinitionMonitorLogAttributeWithOptions(request *DescribeHighDefinitionMonitorLogAttributeRequest, runtime *dara.RuntimeOptions) (_result *DescribeHighDefinitionMonitorLogAttributeResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.InstanceId) {
		query["InstanceId"] = request.InstanceId
	}

	if !dara.IsNil(request.InstanceType) {
		query["InstanceType"] = request.InstanceType
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeHighDefinitionMonitorLogAttribute"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DescribeHighDefinitionMonitorLogAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries configurations about the fine-grained monitoring feature of an elastic IP address (EIP).
//
// @param request - DescribeHighDefinitionMonitorLogAttributeRequest
//
// @return DescribeHighDefinitionMonitorLogAttributeResponse
func (client *Client) DescribeHighDefinitionMonitorLogAttribute(request *DescribeHighDefinitionMonitorLogAttributeRequest) (_result *DescribeHighDefinitionMonitorLogAttributeResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DescribeHighDefinitionMonitorLogAttributeResponse{}
	_body, _err := client.DescribeHighDefinitionMonitorLogAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the details of an access control list (ACL), including the specified IP addresses and associated IPv6 mapping entries.
//
// @param request - DescribeIPv6TranslatorAclListAttributesRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeIPv6TranslatorAclListAttributesResponse
func (client *Client) DescribeIPv6TranslatorAclListAttributesWithOptions(request *DescribeIPv6TranslatorAclListAttributesRequest, runtime *dara.RuntimeOptions) (_result *DescribeIPv6TranslatorAclListAttributesResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.AclId) {
		query["AclId"] = request.AclId
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PageNumber) {
		query["PageNumber"] = request.PageNumber
	}

	if !dara.IsNil(request.PageSize) {
		query["PageSize"] = request.PageSize
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeIPv6TranslatorAclListAttributes"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DescribeIPv6TranslatorAclListAttributesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the details of an access control list (ACL), including the specified IP addresses and associated IPv6 mapping entries.
//
// @param request - DescribeIPv6TranslatorAclListAttributesRequest
//
// @return DescribeIPv6TranslatorAclListAttributesResponse
func (client *Client) DescribeIPv6TranslatorAclListAttributes(request *DescribeIPv6TranslatorAclListAttributesRequest) (_result *DescribeIPv6TranslatorAclListAttributesResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DescribeIPv6TranslatorAclListAttributesResponse{}
	_body, _err := client.DescribeIPv6TranslatorAclListAttributesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Deprecated: OpenAPI DescribeIPv6TranslatorAclLists is deprecated
//
// Summary:
//
// Queries access control lists (ACLs).
//
// @param request - DescribeIPv6TranslatorAclListsRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeIPv6TranslatorAclListsResponse
func (client *Client) DescribeIPv6TranslatorAclListsWithOptions(request *DescribeIPv6TranslatorAclListsRequest, runtime *dara.RuntimeOptions) (_result *DescribeIPv6TranslatorAclListsResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.AclId) {
		query["AclId"] = request.AclId
	}

	if !dara.IsNil(request.AclName) {
		query["AclName"] = request.AclName
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PageNumber) {
		query["PageNumber"] = request.PageNumber
	}

	if !dara.IsNil(request.PageSize) {
		query["PageSize"] = request.PageSize
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeIPv6TranslatorAclLists"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DescribeIPv6TranslatorAclListsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Deprecated: OpenAPI DescribeIPv6TranslatorAclLists is deprecated
//
// Summary:
//
// Queries access control lists (ACLs).
//
// @param request - DescribeIPv6TranslatorAclListsRequest
//
// @return DescribeIPv6TranslatorAclListsResponse
// Deprecated
func (client *Client) DescribeIPv6TranslatorAclLists(request *DescribeIPv6TranslatorAclListsRequest) (_result *DescribeIPv6TranslatorAclListsResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DescribeIPv6TranslatorAclListsResponse{}
	_body, _err := client.DescribeIPv6TranslatorAclListsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Deprecated: OpenAPI DescribeIPv6TranslatorEntries is deprecated
//
// Summary:
//
// Queries IPv6 mapping entries.
//
// @param request - DescribeIPv6TranslatorEntriesRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeIPv6TranslatorEntriesResponse
func (client *Client) DescribeIPv6TranslatorEntriesWithOptions(request *DescribeIPv6TranslatorEntriesRequest, runtime *dara.RuntimeOptions) (_result *DescribeIPv6TranslatorEntriesResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.AclId) {
		query["AclId"] = request.AclId
	}

	if !dara.IsNil(request.AclStatus) {
		query["AclStatus"] = request.AclStatus
	}

	if !dara.IsNil(request.AclType) {
		query["AclType"] = request.AclType
	}

	if !dara.IsNil(request.AllocateIpv6Addr) {
		query["AllocateIpv6Addr"] = request.AllocateIpv6Addr
	}

	if !dara.IsNil(request.AllocateIpv6Port) {
		query["AllocateIpv6Port"] = request.AllocateIpv6Port
	}

	if !dara.IsNil(request.BackendIpv4Addr) {
		query["BackendIpv4Addr"] = request.BackendIpv4Addr
	}

	if !dara.IsNil(request.BackendIpv4Port) {
		query["BackendIpv4Port"] = request.BackendIpv4Port
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.EntryName) {
		query["EntryName"] = request.EntryName
	}

	if !dara.IsNil(request.Ipv6TranslatorEntryId) {
		query["Ipv6TranslatorEntryId"] = request.Ipv6TranslatorEntryId
	}

	if !dara.IsNil(request.Ipv6TranslatorId) {
		query["Ipv6TranslatorId"] = request.Ipv6TranslatorId
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PageNumber) {
		query["PageNumber"] = request.PageNumber
	}

	if !dara.IsNil(request.PageSize) {
		query["PageSize"] = request.PageSize
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.TransProtocol) {
		query["TransProtocol"] = request.TransProtocol
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeIPv6TranslatorEntries"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DescribeIPv6TranslatorEntriesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Deprecated: OpenAPI DescribeIPv6TranslatorEntries is deprecated
//
// Summary:
//
// Queries IPv6 mapping entries.
//
// @param request - DescribeIPv6TranslatorEntriesRequest
//
// @return DescribeIPv6TranslatorEntriesResponse
// Deprecated
func (client *Client) DescribeIPv6TranslatorEntries(request *DescribeIPv6TranslatorEntriesRequest) (_result *DescribeIPv6TranslatorEntriesResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DescribeIPv6TranslatorEntriesResponse{}
	_body, _err := client.DescribeIPv6TranslatorEntriesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Deprecated: OpenAPI DescribeIPv6Translators is deprecated
//
// Summary:
//
// Queries IPv6 Translation Service instances.
//
// @param request - DescribeIPv6TranslatorsRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeIPv6TranslatorsResponse
func (client *Client) DescribeIPv6TranslatorsWithOptions(request *DescribeIPv6TranslatorsRequest, runtime *dara.RuntimeOptions) (_result *DescribeIPv6TranslatorsResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.AllocateIpv4Addr) {
		query["AllocateIpv4Addr"] = request.AllocateIpv4Addr
	}

	if !dara.IsNil(request.AllocateIpv6Addr) {
		query["AllocateIpv6Addr"] = request.AllocateIpv6Addr
	}

	if !dara.IsNil(request.BusinessStatus) {
		query["BusinessStatus"] = request.BusinessStatus
	}

	if !dara.IsNil(request.Ipv6TranslatorId) {
		query["Ipv6TranslatorId"] = request.Ipv6TranslatorId
	}

	if !dara.IsNil(request.Name) {
		query["Name"] = request.Name
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PageNumber) {
		query["PageNumber"] = request.PageNumber
	}

	if !dara.IsNil(request.PageSize) {
		query["PageSize"] = request.PageSize
	}

	if !dara.IsNil(request.PayType) {
		query["PayType"] = request.PayType
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.Spec) {
		query["Spec"] = request.Spec
	}

	if !dara.IsNil(request.Status) {
		query["Status"] = request.Status
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeIPv6Translators"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DescribeIPv6TranslatorsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Deprecated: OpenAPI DescribeIPv6Translators is deprecated
//
// Summary:
//
// Queries IPv6 Translation Service instances.
//
// @param request - DescribeIPv6TranslatorsRequest
//
// @return DescribeIPv6TranslatorsResponse
// Deprecated
func (client *Client) DescribeIPv6Translators(request *DescribeIPv6TranslatorsRequest) (_result *DescribeIPv6TranslatorsResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DescribeIPv6TranslatorsResponse{}
	_body, _err := client.DescribeIPv6TranslatorsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries IPv6 addresses in a region.
//
// @param request - DescribeIpv6AddressesRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeIpv6AddressesResponse
func (client *Client) DescribeIpv6AddressesWithOptions(request *DescribeIpv6AddressesRequest, runtime *dara.RuntimeOptions) (_result *DescribeIpv6AddressesResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.AddressType) {
		query["AddressType"] = request.AddressType
	}

	if !dara.IsNil(request.AssociatedInstanceId) {
		query["AssociatedInstanceId"] = request.AssociatedInstanceId
	}

	if !dara.IsNil(request.AssociatedInstanceType) {
		query["AssociatedInstanceType"] = request.AssociatedInstanceType
	}

	if !dara.IsNil(request.IncludeReservationData) {
		query["IncludeReservationData"] = request.IncludeReservationData
	}

	if !dara.IsNil(request.Ipv6Address) {
		query["Ipv6Address"] = request.Ipv6Address
	}

	if !dara.IsNil(request.Ipv6AddressId) {
		query["Ipv6AddressId"] = request.Ipv6AddressId
	}

	if !dara.IsNil(request.Ipv6InternetBandwidthId) {
		query["Ipv6InternetBandwidthId"] = request.Ipv6InternetBandwidthId
	}

	if !dara.IsNil(request.Name) {
		query["Name"] = request.Name
	}

	if !dara.IsNil(request.NetworkType) {
		query["NetworkType"] = request.NetworkType
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PageNumber) {
		query["PageNumber"] = request.PageNumber
	}

	if !dara.IsNil(request.PageSize) {
		query["PageSize"] = request.PageSize
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceGroupId) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.ServiceManaged) {
		query["ServiceManaged"] = request.ServiceManaged
	}

	if !dara.IsNil(request.Tag) {
		query["Tag"] = request.Tag
	}

	if !dara.IsNil(request.VSwitchId) {
		query["VSwitchId"] = request.VSwitchId
	}

	if !dara.IsNil(request.VpcId) {
		query["VpcId"] = request.VpcId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeIpv6Addresses"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DescribeIpv6AddressesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries IPv6 addresses in a region.
//
// @param request - DescribeIpv6AddressesRequest
//
// @return DescribeIpv6AddressesResponse
func (client *Client) DescribeIpv6Addresses(request *DescribeIpv6AddressesRequest) (_result *DescribeIpv6AddressesResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DescribeIpv6AddressesResponse{}
	_body, _err := client.DescribeIpv6AddressesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries egress-only rules.
//
// @param request - DescribeIpv6EgressOnlyRulesRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeIpv6EgressOnlyRulesResponse
func (client *Client) DescribeIpv6EgressOnlyRulesWithOptions(request *DescribeIpv6EgressOnlyRulesRequest, runtime *dara.RuntimeOptions) (_result *DescribeIpv6EgressOnlyRulesResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.InstanceId) {
		query["InstanceId"] = request.InstanceId
	}

	if !dara.IsNil(request.InstanceType) {
		query["InstanceType"] = request.InstanceType
	}

	if !dara.IsNil(request.Ipv6EgressOnlyRuleId) {
		query["Ipv6EgressOnlyRuleId"] = request.Ipv6EgressOnlyRuleId
	}

	if !dara.IsNil(request.Ipv6GatewayId) {
		query["Ipv6GatewayId"] = request.Ipv6GatewayId
	}

	if !dara.IsNil(request.Name) {
		query["Name"] = request.Name
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PageNumber) {
		query["PageNumber"] = request.PageNumber
	}

	if !dara.IsNil(request.PageSize) {
		query["PageSize"] = request.PageSize
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeIpv6EgressOnlyRules"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DescribeIpv6EgressOnlyRulesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries egress-only rules.
//
// @param request - DescribeIpv6EgressOnlyRulesRequest
//
// @return DescribeIpv6EgressOnlyRulesResponse
func (client *Client) DescribeIpv6EgressOnlyRules(request *DescribeIpv6EgressOnlyRulesRequest) (_result *DescribeIpv6EgressOnlyRulesResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DescribeIpv6EgressOnlyRulesResponse{}
	_body, _err := client.DescribeIpv6EgressOnlyRulesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the information about an IPv6 gateway, including the region, virtual private cloud (VPC), status, and billing method.
//
// @param request - DescribeIpv6GatewayAttributeRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeIpv6GatewayAttributeResponse
func (client *Client) DescribeIpv6GatewayAttributeWithOptions(request *DescribeIpv6GatewayAttributeRequest, runtime *dara.RuntimeOptions) (_result *DescribeIpv6GatewayAttributeResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.Ipv6GatewayId) {
		query["Ipv6GatewayId"] = request.Ipv6GatewayId
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeIpv6GatewayAttribute"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DescribeIpv6GatewayAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the information about an IPv6 gateway, including the region, virtual private cloud (VPC), status, and billing method.
//
// @param request - DescribeIpv6GatewayAttributeRequest
//
// @return DescribeIpv6GatewayAttributeResponse
func (client *Client) DescribeIpv6GatewayAttribute(request *DescribeIpv6GatewayAttributeRequest) (_result *DescribeIpv6GatewayAttributeResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DescribeIpv6GatewayAttributeResponse{}
	_body, _err := client.DescribeIpv6GatewayAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries IPv6 gateways in a region.
//
// @param request - DescribeIpv6GatewaysRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeIpv6GatewaysResponse
func (client *Client) DescribeIpv6GatewaysWithOptions(request *DescribeIpv6GatewaysRequest, runtime *dara.RuntimeOptions) (_result *DescribeIpv6GatewaysResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.Ipv6GatewayId) {
		query["Ipv6GatewayId"] = request.Ipv6GatewayId
	}

	if !dara.IsNil(request.Name) {
		query["Name"] = request.Name
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PageNumber) {
		query["PageNumber"] = request.PageNumber
	}

	if !dara.IsNil(request.PageSize) {
		query["PageSize"] = request.PageSize
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceGroupId) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.Tags) {
		query["Tags"] = request.Tags
	}

	if !dara.IsNil(request.VpcId) {
		query["VpcId"] = request.VpcId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeIpv6Gateways"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DescribeIpv6GatewaysResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries IPv6 gateways in a region.
//
// @param request - DescribeIpv6GatewaysRequest
//
// @return DescribeIpv6GatewaysResponse
func (client *Client) DescribeIpv6Gateways(request *DescribeIpv6GatewaysRequest) (_result *DescribeIpv6GatewaysResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DescribeIpv6GatewaysResponse{}
	_body, _err := client.DescribeIpv6GatewaysWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// NATENI
//
// @param request - DescribeNatGatewayAssociateNetworkInterfacesRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeNatGatewayAssociateNetworkInterfacesResponse
func (client *Client) DescribeNatGatewayAssociateNetworkInterfacesWithOptions(request *DescribeNatGatewayAssociateNetworkInterfacesRequest, runtime *dara.RuntimeOptions) (_result *DescribeNatGatewayAssociateNetworkInterfacesResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.Filter) {
		query["Filter"] = request.Filter
	}

	if !dara.IsNil(request.MaxResults) {
		query["MaxResults"] = request.MaxResults
	}

	if !dara.IsNil(request.NatGatewayId) {
		query["NatGatewayId"] = request.NatGatewayId
	}

	if !dara.IsNil(request.NextToken) {
		query["NextToken"] = request.NextToken
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceGroupId) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.Tag) {
		query["Tag"] = request.Tag
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeNatGatewayAssociateNetworkInterfaces"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DescribeNatGatewayAssociateNetworkInterfacesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// NATENI
//
// @param request - DescribeNatGatewayAssociateNetworkInterfacesRequest
//
// @return DescribeNatGatewayAssociateNetworkInterfacesResponse
func (client *Client) DescribeNatGatewayAssociateNetworkInterfaces(request *DescribeNatGatewayAssociateNetworkInterfacesRequest) (_result *DescribeNatGatewayAssociateNetworkInterfacesResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DescribeNatGatewayAssociateNetworkInterfacesResponse{}
	_body, _err := client.DescribeNatGatewayAssociateNetworkInterfacesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries NAT gateways that meet specific conditions in a specified region.
//
// Description:
//
// You can call this operation to query both Virtual Private Cloud (VPC) NAT gateways and Internet NAT gateways. NAT gateways in this topic refer to both VPC NAT gateways and Internet NAT gateways.
//
// @param request - DescribeNatGatewaysRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeNatGatewaysResponse
func (client *Client) DescribeNatGatewaysWithOptions(request *DescribeNatGatewaysRequest, runtime *dara.RuntimeOptions) (_result *DescribeNatGatewaysResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.InstanceChargeType) {
		query["InstanceChargeType"] = request.InstanceChargeType
	}

	if !dara.IsNil(request.Name) {
		query["Name"] = request.Name
	}

	if !dara.IsNil(request.NatGatewayId) {
		query["NatGatewayId"] = request.NatGatewayId
	}

	if !dara.IsNil(request.NatType) {
		query["NatType"] = request.NatType
	}

	if !dara.IsNil(request.NetworkType) {
		query["NetworkType"] = request.NetworkType
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PageNumber) {
		query["PageNumber"] = request.PageNumber
	}

	if !dara.IsNil(request.PageSize) {
		query["PageSize"] = request.PageSize
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceGroupId) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.Spec) {
		query["Spec"] = request.Spec
	}

	if !dara.IsNil(request.Status) {
		query["Status"] = request.Status
	}

	if !dara.IsNil(request.Tag) {
		query["Tag"] = request.Tag
	}

	if !dara.IsNil(request.VpcId) {
		query["VpcId"] = request.VpcId
	}

	if !dara.IsNil(request.ZoneId) {
		query["ZoneId"] = request.ZoneId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeNatGateways"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DescribeNatGatewaysResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries NAT gateways that meet specific conditions in a specified region.
//
// Description:
//
// You can call this operation to query both Virtual Private Cloud (VPC) NAT gateways and Internet NAT gateways. NAT gateways in this topic refer to both VPC NAT gateways and Internet NAT gateways.
//
// @param request - DescribeNatGatewaysRequest
//
// @return DescribeNatGatewaysResponse
func (client *Client) DescribeNatGateways(request *DescribeNatGatewaysRequest) (_result *DescribeNatGatewaysResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DescribeNatGatewaysResponse{}
	_body, _err := client.DescribeNatGatewaysWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries network access control lists (ACLs).
//
// @param request - DescribeNetworkAclAttributesRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeNetworkAclAttributesResponse
func (client *Client) DescribeNetworkAclAttributesWithOptions(request *DescribeNetworkAclAttributesRequest, runtime *dara.RuntimeOptions) (_result *DescribeNetworkAclAttributesResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.NetworkAclId) {
		query["NetworkAclId"] = request.NetworkAclId
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeNetworkAclAttributes"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DescribeNetworkAclAttributesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries network access control lists (ACLs).
//
// @param request - DescribeNetworkAclAttributesRequest
//
// @return DescribeNetworkAclAttributesResponse
func (client *Client) DescribeNetworkAclAttributes(request *DescribeNetworkAclAttributesRequest) (_result *DescribeNetworkAclAttributesResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DescribeNetworkAclAttributesResponse{}
	_body, _err := client.DescribeNetworkAclAttributesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries network ACLs.
//
// @param request - DescribeNetworkAclsRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeNetworkAclsResponse
func (client *Client) DescribeNetworkAclsWithOptions(request *DescribeNetworkAclsRequest, runtime *dara.RuntimeOptions) (_result *DescribeNetworkAclsResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.NetworkAclId) {
		query["NetworkAclId"] = request.NetworkAclId
	}

	if !dara.IsNil(request.NetworkAclName) {
		query["NetworkAclName"] = request.NetworkAclName
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PageNumber) {
		query["PageNumber"] = request.PageNumber
	}

	if !dara.IsNil(request.PageSize) {
		query["PageSize"] = request.PageSize
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceId) {
		query["ResourceId"] = request.ResourceId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.ResourceType) {
		query["ResourceType"] = request.ResourceType
	}

	if !dara.IsNil(request.Tags) {
		query["Tags"] = request.Tags
	}

	if !dara.IsNil(request.VpcId) {
		query["VpcId"] = request.VpcId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeNetworkAcls"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DescribeNetworkAclsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries network ACLs.
//
// @param request - DescribeNetworkAclsRequest
//
// @return DescribeNetworkAclsResponse
func (client *Client) DescribeNetworkAcls(request *DescribeNetworkAclsRequest) (_result *DescribeNetworkAclsResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DescribeNetworkAclsResponse{}
	_body, _err := client.DescribeNetworkAclsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// LOA
//
// @param request - DescribePhysicalConnectionLOARequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribePhysicalConnectionLOAResponse
func (client *Client) DescribePhysicalConnectionLOAWithOptions(request *DescribePhysicalConnectionLOARequest, runtime *dara.RuntimeOptions) (_result *DescribePhysicalConnectionLOAResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.InstanceId) {
		query["InstanceId"] = request.InstanceId
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribePhysicalConnectionLOA"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DescribePhysicalConnectionLOAResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// LOA
//
// @param request - DescribePhysicalConnectionLOARequest
//
// @return DescribePhysicalConnectionLOAResponse
func (client *Client) DescribePhysicalConnectionLOA(request *DescribePhysicalConnectionLOARequest) (_result *DescribePhysicalConnectionLOAResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DescribePhysicalConnectionLOAResponse{}
	_body, _err := client.DescribePhysicalConnectionLOAWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries Express Connect circuits in a region.
//
// Description:
//
// By default, the system queries information about all Express Connect circuits in the specified region. You can query Express Connect circuits that meet specific conditions by specifying filter conditions provided by the **DescribePhysicalConnections*	- operation. For more information about the supported filter conditions, see **Key*	- in the **Request parameters*	- section.
//
// @param request - DescribePhysicalConnectionsRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribePhysicalConnectionsResponse
func (client *Client) DescribePhysicalConnectionsWithOptions(request *DescribePhysicalConnectionsRequest, runtime *dara.RuntimeOptions) (_result *DescribePhysicalConnectionsResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.Filter) {
		query["Filter"] = request.Filter
	}

	if !dara.IsNil(request.IncludeReservationData) {
		query["IncludeReservationData"] = request.IncludeReservationData
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PageNumber) {
		query["PageNumber"] = request.PageNumber
	}

	if !dara.IsNil(request.PageSize) {
		query["PageSize"] = request.PageSize
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceGroupId) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.Tags) {
		query["Tags"] = request.Tags
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribePhysicalConnections"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DescribePhysicalConnectionsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries Express Connect circuits in a region.
//
// Description:
//
// By default, the system queries information about all Express Connect circuits in the specified region. You can query Express Connect circuits that meet specific conditions by specifying filter conditions provided by the **DescribePhysicalConnections*	- operation. For more information about the supported filter conditions, see **Key*	- in the **Request parameters*	- section.
//
// @param request - DescribePhysicalConnectionsRequest
//
// @return DescribePhysicalConnectionsResponse
func (client *Client) DescribePhysicalConnections(request *DescribePhysicalConnectionsRequest) (_result *DescribePhysicalConnectionsResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DescribePhysicalConnectionsResponse{}
	_body, _err := client.DescribePhysicalConnectionsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the public IP address range of a virtual private cloud (VPC) in a region.
//
// Description:
//
// You cannot query the range of public IP addresses of a classic network by calling the **DescribePublicIpAddress*	- operation.
//
// @param request - DescribePublicIpAddressRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribePublicIpAddressResponse
func (client *Client) DescribePublicIpAddressWithOptions(request *DescribePublicIpAddressRequest, runtime *dara.RuntimeOptions) (_result *DescribePublicIpAddressResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.IpVersion) {
		query["IpVersion"] = request.IpVersion
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PageNumber) {
		query["PageNumber"] = request.PageNumber
	}

	if !dara.IsNil(request.PageSize) {
		query["PageSize"] = request.PageSize
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribePublicIpAddress"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DescribePublicIpAddressResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the public IP address range of a virtual private cloud (VPC) in a region.
//
// Description:
//
// You cannot query the range of public IP addresses of a classic network by calling the **DescribePublicIpAddress*	- operation.
//
// @param request - DescribePublicIpAddressRequest
//
// @return DescribePublicIpAddressResponse
func (client *Client) DescribePublicIpAddress(request *DescribePublicIpAddressRequest) (_result *DescribePublicIpAddressResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DescribePublicIpAddressResponse{}
	_body, _err := client.DescribePublicIpAddressWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the most recent region list.
//
// @param request - DescribeRegionsRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeRegionsResponse
func (client *Client) DescribeRegionsWithOptions(request *DescribeRegionsRequest, runtime *dara.RuntimeOptions) (_result *DescribeRegionsResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.AcceptLanguage) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.ProductType) {
		query["ProductType"] = request.ProductType
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeRegions"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DescribeRegionsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the most recent region list.
//
// @param request - DescribeRegionsRequest
//
// @return DescribeRegionsResponse
func (client *Client) DescribeRegions(request *DescribeRegionsRequest) (_result *DescribeRegionsResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DescribeRegionsResponse{}
	_body, _err := client.DescribeRegionsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries information about route entries in a route table.
//
// Description:
//
// Before you call the [DeleteRouteEntry](https://help.aliyun.com/document_detail/36013.html) operation to delete a route, you can call this operation to query the next hop of the route that you want to delete.
//
// @param request - DescribeRouteEntryListRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeRouteEntryListResponse
func (client *Client) DescribeRouteEntryListWithOptions(request *DescribeRouteEntryListRequest, runtime *dara.RuntimeOptions) (_result *DescribeRouteEntryListResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.DestCidrBlockList) {
		query["DestCidrBlockList"] = request.DestCidrBlockList
	}

	if !dara.IsNil(request.DestinationCidrBlock) {
		query["DestinationCidrBlock"] = request.DestinationCidrBlock
	}

	if !dara.IsNil(request.IpVersion) {
		query["IpVersion"] = request.IpVersion
	}

	if !dara.IsNil(request.MaxResult) {
		query["MaxResult"] = request.MaxResult
	}

	if !dara.IsNil(request.NextHopId) {
		query["NextHopId"] = request.NextHopId
	}

	if !dara.IsNil(request.NextHopType) {
		query["NextHopType"] = request.NextHopType
	}

	if !dara.IsNil(request.NextToken) {
		query["NextToken"] = request.NextToken
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.RouteEntryId) {
		query["RouteEntryId"] = request.RouteEntryId
	}

	if !dara.IsNil(request.RouteEntryName) {
		query["RouteEntryName"] = request.RouteEntryName
	}

	if !dara.IsNil(request.RouteEntryType) {
		query["RouteEntryType"] = request.RouteEntryType
	}

	if !dara.IsNil(request.RouteTableId) {
		query["RouteTableId"] = request.RouteTableId
	}

	if !dara.IsNil(request.ServiceType) {
		query["ServiceType"] = request.ServiceType
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeRouteEntryList"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DescribeRouteEntryListResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries information about route entries in a route table.
//
// Description:
//
// Before you call the [DeleteRouteEntry](https://help.aliyun.com/document_detail/36013.html) operation to delete a route, you can call this operation to query the next hop of the route that you want to delete.
//
// @param request - DescribeRouteEntryListRequest
//
// @return DescribeRouteEntryListResponse
func (client *Client) DescribeRouteEntryList(request *DescribeRouteEntryListRequest) (_result *DescribeRouteEntryListResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DescribeRouteEntryListResponse{}
	_body, _err := client.DescribeRouteEntryListWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries route tables.
//
// @param request - DescribeRouteTableListRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeRouteTableListResponse
func (client *Client) DescribeRouteTableListWithOptions(request *DescribeRouteTableListRequest, runtime *dara.RuntimeOptions) (_result *DescribeRouteTableListResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PageNumber) {
		query["PageNumber"] = request.PageNumber
	}

	if !dara.IsNil(request.PageSize) {
		query["PageSize"] = request.PageSize
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceGroupId) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.RouteTableId) {
		query["RouteTableId"] = request.RouteTableId
	}

	if !dara.IsNil(request.RouteTableName) {
		query["RouteTableName"] = request.RouteTableName
	}

	if !dara.IsNil(request.RouteTableType) {
		query["RouteTableType"] = request.RouteTableType
	}

	if !dara.IsNil(request.RouterId) {
		query["RouterId"] = request.RouterId
	}

	if !dara.IsNil(request.RouterType) {
		query["RouterType"] = request.RouterType
	}

	if !dara.IsNil(request.Tag) {
		query["Tag"] = request.Tag
	}

	if !dara.IsNil(request.VpcId) {
		query["VpcId"] = request.VpcId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeRouteTableList"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DescribeRouteTableListResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries route tables.
//
// @param request - DescribeRouteTableListRequest
//
// @return DescribeRouteTableListResponse
func (client *Client) DescribeRouteTableList(request *DescribeRouteTableListRequest) (_result *DescribeRouteTableListResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DescribeRouteTableListResponse{}
	_body, _err := client.DescribeRouteTableListWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Deprecated: OpenAPI DescribeRouteTables is deprecated, please use Vpc::2016-04-28::DescribeRouteTableList instead.
//
// Summary:
//
// Queries route tables.
//
// @param request - DescribeRouteTablesRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeRouteTablesResponse
func (client *Client) DescribeRouteTablesWithOptions(request *DescribeRouteTablesRequest, runtime *dara.RuntimeOptions) (_result *DescribeRouteTablesResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PageNumber) {
		query["PageNumber"] = request.PageNumber
	}

	if !dara.IsNil(request.PageSize) {
		query["PageSize"] = request.PageSize
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceGroupId) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.RouteTableId) {
		query["RouteTableId"] = request.RouteTableId
	}

	if !dara.IsNil(request.RouteTableName) {
		query["RouteTableName"] = request.RouteTableName
	}

	if !dara.IsNil(request.RouterId) {
		query["RouterId"] = request.RouterId
	}

	if !dara.IsNil(request.RouterType) {
		query["RouterType"] = request.RouterType
	}

	if !dara.IsNil(request.Type) {
		query["Type"] = request.Type
	}

	if !dara.IsNil(request.VRouterId) {
		query["VRouterId"] = request.VRouterId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeRouteTables"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DescribeRouteTablesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Deprecated: OpenAPI DescribeRouteTables is deprecated, please use Vpc::2016-04-28::DescribeRouteTableList instead.
//
// Summary:
//
// Queries route tables.
//
// @param request - DescribeRouteTablesRequest
//
// @return DescribeRouteTablesResponse
// Deprecated
func (client *Client) DescribeRouteTables(request *DescribeRouteTablesRequest) (_result *DescribeRouteTablesResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DescribeRouteTablesResponse{}
	_body, _err := client.DescribeRouteTablesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the configuration of a router interface.
//
// @param request - DescribeRouterInterfaceAttributeRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeRouterInterfaceAttributeResponse
func (client *Client) DescribeRouterInterfaceAttributeWithOptions(request *DescribeRouterInterfaceAttributeRequest, runtime *dara.RuntimeOptions) (_result *DescribeRouterInterfaceAttributeResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.InstanceId) {
		query["InstanceId"] = request.InstanceId
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeRouterInterfaceAttribute"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DescribeRouterInterfaceAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the configuration of a router interface.
//
// @param request - DescribeRouterInterfaceAttributeRequest
//
// @return DescribeRouterInterfaceAttributeResponse
func (client *Client) DescribeRouterInterfaceAttribute(request *DescribeRouterInterfaceAttributeRequest) (_result *DescribeRouterInterfaceAttributeResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DescribeRouterInterfaceAttributeResponse{}
	_body, _err := client.DescribeRouterInterfaceAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries router interfaces in a specified region.
//
// @param request - DescribeRouterInterfacesRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeRouterInterfacesResponse
func (client *Client) DescribeRouterInterfacesWithOptions(request *DescribeRouterInterfacesRequest, runtime *dara.RuntimeOptions) (_result *DescribeRouterInterfacesResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.Filter) {
		query["Filter"] = request.Filter
	}

	if !dara.IsNil(request.IncludeReservationData) {
		query["IncludeReservationData"] = request.IncludeReservationData
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PageNumber) {
		query["PageNumber"] = request.PageNumber
	}

	if !dara.IsNil(request.PageSize) {
		query["PageSize"] = request.PageSize
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceGroupId) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.Tags) {
		query["Tags"] = request.Tags
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeRouterInterfaces"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DescribeRouterInterfacesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries router interfaces in a specified region.
//
// @param request - DescribeRouterInterfacesRequest
//
// @return DescribeRouterInterfacesResponse
func (client *Client) DescribeRouterInterfaces(request *DescribeRouterInterfacesRequest) (_result *DescribeRouterInterfacesResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DescribeRouterInterfacesResponse{}
	_body, _err := client.DescribeRouterInterfacesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries Global Accelerator (GA) instances that are associated with a backend server.
//
// Description:
//
// > You can call this operation to query only dedicated-bandwidth GA instances.
//
// @param request - DescribeServerRelatedGlobalAccelerationInstancesRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeServerRelatedGlobalAccelerationInstancesResponse
func (client *Client) DescribeServerRelatedGlobalAccelerationInstancesWithOptions(request *DescribeServerRelatedGlobalAccelerationInstancesRequest, runtime *dara.RuntimeOptions) (_result *DescribeServerRelatedGlobalAccelerationInstancesResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.ServerId) {
		query["ServerId"] = request.ServerId
	}

	if !dara.IsNil(request.ServerType) {
		query["ServerType"] = request.ServerType
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeServerRelatedGlobalAccelerationInstances"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DescribeServerRelatedGlobalAccelerationInstancesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries Global Accelerator (GA) instances that are associated with a backend server.
//
// Description:
//
// > You can call this operation to query only dedicated-bandwidth GA instances.
//
// @param request - DescribeServerRelatedGlobalAccelerationInstancesRequest
//
// @return DescribeServerRelatedGlobalAccelerationInstancesResponse
func (client *Client) DescribeServerRelatedGlobalAccelerationInstances(request *DescribeServerRelatedGlobalAccelerationInstancesRequest) (_result *DescribeServerRelatedGlobalAccelerationInstancesResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DescribeServerRelatedGlobalAccelerationInstancesResponse{}
	_body, _err := client.DescribeServerRelatedGlobalAccelerationInstancesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries SNAT entries.
//
// @param request - DescribeSnatTableEntriesRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeSnatTableEntriesResponse
func (client *Client) DescribeSnatTableEntriesWithOptions(request *DescribeSnatTableEntriesRequest, runtime *dara.RuntimeOptions) (_result *DescribeSnatTableEntriesResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.NatGatewayId) {
		query["NatGatewayId"] = request.NatGatewayId
	}

	if !dara.IsNil(request.NetworkInterfaceIds) {
		query["NetworkInterfaceIds"] = request.NetworkInterfaceIds
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PageNumber) {
		query["PageNumber"] = request.PageNumber
	}

	if !dara.IsNil(request.PageSize) {
		query["PageSize"] = request.PageSize
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.SnatEntryId) {
		query["SnatEntryId"] = request.SnatEntryId
	}

	if !dara.IsNil(request.SnatEntryName) {
		query["SnatEntryName"] = request.SnatEntryName
	}

	if !dara.IsNil(request.SnatIp) {
		query["SnatIp"] = request.SnatIp
	}

	if !dara.IsNil(request.SnatTableId) {
		query["SnatTableId"] = request.SnatTableId
	}

	if !dara.IsNil(request.SourceCIDR) {
		query["SourceCIDR"] = request.SourceCIDR
	}

	if !dara.IsNil(request.SourceVSwitchId) {
		query["SourceVSwitchId"] = request.SourceVSwitchId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeSnatTableEntries"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DescribeSnatTableEntriesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries SNAT entries.
//
// @param request - DescribeSnatTableEntriesRequest
//
// @return DescribeSnatTableEntriesResponse
func (client *Client) DescribeSnatTableEntries(request *DescribeSnatTableEntriesRequest) (_result *DescribeSnatTableEntriesResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DescribeSnatTableEntriesResponse{}
	_body, _err := client.DescribeSnatTableEntriesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the details of an SSL client certificate.
//
// @param request - DescribeSslVpnClientCertRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeSslVpnClientCertResponse
func (client *Client) DescribeSslVpnClientCertWithOptions(request *DescribeSslVpnClientCertRequest, runtime *dara.RuntimeOptions) (_result *DescribeSslVpnClientCertResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.SslVpnClientCertId) {
		query["SslVpnClientCertId"] = request.SslVpnClientCertId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeSslVpnClientCert"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DescribeSslVpnClientCertResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the details of an SSL client certificate.
//
// @param request - DescribeSslVpnClientCertRequest
//
// @return DescribeSslVpnClientCertResponse
func (client *Client) DescribeSslVpnClientCert(request *DescribeSslVpnClientCertRequest) (_result *DescribeSslVpnClientCertResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DescribeSslVpnClientCertResponse{}
	_body, _err := client.DescribeSslVpnClientCertWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries SSL client certificates.
//
// @param request - DescribeSslVpnClientCertsRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeSslVpnClientCertsResponse
func (client *Client) DescribeSslVpnClientCertsWithOptions(request *DescribeSslVpnClientCertsRequest, runtime *dara.RuntimeOptions) (_result *DescribeSslVpnClientCertsResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.Name) {
		query["Name"] = request.Name
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PageNumber) {
		query["PageNumber"] = request.PageNumber
	}

	if !dara.IsNil(request.PageSize) {
		query["PageSize"] = request.PageSize
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceGroupId) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.SslVpnClientCertId) {
		query["SslVpnClientCertId"] = request.SslVpnClientCertId
	}

	if !dara.IsNil(request.SslVpnServerId) {
		query["SslVpnServerId"] = request.SslVpnServerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeSslVpnClientCerts"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DescribeSslVpnClientCertsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries SSL client certificates.
//
// @param request - DescribeSslVpnClientCertsRequest
//
// @return DescribeSslVpnClientCertsResponse
func (client *Client) DescribeSslVpnClientCerts(request *DescribeSslVpnClientCertsRequest) (_result *DescribeSslVpnClientCertsResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DescribeSslVpnClientCertsResponse{}
	_body, _err := client.DescribeSslVpnClientCertsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the clients that have connected to a VPN gateway through SSL-VPN connections.
//
// Description:
//
// If your VPN gateway was created before December 10, 2022, you need to upgrade the VPN gateway to the latest version to view the connection information about SSL clients. For more information, see [Upgrade a VPN gateway](https://help.aliyun.com/document_detail/2671058.html).
//
// If your VPN gateway was created after December 10, 2022, you can view the connection information about SSL clients by default.
//
// @param request - DescribeSslVpnClientsRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeSslVpnClientsResponse
func (client *Client) DescribeSslVpnClientsWithOptions(request *DescribeSslVpnClientsRequest, runtime *dara.RuntimeOptions) (_result *DescribeSslVpnClientsResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PageNumber) {
		query["PageNumber"] = request.PageNumber
	}

	if !dara.IsNil(request.PageSize) {
		query["PageSize"] = request.PageSize
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.VpnGatewayId) {
		query["VpnGatewayId"] = request.VpnGatewayId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeSslVpnClients"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DescribeSslVpnClientsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the clients that have connected to a VPN gateway through SSL-VPN connections.
//
// Description:
//
// If your VPN gateway was created before December 10, 2022, you need to upgrade the VPN gateway to the latest version to view the connection information about SSL clients. For more information, see [Upgrade a VPN gateway](https://help.aliyun.com/document_detail/2671058.html).
//
// If your VPN gateway was created after December 10, 2022, you can view the connection information about SSL clients by default.
//
// @param request - DescribeSslVpnClientsRequest
//
// @return DescribeSslVpnClientsResponse
func (client *Client) DescribeSslVpnClients(request *DescribeSslVpnClientsRequest) (_result *DescribeSslVpnClientsResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DescribeSslVpnClientsResponse{}
	_body, _err := client.DescribeSslVpnClientsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries one or more SSL-VPN servers.
//
// @param request - DescribeSslVpnServersRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeSslVpnServersResponse
func (client *Client) DescribeSslVpnServersWithOptions(request *DescribeSslVpnServersRequest, runtime *dara.RuntimeOptions) (_result *DescribeSslVpnServersResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.Name) {
		query["Name"] = request.Name
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PageNumber) {
		query["PageNumber"] = request.PageNumber
	}

	if !dara.IsNil(request.PageSize) {
		query["PageSize"] = request.PageSize
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceGroupId) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.SslVpnServerId) {
		query["SslVpnServerId"] = request.SslVpnServerId
	}

	if !dara.IsNil(request.VpnGatewayId) {
		query["VpnGatewayId"] = request.VpnGatewayId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeSslVpnServers"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DescribeSslVpnServersResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries one or more SSL-VPN servers.
//
// @param request - DescribeSslVpnServersRequest
//
// @return DescribeSslVpnServersResponse
func (client *Client) DescribeSslVpnServers(request *DescribeSslVpnServersRequest) (_result *DescribeSslVpnServersResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DescribeSslVpnServersResponse{}
	_body, _err := client.DescribeSslVpnServersWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries tag keys.
//
// @param request - DescribeTagKeysRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeTagKeysResponse
func (client *Client) DescribeTagKeysWithOptions(request *DescribeTagKeysRequest, runtime *dara.RuntimeOptions) (_result *DescribeTagKeysResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.Keyword) {
		query["Keyword"] = request.Keyword
	}

	if !dara.IsNil(request.MaxResult) {
		query["MaxResult"] = request.MaxResult
	}

	if !dara.IsNil(request.NextToken) {
		query["NextToken"] = request.NextToken
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceId) {
		query["ResourceId"] = request.ResourceId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.ResourceType) {
		query["ResourceType"] = request.ResourceType
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeTagKeys"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DescribeTagKeysResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries tag keys.
//
// @param request - DescribeTagKeysRequest
//
// @return DescribeTagKeysResponse
func (client *Client) DescribeTagKeys(request *DescribeTagKeysRequest) (_result *DescribeTagKeysResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DescribeTagKeysResponse{}
	_body, _err := client.DescribeTagKeysWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the tags of an Express Connect circuit.
//
// @param request - DescribeTagKeysForExpressConnectRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeTagKeysForExpressConnectResponse
func (client *Client) DescribeTagKeysForExpressConnectWithOptions(request *DescribeTagKeysForExpressConnectRequest, runtime *dara.RuntimeOptions) (_result *DescribeTagKeysForExpressConnectResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.Keyword) {
		query["Keyword"] = request.Keyword
	}

	if !dara.IsNil(request.MaxResult) {
		query["MaxResult"] = request.MaxResult
	}

	if !dara.IsNil(request.NextToken) {
		query["NextToken"] = request.NextToken
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceId) {
		query["ResourceId"] = request.ResourceId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.ResourceType) {
		query["ResourceType"] = request.ResourceType
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeTagKeysForExpressConnect"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DescribeTagKeysForExpressConnectResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the tags of an Express Connect circuit.
//
// @param request - DescribeTagKeysForExpressConnectRequest
//
// @return DescribeTagKeysForExpressConnectResponse
func (client *Client) DescribeTagKeysForExpressConnect(request *DescribeTagKeysForExpressConnectRequest) (_result *DescribeTagKeysForExpressConnectResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DescribeTagKeysForExpressConnectResponse{}
	_body, _err := client.DescribeTagKeysForExpressConnectWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries tags that meet the specified filter conditions.
//
// Description:
//
//	  You must specify **ResourceId.N*	- or **Tag.N*	- that consists of **Tag.N.Key*	- and **Tag.N.Value*	- in the request to specify the object that you want to query.
//
//		- **Tag.N*	- is a resource tag that consists of a key-value pair. If you specify only **Tag.N.Key**, all tag values that are associated with the specified tag key are returned. If you specify only **Tag.N.Value**, an error message is returned.
//
//		- If you specify **Tag.N*	- and **ResourceId.N*	- to filter tags, **ResourceId.N*	- must match all specified key-value pairs.
//
//		- If you specify multiple key-value pairs, all tags that match the key-value pairs are returned.
//
// @param request - DescribeTagsRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeTagsResponse
func (client *Client) DescribeTagsWithOptions(request *DescribeTagsRequest, runtime *dara.RuntimeOptions) (_result *DescribeTagsResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.MaxResult) {
		query["MaxResult"] = request.MaxResult
	}

	if !dara.IsNil(request.NextToken) {
		query["NextToken"] = request.NextToken
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceId) {
		query["ResourceId"] = request.ResourceId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.ResourceType) {
		query["ResourceType"] = request.ResourceType
	}

	if !dara.IsNil(request.Tag) {
		query["Tag"] = request.Tag
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeTags"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DescribeTagsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries tags that meet the specified filter conditions.
//
// Description:
//
//	  You must specify **ResourceId.N*	- or **Tag.N*	- that consists of **Tag.N.Key*	- and **Tag.N.Value*	- in the request to specify the object that you want to query.
//
//		- **Tag.N*	- is a resource tag that consists of a key-value pair. If you specify only **Tag.N.Key**, all tag values that are associated with the specified tag key are returned. If you specify only **Tag.N.Value**, an error message is returned.
//
//		- If you specify **Tag.N*	- and **ResourceId.N*	- to filter tags, **ResourceId.N*	- must match all specified key-value pairs.
//
//		- If you specify multiple key-value pairs, all tags that match the key-value pairs are returned.
//
// @param request - DescribeTagsRequest
//
// @return DescribeTagsResponse
func (client *Client) DescribeTags(request *DescribeTagsRequest) (_result *DescribeTagsResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DescribeTagsResponse{}
	_body, _err := client.DescribeTagsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries vRouters in a region.
//
// @param request - DescribeVRoutersRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeVRoutersResponse
func (client *Client) DescribeVRoutersWithOptions(request *DescribeVRoutersRequest, runtime *dara.RuntimeOptions) (_result *DescribeVRoutersResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PageNumber) {
		query["PageNumber"] = request.PageNumber
	}

	if !dara.IsNil(request.PageSize) {
		query["PageSize"] = request.PageSize
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.VRouterId) {
		query["VRouterId"] = request.VRouterId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeVRouters"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DescribeVRoutersResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries vRouters in a region.
//
// @param request - DescribeVRoutersRequest
//
// @return DescribeVRoutersResponse
func (client *Client) DescribeVRouters(request *DescribeVRoutersRequest) (_result *DescribeVRoutersResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DescribeVRoutersResponse{}
	_body, _err := client.DescribeVRoutersWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the detailed information about a vSwitch.
//
// @param request - DescribeVSwitchAttributesRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeVSwitchAttributesResponse
func (client *Client) DescribeVSwitchAttributesWithOptions(request *DescribeVSwitchAttributesRequest, runtime *dara.RuntimeOptions) (_result *DescribeVSwitchAttributesResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.VSwitchId) {
		query["VSwitchId"] = request.VSwitchId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeVSwitchAttributes"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DescribeVSwitchAttributesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the detailed information about a vSwitch.
//
// @param request - DescribeVSwitchAttributesRequest
//
// @return DescribeVSwitchAttributesResponse
func (client *Client) DescribeVSwitchAttributes(request *DescribeVSwitchAttributesRequest) (_result *DescribeVSwitchAttributesResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DescribeVSwitchAttributesResponse{}
	_body, _err := client.DescribeVSwitchAttributesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the information about available vSwitches that are used for an internal network.
//
// @param request - DescribeVSwitchesRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeVSwitchesResponse
func (client *Client) DescribeVSwitchesWithOptions(request *DescribeVSwitchesRequest, runtime *dara.RuntimeOptions) (_result *DescribeVSwitchesResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.EnableIpv6) {
		query["EnableIpv6"] = request.EnableIpv6
	}

	if !dara.IsNil(request.IsDefault) {
		query["IsDefault"] = request.IsDefault
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PageNumber) {
		query["PageNumber"] = request.PageNumber
	}

	if !dara.IsNil(request.PageSize) {
		query["PageSize"] = request.PageSize
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceGroupId) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.RouteTableId) {
		query["RouteTableId"] = request.RouteTableId
	}

	if !dara.IsNil(request.Tag) {
		query["Tag"] = request.Tag
	}

	if !dara.IsNil(request.VSwitchId) {
		query["VSwitchId"] = request.VSwitchId
	}

	if !dara.IsNil(request.VSwitchName) {
		query["VSwitchName"] = request.VSwitchName
	}

	if !dara.IsNil(request.VSwitchOwnerId) {
		query["VSwitchOwnerId"] = request.VSwitchOwnerId
	}

	if !dara.IsNil(request.VpcId) {
		query["VpcId"] = request.VpcId
	}

	if !dara.IsNil(request.ZoneId) {
		query["ZoneId"] = request.ZoneId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeVSwitches"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DescribeVSwitchesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the information about available vSwitches that are used for an internal network.
//
// @param request - DescribeVSwitchesRequest
//
// @return DescribeVSwitchesResponse
func (client *Client) DescribeVSwitches(request *DescribeVSwitchesRequest) (_result *DescribeVSwitchesResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DescribeVSwitchesResponse{}
	_body, _err := client.DescribeVSwitchesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries virtual border router (VBR) failover groups.
//
// @param request - DescribeVbrHaRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeVbrHaResponse
func (client *Client) DescribeVbrHaWithOptions(request *DescribeVbrHaRequest, runtime *dara.RuntimeOptions) (_result *DescribeVbrHaResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.VbrHaId) {
		query["VbrHaId"] = request.VbrHaId
	}

	if !dara.IsNil(request.VbrId) {
		query["VbrId"] = request.VbrId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeVbrHa"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DescribeVbrHaResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries virtual border router (VBR) failover groups.
//
// @param request - DescribeVbrHaRequest
//
// @return DescribeVbrHaResponse
func (client *Client) DescribeVbrHa(request *DescribeVbrHaRequest) (_result *DescribeVbrHaResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DescribeVbrHaResponse{}
	_body, _err := client.DescribeVbrHaWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the routes of an IPsec-VPN connection.
//
// @param request - DescribeVcoRouteEntriesRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeVcoRouteEntriesResponse
func (client *Client) DescribeVcoRouteEntriesWithOptions(request *DescribeVcoRouteEntriesRequest, runtime *dara.RuntimeOptions) (_result *DescribeVcoRouteEntriesResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.PageNumber) {
		query["PageNumber"] = request.PageNumber
	}

	if !dara.IsNil(request.PageSize) {
		query["PageSize"] = request.PageSize
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.RouteEntryType) {
		query["RouteEntryType"] = request.RouteEntryType
	}

	if !dara.IsNil(request.VpnConnectionId) {
		query["VpnConnectionId"] = request.VpnConnectionId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeVcoRouteEntries"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DescribeVcoRouteEntriesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the routes of an IPsec-VPN connection.
//
// @param request - DescribeVcoRouteEntriesRequest
//
// @return DescribeVcoRouteEntriesResponse
func (client *Client) DescribeVcoRouteEntries(request *DescribeVcoRouteEntriesRequest) (_result *DescribeVcoRouteEntriesResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DescribeVcoRouteEntriesResponse{}
	_body, _err := client.DescribeVcoRouteEntriesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries virtual border routers (VBRs).
//
// @param request - DescribeVirtualBorderRoutersRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeVirtualBorderRoutersResponse
func (client *Client) DescribeVirtualBorderRoutersWithOptions(request *DescribeVirtualBorderRoutersRequest, runtime *dara.RuntimeOptions) (_result *DescribeVirtualBorderRoutersResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.Filter) {
		query["Filter"] = request.Filter
	}

	if !dara.IsNil(request.IncludeCrossAccountVbr) {
		query["IncludeCrossAccountVbr"] = request.IncludeCrossAccountVbr
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PageNumber) {
		query["PageNumber"] = request.PageNumber
	}

	if !dara.IsNil(request.PageSize) {
		query["PageSize"] = request.PageSize
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceGroupId) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.Tags) {
		query["Tags"] = request.Tags
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeVirtualBorderRouters"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DescribeVirtualBorderRoutersResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries virtual border routers (VBRs).
//
// @param request - DescribeVirtualBorderRoutersRequest
//
// @return DescribeVirtualBorderRoutersResponse
func (client *Client) DescribeVirtualBorderRouters(request *DescribeVirtualBorderRoutersRequest) (_result *DescribeVirtualBorderRoutersResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DescribeVirtualBorderRoutersResponse{}
	_body, _err := client.DescribeVirtualBorderRoutersWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the virtual border routers (VBRs) that are associated with an Express Connect circuit. The VBRs can be created by the owner of the Express Connect circuit and by other Alibaba Cloud accounts.
//
// @param request - DescribeVirtualBorderRoutersForPhysicalConnectionRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeVirtualBorderRoutersForPhysicalConnectionResponse
func (client *Client) DescribeVirtualBorderRoutersForPhysicalConnectionWithOptions(request *DescribeVirtualBorderRoutersForPhysicalConnectionRequest, runtime *dara.RuntimeOptions) (_result *DescribeVirtualBorderRoutersForPhysicalConnectionResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.Filter) {
		query["Filter"] = request.Filter
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PageNumber) {
		query["PageNumber"] = request.PageNumber
	}

	if !dara.IsNil(request.PageSize) {
		query["PageSize"] = request.PageSize
	}

	if !dara.IsNil(request.PhysicalConnectionId) {
		query["PhysicalConnectionId"] = request.PhysicalConnectionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeVirtualBorderRoutersForPhysicalConnection"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DescribeVirtualBorderRoutersForPhysicalConnectionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the virtual border routers (VBRs) that are associated with an Express Connect circuit. The VBRs can be created by the owner of the Express Connect circuit and by other Alibaba Cloud accounts.
//
// @param request - DescribeVirtualBorderRoutersForPhysicalConnectionRequest
//
// @return DescribeVirtualBorderRoutersForPhysicalConnectionResponse
func (client *Client) DescribeVirtualBorderRoutersForPhysicalConnection(request *DescribeVirtualBorderRoutersForPhysicalConnectionRequest) (_result *DescribeVirtualBorderRoutersForPhysicalConnectionResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DescribeVirtualBorderRoutersForPhysicalConnectionResponse{}
	_body, _err := client.DescribeVirtualBorderRoutersForPhysicalConnectionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the configuration of a virtual private cloud (VPC).
//
// @param request - DescribeVpcAttributeRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeVpcAttributeResponse
func (client *Client) DescribeVpcAttributeWithOptions(request *DescribeVpcAttributeRequest, runtime *dara.RuntimeOptions) (_result *DescribeVpcAttributeResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.IsDefault) {
		query["IsDefault"] = request.IsDefault
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.VpcId) {
		query["VpcId"] = request.VpcId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeVpcAttribute"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DescribeVpcAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the configuration of a virtual private cloud (VPC).
//
// @param request - DescribeVpcAttributeRequest
//
// @return DescribeVpcAttributeResponse
func (client *Client) DescribeVpcAttribute(request *DescribeVpcAttributeRequest) (_result *DescribeVpcAttributeResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DescribeVpcAttributeResponse{}
	_body, _err := client.DescribeVpcAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// VPCECR
//
// @param request - DescribeVpcGrantRulesToEcrRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeVpcGrantRulesToEcrResponse
func (client *Client) DescribeVpcGrantRulesToEcrWithOptions(request *DescribeVpcGrantRulesToEcrRequest, runtime *dara.RuntimeOptions) (_result *DescribeVpcGrantRulesToEcrResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.EcrInstanceId) {
		query["EcrInstanceId"] = request.EcrInstanceId
	}

	if !dara.IsNil(request.EcrOwnerId) {
		query["EcrOwnerId"] = request.EcrOwnerId
	}

	if !dara.IsNil(request.InstanceId) {
		query["InstanceId"] = request.InstanceId
	}

	if !dara.IsNil(request.InstanceType) {
		query["InstanceType"] = request.InstanceType
	}

	if !dara.IsNil(request.MaxResults) {
		query["MaxResults"] = request.MaxResults
	}

	if !dara.IsNil(request.NextToken) {
		query["NextToken"] = request.NextToken
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceGroupId) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.Tags) {
		query["Tags"] = request.Tags
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeVpcGrantRulesToEcr"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DescribeVpcGrantRulesToEcrResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// VPCECR
//
// @param request - DescribeVpcGrantRulesToEcrRequest
//
// @return DescribeVpcGrantRulesToEcrResponse
func (client *Client) DescribeVpcGrantRulesToEcr(request *DescribeVpcGrantRulesToEcrRequest) (_result *DescribeVpcGrantRulesToEcrResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DescribeVpcGrantRulesToEcrResponse{}
	_body, _err := client.DescribeVpcGrantRulesToEcrWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries virtual private clouds (VPCs).
//
// @param request - DescribeVpcsRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeVpcsResponse
func (client *Client) DescribeVpcsWithOptions(request *DescribeVpcsRequest, runtime *dara.RuntimeOptions) (_result *DescribeVpcsResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.DhcpOptionsSetId) {
		query["DhcpOptionsSetId"] = request.DhcpOptionsSetId
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.EnableIpv6) {
		query["EnableIpv6"] = request.EnableIpv6
	}

	if !dara.IsNil(request.IsDefault) {
		query["IsDefault"] = request.IsDefault
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PageNumber) {
		query["PageNumber"] = request.PageNumber
	}

	if !dara.IsNil(request.PageSize) {
		query["PageSize"] = request.PageSize
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceGroupId) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.Tag) {
		query["Tag"] = request.Tag
	}

	if !dara.IsNil(request.VpcId) {
		query["VpcId"] = request.VpcId
	}

	if !dara.IsNil(request.VpcName) {
		query["VpcName"] = request.VpcName
	}

	if !dara.IsNil(request.VpcOwnerId) {
		query["VpcOwnerId"] = request.VpcOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeVpcs"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DescribeVpcsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries virtual private clouds (VPCs).
//
// @param request - DescribeVpcsRequest
//
// @return DescribeVpcsResponse
func (client *Client) DescribeVpcs(request *DescribeVpcsRequest) (_result *DescribeVpcsResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DescribeVpcsResponse{}
	_body, _err := client.DescribeVpcsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the IPsec-VPN connections associated with a transit router.
//
// @param request - DescribeVpnAttachmentsRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeVpnAttachmentsResponse
func (client *Client) DescribeVpnAttachmentsWithOptions(request *DescribeVpnAttachmentsRequest, runtime *dara.RuntimeOptions) (_result *DescribeVpnAttachmentsResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.AttachType) {
		query["AttachType"] = request.AttachType
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PageNumber) {
		query["PageNumber"] = request.PageNumber
	}

	if !dara.IsNil(request.PageSize) {
		query["PageSize"] = request.PageSize
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.VpnConnectionId) {
		query["VpnConnectionId"] = request.VpnConnectionId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeVpnAttachments"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DescribeVpnAttachmentsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the IPsec-VPN connections associated with a transit router.
//
// @param request - DescribeVpnAttachmentsRequest
//
// @return DescribeVpnAttachmentsResponse
func (client *Client) DescribeVpnAttachments(request *DescribeVpnAttachmentsRequest) (_result *DescribeVpnAttachmentsResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DescribeVpnAttachmentsResponse{}
	_body, _err := client.DescribeVpnAttachmentsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the detailed information about an IPsec-VPN connection.
//
// @param request - DescribeVpnConnectionRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeVpnConnectionResponse
func (client *Client) DescribeVpnConnectionWithOptions(request *DescribeVpnConnectionRequest, runtime *dara.RuntimeOptions) (_result *DescribeVpnConnectionResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.VpnConnectionId) {
		query["VpnConnectionId"] = request.VpnConnectionId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeVpnConnection"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DescribeVpnConnectionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the detailed information about an IPsec-VPN connection.
//
// @param request - DescribeVpnConnectionRequest
//
// @return DescribeVpnConnectionResponse
func (client *Client) DescribeVpnConnection(request *DescribeVpnConnectionRequest) (_result *DescribeVpnConnectionResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DescribeVpnConnectionResponse{}
	_body, _err := client.DescribeVpnConnectionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries logs of IPsec-VPN connections.
//
// @param request - DescribeVpnConnectionLogsRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeVpnConnectionLogsResponse
func (client *Client) DescribeVpnConnectionLogsWithOptions(request *DescribeVpnConnectionLogsRequest, runtime *dara.RuntimeOptions) (_result *DescribeVpnConnectionLogsResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.From) {
		query["From"] = request.From
	}

	if !dara.IsNil(request.MinutePeriod) {
		query["MinutePeriod"] = request.MinutePeriod
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PageNumber) {
		query["PageNumber"] = request.PageNumber
	}

	if !dara.IsNil(request.PageSize) {
		query["PageSize"] = request.PageSize
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.To) {
		query["To"] = request.To
	}

	if !dara.IsNil(request.TunnelId) {
		query["TunnelId"] = request.TunnelId
	}

	if !dara.IsNil(request.VpnConnectionId) {
		query["VpnConnectionId"] = request.VpnConnectionId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeVpnConnectionLogs"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DescribeVpnConnectionLogsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries logs of IPsec-VPN connections.
//
// @param request - DescribeVpnConnectionLogsRequest
//
// @return DescribeVpnConnectionLogsResponse
func (client *Client) DescribeVpnConnectionLogs(request *DescribeVpnConnectionLogsRequest) (_result *DescribeVpnConnectionLogsResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DescribeVpnConnectionLogsResponse{}
	_body, _err := client.DescribeVpnConnectionLogsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries IPsec-VPN connections.
//
// @param request - DescribeVpnConnectionsRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeVpnConnectionsResponse
func (client *Client) DescribeVpnConnectionsWithOptions(request *DescribeVpnConnectionsRequest, runtime *dara.RuntimeOptions) (_result *DescribeVpnConnectionsResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.CustomerGatewayId) {
		query["CustomerGatewayId"] = request.CustomerGatewayId
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PageNumber) {
		query["PageNumber"] = request.PageNumber
	}

	if !dara.IsNil(request.PageSize) {
		query["PageSize"] = request.PageSize
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceGroupId) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.Tag) {
		query["Tag"] = request.Tag
	}

	if !dara.IsNil(request.VpnConnectionId) {
		query["VpnConnectionId"] = request.VpnConnectionId
	}

	if !dara.IsNil(request.VpnGatewayId) {
		query["VpnGatewayId"] = request.VpnGatewayId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeVpnConnections"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DescribeVpnConnectionsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries IPsec-VPN connections.
//
// @param request - DescribeVpnConnectionsRequest
//
// @return DescribeVpnConnectionsResponse
func (client *Client) DescribeVpnConnections(request *DescribeVpnConnectionsRequest) (_result *DescribeVpnConnectionsResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DescribeVpnConnectionsResponse{}
	_body, _err := client.DescribeVpnConnectionsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the cross-account authorization information about an IPsec-VPN connection.
//
// @param request - DescribeVpnCrossAccountAuthorizationsRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeVpnCrossAccountAuthorizationsResponse
func (client *Client) DescribeVpnCrossAccountAuthorizationsWithOptions(request *DescribeVpnCrossAccountAuthorizationsRequest, runtime *dara.RuntimeOptions) (_result *DescribeVpnCrossAccountAuthorizationsResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.PageNumber) {
		query["PageNumber"] = request.PageNumber
	}

	if !dara.IsNil(request.PageSize) {
		query["PageSize"] = request.PageSize
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.VpnConnectionId) {
		query["VpnConnectionId"] = request.VpnConnectionId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeVpnCrossAccountAuthorizations"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DescribeVpnCrossAccountAuthorizationsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the cross-account authorization information about an IPsec-VPN connection.
//
// @param request - DescribeVpnCrossAccountAuthorizationsRequest
//
// @return DescribeVpnCrossAccountAuthorizationsResponse
func (client *Client) DescribeVpnCrossAccountAuthorizations(request *DescribeVpnCrossAccountAuthorizationsRequest) (_result *DescribeVpnCrossAccountAuthorizationsResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DescribeVpnCrossAccountAuthorizationsResponse{}
	_body, _err := client.DescribeVpnCrossAccountAuthorizationsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the detailed information about a VPN gateway.
//
// @param request - DescribeVpnGatewayRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeVpnGatewayResponse
func (client *Client) DescribeVpnGatewayWithOptions(request *DescribeVpnGatewayRequest, runtime *dara.RuntimeOptions) (_result *DescribeVpnGatewayResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.IncludeReservationData) {
		query["IncludeReservationData"] = request.IncludeReservationData
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.VpnGatewayId) {
		query["VpnGatewayId"] = request.VpnGatewayId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeVpnGateway"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DescribeVpnGatewayResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the detailed information about a VPN gateway.
//
// @param request - DescribeVpnGatewayRequest
//
// @return DescribeVpnGatewayResponse
func (client *Client) DescribeVpnGateway(request *DescribeVpnGatewayRequest) (_result *DescribeVpnGatewayResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DescribeVpnGatewayResponse{}
	_body, _err := client.DescribeVpnGatewayWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries zones that support IPsec-VPN connections in a region.
//
// @param request - DescribeVpnGatewayAvailableZonesRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeVpnGatewayAvailableZonesResponse
func (client *Client) DescribeVpnGatewayAvailableZonesWithOptions(request *DescribeVpnGatewayAvailableZonesRequest, runtime *dara.RuntimeOptions) (_result *DescribeVpnGatewayAvailableZonesResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(dara.ToMap(request))
	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeVpnGatewayAvailableZones"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("GET"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DescribeVpnGatewayAvailableZonesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries zones that support IPsec-VPN connections in a region.
//
// @param request - DescribeVpnGatewayAvailableZonesRequest
//
// @return DescribeVpnGatewayAvailableZonesResponse
func (client *Client) DescribeVpnGatewayAvailableZones(request *DescribeVpnGatewayAvailableZonesRequest) (_result *DescribeVpnGatewayAvailableZonesResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DescribeVpnGatewayAvailableZonesResponse{}
	_body, _err := client.DescribeVpnGatewayAvailableZonesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries VPN gateways in a region.
//
// @param request - DescribeVpnGatewaysRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeVpnGatewaysResponse
func (client *Client) DescribeVpnGatewaysWithOptions(request *DescribeVpnGatewaysRequest, runtime *dara.RuntimeOptions) (_result *DescribeVpnGatewaysResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.BusinessStatus) {
		query["BusinessStatus"] = request.BusinessStatus
	}

	if !dara.IsNil(request.IncludeReservationData) {
		query["IncludeReservationData"] = request.IncludeReservationData
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PageNumber) {
		query["PageNumber"] = request.PageNumber
	}

	if !dara.IsNil(request.PageSize) {
		query["PageSize"] = request.PageSize
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceGroupId) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.Status) {
		query["Status"] = request.Status
	}

	if !dara.IsNil(request.Tag) {
		query["Tag"] = request.Tag
	}

	if !dara.IsNil(request.VpcId) {
		query["VpcId"] = request.VpcId
	}

	if !dara.IsNil(request.VpnGatewayId) {
		query["VpnGatewayId"] = request.VpnGatewayId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeVpnGateways"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DescribeVpnGatewaysResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries VPN gateways in a region.
//
// @param request - DescribeVpnGatewaysRequest
//
// @return DescribeVpnGatewaysResponse
func (client *Client) DescribeVpnGateways(request *DescribeVpnGatewaysRequest) (_result *DescribeVpnGatewaysResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DescribeVpnGatewaysResponse{}
	_body, _err := client.DescribeVpnGatewaysWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries policy-based routes configured for a VPN gateway.
//
// @param request - DescribeVpnPbrRouteEntriesRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeVpnPbrRouteEntriesResponse
func (client *Client) DescribeVpnPbrRouteEntriesWithOptions(request *DescribeVpnPbrRouteEntriesRequest, runtime *dara.RuntimeOptions) (_result *DescribeVpnPbrRouteEntriesResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PageNumber) {
		query["PageNumber"] = request.PageNumber
	}

	if !dara.IsNil(request.PageSize) {
		query["PageSize"] = request.PageSize
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.VpnGatewayId) {
		query["VpnGatewayId"] = request.VpnGatewayId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeVpnPbrRouteEntries"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DescribeVpnPbrRouteEntriesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries policy-based routes configured for a VPN gateway.
//
// @param request - DescribeVpnPbrRouteEntriesRequest
//
// @return DescribeVpnPbrRouteEntriesResponse
func (client *Client) DescribeVpnPbrRouteEntries(request *DescribeVpnPbrRouteEntriesRequest) (_result *DescribeVpnPbrRouteEntriesResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DescribeVpnPbrRouteEntriesResponse{}
	_body, _err := client.DescribeVpnPbrRouteEntriesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries destination-based and BGP route entries of a VPN gateway.
//
// @param request - DescribeVpnRouteEntriesRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeVpnRouteEntriesResponse
func (client *Client) DescribeVpnRouteEntriesWithOptions(request *DescribeVpnRouteEntriesRequest, runtime *dara.RuntimeOptions) (_result *DescribeVpnRouteEntriesResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PageNumber) {
		query["PageNumber"] = request.PageNumber
	}

	if !dara.IsNil(request.PageSize) {
		query["PageSize"] = request.PageSize
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.RouteEntryType) {
		query["RouteEntryType"] = request.RouteEntryType
	}

	if !dara.IsNil(request.VpnGatewayId) {
		query["VpnGatewayId"] = request.VpnGatewayId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeVpnRouteEntries"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DescribeVpnRouteEntriesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries destination-based and BGP route entries of a VPN gateway.
//
// @param request - DescribeVpnRouteEntriesRequest
//
// @return DescribeVpnRouteEntriesResponse
func (client *Client) DescribeVpnRouteEntries(request *DescribeVpnRouteEntriesRequest) (_result *DescribeVpnRouteEntriesResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DescribeVpnRouteEntriesResponse{}
	_body, _err := client.DescribeVpnRouteEntriesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the log entries of an SSL server.
//
// @param request - DescribeVpnSslServerLogsRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeVpnSslServerLogsResponse
func (client *Client) DescribeVpnSslServerLogsWithOptions(request *DescribeVpnSslServerLogsRequest, runtime *dara.RuntimeOptions) (_result *DescribeVpnSslServerLogsResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.From) {
		query["From"] = request.From
	}

	if !dara.IsNil(request.MinutePeriod) {
		query["MinutePeriod"] = request.MinutePeriod
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PageNumber) {
		query["PageNumber"] = request.PageNumber
	}

	if !dara.IsNil(request.PageSize) {
		query["PageSize"] = request.PageSize
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.SslVpnClientCertId) {
		query["SslVpnClientCertId"] = request.SslVpnClientCertId
	}

	if !dara.IsNil(request.To) {
		query["To"] = request.To
	}

	if !dara.IsNil(request.VpnSslServerId) {
		query["VpnSslServerId"] = request.VpnSslServerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeVpnSslServerLogs"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DescribeVpnSslServerLogsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the log entries of an SSL server.
//
// @param request - DescribeVpnSslServerLogsRequest
//
// @return DescribeVpnSslServerLogsResponse
func (client *Client) DescribeVpnSslServerLogs(request *DescribeVpnSslServerLogsRequest) (_result *DescribeVpnSslServerLogsResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DescribeVpnSslServerLogsResponse{}
	_body, _err := client.DescribeVpnSslServerLogsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries zones in a region.
//
// @param request - DescribeZonesRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeZonesResponse
func (client *Client) DescribeZonesWithOptions(request *DescribeZonesRequest, runtime *dara.RuntimeOptions) (_result *DescribeZonesResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.AcceptLanguage) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.ZoneType) {
		query["ZoneType"] = request.ZoneType
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeZones"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DescribeZonesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries zones in a region.
//
// @param request - DescribeZonesRequest
//
// @return DescribeZonesResponse
func (client *Client) DescribeZones(request *DescribeZonesRequest) (_result *DescribeZonesResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DescribeZonesResponse{}
	_body, _err := client.DescribeZonesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Disassociates a DHCP options set from a virtual private cloud (VPC).
//
// Description:
//
// ## [](#)Description
//
//   - **DetachDhcpOptionsSetFromVpc*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpcAttribute](https://help.aliyun.com/document_detail/94565.html) operation to query the status of the task.
//
//   - If the DHCP options set is in the **Pending*	- state, the DHCP options set is being disassociated.
//
//   - If the DHCP options set is in the **UnUsed*	- state, the DHCP options set is disassociated.
//
//   - You cannot repeatedly call the **DetachDhcpOptionsSetFromVpc*	- operation to disassociate a DHCP options set from a VPC within the specified period of time.
//
// @param request - DetachDhcpOptionsSetFromVpcRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DetachDhcpOptionsSetFromVpcResponse
func (client *Client) DetachDhcpOptionsSetFromVpcWithOptions(request *DetachDhcpOptionsSetFromVpcRequest, runtime *dara.RuntimeOptions) (_result *DetachDhcpOptionsSetFromVpcResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DhcpOptionsSetId) {
		query["DhcpOptionsSetId"] = request.DhcpOptionsSetId
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.VpcId) {
		query["VpcId"] = request.VpcId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DetachDhcpOptionsSetFromVpc"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DetachDhcpOptionsSetFromVpcResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Disassociates a DHCP options set from a virtual private cloud (VPC).
//
// Description:
//
// ## [](#)Description
//
//   - **DetachDhcpOptionsSetFromVpc*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpcAttribute](https://help.aliyun.com/document_detail/94565.html) operation to query the status of the task.
//
//   - If the DHCP options set is in the **Pending*	- state, the DHCP options set is being disassociated.
//
//   - If the DHCP options set is in the **UnUsed*	- state, the DHCP options set is disassociated.
//
//   - You cannot repeatedly call the **DetachDhcpOptionsSetFromVpc*	- operation to disassociate a DHCP options set from a VPC within the specified period of time.
//
// @param request - DetachDhcpOptionsSetFromVpcRequest
//
// @return DetachDhcpOptionsSetFromVpcResponse
func (client *Client) DetachDhcpOptionsSetFromVpc(request *DetachDhcpOptionsSetFromVpcRequest) (_result *DetachDhcpOptionsSetFromVpcResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DetachDhcpOptionsSetFromVpcResponse{}
	_body, _err := client.DetachDhcpOptionsSetFromVpcWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Diagnoses IPsec-VPN connections.
//
// Description:
//
//	  If the IPsec-VPN connection is in single-tunnel mode, the request parameter `VpnConnectionIds` is required when you call the **DiagnoseVpnConnections*	- operation.
//
//		- If the IPsec-VPN connection is in dual-tunnel mode, the request parameter `TunnelIds` is required when you call the **DiagnoseVpnConnections*	- operation.
//
//		- After you call the **DiagnoseVpnConnections*	- operation, if the current IPsec-VPN connection is faulty, the operation returns the corresponding error code (**FailedReasonCode**) and log (**SourceLog**). You can troubleshoot based on the error code and log information. For more information, see [Common errors and troubleshooting methods for IPsec-VPN connections](https://help.aliyun.com/document_detail/477862.html).
//
// @param request - DiagnoseVpnConnectionsRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DiagnoseVpnConnectionsResponse
func (client *Client) DiagnoseVpnConnectionsWithOptions(request *DiagnoseVpnConnectionsRequest, runtime *dara.RuntimeOptions) (_result *DiagnoseVpnConnectionsResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.PageNumber) {
		query["PageNumber"] = request.PageNumber
	}

	if !dara.IsNil(request.PageSize) {
		query["PageSize"] = request.PageSize
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.TunnelIds) {
		query["TunnelIds"] = request.TunnelIds
	}

	if !dara.IsNil(request.VpnConnectionIds) {
		query["VpnConnectionIds"] = request.VpnConnectionIds
	}

	if !dara.IsNil(request.VpnGatewayId) {
		query["VpnGatewayId"] = request.VpnGatewayId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DiagnoseVpnConnections"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DiagnoseVpnConnectionsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Diagnoses IPsec-VPN connections.
//
// Description:
//
//	  If the IPsec-VPN connection is in single-tunnel mode, the request parameter `VpnConnectionIds` is required when you call the **DiagnoseVpnConnections*	- operation.
//
//		- If the IPsec-VPN connection is in dual-tunnel mode, the request parameter `TunnelIds` is required when you call the **DiagnoseVpnConnections*	- operation.
//
//		- After you call the **DiagnoseVpnConnections*	- operation, if the current IPsec-VPN connection is faulty, the operation returns the corresponding error code (**FailedReasonCode**) and log (**SourceLog**). You can troubleshoot based on the error code and log information. For more information, see [Common errors and troubleshooting methods for IPsec-VPN connections](https://help.aliyun.com/document_detail/477862.html).
//
// @param request - DiagnoseVpnConnectionsRequest
//
// @return DiagnoseVpnConnectionsResponse
func (client *Client) DiagnoseVpnConnections(request *DiagnoseVpnConnectionsRequest) (_result *DiagnoseVpnConnectionsResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DiagnoseVpnConnectionsResponse{}
	_body, _err := client.DiagnoseVpnConnectionsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Diagnoses a VPN gateway.
//
// @param request - DiagnoseVpnGatewayRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DiagnoseVpnGatewayResponse
func (client *Client) DiagnoseVpnGatewayWithOptions(request *DiagnoseVpnGatewayRequest, runtime *dara.RuntimeOptions) (_result *DiagnoseVpnGatewayResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.IPsecExtendInfo) {
		query["IPsecExtendInfo"] = request.IPsecExtendInfo
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceId) {
		query["ResourceId"] = request.ResourceId
	}

	if !dara.IsNil(request.ResourceType) {
		query["ResourceType"] = request.ResourceType
	}

	if !dara.IsNil(request.VpnGatewayId) {
		query["VpnGatewayId"] = request.VpnGatewayId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DiagnoseVpnGateway"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DiagnoseVpnGatewayResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Diagnoses a VPN gateway.
//
// @param request - DiagnoseVpnGatewayRequest
//
// @return DiagnoseVpnGatewayResponse
func (client *Client) DiagnoseVpnGateway(request *DiagnoseVpnGatewayRequest) (_result *DiagnoseVpnGatewayResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DiagnoseVpnGatewayResponse{}
	_body, _err := client.DiagnoseVpnGatewayWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Deprecated: OpenAPI DisableNatGatewayEcsMetric is deprecated
//
// Summary:
//
// Disables traffic monitoring for an Elastic Compute Service (ECS) instance.
//
// @param request - DisableNatGatewayEcsMetricRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DisableNatGatewayEcsMetricResponse
func (client *Client) DisableNatGatewayEcsMetricWithOptions(request *DisableNatGatewayEcsMetricRequest, runtime *dara.RuntimeOptions) (_result *DisableNatGatewayEcsMetricResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.NatGatewayId) {
		query["NatGatewayId"] = request.NatGatewayId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DisableNatGatewayEcsMetric"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DisableNatGatewayEcsMetricResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Deprecated: OpenAPI DisableNatGatewayEcsMetric is deprecated
//
// Summary:
//
// Disables traffic monitoring for an Elastic Compute Service (ECS) instance.
//
// @param request - DisableNatGatewayEcsMetricRequest
//
// @return DisableNatGatewayEcsMetricResponse
// Deprecated
func (client *Client) DisableNatGatewayEcsMetric(request *DisableNatGatewayEcsMetricRequest) (_result *DisableNatGatewayEcsMetricResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DisableNatGatewayEcsMetricResponse{}
	_body, _err := client.DisableNatGatewayEcsMetricWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Disables ClassicLink for a virtual private cloud (VPC).
//
// @param request - DisableVpcClassicLinkRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DisableVpcClassicLinkResponse
func (client *Client) DisableVpcClassicLinkWithOptions(request *DisableVpcClassicLinkRequest, runtime *dara.RuntimeOptions) (_result *DisableVpcClassicLinkResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.VpcId) {
		query["VpcId"] = request.VpcId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DisableVpcClassicLink"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DisableVpcClassicLinkResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Disables ClassicLink for a virtual private cloud (VPC).
//
// @param request - DisableVpcClassicLinkRequest
//
// @return DisableVpcClassicLinkResponse
func (client *Client) DisableVpcClassicLink(request *DisableVpcClassicLinkRequest) (_result *DisableVpcClassicLinkResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DisableVpcClassicLinkResponse{}
	_body, _err := client.DisableVpcClassicLinkWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Disassociates a gateway route table from an IPv4 gateway.
//
// @param request - DissociateRouteTableFromGatewayRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DissociateRouteTableFromGatewayResponse
func (client *Client) DissociateRouteTableFromGatewayWithOptions(request *DissociateRouteTableFromGatewayRequest, runtime *dara.RuntimeOptions) (_result *DissociateRouteTableFromGatewayResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.GatewayId) {
		query["GatewayId"] = request.GatewayId
	}

	if !dara.IsNil(request.GatewayType) {
		query["GatewayType"] = request.GatewayType
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.RouteTableId) {
		query["RouteTableId"] = request.RouteTableId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DissociateRouteTableFromGateway"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DissociateRouteTableFromGatewayResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Disassociates a gateway route table from an IPv4 gateway.
//
// @param request - DissociateRouteTableFromGatewayRequest
//
// @return DissociateRouteTableFromGatewayResponse
func (client *Client) DissociateRouteTableFromGateway(request *DissociateRouteTableFromGatewayRequest) (_result *DissociateRouteTableFromGatewayResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DissociateRouteTableFromGatewayResponse{}
	_body, _err := client.DissociateRouteTableFromGatewayWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Disassociates a gateway endpoint from a route table.
//
// @param request - DissociateRouteTablesFromVpcGatewayEndpointRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DissociateRouteTablesFromVpcGatewayEndpointResponse
func (client *Client) DissociateRouteTablesFromVpcGatewayEndpointWithOptions(request *DissociateRouteTablesFromVpcGatewayEndpointRequest, runtime *dara.RuntimeOptions) (_result *DissociateRouteTablesFromVpcGatewayEndpointResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.EndpointId) {
		query["EndpointId"] = request.EndpointId
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.RouteTableIds) {
		query["RouteTableIds"] = request.RouteTableIds
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DissociateRouteTablesFromVpcGatewayEndpoint"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DissociateRouteTablesFromVpcGatewayEndpointResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Disassociates a gateway endpoint from a route table.
//
// @param request - DissociateRouteTablesFromVpcGatewayEndpointRequest
//
// @return DissociateRouteTablesFromVpcGatewayEndpointResponse
func (client *Client) DissociateRouteTablesFromVpcGatewayEndpoint(request *DissociateRouteTablesFromVpcGatewayEndpointRequest) (_result *DissociateRouteTablesFromVpcGatewayEndpointResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DissociateRouteTablesFromVpcGatewayEndpointResponse{}
	_body, _err := client.DissociateRouteTablesFromVpcGatewayEndpointWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Disassociates a certificate from a VPN gateway.
//
// Description:
//
//	  **DissociateVpnGatewayWithCertificate*	- is an asynchronous operation. After a request is sent, the system returns a request and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) operation to query the status the task.
//
//	    	- If the VPN gateway is in the **updating*	- state, the SSL certificate is being disassociated from the VPN gateway.
//
//	    	- If the VPN gateway is in the **active*	- state, the SSL certificate is disassociated from the VPN gateway.
//
//		- You cannot repeatedly call **DissociateVpnGatewayWithCertificate*	- within a specific period of time.
//
// @param request - DissociateVpnGatewayWithCertificateRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DissociateVpnGatewayWithCertificateResponse
func (client *Client) DissociateVpnGatewayWithCertificateWithOptions(request *DissociateVpnGatewayWithCertificateRequest, runtime *dara.RuntimeOptions) (_result *DissociateVpnGatewayWithCertificateResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.CertificateId) {
		query["CertificateId"] = request.CertificateId
	}

	if !dara.IsNil(request.CertificateType) {
		query["CertificateType"] = request.CertificateType
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.VpnGatewayId) {
		query["VpnGatewayId"] = request.VpnGatewayId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DissociateVpnGatewayWithCertificate"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DissociateVpnGatewayWithCertificateResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Disassociates a certificate from a VPN gateway.
//
// Description:
//
//	  **DissociateVpnGatewayWithCertificate*	- is an asynchronous operation. After a request is sent, the system returns a request and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) operation to query the status the task.
//
//	    	- If the VPN gateway is in the **updating*	- state, the SSL certificate is being disassociated from the VPN gateway.
//
//	    	- If the VPN gateway is in the **active*	- state, the SSL certificate is disassociated from the VPN gateway.
//
//		- You cannot repeatedly call **DissociateVpnGatewayWithCertificate*	- within a specific period of time.
//
// @param request - DissociateVpnGatewayWithCertificateRequest
//
// @return DissociateVpnGatewayWithCertificateResponse
func (client *Client) DissociateVpnGatewayWithCertificate(request *DissociateVpnGatewayWithCertificateRequest) (_result *DissociateVpnGatewayWithCertificateResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DissociateVpnGatewayWithCertificateResponse{}
	_body, _err := client.DissociateVpnGatewayWithCertificateWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the configuration of an IPsec-VPN connection.
//
// @param request - DownloadVpnConnectionConfigRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DownloadVpnConnectionConfigResponse
func (client *Client) DownloadVpnConnectionConfigWithOptions(request *DownloadVpnConnectionConfigRequest, runtime *dara.RuntimeOptions) (_result *DownloadVpnConnectionConfigResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.VpnConnectionId) {
		query["VpnConnectionId"] = request.VpnConnectionId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DownloadVpnConnectionConfig"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &DownloadVpnConnectionConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the configuration of an IPsec-VPN connection.
//
// @param request - DownloadVpnConnectionConfigRequest
//
// @return DownloadVpnConnectionConfigResponse
func (client *Client) DownloadVpnConnectionConfig(request *DownloadVpnConnectionConfigRequest) (_result *DownloadVpnConnectionConfigResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &DownloadVpnConnectionConfigResponse{}
	_body, _err := client.DownloadVpnConnectionConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Deprecated: OpenAPI EnableNatGatewayEcsMetric is deprecated
//
// Summary:
//
// Enables Elastic Compute Service (ECS) traffic monitoring.
//
// @param request - EnableNatGatewayEcsMetricRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return EnableNatGatewayEcsMetricResponse
func (client *Client) EnableNatGatewayEcsMetricWithOptions(request *EnableNatGatewayEcsMetricRequest, runtime *dara.RuntimeOptions) (_result *EnableNatGatewayEcsMetricResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.NatGatewayId) {
		query["NatGatewayId"] = request.NatGatewayId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("EnableNatGatewayEcsMetric"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &EnableNatGatewayEcsMetricResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Deprecated: OpenAPI EnableNatGatewayEcsMetric is deprecated
//
// Summary:
//
// Enables Elastic Compute Service (ECS) traffic monitoring.
//
// @param request - EnableNatGatewayEcsMetricRequest
//
// @return EnableNatGatewayEcsMetricResponse
// Deprecated
func (client *Client) EnableNatGatewayEcsMetric(request *EnableNatGatewayEcsMetricRequest) (_result *EnableNatGatewayEcsMetricResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &EnableNatGatewayEcsMetricResponse{}
	_body, _err := client.EnableNatGatewayEcsMetricWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Enables an Express Connect circuit that is in the Confirmed state. After you perform this operation, the Express Connect circuit enters the Enabled state.
//
// Description:
//
// When you call this operation, take note of the following limits:
//
//   - You can enable only an Express Connect circuit that is in the **Confirmed*	- state.
//
//   - After you enable an Express Connect circuit, it enters the **Enabled*	- state.
//
//   - **EnablePhysicalConnection*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribePhysicalConnections](https://help.aliyun.com/document_detail/36042.html) operation to query the status of the task.
//
//   - You cannot repeatedly call **EnablePhysicalConnection*	- for an Express Connect circuit in the **Confirmed*	- state within a specific time period.
//
// @param request - EnablePhysicalConnectionRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return EnablePhysicalConnectionResponse
func (client *Client) EnablePhysicalConnectionWithOptions(request *EnablePhysicalConnectionRequest, runtime *dara.RuntimeOptions) (_result *EnablePhysicalConnectionResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ByPassSp) {
		query["ByPassSp"] = request.ByPassSp
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PhysicalConnectionId) {
		query["PhysicalConnectionId"] = request.PhysicalConnectionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("EnablePhysicalConnection"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &EnablePhysicalConnectionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Enables an Express Connect circuit that is in the Confirmed state. After you perform this operation, the Express Connect circuit enters the Enabled state.
//
// Description:
//
// When you call this operation, take note of the following limits:
//
//   - You can enable only an Express Connect circuit that is in the **Confirmed*	- state.
//
//   - After you enable an Express Connect circuit, it enters the **Enabled*	- state.
//
//   - **EnablePhysicalConnection*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribePhysicalConnections](https://help.aliyun.com/document_detail/36042.html) operation to query the status of the task.
//
//   - You cannot repeatedly call **EnablePhysicalConnection*	- for an Express Connect circuit in the **Confirmed*	- state within a specific time period.
//
// @param request - EnablePhysicalConnectionRequest
//
// @return EnablePhysicalConnectionResponse
func (client *Client) EnablePhysicalConnection(request *EnablePhysicalConnectionRequest) (_result *EnablePhysicalConnectionResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &EnablePhysicalConnectionResponse{}
	_body, _err := client.EnablePhysicalConnectionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Enables ClassicLink for a VPC.
//
// @param request - EnableVpcClassicLinkRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return EnableVpcClassicLinkResponse
func (client *Client) EnableVpcClassicLinkWithOptions(request *EnableVpcClassicLinkRequest, runtime *dara.RuntimeOptions) (_result *EnableVpcClassicLinkResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.VpcId) {
		query["VpcId"] = request.VpcId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("EnableVpcClassicLink"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &EnableVpcClassicLinkResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Enables ClassicLink for a VPC.
//
// @param request - EnableVpcClassicLinkRequest
//
// @return EnableVpcClassicLinkResponse
func (client *Client) EnableVpcClassicLink(request *EnableVpcClassicLinkRequest) (_result *EnableVpcClassicLinkResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &EnableVpcClassicLinkResponse{}
	_body, _err := client.EnableVpcClassicLinkWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Activates an IPv4 gateway.
//
// Description:
//
// ## [](#)Description
//
//   - **EnableVpcIpv4Gateway*	- is an asynchronous operation. After a request is sent, the system returns a **request ID*	- and runs the task in the background. You can call the [GetIpv4GatewayAttribute](https://help.aliyun.com/document_detail/407670.html) operation to query the status of an IPv4 gateway.
//
//   - If the IPv4 gateway is in the **Activating*	- state, the IPv4 gateway is being activated.
//
//   - If the IPv4 gateway is in the **Created*	- state, the IPv4 gateway is activated.
//
//   - You cannot repeatedly call the **EnableVpcIpv4Gateway*	- operation to activate an IPv4 gateway within the specified period of time.
//
// @param request - EnableVpcIpv4GatewayRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return EnableVpcIpv4GatewayResponse
func (client *Client) EnableVpcIpv4GatewayWithOptions(request *EnableVpcIpv4GatewayRequest, runtime *dara.RuntimeOptions) (_result *EnableVpcIpv4GatewayResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.Ipv4GatewayId) {
		query["Ipv4GatewayId"] = request.Ipv4GatewayId
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.RouteTableList) {
		query["RouteTableList"] = request.RouteTableList
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("EnableVpcIpv4Gateway"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &EnableVpcIpv4GatewayResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Activates an IPv4 gateway.
//
// Description:
//
// ## [](#)Description
//
//   - **EnableVpcIpv4Gateway*	- is an asynchronous operation. After a request is sent, the system returns a **request ID*	- and runs the task in the background. You can call the [GetIpv4GatewayAttribute](https://help.aliyun.com/document_detail/407670.html) operation to query the status of an IPv4 gateway.
//
//   - If the IPv4 gateway is in the **Activating*	- state, the IPv4 gateway is being activated.
//
//   - If the IPv4 gateway is in the **Created*	- state, the IPv4 gateway is activated.
//
//   - You cannot repeatedly call the **EnableVpcIpv4Gateway*	- operation to activate an IPv4 gateway within the specified period of time.
//
// @param request - EnableVpcIpv4GatewayRequest
//
// @return EnableVpcIpv4GatewayResponse
func (client *Client) EnableVpcIpv4Gateway(request *EnableVpcIpv4GatewayRequest) (_result *EnableVpcIpv4GatewayResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &EnableVpcIpv4GatewayResponse{}
	_body, _err := client.EnableVpcIpv4GatewayWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries a DHCP options set.
//
// @param request - GetDhcpOptionsSetRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetDhcpOptionsSetResponse
func (client *Client) GetDhcpOptionsSetWithOptions(request *GetDhcpOptionsSetRequest, runtime *dara.RuntimeOptions) (_result *GetDhcpOptionsSetResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.DhcpOptionsSetId) {
		query["DhcpOptionsSetId"] = request.DhcpOptionsSetId
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("GetDhcpOptionsSet"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &GetDhcpOptionsSetResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries a DHCP options set.
//
// @param request - GetDhcpOptionsSetRequest
//
// @return GetDhcpOptionsSetResponse
func (client *Client) GetDhcpOptionsSet(request *GetDhcpOptionsSetRequest) (_result *GetDhcpOptionsSetResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &GetDhcpOptionsSetResponse{}
	_body, _err := client.GetDhcpOptionsSetWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the status of a flow log.
//
// @param request - GetFlowLogServiceStatusRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetFlowLogServiceStatusResponse
func (client *Client) GetFlowLogServiceStatusWithOptions(request *GetFlowLogServiceStatusRequest, runtime *dara.RuntimeOptions) (_result *GetFlowLogServiceStatusResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("GetFlowLogServiceStatus"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &GetFlowLogServiceStatusResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the status of a flow log.
//
// @param request - GetFlowLogServiceStatusRequest
//
// @return GetFlowLogServiceStatusResponse
func (client *Client) GetFlowLogServiceStatus(request *GetFlowLogServiceStatusRequest) (_result *GetFlowLogServiceStatusResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &GetFlowLogServiceStatusResponse{}
	_body, _err := client.GetFlowLogServiceStatusWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries an IPv4 gateway.
//
// @param request - GetIpv4GatewayAttributeRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetIpv4GatewayAttributeResponse
func (client *Client) GetIpv4GatewayAttributeWithOptions(request *GetIpv4GatewayAttributeRequest, runtime *dara.RuntimeOptions) (_result *GetIpv4GatewayAttributeResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.Ipv4GatewayId) {
		query["Ipv4GatewayId"] = request.Ipv4GatewayId
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("GetIpv4GatewayAttribute"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &GetIpv4GatewayAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries an IPv4 gateway.
//
// @param request - GetIpv4GatewayAttributeRequest
//
// @return GetIpv4GatewayAttributeResponse
func (client *Client) GetIpv4GatewayAttribute(request *GetIpv4GatewayAttributeRequest) (_result *GetIpv4GatewayAttributeResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &GetIpv4GatewayAttributeResponse{}
	_body, _err := client.GetIpv4GatewayAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// NAT
//
// Description:
//
// You can call this operation to query information about a specified Internet NAT gateway or Virtual Private Cloud (VPC) NAT gateway. In this topic, "NAT gateway" refers to both gateway types.
//
// @param request - GetNatGatewayAttributeRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetNatGatewayAttributeResponse
func (client *Client) GetNatGatewayAttributeWithOptions(request *GetNatGatewayAttributeRequest, runtime *dara.RuntimeOptions) (_result *GetNatGatewayAttributeResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.NatGatewayId) {
		query["NatGatewayId"] = request.NatGatewayId
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("GetNatGatewayAttribute"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &GetNatGatewayAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// NAT
//
// Description:
//
// You can call this operation to query information about a specified Internet NAT gateway or Virtual Private Cloud (VPC) NAT gateway. In this topic, "NAT gateway" refers to both gateway types.
//
// @param request - GetNatGatewayAttributeRequest
//
// @return GetNatGatewayAttributeResponse
func (client *Client) GetNatGatewayAttribute(request *GetNatGatewayAttributeRequest) (_result *GetNatGatewayAttributeResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &GetNatGatewayAttributeResponse{}
	_body, _err := client.GetNatGatewayAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// 
//
// Description:
//
// You can call this API operation to query the status of outbound data transfer billing for the current account. For more information about outbound data transfer billing, see [Outbound data transfer billing](https://help.aliyun.com/document_detail/274385.html) and [Billing](https://help.aliyun.com/document_detail/54582.html).
//
// @param request - GetPhysicalConnectionServiceStatusRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetPhysicalConnectionServiceStatusResponse
func (client *Client) GetPhysicalConnectionServiceStatusWithOptions(request *GetPhysicalConnectionServiceStatusRequest, runtime *dara.RuntimeOptions) (_result *GetPhysicalConnectionServiceStatusResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("GetPhysicalConnectionServiceStatus"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &GetPhysicalConnectionServiceStatusResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// 
//
// Description:
//
// You can call this API operation to query the status of outbound data transfer billing for the current account. For more information about outbound data transfer billing, see [Outbound data transfer billing](https://help.aliyun.com/document_detail/274385.html) and [Billing](https://help.aliyun.com/document_detail/54582.html).
//
// @param request - GetPhysicalConnectionServiceStatusRequest
//
// @return GetPhysicalConnectionServiceStatusResponse
func (client *Client) GetPhysicalConnectionServiceStatus(request *GetPhysicalConnectionServiceStatusRequest) (_result *GetPhysicalConnectionServiceStatusResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &GetPhysicalConnectionServiceStatusResponse{}
	_body, _err := client.GetPhysicalConnectionServiceStatusWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries whether the IP address pool feature is enabled.
//
// @param request - GetPublicIpAddressPoolServiceStatusRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetPublicIpAddressPoolServiceStatusResponse
func (client *Client) GetPublicIpAddressPoolServiceStatusWithOptions(request *GetPublicIpAddressPoolServiceStatusRequest, runtime *dara.RuntimeOptions) (_result *GetPublicIpAddressPoolServiceStatusResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("GetPublicIpAddressPoolServiceStatus"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &GetPublicIpAddressPoolServiceStatusResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries whether the IP address pool feature is enabled.
//
// @param request - GetPublicIpAddressPoolServiceStatusRequest
//
// @return GetPublicIpAddressPoolServiceStatusResponse
func (client *Client) GetPublicIpAddressPoolServiceStatus(request *GetPublicIpAddressPoolServiceStatusRequest) (_result *GetPublicIpAddressPoolServiceStatusResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &GetPublicIpAddressPoolServiceStatusResponse{}
	_body, _err := client.GetPublicIpAddressPoolServiceStatusWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the status of the traffic mirror feature.
//
// @param request - GetTrafficMirrorServiceStatusRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetTrafficMirrorServiceStatusResponse
func (client *Client) GetTrafficMirrorServiceStatusWithOptions(request *GetTrafficMirrorServiceStatusRequest, runtime *dara.RuntimeOptions) (_result *GetTrafficMirrorServiceStatusResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("GetTrafficMirrorServiceStatus"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &GetTrafficMirrorServiceStatusResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the status of the traffic mirror feature.
//
// @param request - GetTrafficMirrorServiceStatusRequest
//
// @return GetTrafficMirrorServiceStatusResponse
func (client *Client) GetTrafficMirrorServiceStatus(request *GetTrafficMirrorServiceStatusRequest) (_result *GetTrafficMirrorServiceStatusResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &GetTrafficMirrorServiceStatusResponse{}
	_body, _err := client.GetTrafficMirrorServiceStatusWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the usage of a prefix list.
//
// @param request - GetVSwitchCidrReservationUsageRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetVSwitchCidrReservationUsageResponse
func (client *Client) GetVSwitchCidrReservationUsageWithOptions(request *GetVSwitchCidrReservationUsageRequest, runtime *dara.RuntimeOptions) (_result *GetVSwitchCidrReservationUsageResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.MaxResults) {
		query["MaxResults"] = request.MaxResults
	}

	if !dara.IsNil(request.NextToken) {
		query["NextToken"] = request.NextToken
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.VSwitchCidrReservationId) {
		query["VSwitchCidrReservationId"] = request.VSwitchCidrReservationId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("GetVSwitchCidrReservationUsage"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &GetVSwitchCidrReservationUsageResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the usage of a prefix list.
//
// @param request - GetVSwitchCidrReservationUsageRequest
//
// @return GetVSwitchCidrReservationUsageResponse
func (client *Client) GetVSwitchCidrReservationUsage(request *GetVSwitchCidrReservationUsageRequest) (_result *GetVSwitchCidrReservationUsageResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &GetVSwitchCidrReservationUsageResponse{}
	_body, _err := client.GetVSwitchCidrReservationUsageWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the attributes of a gateway endpoint.
//
// @param request - GetVpcGatewayEndpointAttributeRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetVpcGatewayEndpointAttributeResponse
func (client *Client) GetVpcGatewayEndpointAttributeWithOptions(request *GetVpcGatewayEndpointAttributeRequest, runtime *dara.RuntimeOptions) (_result *GetVpcGatewayEndpointAttributeResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.EndpointId) {
		query["EndpointId"] = request.EndpointId
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("GetVpcGatewayEndpointAttribute"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &GetVpcGatewayEndpointAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the attributes of a gateway endpoint.
//
// @param request - GetVpcGatewayEndpointAttributeRequest
//
// @return GetVpcGatewayEndpointAttributeResponse
func (client *Client) GetVpcGatewayEndpointAttribute(request *GetVpcGatewayEndpointAttributeRequest) (_result *GetVpcGatewayEndpointAttributeResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &GetVpcGatewayEndpointAttributeResponse{}
	_body, _err := client.GetVpcGatewayEndpointAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the resources that are associated with a prefix list.
//
// @param request - GetVpcPrefixListAssociationsRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetVpcPrefixListAssociationsResponse
func (client *Client) GetVpcPrefixListAssociationsWithOptions(request *GetVpcPrefixListAssociationsRequest, runtime *dara.RuntimeOptions) (_result *GetVpcPrefixListAssociationsResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.MaxResults) {
		query["MaxResults"] = request.MaxResults
	}

	if !dara.IsNil(request.NextToken) {
		query["NextToken"] = request.NextToken
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PrefixListId) {
		query["PrefixListId"] = request.PrefixListId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("GetVpcPrefixListAssociations"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &GetVpcPrefixListAssociationsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the resources that are associated with a prefix list.
//
// @param request - GetVpcPrefixListAssociationsRequest
//
// @return GetVpcPrefixListAssociationsResponse
func (client *Client) GetVpcPrefixListAssociations(request *GetVpcPrefixListAssociationsRequest) (_result *GetVpcPrefixListAssociationsResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &GetVpcPrefixListAssociationsResponse{}
	_body, _err := client.GetVpcPrefixListAssociationsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the information about a prefix list.
//
// @param request - GetVpcPrefixListEntriesRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetVpcPrefixListEntriesResponse
func (client *Client) GetVpcPrefixListEntriesWithOptions(request *GetVpcPrefixListEntriesRequest, runtime *dara.RuntimeOptions) (_result *GetVpcPrefixListEntriesResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.MaxResults) {
		query["MaxResults"] = request.MaxResults
	}

	if !dara.IsNil(request.NextToken) {
		query["NextToken"] = request.NextToken
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PrefixListId) {
		query["PrefixListId"] = request.PrefixListId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("GetVpcPrefixListEntries"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &GetVpcPrefixListEntriesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the information about a prefix list.
//
// @param request - GetVpcPrefixListEntriesRequest
//
// @return GetVpcPrefixListEntriesResponse
func (client *Client) GetVpcPrefixListEntries(request *GetVpcPrefixListEntriesRequest) (_result *GetVpcPrefixListEntriesResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &GetVpcPrefixListEntriesResponse{}
	_body, _err := client.GetVpcPrefixListEntriesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// 
//
// @param request - GetVpcRouteEntrySummaryRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetVpcRouteEntrySummaryResponse
func (client *Client) GetVpcRouteEntrySummaryWithOptions(request *GetVpcRouteEntrySummaryRequest, runtime *dara.RuntimeOptions) (_result *GetVpcRouteEntrySummaryResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.RouteEntryType) {
		query["RouteEntryType"] = request.RouteEntryType
	}

	if !dara.IsNil(request.RouteTableId) {
		query["RouteTableId"] = request.RouteTableId
	}

	if !dara.IsNil(request.VpcId) {
		query["VpcId"] = request.VpcId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("GetVpcRouteEntrySummary"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &GetVpcRouteEntrySummaryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// 
//
// @param request - GetVpcRouteEntrySummaryRequest
//
// @return GetVpcRouteEntrySummaryResponse
func (client *Client) GetVpcRouteEntrySummary(request *GetVpcRouteEntrySummaryRequest) (_result *GetVpcRouteEntrySummaryResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &GetVpcRouteEntrySummaryResponse{}
	_body, _err := client.GetVpcRouteEntrySummaryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the diagnostic result of a VPN gateway.
//
// Description:
//
// When you call the **GetVpnGatewayDiagnoseResult*	- operation, you must specify one of **DiagnoseId*	- and **VpnGatewayId**.
//
// @param request - GetVpnGatewayDiagnoseResultRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetVpnGatewayDiagnoseResultResponse
func (client *Client) GetVpnGatewayDiagnoseResultWithOptions(request *GetVpnGatewayDiagnoseResultRequest, runtime *dara.RuntimeOptions) (_result *GetVpnGatewayDiagnoseResultResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DiagnoseId) {
		query["DiagnoseId"] = request.DiagnoseId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.VpnGatewayId) {
		query["VpnGatewayId"] = request.VpnGatewayId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("GetVpnGatewayDiagnoseResult"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &GetVpnGatewayDiagnoseResultResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the diagnostic result of a VPN gateway.
//
// Description:
//
// When you call the **GetVpnGatewayDiagnoseResult*	- operation, you must specify one of **DiagnoseId*	- and **VpnGatewayId**.
//
// @param request - GetVpnGatewayDiagnoseResultRequest
//
// @return GetVpnGatewayDiagnoseResultResponse
func (client *Client) GetVpnGatewayDiagnoseResult(request *GetVpnGatewayDiagnoseResultRequest) (_result *GetVpnGatewayDiagnoseResultResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &GetVpnGatewayDiagnoseResultResponse{}
	_body, _err := client.GetVpnGatewayDiagnoseResultWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Grants permissions to a Cloud Enterprise Network (CEN) instance.
//
// Description:
//
//	Before you can attach a network instance that belongs to another Alibaba Cloud account to your CEN instance, you must grant permissions to your CEN instance.
//
// >  **GrantInstanceToCen*	- is a Virtual Private Cloud (VPC) operation. Therefore, you must use the `vpc.aliyuncs.com` domain name to call this operation. The API version is `2016-04-28`.
//
//   - You cannot repeatedly call the **GrantInstanceToCen*	- operation to grant the permissions on a network instance to a CEN instance. The network instance can be a VPC, a virtual border router (VBR), or a Cloud Connect Network (CCN) instance.
//
// @param request - GrantInstanceToCenRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GrantInstanceToCenResponse
func (client *Client) GrantInstanceToCenWithOptions(request *GrantInstanceToCenRequest, runtime *dara.RuntimeOptions) (_result *GrantInstanceToCenResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.CenId) {
		query["CenId"] = request.CenId
	}

	if !dara.IsNil(request.CenOwnerId) {
		query["CenOwnerId"] = request.CenOwnerId
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.InstanceId) {
		query["InstanceId"] = request.InstanceId
	}

	if !dara.IsNil(request.InstanceType) {
		query["InstanceType"] = request.InstanceType
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("GrantInstanceToCen"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &GrantInstanceToCenResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Grants permissions to a Cloud Enterprise Network (CEN) instance.
//
// Description:
//
//	Before you can attach a network instance that belongs to another Alibaba Cloud account to your CEN instance, you must grant permissions to your CEN instance.
//
// >  **GrantInstanceToCen*	- is a Virtual Private Cloud (VPC) operation. Therefore, you must use the `vpc.aliyuncs.com` domain name to call this operation. The API version is `2016-04-28`.
//
//   - You cannot repeatedly call the **GrantInstanceToCen*	- operation to grant the permissions on a network instance to a CEN instance. The network instance can be a VPC, a virtual border router (VBR), or a Cloud Connect Network (CCN) instance.
//
// @param request - GrantInstanceToCenRequest
//
// @return GrantInstanceToCenResponse
func (client *Client) GrantInstanceToCen(request *GrantInstanceToCenRequest) (_result *GrantInstanceToCenResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &GrantInstanceToCenResponse{}
	_body, _err := client.GrantInstanceToCenWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Grants a virtual border router (VBR) the permissions to connect to a virtual private cloud (VPC) that belongs to another Alibaba Cloud account.
//
// Description:
//
// ## Usage notes
//
// When you connect a VBR to a VPC that belongs to another Alibaba Cloud account, the VBR must acquire the required permissions from the VPC.
//
// @param tmpReq - GrantInstanceToVbrRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GrantInstanceToVbrResponse
func (client *Client) GrantInstanceToVbrWithOptions(tmpReq *GrantInstanceToVbrRequest, runtime *dara.RuntimeOptions) (_result *GrantInstanceToVbrResponse, _err error) {
	_err = tmpReq.Validate()
	if _err != nil {
		return _result, _err
	}
	request := &GrantInstanceToVbrShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !dara.IsNil(tmpReq.VbrInstanceIds) {
		request.VbrInstanceIdsShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.VbrInstanceIds, dara.String("VbrInstanceIds"), dara.String("simple"))
	}

	query := map[string]interface{}{}
	if !dara.IsNil(request.GrantType) {
		query["GrantType"] = request.GrantType
	}

	if !dara.IsNil(request.InstanceId) {
		query["InstanceId"] = request.InstanceId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.VbrInstanceIdsShrink) {
		query["VbrInstanceIds"] = request.VbrInstanceIdsShrink
	}

	if !dara.IsNil(request.VbrOwnerUid) {
		query["VbrOwnerUid"] = request.VbrOwnerUid
	}

	if !dara.IsNil(request.VbrRegionNo) {
		query["VbrRegionNo"] = request.VbrRegionNo
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("GrantInstanceToVbr"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &GrantInstanceToVbrResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Grants a virtual border router (VBR) the permissions to connect to a virtual private cloud (VPC) that belongs to another Alibaba Cloud account.
//
// Description:
//
// ## Usage notes
//
// When you connect a VBR to a VPC that belongs to another Alibaba Cloud account, the VBR must acquire the required permissions from the VPC.
//
// @param request - GrantInstanceToVbrRequest
//
// @return GrantInstanceToVbrResponse
func (client *Client) GrantInstanceToVbr(request *GrantInstanceToVbrRequest) (_result *GrantInstanceToVbrResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &GrantInstanceToVbrResponse{}
	_body, _err := client.GrantInstanceToVbrWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the access points of an Express Connect circuit.
//
// @param request - ListBusinessAccessPointsRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListBusinessAccessPointsResponse
func (client *Client) ListBusinessAccessPointsWithOptions(request *ListBusinessAccessPointsRequest, runtime *dara.RuntimeOptions) (_result *ListBusinessAccessPointsResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ListBusinessAccessPoints"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ListBusinessAccessPointsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the access points of an Express Connect circuit.
//
// @param request - ListBusinessAccessPointsRequest
//
// @return ListBusinessAccessPointsResponse
func (client *Client) ListBusinessAccessPoints(request *ListBusinessAccessPointsRequest) (_result *ListBusinessAccessPointsResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ListBusinessAccessPointsResponse{}
	_body, _err := client.ListBusinessAccessPointsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries Dynamic Host Configuration Protocol (DHCP) options sets.
//
// @param request - ListDhcpOptionsSetsRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListDhcpOptionsSetsResponse
func (client *Client) ListDhcpOptionsSetsWithOptions(request *ListDhcpOptionsSetsRequest, runtime *dara.RuntimeOptions) (_result *ListDhcpOptionsSetsResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.DhcpOptionsSetId) {
		query["DhcpOptionsSetId"] = request.DhcpOptionsSetId
	}

	if !dara.IsNil(request.DhcpOptionsSetName) {
		query["DhcpOptionsSetName"] = request.DhcpOptionsSetName
	}

	if !dara.IsNil(request.DomainName) {
		query["DomainName"] = request.DomainName
	}

	if !dara.IsNil(request.MaxResults) {
		query["MaxResults"] = request.MaxResults
	}

	if !dara.IsNil(request.NextToken) {
		query["NextToken"] = request.NextToken
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceGroupId) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.Tags) {
		query["Tags"] = request.Tags
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ListDhcpOptionsSets"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ListDhcpOptionsSetsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries Dynamic Host Configuration Protocol (DHCP) options sets.
//
// @param request - ListDhcpOptionsSetsRequest
//
// @return ListDhcpOptionsSetsResponse
func (client *Client) ListDhcpOptionsSets(request *ListDhcpOptionsSetsRequest) (_result *ListDhcpOptionsSetsResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ListDhcpOptionsSetsResponse{}
	_body, _err := client.ListDhcpOptionsSetsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the zones that support NAT gateways.
//
// Description:
//
// You can call this operation to query zones that support NAT gateways, including Internet NAT gateways and Virtual Private Cloud (VPC) NAT gateways.
//
// @param request - ListEnhanhcedNatGatewayAvailableZonesRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListEnhanhcedNatGatewayAvailableZonesResponse
func (client *Client) ListEnhanhcedNatGatewayAvailableZonesWithOptions(request *ListEnhanhcedNatGatewayAvailableZonesRequest, runtime *dara.RuntimeOptions) (_result *ListEnhanhcedNatGatewayAvailableZonesResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.AcceptLanguage) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !dara.IsNil(request.Filter) {
		query["Filter"] = request.Filter
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ListEnhanhcedNatGatewayAvailableZones"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ListEnhanhcedNatGatewayAvailableZonesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the zones that support NAT gateways.
//
// Description:
//
// You can call this operation to query zones that support NAT gateways, including Internet NAT gateways and Virtual Private Cloud (VPC) NAT gateways.
//
// @param request - ListEnhanhcedNatGatewayAvailableZonesRequest
//
// @return ListEnhanhcedNatGatewayAvailableZonesResponse
func (client *Client) ListEnhanhcedNatGatewayAvailableZones(request *ListEnhanhcedNatGatewayAvailableZonesRequest) (_result *ListEnhanhcedNatGatewayAvailableZonesResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ListEnhanhcedNatGatewayAvailableZonesResponse{}
	_body, _err := client.ListEnhanhcedNatGatewayAvailableZonesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries FULLNAT entries.
//
// @param request - ListFullNatEntriesRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListFullNatEntriesResponse
func (client *Client) ListFullNatEntriesWithOptions(request *ListFullNatEntriesRequest, runtime *dara.RuntimeOptions) (_result *ListFullNatEntriesResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.FullNatEntryId) {
		query["FullNatEntryId"] = request.FullNatEntryId
	}

	if !dara.IsNil(request.FullNatEntryNames) {
		query["FullNatEntryNames"] = request.FullNatEntryNames
	}

	if !dara.IsNil(request.FullNatTableId) {
		query["FullNatTableId"] = request.FullNatTableId
	}

	if !dara.IsNil(request.IpProtocol) {
		query["IpProtocol"] = request.IpProtocol
	}

	if !dara.IsNil(request.MaxResults) {
		query["MaxResults"] = request.MaxResults
	}

	if !dara.IsNil(request.NatGatewayId) {
		query["NatGatewayId"] = request.NatGatewayId
	}

	if !dara.IsNil(request.NatIp) {
		query["NatIp"] = request.NatIp
	}

	if !dara.IsNil(request.NatIpPort) {
		query["NatIpPort"] = request.NatIpPort
	}

	if !dara.IsNil(request.NetworkInterfaceIds) {
		query["NetworkInterfaceIds"] = request.NetworkInterfaceIds
	}

	if !dara.IsNil(request.NextToken) {
		query["NextToken"] = request.NextToken
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ListFullNatEntries"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ListFullNatEntriesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries FULLNAT entries.
//
// @param request - ListFullNatEntriesRequest
//
// @return ListFullNatEntriesResponse
func (client *Client) ListFullNatEntries(request *ListFullNatEntriesRequest) (_result *ListFullNatEntriesResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ListFullNatEntriesResponse{}
	_body, _err := client.ListFullNatEntriesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries route entries of a gateway route table.
//
// @param request - ListGatewayRouteTableEntriesRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListGatewayRouteTableEntriesResponse
func (client *Client) ListGatewayRouteTableEntriesWithOptions(request *ListGatewayRouteTableEntriesRequest, runtime *dara.RuntimeOptions) (_result *ListGatewayRouteTableEntriesResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.DestinationCidrBlock) {
		query["DestinationCidrBlock"] = request.DestinationCidrBlock
	}

	if !dara.IsNil(request.GatewayRouteTableId) {
		query["GatewayRouteTableId"] = request.GatewayRouteTableId
	}

	if !dara.IsNil(request.MaxResults) {
		query["MaxResults"] = request.MaxResults
	}

	if !dara.IsNil(request.NextToken) {
		query["NextToken"] = request.NextToken
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ListGatewayRouteTableEntries"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ListGatewayRouteTableEntriesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries route entries of a gateway route table.
//
// @param request - ListGatewayRouteTableEntriesRequest
//
// @return ListGatewayRouteTableEntriesResponse
func (client *Client) ListGatewayRouteTableEntries(request *ListGatewayRouteTableEntriesRequest) (_result *ListGatewayRouteTableEntriesResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ListGatewayRouteTableEntriesResponse{}
	_body, _err := client.ListGatewayRouteTableEntriesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the most recent region list.
//
// @param request - ListGeographicSubRegionsRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListGeographicSubRegionsResponse
func (client *Client) ListGeographicSubRegionsWithOptions(runtime *dara.RuntimeOptions) (_result *ListGeographicSubRegionsResponse, _err error) {
	req := &openapiutil.OpenApiRequest{}
	params := &openapiutil.Params{
		Action:      dara.String("ListGeographicSubRegions"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ListGeographicSubRegionsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the most recent region list.
//
// @return ListGeographicSubRegionsResponse
func (client *Client) ListGeographicSubRegions() (_result *ListGeographicSubRegionsResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ListGeographicSubRegionsResponse{}
	_body, _err := client.ListGeographicSubRegionsWithOptions(runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the logs of an IPsec server.
//
// @param request - ListIpsecServerLogsRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListIpsecServerLogsResponse
func (client *Client) ListIpsecServerLogsWithOptions(request *ListIpsecServerLogsRequest, runtime *dara.RuntimeOptions) (_result *ListIpsecServerLogsResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.From) {
		query["From"] = request.From
	}

	if !dara.IsNil(request.IpsecServerId) {
		query["IpsecServerId"] = request.IpsecServerId
	}

	if !dara.IsNil(request.MinutePeriod) {
		query["MinutePeriod"] = request.MinutePeriod
	}

	if !dara.IsNil(request.PageNumber) {
		query["PageNumber"] = request.PageNumber
	}

	if !dara.IsNil(request.PageSize) {
		query["PageSize"] = request.PageSize
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.To) {
		query["To"] = request.To
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ListIpsecServerLogs"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ListIpsecServerLogsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the logs of an IPsec server.
//
// @param request - ListIpsecServerLogsRequest
//
// @return ListIpsecServerLogsResponse
func (client *Client) ListIpsecServerLogs(request *ListIpsecServerLogsRequest) (_result *ListIpsecServerLogsResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ListIpsecServerLogsResponse{}
	_body, _err := client.ListIpsecServerLogsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries IPsec servers.
//
// @param request - ListIpsecServersRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListIpsecServersResponse
func (client *Client) ListIpsecServersWithOptions(request *ListIpsecServersRequest, runtime *dara.RuntimeOptions) (_result *ListIpsecServersResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.IpsecServerId) {
		query["IpsecServerId"] = request.IpsecServerId
	}

	if !dara.IsNil(request.IpsecServerName) {
		query["IpsecServerName"] = request.IpsecServerName
	}

	if !dara.IsNil(request.MaxResults) {
		query["MaxResults"] = request.MaxResults
	}

	if !dara.IsNil(request.NextToken) {
		query["NextToken"] = request.NextToken
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceGroupId) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !dara.IsNil(request.VpnGatewayId) {
		query["VpnGatewayId"] = request.VpnGatewayId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ListIpsecServers"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ListIpsecServersResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries IPsec servers.
//
// @param request - ListIpsecServersRequest
//
// @return ListIpsecServersResponse
func (client *Client) ListIpsecServers(request *ListIpsecServersRequest) (_result *ListIpsecServersResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ListIpsecServersResponse{}
	_body, _err := client.ListIpsecServersWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries IPv4 gateways.
//
// @param request - ListIpv4GatewaysRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListIpv4GatewaysResponse
func (client *Client) ListIpv4GatewaysWithOptions(request *ListIpv4GatewaysRequest, runtime *dara.RuntimeOptions) (_result *ListIpv4GatewaysResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.Ipv4GatewayId) {
		query["Ipv4GatewayId"] = request.Ipv4GatewayId
	}

	if !dara.IsNil(request.Ipv4GatewayName) {
		query["Ipv4GatewayName"] = request.Ipv4GatewayName
	}

	if !dara.IsNil(request.MaxResults) {
		query["MaxResults"] = request.MaxResults
	}

	if !dara.IsNil(request.NextToken) {
		query["NextToken"] = request.NextToken
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceGroupId) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.Tags) {
		query["Tags"] = request.Tags
	}

	if !dara.IsNil(request.VpcId) {
		query["VpcId"] = request.VpcId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ListIpv4Gateways"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ListIpv4GatewaysResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries IPv4 gateways.
//
// @param request - ListIpv4GatewaysRequest
//
// @return ListIpv4GatewaysResponse
func (client *Client) ListIpv4Gateways(request *ListIpv4GatewaysRequest) (_result *ListIpv4GatewaysResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ListIpv4GatewaysResponse{}
	_body, _err := client.ListIpv4GatewaysWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the CIDR blocks of a specified NAT gateway.
//
// @param request - ListNatIpCidrsRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListNatIpCidrsResponse
func (client *Client) ListNatIpCidrsWithOptions(request *ListNatIpCidrsRequest, runtime *dara.RuntimeOptions) (_result *ListNatIpCidrsResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.MaxResults) {
		query["MaxResults"] = request.MaxResults
	}

	if !dara.IsNil(request.NatGatewayId) {
		query["NatGatewayId"] = request.NatGatewayId
	}

	if !dara.IsNil(request.NatIpCidr) {
		query["NatIpCidr"] = request.NatIpCidr
	}

	if !dara.IsNil(request.NatIpCidrName) {
		query["NatIpCidrName"] = request.NatIpCidrName
	}

	if !dara.IsNil(request.NatIpCidrStatus) {
		query["NatIpCidrStatus"] = request.NatIpCidrStatus
	}

	if !dara.IsNil(request.NatIpCidrs) {
		query["NatIpCidrs"] = request.NatIpCidrs
	}

	if !dara.IsNil(request.NextToken) {
		query["NextToken"] = request.NextToken
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ListNatIpCidrs"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ListNatIpCidrsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the CIDR blocks of a specified NAT gateway.
//
// @param request - ListNatIpCidrsRequest
//
// @return ListNatIpCidrsResponse
func (client *Client) ListNatIpCidrs(request *ListNatIpCidrsRequest) (_result *ListNatIpCidrsResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ListNatIpCidrsResponse{}
	_body, _err := client.ListNatIpCidrsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the IP addresses on a NAT gateway.
//
// @param request - ListNatIpsRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListNatIpsResponse
func (client *Client) ListNatIpsWithOptions(request *ListNatIpsRequest, runtime *dara.RuntimeOptions) (_result *ListNatIpsResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.MaxResults) {
		query["MaxResults"] = request.MaxResults
	}

	if !dara.IsNil(request.NatGatewayId) {
		query["NatGatewayId"] = request.NatGatewayId
	}

	if !dara.IsNil(request.NatIpCidr) {
		query["NatIpCidr"] = request.NatIpCidr
	}

	if !dara.IsNil(request.NatIpIds) {
		query["NatIpIds"] = request.NatIpIds
	}

	if !dara.IsNil(request.NatIpName) {
		query["NatIpName"] = request.NatIpName
	}

	if !dara.IsNil(request.NatIpStatus) {
		query["NatIpStatus"] = request.NatIpStatus
	}

	if !dara.IsNil(request.NextToken) {
		query["NextToken"] = request.NextToken
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ListNatIps"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ListNatIpsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the IP addresses on a NAT gateway.
//
// @param request - ListNatIpsRequest
//
// @return ListNatIpsResponse
func (client *Client) ListNatIps(request *ListNatIpsRequest) (_result *ListNatIpsResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ListNatIpsResponse{}
	_body, _err := client.ListNatIpsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries prefix lists.
//
// @param request - ListPrefixListsRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListPrefixListsResponse
func (client *Client) ListPrefixListsWithOptions(request *ListPrefixListsRequest, runtime *dara.RuntimeOptions) (_result *ListPrefixListsResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.MaxResults) {
		query["MaxResults"] = request.MaxResults
	}

	if !dara.IsNil(request.NextToken) {
		query["NextToken"] = request.NextToken
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PrefixListIds) {
		query["PrefixListIds"] = request.PrefixListIds
	}

	if !dara.IsNil(request.PrefixListName) {
		query["PrefixListName"] = request.PrefixListName
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceGroupId) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.Tags) {
		query["Tags"] = request.Tags
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ListPrefixLists"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ListPrefixListsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries prefix lists.
//
// @param request - ListPrefixListsRequest
//
// @return ListPrefixListsResponse
func (client *Client) ListPrefixLists(request *ListPrefixListsRequest) (_result *ListPrefixListsResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ListPrefixListsResponse{}
	_body, _err := client.ListPrefixListsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// IPIP
//
// @param request - ListPublicIpAddressPoolCidrBlocksRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListPublicIpAddressPoolCidrBlocksResponse
func (client *Client) ListPublicIpAddressPoolCidrBlocksWithOptions(request *ListPublicIpAddressPoolCidrBlocksRequest, runtime *dara.RuntimeOptions) (_result *ListPublicIpAddressPoolCidrBlocksResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.CidrBlock) {
		query["CidrBlock"] = request.CidrBlock
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.MaxResults) {
		query["MaxResults"] = request.MaxResults
	}

	if !dara.IsNil(request.NextToken) {
		query["NextToken"] = request.NextToken
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PublicIpAddressPoolId) {
		query["PublicIpAddressPoolId"] = request.PublicIpAddressPoolId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ListPublicIpAddressPoolCidrBlocks"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ListPublicIpAddressPoolCidrBlocksResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// IPIP
//
// @param request - ListPublicIpAddressPoolCidrBlocksRequest
//
// @return ListPublicIpAddressPoolCidrBlocksResponse
func (client *Client) ListPublicIpAddressPoolCidrBlocks(request *ListPublicIpAddressPoolCidrBlocksRequest) (_result *ListPublicIpAddressPoolCidrBlocksResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ListPublicIpAddressPoolCidrBlocksResponse{}
	_body, _err := client.ListPublicIpAddressPoolCidrBlocksWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries available IP address pools.
//
// @param request - ListPublicIpAddressPoolsRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListPublicIpAddressPoolsResponse
func (client *Client) ListPublicIpAddressPoolsWithOptions(request *ListPublicIpAddressPoolsRequest, runtime *dara.RuntimeOptions) (_result *ListPublicIpAddressPoolsResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.Isp) {
		query["Isp"] = request.Isp
	}

	if !dara.IsNil(request.MaxResults) {
		query["MaxResults"] = request.MaxResults
	}

	if !dara.IsNil(request.Name) {
		query["Name"] = request.Name
	}

	if !dara.IsNil(request.NextToken) {
		query["NextToken"] = request.NextToken
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PublicIpAddressPoolIds) {
		query["PublicIpAddressPoolIds"] = request.PublicIpAddressPoolIds
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceGroupId) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.SecurityProtectionEnabled) {
		query["SecurityProtectionEnabled"] = request.SecurityProtectionEnabled
	}

	if !dara.IsNil(request.Status) {
		query["Status"] = request.Status
	}

	if !dara.IsNil(request.Tags) {
		query["Tags"] = request.Tags
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ListPublicIpAddressPools"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ListPublicIpAddressPoolsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries available IP address pools.
//
// @param request - ListPublicIpAddressPoolsRequest
//
// @return ListPublicIpAddressPoolsResponse
func (client *Client) ListPublicIpAddressPools(request *ListPublicIpAddressPoolsRequest) (_result *ListPublicIpAddressPoolsResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ListPublicIpAddressPoolsResponse{}
	_body, _err := client.ListPublicIpAddressPoolsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the tags that are added to resources.
//
// Description:
//
// ## Usage notes
//
//   - You must specify **ResourceId.N*	- or **Tag.N*	- that consists of **Tag.N.Key*	- and **Tag.N.Value*	- in the request to specify the object that you want to query.
//
//   - **Tag.N*	- is a resource tag that consists of a key-value pair. If you specify only **Tag.N.Key**, all tag values that are associated with the specified key are returned. If you specify only **Tag.N.Value**, an error message is returned.
//
//   - If you specify **Tag.N*	- and **ResourceId.N*	- to filter tags, **ResourceId.N*	- must match all specified key-value pairs.
//
//   - If you specify multiple key-value pairs, resources that contain these key-value pairs are returned.
//
// @param request - ListTagResourcesRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListTagResourcesResponse
func (client *Client) ListTagResourcesWithOptions(request *ListTagResourcesRequest, runtime *dara.RuntimeOptions) (_result *ListTagResourcesResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.MaxResults) {
		query["MaxResults"] = request.MaxResults
	}

	if !dara.IsNil(request.NextToken) {
		query["NextToken"] = request.NextToken
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceId) {
		query["ResourceId"] = request.ResourceId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.ResourceType) {
		query["ResourceType"] = request.ResourceType
	}

	if !dara.IsNil(request.Tag) {
		query["Tag"] = request.Tag
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ListTagResources"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ListTagResourcesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the tags that are added to resources.
//
// Description:
//
// ## Usage notes
//
//   - You must specify **ResourceId.N*	- or **Tag.N*	- that consists of **Tag.N.Key*	- and **Tag.N.Value*	- in the request to specify the object that you want to query.
//
//   - **Tag.N*	- is a resource tag that consists of a key-value pair. If you specify only **Tag.N.Key**, all tag values that are associated with the specified key are returned. If you specify only **Tag.N.Value**, an error message is returned.
//
//   - If you specify **Tag.N*	- and **ResourceId.N*	- to filter tags, **ResourceId.N*	- must match all specified key-value pairs.
//
//   - If you specify multiple key-value pairs, resources that contain these key-value pairs are returned.
//
// @param request - ListTagResourcesRequest
//
// @return ListTagResourcesResponse
func (client *Client) ListTagResources(request *ListTagResourcesRequest) (_result *ListTagResourcesResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ListTagResourcesResponse{}
	_body, _err := client.ListTagResourcesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the tags that are added to an Express Connect circuit.
//
// Description:
//
// ## [](#)
//
//   - If you want to query a specific object, you must specify **ResourceId.N*	- or **Tag.N*	- that consists of **Tag.N.Key*	- and **Tag.N.Value*	- in the request.
//
//   - **Tag.N*	- is a resource tag that consists of a key-value pair. If you specify only **Tag.N.Key**, all tag values that are associated with the specified key are returned. If you specify only **Tag.N.Value**, an error message is returned.
//
//   - If you specify **Tag.N*	- and **ResourceId.N*	- to filter tags, **ResourceId.N*	- must match all specified key-value pairs.
//
//   - If you specify multiple key-value pairs, resources that contain these key-value pairs are returned.
//
// @param request - ListTagResourcesForExpressConnectRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListTagResourcesForExpressConnectResponse
func (client *Client) ListTagResourcesForExpressConnectWithOptions(request *ListTagResourcesForExpressConnectRequest, runtime *dara.RuntimeOptions) (_result *ListTagResourcesForExpressConnectResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.MaxResults) {
		query["MaxResults"] = request.MaxResults
	}

	if !dara.IsNil(request.NextToken) {
		query["NextToken"] = request.NextToken
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceId) {
		query["ResourceId"] = request.ResourceId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.ResourceType) {
		query["ResourceType"] = request.ResourceType
	}

	if !dara.IsNil(request.Tag) {
		query["Tag"] = request.Tag
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ListTagResourcesForExpressConnect"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ListTagResourcesForExpressConnectResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the tags that are added to an Express Connect circuit.
//
// Description:
//
// ## [](#)
//
//   - If you want to query a specific object, you must specify **ResourceId.N*	- or **Tag.N*	- that consists of **Tag.N.Key*	- and **Tag.N.Value*	- in the request.
//
//   - **Tag.N*	- is a resource tag that consists of a key-value pair. If you specify only **Tag.N.Key**, all tag values that are associated with the specified key are returned. If you specify only **Tag.N.Value**, an error message is returned.
//
//   - If you specify **Tag.N*	- and **ResourceId.N*	- to filter tags, **ResourceId.N*	- must match all specified key-value pairs.
//
//   - If you specify multiple key-value pairs, resources that contain these key-value pairs are returned.
//
// @param request - ListTagResourcesForExpressConnectRequest
//
// @return ListTagResourcesForExpressConnectResponse
func (client *Client) ListTagResourcesForExpressConnect(request *ListTagResourcesForExpressConnectRequest) (_result *ListTagResourcesForExpressConnectResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ListTagResourcesForExpressConnectResponse{}
	_body, _err := client.ListTagResourcesForExpressConnectWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries filters for traffic mirror.
//
// @param request - ListTrafficMirrorFiltersRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListTrafficMirrorFiltersResponse
func (client *Client) ListTrafficMirrorFiltersWithOptions(request *ListTrafficMirrorFiltersRequest, runtime *dara.RuntimeOptions) (_result *ListTrafficMirrorFiltersResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.MaxResults) {
		query["MaxResults"] = request.MaxResults
	}

	if !dara.IsNil(request.NextToken) {
		query["NextToken"] = request.NextToken
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceGroupId) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.Tags) {
		query["Tags"] = request.Tags
	}

	if !dara.IsNil(request.TrafficMirrorFilterIds) {
		query["TrafficMirrorFilterIds"] = request.TrafficMirrorFilterIds
	}

	if !dara.IsNil(request.TrafficMirrorFilterName) {
		query["TrafficMirrorFilterName"] = request.TrafficMirrorFilterName
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ListTrafficMirrorFilters"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ListTrafficMirrorFiltersResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries filters for traffic mirror.
//
// @param request - ListTrafficMirrorFiltersRequest
//
// @return ListTrafficMirrorFiltersResponse
func (client *Client) ListTrafficMirrorFilters(request *ListTrafficMirrorFiltersRequest) (_result *ListTrafficMirrorFiltersResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ListTrafficMirrorFiltersResponse{}
	_body, _err := client.ListTrafficMirrorFiltersWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the details of a traffic mirror session.
//
// @param request - ListTrafficMirrorSessionsRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListTrafficMirrorSessionsResponse
func (client *Client) ListTrafficMirrorSessionsWithOptions(request *ListTrafficMirrorSessionsRequest, runtime *dara.RuntimeOptions) (_result *ListTrafficMirrorSessionsResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.Enabled) {
		query["Enabled"] = request.Enabled
	}

	if !dara.IsNil(request.MaxResults) {
		query["MaxResults"] = request.MaxResults
	}

	if !dara.IsNil(request.NextToken) {
		query["NextToken"] = request.NextToken
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.Priority) {
		query["Priority"] = request.Priority
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceGroupId) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.Tags) {
		query["Tags"] = request.Tags
	}

	if !dara.IsNil(request.TrafficMirrorFilterId) {
		query["TrafficMirrorFilterId"] = request.TrafficMirrorFilterId
	}

	if !dara.IsNil(request.TrafficMirrorSessionIds) {
		query["TrafficMirrorSessionIds"] = request.TrafficMirrorSessionIds
	}

	if !dara.IsNil(request.TrafficMirrorSessionName) {
		query["TrafficMirrorSessionName"] = request.TrafficMirrorSessionName
	}

	if !dara.IsNil(request.TrafficMirrorSourceId) {
		query["TrafficMirrorSourceId"] = request.TrafficMirrorSourceId
	}

	if !dara.IsNil(request.TrafficMirrorTargetId) {
		query["TrafficMirrorTargetId"] = request.TrafficMirrorTargetId
	}

	if !dara.IsNil(request.VirtualNetworkId) {
		query["VirtualNetworkId"] = request.VirtualNetworkId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ListTrafficMirrorSessions"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ListTrafficMirrorSessionsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the details of a traffic mirror session.
//
// @param request - ListTrafficMirrorSessionsRequest
//
// @return ListTrafficMirrorSessionsResponse
func (client *Client) ListTrafficMirrorSessions(request *ListTrafficMirrorSessionsRequest) (_result *ListTrafficMirrorSessionsResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ListTrafficMirrorSessionsResponse{}
	_body, _err := client.ListTrafficMirrorSessionsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the CIDR reservation information about vSwitches.
//
// @param request - ListVSwitchCidrReservationsRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListVSwitchCidrReservationsResponse
func (client *Client) ListVSwitchCidrReservationsWithOptions(request *ListVSwitchCidrReservationsRequest, runtime *dara.RuntimeOptions) (_result *ListVSwitchCidrReservationsResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.IpVersion) {
		query["IpVersion"] = request.IpVersion
	}

	if !dara.IsNil(request.MaxResults) {
		query["MaxResults"] = request.MaxResults
	}

	if !dara.IsNil(request.NextToken) {
		query["NextToken"] = request.NextToken
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.Tags) {
		query["Tags"] = request.Tags
	}

	if !dara.IsNil(request.VSwitchCidrReservationIds) {
		query["VSwitchCidrReservationIds"] = request.VSwitchCidrReservationIds
	}

	if !dara.IsNil(request.VSwitchCidrReservationType) {
		query["VSwitchCidrReservationType"] = request.VSwitchCidrReservationType
	}

	if !dara.IsNil(request.VSwitchId) {
		query["VSwitchId"] = request.VSwitchId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ListVSwitchCidrReservations"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ListVSwitchCidrReservationsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the CIDR reservation information about vSwitches.
//
// @param request - ListVSwitchCidrReservationsRequest
//
// @return ListVSwitchCidrReservationsResponse
func (client *Client) ListVSwitchCidrReservations(request *ListVSwitchCidrReservationsRequest) (_result *ListVSwitchCidrReservationsResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ListVSwitchCidrReservationsResponse{}
	_body, _err := client.ListVSwitchCidrReservationsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries hosted connections.
//
// @param request - ListVirtualPhysicalConnectionsRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListVirtualPhysicalConnectionsResponse
func (client *Client) ListVirtualPhysicalConnectionsWithOptions(request *ListVirtualPhysicalConnectionsRequest, runtime *dara.RuntimeOptions) (_result *ListVirtualPhysicalConnectionsResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.IsConfirmed) {
		query["IsConfirmed"] = request.IsConfirmed
	}

	if !dara.IsNil(request.MaxResults) {
		query["MaxResults"] = request.MaxResults
	}

	if !dara.IsNil(request.NextToken) {
		query["NextToken"] = request.NextToken
	}

	if !dara.IsNil(request.PhysicalConnectionId) {
		query["PhysicalConnectionId"] = request.PhysicalConnectionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceGroupId) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !dara.IsNil(request.Tags) {
		query["Tags"] = request.Tags
	}

	if !dara.IsNil(request.VirtualPhysicalConnectionAliUids) {
		query["VirtualPhysicalConnectionAliUids"] = request.VirtualPhysicalConnectionAliUids
	}

	if !dara.IsNil(request.VirtualPhysicalConnectionBusinessStatus) {
		query["VirtualPhysicalConnectionBusinessStatus"] = request.VirtualPhysicalConnectionBusinessStatus
	}

	if !dara.IsNil(request.VirtualPhysicalConnectionIds) {
		query["VirtualPhysicalConnectionIds"] = request.VirtualPhysicalConnectionIds
	}

	if !dara.IsNil(request.VirtualPhysicalConnectionStatuses) {
		query["VirtualPhysicalConnectionStatuses"] = request.VirtualPhysicalConnectionStatuses
	}

	if !dara.IsNil(request.VlanIds) {
		query["VlanIds"] = request.VlanIds
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ListVirtualPhysicalConnections"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ListVirtualPhysicalConnectionsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries hosted connections.
//
// @param request - ListVirtualPhysicalConnectionsRequest
//
// @return ListVirtualPhysicalConnectionsResponse
func (client *Client) ListVirtualPhysicalConnections(request *ListVirtualPhysicalConnectionsRequest) (_result *ListVirtualPhysicalConnectionsResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ListVirtualPhysicalConnectionsResponse{}
	_body, _err := client.ListVirtualPhysicalConnectionsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries available endpoint services.
//
// @param request - ListVpcEndpointServicesByEndUserRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListVpcEndpointServicesByEndUserResponse
func (client *Client) ListVpcEndpointServicesByEndUserWithOptions(request *ListVpcEndpointServicesByEndUserRequest, runtime *dara.RuntimeOptions) (_result *ListVpcEndpointServicesByEndUserResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.MaxResults) {
		query["MaxResults"] = request.MaxResults
	}

	if !dara.IsNil(request.NextToken) {
		query["NextToken"] = request.NextToken
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.ServiceName) {
		query["ServiceName"] = request.ServiceName
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ListVpcEndpointServicesByEndUser"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ListVpcEndpointServicesByEndUserResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries available endpoint services.
//
// @param request - ListVpcEndpointServicesByEndUserRequest
//
// @return ListVpcEndpointServicesByEndUserResponse
func (client *Client) ListVpcEndpointServicesByEndUser(request *ListVpcEndpointServicesByEndUserRequest) (_result *ListVpcEndpointServicesByEndUserResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ListVpcEndpointServicesByEndUserResponse{}
	_body, _err := client.ListVpcEndpointServicesByEndUserWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries gateway endpoints.
//
// @param request - ListVpcGatewayEndpointsRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListVpcGatewayEndpointsResponse
func (client *Client) ListVpcGatewayEndpointsWithOptions(request *ListVpcGatewayEndpointsRequest, runtime *dara.RuntimeOptions) (_result *ListVpcGatewayEndpointsResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.EndpointId) {
		query["EndpointId"] = request.EndpointId
	}

	if !dara.IsNil(request.EndpointName) {
		query["EndpointName"] = request.EndpointName
	}

	if !dara.IsNil(request.MaxResults) {
		query["MaxResults"] = request.MaxResults
	}

	if !dara.IsNil(request.NextToken) {
		query["NextToken"] = request.NextToken
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceGroupId) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.ServiceName) {
		query["ServiceName"] = request.ServiceName
	}

	if !dara.IsNil(request.Tags) {
		query["Tags"] = request.Tags
	}

	if !dara.IsNil(request.VpcId) {
		query["VpcId"] = request.VpcId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ListVpcGatewayEndpoints"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ListVpcGatewayEndpointsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries gateway endpoints.
//
// @param request - ListVpcGatewayEndpointsRequest
//
// @return ListVpcGatewayEndpointsResponse
func (client *Client) ListVpcGatewayEndpoints(request *ListVpcGatewayEndpointsRequest) (_result *ListVpcGatewayEndpointsResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ListVpcGatewayEndpointsResponse{}
	_body, _err := client.ListVpcGatewayEndpointsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries advertised routes.
//
// @param request - ListVpcPublishedRouteEntriesRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListVpcPublishedRouteEntriesResponse
func (client *Client) ListVpcPublishedRouteEntriesWithOptions(request *ListVpcPublishedRouteEntriesRequest, runtime *dara.RuntimeOptions) (_result *ListVpcPublishedRouteEntriesResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.DestinationCidrBlock) {
		query["DestinationCidrBlock"] = request.DestinationCidrBlock
	}

	if !dara.IsNil(request.MaxResults) {
		query["MaxResults"] = request.MaxResults
	}

	if !dara.IsNil(request.NextToken) {
		query["NextToken"] = request.NextToken
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.RouteTableId) {
		query["RouteTableId"] = request.RouteTableId
	}

	if !dara.IsNil(request.TargetInstanceId) {
		query["TargetInstanceId"] = request.TargetInstanceId
	}

	if !dara.IsNil(request.TargetType) {
		query["TargetType"] = request.TargetType
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ListVpcPublishedRouteEntries"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ListVpcPublishedRouteEntriesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries advertised routes.
//
// @param request - ListVpcPublishedRouteEntriesRequest
//
// @return ListVpcPublishedRouteEntriesResponse
func (client *Client) ListVpcPublishedRouteEntries(request *ListVpcPublishedRouteEntriesRequest) (_result *ListVpcPublishedRouteEntriesResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ListVpcPublishedRouteEntriesResponse{}
	_body, _err := client.ListVpcPublishedRouteEntriesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the association between VPN gateways and certificates in a region.
//
// Description:
//
// When you call **ListVpnCertificateAssociations**, take note of the following information:
//
//   - If you specify only **RegionId**, the SSL certificates associated with all VPN gateways in the specified region are queried.
//
//   - If you specify **RegionId*	- and **CertificateType**, the SSL certificates of the specified type that are associated with the VPN gateways in the specified region are queried.
//
//   - If you specify **RegionId*	- and **VpnGatewayId**, the SSL certificates associated with the specified VPN gateway in the specified region are queried.
//
//   - If you specify **RegionId*	- and **CertificateId**, the VPN gateways associated with the specified SSL certificate in the specified region are queried.
//
// @param request - ListVpnCertificateAssociationsRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListVpnCertificateAssociationsResponse
func (client *Client) ListVpnCertificateAssociationsWithOptions(request *ListVpnCertificateAssociationsRequest, runtime *dara.RuntimeOptions) (_result *ListVpnCertificateAssociationsResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.CertificateId) {
		query["CertificateId"] = request.CertificateId
	}

	if !dara.IsNil(request.CertificateType) {
		query["CertificateType"] = request.CertificateType
	}

	if !dara.IsNil(request.MaxResults) {
		query["MaxResults"] = request.MaxResults
	}

	if !dara.IsNil(request.NextToken) {
		query["NextToken"] = request.NextToken
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.VpnGatewayId) {
		query["VpnGatewayId"] = request.VpnGatewayId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ListVpnCertificateAssociations"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ListVpnCertificateAssociationsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the association between VPN gateways and certificates in a region.
//
// Description:
//
// When you call **ListVpnCertificateAssociations**, take note of the following information:
//
//   - If you specify only **RegionId**, the SSL certificates associated with all VPN gateways in the specified region are queried.
//
//   - If you specify **RegionId*	- and **CertificateType**, the SSL certificates of the specified type that are associated with the VPN gateways in the specified region are queried.
//
//   - If you specify **RegionId*	- and **VpnGatewayId**, the SSL certificates associated with the specified VPN gateway in the specified region are queried.
//
//   - If you specify **RegionId*	- and **CertificateId**, the VPN gateways associated with the specified SSL certificate in the specified region are queried.
//
// @param request - ListVpnCertificateAssociationsRequest
//
// @return ListVpnCertificateAssociationsResponse
func (client *Client) ListVpnCertificateAssociations(request *ListVpnCertificateAssociationsRequest) (_result *ListVpnCertificateAssociationsResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ListVpnCertificateAssociationsResponse{}
	_body, _err := client.ListVpnCertificateAssociationsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Modifies the configuration of a Border Gateway Protocol (BGP) group.
//
// @param request - ModifyBgpGroupAttributeRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ModifyBgpGroupAttributeResponse
func (client *Client) ModifyBgpGroupAttributeWithOptions(request *ModifyBgpGroupAttributeRequest, runtime *dara.RuntimeOptions) (_result *ModifyBgpGroupAttributeResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.AuthKey) {
		query["AuthKey"] = request.AuthKey
	}

	if !dara.IsNil(request.BgpGroupId) {
		query["BgpGroupId"] = request.BgpGroupId
	}

	if !dara.IsNil(request.ClearAuthKey) {
		query["ClearAuthKey"] = request.ClearAuthKey
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.Description) {
		query["Description"] = request.Description
	}

	if !dara.IsNil(request.IsFakeAsn) {
		query["IsFakeAsn"] = request.IsFakeAsn
	}

	if !dara.IsNil(request.LocalAsn) {
		query["LocalAsn"] = request.LocalAsn
	}

	if !dara.IsNil(request.Name) {
		query["Name"] = request.Name
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PeerAsn) {
		query["PeerAsn"] = request.PeerAsn
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.RouteQuota) {
		query["RouteQuota"] = request.RouteQuota
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ModifyBgpGroupAttribute"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ModifyBgpGroupAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Modifies the configuration of a Border Gateway Protocol (BGP) group.
//
// @param request - ModifyBgpGroupAttributeRequest
//
// @return ModifyBgpGroupAttributeResponse
func (client *Client) ModifyBgpGroupAttribute(request *ModifyBgpGroupAttributeRequest) (_result *ModifyBgpGroupAttributeResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ModifyBgpGroupAttributeResponse{}
	_body, _err := client.ModifyBgpGroupAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Modifies the configuration of a BGP peer.
//
// @param request - ModifyBgpPeerAttributeRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ModifyBgpPeerAttributeResponse
func (client *Client) ModifyBgpPeerAttributeWithOptions(request *ModifyBgpPeerAttributeRequest, runtime *dara.RuntimeOptions) (_result *ModifyBgpPeerAttributeResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.BfdMultiHop) {
		query["BfdMultiHop"] = request.BfdMultiHop
	}

	if !dara.IsNil(request.BgpGroupId) {
		query["BgpGroupId"] = request.BgpGroupId
	}

	if !dara.IsNil(request.BgpPeerId) {
		query["BgpPeerId"] = request.BgpPeerId
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.EnableBfd) {
		query["EnableBfd"] = request.EnableBfd
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PeerIpAddress) {
		query["PeerIpAddress"] = request.PeerIpAddress
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ModifyBgpPeerAttribute"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ModifyBgpPeerAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Modifies the configuration of a BGP peer.
//
// @param request - ModifyBgpPeerAttributeRequest
//
// @return ModifyBgpPeerAttributeResponse
func (client *Client) ModifyBgpPeerAttribute(request *ModifyBgpPeerAttributeRequest) (_result *ModifyBgpPeerAttributeResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ModifyBgpPeerAttributeResponse{}
	_body, _err := client.ModifyBgpPeerAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Modifies the name and description of an EIP bandwidth plan.
//
// @param request - ModifyCommonBandwidthPackageAttributeRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ModifyCommonBandwidthPackageAttributeResponse
func (client *Client) ModifyCommonBandwidthPackageAttributeWithOptions(request *ModifyCommonBandwidthPackageAttributeRequest, runtime *dara.RuntimeOptions) (_result *ModifyCommonBandwidthPackageAttributeResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.BandwidthPackageId) {
		query["BandwidthPackageId"] = request.BandwidthPackageId
	}

	if !dara.IsNil(request.Description) {
		query["Description"] = request.Description
	}

	if !dara.IsNil(request.Name) {
		query["Name"] = request.Name
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ModifyCommonBandwidthPackageAttribute"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ModifyCommonBandwidthPackageAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Modifies the name and description of an EIP bandwidth plan.
//
// @param request - ModifyCommonBandwidthPackageAttributeRequest
//
// @return ModifyCommonBandwidthPackageAttributeResponse
func (client *Client) ModifyCommonBandwidthPackageAttribute(request *ModifyCommonBandwidthPackageAttributeRequest) (_result *ModifyCommonBandwidthPackageAttributeResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ModifyCommonBandwidthPackageAttributeResponse{}
	_body, _err := client.ModifyCommonBandwidthPackageAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Sets the maximum bandwidth of an EIP that is associated with an Internet Shared Bandwidth instance.
//
// Description:
//
// You can call the **ModifyCommonBandwidthPackageIpBandwidth*	- operation to set the maximum bandwidth of an EIP that is associated with an Internet Shared Bandwidth instance. This prevents an EIP from exhausting the bandwidth resources of an Internet Shared Bandwidth instance.
//
// For example, two EIPs are associated with an Internet Shared Bandwidth instance whose maximum bandwidth is 800 Mbit/s. In this case, you can set the maximum bandwidth of one EIP to 500 Mbit/s and that of the other EIP to 400 Mbit/s. After you set the maximum bandwidth values, the first EIP cannot consume bandwidth higher than 500 Mbit/s. The second EIP cannot consume bandwidth higher than 400 Mbit/s.
//
// When you call this operation, take note of the following items:
//
//   - This operation is valid only for EIPs that are associated with Elastic Compute Service (ECS) instances. This operation is invalid for EIPs that are associated with Server Load Balancer (SLB) instances, NAT gateways, secondary elastic network interfaces (ENIs), or high-availability virtual IP addresses (HAVIPs).
//
//   - This operation is in public preview. You can call this operation to set the maximum bandwidth of EIPs only if the EIPs are associated with an Internet Shared Bandwidth instance. The feature is not supported in the console.
//
//   - You cannot repeatedly call this operation to set the maximum bandwidth of an EIP within the specified period of time.
//
// @param request - ModifyCommonBandwidthPackageIpBandwidthRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ModifyCommonBandwidthPackageIpBandwidthResponse
func (client *Client) ModifyCommonBandwidthPackageIpBandwidthWithOptions(request *ModifyCommonBandwidthPackageIpBandwidthRequest, runtime *dara.RuntimeOptions) (_result *ModifyCommonBandwidthPackageIpBandwidthResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.Bandwidth) {
		query["Bandwidth"] = request.Bandwidth
	}

	if !dara.IsNil(request.BandwidthPackageId) {
		query["BandwidthPackageId"] = request.BandwidthPackageId
	}

	if !dara.IsNil(request.EipId) {
		query["EipId"] = request.EipId
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ModifyCommonBandwidthPackageIpBandwidth"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ModifyCommonBandwidthPackageIpBandwidthResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Sets the maximum bandwidth of an EIP that is associated with an Internet Shared Bandwidth instance.
//
// Description:
//
// You can call the **ModifyCommonBandwidthPackageIpBandwidth*	- operation to set the maximum bandwidth of an EIP that is associated with an Internet Shared Bandwidth instance. This prevents an EIP from exhausting the bandwidth resources of an Internet Shared Bandwidth instance.
//
// For example, two EIPs are associated with an Internet Shared Bandwidth instance whose maximum bandwidth is 800 Mbit/s. In this case, you can set the maximum bandwidth of one EIP to 500 Mbit/s and that of the other EIP to 400 Mbit/s. After you set the maximum bandwidth values, the first EIP cannot consume bandwidth higher than 500 Mbit/s. The second EIP cannot consume bandwidth higher than 400 Mbit/s.
//
// When you call this operation, take note of the following items:
//
//   - This operation is valid only for EIPs that are associated with Elastic Compute Service (ECS) instances. This operation is invalid for EIPs that are associated with Server Load Balancer (SLB) instances, NAT gateways, secondary elastic network interfaces (ENIs), or high-availability virtual IP addresses (HAVIPs).
//
//   - This operation is in public preview. You can call this operation to set the maximum bandwidth of EIPs only if the EIPs are associated with an Internet Shared Bandwidth instance. The feature is not supported in the console.
//
//   - You cannot repeatedly call this operation to set the maximum bandwidth of an EIP within the specified period of time.
//
// @param request - ModifyCommonBandwidthPackageIpBandwidthRequest
//
// @return ModifyCommonBandwidthPackageIpBandwidthResponse
func (client *Client) ModifyCommonBandwidthPackageIpBandwidth(request *ModifyCommonBandwidthPackageIpBandwidthRequest) (_result *ModifyCommonBandwidthPackageIpBandwidthResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ModifyCommonBandwidthPackageIpBandwidthResponse{}
	_body, _err := client.ModifyCommonBandwidthPackageIpBandwidthWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Modifies the maximum bandwidth of an Internet Shared Bandwidth instance.
//
// Description:
//
// Before you call this operation, take note of the following items:
//
//   - **ModifyCommonBandwidthPackageSpec*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeCommonBandwidthPackages](https://help.aliyun.com/document_detail/120309.html) operation to query the status of the task.
//
//   - If the Internet Shared Bandwidth instance is in the **Modifying*	- state, the maximum bandwidth of the Internet Shared Bandwidth instance is being modified. In this state, you can only query the Internet Shared Bandwidth instance and cannot perform other operations.
//
//   - If the Internet Shared Bandwidth instance is in the **Available*	- state, the maximum bandwidth of the Internet Shared Bandwidth instance is modified.
//
//   - You cannot repeatedly call the **ModifyCommonBandwidthPackageSpec*	- operation to modify the maximum bandwidth of an Internet Shared Bandwidth instance within the specified period of time.
//
// @param request - ModifyCommonBandwidthPackageSpecRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ModifyCommonBandwidthPackageSpecResponse
func (client *Client) ModifyCommonBandwidthPackageSpecWithOptions(request *ModifyCommonBandwidthPackageSpecRequest, runtime *dara.RuntimeOptions) (_result *ModifyCommonBandwidthPackageSpecResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.Bandwidth) {
		query["Bandwidth"] = request.Bandwidth
	}

	if !dara.IsNil(request.BandwidthPackageId) {
		query["BandwidthPackageId"] = request.BandwidthPackageId
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ModifyCommonBandwidthPackageSpec"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ModifyCommonBandwidthPackageSpecResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Modifies the maximum bandwidth of an Internet Shared Bandwidth instance.
//
// Description:
//
// Before you call this operation, take note of the following items:
//
//   - **ModifyCommonBandwidthPackageSpec*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeCommonBandwidthPackages](https://help.aliyun.com/document_detail/120309.html) operation to query the status of the task.
//
//   - If the Internet Shared Bandwidth instance is in the **Modifying*	- state, the maximum bandwidth of the Internet Shared Bandwidth instance is being modified. In this state, you can only query the Internet Shared Bandwidth instance and cannot perform other operations.
//
//   - If the Internet Shared Bandwidth instance is in the **Available*	- state, the maximum bandwidth of the Internet Shared Bandwidth instance is modified.
//
//   - You cannot repeatedly call the **ModifyCommonBandwidthPackageSpec*	- operation to modify the maximum bandwidth of an Internet Shared Bandwidth instance within the specified period of time.
//
// @param request - ModifyCommonBandwidthPackageSpecRequest
//
// @return ModifyCommonBandwidthPackageSpecResponse
func (client *Client) ModifyCommonBandwidthPackageSpec(request *ModifyCommonBandwidthPackageSpecRequest) (_result *ModifyCommonBandwidthPackageSpecResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ModifyCommonBandwidthPackageSpecResponse{}
	_body, _err := client.ModifyCommonBandwidthPackageSpecWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Modifies the configuration of a customer gateway.
//
// Description:
//
//	  When you call **ModifyCustomerGatewayAttribute**, if a value is assigned to **AuthKey**, the operation is asynchronous. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
//
//	    	- If a VPN gateway is in the **updating*	- state, the configurations are being modified.
//
//	    	- If a VPN gateway is in the **active*	- state, the configurations are modified.
//
//		- When you call **ModifyCustomerGatewayAttribute**, if no value is assigned to **AuthKey**, the operation is synchronous.
//
//		- You cannot repeatedly call **ModifyCustomerGatewayAttribute*	- to modify the configurations of a customer gateway within the specified period of time.
//
// @param request - ModifyCustomerGatewayAttributeRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ModifyCustomerGatewayAttributeResponse
func (client *Client) ModifyCustomerGatewayAttributeWithOptions(request *ModifyCustomerGatewayAttributeRequest, runtime *dara.RuntimeOptions) (_result *ModifyCustomerGatewayAttributeResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.AuthKey) {
		query["AuthKey"] = request.AuthKey
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.CustomerGatewayId) {
		query["CustomerGatewayId"] = request.CustomerGatewayId
	}

	if !dara.IsNil(request.Description) {
		query["Description"] = request.Description
	}

	if !dara.IsNil(request.Name) {
		query["Name"] = request.Name
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ModifyCustomerGatewayAttribute"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ModifyCustomerGatewayAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Modifies the configuration of a customer gateway.
//
// Description:
//
//	  When you call **ModifyCustomerGatewayAttribute**, if a value is assigned to **AuthKey**, the operation is asynchronous. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
//
//	    	- If a VPN gateway is in the **updating*	- state, the configurations are being modified.
//
//	    	- If a VPN gateway is in the **active*	- state, the configurations are modified.
//
//		- When you call **ModifyCustomerGatewayAttribute**, if no value is assigned to **AuthKey**, the operation is synchronous.
//
//		- You cannot repeatedly call **ModifyCustomerGatewayAttribute*	- to modify the configurations of a customer gateway within the specified period of time.
//
// @param request - ModifyCustomerGatewayAttributeRequest
//
// @return ModifyCustomerGatewayAttributeResponse
func (client *Client) ModifyCustomerGatewayAttribute(request *ModifyCustomerGatewayAttributeRequest) (_result *ModifyCustomerGatewayAttributeResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ModifyCustomerGatewayAttributeResponse{}
	_body, _err := client.ModifyCustomerGatewayAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Modifies the name, description, and maximum bandwidth of an elastic IP address (EIP).
//
// @param request - ModifyEipAddressAttributeRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ModifyEipAddressAttributeResponse
func (client *Client) ModifyEipAddressAttributeWithOptions(request *ModifyEipAddressAttributeRequest, runtime *dara.RuntimeOptions) (_result *ModifyEipAddressAttributeResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.AllocationId) {
		query["AllocationId"] = request.AllocationId
	}

	if !dara.IsNil(request.Bandwidth) {
		query["Bandwidth"] = request.Bandwidth
	}

	if !dara.IsNil(request.Description) {
		query["Description"] = request.Description
	}

	if !dara.IsNil(request.Name) {
		query["Name"] = request.Name
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ModifyEipAddressAttribute"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ModifyEipAddressAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Modifies the name, description, and maximum bandwidth of an elastic IP address (EIP).
//
// @param request - ModifyEipAddressAttributeRequest
//
// @return ModifyEipAddressAttributeResponse
func (client *Client) ModifyEipAddressAttribute(request *ModifyEipAddressAttributeRequest) (_result *ModifyEipAddressAttributeResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ModifyEipAddressAttributeResponse{}
	_body, _err := client.ModifyEipAddressAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Modifies the EIP forwarding mode.
//
// @param request - ModifyEipForwardModeRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ModifyEipForwardModeResponse
func (client *Client) ModifyEipForwardModeWithOptions(request *ModifyEipForwardModeRequest, runtime *dara.RuntimeOptions) (_result *ModifyEipForwardModeResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.InstanceId) {
		query["InstanceId"] = request.InstanceId
	}

	if !dara.IsNil(request.Mode) {
		query["Mode"] = request.Mode
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ModifyEipForwardMode"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ModifyEipForwardModeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Modifies the EIP forwarding mode.
//
// @param request - ModifyEipForwardModeRequest
//
// @return ModifyEipForwardModeResponse
func (client *Client) ModifyEipForwardMode(request *ModifyEipForwardModeRequest) (_result *ModifyEipForwardModeResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ModifyEipForwardModeResponse{}
	_body, _err := client.ModifyEipForwardModeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Modifies the configuration of an Express Cloud Connect (ECC) instance.
//
// @param request - ModifyExpressCloudConnectionAttributeRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ModifyExpressCloudConnectionAttributeResponse
func (client *Client) ModifyExpressCloudConnectionAttributeWithOptions(request *ModifyExpressCloudConnectionAttributeRequest, runtime *dara.RuntimeOptions) (_result *ModifyExpressCloudConnectionAttributeResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.BgpAs) {
		query["BgpAs"] = request.BgpAs
	}

	if !dara.IsNil(request.CeIp) {
		query["CeIp"] = request.CeIp
	}

	if !dara.IsNil(request.Description) {
		query["Description"] = request.Description
	}

	if !dara.IsNil(request.EccId) {
		query["EccId"] = request.EccId
	}

	if !dara.IsNil(request.Name) {
		query["Name"] = request.Name
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PeIp) {
		query["PeIp"] = request.PeIp
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ModifyExpressCloudConnectionAttribute"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ModifyExpressCloudConnectionAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Modifies the configuration of an Express Cloud Connect (ECC) instance.
//
// @param request - ModifyExpressCloudConnectionAttributeRequest
//
// @return ModifyExpressCloudConnectionAttributeResponse
func (client *Client) ModifyExpressCloudConnectionAttribute(request *ModifyExpressCloudConnectionAttributeRequest) (_result *ModifyExpressCloudConnectionAttributeResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ModifyExpressCloudConnectionAttributeResponse{}
	_body, _err := client.ModifyExpressCloudConnectionAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Modifies the bandwidth of an Express Cloud Connect (ECC) instance.
//
// @param request - ModifyExpressCloudConnectionBandwidthRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ModifyExpressCloudConnectionBandwidthResponse
func (client *Client) ModifyExpressCloudConnectionBandwidthWithOptions(request *ModifyExpressCloudConnectionBandwidthRequest, runtime *dara.RuntimeOptions) (_result *ModifyExpressCloudConnectionBandwidthResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.Bandwidth) {
		query["Bandwidth"] = request.Bandwidth
	}

	if !dara.IsNil(request.EccId) {
		query["EccId"] = request.EccId
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ModifyExpressCloudConnectionBandwidth"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ModifyExpressCloudConnectionBandwidthResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Modifies the bandwidth of an Express Cloud Connect (ECC) instance.
//
// @param request - ModifyExpressCloudConnectionBandwidthRequest
//
// @return ModifyExpressCloudConnectionBandwidthResponse
func (client *Client) ModifyExpressCloudConnectionBandwidth(request *ModifyExpressCloudConnectionBandwidthRequest) (_result *ModifyExpressCloudConnectionBandwidthResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ModifyExpressCloudConnectionBandwidthResponse{}
	_body, _err := client.ModifyExpressCloudConnectionBandwidthWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Modifies a quality of service (QoS) policy or associates a QoS policy with a dedicated Express Connect circuit.
//
// @param request - ModifyExpressConnectTrafficQosRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ModifyExpressConnectTrafficQosResponse
func (client *Client) ModifyExpressConnectTrafficQosWithOptions(request *ModifyExpressConnectTrafficQosRequest, runtime *dara.RuntimeOptions) (_result *ModifyExpressConnectTrafficQosResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.AddInstanceList) {
		query["AddInstanceList"] = request.AddInstanceList
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.QosDescription) {
		query["QosDescription"] = request.QosDescription
	}

	if !dara.IsNil(request.QosId) {
		query["QosId"] = request.QosId
	}

	if !dara.IsNil(request.QosName) {
		query["QosName"] = request.QosName
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.RemoveInstanceList) {
		query["RemoveInstanceList"] = request.RemoveInstanceList
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ModifyExpressConnectTrafficQos"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ModifyExpressConnectTrafficQosResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Modifies a quality of service (QoS) policy or associates a QoS policy with a dedicated Express Connect circuit.
//
// @param request - ModifyExpressConnectTrafficQosRequest
//
// @return ModifyExpressConnectTrafficQosResponse
func (client *Client) ModifyExpressConnectTrafficQos(request *ModifyExpressConnectTrafficQosRequest) (_result *ModifyExpressConnectTrafficQosResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ModifyExpressConnectTrafficQosResponse{}
	_body, _err := client.ModifyExpressConnectTrafficQosWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Modifies a quality of service (QoS) queue.
//
// @param request - ModifyExpressConnectTrafficQosQueueRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ModifyExpressConnectTrafficQosQueueResponse
func (client *Client) ModifyExpressConnectTrafficQosQueueWithOptions(request *ModifyExpressConnectTrafficQosQueueRequest, runtime *dara.RuntimeOptions) (_result *ModifyExpressConnectTrafficQosQueueResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.BandwidthPercent) {
		query["BandwidthPercent"] = request.BandwidthPercent
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.QosId) {
		query["QosId"] = request.QosId
	}

	if !dara.IsNil(request.QueueDescription) {
		query["QueueDescription"] = request.QueueDescription
	}

	if !dara.IsNil(request.QueueId) {
		query["QueueId"] = request.QueueId
	}

	if !dara.IsNil(request.QueueName) {
		query["QueueName"] = request.QueueName
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ModifyExpressConnectTrafficQosQueue"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ModifyExpressConnectTrafficQosQueueResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Modifies a quality of service (QoS) queue.
//
// @param request - ModifyExpressConnectTrafficQosQueueRequest
//
// @return ModifyExpressConnectTrafficQosQueueResponse
func (client *Client) ModifyExpressConnectTrafficQosQueue(request *ModifyExpressConnectTrafficQosQueueRequest) (_result *ModifyExpressConnectTrafficQosQueueResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ModifyExpressConnectTrafficQosQueueResponse{}
	_body, _err := client.ModifyExpressConnectTrafficQosQueueWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Modifies a quality of service (QoS) rule.
//
// @param request - ModifyExpressConnectTrafficQosRuleRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ModifyExpressConnectTrafficQosRuleResponse
func (client *Client) ModifyExpressConnectTrafficQosRuleWithOptions(request *ModifyExpressConnectTrafficQosRuleRequest, runtime *dara.RuntimeOptions) (_result *ModifyExpressConnectTrafficQosRuleResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DstCidr) {
		query["DstCidr"] = request.DstCidr
	}

	if !dara.IsNil(request.DstIPv6Cidr) {
		query["DstIPv6Cidr"] = request.DstIPv6Cidr
	}

	if !dara.IsNil(request.DstPortRange) {
		query["DstPortRange"] = request.DstPortRange
	}

	if !dara.IsNil(request.MatchDscp) {
		query["MatchDscp"] = request.MatchDscp
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.Priority) {
		query["Priority"] = request.Priority
	}

	if !dara.IsNil(request.Protocol) {
		query["Protocol"] = request.Protocol
	}

	if !dara.IsNil(request.QosId) {
		query["QosId"] = request.QosId
	}

	if !dara.IsNil(request.QueueId) {
		query["QueueId"] = request.QueueId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.RemarkingDscp) {
		query["RemarkingDscp"] = request.RemarkingDscp
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.RuleDescription) {
		query["RuleDescription"] = request.RuleDescription
	}

	if !dara.IsNil(request.RuleId) {
		query["RuleId"] = request.RuleId
	}

	if !dara.IsNil(request.RuleName) {
		query["RuleName"] = request.RuleName
	}

	if !dara.IsNil(request.SrcCidr) {
		query["SrcCidr"] = request.SrcCidr
	}

	if !dara.IsNil(request.SrcIPv6Cidr) {
		query["SrcIPv6Cidr"] = request.SrcIPv6Cidr
	}

	if !dara.IsNil(request.SrcPortRange) {
		query["SrcPortRange"] = request.SrcPortRange
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ModifyExpressConnectTrafficQosRule"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ModifyExpressConnectTrafficQosRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Modifies a quality of service (QoS) rule.
//
// @param request - ModifyExpressConnectTrafficQosRuleRequest
//
// @return ModifyExpressConnectTrafficQosRuleResponse
func (client *Client) ModifyExpressConnectTrafficQosRule(request *ModifyExpressConnectTrafficQosRuleRequest) (_result *ModifyExpressConnectTrafficQosRuleResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ModifyExpressConnectTrafficQosRuleResponse{}
	_body, _err := client.ModifyExpressConnectTrafficQosRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Modifies the name and description of a flow log.
//
// Description:
//
//	  **ModifyFlowLogAttribute*	- is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeFlowLogs](https://help.aliyun.com/document_detail/87923.html) operation to query the status of a flow log:
//
//	    	- If the flow log is in the **Modifying*	- state, the flow log is being modified.
//
//	    	- If the flow log is in the **Active*	- or **Inactive*	- state, the flow log is modified.
//
//		- You cannot repeatedly call the **ModifyFlowLogAttribute*	- operation to modify a flow log within the specified period of time.
//
// @param request - ModifyFlowLogAttributeRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ModifyFlowLogAttributeResponse
func (client *Client) ModifyFlowLogAttributeWithOptions(request *ModifyFlowLogAttributeRequest, runtime *dara.RuntimeOptions) (_result *ModifyFlowLogAttributeResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.AggregationInterval) {
		query["AggregationInterval"] = request.AggregationInterval
	}

	if !dara.IsNil(request.Description) {
		query["Description"] = request.Description
	}

	if !dara.IsNil(request.FlowLogId) {
		query["FlowLogId"] = request.FlowLogId
	}

	if !dara.IsNil(request.FlowLogName) {
		query["FlowLogName"] = request.FlowLogName
	}

	if !dara.IsNil(request.IpVersion) {
		query["IpVersion"] = request.IpVersion
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ModifyFlowLogAttribute"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ModifyFlowLogAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Modifies the name and description of a flow log.
//
// Description:
//
//	  **ModifyFlowLogAttribute*	- is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeFlowLogs](https://help.aliyun.com/document_detail/87923.html) operation to query the status of a flow log:
//
//	    	- If the flow log is in the **Modifying*	- state, the flow log is being modified.
//
//	    	- If the flow log is in the **Active*	- or **Inactive*	- state, the flow log is modified.
//
//		- You cannot repeatedly call the **ModifyFlowLogAttribute*	- operation to modify a flow log within the specified period of time.
//
// @param request - ModifyFlowLogAttributeRequest
//
// @return ModifyFlowLogAttributeResponse
func (client *Client) ModifyFlowLogAttribute(request *ModifyFlowLogAttributeRequest) (_result *ModifyFlowLogAttributeResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ModifyFlowLogAttributeResponse{}
	_body, _err := client.ModifyFlowLogAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Modifies a DNAT entry.
//
// Description:
//
//	  **ModifyForwardEntry*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeForwardTableEntries](https://help.aliyun.com/document_detail/36053.html) operation to query the status of the task.
//
//	    	- **Pending**: indicates that the system is modifying the DNAT entry. You can only query the DNAT entry, but cannot perform other operations.
//
//	    	- **Available**: indicates that the DNAT entry is modified.
//
//		- You cannot repeatedly call the **ModifyForwardEntry*	- operation to modify a DNAT entry within the specified period of time.
//
// @param request - ModifyForwardEntryRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ModifyForwardEntryResponse
func (client *Client) ModifyForwardEntryWithOptions(request *ModifyForwardEntryRequest, runtime *dara.RuntimeOptions) (_result *ModifyForwardEntryResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.ExternalIp) {
		query["ExternalIp"] = request.ExternalIp
	}

	if !dara.IsNil(request.ExternalPort) {
		query["ExternalPort"] = request.ExternalPort
	}

	if !dara.IsNil(request.ForwardEntryId) {
		query["ForwardEntryId"] = request.ForwardEntryId
	}

	if !dara.IsNil(request.ForwardEntryName) {
		query["ForwardEntryName"] = request.ForwardEntryName
	}

	if !dara.IsNil(request.ForwardTableId) {
		query["ForwardTableId"] = request.ForwardTableId
	}

	if !dara.IsNil(request.InternalIp) {
		query["InternalIp"] = request.InternalIp
	}

	if !dara.IsNil(request.InternalPort) {
		query["InternalPort"] = request.InternalPort
	}

	if !dara.IsNil(request.IpProtocol) {
		query["IpProtocol"] = request.IpProtocol
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PortBreak) {
		query["PortBreak"] = request.PortBreak
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ModifyForwardEntry"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ModifyForwardEntryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Modifies a DNAT entry.
//
// Description:
//
//	  **ModifyForwardEntry*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeForwardTableEntries](https://help.aliyun.com/document_detail/36053.html) operation to query the status of the task.
//
//	    	- **Pending**: indicates that the system is modifying the DNAT entry. You can only query the DNAT entry, but cannot perform other operations.
//
//	    	- **Available**: indicates that the DNAT entry is modified.
//
//		- You cannot repeatedly call the **ModifyForwardEntry*	- operation to modify a DNAT entry within the specified period of time.
//
// @param request - ModifyForwardEntryRequest
//
// @return ModifyForwardEntryResponse
func (client *Client) ModifyForwardEntry(request *ModifyForwardEntryRequest) (_result *ModifyForwardEntryResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ModifyForwardEntryResponse{}
	_body, _err := client.ModifyForwardEntryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Modifies a FULLNAT entry.
//
// Description:
//
// ## [](#)
//
//   - **ModifyFullNatEntryAttribute*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListFullNatEntries](https://help.aliyun.com/document_detail/348779.html) operation to query the status of a FULLNAT entry.
//
//   - **Modifying**: indicates that the system is modifying the FULLNAT entry. You can query the FULLNAT entry, but cannot perform other operations.
//
//   - **Available**: indicates that the FULLNAT entry is modified.
//
//   - You cannot repeatedly call the **ModifyFullNatEntryAttribute*	- operation to modify a FULLNAT entry within the specified period of time.
//
// @param request - ModifyFullNatEntryAttributeRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ModifyFullNatEntryAttributeResponse
func (client *Client) ModifyFullNatEntryAttributeWithOptions(request *ModifyFullNatEntryAttributeRequest, runtime *dara.RuntimeOptions) (_result *ModifyFullNatEntryAttributeResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.AccessIp) {
		query["AccessIp"] = request.AccessIp
	}

	if !dara.IsNil(request.AccessPort) {
		query["AccessPort"] = request.AccessPort
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.FullNatEntryDescription) {
		query["FullNatEntryDescription"] = request.FullNatEntryDescription
	}

	if !dara.IsNil(request.FullNatEntryId) {
		query["FullNatEntryId"] = request.FullNatEntryId
	}

	if !dara.IsNil(request.FullNatEntryName) {
		query["FullNatEntryName"] = request.FullNatEntryName
	}

	if !dara.IsNil(request.FullNatTableId) {
		query["FullNatTableId"] = request.FullNatTableId
	}

	if !dara.IsNil(request.IpProtocol) {
		query["IpProtocol"] = request.IpProtocol
	}

	if !dara.IsNil(request.NatIp) {
		query["NatIp"] = request.NatIp
	}

	if !dara.IsNil(request.NatIpPort) {
		query["NatIpPort"] = request.NatIpPort
	}

	if !dara.IsNil(request.NetworkInterfaceId) {
		query["NetworkInterfaceId"] = request.NetworkInterfaceId
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ModifyFullNatEntryAttribute"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ModifyFullNatEntryAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Modifies a FULLNAT entry.
//
// Description:
//
// ## [](#)
//
//   - **ModifyFullNatEntryAttribute*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListFullNatEntries](https://help.aliyun.com/document_detail/348779.html) operation to query the status of a FULLNAT entry.
//
//   - **Modifying**: indicates that the system is modifying the FULLNAT entry. You can query the FULLNAT entry, but cannot perform other operations.
//
//   - **Available**: indicates that the FULLNAT entry is modified.
//
//   - You cannot repeatedly call the **ModifyFullNatEntryAttribute*	- operation to modify a FULLNAT entry within the specified period of time.
//
// @param request - ModifyFullNatEntryAttributeRequest
//
// @return ModifyFullNatEntryAttributeResponse
func (client *Client) ModifyFullNatEntryAttribute(request *ModifyFullNatEntryAttributeRequest) (_result *ModifyFullNatEntryAttributeResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ModifyFullNatEntryAttributeResponse{}
	_body, _err := client.ModifyFullNatEntryAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Modifies the name and description of a Global Accelerator (GA) instance.
//
// @param request - ModifyGlobalAccelerationInstanceAttributesRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ModifyGlobalAccelerationInstanceAttributesResponse
func (client *Client) ModifyGlobalAccelerationInstanceAttributesWithOptions(request *ModifyGlobalAccelerationInstanceAttributesRequest, runtime *dara.RuntimeOptions) (_result *ModifyGlobalAccelerationInstanceAttributesResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.Description) {
		query["Description"] = request.Description
	}

	if !dara.IsNil(request.GlobalAccelerationInstanceId) {
		query["GlobalAccelerationInstanceId"] = request.GlobalAccelerationInstanceId
	}

	if !dara.IsNil(request.Name) {
		query["Name"] = request.Name
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ModifyGlobalAccelerationInstanceAttributes"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ModifyGlobalAccelerationInstanceAttributesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Modifies the name and description of a Global Accelerator (GA) instance.
//
// @param request - ModifyGlobalAccelerationInstanceAttributesRequest
//
// @return ModifyGlobalAccelerationInstanceAttributesResponse
func (client *Client) ModifyGlobalAccelerationInstanceAttributes(request *ModifyGlobalAccelerationInstanceAttributesRequest) (_result *ModifyGlobalAccelerationInstanceAttributesResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ModifyGlobalAccelerationInstanceAttributesResponse{}
	_body, _err := client.ModifyGlobalAccelerationInstanceAttributesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Modifies the maximum bandwidth of a Global Accelerator (GA) instance.
//
// Description:
//
// ## Usage notes
//
// You cannot call this operation to modify the maximum bandwidth of a subscription GA instance.
//
// @param request - ModifyGlobalAccelerationInstanceSpecRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ModifyGlobalAccelerationInstanceSpecResponse
func (client *Client) ModifyGlobalAccelerationInstanceSpecWithOptions(request *ModifyGlobalAccelerationInstanceSpecRequest, runtime *dara.RuntimeOptions) (_result *ModifyGlobalAccelerationInstanceSpecResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.Bandwidth) {
		query["Bandwidth"] = request.Bandwidth
	}

	if !dara.IsNil(request.GlobalAccelerationInstanceId) {
		query["GlobalAccelerationInstanceId"] = request.GlobalAccelerationInstanceId
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ModifyGlobalAccelerationInstanceSpec"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ModifyGlobalAccelerationInstanceSpecResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Modifies the maximum bandwidth of a Global Accelerator (GA) instance.
//
// Description:
//
// ## Usage notes
//
// You cannot call this operation to modify the maximum bandwidth of a subscription GA instance.
//
// @param request - ModifyGlobalAccelerationInstanceSpecRequest
//
// @return ModifyGlobalAccelerationInstanceSpecResponse
func (client *Client) ModifyGlobalAccelerationInstanceSpec(request *ModifyGlobalAccelerationInstanceSpecRequest) (_result *ModifyGlobalAccelerationInstanceSpecResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ModifyGlobalAccelerationInstanceSpecResponse{}
	_body, _err := client.ModifyGlobalAccelerationInstanceSpecWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Modifies the name and description of a high-availability virtual IP address (HaVip).
//
// Description:
//
// You cannot repeatedly call the **ModifyHaVipAttribute*	- operation to modify the name and description of an HaVip within the specified periods of time.
//
// @param request - ModifyHaVipAttributeRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ModifyHaVipAttributeResponse
func (client *Client) ModifyHaVipAttributeWithOptions(request *ModifyHaVipAttributeRequest, runtime *dara.RuntimeOptions) (_result *ModifyHaVipAttributeResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.Description) {
		query["Description"] = request.Description
	}

	if !dara.IsNil(request.HaVipId) {
		query["HaVipId"] = request.HaVipId
	}

	if !dara.IsNil(request.Name) {
		query["Name"] = request.Name
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ModifyHaVipAttribute"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ModifyHaVipAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Modifies the name and description of a high-availability virtual IP address (HaVip).
//
// Description:
//
// You cannot repeatedly call the **ModifyHaVipAttribute*	- operation to modify the name and description of an HaVip within the specified periods of time.
//
// @param request - ModifyHaVipAttributeRequest
//
// @return ModifyHaVipAttributeResponse
func (client *Client) ModifyHaVipAttribute(request *ModifyHaVipAttributeRequest) (_result *ModifyHaVipAttributeResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ModifyHaVipAttributeResponse{}
	_body, _err := client.ModifyHaVipAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Deprecated: OpenAPI ModifyIPv6TranslatorAclAttribute is deprecated
//
// Summary:
//
// Modifies the name of an access control list (ACL).
//
// @param request - ModifyIPv6TranslatorAclAttributeRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ModifyIPv6TranslatorAclAttributeResponse
func (client *Client) ModifyIPv6TranslatorAclAttributeWithOptions(request *ModifyIPv6TranslatorAclAttributeRequest, runtime *dara.RuntimeOptions) (_result *ModifyIPv6TranslatorAclAttributeResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.AclId) {
		query["AclId"] = request.AclId
	}

	if !dara.IsNil(request.AclName) {
		query["AclName"] = request.AclName
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ModifyIPv6TranslatorAclAttribute"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ModifyIPv6TranslatorAclAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Deprecated: OpenAPI ModifyIPv6TranslatorAclAttribute is deprecated
//
// Summary:
//
// Modifies the name of an access control list (ACL).
//
// @param request - ModifyIPv6TranslatorAclAttributeRequest
//
// @return ModifyIPv6TranslatorAclAttributeResponse
// Deprecated
func (client *Client) ModifyIPv6TranslatorAclAttribute(request *ModifyIPv6TranslatorAclAttributeRequest) (_result *ModifyIPv6TranslatorAclAttributeResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ModifyIPv6TranslatorAclAttributeResponse{}
	_body, _err := client.ModifyIPv6TranslatorAclAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Modifies an IP entry in an access control list (ACL).
//
// @param request - ModifyIPv6TranslatorAclListEntryRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ModifyIPv6TranslatorAclListEntryResponse
func (client *Client) ModifyIPv6TranslatorAclListEntryWithOptions(request *ModifyIPv6TranslatorAclListEntryRequest, runtime *dara.RuntimeOptions) (_result *ModifyIPv6TranslatorAclListEntryResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.AclEntryComment) {
		query["AclEntryComment"] = request.AclEntryComment
	}

	if !dara.IsNil(request.AclEntryId) {
		query["AclEntryId"] = request.AclEntryId
	}

	if !dara.IsNil(request.AclId) {
		query["AclId"] = request.AclId
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ModifyIPv6TranslatorAclListEntry"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ModifyIPv6TranslatorAclListEntryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Modifies an IP entry in an access control list (ACL).
//
// @param request - ModifyIPv6TranslatorAclListEntryRequest
//
// @return ModifyIPv6TranslatorAclListEntryResponse
func (client *Client) ModifyIPv6TranslatorAclListEntry(request *ModifyIPv6TranslatorAclListEntryRequest) (_result *ModifyIPv6TranslatorAclListEntryResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ModifyIPv6TranslatorAclListEntryResponse{}
	_body, _err := client.ModifyIPv6TranslatorAclListEntryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Modifies the name and description of an IPv6 Translation Service instance.
//
// @param request - ModifyIPv6TranslatorAttributeRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ModifyIPv6TranslatorAttributeResponse
func (client *Client) ModifyIPv6TranslatorAttributeWithOptions(request *ModifyIPv6TranslatorAttributeRequest, runtime *dara.RuntimeOptions) (_result *ModifyIPv6TranslatorAttributeResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.Description) {
		query["Description"] = request.Description
	}

	if !dara.IsNil(request.Ipv6TranslatorId) {
		query["Ipv6TranslatorId"] = request.Ipv6TranslatorId
	}

	if !dara.IsNil(request.Name) {
		query["Name"] = request.Name
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ModifyIPv6TranslatorAttribute"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ModifyIPv6TranslatorAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Modifies the name and description of an IPv6 Translation Service instance.
//
// @param request - ModifyIPv6TranslatorAttributeRequest
//
// @return ModifyIPv6TranslatorAttributeResponse
func (client *Client) ModifyIPv6TranslatorAttribute(request *ModifyIPv6TranslatorAttributeRequest) (_result *ModifyIPv6TranslatorAttributeResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ModifyIPv6TranslatorAttributeResponse{}
	_body, _err := client.ModifyIPv6TranslatorAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Modifies the maximum bandwidth of an IPv6 Translation Service instance.
//
// @param request - ModifyIPv6TranslatorBandwidthRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ModifyIPv6TranslatorBandwidthResponse
func (client *Client) ModifyIPv6TranslatorBandwidthWithOptions(request *ModifyIPv6TranslatorBandwidthRequest, runtime *dara.RuntimeOptions) (_result *ModifyIPv6TranslatorBandwidthResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.AutoPay) {
		query["AutoPay"] = request.AutoPay
	}

	if !dara.IsNil(request.Bandwidth) {
		query["Bandwidth"] = request.Bandwidth
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.Ipv6TranslatorId) {
		query["Ipv6TranslatorId"] = request.Ipv6TranslatorId
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ModifyIPv6TranslatorBandwidth"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ModifyIPv6TranslatorBandwidthResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Modifies the maximum bandwidth of an IPv6 Translation Service instance.
//
// @param request - ModifyIPv6TranslatorBandwidthRequest
//
// @return ModifyIPv6TranslatorBandwidthResponse
func (client *Client) ModifyIPv6TranslatorBandwidth(request *ModifyIPv6TranslatorBandwidthRequest) (_result *ModifyIPv6TranslatorBandwidthResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ModifyIPv6TranslatorBandwidthResponse{}
	_body, _err := client.ModifyIPv6TranslatorBandwidthWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Deprecated: OpenAPI ModifyIPv6TranslatorEntry is deprecated
//
// Summary:
//
// Modifies an IPv6 mapping entry.
//
// @param request - ModifyIPv6TranslatorEntryRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ModifyIPv6TranslatorEntryResponse
func (client *Client) ModifyIPv6TranslatorEntryWithOptions(request *ModifyIPv6TranslatorEntryRequest, runtime *dara.RuntimeOptions) (_result *ModifyIPv6TranslatorEntryResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.AclId) {
		query["AclId"] = request.AclId
	}

	if !dara.IsNil(request.AclStatus) {
		query["AclStatus"] = request.AclStatus
	}

	if !dara.IsNil(request.AclType) {
		query["AclType"] = request.AclType
	}

	if !dara.IsNil(request.AllocateIpv6Port) {
		query["AllocateIpv6Port"] = request.AllocateIpv6Port
	}

	if !dara.IsNil(request.BackendIpv4Addr) {
		query["BackendIpv4Addr"] = request.BackendIpv4Addr
	}

	if !dara.IsNil(request.BackendIpv4Port) {
		query["BackendIpv4Port"] = request.BackendIpv4Port
	}

	if !dara.IsNil(request.EntryBandwidth) {
		query["EntryBandwidth"] = request.EntryBandwidth
	}

	if !dara.IsNil(request.EntryDescription) {
		query["EntryDescription"] = request.EntryDescription
	}

	if !dara.IsNil(request.EntryName) {
		query["EntryName"] = request.EntryName
	}

	if !dara.IsNil(request.Ipv6TranslatorEntryId) {
		query["Ipv6TranslatorEntryId"] = request.Ipv6TranslatorEntryId
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.TransProtocol) {
		query["TransProtocol"] = request.TransProtocol
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ModifyIPv6TranslatorEntry"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ModifyIPv6TranslatorEntryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Deprecated: OpenAPI ModifyIPv6TranslatorEntry is deprecated
//
// Summary:
//
// Modifies an IPv6 mapping entry.
//
// @param request - ModifyIPv6TranslatorEntryRequest
//
// @return ModifyIPv6TranslatorEntryResponse
// Deprecated
func (client *Client) ModifyIPv6TranslatorEntry(request *ModifyIPv6TranslatorEntryRequest) (_result *ModifyIPv6TranslatorEntryResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ModifyIPv6TranslatorEntryResponse{}
	_body, _err := client.ModifyIPv6TranslatorEntryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Modifies the name and description of an IPv6 address.
//
// @param request - ModifyIpv6AddressAttributeRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ModifyIpv6AddressAttributeResponse
func (client *Client) ModifyIpv6AddressAttributeWithOptions(request *ModifyIpv6AddressAttributeRequest, runtime *dara.RuntimeOptions) (_result *ModifyIpv6AddressAttributeResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.Description) {
		query["Description"] = request.Description
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.Ipv6AddressId) {
		query["Ipv6AddressId"] = request.Ipv6AddressId
	}

	if !dara.IsNil(request.Name) {
		query["Name"] = request.Name
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ModifyIpv6AddressAttribute"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ModifyIpv6AddressAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Modifies the name and description of an IPv6 address.
//
// @param request - ModifyIpv6AddressAttributeRequest
//
// @return ModifyIpv6AddressAttributeResponse
func (client *Client) ModifyIpv6AddressAttribute(request *ModifyIpv6AddressAttributeRequest) (_result *ModifyIpv6AddressAttributeResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ModifyIpv6AddressAttributeResponse{}
	_body, _err := client.ModifyIpv6AddressAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Modifies the name and description of an IPv6 gateway.
//
// @param request - ModifyIpv6GatewayAttributeRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ModifyIpv6GatewayAttributeResponse
func (client *Client) ModifyIpv6GatewayAttributeWithOptions(request *ModifyIpv6GatewayAttributeRequest, runtime *dara.RuntimeOptions) (_result *ModifyIpv6GatewayAttributeResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.Description) {
		query["Description"] = request.Description
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.Ipv6GatewayId) {
		query["Ipv6GatewayId"] = request.Ipv6GatewayId
	}

	if !dara.IsNil(request.Name) {
		query["Name"] = request.Name
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ModifyIpv6GatewayAttribute"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ModifyIpv6GatewayAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Modifies the name and description of an IPv6 gateway.
//
// @param request - ModifyIpv6GatewayAttributeRequest
//
// @return ModifyIpv6GatewayAttributeResponse
func (client *Client) ModifyIpv6GatewayAttribute(request *ModifyIpv6GatewayAttributeRequest) (_result *ModifyIpv6GatewayAttributeResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ModifyIpv6GatewayAttributeResponse{}
	_body, _err := client.ModifyIpv6GatewayAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Modifies the Internet bandwidth of an IPv6 address.
//
// Description:
//
// You cannot repeatedly call the **ModifyIpv6InternetBandwidth*	- operation to modify the Internet bandwidth value of an IPv6 CIDR block within the specified period of time.
//
// @param request - ModifyIpv6InternetBandwidthRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ModifyIpv6InternetBandwidthResponse
func (client *Client) ModifyIpv6InternetBandwidthWithOptions(request *ModifyIpv6InternetBandwidthRequest, runtime *dara.RuntimeOptions) (_result *ModifyIpv6InternetBandwidthResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.Bandwidth) {
		query["Bandwidth"] = request.Bandwidth
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.Ipv6AddressId) {
		query["Ipv6AddressId"] = request.Ipv6AddressId
	}

	if !dara.IsNil(request.Ipv6InternetBandwidthId) {
		query["Ipv6InternetBandwidthId"] = request.Ipv6InternetBandwidthId
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ModifyIpv6InternetBandwidth"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ModifyIpv6InternetBandwidthResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Modifies the Internet bandwidth of an IPv6 address.
//
// Description:
//
// You cannot repeatedly call the **ModifyIpv6InternetBandwidth*	- operation to modify the Internet bandwidth value of an IPv6 CIDR block within the specified period of time.
//
// @param request - ModifyIpv6InternetBandwidthRequest
//
// @return ModifyIpv6InternetBandwidthResponse
func (client *Client) ModifyIpv6InternetBandwidth(request *ModifyIpv6InternetBandwidthRequest) (_result *ModifyIpv6InternetBandwidthResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ModifyIpv6InternetBandwidthResponse{}
	_body, _err := client.ModifyIpv6InternetBandwidthWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Modifies the name and description of a NAT gateway.
//
// Description:
//
// ## [](#)Description
//
// You can call this operation to query an Internet NAT gateway or a virtual private cloud (VPC) NAT gateway. The term NAT gateway in this topic refers to both NAT gateway types.
//
// @param tmpReq - ModifyNatGatewayAttributeRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ModifyNatGatewayAttributeResponse
func (client *Client) ModifyNatGatewayAttributeWithOptions(tmpReq *ModifyNatGatewayAttributeRequest, runtime *dara.RuntimeOptions) (_result *ModifyNatGatewayAttributeResponse, _err error) {
	_err = tmpReq.Validate()
	if _err != nil {
		return _result, _err
	}
	request := &ModifyNatGatewayAttributeShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !dara.IsNil(tmpReq.LogDelivery) {
		request.LogDeliveryShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.LogDelivery, dara.String("LogDelivery"), dara.String("json"))
	}

	query := map[string]interface{}{}
	if !dara.IsNil(request.Description) {
		query["Description"] = request.Description
	}

	if !dara.IsNil(request.EipBindMode) {
		query["EipBindMode"] = request.EipBindMode
	}

	if !dara.IsNil(request.EnableSessionLog) {
		query["EnableSessionLog"] = request.EnableSessionLog
	}

	if !dara.IsNil(request.IcmpReplyEnabled) {
		query["IcmpReplyEnabled"] = request.IcmpReplyEnabled
	}

	if !dara.IsNil(request.LogDeliveryShrink) {
		query["LogDelivery"] = request.LogDeliveryShrink
	}

	if !dara.IsNil(request.Name) {
		query["Name"] = request.Name
	}

	if !dara.IsNil(request.NatGatewayId) {
		query["NatGatewayId"] = request.NatGatewayId
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ModifyNatGatewayAttribute"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ModifyNatGatewayAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Modifies the name and description of a NAT gateway.
//
// Description:
//
// ## [](#)Description
//
// You can call this operation to query an Internet NAT gateway or a virtual private cloud (VPC) NAT gateway. The term NAT gateway in this topic refers to both NAT gateway types.
//
// @param request - ModifyNatGatewayAttributeRequest
//
// @return ModifyNatGatewayAttributeResponse
func (client *Client) ModifyNatGatewayAttribute(request *ModifyNatGatewayAttributeRequest) (_result *ModifyNatGatewayAttributeResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ModifyNatGatewayAttributeResponse{}
	_body, _err := client.ModifyNatGatewayAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Upgrades a subscription Internet NAT gateway.
//
// Description:
//
// - You cannot call this operation to downgrade a subscription Internet NAT gateway. You can downgrade a subscription Internet NAT gateway only in the console.
//
// - When you call this operation to upgrade a subscription Internet NAT gateway, an order is generated. After you complete the payment in the order center, the Internet NAT gateway is upgraded.
//
// - **ModifyNatGatewaySpec*	- is an asynchronous operation. After you make a request, the ID of the request is returned but the Internet NAT gateway is not upgraded. The system upgrades the NAT gateway in the background. You can call the [DescribeNatGateways](/help/en/virtual-private-cloud/latest/describenatgateways) operation to query the status of an Internet NAT gateway.    - If an Internet NAT gateway is in the **Modifying*	- state, the NAT gateway is being upgraded. In this case, you can only query the NAT gateway but cannot perform other operations.
//
//   - If an Internet NAT gateway is in the **Available*	- state, the Internet NAT gateway is upgraded.
//
// - You cannot repeatedly call the **ModifyNatGatewaySpec*	- operation to resize a pay-by-specification NAT gateway.
//
// Internet NAT gateways are available in different sizes. The size of an Internet NAT gateway determines the SNAT performance, which includes the maximum number of connections and the number of new connections per second. However, the size of a NAT gateway does not affect the data throughput. The following table describes the correlations between different sizes of Internet NAT gateways and SNAT performance metrics.
//
// | Size | Maximum number of connections | Number of new connections per second |
//
// | ---- | ----------------------------- | ------------------------------------ |
//
// | Small | 10,000 | 1,000 |
//
// | Medium | 50,000 | 5,000 |
//
// | Large | 200,000 | 10,000 |
//
// @param request - ModifyNatGatewaySpecRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ModifyNatGatewaySpecResponse
func (client *Client) ModifyNatGatewaySpecWithOptions(request *ModifyNatGatewaySpecRequest, runtime *dara.RuntimeOptions) (_result *ModifyNatGatewaySpecResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.AutoPay) {
		query["AutoPay"] = request.AutoPay
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.NatGatewayId) {
		query["NatGatewayId"] = request.NatGatewayId
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.Spec) {
		query["Spec"] = request.Spec
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ModifyNatGatewaySpec"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ModifyNatGatewaySpecResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Upgrades a subscription Internet NAT gateway.
//
// Description:
//
// - You cannot call this operation to downgrade a subscription Internet NAT gateway. You can downgrade a subscription Internet NAT gateway only in the console.
//
// - When you call this operation to upgrade a subscription Internet NAT gateway, an order is generated. After you complete the payment in the order center, the Internet NAT gateway is upgraded.
//
// - **ModifyNatGatewaySpec*	- is an asynchronous operation. After you make a request, the ID of the request is returned but the Internet NAT gateway is not upgraded. The system upgrades the NAT gateway in the background. You can call the [DescribeNatGateways](/help/en/virtual-private-cloud/latest/describenatgateways) operation to query the status of an Internet NAT gateway.    - If an Internet NAT gateway is in the **Modifying*	- state, the NAT gateway is being upgraded. In this case, you can only query the NAT gateway but cannot perform other operations.
//
//   - If an Internet NAT gateway is in the **Available*	- state, the Internet NAT gateway is upgraded.
//
// - You cannot repeatedly call the **ModifyNatGatewaySpec*	- operation to resize a pay-by-specification NAT gateway.
//
// Internet NAT gateways are available in different sizes. The size of an Internet NAT gateway determines the SNAT performance, which includes the maximum number of connections and the number of new connections per second. However, the size of a NAT gateway does not affect the data throughput. The following table describes the correlations between different sizes of Internet NAT gateways and SNAT performance metrics.
//
// | Size | Maximum number of connections | Number of new connections per second |
//
// | ---- | ----------------------------- | ------------------------------------ |
//
// | Small | 10,000 | 1,000 |
//
// | Medium | 50,000 | 5,000 |
//
// | Large | 200,000 | 10,000 |
//
// @param request - ModifyNatGatewaySpecRequest
//
// @return ModifyNatGatewaySpecResponse
func (client *Client) ModifyNatGatewaySpec(request *ModifyNatGatewaySpecRequest) (_result *ModifyNatGatewaySpecResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ModifyNatGatewaySpecResponse{}
	_body, _err := client.ModifyNatGatewaySpecWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Modifies the name and description of a NAT IP address.
//
// Description:
//
// ## [](#)Description
//
// You cannot repeatedly call the **ModifyNatIpAttribute*	- operation to modify the name and description of a NAT IP address within the specified period of time.
//
// @param request - ModifyNatIpAttributeRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ModifyNatIpAttributeResponse
func (client *Client) ModifyNatIpAttributeWithOptions(request *ModifyNatIpAttributeRequest, runtime *dara.RuntimeOptions) (_result *ModifyNatIpAttributeResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.NatIpDescription) {
		query["NatIpDescription"] = request.NatIpDescription
	}

	if !dara.IsNil(request.NatIpId) {
		query["NatIpId"] = request.NatIpId
	}

	if !dara.IsNil(request.NatIpName) {
		query["NatIpName"] = request.NatIpName
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ModifyNatIpAttribute"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ModifyNatIpAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Modifies the name and description of a NAT IP address.
//
// Description:
//
// ## [](#)Description
//
// You cannot repeatedly call the **ModifyNatIpAttribute*	- operation to modify the name and description of a NAT IP address within the specified period of time.
//
// @param request - ModifyNatIpAttributeRequest
//
// @return ModifyNatIpAttributeResponse
func (client *Client) ModifyNatIpAttribute(request *ModifyNatIpAttributeRequest) (_result *ModifyNatIpAttributeResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ModifyNatIpAttributeResponse{}
	_body, _err := client.ModifyNatIpAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Modifies the name and description of a NAT CIDR block.
//
// @param request - ModifyNatIpCidrAttributeRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ModifyNatIpCidrAttributeResponse
func (client *Client) ModifyNatIpCidrAttributeWithOptions(request *ModifyNatIpCidrAttributeRequest, runtime *dara.RuntimeOptions) (_result *ModifyNatIpCidrAttributeResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.NatGatewayId) {
		query["NatGatewayId"] = request.NatGatewayId
	}

	if !dara.IsNil(request.NatIpCidr) {
		query["NatIpCidr"] = request.NatIpCidr
	}

	if !dara.IsNil(request.NatIpCidrDescription) {
		query["NatIpCidrDescription"] = request.NatIpCidrDescription
	}

	if !dara.IsNil(request.NatIpCidrName) {
		query["NatIpCidrName"] = request.NatIpCidrName
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ModifyNatIpCidrAttribute"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ModifyNatIpCidrAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Modifies the name and description of a NAT CIDR block.
//
// @param request - ModifyNatIpCidrAttributeRequest
//
// @return ModifyNatIpCidrAttributeResponse
func (client *Client) ModifyNatIpCidrAttribute(request *ModifyNatIpCidrAttributeRequest) (_result *ModifyNatIpCidrAttributeResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ModifyNatIpCidrAttributeResponse{}
	_body, _err := client.ModifyNatIpCidrAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Modifies the attributes of a network access control list (ACL).
//
// @param request - ModifyNetworkAclAttributesRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ModifyNetworkAclAttributesResponse
func (client *Client) ModifyNetworkAclAttributesWithOptions(request *ModifyNetworkAclAttributesRequest, runtime *dara.RuntimeOptions) (_result *ModifyNetworkAclAttributesResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.Description) {
		query["Description"] = request.Description
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.NetworkAclId) {
		query["NetworkAclId"] = request.NetworkAclId
	}

	if !dara.IsNil(request.NetworkAclName) {
		query["NetworkAclName"] = request.NetworkAclName
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ModifyNetworkAclAttributes"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ModifyNetworkAclAttributesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Modifies the attributes of a network access control list (ACL).
//
// @param request - ModifyNetworkAclAttributesRequest
//
// @return ModifyNetworkAclAttributesResponse
func (client *Client) ModifyNetworkAclAttributes(request *ModifyNetworkAclAttributesRequest) (_result *ModifyNetworkAclAttributesResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ModifyNetworkAclAttributesResponse{}
	_body, _err := client.ModifyNetworkAclAttributesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Modifies the configurations of an Express Connect circuit.
//
// Description:
//
// When you call this operation, take note of the following limits:
//
//   - If an Express Connect circuit is in the **Initial**, **Enabled**, or **Rejected*	- state, you can modify the specifications of the Express Connect circuit and the ID of the redundant circuit.
//
//   - If an Express Connect circuit is in the **Canceled**, **Allocating**, **AllocationFailed**, or **Terminated*	- state, you cannot modify the specifications of the Express Connect circuit.
//
//   - After you modify the specifications of an Express Connect circuit that is in the **Rejected*	- state, the Express Connect circuit enters the **Initial*	- state.
//
// @param request - ModifyPhysicalConnectionAttributeRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ModifyPhysicalConnectionAttributeResponse
func (client *Client) ModifyPhysicalConnectionAttributeWithOptions(request *ModifyPhysicalConnectionAttributeRequest, runtime *dara.RuntimeOptions) (_result *ModifyPhysicalConnectionAttributeResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.CircuitCode) {
		query["CircuitCode"] = request.CircuitCode
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.Description) {
		query["Description"] = request.Description
	}

	if !dara.IsNil(request.LineOperator) {
		query["LineOperator"] = request.LineOperator
	}

	if !dara.IsNil(request.Name) {
		query["Name"] = request.Name
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PeerLocation) {
		query["PeerLocation"] = request.PeerLocation
	}

	if !dara.IsNil(request.PhysicalConnectionId) {
		query["PhysicalConnectionId"] = request.PhysicalConnectionId
	}

	if !dara.IsNil(request.PortType) {
		query["PortType"] = request.PortType
	}

	if !dara.IsNil(request.RedundantPhysicalConnectionId) {
		query["RedundantPhysicalConnectionId"] = request.RedundantPhysicalConnectionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.Bandwidth) {
		query["bandwidth"] = request.Bandwidth
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ModifyPhysicalConnectionAttribute"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ModifyPhysicalConnectionAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Modifies the configurations of an Express Connect circuit.
//
// Description:
//
// When you call this operation, take note of the following limits:
//
//   - If an Express Connect circuit is in the **Initial**, **Enabled**, or **Rejected*	- state, you can modify the specifications of the Express Connect circuit and the ID of the redundant circuit.
//
//   - If an Express Connect circuit is in the **Canceled**, **Allocating**, **AllocationFailed**, or **Terminated*	- state, you cannot modify the specifications of the Express Connect circuit.
//
//   - After you modify the specifications of an Express Connect circuit that is in the **Rejected*	- state, the Express Connect circuit enters the **Initial*	- state.
//
// @param request - ModifyPhysicalConnectionAttributeRequest
//
// @return ModifyPhysicalConnectionAttributeResponse
func (client *Client) ModifyPhysicalConnectionAttribute(request *ModifyPhysicalConnectionAttributeRequest) (_result *ModifyPhysicalConnectionAttributeResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ModifyPhysicalConnectionAttributeResponse{}
	_body, _err := client.ModifyPhysicalConnectionAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Modifies the name and description of a custom route entry.
//
// Description:
//
// You cannot repeatedly call the **ModifyRouteEntry*	- operation to modify the name and description of a custom route within the specified period of time.
//
// @param request - ModifyRouteEntryRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ModifyRouteEntryResponse
func (client *Client) ModifyRouteEntryWithOptions(request *ModifyRouteEntryRequest, runtime *dara.RuntimeOptions) (_result *ModifyRouteEntryResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.Description) {
		query["Description"] = request.Description
	}

	if !dara.IsNil(request.DestinationCidrBlock) {
		query["DestinationCidrBlock"] = request.DestinationCidrBlock
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.NewNextHopId) {
		query["NewNextHopId"] = request.NewNextHopId
	}

	if !dara.IsNil(request.NewNextHopType) {
		query["NewNextHopType"] = request.NewNextHopType
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.RouteEntryId) {
		query["RouteEntryId"] = request.RouteEntryId
	}

	if !dara.IsNil(request.RouteEntryName) {
		query["RouteEntryName"] = request.RouteEntryName
	}

	if !dara.IsNil(request.RouteTableId) {
		query["RouteTableId"] = request.RouteTableId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ModifyRouteEntry"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ModifyRouteEntryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Modifies the name and description of a custom route entry.
//
// Description:
//
// You cannot repeatedly call the **ModifyRouteEntry*	- operation to modify the name and description of a custom route within the specified period of time.
//
// @param request - ModifyRouteEntryRequest
//
// @return ModifyRouteEntryResponse
func (client *Client) ModifyRouteEntry(request *ModifyRouteEntryRequest) (_result *ModifyRouteEntryResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ModifyRouteEntryResponse{}
	_body, _err := client.ModifyRouteEntryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Modifies the name and description of a route table.
//
// Description:
//
// You cannot repeatedly call the **ModifyRouteTableAttributes*	- operation to modify the name and description of a route table within the specified period of time.
//
// @param request - ModifyRouteTableAttributesRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ModifyRouteTableAttributesResponse
func (client *Client) ModifyRouteTableAttributesWithOptions(request *ModifyRouteTableAttributesRequest, runtime *dara.RuntimeOptions) (_result *ModifyRouteTableAttributesResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.Description) {
		query["Description"] = request.Description
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.RoutePropagationEnable) {
		query["RoutePropagationEnable"] = request.RoutePropagationEnable
	}

	if !dara.IsNil(request.RouteTableId) {
		query["RouteTableId"] = request.RouteTableId
	}

	if !dara.IsNil(request.RouteTableName) {
		query["RouteTableName"] = request.RouteTableName
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ModifyRouteTableAttributes"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ModifyRouteTableAttributesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Modifies the name and description of a route table.
//
// Description:
//
// You cannot repeatedly call the **ModifyRouteTableAttributes*	- operation to modify the name and description of a route table within the specified period of time.
//
// @param request - ModifyRouteTableAttributesRequest
//
// @return ModifyRouteTableAttributesResponse
func (client *Client) ModifyRouteTableAttributes(request *ModifyRouteTableAttributesRequest) (_result *ModifyRouteTableAttributesResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ModifyRouteTableAttributesResponse{}
	_body, _err := client.ModifyRouteTableAttributesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Modifies the configuration of a router interface.
//
// @param request - ModifyRouterInterfaceAttributeRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ModifyRouterInterfaceAttributeResponse
func (client *Client) ModifyRouterInterfaceAttributeWithOptions(request *ModifyRouterInterfaceAttributeRequest, runtime *dara.RuntimeOptions) (_result *ModifyRouterInterfaceAttributeResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.DeleteHealthCheckIp) {
		query["DeleteHealthCheckIp"] = request.DeleteHealthCheckIp
	}

	if !dara.IsNil(request.Description) {
		query["Description"] = request.Description
	}

	if !dara.IsNil(request.HcRate) {
		query["HcRate"] = request.HcRate
	}

	if !dara.IsNil(request.HcThreshold) {
		query["HcThreshold"] = request.HcThreshold
	}

	if !dara.IsNil(request.HealthCheckSourceIp) {
		query["HealthCheckSourceIp"] = request.HealthCheckSourceIp
	}

	if !dara.IsNil(request.HealthCheckTargetIp) {
		query["HealthCheckTargetIp"] = request.HealthCheckTargetIp
	}

	if !dara.IsNil(request.Name) {
		query["Name"] = request.Name
	}

	if !dara.IsNil(request.OppositeInterfaceId) {
		query["OppositeInterfaceId"] = request.OppositeInterfaceId
	}

	if !dara.IsNil(request.OppositeInterfaceOwnerId) {
		query["OppositeInterfaceOwnerId"] = request.OppositeInterfaceOwnerId
	}

	if !dara.IsNil(request.OppositeRouterId) {
		query["OppositeRouterId"] = request.OppositeRouterId
	}

	if !dara.IsNil(request.OppositeRouterType) {
		query["OppositeRouterType"] = request.OppositeRouterType
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.RouterInterfaceId) {
		query["RouterInterfaceId"] = request.RouterInterfaceId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ModifyRouterInterfaceAttribute"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ModifyRouterInterfaceAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Modifies the configuration of a router interface.
//
// @param request - ModifyRouterInterfaceAttributeRequest
//
// @return ModifyRouterInterfaceAttributeResponse
func (client *Client) ModifyRouterInterfaceAttribute(request *ModifyRouterInterfaceAttributeRequest) (_result *ModifyRouterInterfaceAttributeResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ModifyRouterInterfaceAttributeResponse{}
	_body, _err := client.ModifyRouterInterfaceAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Modifies the specification of a router interface.
//
// Description:
//
// After you call this operation, the router interface enters the **Activating*	- state. After the router interface is activated, the router interface enters the **Active*	- state.
//
// >  You cannot modify the specification of a router interface that has overdue payments.
//
// @param request - ModifyRouterInterfaceSpecRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ModifyRouterInterfaceSpecResponse
func (client *Client) ModifyRouterInterfaceSpecWithOptions(request *ModifyRouterInterfaceSpecRequest, runtime *dara.RuntimeOptions) (_result *ModifyRouterInterfaceSpecResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.RouterInterfaceId) {
		query["RouterInterfaceId"] = request.RouterInterfaceId
	}

	if !dara.IsNil(request.Spec) {
		query["Spec"] = request.Spec
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ModifyRouterInterfaceSpec"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ModifyRouterInterfaceSpecResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Modifies the specification of a router interface.
//
// Description:
//
// After you call this operation, the router interface enters the **Activating*	- state. After the router interface is activated, the router interface enters the **Active*	- state.
//
// >  You cannot modify the specification of a router interface that has overdue payments.
//
// @param request - ModifyRouterInterfaceSpecRequest
//
// @return ModifyRouterInterfaceSpecResponse
func (client *Client) ModifyRouterInterfaceSpec(request *ModifyRouterInterfaceSpecRequest) (_result *ModifyRouterInterfaceSpecResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ModifyRouterInterfaceSpecResponse{}
	_body, _err := client.ModifyRouterInterfaceSpecWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Modifies an SNAT entry.
//
// Description:
//
// ## [](#)
//
// **ModifySnatEntry*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeSnatTableEntries](https://help.aliyun.com/document_detail/42677.html) operation to query the status of the task.
//
//   - **Pending**: indicates that the system is modifying the SNAT entry. You can only query the status of the SNAT entry, but cannot perform other operations.
//
//   - **Available**: indicates that the SNAT entry is modified.
//
// >  If an SNAT entry is in the **Pending*	- state, it indicates that you cannot modify the SNAT entry.
//
// You cannot repeatedly call the **ModifySnatEntry*	- operation to modify an SNAT entry within a specific period of time.
//
// @param request - ModifySnatEntryRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ModifySnatEntryResponse
func (client *Client) ModifySnatEntryWithOptions(request *ModifySnatEntryRequest, runtime *dara.RuntimeOptions) (_result *ModifySnatEntryResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.EipAffinity) {
		query["EipAffinity"] = request.EipAffinity
	}

	if !dara.IsNil(request.NetworkInterfaceId) {
		query["NetworkInterfaceId"] = request.NetworkInterfaceId
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.SnatEntryId) {
		query["SnatEntryId"] = request.SnatEntryId
	}

	if !dara.IsNil(request.SnatEntryName) {
		query["SnatEntryName"] = request.SnatEntryName
	}

	if !dara.IsNil(request.SnatIp) {
		query["SnatIp"] = request.SnatIp
	}

	if !dara.IsNil(request.SnatTableId) {
		query["SnatTableId"] = request.SnatTableId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ModifySnatEntry"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ModifySnatEntryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Modifies an SNAT entry.
//
// Description:
//
// ## [](#)
//
// **ModifySnatEntry*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeSnatTableEntries](https://help.aliyun.com/document_detail/42677.html) operation to query the status of the task.
//
//   - **Pending**: indicates that the system is modifying the SNAT entry. You can only query the status of the SNAT entry, but cannot perform other operations.
//
//   - **Available**: indicates that the SNAT entry is modified.
//
// >  If an SNAT entry is in the **Pending*	- state, it indicates that you cannot modify the SNAT entry.
//
// You cannot repeatedly call the **ModifySnatEntry*	- operation to modify an SNAT entry within a specific period of time.
//
// @param request - ModifySnatEntryRequest
//
// @return ModifySnatEntryResponse
func (client *Client) ModifySnatEntry(request *ModifySnatEntryRequest) (_result *ModifySnatEntryResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ModifySnatEntryResponse{}
	_body, _err := client.ModifySnatEntryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Modifies the name of an SSL-VPN client certificate.
//
// @param request - ModifySslVpnClientCertRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ModifySslVpnClientCertResponse
func (client *Client) ModifySslVpnClientCertWithOptions(request *ModifySslVpnClientCertRequest, runtime *dara.RuntimeOptions) (_result *ModifySslVpnClientCertResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.Name) {
		query["Name"] = request.Name
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.SslVpnClientCertId) {
		query["SslVpnClientCertId"] = request.SslVpnClientCertId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ModifySslVpnClientCert"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ModifySslVpnClientCertResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Modifies the name of an SSL-VPN client certificate.
//
// @param request - ModifySslVpnClientCertRequest
//
// @return ModifySslVpnClientCertResponse
func (client *Client) ModifySslVpnClientCert(request *ModifySslVpnClientCertRequest) (_result *ModifySslVpnClientCertResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ModifySslVpnClientCertResponse{}
	_body, _err := client.ModifySslVpnClientCertWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Modifies the configurations of an SSL server.
//
// Description:
//
//	  To enable two-factor authentication for an SSL server, make sure that the VPN gateway supports two-factor authentication. You may need to upgrade the VPN gateway. For more information, see [Two-factor authentication supports IDaaS EIAM 2.0](https://help.aliyun.com/document_detail/2785320.html).
//
//		- If you modify only **Name**, this operation is synchronous. If you modify other parameters besides **Name**, this operation is asynchronous.
//
//		- **ModifySslVpnServer*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) operation to query the status of the task.
//
//	    	- If the VPN gateway is in the **updating*	- state, the SSL server is being modified.
//
//	    	- If the VPN gateway is in the **active*	- state, the SSL server is modified.
//
//		- You cannot repeatedly call **ModifySslVpnServer*	- within the specified period of time.
//
// @param request - ModifySslVpnServerRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ModifySslVpnServerResponse
func (client *Client) ModifySslVpnServerWithOptions(request *ModifySslVpnServerRequest, runtime *dara.RuntimeOptions) (_result *ModifySslVpnServerResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.Cipher) {
		query["Cipher"] = request.Cipher
	}

	if !dara.IsNil(request.ClientIpPool) {
		query["ClientIpPool"] = request.ClientIpPool
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.Compress) {
		query["Compress"] = request.Compress
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.EnableMultiFactorAuth) {
		query["EnableMultiFactorAuth"] = request.EnableMultiFactorAuth
	}

	if !dara.IsNil(request.IDaaSApplicationId) {
		query["IDaaSApplicationId"] = request.IDaaSApplicationId
	}

	if !dara.IsNil(request.IDaaSInstanceId) {
		query["IDaaSInstanceId"] = request.IDaaSInstanceId
	}

	if !dara.IsNil(request.IDaaSRegionId) {
		query["IDaaSRegionId"] = request.IDaaSRegionId
	}

	if !dara.IsNil(request.LocalSubnet) {
		query["LocalSubnet"] = request.LocalSubnet
	}

	if !dara.IsNil(request.Name) {
		query["Name"] = request.Name
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.Port) {
		query["Port"] = request.Port
	}

	if !dara.IsNil(request.Proto) {
		query["Proto"] = request.Proto
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.SslVpnServerId) {
		query["SslVpnServerId"] = request.SslVpnServerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ModifySslVpnServer"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ModifySslVpnServerResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Modifies the configurations of an SSL server.
//
// Description:
//
//	  To enable two-factor authentication for an SSL server, make sure that the VPN gateway supports two-factor authentication. You may need to upgrade the VPN gateway. For more information, see [Two-factor authentication supports IDaaS EIAM 2.0](https://help.aliyun.com/document_detail/2785320.html).
//
//		- If you modify only **Name**, this operation is synchronous. If you modify other parameters besides **Name**, this operation is asynchronous.
//
//		- **ModifySslVpnServer*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) operation to query the status of the task.
//
//	    	- If the VPN gateway is in the **updating*	- state, the SSL server is being modified.
//
//	    	- If the VPN gateway is in the **active*	- state, the SSL server is modified.
//
//		- You cannot repeatedly call **ModifySslVpnServer*	- within the specified period of time.
//
// @param request - ModifySslVpnServerRequest
//
// @return ModifySslVpnServerResponse
func (client *Client) ModifySslVpnServer(request *ModifySslVpnServerRequest) (_result *ModifySslVpnServerResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ModifySslVpnServerResponse{}
	_body, _err := client.ModifySslVpnServerWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Modifies a VPN tunnel.
//
// @param request - ModifyTunnelAttributeRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ModifyTunnelAttributeResponse
func (client *Client) ModifyTunnelAttributeWithOptions(request *ModifyTunnelAttributeRequest, runtime *dara.RuntimeOptions) (_result *ModifyTunnelAttributeResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.TunnelId) {
		query["TunnelId"] = request.TunnelId
	}

	if !dara.IsNil(request.TunnelOptionsSpecification) {
		query["TunnelOptionsSpecification"] = request.TunnelOptionsSpecification
	}

	if !dara.IsNil(request.VpnConnectionId) {
		query["VpnConnectionId"] = request.VpnConnectionId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ModifyTunnelAttribute"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ModifyTunnelAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Modifies a VPN tunnel.
//
// @param request - ModifyTunnelAttributeRequest
//
// @return ModifyTunnelAttributeResponse
func (client *Client) ModifyTunnelAttribute(request *ModifyTunnelAttributeRequest) (_result *ModifyTunnelAttributeResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ModifyTunnelAttributeResponse{}
	_body, _err := client.ModifyTunnelAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Modifies the name and description of a vRouter.
//
// Description:
//
// You cannot repeatedly call the **ModifyVRouterAttribute*	- operation within a specific period of time.
//
// @param request - ModifyVRouterAttributeRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ModifyVRouterAttributeResponse
func (client *Client) ModifyVRouterAttributeWithOptions(request *ModifyVRouterAttributeRequest, runtime *dara.RuntimeOptions) (_result *ModifyVRouterAttributeResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.Description) {
		query["Description"] = request.Description
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.VRouterId) {
		query["VRouterId"] = request.VRouterId
	}

	if !dara.IsNil(request.VRouterName) {
		query["VRouterName"] = request.VRouterName
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ModifyVRouterAttribute"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ModifyVRouterAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Modifies the name and description of a vRouter.
//
// Description:
//
// You cannot repeatedly call the **ModifyVRouterAttribute*	- operation within a specific period of time.
//
// @param request - ModifyVRouterAttributeRequest
//
// @return ModifyVRouterAttributeResponse
func (client *Client) ModifyVRouterAttribute(request *ModifyVRouterAttributeRequest) (_result *ModifyVRouterAttributeResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ModifyVRouterAttributeResponse{}
	_body, _err := client.ModifyVRouterAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// VSwitch
//
// Description:
//
//	  **ModifyVSwitchAttribute*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVSwitchAttributes](https://help.aliyun.com/document_detail/94567.html) operation to query the status of the task:
//
//	    	- If the vSwitch is in the **Pending*	- state, the name and description of the vSwitch are being modified.
//
//	    	- If the vSwitch is in the **Available*	- state, the name and description of the vSwitch are modified.
//
//		- You cannot repeatedly call the **ModifyVSwitchAttribute*	- operation to modify the name and description of a vSwitch within the specified period of time.
//
// @param request - ModifyVSwitchAttributeRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ModifyVSwitchAttributeResponse
func (client *Client) ModifyVSwitchAttributeWithOptions(request *ModifyVSwitchAttributeRequest, runtime *dara.RuntimeOptions) (_result *ModifyVSwitchAttributeResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.Description) {
		query["Description"] = request.Description
	}

	if !dara.IsNil(request.EnableIPv6) {
		query["EnableIPv6"] = request.EnableIPv6
	}

	if !dara.IsNil(request.Ipv6CidrBlock) {
		query["Ipv6CidrBlock"] = request.Ipv6CidrBlock
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.VSwitchId) {
		query["VSwitchId"] = request.VSwitchId
	}

	if !dara.IsNil(request.VSwitchName) {
		query["VSwitchName"] = request.VSwitchName
	}

	if !dara.IsNil(request.VpcIpv6CidrBlock) {
		query["VpcIpv6CidrBlock"] = request.VpcIpv6CidrBlock
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ModifyVSwitchAttribute"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ModifyVSwitchAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// VSwitch
//
// Description:
//
//	  **ModifyVSwitchAttribute*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVSwitchAttributes](https://help.aliyun.com/document_detail/94567.html) operation to query the status of the task:
//
//	    	- If the vSwitch is in the **Pending*	- state, the name and description of the vSwitch are being modified.
//
//	    	- If the vSwitch is in the **Available*	- state, the name and description of the vSwitch are modified.
//
//		- You cannot repeatedly call the **ModifyVSwitchAttribute*	- operation to modify the name and description of a vSwitch within the specified period of time.
//
// @param request - ModifyVSwitchAttributeRequest
//
// @return ModifyVSwitchAttributeResponse
func (client *Client) ModifyVSwitchAttribute(request *ModifyVSwitchAttributeRequest) (_result *ModifyVSwitchAttributeResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ModifyVSwitchAttributeResponse{}
	_body, _err := client.ModifyVSwitchAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// 
//
// Description:
//
// ## [](#)Usage notes
//
// You cannot repeatedly call **ModifyVSwitchCidrReservationAttribute*	- within a specific time period.
//
// @param request - ModifyVSwitchCidrReservationAttributeRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ModifyVSwitchCidrReservationAttributeResponse
func (client *Client) ModifyVSwitchCidrReservationAttributeWithOptions(request *ModifyVSwitchCidrReservationAttributeRequest, runtime *dara.RuntimeOptions) (_result *ModifyVSwitchCidrReservationAttributeResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.VSwitchCidrReservationDescription) {
		query["VSwitchCidrReservationDescription"] = request.VSwitchCidrReservationDescription
	}

	if !dara.IsNil(request.VSwitchCidrReservationId) {
		query["VSwitchCidrReservationId"] = request.VSwitchCidrReservationId
	}

	if !dara.IsNil(request.VSwitchCidrReservationName) {
		query["VSwitchCidrReservationName"] = request.VSwitchCidrReservationName
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ModifyVSwitchCidrReservationAttribute"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ModifyVSwitchCidrReservationAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// 
//
// Description:
//
// ## [](#)Usage notes
//
// You cannot repeatedly call **ModifyVSwitchCidrReservationAttribute*	- within a specific time period.
//
// @param request - ModifyVSwitchCidrReservationAttributeRequest
//
// @return ModifyVSwitchCidrReservationAttributeResponse
func (client *Client) ModifyVSwitchCidrReservationAttribute(request *ModifyVSwitchCidrReservationAttributeRequest) (_result *ModifyVSwitchCidrReservationAttributeResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ModifyVSwitchCidrReservationAttributeResponse{}
	_body, _err := client.ModifyVSwitchCidrReservationAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Modifies the weight of a destination-based route for an IPsec-VPN connection.
//
// Description:
//
//	  **ModifyVcoRouteEntryWeight*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnConnection](https://help.aliyun.com/document_detail/53046.html) operation to query the status of the associated IPsec-VPN connection and determine whether the weight of the specified destination-based route is modified.
//
//	    	- If the IPsec-VPN connection is in the **updating*	- state, the weight of the destination-based route is being modified.
//
//	    	- If the IPsec-VPN connection is in the **attached*	- state, the weight of the destination-based route is modified.
//
//		- You cannot repeatedly call the **ModifyVcoRouteEntryWeight*	- operation for the same IPsec-VPN connection within the specified period of time.
//
// @param request - ModifyVcoRouteEntryWeightRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ModifyVcoRouteEntryWeightResponse
func (client *Client) ModifyVcoRouteEntryWeightWithOptions(request *ModifyVcoRouteEntryWeightRequest, runtime *dara.RuntimeOptions) (_result *ModifyVcoRouteEntryWeightResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.NewWeight) {
		query["NewWeight"] = request.NewWeight
	}

	if !dara.IsNil(request.NextHop) {
		query["NextHop"] = request.NextHop
	}

	if !dara.IsNil(request.OverlayMode) {
		query["OverlayMode"] = request.OverlayMode
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.RouteDest) {
		query["RouteDest"] = request.RouteDest
	}

	if !dara.IsNil(request.VpnConnectionId) {
		query["VpnConnectionId"] = request.VpnConnectionId
	}

	if !dara.IsNil(request.Weight) {
		query["Weight"] = request.Weight
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ModifyVcoRouteEntryWeight"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ModifyVcoRouteEntryWeightResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Modifies the weight of a destination-based route for an IPsec-VPN connection.
//
// Description:
//
//	  **ModifyVcoRouteEntryWeight*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnConnection](https://help.aliyun.com/document_detail/53046.html) operation to query the status of the associated IPsec-VPN connection and determine whether the weight of the specified destination-based route is modified.
//
//	    	- If the IPsec-VPN connection is in the **updating*	- state, the weight of the destination-based route is being modified.
//
//	    	- If the IPsec-VPN connection is in the **attached*	- state, the weight of the destination-based route is modified.
//
//		- You cannot repeatedly call the **ModifyVcoRouteEntryWeight*	- operation for the same IPsec-VPN connection within the specified period of time.
//
// @param request - ModifyVcoRouteEntryWeightRequest
//
// @return ModifyVcoRouteEntryWeightResponse
func (client *Client) ModifyVcoRouteEntryWeight(request *ModifyVcoRouteEntryWeightRequest) (_result *ModifyVcoRouteEntryWeightResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ModifyVcoRouteEntryWeightResponse{}
	_body, _err := client.ModifyVcoRouteEntryWeightWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Modifies the configuration of a virtual border router (VBR).
//
// Description:
//
// # [](#)
//
//   - Only the owner of an Express Connect circuit can modify the **VlanId*	- parameter.
//
//   - One VLAN ID of an Express Connect circuit cannot be used only by one VBR at the same time.
//
//   - The VLAN ID of a VBR in the **Terminated*	- state is reserved for seven days and cannot be used by other VBRs. The VLAN ID can be used by other VBRs after 7 days.
//
//   - You cannot set **LocalGatewayIp**, **PeerGatewayIp**, or **PeeringSubnetMask*	- for VBRs that do not belong to your Alibaba Cloud account.
//
//   - Set **PeeringSubnetMask*	- to a subnet mask with 24 to 30 bits in length (255.255.255.0255.255.255.252).
//
//   - Set **LocalGatewayIp*	- and **PeerGatewayIp*	- to IP addresses that belong to the same CIDR block. For example, you can set LocalGatewayIp to 192.168.XX.XX, PeerGatewayIp to 192.168.XX.XX, and PeeringSubnetMask to 255.255.255.248.
//
// @param request - ModifyVirtualBorderRouterAttributeRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ModifyVirtualBorderRouterAttributeResponse
func (client *Client) ModifyVirtualBorderRouterAttributeWithOptions(request *ModifyVirtualBorderRouterAttributeRequest, runtime *dara.RuntimeOptions) (_result *ModifyVirtualBorderRouterAttributeResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.AssociatedPhysicalConnections) {
		query["AssociatedPhysicalConnections"] = request.AssociatedPhysicalConnections
	}

	if !dara.IsNil(request.Bandwidth) {
		query["Bandwidth"] = request.Bandwidth
	}

	if !dara.IsNil(request.CircuitCode) {
		query["CircuitCode"] = request.CircuitCode
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.Description) {
		query["Description"] = request.Description
	}

	if !dara.IsNil(request.DetectMultiplier) {
		query["DetectMultiplier"] = request.DetectMultiplier
	}

	if !dara.IsNil(request.EnableIpv6) {
		query["EnableIpv6"] = request.EnableIpv6
	}

	if !dara.IsNil(request.LocalGatewayIp) {
		query["LocalGatewayIp"] = request.LocalGatewayIp
	}

	if !dara.IsNil(request.LocalIpv6GatewayIp) {
		query["LocalIpv6GatewayIp"] = request.LocalIpv6GatewayIp
	}

	if !dara.IsNil(request.MinRxInterval) {
		query["MinRxInterval"] = request.MinRxInterval
	}

	if !dara.IsNil(request.MinTxInterval) {
		query["MinTxInterval"] = request.MinTxInterval
	}

	if !dara.IsNil(request.Name) {
		query["Name"] = request.Name
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PeerGatewayIp) {
		query["PeerGatewayIp"] = request.PeerGatewayIp
	}

	if !dara.IsNil(request.PeerIpv6GatewayIp) {
		query["PeerIpv6GatewayIp"] = request.PeerIpv6GatewayIp
	}

	if !dara.IsNil(request.PeeringIpv6SubnetMask) {
		query["PeeringIpv6SubnetMask"] = request.PeeringIpv6SubnetMask
	}

	if !dara.IsNil(request.PeeringSubnetMask) {
		query["PeeringSubnetMask"] = request.PeeringSubnetMask
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.SitelinkEnable) {
		query["SitelinkEnable"] = request.SitelinkEnable
	}

	if !dara.IsNil(request.VbrId) {
		query["VbrId"] = request.VbrId
	}

	if !dara.IsNil(request.VlanId) {
		query["VlanId"] = request.VlanId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ModifyVirtualBorderRouterAttribute"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ModifyVirtualBorderRouterAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Modifies the configuration of a virtual border router (VBR).
//
// Description:
//
// # [](#)
//
//   - Only the owner of an Express Connect circuit can modify the **VlanId*	- parameter.
//
//   - One VLAN ID of an Express Connect circuit cannot be used only by one VBR at the same time.
//
//   - The VLAN ID of a VBR in the **Terminated*	- state is reserved for seven days and cannot be used by other VBRs. The VLAN ID can be used by other VBRs after 7 days.
//
//   - You cannot set **LocalGatewayIp**, **PeerGatewayIp**, or **PeeringSubnetMask*	- for VBRs that do not belong to your Alibaba Cloud account.
//
//   - Set **PeeringSubnetMask*	- to a subnet mask with 24 to 30 bits in length (255.255.255.0255.255.255.252).
//
//   - Set **LocalGatewayIp*	- and **PeerGatewayIp*	- to IP addresses that belong to the same CIDR block. For example, you can set LocalGatewayIp to 192.168.XX.XX, PeerGatewayIp to 192.168.XX.XX, and PeeringSubnetMask to 255.255.255.248.
//
// @param request - ModifyVirtualBorderRouterAttributeRequest
//
// @return ModifyVirtualBorderRouterAttributeResponse
func (client *Client) ModifyVirtualBorderRouterAttribute(request *ModifyVirtualBorderRouterAttributeRequest) (_result *ModifyVirtualBorderRouterAttributeResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ModifyVirtualBorderRouterAttributeResponse{}
	_body, _err := client.ModifyVirtualBorderRouterAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Modifies the name and description of a virtual private cloud (VPC).
//
// Description:
//
// ## [](#)Description
//
// You cannot repeatedly call the **ModifyVpcAttribute*	- operation to modify the name and description of a VPC within the specified period of time.
//
// @param request - ModifyVpcAttributeRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ModifyVpcAttributeResponse
func (client *Client) ModifyVpcAttributeWithOptions(request *ModifyVpcAttributeRequest, runtime *dara.RuntimeOptions) (_result *ModifyVpcAttributeResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.CidrBlock) {
		query["CidrBlock"] = request.CidrBlock
	}

	if !dara.IsNil(request.Description) {
		query["Description"] = request.Description
	}

	if !dara.IsNil(request.EnableDnsHostname) {
		query["EnableDnsHostname"] = request.EnableDnsHostname
	}

	if !dara.IsNil(request.EnableIPv6) {
		query["EnableIPv6"] = request.EnableIPv6
	}

	if !dara.IsNil(request.Ipv6CidrBlock) {
		query["Ipv6CidrBlock"] = request.Ipv6CidrBlock
	}

	if !dara.IsNil(request.Ipv6Isp) {
		query["Ipv6Isp"] = request.Ipv6Isp
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.VpcId) {
		query["VpcId"] = request.VpcId
	}

	if !dara.IsNil(request.VpcName) {
		query["VpcName"] = request.VpcName
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ModifyVpcAttribute"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ModifyVpcAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Modifies the name and description of a virtual private cloud (VPC).
//
// Description:
//
// ## [](#)Description
//
// You cannot repeatedly call the **ModifyVpcAttribute*	- operation to modify the name and description of a VPC within the specified period of time.
//
// @param request - ModifyVpcAttributeRequest
//
// @return ModifyVpcAttributeResponse
func (client *Client) ModifyVpcAttribute(request *ModifyVpcAttributeRequest) (_result *ModifyVpcAttributeResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ModifyVpcAttributeResponse{}
	_body, _err := client.ModifyVpcAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Modifies the configuration of a prefix list.
//
// Description:
//
//	  **ModifyVpcPrefixList*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListPrefixLists](https://help.aliyun.com/document_detail/311535.html) to query the status of the task.
//
//	    	- If the prefix list is in the **Modifying*	- state, the configuration of the prefix list is being modified.
//
//	    	- If the prefix list is in the **Created*	- state, the configuration of the prefix list is modified.
//
//	    	- After the configuration of the prefix list is modified, you can call the [GetVpcPrefixListAssociations](https://help.aliyun.com/document_detail/445478.html) operation to query the information about the network instances that are associated with the prefix list and determine whether the associated network instances use the new CIDR blocks. If the association **status*	- of the prefix list is **Created**, the new CIDR blocks are used by the network instances that are associated with the prefix list.
//
//		- You cannot repeatedly call **ModifyVpcPrefixList*	- to modify the configuration of a prefix list within the specified period of time.
//
// @param request - ModifyVpcPrefixListRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ModifyVpcPrefixListResponse
func (client *Client) ModifyVpcPrefixListWithOptions(request *ModifyVpcPrefixListRequest, runtime *dara.RuntimeOptions) (_result *ModifyVpcPrefixListResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.AddPrefixListEntry) {
		query["AddPrefixListEntry"] = request.AddPrefixListEntry
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.MaxEntries) {
		query["MaxEntries"] = request.MaxEntries
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PrefixListDescription) {
		query["PrefixListDescription"] = request.PrefixListDescription
	}

	if !dara.IsNil(request.PrefixListId) {
		query["PrefixListId"] = request.PrefixListId
	}

	if !dara.IsNil(request.PrefixListName) {
		query["PrefixListName"] = request.PrefixListName
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.RemovePrefixListEntry) {
		query["RemovePrefixListEntry"] = request.RemovePrefixListEntry
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ModifyVpcPrefixList"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ModifyVpcPrefixListResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Modifies the configuration of a prefix list.
//
// Description:
//
//	  **ModifyVpcPrefixList*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListPrefixLists](https://help.aliyun.com/document_detail/311535.html) to query the status of the task.
//
//	    	- If the prefix list is in the **Modifying*	- state, the configuration of the prefix list is being modified.
//
//	    	- If the prefix list is in the **Created*	- state, the configuration of the prefix list is modified.
//
//	    	- After the configuration of the prefix list is modified, you can call the [GetVpcPrefixListAssociations](https://help.aliyun.com/document_detail/445478.html) operation to query the information about the network instances that are associated with the prefix list and determine whether the associated network instances use the new CIDR blocks. If the association **status*	- of the prefix list is **Created**, the new CIDR blocks are used by the network instances that are associated with the prefix list.
//
//		- You cannot repeatedly call **ModifyVpcPrefixList*	- to modify the configuration of a prefix list within the specified period of time.
//
// @param request - ModifyVpcPrefixListRequest
//
// @return ModifyVpcPrefixListResponse
func (client *Client) ModifyVpcPrefixList(request *ModifyVpcPrefixListRequest) (_result *ModifyVpcPrefixListResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ModifyVpcPrefixListResponse{}
	_body, _err := client.ModifyVpcPrefixListWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Modifies the configuration of an IPsec-VPN connection.
//
// Description:
//
//	  When you modify a IPsec-VPN connection in dual-tunnel mode, you can configure the following parameters in addition to the required request parameters: **ClientToken**, **Name**, **LocalSubnet**, **RemoteSubnet**, **EffectImmediately**, **AutoConfigRoute**, **TunnelOptionsSpecification*	- array, and **EnableTunnelsBgp**.
//
//		- When you modify a IPsec-VPN connection in single tunnel mode, you can configure the following parameters in addition to the required request parameters: **ClientToken**, **Name**, **LocalSubnet**, **RemoteSubnet**, **EffectImmediately**, **IkeConfig**, **IpsecConfig**, **HealthCheckConfig**, **AutoConfigRoute**, **EnableDpd**, **EnableNatTraversal**, **BgpConfig**, and **CustomerGatewayId**.
//
//		- **ModifyVpnAttachmentAttribute*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnConnection](https://help.aliyun.com/document_detail/53046.html) operation to query the status of the task:
//
//	    	- If the IPsec-VPN connection is in the **updating*	- state, the IPsec-VPN connection is being modified.
//
//	    	- If the IPsec-VPN connection is in the **attached*	- state, the IPsec-VPN connection is modified.
//
//		- You cannot concurrently call **ModifyVpnAttachmentAttribute*	- within the specified period of time.
//
//		- You cannot call **ModifyVpnAttachmentAttribute*	- to modify the gateway type of an IPsec-VPN connection.
//
// @param request - ModifyVpnAttachmentAttributeRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ModifyVpnAttachmentAttributeResponse
func (client *Client) ModifyVpnAttachmentAttributeWithOptions(request *ModifyVpnAttachmentAttributeRequest, runtime *dara.RuntimeOptions) (_result *ModifyVpnAttachmentAttributeResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.AutoConfigRoute) {
		query["AutoConfigRoute"] = request.AutoConfigRoute
	}

	if !dara.IsNil(request.BgpConfig) {
		query["BgpConfig"] = request.BgpConfig
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.CustomerGatewayId) {
		query["CustomerGatewayId"] = request.CustomerGatewayId
	}

	if !dara.IsNil(request.EffectImmediately) {
		query["EffectImmediately"] = request.EffectImmediately
	}

	if !dara.IsNil(request.EnableDpd) {
		query["EnableDpd"] = request.EnableDpd
	}

	if !dara.IsNil(request.EnableNatTraversal) {
		query["EnableNatTraversal"] = request.EnableNatTraversal
	}

	if !dara.IsNil(request.EnableTunnelsBgp) {
		query["EnableTunnelsBgp"] = request.EnableTunnelsBgp
	}

	if !dara.IsNil(request.HealthCheckConfig) {
		query["HealthCheckConfig"] = request.HealthCheckConfig
	}

	if !dara.IsNil(request.IkeConfig) {
		query["IkeConfig"] = request.IkeConfig
	}

	if !dara.IsNil(request.IpsecConfig) {
		query["IpsecConfig"] = request.IpsecConfig
	}

	if !dara.IsNil(request.LocalSubnet) {
		query["LocalSubnet"] = request.LocalSubnet
	}

	if !dara.IsNil(request.Name) {
		query["Name"] = request.Name
	}

	if !dara.IsNil(request.NetworkType) {
		query["NetworkType"] = request.NetworkType
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.RemoteCaCert) {
		query["RemoteCaCert"] = request.RemoteCaCert
	}

	if !dara.IsNil(request.RemoteSubnet) {
		query["RemoteSubnet"] = request.RemoteSubnet
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.VpnConnectionId) {
		query["VpnConnectionId"] = request.VpnConnectionId
	}

	body := map[string]interface{}{}
	bodyFlat := map[string]interface{}{}
	if !dara.IsNil(request.TunnelOptionsSpecification) {
		bodyFlat["TunnelOptionsSpecification"] = request.TunnelOptionsSpecification
	}

	body = dara.ToMap(body,
		openapiutil.Query(bodyFlat))
	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
		Body:  openapiutil.ParseToMap(body),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ModifyVpnAttachmentAttribute"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ModifyVpnAttachmentAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Modifies the configuration of an IPsec-VPN connection.
//
// Description:
//
//	  When you modify a IPsec-VPN connection in dual-tunnel mode, you can configure the following parameters in addition to the required request parameters: **ClientToken**, **Name**, **LocalSubnet**, **RemoteSubnet**, **EffectImmediately**, **AutoConfigRoute**, **TunnelOptionsSpecification*	- array, and **EnableTunnelsBgp**.
//
//		- When you modify a IPsec-VPN connection in single tunnel mode, you can configure the following parameters in addition to the required request parameters: **ClientToken**, **Name**, **LocalSubnet**, **RemoteSubnet**, **EffectImmediately**, **IkeConfig**, **IpsecConfig**, **HealthCheckConfig**, **AutoConfigRoute**, **EnableDpd**, **EnableNatTraversal**, **BgpConfig**, and **CustomerGatewayId**.
//
//		- **ModifyVpnAttachmentAttribute*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnConnection](https://help.aliyun.com/document_detail/53046.html) operation to query the status of the task:
//
//	    	- If the IPsec-VPN connection is in the **updating*	- state, the IPsec-VPN connection is being modified.
//
//	    	- If the IPsec-VPN connection is in the **attached*	- state, the IPsec-VPN connection is modified.
//
//		- You cannot concurrently call **ModifyVpnAttachmentAttribute*	- within the specified period of time.
//
//		- You cannot call **ModifyVpnAttachmentAttribute*	- to modify the gateway type of an IPsec-VPN connection.
//
// @param request - ModifyVpnAttachmentAttributeRequest
//
// @return ModifyVpnAttachmentAttributeResponse
func (client *Client) ModifyVpnAttachmentAttribute(request *ModifyVpnAttachmentAttributeRequest) (_result *ModifyVpnAttachmentAttributeResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ModifyVpnAttachmentAttributeResponse{}
	_body, _err := client.ModifyVpnAttachmentAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Modifies the configuration of an IPsec-VPN connection.
//
// Description:
//
//	  If you want to modify a IPsec-VPN connection in dual-tunnel mode, call the `ModifyVpnConnectionAttribute` operation. You can modify the required parameters and the following request parameters:
//
//	    **ClientToken**, **Name**, **LocalSubnet**, **RemoteSubnet**, **EffectImmediately**, **AutoConfigRoute**, **TunnelOptionsSpecification**, and **EnableTunnelsBgp**.
//
//		- If you want to modify a IPsec-VPN connection in single-tunnel mode, call the `ModifyVpnConnectionAttribute` operation. You can modify the required parameters and the following request parameters:
//
//	    **ClientToken**, **Name**, **LocalSubnet**, **RemoteSubnet**, **EffectImmediately**, **IkeConfig**, **IpsecConfig**, **HealthCheckConfig**, **AutoConfigRoute**, **EnableDpd**, **EnableNatTraversal**, **BgpConfig**, and **RemoteCaCertificate**.
//
//		- **ModifyVpnConnectionAttribute*	- is an asynchronous operation. After a request is sent, the system returns a request ID and modifies the configuration of the IPsec-VPN connection in the backend. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) operation to query the status of a VPN gateway.
//
//	    	- If the VPN gateway is in the **updating*	- state, the configuration of the IPsec-VPN connection is being modified.
//
//	    	- If the VPN gateway is in the **active*	- state, the configuration of the IPsec-VPN connection is modified.
//
//		- You cannot repeatedly call the **ModifyVpnConnectionAttribute*	- operation for the same VPN gateway within the specified period of time.
//
// @param request - ModifyVpnConnectionAttributeRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ModifyVpnConnectionAttributeResponse
func (client *Client) ModifyVpnConnectionAttributeWithOptions(request *ModifyVpnConnectionAttributeRequest, runtime *dara.RuntimeOptions) (_result *ModifyVpnConnectionAttributeResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.AutoConfigRoute) {
		query["AutoConfigRoute"] = request.AutoConfigRoute
	}

	if !dara.IsNil(request.BgpConfig) {
		query["BgpConfig"] = request.BgpConfig
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.EffectImmediately) {
		query["EffectImmediately"] = request.EffectImmediately
	}

	if !dara.IsNil(request.EnableDpd) {
		query["EnableDpd"] = request.EnableDpd
	}

	if !dara.IsNil(request.EnableNatTraversal) {
		query["EnableNatTraversal"] = request.EnableNatTraversal
	}

	if !dara.IsNil(request.EnableTunnelsBgp) {
		query["EnableTunnelsBgp"] = request.EnableTunnelsBgp
	}

	if !dara.IsNil(request.HealthCheckConfig) {
		query["HealthCheckConfig"] = request.HealthCheckConfig
	}

	if !dara.IsNil(request.IkeConfig) {
		query["IkeConfig"] = request.IkeConfig
	}

	if !dara.IsNil(request.IpsecConfig) {
		query["IpsecConfig"] = request.IpsecConfig
	}

	if !dara.IsNil(request.LocalSubnet) {
		query["LocalSubnet"] = request.LocalSubnet
	}

	if !dara.IsNil(request.Name) {
		query["Name"] = request.Name
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.RemoteCaCertificate) {
		query["RemoteCaCertificate"] = request.RemoteCaCertificate
	}

	if !dara.IsNil(request.RemoteSubnet) {
		query["RemoteSubnet"] = request.RemoteSubnet
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.VpnConnectionId) {
		query["VpnConnectionId"] = request.VpnConnectionId
	}

	body := map[string]interface{}{}
	bodyFlat := map[string]interface{}{}
	if !dara.IsNil(request.TunnelOptionsSpecification) {
		bodyFlat["TunnelOptionsSpecification"] = request.TunnelOptionsSpecification
	}

	body = dara.ToMap(body,
		openapiutil.Query(bodyFlat))
	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
		Body:  openapiutil.ParseToMap(body),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ModifyVpnConnectionAttribute"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ModifyVpnConnectionAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Modifies the configuration of an IPsec-VPN connection.
//
// Description:
//
//	  If you want to modify a IPsec-VPN connection in dual-tunnel mode, call the `ModifyVpnConnectionAttribute` operation. You can modify the required parameters and the following request parameters:
//
//	    **ClientToken**, **Name**, **LocalSubnet**, **RemoteSubnet**, **EffectImmediately**, **AutoConfigRoute**, **TunnelOptionsSpecification**, and **EnableTunnelsBgp**.
//
//		- If you want to modify a IPsec-VPN connection in single-tunnel mode, call the `ModifyVpnConnectionAttribute` operation. You can modify the required parameters and the following request parameters:
//
//	    **ClientToken**, **Name**, **LocalSubnet**, **RemoteSubnet**, **EffectImmediately**, **IkeConfig**, **IpsecConfig**, **HealthCheckConfig**, **AutoConfigRoute**, **EnableDpd**, **EnableNatTraversal**, **BgpConfig**, and **RemoteCaCertificate**.
//
//		- **ModifyVpnConnectionAttribute*	- is an asynchronous operation. After a request is sent, the system returns a request ID and modifies the configuration of the IPsec-VPN connection in the backend. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) operation to query the status of a VPN gateway.
//
//	    	- If the VPN gateway is in the **updating*	- state, the configuration of the IPsec-VPN connection is being modified.
//
//	    	- If the VPN gateway is in the **active*	- state, the configuration of the IPsec-VPN connection is modified.
//
//		- You cannot repeatedly call the **ModifyVpnConnectionAttribute*	- operation for the same VPN gateway within the specified period of time.
//
// @param request - ModifyVpnConnectionAttributeRequest
//
// @return ModifyVpnConnectionAttributeResponse
func (client *Client) ModifyVpnConnectionAttribute(request *ModifyVpnConnectionAttributeRequest) (_result *ModifyVpnConnectionAttributeResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ModifyVpnConnectionAttributeResponse{}
	_body, _err := client.ModifyVpnConnectionAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Modifies the name and description of a VPN gateway.
//
// Description:
//
//	  **ModifyVpnGatewayAttribute*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
//
//	    	- If the VPN gateway is in the **updating*	- state, the VPN gateway is being modified.
//
//	    	- If the VPN gateway is in the **active*	- state, the VPN gateway is modified.
//
//		- You cannot repeatedly call **ModifyVpnGatewayAttribute*	- to modify a VPN gateway within the specified period of time.
//
// @param request - ModifyVpnGatewayAttributeRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ModifyVpnGatewayAttributeResponse
func (client *Client) ModifyVpnGatewayAttributeWithOptions(request *ModifyVpnGatewayAttributeRequest, runtime *dara.RuntimeOptions) (_result *ModifyVpnGatewayAttributeResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.AutoPropagate) {
		query["AutoPropagate"] = request.AutoPropagate
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.Description) {
		query["Description"] = request.Description
	}

	if !dara.IsNil(request.Name) {
		query["Name"] = request.Name
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.VpnGatewayId) {
		query["VpnGatewayId"] = request.VpnGatewayId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ModifyVpnGatewayAttribute"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ModifyVpnGatewayAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Modifies the name and description of a VPN gateway.
//
// Description:
//
//	  **ModifyVpnGatewayAttribute*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
//
//	    	- If the VPN gateway is in the **updating*	- state, the VPN gateway is being modified.
//
//	    	- If the VPN gateway is in the **active*	- state, the VPN gateway is modified.
//
//		- You cannot repeatedly call **ModifyVpnGatewayAttribute*	- to modify a VPN gateway within the specified period of time.
//
// @param request - ModifyVpnGatewayAttributeRequest
//
// @return ModifyVpnGatewayAttributeResponse
func (client *Client) ModifyVpnGatewayAttribute(request *ModifyVpnGatewayAttributeRequest) (_result *ModifyVpnGatewayAttributeResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ModifyVpnGatewayAttributeResponse{}
	_body, _err := client.ModifyVpnGatewayAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Modifies the weight and priority of a policy-based route.
//
// Description:
//
//	  You can call the **ModifyVpnPbrRouteEntryAttribute*	- operation to modify the weight and priority of a policy-based route.
//
//	    	- If you want to modify only the weight of a policy-based route, call [ModifyVpnPbrRouteEntryWeight](https://help.aliyun.com/document_detail/127249.html).
//
//	    	- If you want to modify only the priority of a policy-based route, call [ModifyVpnPbrRouteEntryPriority](https://help.aliyun.com/document_detail/466870.html).
//
//	    	- If a policy-based route does not support priorities, you can only call [ModifyVpnPbrRouteEntryWeight](https://help.aliyun.com/document_detail/127249.html) to modify its weight.
//
//		- The **ModifyVpnPbrRouteEntryAttribute*	- operation is asynchronous. After you send a request, the system returns a request ID, but the operation is still being performed in the system background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of a VPN gateway.
//
//	    	- If a VPN gateway is in the **updating*	- state, the policy-based route entry is being modified.
//
//	    	- If a VPN gateway is in the **active*	- state, the policy-based route entry is modified.
//
//		- You cannot repeatedly call the **ModifyVpnPbrRouteEntryAttribute*	- operation for the same VPN gateway within the specified period of time.
//
// @param request - ModifyVpnPbrRouteEntryAttributeRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ModifyVpnPbrRouteEntryAttributeResponse
func (client *Client) ModifyVpnPbrRouteEntryAttributeWithOptions(request *ModifyVpnPbrRouteEntryAttributeRequest, runtime *dara.RuntimeOptions) (_result *ModifyVpnPbrRouteEntryAttributeResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.NewPriority) {
		query["NewPriority"] = request.NewPriority
	}

	if !dara.IsNil(request.NewWeight) {
		query["NewWeight"] = request.NewWeight
	}

	if !dara.IsNil(request.NextHop) {
		query["NextHop"] = request.NextHop
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.Priority) {
		query["Priority"] = request.Priority
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.RouteDest) {
		query["RouteDest"] = request.RouteDest
	}

	if !dara.IsNil(request.RouteSource) {
		query["RouteSource"] = request.RouteSource
	}

	if !dara.IsNil(request.VpnGatewayId) {
		query["VpnGatewayId"] = request.VpnGatewayId
	}

	if !dara.IsNil(request.Weight) {
		query["Weight"] = request.Weight
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ModifyVpnPbrRouteEntryAttribute"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ModifyVpnPbrRouteEntryAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Modifies the weight and priority of a policy-based route.
//
// Description:
//
//	  You can call the **ModifyVpnPbrRouteEntryAttribute*	- operation to modify the weight and priority of a policy-based route.
//
//	    	- If you want to modify only the weight of a policy-based route, call [ModifyVpnPbrRouteEntryWeight](https://help.aliyun.com/document_detail/127249.html).
//
//	    	- If you want to modify only the priority of a policy-based route, call [ModifyVpnPbrRouteEntryPriority](https://help.aliyun.com/document_detail/466870.html).
//
//	    	- If a policy-based route does not support priorities, you can only call [ModifyVpnPbrRouteEntryWeight](https://help.aliyun.com/document_detail/127249.html) to modify its weight.
//
//		- The **ModifyVpnPbrRouteEntryAttribute*	- operation is asynchronous. After you send a request, the system returns a request ID, but the operation is still being performed in the system background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of a VPN gateway.
//
//	    	- If a VPN gateway is in the **updating*	- state, the policy-based route entry is being modified.
//
//	    	- If a VPN gateway is in the **active*	- state, the policy-based route entry is modified.
//
//		- You cannot repeatedly call the **ModifyVpnPbrRouteEntryAttribute*	- operation for the same VPN gateway within the specified period of time.
//
// @param request - ModifyVpnPbrRouteEntryAttributeRequest
//
// @return ModifyVpnPbrRouteEntryAttributeResponse
func (client *Client) ModifyVpnPbrRouteEntryAttribute(request *ModifyVpnPbrRouteEntryAttributeRequest) (_result *ModifyVpnPbrRouteEntryAttributeResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ModifyVpnPbrRouteEntryAttributeResponse{}
	_body, _err := client.ModifyVpnPbrRouteEntryAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Modifies the priority of a policy-based route.
//
// Description:
//
//	  **ModifyVpnPbrRouteEntryPriority*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
//
//	    	- If a VPN gateway is in the **updating*	- state, the policy-based route entry is being modified.
//
//	    	- If the VPN gateway is in the **active*	- state, the policy-based route is created.
//
//		- You cannot repeatedly call the **ModifyVpnPbrRouteEntryPriority*	- operation for the same VPN gateway within the specified period of time.
//
// @param request - ModifyVpnPbrRouteEntryPriorityRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ModifyVpnPbrRouteEntryPriorityResponse
func (client *Client) ModifyVpnPbrRouteEntryPriorityWithOptions(request *ModifyVpnPbrRouteEntryPriorityRequest, runtime *dara.RuntimeOptions) (_result *ModifyVpnPbrRouteEntryPriorityResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.NewPriority) {
		query["NewPriority"] = request.NewPriority
	}

	if !dara.IsNil(request.NextHop) {
		query["NextHop"] = request.NextHop
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.Priority) {
		query["Priority"] = request.Priority
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.RouteDest) {
		query["RouteDest"] = request.RouteDest
	}

	if !dara.IsNil(request.RouteSource) {
		query["RouteSource"] = request.RouteSource
	}

	if !dara.IsNil(request.VpnGatewayId) {
		query["VpnGatewayId"] = request.VpnGatewayId
	}

	if !dara.IsNil(request.Weight) {
		query["Weight"] = request.Weight
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ModifyVpnPbrRouteEntryPriority"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ModifyVpnPbrRouteEntryPriorityResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Modifies the priority of a policy-based route.
//
// Description:
//
//	  **ModifyVpnPbrRouteEntryPriority*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
//
//	    	- If a VPN gateway is in the **updating*	- state, the policy-based route entry is being modified.
//
//	    	- If the VPN gateway is in the **active*	- state, the policy-based route is created.
//
//		- You cannot repeatedly call the **ModifyVpnPbrRouteEntryPriority*	- operation for the same VPN gateway within the specified period of time.
//
// @param request - ModifyVpnPbrRouteEntryPriorityRequest
//
// @return ModifyVpnPbrRouteEntryPriorityResponse
func (client *Client) ModifyVpnPbrRouteEntryPriority(request *ModifyVpnPbrRouteEntryPriorityRequest) (_result *ModifyVpnPbrRouteEntryPriorityResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ModifyVpnPbrRouteEntryPriorityResponse{}
	_body, _err := client.ModifyVpnPbrRouteEntryPriorityWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Modifies the weight of a policy-based route of a VPN gateway.
//
// Description:
//
//	  **ModifyVpnPbrRouteEntryWeight*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
//
//	    	- If a VPN gateway is in the **updating*	- state, the policy-based route entry is being modified.
//
//	    	- If a VPN gateway is in the **active*	- state, the policy-based route entry is modified.
//
//		- You cannot repeatedly call the **ModifyVpnPbrRouteEntryWeight*	- operation for the same VPN gateway within the specified period of time.
//
// @param request - ModifyVpnPbrRouteEntryWeightRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ModifyVpnPbrRouteEntryWeightResponse
func (client *Client) ModifyVpnPbrRouteEntryWeightWithOptions(request *ModifyVpnPbrRouteEntryWeightRequest, runtime *dara.RuntimeOptions) (_result *ModifyVpnPbrRouteEntryWeightResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.NewWeight) {
		query["NewWeight"] = request.NewWeight
	}

	if !dara.IsNil(request.NextHop) {
		query["NextHop"] = request.NextHop
	}

	if !dara.IsNil(request.OverlayMode) {
		query["OverlayMode"] = request.OverlayMode
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.Priority) {
		query["Priority"] = request.Priority
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.RouteDest) {
		query["RouteDest"] = request.RouteDest
	}

	if !dara.IsNil(request.RouteSource) {
		query["RouteSource"] = request.RouteSource
	}

	if !dara.IsNil(request.VpnGatewayId) {
		query["VpnGatewayId"] = request.VpnGatewayId
	}

	if !dara.IsNil(request.Weight) {
		query["Weight"] = request.Weight
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ModifyVpnPbrRouteEntryWeight"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ModifyVpnPbrRouteEntryWeightResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Modifies the weight of a policy-based route of a VPN gateway.
//
// Description:
//
//	  **ModifyVpnPbrRouteEntryWeight*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
//
//	    	- If a VPN gateway is in the **updating*	- state, the policy-based route entry is being modified.
//
//	    	- If a VPN gateway is in the **active*	- state, the policy-based route entry is modified.
//
//		- You cannot repeatedly call the **ModifyVpnPbrRouteEntryWeight*	- operation for the same VPN gateway within the specified period of time.
//
// @param request - ModifyVpnPbrRouteEntryWeightRequest
//
// @return ModifyVpnPbrRouteEntryWeightResponse
func (client *Client) ModifyVpnPbrRouteEntryWeight(request *ModifyVpnPbrRouteEntryWeightRequest) (_result *ModifyVpnPbrRouteEntryWeightResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ModifyVpnPbrRouteEntryWeightResponse{}
	_body, _err := client.ModifyVpnPbrRouteEntryWeightWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Modifies the weight of a destination-based route.
//
// Description:
//
//	  In scenarios where a VPN gateway has an active and a standby destination-based route, if you need to modify the weight of the active destination-based route, you must first delete the standby destination-based route. After you modify the active destination-based route, configure a standby destination-based route. If you need to modify the weight of the standby destination-based route, you also need to delete the active destination-based route first. After you modify the standby destination-based route, configure an active destination-based route. For more information about how to delete a destination-based route, see [DeleteVpnRouteEntry](https://help.aliyun.com/document_detail/2526961.html).
//
//		- **ModifyVpnRouteEntryWeight*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
//
//	    	- If the VPN gateway is in the **updating*	- state, the weight of the destination-based route is being modified.
//
//	    	- If the VPN gateway is in the **active*	- state, the weight of the destination-based route is modified.
//
//		- You cannot repeatedly call the **ModifyVpnRouteEntryWeight*	- operation to modify the weight of destination-based route for the same VPN gateway within the specified period of time.
//
// @param request - ModifyVpnRouteEntryWeightRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ModifyVpnRouteEntryWeightResponse
func (client *Client) ModifyVpnRouteEntryWeightWithOptions(request *ModifyVpnRouteEntryWeightRequest, runtime *dara.RuntimeOptions) (_result *ModifyVpnRouteEntryWeightResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.NewWeight) {
		query["NewWeight"] = request.NewWeight
	}

	if !dara.IsNil(request.NextHop) {
		query["NextHop"] = request.NextHop
	}

	if !dara.IsNil(request.OverlayMode) {
		query["OverlayMode"] = request.OverlayMode
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.RouteDest) {
		query["RouteDest"] = request.RouteDest
	}

	if !dara.IsNil(request.VpnGatewayId) {
		query["VpnGatewayId"] = request.VpnGatewayId
	}

	if !dara.IsNil(request.Weight) {
		query["Weight"] = request.Weight
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ModifyVpnRouteEntryWeight"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ModifyVpnRouteEntryWeightResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Modifies the weight of a destination-based route.
//
// Description:
//
//	  In scenarios where a VPN gateway has an active and a standby destination-based route, if you need to modify the weight of the active destination-based route, you must first delete the standby destination-based route. After you modify the active destination-based route, configure a standby destination-based route. If you need to modify the weight of the standby destination-based route, you also need to delete the active destination-based route first. After you modify the standby destination-based route, configure an active destination-based route. For more information about how to delete a destination-based route, see [DeleteVpnRouteEntry](https://help.aliyun.com/document_detail/2526961.html).
//
//		- **ModifyVpnRouteEntryWeight*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
//
//	    	- If the VPN gateway is in the **updating*	- state, the weight of the destination-based route is being modified.
//
//	    	- If the VPN gateway is in the **active*	- state, the weight of the destination-based route is modified.
//
//		- You cannot repeatedly call the **ModifyVpnRouteEntryWeight*	- operation to modify the weight of destination-based route for the same VPN gateway within the specified period of time.
//
// @param request - ModifyVpnRouteEntryWeightRequest
//
// @return ModifyVpnRouteEntryWeightResponse
func (client *Client) ModifyVpnRouteEntryWeight(request *ModifyVpnRouteEntryWeightRequest) (_result *ModifyVpnRouteEntryWeightResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ModifyVpnRouteEntryWeightResponse{}
	_body, _err := client.ModifyVpnRouteEntryWeightWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Moves a resource to another resource group.
//
// @param request - MoveResourceGroupRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return MoveResourceGroupResponse
func (client *Client) MoveResourceGroupWithOptions(request *MoveResourceGroupRequest, runtime *dara.RuntimeOptions) (_result *MoveResourceGroupResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.NewResourceGroupId) {
		query["NewResourceGroupId"] = request.NewResourceGroupId
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceId) {
		query["ResourceId"] = request.ResourceId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.ResourceType) {
		query["ResourceType"] = request.ResourceType
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("MoveResourceGroup"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &MoveResourceGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Moves a resource to another resource group.
//
// @param request - MoveResourceGroupRequest
//
// @return MoveResourceGroupResponse
func (client *Client) MoveResourceGroup(request *MoveResourceGroupRequest) (_result *MoveResourceGroupResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &MoveResourceGroupResponse{}
	_body, _err := client.MoveResourceGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Moves a VPN gateway resource to a new resource group.
//
// @param request - MoveVpnResourceGroupRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return MoveVpnResourceGroupResponse
func (client *Client) MoveVpnResourceGroupWithOptions(request *MoveVpnResourceGroupRequest, runtime *dara.RuntimeOptions) (_result *MoveVpnResourceGroupResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.InstanceId) {
		query["InstanceId"] = request.InstanceId
	}

	if !dara.IsNil(request.NewResourceGroupId) {
		query["NewResourceGroupId"] = request.NewResourceGroupId
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.ResourceType) {
		query["ResourceType"] = request.ResourceType
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("MoveVpnResourceGroup"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &MoveVpnResourceGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Moves a VPN gateway resource to a new resource group.
//
// @param request - MoveVpnResourceGroupRequest
//
// @return MoveVpnResourceGroupResponse
func (client *Client) MoveVpnResourceGroup(request *MoveVpnResourceGroupRequest) (_result *MoveVpnResourceGroupResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &MoveVpnResourceGroupResponse{}
	_body, _err := client.MoveVpnResourceGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Enables the flow log feature.
//
// Description:
//
//	  You cannot repeatedly call the **OpenFlowLogService*	- operation within the specified period of time by using an Alibaba Cloud account.
//
//		- You can call the [GetFlowLogServiceStatus](https://help.aliyun.com/document_detail/449624.html) operation to query the status of the flow log feature.
//
// @param request - OpenFlowLogServiceRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return OpenFlowLogServiceResponse
func (client *Client) OpenFlowLogServiceWithOptions(request *OpenFlowLogServiceRequest, runtime *dara.RuntimeOptions) (_result *OpenFlowLogServiceResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("OpenFlowLogService"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &OpenFlowLogServiceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Enables the flow log feature.
//
// Description:
//
//	  You cannot repeatedly call the **OpenFlowLogService*	- operation within the specified period of time by using an Alibaba Cloud account.
//
//		- You can call the [GetFlowLogServiceStatus](https://help.aliyun.com/document_detail/449624.html) operation to query the status of the flow log feature.
//
// @param request - OpenFlowLogServiceRequest
//
// @return OpenFlowLogServiceResponse
func (client *Client) OpenFlowLogService(request *OpenFlowLogServiceRequest) (_result *OpenFlowLogServiceResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &OpenFlowLogServiceResponse{}
	_body, _err := client.OpenFlowLogServiceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Enables billing for outbound data transfer.
//
// @param request - OpenPhysicalConnectionServiceRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return OpenPhysicalConnectionServiceResponse
func (client *Client) OpenPhysicalConnectionServiceWithOptions(request *OpenPhysicalConnectionServiceRequest, runtime *dara.RuntimeOptions) (_result *OpenPhysicalConnectionServiceResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("OpenPhysicalConnectionService"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &OpenPhysicalConnectionServiceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Enables billing for outbound data transfer.
//
// @param request - OpenPhysicalConnectionServiceRequest
//
// @return OpenPhysicalConnectionServiceResponse
func (client *Client) OpenPhysicalConnectionService(request *OpenPhysicalConnectionServiceRequest) (_result *OpenPhysicalConnectionServiceResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &OpenPhysicalConnectionServiceResponse{}
	_body, _err := client.OpenPhysicalConnectionServiceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// IP
//
// @param request - OpenPublicIpAddressPoolServiceRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return OpenPublicIpAddressPoolServiceResponse
func (client *Client) OpenPublicIpAddressPoolServiceWithOptions(request *OpenPublicIpAddressPoolServiceRequest, runtime *dara.RuntimeOptions) (_result *OpenPublicIpAddressPoolServiceResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("OpenPublicIpAddressPoolService"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &OpenPublicIpAddressPoolServiceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// IP
//
// @param request - OpenPublicIpAddressPoolServiceRequest
//
// @return OpenPublicIpAddressPoolServiceResponse
func (client *Client) OpenPublicIpAddressPoolService(request *OpenPublicIpAddressPoolServiceRequest) (_result *OpenPublicIpAddressPoolServiceResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &OpenPublicIpAddressPoolServiceResponse{}
	_body, _err := client.OpenPublicIpAddressPoolServiceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Enables traffic mirror.
//
// Description:
//
// ## [](#)Usage notes
//
// You can enable traffic mirror for different regions. You cannot repeatedly call the **OpenTrafficMirrorService*	- operation to enable traffic mirror for one region within the specified period of time.
//
// @param request - OpenTrafficMirrorServiceRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return OpenTrafficMirrorServiceResponse
func (client *Client) OpenTrafficMirrorServiceWithOptions(request *OpenTrafficMirrorServiceRequest, runtime *dara.RuntimeOptions) (_result *OpenTrafficMirrorServiceResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("OpenTrafficMirrorService"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &OpenTrafficMirrorServiceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Enables traffic mirror.
//
// Description:
//
// ## [](#)Usage notes
//
// You can enable traffic mirror for different regions. You cannot repeatedly call the **OpenTrafficMirrorService*	- operation to enable traffic mirror for one region within the specified period of time.
//
// @param request - OpenTrafficMirrorServiceRequest
//
// @return OpenTrafficMirrorServiceResponse
func (client *Client) OpenTrafficMirrorService(request *OpenTrafficMirrorServiceRequest) (_result *OpenTrafficMirrorServiceResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &OpenTrafficMirrorServiceResponse{}
	_body, _err := client.OpenTrafficMirrorServiceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Advertises VPC routes to an external component.
//
// @param request - PublishVpcRouteEntriesRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return PublishVpcRouteEntriesResponse
func (client *Client) PublishVpcRouteEntriesWithOptions(request *PublishVpcRouteEntriesRequest, runtime *dara.RuntimeOptions) (_result *PublishVpcRouteEntriesResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.RouteEntries) {
		query["RouteEntries"] = request.RouteEntries
	}

	if !dara.IsNil(request.TargetInstanceId) {
		query["TargetInstanceId"] = request.TargetInstanceId
	}

	if !dara.IsNil(request.TargetType) {
		query["TargetType"] = request.TargetType
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("PublishVpcRouteEntries"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &PublishVpcRouteEntriesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Advertises VPC routes to an external component.
//
// @param request - PublishVpcRouteEntriesRequest
//
// @return PublishVpcRouteEntriesResponse
func (client *Client) PublishVpcRouteEntries(request *PublishVpcRouteEntriesRequest) (_result *PublishVpcRouteEntriesResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &PublishVpcRouteEntriesResponse{}
	_body, _err := client.PublishVpcRouteEntriesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Advertises a VPN route to a VPC.
//
// @param request - PublishVpnRouteEntryRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return PublishVpnRouteEntryResponse
func (client *Client) PublishVpnRouteEntryWithOptions(request *PublishVpnRouteEntryRequest, runtime *dara.RuntimeOptions) (_result *PublishVpnRouteEntryResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.NextHop) {
		query["NextHop"] = request.NextHop
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PublishVpc) {
		query["PublishVpc"] = request.PublishVpc
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.RouteDest) {
		query["RouteDest"] = request.RouteDest
	}

	if !dara.IsNil(request.RouteType) {
		query["RouteType"] = request.RouteType
	}

	if !dara.IsNil(request.VpnGatewayId) {
		query["VpnGatewayId"] = request.VpnGatewayId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("PublishVpnRouteEntry"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &PublishVpnRouteEntryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Advertises a VPN route to a VPC.
//
// @param request - PublishVpnRouteEntryRequest
//
// @return PublishVpnRouteEntryResponse
func (client *Client) PublishVpnRouteEntry(request *PublishVpnRouteEntryRequest) (_result *PublishVpnRouteEntryResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &PublishVpnRouteEntryResponse{}
	_body, _err := client.PublishVpnRouteEntryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Resumes an Express Connect circuit.
//
// Description:
//
// # [](#)Description
//
// You can call this API operation to resume a suspended Express Connect circuit. You can resume only shared Express Connect circuits by calling this API operation.
//
// @param request - RecoverPhysicalConnectionRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return RecoverPhysicalConnectionResponse
func (client *Client) RecoverPhysicalConnectionWithOptions(request *RecoverPhysicalConnectionRequest, runtime *dara.RuntimeOptions) (_result *RecoverPhysicalConnectionResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.InstanceId) {
		query["InstanceId"] = request.InstanceId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.Token) {
		query["Token"] = request.Token
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("RecoverPhysicalConnection"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &RecoverPhysicalConnectionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Resumes an Express Connect circuit.
//
// Description:
//
// # [](#)Description
//
// You can call this API operation to resume a suspended Express Connect circuit. You can resume only shared Express Connect circuits by calling this API operation.
//
// @param request - RecoverPhysicalConnectionRequest
//
// @return RecoverPhysicalConnectionResponse
func (client *Client) RecoverPhysicalConnection(request *RecoverPhysicalConnectionRequest) (_result *RecoverPhysicalConnectionResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &RecoverPhysicalConnectionResponse{}
	_body, _err := client.RecoverPhysicalConnectionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Enables a disabled virtual border router (VBR).
//
// Description:
//
// After you call this operation, the VBR changes from the **terminated*	- state to the **recovering*	- state. After the operation is performed, the VBR enters the **active*	- state.
//
// When you call this operation, take note of the following items:
//
//   - Only the owner of the Express Connect circuit can call this operation.
//
//   - The Express Connect circuit to which the VBR connects must be in the **Enabled*	- state.
//
// @param request - RecoverVirtualBorderRouterRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return RecoverVirtualBorderRouterResponse
func (client *Client) RecoverVirtualBorderRouterWithOptions(request *RecoverVirtualBorderRouterRequest, runtime *dara.RuntimeOptions) (_result *RecoverVirtualBorderRouterResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.VbrId) {
		query["VbrId"] = request.VbrId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("RecoverVirtualBorderRouter"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &RecoverVirtualBorderRouterResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Enables a disabled virtual border router (VBR).
//
// Description:
//
// After you call this operation, the VBR changes from the **terminated*	- state to the **recovering*	- state. After the operation is performed, the VBR enters the **active*	- state.
//
// When you call this operation, take note of the following items:
//
//   - Only the owner of the Express Connect circuit can call this operation.
//
//   - The Express Connect circuit to which the VBR connects must be in the **Enabled*	- state.
//
// @param request - RecoverVirtualBorderRouterRequest
//
// @return RecoverVirtualBorderRouterResponse
func (client *Client) RecoverVirtualBorderRouter(request *RecoverVirtualBorderRouterRequest) (_result *RecoverVirtualBorderRouterResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &RecoverVirtualBorderRouterResponse{}
	_body, _err := client.RecoverVirtualBorderRouterWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Releases an elastic IP address (EIP).
//
// Description:
//
// Before you call this operation, take note of the following items:
//
//   - Before you release an EIP, make sure that the EIP meets the following requirements:
//
//   - You can release only an EIP that is in the **Available*	- state.
//
//   - You can release only a pay-as-you-go EIP. You cannot release a subscription EIP.
//
//   - **ReleaseEipAddress*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeEipAddresses](https://help.aliyun.com/document_detail/120193.html) operation to query the status of the task:
//
//   - If the EIP is in the **Releasing*	- state, the EIP is being released. In this state, you can only query the EIP and cannot perform other operations.
//
//   - If you cannot query the EIP, the EIP is released.
//
//   - You cannot repeatedly call the **ReleaseEipAddress*	- operation to release an EIP within the specified period of time.
//
// @param request - ReleaseEipAddressRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ReleaseEipAddressResponse
func (client *Client) ReleaseEipAddressWithOptions(request *ReleaseEipAddressRequest, runtime *dara.RuntimeOptions) (_result *ReleaseEipAddressResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.AllocationId) {
		query["AllocationId"] = request.AllocationId
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ReleaseEipAddress"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ReleaseEipAddressResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Releases an elastic IP address (EIP).
//
// Description:
//
// Before you call this operation, take note of the following items:
//
//   - Before you release an EIP, make sure that the EIP meets the following requirements:
//
//   - You can release only an EIP that is in the **Available*	- state.
//
//   - You can release only a pay-as-you-go EIP. You cannot release a subscription EIP.
//
//   - **ReleaseEipAddress*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeEipAddresses](https://help.aliyun.com/document_detail/120193.html) operation to query the status of the task:
//
//   - If the EIP is in the **Releasing*	- state, the EIP is being released. In this state, you can only query the EIP and cannot perform other operations.
//
//   - If you cannot query the EIP, the EIP is released.
//
//   - You cannot repeatedly call the **ReleaseEipAddress*	- operation to release an EIP within the specified period of time.
//
// @param request - ReleaseEipAddressRequest
//
// @return ReleaseEipAddressResponse
func (client *Client) ReleaseEipAddress(request *ReleaseEipAddressRequest) (_result *ReleaseEipAddressResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ReleaseEipAddressResponse{}
	_body, _err := client.ReleaseEipAddressWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Releases contiguous elastic IP addresses (EIPs).
//
// Description:
//
//	  After you call the **ReleaseEipSegmentAddress*	- operation, all EIPs in the specified group are released.
//
//		- **ReleaseEipSegmentAddress*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeEipSegment](https://help.aliyun.com/document_detail/156063.html) operation to query the status of the task.
//
//	    	- If the group is in the **Releasing*	- state, EIPs in the group are being released. In this state, you can only query the group and cannot perform other operations.
//
//	    	- If you cannot query the group of contiguous EIPs, the contiguous EIPs are released.
//
//		- You cannot repeatedly call the **ReleaseEipSegmentAddress*	- operation to release a group of contiguous EIPs within the specified period of time.
//
// @param request - ReleaseEipSegmentAddressRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ReleaseEipSegmentAddressResponse
func (client *Client) ReleaseEipSegmentAddressWithOptions(request *ReleaseEipSegmentAddressRequest, runtime *dara.RuntimeOptions) (_result *ReleaseEipSegmentAddressResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.SegmentInstanceId) {
		query["SegmentInstanceId"] = request.SegmentInstanceId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ReleaseEipSegmentAddress"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ReleaseEipSegmentAddressResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Releases contiguous elastic IP addresses (EIPs).
//
// Description:
//
//	  After you call the **ReleaseEipSegmentAddress*	- operation, all EIPs in the specified group are released.
//
//		- **ReleaseEipSegmentAddress*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeEipSegment](https://help.aliyun.com/document_detail/156063.html) operation to query the status of the task.
//
//	    	- If the group is in the **Releasing*	- state, EIPs in the group are being released. In this state, you can only query the group and cannot perform other operations.
//
//	    	- If you cannot query the group of contiguous EIPs, the contiguous EIPs are released.
//
//		- You cannot repeatedly call the **ReleaseEipSegmentAddress*	- operation to release a group of contiguous EIPs within the specified period of time.
//
// @param request - ReleaseEipSegmentAddressRequest
//
// @return ReleaseEipSegmentAddressResponse
func (client *Client) ReleaseEipSegmentAddress(request *ReleaseEipSegmentAddressRequest) (_result *ReleaseEipSegmentAddressResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ReleaseEipSegmentAddressResponse{}
	_body, _err := client.ReleaseEipSegmentAddressWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Releases an idle IPv6 address.
//
// @param request - ReleaseIpv6AddressRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ReleaseIpv6AddressResponse
func (client *Client) ReleaseIpv6AddressWithOptions(request *ReleaseIpv6AddressRequest, runtime *dara.RuntimeOptions) (_result *ReleaseIpv6AddressResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.Ipv6AddressId) {
		query["Ipv6AddressId"] = request.Ipv6AddressId
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ReleaseIpv6Address"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ReleaseIpv6AddressResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Releases an idle IPv6 address.
//
// @param request - ReleaseIpv6AddressRequest
//
// @return ReleaseIpv6AddressResponse
func (client *Client) ReleaseIpv6Address(request *ReleaseIpv6AddressRequest) (_result *ReleaseIpv6AddressResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ReleaseIpv6AddressResponse{}
	_body, _err := client.ReleaseIpv6AddressWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Disassociates an EIP from an Internet Shared Bandwidth instance.
//
// @param request - RemoveCommonBandwidthPackageIpRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return RemoveCommonBandwidthPackageIpResponse
func (client *Client) RemoveCommonBandwidthPackageIpWithOptions(request *RemoveCommonBandwidthPackageIpRequest, runtime *dara.RuntimeOptions) (_result *RemoveCommonBandwidthPackageIpResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.BandwidthPackageId) {
		query["BandwidthPackageId"] = request.BandwidthPackageId
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.IpInstanceId) {
		query["IpInstanceId"] = request.IpInstanceId
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("RemoveCommonBandwidthPackageIp"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &RemoveCommonBandwidthPackageIpResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Disassociates an EIP from an Internet Shared Bandwidth instance.
//
// @param request - RemoveCommonBandwidthPackageIpRequest
//
// @return RemoveCommonBandwidthPackageIpResponse
func (client *Client) RemoveCommonBandwidthPackageIp(request *RemoveCommonBandwidthPackageIpRequest) (_result *RemoveCommonBandwidthPackageIpResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &RemoveCommonBandwidthPackageIpResponse{}
	_body, _err := client.RemoveCommonBandwidthPackageIpWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// @param request - RemoveGlobalAccelerationInstanceIpRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return RemoveGlobalAccelerationInstanceIpResponse
func (client *Client) RemoveGlobalAccelerationInstanceIpWithOptions(request *RemoveGlobalAccelerationInstanceIpRequest, runtime *dara.RuntimeOptions) (_result *RemoveGlobalAccelerationInstanceIpResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.GlobalAccelerationInstanceId) {
		query["GlobalAccelerationInstanceId"] = request.GlobalAccelerationInstanceId
	}

	if !dara.IsNil(request.IpInstanceId) {
		query["IpInstanceId"] = request.IpInstanceId
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("RemoveGlobalAccelerationInstanceIp"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &RemoveGlobalAccelerationInstanceIpResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// @param request - RemoveGlobalAccelerationInstanceIpRequest
//
// @return RemoveGlobalAccelerationInstanceIpResponse
func (client *Client) RemoveGlobalAccelerationInstanceIp(request *RemoveGlobalAccelerationInstanceIpRequest) (_result *RemoveGlobalAccelerationInstanceIpResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &RemoveGlobalAccelerationInstanceIpResponse{}
	_body, _err := client.RemoveGlobalAccelerationInstanceIpWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes an IP entry from an ACL.
//
// @param request - RemoveIPv6TranslatorAclListEntryRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return RemoveIPv6TranslatorAclListEntryResponse
func (client *Client) RemoveIPv6TranslatorAclListEntryWithOptions(request *RemoveIPv6TranslatorAclListEntryRequest, runtime *dara.RuntimeOptions) (_result *RemoveIPv6TranslatorAclListEntryResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.AclEntryId) {
		query["AclEntryId"] = request.AclEntryId
	}

	if !dara.IsNil(request.AclId) {
		query["AclId"] = request.AclId
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("RemoveIPv6TranslatorAclListEntry"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &RemoveIPv6TranslatorAclListEntryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Deletes an IP entry from an ACL.
//
// @param request - RemoveIPv6TranslatorAclListEntryRequest
//
// @return RemoveIPv6TranslatorAclListEntryResponse
func (client *Client) RemoveIPv6TranslatorAclListEntry(request *RemoveIPv6TranslatorAclListEntryRequest) (_result *RemoveIPv6TranslatorAclListEntryResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &RemoveIPv6TranslatorAclListEntryResponse{}
	_body, _err := client.RemoveIPv6TranslatorAclListEntryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes a traffic mirror source from a traffic mirror session.
//
// Description:
//
//	  **RemoveSourcesFromTrafficMirrorSession*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListTrafficMirrorSessions](https://help.aliyun.com/document_detail/261367.html) operation to query the status of the task.
//
//	    	- If the traffic mirror session is in the **Modifying*	- state, the traffic mirror source is being deleted.
//
//	    	- If the traffic mirror session is in the **Created*	- state, the traffic mirror source is deleted.
//
//		- You cannot repeatedly call **RemoveSourcesFromTrafficMirrorSession*	- within the specified period of time.
//
// @param request - RemoveSourcesFromTrafficMirrorSessionRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return RemoveSourcesFromTrafficMirrorSessionResponse
func (client *Client) RemoveSourcesFromTrafficMirrorSessionWithOptions(request *RemoveSourcesFromTrafficMirrorSessionRequest, runtime *dara.RuntimeOptions) (_result *RemoveSourcesFromTrafficMirrorSessionResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.TrafficMirrorSessionId) {
		query["TrafficMirrorSessionId"] = request.TrafficMirrorSessionId
	}

	if !dara.IsNil(request.TrafficMirrorSourceIds) {
		query["TrafficMirrorSourceIds"] = request.TrafficMirrorSourceIds
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("RemoveSourcesFromTrafficMirrorSession"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &RemoveSourcesFromTrafficMirrorSessionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Deletes a traffic mirror source from a traffic mirror session.
//
// Description:
//
//	  **RemoveSourcesFromTrafficMirrorSession*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListTrafficMirrorSessions](https://help.aliyun.com/document_detail/261367.html) operation to query the status of the task.
//
//	    	- If the traffic mirror session is in the **Modifying*	- state, the traffic mirror source is being deleted.
//
//	    	- If the traffic mirror session is in the **Created*	- state, the traffic mirror source is deleted.
//
//		- You cannot repeatedly call **RemoveSourcesFromTrafficMirrorSession*	- within the specified period of time.
//
// @param request - RemoveSourcesFromTrafficMirrorSessionRequest
//
// @return RemoveSourcesFromTrafficMirrorSessionResponse
func (client *Client) RemoveSourcesFromTrafficMirrorSession(request *RemoveSourcesFromTrafficMirrorSessionRequest) (_result *RemoveSourcesFromTrafficMirrorSessionResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &RemoveSourcesFromTrafficMirrorSessionResponse{}
	_body, _err := client.RemoveSourcesFromTrafficMirrorSessionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// DHCPVPC
//
// Description:
//
//	  The **ReplaceVpcDhcpOptionsSet*	- operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeVpcAttribute](https://help.aliyun.com/document_detail/94565.html) operation to query the status of a DHCP options set:
//
//	    	- If the DHCP options set is in the **Pending*	- state, the DHCP options set is being replaced.
//
//	    	- If the DHCP options set is in the **InUse*	- state, the DHCP options set is replaced.
//
//		- You cannot repeatedly call the **ReplaceVpcDhcpOptionsSet*	- operation to replace the DHCP options set associated with a VPC within the specified period of time.
//
// @param request - ReplaceVpcDhcpOptionsSetRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ReplaceVpcDhcpOptionsSetResponse
func (client *Client) ReplaceVpcDhcpOptionsSetWithOptions(request *ReplaceVpcDhcpOptionsSetRequest, runtime *dara.RuntimeOptions) (_result *ReplaceVpcDhcpOptionsSetResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DhcpOptionsSetId) {
		query["DhcpOptionsSetId"] = request.DhcpOptionsSetId
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.VpcId) {
		query["VpcId"] = request.VpcId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ReplaceVpcDhcpOptionsSet"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &ReplaceVpcDhcpOptionsSetResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// DHCPVPC
//
// Description:
//
//	  The **ReplaceVpcDhcpOptionsSet*	- operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeVpcAttribute](https://help.aliyun.com/document_detail/94565.html) operation to query the status of a DHCP options set:
//
//	    	- If the DHCP options set is in the **Pending*	- state, the DHCP options set is being replaced.
//
//	    	- If the DHCP options set is in the **InUse*	- state, the DHCP options set is replaced.
//
//		- You cannot repeatedly call the **ReplaceVpcDhcpOptionsSet*	- operation to replace the DHCP options set associated with a VPC within the specified period of time.
//
// @param request - ReplaceVpcDhcpOptionsSetRequest
//
// @return ReplaceVpcDhcpOptionsSetResponse
func (client *Client) ReplaceVpcDhcpOptionsSet(request *ReplaceVpcDhcpOptionsSetRequest) (_result *ReplaceVpcDhcpOptionsSetResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &ReplaceVpcDhcpOptionsSetResponse{}
	_body, _err := client.ReplaceVpcDhcpOptionsSetWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Re-applies a prefix list.
//
// Description:
//
//	  If you modify the information about a prefix list but the modification is not automatically applied to the route table that is associated with the prefix list, you can call this operation to apply the latest prefix list to the associated route table.
//
//		- The **RetryVpcPrefixListAssociation*	- operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the background. You can call the [GetVpcPrefixListAssociations](https://help.aliyun.com/document_detail/445478.html) to check whether the prefix list is re-applied.
//
//	    	- If the prefix list is in the **Modifying*	- state, the prefix list is being re-applied.
//
//	    	- If the prefix list is in the **ModifyFailed*	- state, the prefix list fails to be re-applied.
//
//	    	- If the prefix list is in the **Created*	- state, the prefix list is re-applied.
//
//		- After you call the **RetryVpcPrefixListAssociation*	- operation to re-apply a prefix list, you cannot call the operation again until the current task is complete.
//
// @param request - RetryVpcPrefixListAssociationRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return RetryVpcPrefixListAssociationResponse
func (client *Client) RetryVpcPrefixListAssociationWithOptions(request *RetryVpcPrefixListAssociationRequest, runtime *dara.RuntimeOptions) (_result *RetryVpcPrefixListAssociationResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PrefixListId) {
		query["PrefixListId"] = request.PrefixListId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceId) {
		query["ResourceId"] = request.ResourceId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.ResourceType) {
		query["ResourceType"] = request.ResourceType
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("RetryVpcPrefixListAssociation"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &RetryVpcPrefixListAssociationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Re-applies a prefix list.
//
// Description:
//
//	  If you modify the information about a prefix list but the modification is not automatically applied to the route table that is associated with the prefix list, you can call this operation to apply the latest prefix list to the associated route table.
//
//		- The **RetryVpcPrefixListAssociation*	- operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the background. You can call the [GetVpcPrefixListAssociations](https://help.aliyun.com/document_detail/445478.html) to check whether the prefix list is re-applied.
//
//	    	- If the prefix list is in the **Modifying*	- state, the prefix list is being re-applied.
//
//	    	- If the prefix list is in the **ModifyFailed*	- state, the prefix list fails to be re-applied.
//
//	    	- If the prefix list is in the **Created*	- state, the prefix list is re-applied.
//
//		- After you call the **RetryVpcPrefixListAssociation*	- operation to re-apply a prefix list, you cannot call the operation again until the current task is complete.
//
// @param request - RetryVpcPrefixListAssociationRequest
//
// @return RetryVpcPrefixListAssociationResponse
func (client *Client) RetryVpcPrefixListAssociation(request *RetryVpcPrefixListAssociationRequest) (_result *RetryVpcPrefixListAssociationResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &RetryVpcPrefixListAssociationResponse{}
	_body, _err := client.RetryVpcPrefixListAssociationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Revokes the permissions granted to a Cloud Enterprise Network (CEN) instance on a network instance.
//
// Description:
//
// ## [](#)Usage notes
//
//   - **RevokeInstanceFromCen*	- is a Virtual Private Cloud (VPC) operation. Therefore, you must use `vpc.aliyuncs.com` as the domain name when you call this operation. The API version is `2016-04-28`.
//
//   - You cannot repeatedly call the **RevokeInstanceFromCen*	- operation to revoke the permissions on a network instance that is attached to a CEN instance within the specified period of time. The network instance can be a VPC, virtual border router (VBR), or a Cloud Connect Network (CCN) instance.
//
// @param request - RevokeInstanceFromCenRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return RevokeInstanceFromCenResponse
func (client *Client) RevokeInstanceFromCenWithOptions(request *RevokeInstanceFromCenRequest, runtime *dara.RuntimeOptions) (_result *RevokeInstanceFromCenResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.CenId) {
		query["CenId"] = request.CenId
	}

	if !dara.IsNil(request.CenOwnerId) {
		query["CenOwnerId"] = request.CenOwnerId
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.InstanceId) {
		query["InstanceId"] = request.InstanceId
	}

	if !dara.IsNil(request.InstanceType) {
		query["InstanceType"] = request.InstanceType
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("RevokeInstanceFromCen"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &RevokeInstanceFromCenResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Revokes the permissions granted to a Cloud Enterprise Network (CEN) instance on a network instance.
//
// Description:
//
// ## [](#)Usage notes
//
//   - **RevokeInstanceFromCen*	- is a Virtual Private Cloud (VPC) operation. Therefore, you must use `vpc.aliyuncs.com` as the domain name when you call this operation. The API version is `2016-04-28`.
//
//   - You cannot repeatedly call the **RevokeInstanceFromCen*	- operation to revoke the permissions on a network instance that is attached to a CEN instance within the specified period of time. The network instance can be a VPC, virtual border router (VBR), or a Cloud Connect Network (CCN) instance.
//
// @param request - RevokeInstanceFromCenRequest
//
// @return RevokeInstanceFromCenResponse
func (client *Client) RevokeInstanceFromCen(request *RevokeInstanceFromCenRequest) (_result *RevokeInstanceFromCenResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &RevokeInstanceFromCenResponse{}
	_body, _err := client.RevokeInstanceFromCenWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Revokes the permissions granted to a virtual border router (VBR) on a virtual private cloud (VPC).
//
// @param tmpReq - RevokeInstanceFromVbrRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return RevokeInstanceFromVbrResponse
func (client *Client) RevokeInstanceFromVbrWithOptions(tmpReq *RevokeInstanceFromVbrRequest, runtime *dara.RuntimeOptions) (_result *RevokeInstanceFromVbrResponse, _err error) {
	_err = tmpReq.Validate()
	if _err != nil {
		return _result, _err
	}
	request := &RevokeInstanceFromVbrShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !dara.IsNil(tmpReq.VbrInstanceIds) {
		request.VbrInstanceIdsShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.VbrInstanceIds, dara.String("VbrInstanceIds"), dara.String("simple"))
	}

	query := map[string]interface{}{}
	if !dara.IsNil(request.GrantType) {
		query["GrantType"] = request.GrantType
	}

	if !dara.IsNil(request.InstanceId) {
		query["InstanceId"] = request.InstanceId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.VbrInstanceIdsShrink) {
		query["VbrInstanceIds"] = request.VbrInstanceIdsShrink
	}

	if !dara.IsNil(request.VbrOwnerUid) {
		query["VbrOwnerUid"] = request.VbrOwnerUid
	}

	if !dara.IsNil(request.VbrRegionNo) {
		query["VbrRegionNo"] = request.VbrRegionNo
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("RevokeInstanceFromVbr"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &RevokeInstanceFromVbrResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Revokes the permissions granted to a virtual border router (VBR) on a virtual private cloud (VPC).
//
// @param request - RevokeInstanceFromVbrRequest
//
// @return RevokeInstanceFromVbrResponse
func (client *Client) RevokeInstanceFromVbr(request *RevokeInstanceFromVbrRequest) (_result *RevokeInstanceFromVbrResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &RevokeInstanceFromVbrResponse{}
	_body, _err := client.RevokeInstanceFromVbrWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// If your application for a Letter of Authorization (LOA) by calling the ApplyPhysicalConnectionLOA operation is denied, you can call this operation to apply again.
//
// @param request - SecondApplyPhysicalConnectionLOARequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return SecondApplyPhysicalConnectionLOAResponse
func (client *Client) SecondApplyPhysicalConnectionLOAWithOptions(request *SecondApplyPhysicalConnectionLOARequest, runtime *dara.RuntimeOptions) (_result *SecondApplyPhysicalConnectionLOAResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.Bandwidth) {
		query["Bandwidth"] = request.Bandwidth
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.CompanyName) {
		query["CompanyName"] = request.CompanyName
	}

	if !dara.IsNil(request.ConstructionTime) {
		query["ConstructionTime"] = request.ConstructionTime
	}

	if !dara.IsNil(request.InstanceId) {
		query["InstanceId"] = request.InstanceId
	}

	if !dara.IsNil(request.LineType) {
		query["LineType"] = request.LineType
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PMInfo) {
		query["PMInfo"] = request.PMInfo
	}

	if !dara.IsNil(request.PeerLocation) {
		query["PeerLocation"] = request.PeerLocation
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.Si) {
		query["Si"] = request.Si
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("SecondApplyPhysicalConnectionLOA"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &SecondApplyPhysicalConnectionLOAResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// If your application for a Letter of Authorization (LOA) by calling the ApplyPhysicalConnectionLOA operation is denied, you can call this operation to apply again.
//
// @param request - SecondApplyPhysicalConnectionLOARequest
//
// @return SecondApplyPhysicalConnectionLOAResponse
func (client *Client) SecondApplyPhysicalConnectionLOA(request *SecondApplyPhysicalConnectionLOARequest) (_result *SecondApplyPhysicalConnectionLOAResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &SecondApplyPhysicalConnectionLOAResponse{}
	_body, _err := client.SecondApplyPhysicalConnectionLOAWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Configures fine-grained monitoring for an elastic IP address (EIP).
//
// Description:
//
// You cannot repeatedly call **SetHighDefinitionMonitorLogStatus*	- within a specific period of time.
//
// @param request - SetHighDefinitionMonitorLogStatusRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return SetHighDefinitionMonitorLogStatusResponse
func (client *Client) SetHighDefinitionMonitorLogStatusWithOptions(request *SetHighDefinitionMonitorLogStatusRequest, runtime *dara.RuntimeOptions) (_result *SetHighDefinitionMonitorLogStatusResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.InstanceId) {
		query["InstanceId"] = request.InstanceId
	}

	if !dara.IsNil(request.InstanceType) {
		query["InstanceType"] = request.InstanceType
	}

	if !dara.IsNil(request.LogProject) {
		query["LogProject"] = request.LogProject
	}

	if !dara.IsNil(request.LogStore) {
		query["LogStore"] = request.LogStore
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.Status) {
		query["Status"] = request.Status
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("SetHighDefinitionMonitorLogStatus"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &SetHighDefinitionMonitorLogStatusResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Configures fine-grained monitoring for an elastic IP address (EIP).
//
// Description:
//
// You cannot repeatedly call **SetHighDefinitionMonitorLogStatus*	- within a specific period of time.
//
// @param request - SetHighDefinitionMonitorLogStatusRequest
//
// @return SetHighDefinitionMonitorLogStatusResponse
func (client *Client) SetHighDefinitionMonitorLogStatus(request *SetHighDefinitionMonitorLogStatusRequest) (_result *SetHighDefinitionMonitorLogStatusResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &SetHighDefinitionMonitorLogStatusResponse{}
	_body, _err := client.SetHighDefinitionMonitorLogStatusWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Performs a failover test.
//
// Description:
//
// You can perform only failover tests that are in the **Pending*	- state.
//
// @param request - StartFailoverTestJobRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return StartFailoverTestJobResponse
func (client *Client) StartFailoverTestJobWithOptions(request *StartFailoverTestJobRequest, runtime *dara.RuntimeOptions) (_result *StartFailoverTestJobResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.JobId) {
		query["JobId"] = request.JobId
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("StartFailoverTestJob"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &StartFailoverTestJobResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Performs a failover test.
//
// Description:
//
// You can perform only failover tests that are in the **Pending*	- state.
//
// @param request - StartFailoverTestJobRequest
//
// @return StartFailoverTestJobResponse
func (client *Client) StartFailoverTestJob(request *StartFailoverTestJobRequest) (_result *StartFailoverTestJobResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &StartFailoverTestJobResponse{}
	_body, _err := client.StartFailoverTestJobWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Terminates a failover test.
//
// @param request - StopFailoverTestJobRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return StopFailoverTestJobResponse
func (client *Client) StopFailoverTestJobWithOptions(request *StopFailoverTestJobRequest, runtime *dara.RuntimeOptions) (_result *StopFailoverTestJobResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.JobId) {
		query["JobId"] = request.JobId
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("StopFailoverTestJob"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &StopFailoverTestJobResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Terminates a failover test.
//
// @param request - StopFailoverTestJobRequest
//
// @return StopFailoverTestJobResponse
func (client *Client) StopFailoverTestJob(request *StopFailoverTestJobRequest) (_result *StopFailoverTestJobResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &StopFailoverTestJobResponse{}
	_body, _err := client.StopFailoverTestJobWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates and adds tags to resources.
//
// Description:
//
// Tags are used to classify instances. Each tag consists of a key-value pair. Before you use tags, take note of the following limits:
//
//   - The keys of tags that are added to the same instance must be unique.
//
//   - You cannot create tags without adding them to instances. All tags must be added to instances.
//
//   - Tag information is not shared across regions.
//
//     For example, you cannot view the tags that are created in the China (Hangzhou) region from the China (Shanghai) region.
//
//   - Virtual private clouds (VPCs), route tables, vSwitches, and elastic IP addresses (EIPs) that belong to the same Alibaba Cloud account and are deployed in the same region share tag information with each other.
//
//     For example, if you added a tag to a VPC, the tag is available to vSwitches, route tables, and EIPs that belong to the same account and are deployed in the same region in which the VPC is created. You can select this tag from the editing page without the need to enter the tag again. You can modify the key and the value of a tag or remove a tag from an instance. After you delete an instance, all tags that are added to the instance are deleted.
//
//   - You can add up to 20 tags to each instance. Before you add a tag to an instance, the system automatically checks the number of existing tags. An error message is returned if the maximum number of tags is reached.
//
// @param request - TagResourcesRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return TagResourcesResponse
func (client *Client) TagResourcesWithOptions(request *TagResourcesRequest, runtime *dara.RuntimeOptions) (_result *TagResourcesResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceId) {
		query["ResourceId"] = request.ResourceId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.ResourceType) {
		query["ResourceType"] = request.ResourceType
	}

	if !dara.IsNil(request.Tag) {
		query["Tag"] = request.Tag
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("TagResources"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &TagResourcesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Creates and adds tags to resources.
//
// Description:
//
// Tags are used to classify instances. Each tag consists of a key-value pair. Before you use tags, take note of the following limits:
//
//   - The keys of tags that are added to the same instance must be unique.
//
//   - You cannot create tags without adding them to instances. All tags must be added to instances.
//
//   - Tag information is not shared across regions.
//
//     For example, you cannot view the tags that are created in the China (Hangzhou) region from the China (Shanghai) region.
//
//   - Virtual private clouds (VPCs), route tables, vSwitches, and elastic IP addresses (EIPs) that belong to the same Alibaba Cloud account and are deployed in the same region share tag information with each other.
//
//     For example, if you added a tag to a VPC, the tag is available to vSwitches, route tables, and EIPs that belong to the same account and are deployed in the same region in which the VPC is created. You can select this tag from the editing page without the need to enter the tag again. You can modify the key and the value of a tag or remove a tag from an instance. After you delete an instance, all tags that are added to the instance are deleted.
//
//   - You can add up to 20 tags to each instance. Before you add a tag to an instance, the system automatically checks the number of existing tags. An error message is returned if the maximum number of tags is reached.
//
// @param request - TagResourcesRequest
//
// @return TagResourcesResponse
func (client *Client) TagResources(request *TagResourcesRequest) (_result *TagResourcesResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &TagResourcesResponse{}
	_body, _err := client.TagResourcesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates tags and adds the tags to an Express Connect circuit.
//
// Description:
//
// ## [](#)
//
// Tags are used to classify instances. Each tag consists of a key-value pair. Before you use tags, take note of the following items:
//
//   - Each tag key that is added to an instance must be unique.
//
//   - You cannot create tags without adding them to instances. All tags must be added to instances.
//
//   - Tag information is not shared across regions.
//
//     For example, you cannot view the tags that are created in the China (Hangzhou) region from the China (Shanghai) region.
//
//   - You can add up to 20 tags to each instance. Before you add a tag to an instance, the system automatically checks the number of existing tags. An error message is returned if the maximum number of tags is reached.
//
// @param request - TagResourcesForExpressConnectRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return TagResourcesForExpressConnectResponse
func (client *Client) TagResourcesForExpressConnectWithOptions(request *TagResourcesForExpressConnectRequest, runtime *dara.RuntimeOptions) (_result *TagResourcesForExpressConnectResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceId) {
		query["ResourceId"] = request.ResourceId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.ResourceType) {
		query["ResourceType"] = request.ResourceType
	}

	if !dara.IsNil(request.Tag) {
		query["Tag"] = request.Tag
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("TagResourcesForExpressConnect"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &TagResourcesForExpressConnectResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Creates tags and adds the tags to an Express Connect circuit.
//
// Description:
//
// ## [](#)
//
// Tags are used to classify instances. Each tag consists of a key-value pair. Before you use tags, take note of the following items:
//
//   - Each tag key that is added to an instance must be unique.
//
//   - You cannot create tags without adding them to instances. All tags must be added to instances.
//
//   - Tag information is not shared across regions.
//
//     For example, you cannot view the tags that are created in the China (Hangzhou) region from the China (Shanghai) region.
//
//   - You can add up to 20 tags to each instance. Before you add a tag to an instance, the system automatically checks the number of existing tags. An error message is returned if the maximum number of tags is reached.
//
// @param request - TagResourcesForExpressConnectRequest
//
// @return TagResourcesForExpressConnectResponse
func (client *Client) TagResourcesForExpressConnect(request *TagResourcesForExpressConnectRequest) (_result *TagResourcesForExpressConnectResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &TagResourcesForExpressConnectResponse{}
	_body, _err := client.TagResourcesForExpressConnectWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Disables an Express Connect circuit after it is enabled.
//
// Description:
//
// After you call this operation, the specified Express Connect circuit changes to the **Terminating*	- state. After the Express Connect circuit is disabled, it changes to the **Terminated*	- state. When you call this operation, take note of the following limits:
//
//   - You can only disable an Express Connect circuit that is in the **Enabled*	- state.
//
//   - Before you disable an Express Connect circuit, you must delete the virtual border routers (VBRs) associated with it.
//
// @param request - TerminatePhysicalConnectionRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return TerminatePhysicalConnectionResponse
func (client *Client) TerminatePhysicalConnectionWithOptions(request *TerminatePhysicalConnectionRequest, runtime *dara.RuntimeOptions) (_result *TerminatePhysicalConnectionResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PhysicalConnectionId) {
		query["PhysicalConnectionId"] = request.PhysicalConnectionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("TerminatePhysicalConnection"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &TerminatePhysicalConnectionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Disables an Express Connect circuit after it is enabled.
//
// Description:
//
// After you call this operation, the specified Express Connect circuit changes to the **Terminating*	- state. After the Express Connect circuit is disabled, it changes to the **Terminated*	- state. When you call this operation, take note of the following limits:
//
//   - You can only disable an Express Connect circuit that is in the **Enabled*	- state.
//
//   - Before you disable an Express Connect circuit, you must delete the virtual border routers (VBRs) associated with it.
//
// @param request - TerminatePhysicalConnectionRequest
//
// @return TerminatePhysicalConnectionResponse
func (client *Client) TerminatePhysicalConnection(request *TerminatePhysicalConnectionRequest) (_result *TerminatePhysicalConnectionResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &TerminatePhysicalConnectionResponse{}
	_body, _err := client.TerminatePhysicalConnectionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Terminates a virtual border router (VBR).
//
// Description:
//
// After you call this operation, the VBR enters the **terminating*	- state from the **active*	- state. After the VBR is terminated, the VBR enters the **terminated*	- state.
//
// >  Only the owner of an Express Connect circuit can call this operation.
//
// @param request - TerminateVirtualBorderRouterRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return TerminateVirtualBorderRouterResponse
func (client *Client) TerminateVirtualBorderRouterWithOptions(request *TerminateVirtualBorderRouterRequest, runtime *dara.RuntimeOptions) (_result *TerminateVirtualBorderRouterResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.VbrId) {
		query["VbrId"] = request.VbrId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("TerminateVirtualBorderRouter"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &TerminateVirtualBorderRouterResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Terminates a virtual border router (VBR).
//
// Description:
//
// After you call this operation, the VBR enters the **terminating*	- state from the **active*	- state. After the VBR is terminated, the VBR enters the **terminated*	- state.
//
// >  Only the owner of an Express Connect circuit can call this operation.
//
// @param request - TerminateVirtualBorderRouterRequest
//
// @return TerminateVirtualBorderRouterResponse
func (client *Client) TerminateVirtualBorderRouter(request *TerminateVirtualBorderRouterRequest) (_result *TerminateVirtualBorderRouterResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &TerminateVirtualBorderRouterResponse{}
	_body, _err := client.TerminateVirtualBorderRouterWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Migrate contiguous EIP groups to IP address pool by calling TransformEipSegmentToPublicIpAddressPool.
//
// @param request - TransformEipSegmentToPublicIpAddressPoolRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return TransformEipSegmentToPublicIpAddressPoolResponse
func (client *Client) TransformEipSegmentToPublicIpAddressPoolWithOptions(request *TransformEipSegmentToPublicIpAddressPoolRequest, runtime *dara.RuntimeOptions) (_result *TransformEipSegmentToPublicIpAddressPoolResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.Description) {
		query["Description"] = request.Description
	}

	if !dara.IsNil(request.InstanceId) {
		query["InstanceId"] = request.InstanceId
	}

	if !dara.IsNil(request.Name) {
		query["Name"] = request.Name
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceGroupId) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("TransformEipSegmentToPublicIpAddressPool"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &TransformEipSegmentToPublicIpAddressPoolResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Migrate contiguous EIP groups to IP address pool by calling TransformEipSegmentToPublicIpAddressPool.
//
// @param request - TransformEipSegmentToPublicIpAddressPoolRequest
//
// @return TransformEipSegmentToPublicIpAddressPoolResponse
func (client *Client) TransformEipSegmentToPublicIpAddressPool(request *TransformEipSegmentToPublicIpAddressPoolRequest) (_result *TransformEipSegmentToPublicIpAddressPoolResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &TransformEipSegmentToPublicIpAddressPoolResponse{}
	_body, _err := client.TransformEipSegmentToPublicIpAddressPoolWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Removes tags from resources.
//
// @param request - UnTagResourcesRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UnTagResourcesResponse
func (client *Client) UnTagResourcesWithOptions(request *UnTagResourcesRequest, runtime *dara.RuntimeOptions) (_result *UnTagResourcesResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.All) {
		query["All"] = request.All
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceId) {
		query["ResourceId"] = request.ResourceId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.ResourceType) {
		query["ResourceType"] = request.ResourceType
	}

	if !dara.IsNil(request.TagKey) {
		query["TagKey"] = request.TagKey
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("UnTagResources"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &UnTagResourcesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Removes tags from resources.
//
// @param request - UnTagResourcesRequest
//
// @return UnTagResourcesResponse
func (client *Client) UnTagResources(request *UnTagResourcesRequest) (_result *UnTagResourcesResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &UnTagResourcesResponse{}
	_body, _err := client.UnTagResourcesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Disassociates an elastic IP address (EIP) from a cloud resource.
//
// Description:
//
//	  **UnassociateEipAddress*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeEipAddresses](https://help.aliyun.com/document_detail/120193.html) operation to query the status of the task.
//
//	    	- If the EIP is in the **Unassociating*	- state, the EIP is being disassociated. In this state, you can only query the EIP and cannot perform other operations.
//
//	    	- If the EIP is in the **Available*	- state, the EIP is disassociated.
//
//		- You cannot repeatedly call the **UnassociateEipAddress*	- operation within the specified period of time.
//
// @param request - UnassociateEipAddressRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UnassociateEipAddressResponse
func (client *Client) UnassociateEipAddressWithOptions(request *UnassociateEipAddressRequest, runtime *dara.RuntimeOptions) (_result *UnassociateEipAddressResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.AllocationId) {
		query["AllocationId"] = request.AllocationId
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.Force) {
		query["Force"] = request.Force
	}

	if !dara.IsNil(request.InstanceId) {
		query["InstanceId"] = request.InstanceId
	}

	if !dara.IsNil(request.InstanceType) {
		query["InstanceType"] = request.InstanceType
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PrivateIpAddress) {
		query["PrivateIpAddress"] = request.PrivateIpAddress
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("UnassociateEipAddress"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &UnassociateEipAddressResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Disassociates an elastic IP address (EIP) from a cloud resource.
//
// Description:
//
//	  **UnassociateEipAddress*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeEipAddresses](https://help.aliyun.com/document_detail/120193.html) operation to query the status of the task.
//
//	    	- If the EIP is in the **Unassociating*	- state, the EIP is being disassociated. In this state, you can only query the EIP and cannot perform other operations.
//
//	    	- If the EIP is in the **Available*	- state, the EIP is disassociated.
//
//		- You cannot repeatedly call the **UnassociateEipAddress*	- operation within the specified period of time.
//
// @param request - UnassociateEipAddressRequest
//
// @return UnassociateEipAddressResponse
func (client *Client) UnassociateEipAddress(request *UnassociateEipAddressRequest) (_result *UnassociateEipAddressResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &UnassociateEipAddressResponse{}
	_body, _err := client.UnassociateEipAddressWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Disassociates a Global Accelerator (GA) instance from a backend server.
//
// @param request - UnassociateGlobalAccelerationInstanceRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UnassociateGlobalAccelerationInstanceResponse
func (client *Client) UnassociateGlobalAccelerationInstanceWithOptions(request *UnassociateGlobalAccelerationInstanceRequest, runtime *dara.RuntimeOptions) (_result *UnassociateGlobalAccelerationInstanceResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.GlobalAccelerationInstanceId) {
		query["GlobalAccelerationInstanceId"] = request.GlobalAccelerationInstanceId
	}

	if !dara.IsNil(request.InstanceType) {
		query["InstanceType"] = request.InstanceType
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("UnassociateGlobalAccelerationInstance"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &UnassociateGlobalAccelerationInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Disassociates a Global Accelerator (GA) instance from a backend server.
//
// @param request - UnassociateGlobalAccelerationInstanceRequest
//
// @return UnassociateGlobalAccelerationInstanceResponse
func (client *Client) UnassociateGlobalAccelerationInstance(request *UnassociateGlobalAccelerationInstanceRequest) (_result *UnassociateGlobalAccelerationInstanceResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &UnassociateGlobalAccelerationInstanceResponse{}
	_body, _err := client.UnassociateGlobalAccelerationInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Disassociates a high-availability virtual IP address (HaVip) from an Elastic Compute Service (ECS) in a virtual private cloud (VPC) or from an elastic network interface (ENI).
//
// Description:
//
// ## [](#)
//
// When you call this operation, take note of the following limits:
//
//   - The ECS instance must be in the **Running*	- or **Stopped*	- state.
//
//   - The HaVip must be in the **Available*	- or **InUse*	- state.
//
//   - **UnassociateHaVip*	- is an asynchronous operation. After a request is sent, the system returns a request ID and an instance ID and runs the task in the background. You can call the [DescribeHaVips](https://help.aliyun.com/document_detail/114611.html) operation to query the status of an HaVip:
//
//   - If the HaVip is in the **Unassociating*	- state, the HaVip is being disassociated.
//
//   - If the HaVip is in the **Inuse*	- or **Available*	- state, the HaVip is disassociated.
//
//   - You cannot repeatedly call the **UnassociateHaVip*	- operation to disassociate an HaVip within the specified period of time.
//
// @param request - UnassociateHaVipRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UnassociateHaVipResponse
func (client *Client) UnassociateHaVipWithOptions(request *UnassociateHaVipRequest, runtime *dara.RuntimeOptions) (_result *UnassociateHaVipResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.Force) {
		query["Force"] = request.Force
	}

	if !dara.IsNil(request.HaVipId) {
		query["HaVipId"] = request.HaVipId
	}

	if !dara.IsNil(request.InstanceId) {
		query["InstanceId"] = request.InstanceId
	}

	if !dara.IsNil(request.InstanceType) {
		query["InstanceType"] = request.InstanceType
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("UnassociateHaVip"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &UnassociateHaVipResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Disassociates a high-availability virtual IP address (HaVip) from an Elastic Compute Service (ECS) in a virtual private cloud (VPC) or from an elastic network interface (ENI).
//
// Description:
//
// ## [](#)
//
// When you call this operation, take note of the following limits:
//
//   - The ECS instance must be in the **Running*	- or **Stopped*	- state.
//
//   - The HaVip must be in the **Available*	- or **InUse*	- state.
//
//   - **UnassociateHaVip*	- is an asynchronous operation. After a request is sent, the system returns a request ID and an instance ID and runs the task in the background. You can call the [DescribeHaVips](https://help.aliyun.com/document_detail/114611.html) operation to query the status of an HaVip:
//
//   - If the HaVip is in the **Unassociating*	- state, the HaVip is being disassociated.
//
//   - If the HaVip is in the **Inuse*	- or **Available*	- state, the HaVip is disassociated.
//
//   - You cannot repeatedly call the **UnassociateHaVip*	- operation to disassociate an HaVip within the specified period of time.
//
// @param request - UnassociateHaVipRequest
//
// @return UnassociateHaVipResponse
func (client *Client) UnassociateHaVip(request *UnassociateHaVipRequest) (_result *UnassociateHaVipResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &UnassociateHaVipResponse{}
	_body, _err := client.UnassociateHaVipWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Disassociates a network access control list (ACL) from a vSwitch.
//
// Description:
//
// ## [](#)Description
//
//   - **UnassociateNetworkAcl*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeNetworkAclAttributes](https://help.aliyun.com/document_detail/116542.html) operation to query the status of the task.
//
//   - If the network ACL is in the **UNBINDING*	- state, the network ACL is being disassociated from the vSwitch.
//
//   - If the network ACL is in the **UNBINDED*	- state, the network ACL is disassociated from the vSwitch.
//
//   - You cannot repeatedly call the **UnassociateNetworkAcl*	- operation to disassociate a network ACL from a vSwitch within the specified period of time.
//
// @param request - UnassociateNetworkAclRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UnassociateNetworkAclResponse
func (client *Client) UnassociateNetworkAclWithOptions(request *UnassociateNetworkAclRequest, runtime *dara.RuntimeOptions) (_result *UnassociateNetworkAclResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.NetworkAclId) {
		query["NetworkAclId"] = request.NetworkAclId
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.Resource) {
		query["Resource"] = request.Resource
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("UnassociateNetworkAcl"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &UnassociateNetworkAclResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Disassociates a network access control list (ACL) from a vSwitch.
//
// Description:
//
// ## [](#)Description
//
//   - **UnassociateNetworkAcl*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeNetworkAclAttributes](https://help.aliyun.com/document_detail/116542.html) operation to query the status of the task.
//
//   - If the network ACL is in the **UNBINDING*	- state, the network ACL is being disassociated from the vSwitch.
//
//   - If the network ACL is in the **UNBINDED*	- state, the network ACL is disassociated from the vSwitch.
//
//   - You cannot repeatedly call the **UnassociateNetworkAcl*	- operation to disassociate a network ACL from a vSwitch within the specified period of time.
//
// @param request - UnassociateNetworkAclRequest
//
// @return UnassociateNetworkAclResponse
func (client *Client) UnassociateNetworkAcl(request *UnassociateNetworkAclRequest) (_result *UnassociateNetworkAclResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &UnassociateNetworkAclResponse{}
	_body, _err := client.UnassociateNetworkAclWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Disassociates a virtual border router (VBR) from an Express Connect circuit.
//
// @param request - UnassociatePhysicalConnectionFromVirtualBorderRouterRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UnassociatePhysicalConnectionFromVirtualBorderRouterResponse
func (client *Client) UnassociatePhysicalConnectionFromVirtualBorderRouterWithOptions(request *UnassociatePhysicalConnectionFromVirtualBorderRouterRequest, runtime *dara.RuntimeOptions) (_result *UnassociatePhysicalConnectionFromVirtualBorderRouterResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PhysicalConnectionId) {
		query["PhysicalConnectionId"] = request.PhysicalConnectionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.VbrId) {
		query["VbrId"] = request.VbrId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("UnassociatePhysicalConnectionFromVirtualBorderRouter"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &UnassociatePhysicalConnectionFromVirtualBorderRouterResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Disassociates a virtual border router (VBR) from an Express Connect circuit.
//
// @param request - UnassociatePhysicalConnectionFromVirtualBorderRouterRequest
//
// @return UnassociatePhysicalConnectionFromVirtualBorderRouterResponse
func (client *Client) UnassociatePhysicalConnectionFromVirtualBorderRouter(request *UnassociatePhysicalConnectionFromVirtualBorderRouterRequest) (_result *UnassociatePhysicalConnectionFromVirtualBorderRouterResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &UnassociatePhysicalConnectionFromVirtualBorderRouterResponse{}
	_body, _err := client.UnassociatePhysicalConnectionFromVirtualBorderRouterWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Disassociates a route table from a vSwitch.
//
// Description:
//
// ## [](#)References
//
//   - **UnassociateRouteTable*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVSwitchAttributes](https://help.aliyun.com/document_detail/94567.html) operation to query the status of the task.
//
//   - If the vSwitch is in the **Pending*	- state, the route table is being disassociated.
//
//   - If the vSwitch is in the **Available*	- state, the route table is disassociated.
//
//   - You cannot repeatedly call the **UnassociateRouteTable*	- operation to disassociate a route table from a vSwitch within the specified period of time.
//
// @param request - UnassociateRouteTableRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UnassociateRouteTableResponse
func (client *Client) UnassociateRouteTableWithOptions(request *UnassociateRouteTableRequest, runtime *dara.RuntimeOptions) (_result *UnassociateRouteTableResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.RouteTableId) {
		query["RouteTableId"] = request.RouteTableId
	}

	if !dara.IsNil(request.VSwitchId) {
		query["VSwitchId"] = request.VSwitchId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("UnassociateRouteTable"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &UnassociateRouteTableResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Disassociates a route table from a vSwitch.
//
// Description:
//
// ## [](#)References
//
//   - **UnassociateRouteTable*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVSwitchAttributes](https://help.aliyun.com/document_detail/94567.html) operation to query the status of the task.
//
//   - If the vSwitch is in the **Pending*	- state, the route table is being disassociated.
//
//   - If the vSwitch is in the **Available*	- state, the route table is disassociated.
//
//   - You cannot repeatedly call the **UnassociateRouteTable*	- operation to disassociate a route table from a vSwitch within the specified period of time.
//
// @param request - UnassociateRouteTableRequest
//
// @return UnassociateRouteTableResponse
func (client *Client) UnassociateRouteTable(request *UnassociateRouteTableRequest) (_result *UnassociateRouteTableResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &UnassociateRouteTableResponse{}
	_body, _err := client.UnassociateRouteTableWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Removes a secondary CIDR block from a virtual private cloud (VPC).
//
// Description:
//
//	  Before you delete a secondary CIDR block from a VPC, delete the vSwitch which is created with the CIDR block. For more information, see [DeleteVSwitch](https://help.aliyun.com/document_detail/35746.html).
//
//		- You cannot repeatedly call the **UnassociateVpcCidrBlock*	- operation to delete a secondary CIDR block from a VPC within the specified period of time.
//
// @param request - UnassociateVpcCidrBlockRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UnassociateVpcCidrBlockResponse
func (client *Client) UnassociateVpcCidrBlockWithOptions(request *UnassociateVpcCidrBlockRequest, runtime *dara.RuntimeOptions) (_result *UnassociateVpcCidrBlockResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.IPv6CidrBlock) {
		query["IPv6CidrBlock"] = request.IPv6CidrBlock
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.SecondaryCidrBlock) {
		query["SecondaryCidrBlock"] = request.SecondaryCidrBlock
	}

	if !dara.IsNil(request.VpcId) {
		query["VpcId"] = request.VpcId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("UnassociateVpcCidrBlock"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &UnassociateVpcCidrBlockResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Removes a secondary CIDR block from a virtual private cloud (VPC).
//
// Description:
//
//	  Before you delete a secondary CIDR block from a VPC, delete the vSwitch which is created with the CIDR block. For more information, see [DeleteVSwitch](https://help.aliyun.com/document_detail/35746.html).
//
//		- You cannot repeatedly call the **UnassociateVpcCidrBlock*	- operation to delete a secondary CIDR block from a VPC within the specified period of time.
//
// @param request - UnassociateVpcCidrBlockRequest
//
// @return UnassociateVpcCidrBlockResponse
func (client *Client) UnassociateVpcCidrBlock(request *UnassociateVpcCidrBlockRequest) (_result *UnassociateVpcCidrBlockResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &UnassociateVpcCidrBlockResponse{}
	_body, _err := client.UnassociateVpcCidrBlockWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Removes tags from an Express Connect circuit at a time.
//
// @param request - UntagResourcesForExpressConnectRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UntagResourcesForExpressConnectResponse
func (client *Client) UntagResourcesForExpressConnectWithOptions(request *UntagResourcesForExpressConnectRequest, runtime *dara.RuntimeOptions) (_result *UntagResourcesForExpressConnectResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.All) {
		query["All"] = request.All
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceId) {
		query["ResourceId"] = request.ResourceId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.ResourceType) {
		query["ResourceType"] = request.ResourceType
	}

	if !dara.IsNil(request.TagKey) {
		query["TagKey"] = request.TagKey
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("UntagResourcesForExpressConnect"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &UntagResourcesForExpressConnectResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Removes tags from an Express Connect circuit at a time.
//
// @param request - UntagResourcesForExpressConnectRequest
//
// @return UntagResourcesForExpressConnectResponse
func (client *Client) UntagResourcesForExpressConnect(request *UntagResourcesForExpressConnectRequest) (_result *UntagResourcesForExpressConnectResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &UntagResourcesForExpressConnectResponse{}
	_body, _err := client.UntagResourcesForExpressConnectWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Dhcp
//
// @param request - UpdateDhcpOptionsSetAttributeRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateDhcpOptionsSetAttributeResponse
func (client *Client) UpdateDhcpOptionsSetAttributeWithOptions(request *UpdateDhcpOptionsSetAttributeRequest, runtime *dara.RuntimeOptions) (_result *UpdateDhcpOptionsSetAttributeResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DhcpOptionsSetDescription) {
		query["DhcpOptionsSetDescription"] = request.DhcpOptionsSetDescription
	}

	if !dara.IsNil(request.DhcpOptionsSetId) {
		query["DhcpOptionsSetId"] = request.DhcpOptionsSetId
	}

	if !dara.IsNil(request.DhcpOptionsSetName) {
		query["DhcpOptionsSetName"] = request.DhcpOptionsSetName
	}

	if !dara.IsNil(request.DomainName) {
		query["DomainName"] = request.DomainName
	}

	if !dara.IsNil(request.DomainNameServers) {
		query["DomainNameServers"] = request.DomainNameServers
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.Ipv6LeaseTime) {
		query["Ipv6LeaseTime"] = request.Ipv6LeaseTime
	}

	if !dara.IsNil(request.LeaseTime) {
		query["LeaseTime"] = request.LeaseTime
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("UpdateDhcpOptionsSetAttribute"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &UpdateDhcpOptionsSetAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Dhcp
//
// @param request - UpdateDhcpOptionsSetAttributeRequest
//
// @return UpdateDhcpOptionsSetAttributeResponse
func (client *Client) UpdateDhcpOptionsSetAttribute(request *UpdateDhcpOptionsSetAttributeRequest) (_result *UpdateDhcpOptionsSetAttributeResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &UpdateDhcpOptionsSetAttributeResponse{}
	_body, _err := client.UpdateDhcpOptionsSetAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Updates a failover test.
//
// @param request - UpdateFailoverTestJobRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateFailoverTestJobResponse
func (client *Client) UpdateFailoverTestJobWithOptions(request *UpdateFailoverTestJobRequest, runtime *dara.RuntimeOptions) (_result *UpdateFailoverTestJobResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.Description) {
		query["Description"] = request.Description
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.JobDuration) {
		query["JobDuration"] = request.JobDuration
	}

	if !dara.IsNil(request.JobId) {
		query["JobId"] = request.JobId
	}

	if !dara.IsNil(request.Name) {
		query["Name"] = request.Name
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceId) {
		query["ResourceId"] = request.ResourceId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("UpdateFailoverTestJob"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &UpdateFailoverTestJobResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Updates a failover test.
//
// @param request - UpdateFailoverTestJobRequest
//
// @return UpdateFailoverTestJobResponse
func (client *Client) UpdateFailoverTestJob(request *UpdateFailoverTestJobRequest) (_result *UpdateFailoverTestJobResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &UpdateFailoverTestJobResponse{}
	_body, _err := client.UpdateFailoverTestJobWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Modifies the next hop type and next hop of the route entry in a gateway route table.
//
// @param request - UpdateGatewayRouteTableEntryAttributeRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateGatewayRouteTableEntryAttributeResponse
func (client *Client) UpdateGatewayRouteTableEntryAttributeWithOptions(request *UpdateGatewayRouteTableEntryAttributeRequest, runtime *dara.RuntimeOptions) (_result *UpdateGatewayRouteTableEntryAttributeResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.Description) {
		query["Description"] = request.Description
	}

	if !dara.IsNil(request.DestinationCidrBlock) {
		query["DestinationCidrBlock"] = request.DestinationCidrBlock
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.GatewayRouteTableId) {
		query["GatewayRouteTableId"] = request.GatewayRouteTableId
	}

	if !dara.IsNil(request.IPv4GatewayRouteTableId) {
		query["IPv4GatewayRouteTableId"] = request.IPv4GatewayRouteTableId
	}

	if !dara.IsNil(request.Name) {
		query["Name"] = request.Name
	}

	if !dara.IsNil(request.NextHopId) {
		query["NextHopId"] = request.NextHopId
	}

	if !dara.IsNil(request.NextHopType) {
		query["NextHopType"] = request.NextHopType
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("UpdateGatewayRouteTableEntryAttribute"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &UpdateGatewayRouteTableEntryAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Modifies the next hop type and next hop of the route entry in a gateway route table.
//
// @param request - UpdateGatewayRouteTableEntryAttributeRequest
//
// @return UpdateGatewayRouteTableEntryAttributeResponse
func (client *Client) UpdateGatewayRouteTableEntryAttribute(request *UpdateGatewayRouteTableEntryAttributeRequest) (_result *UpdateGatewayRouteTableEntryAttributeResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &UpdateGatewayRouteTableEntryAttributeResponse{}
	_body, _err := client.UpdateGatewayRouteTableEntryAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Modifies the configuration of an IPsec server.
//
// Description:
//
//	  If you modify only **IpsecServerName*	- of the IPsec server, this operation is synchronous. If you modify other parameters besides **IpsecServerName**, this operation is asynchronous.
//
//		- If **UpdateIpsecServer*	- is an asynchronous operation, after a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) operation to query the status of the task.
//
//	    	- If the VPN gateway is in the **updating*	- state, the IPsec server is being modified.
//
//	    	- If the VPN gateway is in the **active*	- state, the IPsec server is modified.
//
//		- You cannot repeatedly call **UpdateIpsecServer*	- within the specified period of time.
//
// @param request - UpdateIpsecServerRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateIpsecServerResponse
func (client *Client) UpdateIpsecServerWithOptions(request *UpdateIpsecServerRequest, runtime *dara.RuntimeOptions) (_result *UpdateIpsecServerResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientIpPool) {
		query["ClientIpPool"] = request.ClientIpPool
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.EffectImmediately) {
		query["EffectImmediately"] = request.EffectImmediately
	}

	if !dara.IsNil(request.IkeConfig) {
		query["IkeConfig"] = request.IkeConfig
	}

	if !dara.IsNil(request.IpsecConfig) {
		query["IpsecConfig"] = request.IpsecConfig
	}

	if !dara.IsNil(request.IpsecServerId) {
		query["IpsecServerId"] = request.IpsecServerId
	}

	if !dara.IsNil(request.IpsecServerName) {
		query["IpsecServerName"] = request.IpsecServerName
	}

	if !dara.IsNil(request.LocalSubnet) {
		query["LocalSubnet"] = request.LocalSubnet
	}

	if !dara.IsNil(request.Psk) {
		query["Psk"] = request.Psk
	}

	if !dara.IsNil(request.PskEnabled) {
		query["PskEnabled"] = request.PskEnabled
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("UpdateIpsecServer"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &UpdateIpsecServerResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Modifies the configuration of an IPsec server.
//
// Description:
//
//	  If you modify only **IpsecServerName*	- of the IPsec server, this operation is synchronous. If you modify other parameters besides **IpsecServerName**, this operation is asynchronous.
//
//		- If **UpdateIpsecServer*	- is an asynchronous operation, after a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) operation to query the status of the task.
//
//	    	- If the VPN gateway is in the **updating*	- state, the IPsec server is being modified.
//
//	    	- If the VPN gateway is in the **active*	- state, the IPsec server is modified.
//
//		- You cannot repeatedly call **UpdateIpsecServer*	- within the specified period of time.
//
// @param request - UpdateIpsecServerRequest
//
// @return UpdateIpsecServerResponse
func (client *Client) UpdateIpsecServer(request *UpdateIpsecServerRequest) (_result *UpdateIpsecServerResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &UpdateIpsecServerResponse{}
	_body, _err := client.UpdateIpsecServerWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Modifies the description or name of an IPv4 gateway.
//
// Description:
//
// You cannot repeatedly call the **UpdateIpv4GatewayAttribute*	- operation to modify the name or description of an IPv4 gateway within the specified period of time.
//
// @param request - UpdateIpv4GatewayAttributeRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateIpv4GatewayAttributeResponse
func (client *Client) UpdateIpv4GatewayAttributeWithOptions(request *UpdateIpv4GatewayAttributeRequest, runtime *dara.RuntimeOptions) (_result *UpdateIpv4GatewayAttributeResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.Ipv4GatewayDescription) {
		query["Ipv4GatewayDescription"] = request.Ipv4GatewayDescription
	}

	if !dara.IsNil(request.Ipv4GatewayId) {
		query["Ipv4GatewayId"] = request.Ipv4GatewayId
	}

	if !dara.IsNil(request.Ipv4GatewayName) {
		query["Ipv4GatewayName"] = request.Ipv4GatewayName
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("UpdateIpv4GatewayAttribute"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &UpdateIpv4GatewayAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Modifies the description or name of an IPv4 gateway.
//
// Description:
//
// You cannot repeatedly call the **UpdateIpv4GatewayAttribute*	- operation to modify the name or description of an IPv4 gateway within the specified period of time.
//
// @param request - UpdateIpv4GatewayAttributeRequest
//
// @return UpdateIpv4GatewayAttributeResponse
func (client *Client) UpdateIpv4GatewayAttribute(request *UpdateIpv4GatewayAttributeRequest) (_result *UpdateIpv4GatewayAttributeResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &UpdateIpv4GatewayAttributeResponse{}
	_body, _err := client.UpdateIpv4GatewayAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Deprecated: OpenAPI UpdateNatGatewayNatType is deprecated
//
// Summary:
//
// Upgrades a standard NAT gateway to an enhanced NAT gateway.
//
// Description:
//
// Before you call this operation, take note of the following limits:
//
//   - **UpdateNatGatewayNatType*	- is an asynchronous operation. After you send a request to call this operation, the system returns a request ID and the NAT gateway is still being upgraded in the backend. You can call the GetNatGatewayConvertStatus operation to query the upgrade progress of a NAT gateway. For more information, see [GetNatGatewayConvertStatus](https://help.aliyun.com/document_detail/184744.html).
//
//   - If the NAT gateway is in the **processing*	- state, the NAT gateway is being upgraded. You can only query the status of the NAT gateway but cannot perform other operations.
//
//   - If the NAT gateway is in the **successful*	- state, the NAT gateway is upgraded.
//
//   - If the NAT gateway is in the **failed*	- state, the system failed to upgrade the NAT gateway.
//
//   - You cannot repeatedly call the **UpdateNatGatewayNatType*	- operation for the same VPN gateway within the specified period of time.
//
//   - The billing method and billable items remain the same after the upgrade.
//
//   - It takes about five minutes to upgrade a standard NAT gateway to an enhanced NAT gateway. During the upgrade, transient connection errors may occur once or twice. The service can be recovered by reconnection. You can determine whether to enable automatic reconnection or use manual reconnection based on your business requirements.
//
//   - You can only upgrade standard NAT gateways to enhanced NAT gateways. You are not allowed to downgrade enhanced NAT gateways to standard NAT gateways.
//
// @param request - UpdateNatGatewayNatTypeRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateNatGatewayNatTypeResponse
func (client *Client) UpdateNatGatewayNatTypeWithOptions(request *UpdateNatGatewayNatTypeRequest, runtime *dara.RuntimeOptions) (_result *UpdateNatGatewayNatTypeResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.NatGatewayId) {
		query["NatGatewayId"] = request.NatGatewayId
	}

	if !dara.IsNil(request.NatType) {
		query["NatType"] = request.NatType
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.VSwitchId) {
		query["VSwitchId"] = request.VSwitchId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("UpdateNatGatewayNatType"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &UpdateNatGatewayNatTypeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Deprecated: OpenAPI UpdateNatGatewayNatType is deprecated
//
// Summary:
//
// Upgrades a standard NAT gateway to an enhanced NAT gateway.
//
// Description:
//
// Before you call this operation, take note of the following limits:
//
//   - **UpdateNatGatewayNatType*	- is an asynchronous operation. After you send a request to call this operation, the system returns a request ID and the NAT gateway is still being upgraded in the backend. You can call the GetNatGatewayConvertStatus operation to query the upgrade progress of a NAT gateway. For more information, see [GetNatGatewayConvertStatus](https://help.aliyun.com/document_detail/184744.html).
//
//   - If the NAT gateway is in the **processing*	- state, the NAT gateway is being upgraded. You can only query the status of the NAT gateway but cannot perform other operations.
//
//   - If the NAT gateway is in the **successful*	- state, the NAT gateway is upgraded.
//
//   - If the NAT gateway is in the **failed*	- state, the system failed to upgrade the NAT gateway.
//
//   - You cannot repeatedly call the **UpdateNatGatewayNatType*	- operation for the same VPN gateway within the specified period of time.
//
//   - The billing method and billable items remain the same after the upgrade.
//
//   - It takes about five minutes to upgrade a standard NAT gateway to an enhanced NAT gateway. During the upgrade, transient connection errors may occur once or twice. The service can be recovered by reconnection. You can determine whether to enable automatic reconnection or use manual reconnection based on your business requirements.
//
//   - You can only upgrade standard NAT gateways to enhanced NAT gateways. You are not allowed to downgrade enhanced NAT gateways to standard NAT gateways.
//
// @param request - UpdateNatGatewayNatTypeRequest
//
// @return UpdateNatGatewayNatTypeResponse
// Deprecated
func (client *Client) UpdateNatGatewayNatType(request *UpdateNatGatewayNatTypeRequest) (_result *UpdateNatGatewayNatTypeResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &UpdateNatGatewayNatTypeResponse{}
	_body, _err := client.UpdateNatGatewayNatTypeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Updates the rules of a network access control list (ACL).
//
// Description:
//
//	  **UpdateNetworkAclEntries*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeNetworkAclAttributes](https://help.aliyun.com/document_detail/116542.html) operation to query the status of a network ACL:
//
//	    	- If the network ACL is in the **Modifying*	- state, the rules of the network ACL are being updated.
//
//	    	- If the network ACL is in the **Available*	- state, the rules of the network ACL are updated.
//
//		- You cannot repeatedly call the **UpdateNetworkAclEntries*	- operation to update the rules of a network ACL within the specified period of time.
//
// @param request - UpdateNetworkAclEntriesRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateNetworkAclEntriesResponse
func (client *Client) UpdateNetworkAclEntriesWithOptions(request *UpdateNetworkAclEntriesRequest, runtime *dara.RuntimeOptions) (_result *UpdateNetworkAclEntriesResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.EgressAclEntries) {
		query["EgressAclEntries"] = request.EgressAclEntries
	}

	if !dara.IsNil(request.IngressAclEntries) {
		query["IngressAclEntries"] = request.IngressAclEntries
	}

	if !dara.IsNil(request.NetworkAclId) {
		query["NetworkAclId"] = request.NetworkAclId
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.UpdateEgressAclEntries) {
		query["UpdateEgressAclEntries"] = request.UpdateEgressAclEntries
	}

	if !dara.IsNil(request.UpdateIngressAclEntries) {
		query["UpdateIngressAclEntries"] = request.UpdateIngressAclEntries
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("UpdateNetworkAclEntries"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &UpdateNetworkAclEntriesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Updates the rules of a network access control list (ACL).
//
// Description:
//
//	  **UpdateNetworkAclEntries*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeNetworkAclAttributes](https://help.aliyun.com/document_detail/116542.html) operation to query the status of a network ACL:
//
//	    	- If the network ACL is in the **Modifying*	- state, the rules of the network ACL are being updated.
//
//	    	- If the network ACL is in the **Available*	- state, the rules of the network ACL are updated.
//
//		- You cannot repeatedly call the **UpdateNetworkAclEntries*	- operation to update the rules of a network ACL within the specified period of time.
//
// @param request - UpdateNetworkAclEntriesRequest
//
// @return UpdateNetworkAclEntriesResponse
func (client *Client) UpdateNetworkAclEntries(request *UpdateNetworkAclEntriesRequest) (_result *UpdateNetworkAclEntriesResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &UpdateNetworkAclEntriesResponse{}
	_body, _err := client.UpdateNetworkAclEntriesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Modifies the attributes of an IP address pool.
//
// Description:
//
// You cannot repeatedly call the **UpdatePublicIpAddressPoolAttribute*	- operation to modify the attributes of an IP address pool within the specified period of time.
//
// @param request - UpdatePublicIpAddressPoolAttributeRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdatePublicIpAddressPoolAttributeResponse
func (client *Client) UpdatePublicIpAddressPoolAttributeWithOptions(request *UpdatePublicIpAddressPoolAttributeRequest, runtime *dara.RuntimeOptions) (_result *UpdatePublicIpAddressPoolAttributeResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.Description) {
		query["Description"] = request.Description
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.Name) {
		query["Name"] = request.Name
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PublicIpAddressPoolId) {
		query["PublicIpAddressPoolId"] = request.PublicIpAddressPoolId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("UpdatePublicIpAddressPoolAttribute"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &UpdatePublicIpAddressPoolAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Modifies the attributes of an IP address pool.
//
// Description:
//
// You cannot repeatedly call the **UpdatePublicIpAddressPoolAttribute*	- operation to modify the attributes of an IP address pool within the specified period of time.
//
// @param request - UpdatePublicIpAddressPoolAttributeRequest
//
// @return UpdatePublicIpAddressPoolAttributeResponse
func (client *Client) UpdatePublicIpAddressPoolAttribute(request *UpdatePublicIpAddressPoolAttributeRequest) (_result *UpdatePublicIpAddressPoolAttributeResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &UpdatePublicIpAddressPoolAttributeResponse{}
	_body, _err := client.UpdatePublicIpAddressPoolAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Modifies the configuration of a filter for traffic mirror.
//
// Description:
//
// You cannot repeatedly call the **UpdateTrafficMirrorFilterAttribute*	- operation to modify the configuration of a filter for traffic mirror within the specified period of time.
//
// @param request - UpdateTrafficMirrorFilterAttributeRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateTrafficMirrorFilterAttributeResponse
func (client *Client) UpdateTrafficMirrorFilterAttributeWithOptions(request *UpdateTrafficMirrorFilterAttributeRequest, runtime *dara.RuntimeOptions) (_result *UpdateTrafficMirrorFilterAttributeResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.TrafficMirrorFilterDescription) {
		query["TrafficMirrorFilterDescription"] = request.TrafficMirrorFilterDescription
	}

	if !dara.IsNil(request.TrafficMirrorFilterId) {
		query["TrafficMirrorFilterId"] = request.TrafficMirrorFilterId
	}

	if !dara.IsNil(request.TrafficMirrorFilterName) {
		query["TrafficMirrorFilterName"] = request.TrafficMirrorFilterName
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("UpdateTrafficMirrorFilterAttribute"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &UpdateTrafficMirrorFilterAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Modifies the configuration of a filter for traffic mirror.
//
// Description:
//
// You cannot repeatedly call the **UpdateTrafficMirrorFilterAttribute*	- operation to modify the configuration of a filter for traffic mirror within the specified period of time.
//
// @param request - UpdateTrafficMirrorFilterAttributeRequest
//
// @return UpdateTrafficMirrorFilterAttributeResponse
func (client *Client) UpdateTrafficMirrorFilterAttribute(request *UpdateTrafficMirrorFilterAttributeRequest) (_result *UpdateTrafficMirrorFilterAttributeResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &UpdateTrafficMirrorFilterAttributeResponse{}
	_body, _err := client.UpdateTrafficMirrorFilterAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Modifies the configuration of an inbound or outbound rule for traffic mirroring.
//
// Description:
//
//	  The **UpdateTrafficMirrorFilterRuleAttribute*	- operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [ListTrafficMirrorFilters](https://help.aliyun.com/document_detail/261353.html) operation to query the status of an inbound or outbound rule:
//
//	    	- If the rule is in the **Modifying*	- state, the rule is being modified.
//
//	    	- If the rule is in the **Created*	- state, the rule is modified.
//
//		- You cannot repeatedly call the **UpdateTrafficMirrorFilterRuleAttribute*	- operation to modify an inbound or outbound rule within the specified period of time.
//
// @param request - UpdateTrafficMirrorFilterRuleAttributeRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateTrafficMirrorFilterRuleAttributeResponse
func (client *Client) UpdateTrafficMirrorFilterRuleAttributeWithOptions(request *UpdateTrafficMirrorFilterRuleAttributeRequest, runtime *dara.RuntimeOptions) (_result *UpdateTrafficMirrorFilterRuleAttributeResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DestinationCidrBlock) {
		query["DestinationCidrBlock"] = request.DestinationCidrBlock
	}

	if !dara.IsNil(request.DestinationPortRange) {
		query["DestinationPortRange"] = request.DestinationPortRange
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.Priority) {
		query["Priority"] = request.Priority
	}

	if !dara.IsNil(request.Protocol) {
		query["Protocol"] = request.Protocol
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.RuleAction) {
		query["RuleAction"] = request.RuleAction
	}

	if !dara.IsNil(request.SourceCidrBlock) {
		query["SourceCidrBlock"] = request.SourceCidrBlock
	}

	if !dara.IsNil(request.SourcePortRange) {
		query["SourcePortRange"] = request.SourcePortRange
	}

	if !dara.IsNil(request.TrafficMirrorFilterRuleId) {
		query["TrafficMirrorFilterRuleId"] = request.TrafficMirrorFilterRuleId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("UpdateTrafficMirrorFilterRuleAttribute"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &UpdateTrafficMirrorFilterRuleAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Modifies the configuration of an inbound or outbound rule for traffic mirroring.
//
// Description:
//
//	  The **UpdateTrafficMirrorFilterRuleAttribute*	- operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [ListTrafficMirrorFilters](https://help.aliyun.com/document_detail/261353.html) operation to query the status of an inbound or outbound rule:
//
//	    	- If the rule is in the **Modifying*	- state, the rule is being modified.
//
//	    	- If the rule is in the **Created*	- state, the rule is modified.
//
//		- You cannot repeatedly call the **UpdateTrafficMirrorFilterRuleAttribute*	- operation to modify an inbound or outbound rule within the specified period of time.
//
// @param request - UpdateTrafficMirrorFilterRuleAttributeRequest
//
// @return UpdateTrafficMirrorFilterRuleAttributeResponse
func (client *Client) UpdateTrafficMirrorFilterRuleAttribute(request *UpdateTrafficMirrorFilterRuleAttributeRequest) (_result *UpdateTrafficMirrorFilterRuleAttributeResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &UpdateTrafficMirrorFilterRuleAttributeResponse{}
	_body, _err := client.UpdateTrafficMirrorFilterRuleAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Modifies the configuration of a traffic mirror session.
//
// Description:
//
// ## Usage notes
//
//   - **UpdateTrafficMirrorSessionAttribute*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListTrafficMirrorSessions](https://help.aliyun.com/document_detail/261367.html) operation to query the status of the task.
//
//   - If the traffic mirror session is in the **Modifying*	- state, the configuration of the traffic mirror session is being modified.
//
//   - If the traffic mirror session is in the **Created*	- state, the configuration of the traffic mirror session is modified.
//
//   - You cannot repeatedly call the **UpdateTrafficMirrorSessionAttribute*	- operation within a specific period of time.
//
// @param request - UpdateTrafficMirrorSessionAttributeRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateTrafficMirrorSessionAttributeResponse
func (client *Client) UpdateTrafficMirrorSessionAttributeWithOptions(request *UpdateTrafficMirrorSessionAttributeRequest, runtime *dara.RuntimeOptions) (_result *UpdateTrafficMirrorSessionAttributeResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.Enabled) {
		query["Enabled"] = request.Enabled
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PacketLength) {
		query["PacketLength"] = request.PacketLength
	}

	if !dara.IsNil(request.Priority) {
		query["Priority"] = request.Priority
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.TrafficMirrorFilterId) {
		query["TrafficMirrorFilterId"] = request.TrafficMirrorFilterId
	}

	if !dara.IsNil(request.TrafficMirrorSessionDescription) {
		query["TrafficMirrorSessionDescription"] = request.TrafficMirrorSessionDescription
	}

	if !dara.IsNil(request.TrafficMirrorSessionId) {
		query["TrafficMirrorSessionId"] = request.TrafficMirrorSessionId
	}

	if !dara.IsNil(request.TrafficMirrorSessionName) {
		query["TrafficMirrorSessionName"] = request.TrafficMirrorSessionName
	}

	if !dara.IsNil(request.TrafficMirrorTargetId) {
		query["TrafficMirrorTargetId"] = request.TrafficMirrorTargetId
	}

	if !dara.IsNil(request.TrafficMirrorTargetType) {
		query["TrafficMirrorTargetType"] = request.TrafficMirrorTargetType
	}

	if !dara.IsNil(request.VirtualNetworkId) {
		query["VirtualNetworkId"] = request.VirtualNetworkId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("UpdateTrafficMirrorSessionAttribute"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &UpdateTrafficMirrorSessionAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Modifies the configuration of a traffic mirror session.
//
// Description:
//
// ## Usage notes
//
//   - **UpdateTrafficMirrorSessionAttribute*	- is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListTrafficMirrorSessions](https://help.aliyun.com/document_detail/261367.html) operation to query the status of the task.
//
//   - If the traffic mirror session is in the **Modifying*	- state, the configuration of the traffic mirror session is being modified.
//
//   - If the traffic mirror session is in the **Created*	- state, the configuration of the traffic mirror session is modified.
//
//   - You cannot repeatedly call the **UpdateTrafficMirrorSessionAttribute*	- operation within a specific period of time.
//
// @param request - UpdateTrafficMirrorSessionAttributeRequest
//
// @return UpdateTrafficMirrorSessionAttributeResponse
func (client *Client) UpdateTrafficMirrorSessionAttribute(request *UpdateTrafficMirrorSessionAttributeRequest) (_result *UpdateTrafficMirrorSessionAttributeResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &UpdateTrafficMirrorSessionAttributeResponse{}
	_body, _err := client.UpdateTrafficMirrorSessionAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Updates the maximum bandwidth value of outbound data transfer for a virtual border router (VBR).
//
// @param request - UpdateVirtualBorderBandwidthRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateVirtualBorderBandwidthResponse
func (client *Client) UpdateVirtualBorderBandwidthWithOptions(request *UpdateVirtualBorderBandwidthRequest, runtime *dara.RuntimeOptions) (_result *UpdateVirtualBorderBandwidthResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.Bandwidth) {
		query["Bandwidth"] = request.Bandwidth
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.VirtualBorderRouterId) {
		query["VirtualBorderRouterId"] = request.VirtualBorderRouterId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("UpdateVirtualBorderBandwidth"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &UpdateVirtualBorderBandwidthResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Updates the maximum bandwidth value of outbound data transfer for a virtual border router (VBR).
//
// @param request - UpdateVirtualBorderBandwidthRequest
//
// @return UpdateVirtualBorderBandwidthResponse
func (client *Client) UpdateVirtualBorderBandwidth(request *UpdateVirtualBorderBandwidthRequest) (_result *UpdateVirtualBorderBandwidthResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &UpdateVirtualBorderBandwidthResponse{}
	_body, _err := client.UpdateVirtualBorderBandwidthWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Changes the virtual local area network (VLAN) ID of a hosted connection over Express Connect circuit.
//
// @param request - UpdateVirtualPhysicalConnectionRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateVirtualPhysicalConnectionResponse
func (client *Client) UpdateVirtualPhysicalConnectionWithOptions(request *UpdateVirtualPhysicalConnectionRequest, runtime *dara.RuntimeOptions) (_result *UpdateVirtualPhysicalConnectionResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.ExpectSpec) {
		query["ExpectSpec"] = request.ExpectSpec
	}

	if !dara.IsNil(request.InstanceId) {
		query["InstanceId"] = request.InstanceId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.Token) {
		query["Token"] = request.Token
	}

	if !dara.IsNil(request.VlanId) {
		query["VlanId"] = request.VlanId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("UpdateVirtualPhysicalConnection"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &UpdateVirtualPhysicalConnectionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Changes the virtual local area network (VLAN) ID of a hosted connection over Express Connect circuit.
//
// @param request - UpdateVirtualPhysicalConnectionRequest
//
// @return UpdateVirtualPhysicalConnectionResponse
func (client *Client) UpdateVirtualPhysicalConnection(request *UpdateVirtualPhysicalConnectionRequest) (_result *UpdateVirtualPhysicalConnectionResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &UpdateVirtualPhysicalConnectionResponse{}
	_body, _err := client.UpdateVirtualPhysicalConnectionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Modifies the configuration of a gateway endpoint.
//
// Description:
//
//	  **UpdateVpcGatewayEndpointAttribute*	- is an asynchronous operation. After a request is sent, the system returns a **request ID*	- and runs the task in the background. You can call the [GetVpcGatewayEndpointAttribute](https://help.aliyun.com/document_detail/311017.html) operation to query the status of the task.
//
//	    	- If the gateway endpoint is in the **Updating*	- state, it is being modified.
//
//	    	- If the gateway endpoint is in the **Created*	- state, it is modified.
//
//		- You cannot call the **UpdateVpcGatewayEndpointAttribute*	- operation within a specific period of time.
//
// @param request - UpdateVpcGatewayEndpointAttributeRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateVpcGatewayEndpointAttributeResponse
func (client *Client) UpdateVpcGatewayEndpointAttributeWithOptions(request *UpdateVpcGatewayEndpointAttributeRequest, runtime *dara.RuntimeOptions) (_result *UpdateVpcGatewayEndpointAttributeResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.EndpointDescription) {
		query["EndpointDescription"] = request.EndpointDescription
	}

	if !dara.IsNil(request.EndpointId) {
		query["EndpointId"] = request.EndpointId
	}

	if !dara.IsNil(request.EndpointName) {
		query["EndpointName"] = request.EndpointName
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.PolicyDocument) {
		query["PolicyDocument"] = request.PolicyDocument
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("UpdateVpcGatewayEndpointAttribute"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &UpdateVpcGatewayEndpointAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Modifies the configuration of a gateway endpoint.
//
// Description:
//
//	  **UpdateVpcGatewayEndpointAttribute*	- is an asynchronous operation. After a request is sent, the system returns a **request ID*	- and runs the task in the background. You can call the [GetVpcGatewayEndpointAttribute](https://help.aliyun.com/document_detail/311017.html) operation to query the status of the task.
//
//	    	- If the gateway endpoint is in the **Updating*	- state, it is being modified.
//
//	    	- If the gateway endpoint is in the **Created*	- state, it is modified.
//
//		- You cannot call the **UpdateVpcGatewayEndpointAttribute*	- operation within a specific period of time.
//
// @param request - UpdateVpcGatewayEndpointAttributeRequest
//
// @return UpdateVpcGatewayEndpointAttributeResponse
func (client *Client) UpdateVpcGatewayEndpointAttribute(request *UpdateVpcGatewayEndpointAttributeRequest) (_result *UpdateVpcGatewayEndpointAttributeResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &UpdateVpcGatewayEndpointAttributeResponse{}
	_body, _err := client.UpdateVpcGatewayEndpointAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// eni quota
//
// Description:
//
// Before you call this operation, make sure that a VPC NAT gateway is created. For more information, see [CreateNatGateway](https://help.aliyun.com/document_detail/120219.html).
//
// @param request - VpcDescribeVpcNatGatewayNetworkInterfaceQuotaRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return VpcDescribeVpcNatGatewayNetworkInterfaceQuotaResponse
func (client *Client) VpcDescribeVpcNatGatewayNetworkInterfaceQuotaWithOptions(request *VpcDescribeVpcNatGatewayNetworkInterfaceQuotaRequest, runtime *dara.RuntimeOptions) (_result *VpcDescribeVpcNatGatewayNetworkInterfaceQuotaResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.NatGatewayId) {
		query["NatGatewayId"] = request.NatGatewayId
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.ResourceUid) {
		query["ResourceUid"] = request.ResourceUid
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("VpcDescribeVpcNatGatewayNetworkInterfaceQuota"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &VpcDescribeVpcNatGatewayNetworkInterfaceQuotaResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// eni quota
//
// Description:
//
// Before you call this operation, make sure that a VPC NAT gateway is created. For more information, see [CreateNatGateway](https://help.aliyun.com/document_detail/120219.html).
//
// @param request - VpcDescribeVpcNatGatewayNetworkInterfaceQuotaRequest
//
// @return VpcDescribeVpcNatGatewayNetworkInterfaceQuotaResponse
func (client *Client) VpcDescribeVpcNatGatewayNetworkInterfaceQuota(request *VpcDescribeVpcNatGatewayNetworkInterfaceQuotaRequest) (_result *VpcDescribeVpcNatGatewayNetworkInterfaceQuotaResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &VpcDescribeVpcNatGatewayNetworkInterfaceQuotaResponse{}
	_body, _err := client.VpcDescribeVpcNatGatewayNetworkInterfaceQuotaWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Withdraw advertised Virtual Private Cloud (VPC) routes.
//
// @param request - WithdrawVpcPublishedRouteEntriesRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return WithdrawVpcPublishedRouteEntriesResponse
func (client *Client) WithdrawVpcPublishedRouteEntriesWithOptions(request *WithdrawVpcPublishedRouteEntriesRequest, runtime *dara.RuntimeOptions) (_result *WithdrawVpcPublishedRouteEntriesResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.OwnerAccount) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !dara.IsNil(request.OwnerId) {
		query["OwnerId"] = request.OwnerId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceOwnerAccount) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !dara.IsNil(request.ResourceOwnerId) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !dara.IsNil(request.RouteEntries) {
		query["RouteEntries"] = request.RouteEntries
	}

	if !dara.IsNil(request.TargetInstanceId) {
		query["TargetInstanceId"] = request.TargetInstanceId
	}

	if !dara.IsNil(request.TargetType) {
		query["TargetType"] = request.TargetType
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("WithdrawVpcPublishedRouteEntries"),
		Version:     dara.String("2016-04-28"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	_result = &WithdrawVpcPublishedRouteEntriesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = dara.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Withdraw advertised Virtual Private Cloud (VPC) routes.
//
// @param request - WithdrawVpcPublishedRouteEntriesRequest
//
// @return WithdrawVpcPublishedRouteEntriesResponse
func (client *Client) WithdrawVpcPublishedRouteEntries(request *WithdrawVpcPublishedRouteEntriesRequest) (_result *WithdrawVpcPublishedRouteEntriesResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_result = &WithdrawVpcPublishedRouteEntriesResponse{}
	_body, _err := client.WithdrawVpcPublishedRouteEntriesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}
