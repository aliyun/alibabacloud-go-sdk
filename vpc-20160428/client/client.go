// This file is auto-generated, don't edit it. Thanks.
/**
 *
 */
package client

import (
	openapi "github.com/alibabacloud-go/darabonba-openapi/v2/client"
	endpointutil "github.com/alibabacloud-go/endpoint-util/service"
	openapiutil "github.com/alibabacloud-go/openapi-util/service"
	util "github.com/alibabacloud-go/tea-utils/v2/service"
	"github.com/alibabacloud-go/tea/tea"
)

type ActivateRouterInterfaceRequest struct {
	OwnerId *int64 `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region to which the router interface belongs.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the router interface.
	RouterInterfaceId *string `json:"RouterInterfaceId,omitempty" xml:"RouterInterfaceId,omitempty"`
}

func (s ActivateRouterInterfaceRequest) String() string {
	return tea.Prettify(s)
}

func (s ActivateRouterInterfaceRequest) GoString() string {
	return s.String()
}

func (s *ActivateRouterInterfaceRequest) SetOwnerId(v int64) *ActivateRouterInterfaceRequest {
	s.OwnerId = &v
	return s
}

func (s *ActivateRouterInterfaceRequest) SetRegionId(v string) *ActivateRouterInterfaceRequest {
	s.RegionId = &v
	return s
}

func (s *ActivateRouterInterfaceRequest) SetResourceOwnerAccount(v string) *ActivateRouterInterfaceRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ActivateRouterInterfaceRequest) SetResourceOwnerId(v int64) *ActivateRouterInterfaceRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ActivateRouterInterfaceRequest) SetRouterInterfaceId(v string) *ActivateRouterInterfaceRequest {
	s.RouterInterfaceId = &v
	return s
}

type ActivateRouterInterfaceResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ActivateRouterInterfaceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ActivateRouterInterfaceResponseBody) GoString() string {
	return s.String()
}

func (s *ActivateRouterInterfaceResponseBody) SetRequestId(v string) *ActivateRouterInterfaceResponseBody {
	s.RequestId = &v
	return s
}

type ActivateRouterInterfaceResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ActivateRouterInterfaceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ActivateRouterInterfaceResponse) String() string {
	return tea.Prettify(s)
}

func (s ActivateRouterInterfaceResponse) GoString() string {
	return s.String()
}

func (s *ActivateRouterInterfaceResponse) SetHeaders(v map[string]*string) *ActivateRouterInterfaceResponse {
	s.Headers = v
	return s
}

func (s *ActivateRouterInterfaceResponse) SetStatusCode(v int32) *ActivateRouterInterfaceResponse {
	s.StatusCode = &v
	return s
}

func (s *ActivateRouterInterfaceResponse) SetBody(v *ActivateRouterInterfaceResponseBody) *ActivateRouterInterfaceResponse {
	s.Body = v
	return s
}

type ActiveFlowLogRequest struct {
	// The ID of the flow log.
	FlowLogId    *string `json:"FlowLogId,omitempty" xml:"FlowLogId,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region where you want to create the flow log. You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ActiveFlowLogRequest) String() string {
	return tea.Prettify(s)
}

func (s ActiveFlowLogRequest) GoString() string {
	return s.String()
}

func (s *ActiveFlowLogRequest) SetFlowLogId(v string) *ActiveFlowLogRequest {
	s.FlowLogId = &v
	return s
}

func (s *ActiveFlowLogRequest) SetOwnerAccount(v string) *ActiveFlowLogRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ActiveFlowLogRequest) SetOwnerId(v int64) *ActiveFlowLogRequest {
	s.OwnerId = &v
	return s
}

func (s *ActiveFlowLogRequest) SetRegionId(v string) *ActiveFlowLogRequest {
	s.RegionId = &v
	return s
}

func (s *ActiveFlowLogRequest) SetResourceOwnerAccount(v string) *ActiveFlowLogRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ActiveFlowLogRequest) SetResourceOwnerId(v int64) *ActiveFlowLogRequest {
	s.ResourceOwnerId = &v
	return s
}

type ActiveFlowLogResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the operation is successful. Valid values:
	//
	// *   **true**: yes
	// *   **false**: no
	Success *string `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ActiveFlowLogResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ActiveFlowLogResponseBody) GoString() string {
	return s.String()
}

func (s *ActiveFlowLogResponseBody) SetRequestId(v string) *ActiveFlowLogResponseBody {
	s.RequestId = &v
	return s
}

func (s *ActiveFlowLogResponseBody) SetSuccess(v string) *ActiveFlowLogResponseBody {
	s.Success = &v
	return s
}

type ActiveFlowLogResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ActiveFlowLogResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ActiveFlowLogResponse) String() string {
	return tea.Prettify(s)
}

func (s ActiveFlowLogResponse) GoString() string {
	return s.String()
}

func (s *ActiveFlowLogResponse) SetHeaders(v map[string]*string) *ActiveFlowLogResponse {
	s.Headers = v
	return s
}

func (s *ActiveFlowLogResponse) SetStatusCode(v int32) *ActiveFlowLogResponse {
	s.StatusCode = &v
	return s
}

func (s *ActiveFlowLogResponse) SetBody(v *ActiveFlowLogResponseBody) *ActiveFlowLogResponse {
	s.Body = v
	return s
}

type AddBgpNetworkRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can contain only ASCII characters.
	//
	// >  If you do not specify this parameter, the system automatically uses **RequestId** as **ClientToken**. **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The CIDR block of the virtual private cloud (VPC) or vSwitch that you want to connect to a data center.
	DstCidrBlock *string `json:"DstCidrBlock,omitempty" xml:"DstCidrBlock,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the virtual border router (VBR) group.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the router that is associated with the router interface.
	RouterId *string `json:"RouterId,omitempty" xml:"RouterId,omitempty"`
	// The ID of the VPC.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s AddBgpNetworkRequest) String() string {
	return tea.Prettify(s)
}

func (s AddBgpNetworkRequest) GoString() string {
	return s.String()
}

func (s *AddBgpNetworkRequest) SetClientToken(v string) *AddBgpNetworkRequest {
	s.ClientToken = &v
	return s
}

func (s *AddBgpNetworkRequest) SetDstCidrBlock(v string) *AddBgpNetworkRequest {
	s.DstCidrBlock = &v
	return s
}

func (s *AddBgpNetworkRequest) SetOwnerAccount(v string) *AddBgpNetworkRequest {
	s.OwnerAccount = &v
	return s
}

func (s *AddBgpNetworkRequest) SetOwnerId(v int64) *AddBgpNetworkRequest {
	s.OwnerId = &v
	return s
}

func (s *AddBgpNetworkRequest) SetRegionId(v string) *AddBgpNetworkRequest {
	s.RegionId = &v
	return s
}

func (s *AddBgpNetworkRequest) SetResourceOwnerAccount(v string) *AddBgpNetworkRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *AddBgpNetworkRequest) SetResourceOwnerId(v int64) *AddBgpNetworkRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *AddBgpNetworkRequest) SetRouterId(v string) *AddBgpNetworkRequest {
	s.RouterId = &v
	return s
}

func (s *AddBgpNetworkRequest) SetVpcId(v string) *AddBgpNetworkRequest {
	s.VpcId = &v
	return s
}

type AddBgpNetworkResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AddBgpNetworkResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddBgpNetworkResponseBody) GoString() string {
	return s.String()
}

func (s *AddBgpNetworkResponseBody) SetRequestId(v string) *AddBgpNetworkResponseBody {
	s.RequestId = &v
	return s
}

type AddBgpNetworkResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddBgpNetworkResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddBgpNetworkResponse) String() string {
	return tea.Prettify(s)
}

func (s AddBgpNetworkResponse) GoString() string {
	return s.String()
}

func (s *AddBgpNetworkResponse) SetHeaders(v map[string]*string) *AddBgpNetworkResponse {
	s.Headers = v
	return s
}

func (s *AddBgpNetworkResponse) SetStatusCode(v int32) *AddBgpNetworkResponse {
	s.StatusCode = &v
	return s
}

func (s *AddBgpNetworkResponse) SetBody(v *AddBgpNetworkResponseBody) *AddBgpNetworkResponse {
	s.Body = v
	return s
}

type AddCommonBandwidthPackageIpRequest struct {
	// The ID of the EIP bandwidth plan.
	BandwidthPackageId *string `json:"BandwidthPackageId,omitempty" xml:"BandwidthPackageId,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, the system uses **RequestId** as **ClientToken**. The value of **RequestId** for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the EIP.
	//
	// You can call the [DescribeEipAddresses](~~36018~~) operation to query the most recent region list.
	IpInstanceId *string `json:"IpInstanceId,omitempty" xml:"IpInstanceId,omitempty"`
	// The type of IP address. Set the value to **EIP** to associate an EIP with the EIP bandwidth plan.
	IpType       *string `json:"IpType,omitempty" xml:"IpType,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the EIP bandwidth plan.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s AddCommonBandwidthPackageIpRequest) String() string {
	return tea.Prettify(s)
}

func (s AddCommonBandwidthPackageIpRequest) GoString() string {
	return s.String()
}

func (s *AddCommonBandwidthPackageIpRequest) SetBandwidthPackageId(v string) *AddCommonBandwidthPackageIpRequest {
	s.BandwidthPackageId = &v
	return s
}

func (s *AddCommonBandwidthPackageIpRequest) SetClientToken(v string) *AddCommonBandwidthPackageIpRequest {
	s.ClientToken = &v
	return s
}

func (s *AddCommonBandwidthPackageIpRequest) SetIpInstanceId(v string) *AddCommonBandwidthPackageIpRequest {
	s.IpInstanceId = &v
	return s
}

func (s *AddCommonBandwidthPackageIpRequest) SetIpType(v string) *AddCommonBandwidthPackageIpRequest {
	s.IpType = &v
	return s
}

func (s *AddCommonBandwidthPackageIpRequest) SetOwnerAccount(v string) *AddCommonBandwidthPackageIpRequest {
	s.OwnerAccount = &v
	return s
}

func (s *AddCommonBandwidthPackageIpRequest) SetOwnerId(v int64) *AddCommonBandwidthPackageIpRequest {
	s.OwnerId = &v
	return s
}

func (s *AddCommonBandwidthPackageIpRequest) SetRegionId(v string) *AddCommonBandwidthPackageIpRequest {
	s.RegionId = &v
	return s
}

func (s *AddCommonBandwidthPackageIpRequest) SetResourceOwnerAccount(v string) *AddCommonBandwidthPackageIpRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *AddCommonBandwidthPackageIpRequest) SetResourceOwnerId(v int64) *AddCommonBandwidthPackageIpRequest {
	s.ResourceOwnerId = &v
	return s
}

type AddCommonBandwidthPackageIpResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AddCommonBandwidthPackageIpResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddCommonBandwidthPackageIpResponseBody) GoString() string {
	return s.String()
}

func (s *AddCommonBandwidthPackageIpResponseBody) SetRequestId(v string) *AddCommonBandwidthPackageIpResponseBody {
	s.RequestId = &v
	return s
}

type AddCommonBandwidthPackageIpResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddCommonBandwidthPackageIpResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddCommonBandwidthPackageIpResponse) String() string {
	return tea.Prettify(s)
}

func (s AddCommonBandwidthPackageIpResponse) GoString() string {
	return s.String()
}

func (s *AddCommonBandwidthPackageIpResponse) SetHeaders(v map[string]*string) *AddCommonBandwidthPackageIpResponse {
	s.Headers = v
	return s
}

func (s *AddCommonBandwidthPackageIpResponse) SetStatusCode(v int32) *AddCommonBandwidthPackageIpResponse {
	s.StatusCode = &v
	return s
}

func (s *AddCommonBandwidthPackageIpResponse) SetBody(v *AddCommonBandwidthPackageIpResponseBody) *AddCommonBandwidthPackageIpResponse {
	s.Body = v
	return s
}

type AddCommonBandwidthPackageIpsRequest struct {
	// The ID of the EIP bandwidth plan.
	BandwidthPackageId *string `json:"BandwidthPackageId,omitempty" xml:"BandwidthPackageId,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, the system uses **RequestId** as **ClientToken**. **RequestId** may be different for each API request.
	ClientToken   *string   `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	IpInstanceIds []*string `json:"IpInstanceIds,omitempty" xml:"IpInstanceIds,omitempty" type:"Repeated"`
	// The type of IP address. Set the value to **EIP** to associate EIPs with the EIP bandwidth plan.
	IpType       *string `json:"IpType,omitempty" xml:"IpType,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the EIP bandwidth plan.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s AddCommonBandwidthPackageIpsRequest) String() string {
	return tea.Prettify(s)
}

func (s AddCommonBandwidthPackageIpsRequest) GoString() string {
	return s.String()
}

func (s *AddCommonBandwidthPackageIpsRequest) SetBandwidthPackageId(v string) *AddCommonBandwidthPackageIpsRequest {
	s.BandwidthPackageId = &v
	return s
}

func (s *AddCommonBandwidthPackageIpsRequest) SetClientToken(v string) *AddCommonBandwidthPackageIpsRequest {
	s.ClientToken = &v
	return s
}

func (s *AddCommonBandwidthPackageIpsRequest) SetIpInstanceIds(v []*string) *AddCommonBandwidthPackageIpsRequest {
	s.IpInstanceIds = v
	return s
}

func (s *AddCommonBandwidthPackageIpsRequest) SetIpType(v string) *AddCommonBandwidthPackageIpsRequest {
	s.IpType = &v
	return s
}

func (s *AddCommonBandwidthPackageIpsRequest) SetOwnerAccount(v string) *AddCommonBandwidthPackageIpsRequest {
	s.OwnerAccount = &v
	return s
}

func (s *AddCommonBandwidthPackageIpsRequest) SetOwnerId(v int64) *AddCommonBandwidthPackageIpsRequest {
	s.OwnerId = &v
	return s
}

func (s *AddCommonBandwidthPackageIpsRequest) SetRegionId(v string) *AddCommonBandwidthPackageIpsRequest {
	s.RegionId = &v
	return s
}

func (s *AddCommonBandwidthPackageIpsRequest) SetResourceOwnerAccount(v string) *AddCommonBandwidthPackageIpsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *AddCommonBandwidthPackageIpsRequest) SetResourceOwnerId(v int64) *AddCommonBandwidthPackageIpsRequest {
	s.ResourceOwnerId = &v
	return s
}

type AddCommonBandwidthPackageIpsResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AddCommonBandwidthPackageIpsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddCommonBandwidthPackageIpsResponseBody) GoString() string {
	return s.String()
}

func (s *AddCommonBandwidthPackageIpsResponseBody) SetRequestId(v string) *AddCommonBandwidthPackageIpsResponseBody {
	s.RequestId = &v
	return s
}

type AddCommonBandwidthPackageIpsResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddCommonBandwidthPackageIpsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddCommonBandwidthPackageIpsResponse) String() string {
	return tea.Prettify(s)
}

func (s AddCommonBandwidthPackageIpsResponse) GoString() string {
	return s.String()
}

func (s *AddCommonBandwidthPackageIpsResponse) SetHeaders(v map[string]*string) *AddCommonBandwidthPackageIpsResponse {
	s.Headers = v
	return s
}

func (s *AddCommonBandwidthPackageIpsResponse) SetStatusCode(v int32) *AddCommonBandwidthPackageIpsResponse {
	s.StatusCode = &v
	return s
}

func (s *AddCommonBandwidthPackageIpsResponse) SetBody(v *AddCommonBandwidthPackageIpsResponseBody) *AddCommonBandwidthPackageIpsResponse {
	s.Body = v
	return s
}

type AddGlobalAccelerationInstanceIpRequest struct {
	// The ID of the shared-bandwidth GA instance.
	GlobalAccelerationInstanceId *string `json:"GlobalAccelerationInstanceId,omitempty" xml:"GlobalAccelerationInstanceId,omitempty"`
	// The EIP ID. You can call the [DescribeEipAddresses](~~36018~~) operation to query EIP IDs.
	//
	// >  Make sure that the billing method of the EIP is pay-as-you-go, and the EIP and the shared-bandwidth GA instance belong to the same region.
	IpInstanceId *string `json:"IpInstanceId,omitempty" xml:"IpInstanceId,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region of the shared-bandwidth GA instance.
	//
	// You can call the **DescribeRegions** operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s AddGlobalAccelerationInstanceIpRequest) String() string {
	return tea.Prettify(s)
}

func (s AddGlobalAccelerationInstanceIpRequest) GoString() string {
	return s.String()
}

func (s *AddGlobalAccelerationInstanceIpRequest) SetGlobalAccelerationInstanceId(v string) *AddGlobalAccelerationInstanceIpRequest {
	s.GlobalAccelerationInstanceId = &v
	return s
}

func (s *AddGlobalAccelerationInstanceIpRequest) SetIpInstanceId(v string) *AddGlobalAccelerationInstanceIpRequest {
	s.IpInstanceId = &v
	return s
}

func (s *AddGlobalAccelerationInstanceIpRequest) SetOwnerAccount(v string) *AddGlobalAccelerationInstanceIpRequest {
	s.OwnerAccount = &v
	return s
}

func (s *AddGlobalAccelerationInstanceIpRequest) SetOwnerId(v int64) *AddGlobalAccelerationInstanceIpRequest {
	s.OwnerId = &v
	return s
}

func (s *AddGlobalAccelerationInstanceIpRequest) SetRegionId(v string) *AddGlobalAccelerationInstanceIpRequest {
	s.RegionId = &v
	return s
}

func (s *AddGlobalAccelerationInstanceIpRequest) SetResourceOwnerAccount(v string) *AddGlobalAccelerationInstanceIpRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *AddGlobalAccelerationInstanceIpRequest) SetResourceOwnerId(v int64) *AddGlobalAccelerationInstanceIpRequest {
	s.ResourceOwnerId = &v
	return s
}

type AddGlobalAccelerationInstanceIpResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AddGlobalAccelerationInstanceIpResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddGlobalAccelerationInstanceIpResponseBody) GoString() string {
	return s.String()
}

func (s *AddGlobalAccelerationInstanceIpResponseBody) SetRequestId(v string) *AddGlobalAccelerationInstanceIpResponseBody {
	s.RequestId = &v
	return s
}

type AddGlobalAccelerationInstanceIpResponse struct {
	Headers    map[string]*string                           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddGlobalAccelerationInstanceIpResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddGlobalAccelerationInstanceIpResponse) String() string {
	return tea.Prettify(s)
}

func (s AddGlobalAccelerationInstanceIpResponse) GoString() string {
	return s.String()
}

func (s *AddGlobalAccelerationInstanceIpResponse) SetHeaders(v map[string]*string) *AddGlobalAccelerationInstanceIpResponse {
	s.Headers = v
	return s
}

func (s *AddGlobalAccelerationInstanceIpResponse) SetStatusCode(v int32) *AddGlobalAccelerationInstanceIpResponse {
	s.StatusCode = &v
	return s
}

func (s *AddGlobalAccelerationInstanceIpResponse) SetBody(v *AddGlobalAccelerationInstanceIpResponseBody) *AddGlobalAccelerationInstanceIpResponse {
	s.Body = v
	return s
}

type AddIPv6TranslatorAclListEntryRequest struct {
	// The remarks of the ACL entry.
	//
	// It must be 2 to 100 characters in length, and can contain letters, digits, underscores (\_), and hyphens (-). It must start with a letter.
	AclEntryComment *string `json:"AclEntryComment,omitempty" xml:"AclEntryComment,omitempty"`
	// The IPv6 address or IPv6 CIDR block that you want to add to the ACL entry, for example, 12XX:0:0:XXXX::0102 or 12XX:0:0:XXXX::/60.
	AclEntryIp *string `json:"AclEntryIp,omitempty" xml:"AclEntryIp,omitempty"`
	// The ID of the ACL to which you want to add the IP entry.
	AclId        *string `json:"AclId,omitempty" xml:"AclId,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the ACL.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s AddIPv6TranslatorAclListEntryRequest) String() string {
	return tea.Prettify(s)
}

func (s AddIPv6TranslatorAclListEntryRequest) GoString() string {
	return s.String()
}

func (s *AddIPv6TranslatorAclListEntryRequest) SetAclEntryComment(v string) *AddIPv6TranslatorAclListEntryRequest {
	s.AclEntryComment = &v
	return s
}

func (s *AddIPv6TranslatorAclListEntryRequest) SetAclEntryIp(v string) *AddIPv6TranslatorAclListEntryRequest {
	s.AclEntryIp = &v
	return s
}

func (s *AddIPv6TranslatorAclListEntryRequest) SetAclId(v string) *AddIPv6TranslatorAclListEntryRequest {
	s.AclId = &v
	return s
}

func (s *AddIPv6TranslatorAclListEntryRequest) SetOwnerAccount(v string) *AddIPv6TranslatorAclListEntryRequest {
	s.OwnerAccount = &v
	return s
}

func (s *AddIPv6TranslatorAclListEntryRequest) SetOwnerId(v int64) *AddIPv6TranslatorAclListEntryRequest {
	s.OwnerId = &v
	return s
}

func (s *AddIPv6TranslatorAclListEntryRequest) SetRegionId(v string) *AddIPv6TranslatorAclListEntryRequest {
	s.RegionId = &v
	return s
}

func (s *AddIPv6TranslatorAclListEntryRequest) SetResourceOwnerAccount(v string) *AddIPv6TranslatorAclListEntryRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *AddIPv6TranslatorAclListEntryRequest) SetResourceOwnerId(v int64) *AddIPv6TranslatorAclListEntryRequest {
	s.ResourceOwnerId = &v
	return s
}

type AddIPv6TranslatorAclListEntryResponseBody struct {
	// The ID of the ACL entry.
	AclEntryId *string `json:"AclEntryId,omitempty" xml:"AclEntryId,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AddIPv6TranslatorAclListEntryResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddIPv6TranslatorAclListEntryResponseBody) GoString() string {
	return s.String()
}

func (s *AddIPv6TranslatorAclListEntryResponseBody) SetAclEntryId(v string) *AddIPv6TranslatorAclListEntryResponseBody {
	s.AclEntryId = &v
	return s
}

func (s *AddIPv6TranslatorAclListEntryResponseBody) SetRequestId(v string) *AddIPv6TranslatorAclListEntryResponseBody {
	s.RequestId = &v
	return s
}

type AddIPv6TranslatorAclListEntryResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddIPv6TranslatorAclListEntryResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddIPv6TranslatorAclListEntryResponse) String() string {
	return tea.Prettify(s)
}

func (s AddIPv6TranslatorAclListEntryResponse) GoString() string {
	return s.String()
}

func (s *AddIPv6TranslatorAclListEntryResponse) SetHeaders(v map[string]*string) *AddIPv6TranslatorAclListEntryResponse {
	s.Headers = v
	return s
}

func (s *AddIPv6TranslatorAclListEntryResponse) SetStatusCode(v int32) *AddIPv6TranslatorAclListEntryResponse {
	s.StatusCode = &v
	return s
}

func (s *AddIPv6TranslatorAclListEntryResponse) SetBody(v *AddIPv6TranslatorAclListEntryResponseBody) *AddIPv6TranslatorAclListEntryResponse {
	s.Body = v
	return s
}

type AddPublicIpAddressPoolCidrBlockRequest struct {
	// The CIDR block.
	//
	// >  You cannot set the **CidrBlock** and **CidrMask** parameters at the same time.
	CidrBlock *string `json:"CidrBlock,omitempty" xml:"CidrBlock,omitempty"`
	// The subnet mask of the CIDR block.
	//
	// After you enter the subnet mask, the system automatically allocates IP addresses.
	//
	// Valid values: **24** to **30**.
	//
	// >  You cannot set the **CidrBlock** and **CidrMask** parameters at the same time. Set one of them.
	CidrMask *int32 `json:"CidrMask,omitempty" xml:"CidrMask,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among all requests. The token can contain only ASCII characters.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to perform a dry run. Valid values:
	//
	// *   **true**: performs a dry run. The system checks the required parameters, request syntax, and limits. If the request fails the dry run, an error message is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
	// *   **false** (default): performs a dry run and sends the request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed.
	DryRun       *bool   `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the IP address pool.
	PublicIpAddressPoolId *string `json:"PublicIpAddressPoolId,omitempty" xml:"PublicIpAddressPoolId,omitempty"`
	// The region ID of the IP address pool to which you want to add the CIDR block.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s AddPublicIpAddressPoolCidrBlockRequest) String() string {
	return tea.Prettify(s)
}

func (s AddPublicIpAddressPoolCidrBlockRequest) GoString() string {
	return s.String()
}

func (s *AddPublicIpAddressPoolCidrBlockRequest) SetCidrBlock(v string) *AddPublicIpAddressPoolCidrBlockRequest {
	s.CidrBlock = &v
	return s
}

func (s *AddPublicIpAddressPoolCidrBlockRequest) SetCidrMask(v int32) *AddPublicIpAddressPoolCidrBlockRequest {
	s.CidrMask = &v
	return s
}

func (s *AddPublicIpAddressPoolCidrBlockRequest) SetClientToken(v string) *AddPublicIpAddressPoolCidrBlockRequest {
	s.ClientToken = &v
	return s
}

func (s *AddPublicIpAddressPoolCidrBlockRequest) SetDryRun(v bool) *AddPublicIpAddressPoolCidrBlockRequest {
	s.DryRun = &v
	return s
}

func (s *AddPublicIpAddressPoolCidrBlockRequest) SetOwnerAccount(v string) *AddPublicIpAddressPoolCidrBlockRequest {
	s.OwnerAccount = &v
	return s
}

func (s *AddPublicIpAddressPoolCidrBlockRequest) SetOwnerId(v int64) *AddPublicIpAddressPoolCidrBlockRequest {
	s.OwnerId = &v
	return s
}

func (s *AddPublicIpAddressPoolCidrBlockRequest) SetPublicIpAddressPoolId(v string) *AddPublicIpAddressPoolCidrBlockRequest {
	s.PublicIpAddressPoolId = &v
	return s
}

func (s *AddPublicIpAddressPoolCidrBlockRequest) SetRegionId(v string) *AddPublicIpAddressPoolCidrBlockRequest {
	s.RegionId = &v
	return s
}

func (s *AddPublicIpAddressPoolCidrBlockRequest) SetResourceOwnerAccount(v string) *AddPublicIpAddressPoolCidrBlockRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *AddPublicIpAddressPoolCidrBlockRequest) SetResourceOwnerId(v int64) *AddPublicIpAddressPoolCidrBlockRequest {
	s.ResourceOwnerId = &v
	return s
}

type AddPublicIpAddressPoolCidrBlockResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AddPublicIpAddressPoolCidrBlockResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddPublicIpAddressPoolCidrBlockResponseBody) GoString() string {
	return s.String()
}

func (s *AddPublicIpAddressPoolCidrBlockResponseBody) SetRequestId(v string) *AddPublicIpAddressPoolCidrBlockResponseBody {
	s.RequestId = &v
	return s
}

type AddPublicIpAddressPoolCidrBlockResponse struct {
	Headers    map[string]*string                           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddPublicIpAddressPoolCidrBlockResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddPublicIpAddressPoolCidrBlockResponse) String() string {
	return tea.Prettify(s)
}

func (s AddPublicIpAddressPoolCidrBlockResponse) GoString() string {
	return s.String()
}

func (s *AddPublicIpAddressPoolCidrBlockResponse) SetHeaders(v map[string]*string) *AddPublicIpAddressPoolCidrBlockResponse {
	s.Headers = v
	return s
}

func (s *AddPublicIpAddressPoolCidrBlockResponse) SetStatusCode(v int32) *AddPublicIpAddressPoolCidrBlockResponse {
	s.StatusCode = &v
	return s
}

func (s *AddPublicIpAddressPoolCidrBlockResponse) SetBody(v *AddPublicIpAddressPoolCidrBlockResponseBody) *AddPublicIpAddressPoolCidrBlockResponse {
	s.Body = v
	return s
}

type AddSourcesToTrafficMirrorSessionRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, the system uses **RequestId** as **ClientToken**. **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to check the request without performing the operation. Valid values:
	//
	// *   **true**: checks the request without performing the operation. The system checks the required parameters, request format, and limits. If the request fails the check, an error message is returned. If the request passes the check, the `DryRunOperation` error code is returned.
	// *   **false** (default): sends the request. After the request passes the check, the operation is performed.
	DryRun       *bool   `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region to which the traffic mirror session belongs.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	//
	// For more information about regions that support traffic mirroring, see [Overview of traffic mirroring](~~207513~~).
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the traffic mirror session.
	TrafficMirrorSessionId *string   `json:"TrafficMirrorSessionId,omitempty" xml:"TrafficMirrorSessionId,omitempty"`
	TrafficMirrorSourceIds []*string `json:"TrafficMirrorSourceIds,omitempty" xml:"TrafficMirrorSourceIds,omitempty" type:"Repeated"`
}

func (s AddSourcesToTrafficMirrorSessionRequest) String() string {
	return tea.Prettify(s)
}

func (s AddSourcesToTrafficMirrorSessionRequest) GoString() string {
	return s.String()
}

func (s *AddSourcesToTrafficMirrorSessionRequest) SetClientToken(v string) *AddSourcesToTrafficMirrorSessionRequest {
	s.ClientToken = &v
	return s
}

func (s *AddSourcesToTrafficMirrorSessionRequest) SetDryRun(v bool) *AddSourcesToTrafficMirrorSessionRequest {
	s.DryRun = &v
	return s
}

func (s *AddSourcesToTrafficMirrorSessionRequest) SetOwnerAccount(v string) *AddSourcesToTrafficMirrorSessionRequest {
	s.OwnerAccount = &v
	return s
}

func (s *AddSourcesToTrafficMirrorSessionRequest) SetOwnerId(v int64) *AddSourcesToTrafficMirrorSessionRequest {
	s.OwnerId = &v
	return s
}

func (s *AddSourcesToTrafficMirrorSessionRequest) SetRegionId(v string) *AddSourcesToTrafficMirrorSessionRequest {
	s.RegionId = &v
	return s
}

func (s *AddSourcesToTrafficMirrorSessionRequest) SetResourceOwnerAccount(v string) *AddSourcesToTrafficMirrorSessionRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *AddSourcesToTrafficMirrorSessionRequest) SetResourceOwnerId(v int64) *AddSourcesToTrafficMirrorSessionRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *AddSourcesToTrafficMirrorSessionRequest) SetTrafficMirrorSessionId(v string) *AddSourcesToTrafficMirrorSessionRequest {
	s.TrafficMirrorSessionId = &v
	return s
}

func (s *AddSourcesToTrafficMirrorSessionRequest) SetTrafficMirrorSourceIds(v []*string) *AddSourcesToTrafficMirrorSessionRequest {
	s.TrafficMirrorSourceIds = v
	return s
}

type AddSourcesToTrafficMirrorSessionResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AddSourcesToTrafficMirrorSessionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddSourcesToTrafficMirrorSessionResponseBody) GoString() string {
	return s.String()
}

func (s *AddSourcesToTrafficMirrorSessionResponseBody) SetRequestId(v string) *AddSourcesToTrafficMirrorSessionResponseBody {
	s.RequestId = &v
	return s
}

type AddSourcesToTrafficMirrorSessionResponse struct {
	Headers    map[string]*string                            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddSourcesToTrafficMirrorSessionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddSourcesToTrafficMirrorSessionResponse) String() string {
	return tea.Prettify(s)
}

func (s AddSourcesToTrafficMirrorSessionResponse) GoString() string {
	return s.String()
}

func (s *AddSourcesToTrafficMirrorSessionResponse) SetHeaders(v map[string]*string) *AddSourcesToTrafficMirrorSessionResponse {
	s.Headers = v
	return s
}

func (s *AddSourcesToTrafficMirrorSessionResponse) SetStatusCode(v int32) *AddSourcesToTrafficMirrorSessionResponse {
	s.StatusCode = &v
	return s
}

func (s *AddSourcesToTrafficMirrorSessionResponse) SetBody(v *AddSourcesToTrafficMirrorSessionResponseBody) *AddSourcesToTrafficMirrorSessionResponse {
	s.Body = v
	return s
}

type AllocateEipAddressRequest struct {
	// The promotion code. Ignore this parameter.
	ActivityId *int64 `json:"ActivityId,omitempty" xml:"ActivityId,omitempty"`
	// Specifies whether to enable automatic payment. Default value: false. Valid values:
	//
	// *   **false**: disables automatic payment. This is the default value. If you select this option, you must go to the Order Center to complete the payment after an order is generated.
	// *   **true**: enables automatic payment. Payments are automatically completed.
	//
	// When **InstanceChargeType** is set to **PrePaid**, this parameter is required. When **InstanceChargeType** is set to **PostPaid**, this parameter is not required.
	AutoPay *bool `json:"AutoPay,omitempty" xml:"AutoPay,omitempty"`
	// The maximum bandwidth of the EIP. Unit: Mbit/s.
	//
	// *   When **InstanceChargeType** is set to **PostPaid** and **InternetChargeType** is set to **PayByBandwidth**, valid values for **Bandwidth** are **1** to **500**.
	// *   When **InstanceChargeType** is set to **PostPaid** and **InternetChargeType** is set to **PayByTraffic**, valid values for **Bandwidth** are **1** to **200**.
	// *   When **InstanceChargeType** is set to **PrePaid**, valid values for **Bandwidth** are **1** to **1000**.
	//
	// Default value: **5**. Unit: Mbit/s.
	Bandwidth *string `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among different requests. The **token** can contain only ASCII characters.
	//
	// >  If you do not set this parameter, the system automatically uses the value of **RequestId** as the value of **ClientToken**. The value of **RequestId** for each API request is different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The description of the EIP.
	//
	// The description must be 2 to 256 characters in length. It must start with a letter but cannot start with `http://` or `https://`.
	//
	// >  This parameter is unavailable when you create a subscription EIP.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The line type. Valid values:
	//
	// *   **BGP** (default): BGP (Multi-ISP) lines All regions support BGP (Multi-ISP) EIPs.
	// *   **BGP_PRO**: BGP (Multi-ISP) Pro lines Only the following regions support BGP (Multi-ISP) Pro lines: China (Hong Kong), Singapore, Malaysia (Kuala Lumpur), Philippines (Manila), Indonesia (Jakarta), and Thailand (Bangkok).
	//
	// For more information about BGP (Multi-ISP) and BGP (Multi-ISP) Pro, see [EIP line types](~~32321~~).
	//
	// *   If you are allowed to use single-ISP bandwidth, you can also choose one of the following values:
	//
	//     *   **ChinaTelecom**: China Telecom
	//     *   **ChinaUnicom**: China Unicom
	//     *   **ChinaMobile**: China Mobile
	//     *   **ChinaTelecom_L2**: China Telecom L2
	//     *   **ChinaUnicom_L2**: China Unicom L2
	//     *   **ChinaMobile_L2**: China Mobile L2
	//
	// *   If your services are deployed in China East 1 Finance, this parameter is required and you must set the value to **BGP_FinanceCloud**.
	ISP *string `json:"ISP,omitempty" xml:"ISP,omitempty"`
	// The billing method of the EIP. Valid values:
	//
	// *   **PrePaid**: subscription
	// *   **PostPaid** (default): pay-as-you-go
	//
	// When **InstanceChargeType** is set to **PrePaid**, set **InternetChargeType** to **PayByBandwidth**. When **InstanceChargeType** is set to **PostPaid**, set **InternetChargeType** to **PayByBandwidth** or **PayByTraffic**.
	InstanceChargeType *string `json:"InstanceChargeType,omitempty" xml:"InstanceChargeType,omitempty"`
	InstanceId         *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The metering method of the EIP. Valid values:
	//
	// *   **PayByBandwidth** (default): pay-by-bandwidth
	// *   **PayByTraffic**: pay-by-data-transfer
	//
	// When **InstanceChargeType** is set to **PrePaid**, you must set **InternetChargeType** to **PayByBandwidth**.
	//
	// When **InstanceChargeType** is set to **PostPaid**, set **InternetChargeType** to **PayByBandwidth** or **PayByTraffic**.
	InternetChargeType *string `json:"InternetChargeType,omitempty" xml:"InternetChargeType,omitempty"`
	IpAddress          *string `json:"IpAddress,omitempty" xml:"IpAddress,omitempty"`
	// The name of the EIP.
	//
	// The name must be 1 to 128 characters in length, and can contain letters, digits, periods (.), underscores (\_), and hyphens (-). It must start with a letter.
	//
	// >  This parameter is unavailable when you create a subscription EIP.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The network type. Set the value to **public**, which specifies the Internet.
	Netmode      *string `json:"Netmode,omitempty" xml:"Netmode,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The subscription duration of the instance.
	//
	// When **PricingCycle** is set to **Month**, set **Period** to a value from **1** to **9**.
	//
	// When **PricingCycle** is set to **Year**, set **Period** to a value from **1** to **5**.
	//
	// This parameter is required when **InstanceChargeType** is set to **PrePaid**. This parameter is optional when **InstanceChargeType** is set to **PostPaid**.
	Period *int32 `json:"Period,omitempty" xml:"Period,omitempty"`
	// The billing cycle of the subscription EIP. Valid values:
	//
	// *   **Month** (default): The EIP is billed on a monthly basis.
	// *   **Year**: The EIP is billed on an annual basis.
	//
	// When **InstanceChargeType** is set to **PrePaid**, this parameter is required. When **InstanceChargeType** is set to **PostPaid**, this parameter is not required.
	PricingCycle *string `json:"PricingCycle,omitempty" xml:"PricingCycle,omitempty"`
	// The ID of the IP address pool.
	//
	// The EIP is allocated from the IP address pool.
	//
	// You cannot use the IP address pool feature by default. To use the IP address pool feature, apply for the privilege in the Quota Center console. For more information, see [Request a quota increase in the Quota Center console](~~108213~~).
	PublicIpAddressPoolId *string `json:"PublicIpAddressPoolId,omitempty" xml:"PublicIpAddressPoolId,omitempty"`
	// The ID of the region to which the EIP belongs.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId         *string   `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount    *string   `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId         *int64    `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	SecurityProtectionTypes []*string `json:"SecurityProtectionTypes,omitempty" xml:"SecurityProtectionTypes,omitempty" type:"Repeated"`
	Zone                    *string   `json:"Zone,omitempty" xml:"Zone,omitempty"`
}

func (s AllocateEipAddressRequest) String() string {
	return tea.Prettify(s)
}

func (s AllocateEipAddressRequest) GoString() string {
	return s.String()
}

func (s *AllocateEipAddressRequest) SetActivityId(v int64) *AllocateEipAddressRequest {
	s.ActivityId = &v
	return s
}

func (s *AllocateEipAddressRequest) SetAutoPay(v bool) *AllocateEipAddressRequest {
	s.AutoPay = &v
	return s
}

func (s *AllocateEipAddressRequest) SetBandwidth(v string) *AllocateEipAddressRequest {
	s.Bandwidth = &v
	return s
}

func (s *AllocateEipAddressRequest) SetClientToken(v string) *AllocateEipAddressRequest {
	s.ClientToken = &v
	return s
}

func (s *AllocateEipAddressRequest) SetDescription(v string) *AllocateEipAddressRequest {
	s.Description = &v
	return s
}

func (s *AllocateEipAddressRequest) SetISP(v string) *AllocateEipAddressRequest {
	s.ISP = &v
	return s
}

func (s *AllocateEipAddressRequest) SetInstanceChargeType(v string) *AllocateEipAddressRequest {
	s.InstanceChargeType = &v
	return s
}

func (s *AllocateEipAddressRequest) SetInstanceId(v string) *AllocateEipAddressRequest {
	s.InstanceId = &v
	return s
}

func (s *AllocateEipAddressRequest) SetInternetChargeType(v string) *AllocateEipAddressRequest {
	s.InternetChargeType = &v
	return s
}

func (s *AllocateEipAddressRequest) SetIpAddress(v string) *AllocateEipAddressRequest {
	s.IpAddress = &v
	return s
}

func (s *AllocateEipAddressRequest) SetName(v string) *AllocateEipAddressRequest {
	s.Name = &v
	return s
}

func (s *AllocateEipAddressRequest) SetNetmode(v string) *AllocateEipAddressRequest {
	s.Netmode = &v
	return s
}

func (s *AllocateEipAddressRequest) SetOwnerAccount(v string) *AllocateEipAddressRequest {
	s.OwnerAccount = &v
	return s
}

func (s *AllocateEipAddressRequest) SetOwnerId(v int64) *AllocateEipAddressRequest {
	s.OwnerId = &v
	return s
}

func (s *AllocateEipAddressRequest) SetPeriod(v int32) *AllocateEipAddressRequest {
	s.Period = &v
	return s
}

func (s *AllocateEipAddressRequest) SetPricingCycle(v string) *AllocateEipAddressRequest {
	s.PricingCycle = &v
	return s
}

func (s *AllocateEipAddressRequest) SetPublicIpAddressPoolId(v string) *AllocateEipAddressRequest {
	s.PublicIpAddressPoolId = &v
	return s
}

func (s *AllocateEipAddressRequest) SetRegionId(v string) *AllocateEipAddressRequest {
	s.RegionId = &v
	return s
}

func (s *AllocateEipAddressRequest) SetResourceGroupId(v string) *AllocateEipAddressRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *AllocateEipAddressRequest) SetResourceOwnerAccount(v string) *AllocateEipAddressRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *AllocateEipAddressRequest) SetResourceOwnerId(v int64) *AllocateEipAddressRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *AllocateEipAddressRequest) SetSecurityProtectionTypes(v []*string) *AllocateEipAddressRequest {
	s.SecurityProtectionTypes = v
	return s
}

func (s *AllocateEipAddressRequest) SetZone(v string) *AllocateEipAddressRequest {
	s.Zone = &v
	return s
}

type AllocateEipAddressResponseBody struct {
	// The ID of the EIP.
	AllocationId *string `json:"AllocationId,omitempty" xml:"AllocationId,omitempty"`
	// The EIP that is allocated. This parameter is returned only when **InstanceChargeType** is set to **PostPaid**.
	EipAddress *string `json:"EipAddress,omitempty" xml:"EipAddress,omitempty"`
	// The ID of the order. This parameter is returned only when **InstanceChargeType** is set to **PrePaid**.
	OrderId *int64 `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the resource group. This parameter is returned only when **InstanceChargeType** is set to **PostPaid**.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
}

func (s AllocateEipAddressResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AllocateEipAddressResponseBody) GoString() string {
	return s.String()
}

func (s *AllocateEipAddressResponseBody) SetAllocationId(v string) *AllocateEipAddressResponseBody {
	s.AllocationId = &v
	return s
}

func (s *AllocateEipAddressResponseBody) SetEipAddress(v string) *AllocateEipAddressResponseBody {
	s.EipAddress = &v
	return s
}

func (s *AllocateEipAddressResponseBody) SetOrderId(v int64) *AllocateEipAddressResponseBody {
	s.OrderId = &v
	return s
}

func (s *AllocateEipAddressResponseBody) SetRequestId(v string) *AllocateEipAddressResponseBody {
	s.RequestId = &v
	return s
}

func (s *AllocateEipAddressResponseBody) SetResourceGroupId(v string) *AllocateEipAddressResponseBody {
	s.ResourceGroupId = &v
	return s
}

type AllocateEipAddressResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AllocateEipAddressResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AllocateEipAddressResponse) String() string {
	return tea.Prettify(s)
}

func (s AllocateEipAddressResponse) GoString() string {
	return s.String()
}

func (s *AllocateEipAddressResponse) SetHeaders(v map[string]*string) *AllocateEipAddressResponse {
	s.Headers = v
	return s
}

func (s *AllocateEipAddressResponse) SetStatusCode(v int32) *AllocateEipAddressResponse {
	s.StatusCode = &v
	return s
}

func (s *AllocateEipAddressResponse) SetBody(v *AllocateEipAddressResponseBody) *AllocateEipAddressResponse {
	s.Body = v
	return s
}

type AllocateEipAddressProRequest struct {
	// Specifies whether to enable automatic payment. Valid values:
	//
	// *   **false**: disables automatic payment. After an order is generated, you must go to the Order Center to complete the payment.
	// *   **true**: enabled. Payments are automatically completed.
	//
	// When **InstanceChargeType** is set to **PrePaid**, this parameter is required. When **InstanceChargeType** is set to **PostPaid**, this parameter is not required.
	AutoPay *bool `json:"AutoPay,omitempty" xml:"AutoPay,omitempty"`
	// The maximum bandwidth of the specified EIP. Unit: Mbit/s.
	//
	// *   When **InstanceChargeType** is set to **PostPaid** and **InternetChargeType** is set to **PayByBandwidth**, valid values for **Bandwidth** are **1** to **500**.
	// *   When **InstanceChargeType** is set to **PostPaid** and **InternetChargeType** is set to **PayByTraffic**, valid values for **Bandwidth** are **1** to **200**.
	// *   When **InstanceChargeType** is set to **PrePaid**, valid values for **Bandwidth** are **1** to **1000**.
	//
	// Default value: **5**. Unit: Mbit/s.
	Bandwidth *string `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The line type. Valid values:
	//
	// *   **BGP** (default): BGP (Multi-ISP) lines All regions support BGP (Multi-ISP) EIPs.
	// *   **BGP_PRO**: BGP (Multi-ISP) Pro lines Only the following regions support BGP (Multi-ISP) Pro lines: China (Hong Kong), Singapore, Malaysia (Kuala Lumpur), Philippines (Manila), Indonesia (Jakarta), and Thailand (Bangkok).
	//
	// For more information about BGP (Multi-ISP) and BGP (Multi-ISP) Pro, see [EIP line types](~~32321~~).
	//
	// *   If you are allowed to use single-ISP bandwidth, you can also choose one of the following values:
	//
	//     *   **ChinaTelecom**: China Telecom
	//     *   **ChinaUnicom**: China Unicom
	//     *   **ChinaMobile**: China Mobile
	//     *   **ChinaTelecom_L2**: China Telecom L2
	//     *   **ChinaUnicom_L2**: China Unicom L2
	//     *   **ChinaMobile_L2**: China Mobile L2
	//
	// *   If your services are deployed in China East 1 Finance, this parameter is required and you must set the value to **BGP_FinanceCloud**.
	ISP *string `json:"ISP,omitempty" xml:"ISP,omitempty"`
	// The billing method of the specified EIP. Valid values:
	//
	// *   **PrePaid**: subscription
	// *   **PostPaid** (default): pay-as-you-go
	//
	// When **InstanceChargeType** is set to **PrePaid**, you must set **InternetChargeType** to **PayByBandwidth**.
	//
	// When **InstanceChargeType** is set to **PostPaid**, you must set **InternetChargeType** to **PayByBandwidth** or **PayByTraffic**.
	InstanceChargeType *string `json:"InstanceChargeType,omitempty" xml:"InstanceChargeType,omitempty"`
	// The ID of the EIP.
	//
	// Set **IpAddress** or **InstanceId**. If you leave both parameters empty, the system randomly allocates an EIP.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The metering method of the specified EIP. Valid values:
	//
	// *   **PayByBandwidth** (default): pay-by-bandwidth
	// *   **PayByTraffic**: pay-by-data-transfer
	//
	// When **InstanceChargeType** is set to **PrePaid**, you must set **InternetChargeType** to **PayByBandwidth**.
	//
	// When **InstanceChargeType** is set to **PostPaid**, you must set **InternetChargeType** to **PayByBandwidth** or **PayByTraffic**.
	InternetChargeType *string `json:"InternetChargeType,omitempty" xml:"InternetChargeType,omitempty"`
	// The IP address of the EIP that you want to request.
	//
	// Set **IpAddress** or **InstanceId**. If you leave both parameters empty, the system randomly allocates an EIP.
	IpAddress *string `json:"IpAddress,omitempty" xml:"IpAddress,omitempty"`
	// The network type. Set the value to **public**, which specifies the Internet.
	Netmode      *string `json:"Netmode,omitempty" xml:"Netmode,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The subscription duration of the bandwidth plan.
	//
	// *   If **PricingCycle** is set to **Month**, set **Period** to a value from **1 to 9**.
	// *   If **PricingCycle** is set to **Year**, set **Period** to a value from **1 to 3**.
	//
	// When **InstanceChargeType** is set to **PrePaid**, this parameter is required.
	//
	// Ignore this parameter when **InstanceChargeType** is set to **PostPaid**.
	Period *int32 `json:"Period,omitempty" xml:"Period,omitempty"`
	// The billing cycle of the subscription EIP. Valid values:
	//
	// *   **Month** (default): The EIP is billed on a monthly basis.
	// *   **Year**: The EIP is billed on an annual basis.
	//
	// When **InstanceChargeType** is set to **PrePaid**, this parameter is required. When **InstanceChargeType** is set to **PostPaid**, this parameter is not required.
	PricingCycle *string `json:"PricingCycle,omitempty" xml:"PricingCycle,omitempty"`
	// The ID of the IP address pool.
	//
	// The EIP is allocated from the IP address pool.
	//
	// You cannot use the IP address pool feature by default. To use this feature, apply for the privilege in the Quota Center console. For more information, see [Request a quota increase in the Quota Center console](~~108213~~).
	PublicIpAddressPoolId *string `json:"PublicIpAddressPoolId,omitempty" xml:"PublicIpAddressPoolId,omitempty"`
	// The ID of the region where you want to request a specified EIP.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group to which the EIP belongs.
	ResourceGroupId         *string   `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount    *string   `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId         *int64    `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	SecurityProtectionTypes []*string `json:"SecurityProtectionTypes,omitempty" xml:"SecurityProtectionTypes,omitempty" type:"Repeated"`
}

func (s AllocateEipAddressProRequest) String() string {
	return tea.Prettify(s)
}

func (s AllocateEipAddressProRequest) GoString() string {
	return s.String()
}

func (s *AllocateEipAddressProRequest) SetAutoPay(v bool) *AllocateEipAddressProRequest {
	s.AutoPay = &v
	return s
}

func (s *AllocateEipAddressProRequest) SetBandwidth(v string) *AllocateEipAddressProRequest {
	s.Bandwidth = &v
	return s
}

func (s *AllocateEipAddressProRequest) SetClientToken(v string) *AllocateEipAddressProRequest {
	s.ClientToken = &v
	return s
}

func (s *AllocateEipAddressProRequest) SetISP(v string) *AllocateEipAddressProRequest {
	s.ISP = &v
	return s
}

func (s *AllocateEipAddressProRequest) SetInstanceChargeType(v string) *AllocateEipAddressProRequest {
	s.InstanceChargeType = &v
	return s
}

func (s *AllocateEipAddressProRequest) SetInstanceId(v string) *AllocateEipAddressProRequest {
	s.InstanceId = &v
	return s
}

func (s *AllocateEipAddressProRequest) SetInternetChargeType(v string) *AllocateEipAddressProRequest {
	s.InternetChargeType = &v
	return s
}

func (s *AllocateEipAddressProRequest) SetIpAddress(v string) *AllocateEipAddressProRequest {
	s.IpAddress = &v
	return s
}

func (s *AllocateEipAddressProRequest) SetNetmode(v string) *AllocateEipAddressProRequest {
	s.Netmode = &v
	return s
}

func (s *AllocateEipAddressProRequest) SetOwnerAccount(v string) *AllocateEipAddressProRequest {
	s.OwnerAccount = &v
	return s
}

func (s *AllocateEipAddressProRequest) SetOwnerId(v int64) *AllocateEipAddressProRequest {
	s.OwnerId = &v
	return s
}

func (s *AllocateEipAddressProRequest) SetPeriod(v int32) *AllocateEipAddressProRequest {
	s.Period = &v
	return s
}

func (s *AllocateEipAddressProRequest) SetPricingCycle(v string) *AllocateEipAddressProRequest {
	s.PricingCycle = &v
	return s
}

func (s *AllocateEipAddressProRequest) SetPublicIpAddressPoolId(v string) *AllocateEipAddressProRequest {
	s.PublicIpAddressPoolId = &v
	return s
}

func (s *AllocateEipAddressProRequest) SetRegionId(v string) *AllocateEipAddressProRequest {
	s.RegionId = &v
	return s
}

func (s *AllocateEipAddressProRequest) SetResourceGroupId(v string) *AllocateEipAddressProRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *AllocateEipAddressProRequest) SetResourceOwnerAccount(v string) *AllocateEipAddressProRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *AllocateEipAddressProRequest) SetResourceOwnerId(v int64) *AllocateEipAddressProRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *AllocateEipAddressProRequest) SetSecurityProtectionTypes(v []*string) *AllocateEipAddressProRequest {
	s.SecurityProtectionTypes = v
	return s
}

type AllocateEipAddressProResponseBody struct {
	// The ID of the specified EIP.
	AllocationId *string `json:"AllocationId,omitempty" xml:"AllocationId,omitempty"`
	// The IP address of the requested EIP.
	EipAddress *string `json:"EipAddress,omitempty" xml:"EipAddress,omitempty"`
	// The order number. This parameter is returned only when **InstanceChargeType** is set to **PrePaid**.
	OrderId *int64 `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
}

func (s AllocateEipAddressProResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AllocateEipAddressProResponseBody) GoString() string {
	return s.String()
}

func (s *AllocateEipAddressProResponseBody) SetAllocationId(v string) *AllocateEipAddressProResponseBody {
	s.AllocationId = &v
	return s
}

func (s *AllocateEipAddressProResponseBody) SetEipAddress(v string) *AllocateEipAddressProResponseBody {
	s.EipAddress = &v
	return s
}

func (s *AllocateEipAddressProResponseBody) SetOrderId(v int64) *AllocateEipAddressProResponseBody {
	s.OrderId = &v
	return s
}

func (s *AllocateEipAddressProResponseBody) SetRequestId(v string) *AllocateEipAddressProResponseBody {
	s.RequestId = &v
	return s
}

func (s *AllocateEipAddressProResponseBody) SetResourceGroupId(v string) *AllocateEipAddressProResponseBody {
	s.ResourceGroupId = &v
	return s
}

type AllocateEipAddressProResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AllocateEipAddressProResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AllocateEipAddressProResponse) String() string {
	return tea.Prettify(s)
}

func (s AllocateEipAddressProResponse) GoString() string {
	return s.String()
}

func (s *AllocateEipAddressProResponse) SetHeaders(v map[string]*string) *AllocateEipAddressProResponse {
	s.Headers = v
	return s
}

func (s *AllocateEipAddressProResponse) SetStatusCode(v int32) *AllocateEipAddressProResponse {
	s.StatusCode = &v
	return s
}

func (s *AllocateEipAddressProResponse) SetBody(v *AllocateEipAddressProResponseBody) *AllocateEipAddressProResponse {
	s.Body = v
	return s
}

type AllocateEipSegmentAddressRequest struct {
	// The maximum bandwidth of the EIP. Unit: Mbit/s.
	//
	// *   When **InstanceChargeType** is set to **PostPaid** and **InternetChargeType** is set to **PayByBandwidth**, the valid values for **Bandwidth** are **1** to **500**.
	// *   When **InstanceChargeType** is set to **PostPaid** and **InternetChargeType** is set to **PayByTraffic**, the valid values for **Bandwidth** are **1** to **200**.
	// *   When **InstanceChargeType** is set to **PrePaid**, the valid values for **Bandwidth** are **1** to **1000**.
	//
	// Default value: **5**. Unit: Mbit/s.
	Bandwidth *string `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among all requests. The **client token** can contain only ASCII characters.
	//
	// >  If you do not specify this parameter, the system uses **RequestId** as **ClientToken**. The value of **RequestId** for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The subnet mask length of the contiguous EIPs. Valid values:
	//
	// - **28**: applies for 16 contiguous EIPs in each call.
	// - **27**: applies for 32 contiguous EIPs in each call.
	// - **26**: applies for 64 contiguous EIPs each call.
	// - **25**: applies for 128 contiguous EIPs in each call.
	// - **24**: applies for 256 contiguous EIPs in each call.
	//
	// >  The number of contiguous EIPs allocated by the system may be less than the requested number because one, three, or four EIPs may be reserved.
	EipMask *string `json:"EipMask,omitempty" xml:"EipMask,omitempty"`
	// The metering method of the contiguous EIPs. Valid values:
	//
	// *   **PayByBandwidth** (default): pay-by-bandwidth
	// *   **PayByTraffic**: pay-by-data-transfer
	InternetChargeType *string `json:"InternetChargeType,omitempty" xml:"InternetChargeType,omitempty"`
	// The line type. Valid values:
	//
	// *   **BGP** (default): BGP (Multi-ISP) lines All regions support BGP (Multi-ISP) EIPs.
	// *   **BGP_PRO**: BGP (Multi-ISP) Pro lines. Only the following regions support BGP (Multi-ISP) Pro lines: China (Hong Kong), Singapore, Malaysia (Kuala Lumpur), Philippines (Manila), Indonesia (Jakarta), and Thailand (Bangkok).
	//
	// For more information about BGP (Multi-ISP) and BGP (Multi-ISP) Pro, see [EIP line types](~~32321~~).
	//
	// If you are allowed to use single-ISP bandwidth, you can also choose one of the following values:
	//
	// *   **ChinaTelecom**: China Telecom
	// *   **ChinaUnicom**: China Unicom
	// *   **ChinaMobile**: China Mobile
	// *   **ChinaTelecom_L2**: China Telecom L2
	// *   **ChinaUnicom_L2**: China Unicom L2
	// *   **ChinaMobile_L2**: China Mobile L2
	//
	// If your services are deployed in China East 1 Finance, this parameter is required and you must set the value to **BGP_FinanceCloud**.
	Isp *string `json:"Isp,omitempty" xml:"Isp,omitempty"`
	// Set the value to **public**, which specifies the Internet.
	Netmode      *string `json:"Netmode,omitempty" xml:"Netmode,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the contiguous EIPs.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	Zone                 *string `json:"Zone,omitempty" xml:"Zone,omitempty"`
}

func (s AllocateEipSegmentAddressRequest) String() string {
	return tea.Prettify(s)
}

func (s AllocateEipSegmentAddressRequest) GoString() string {
	return s.String()
}

func (s *AllocateEipSegmentAddressRequest) SetBandwidth(v string) *AllocateEipSegmentAddressRequest {
	s.Bandwidth = &v
	return s
}

func (s *AllocateEipSegmentAddressRequest) SetClientToken(v string) *AllocateEipSegmentAddressRequest {
	s.ClientToken = &v
	return s
}

func (s *AllocateEipSegmentAddressRequest) SetEipMask(v string) *AllocateEipSegmentAddressRequest {
	s.EipMask = &v
	return s
}

func (s *AllocateEipSegmentAddressRequest) SetInternetChargeType(v string) *AllocateEipSegmentAddressRequest {
	s.InternetChargeType = &v
	return s
}

func (s *AllocateEipSegmentAddressRequest) SetIsp(v string) *AllocateEipSegmentAddressRequest {
	s.Isp = &v
	return s
}

func (s *AllocateEipSegmentAddressRequest) SetNetmode(v string) *AllocateEipSegmentAddressRequest {
	s.Netmode = &v
	return s
}

func (s *AllocateEipSegmentAddressRequest) SetOwnerAccount(v string) *AllocateEipSegmentAddressRequest {
	s.OwnerAccount = &v
	return s
}

func (s *AllocateEipSegmentAddressRequest) SetOwnerId(v int64) *AllocateEipSegmentAddressRequest {
	s.OwnerId = &v
	return s
}

func (s *AllocateEipSegmentAddressRequest) SetRegionId(v string) *AllocateEipSegmentAddressRequest {
	s.RegionId = &v
	return s
}

func (s *AllocateEipSegmentAddressRequest) SetResourceGroupId(v string) *AllocateEipSegmentAddressRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *AllocateEipSegmentAddressRequest) SetResourceOwnerAccount(v string) *AllocateEipSegmentAddressRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *AllocateEipSegmentAddressRequest) SetResourceOwnerId(v int64) *AllocateEipSegmentAddressRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *AllocateEipSegmentAddressRequest) SetZone(v string) *AllocateEipSegmentAddressRequest {
	s.Zone = &v
	return s
}

type AllocateEipSegmentAddressResponseBody struct {
	// The ID of the contiguous EIP group.
	EipSegmentInstanceId *string `json:"EipSegmentInstanceId,omitempty" xml:"EipSegmentInstanceId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AllocateEipSegmentAddressResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AllocateEipSegmentAddressResponseBody) GoString() string {
	return s.String()
}

func (s *AllocateEipSegmentAddressResponseBody) SetEipSegmentInstanceId(v string) *AllocateEipSegmentAddressResponseBody {
	s.EipSegmentInstanceId = &v
	return s
}

func (s *AllocateEipSegmentAddressResponseBody) SetRequestId(v string) *AllocateEipSegmentAddressResponseBody {
	s.RequestId = &v
	return s
}

type AllocateEipSegmentAddressResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AllocateEipSegmentAddressResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AllocateEipSegmentAddressResponse) String() string {
	return tea.Prettify(s)
}

func (s AllocateEipSegmentAddressResponse) GoString() string {
	return s.String()
}

func (s *AllocateEipSegmentAddressResponse) SetHeaders(v map[string]*string) *AllocateEipSegmentAddressResponse {
	s.Headers = v
	return s
}

func (s *AllocateEipSegmentAddressResponse) SetStatusCode(v int32) *AllocateEipSegmentAddressResponse {
	s.StatusCode = &v
	return s
}

func (s *AllocateEipSegmentAddressResponse) SetBody(v *AllocateEipSegmentAddressResponseBody) *AllocateEipSegmentAddressResponse {
	s.Body = v
	return s
}

type AllocateIpv6InternetBandwidthRequest struct {
	// The Internet bandwidth that you want to purchase for the IPv6 gateway. Valid values: **1 to 5000**. Unit: Mbit/s.
	Bandwidth *int32 `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must ensure that the value is unique among all requests. ClientToken can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The metering method of the Internet bandwidth of the IPv6 gateway. Valid values:
	//
	// *   **PayByTraffic**: the pay-by-data-transfer metering method
	// *   **PayByBandwidth**: the pay-by-bandwidth metering method
	InternetChargeType *string `json:"InternetChargeType,omitempty" xml:"InternetChargeType,omitempty"`
	// The ID of the IPv6 address.
	Ipv6AddressId *string `json:"Ipv6AddressId,omitempty" xml:"Ipv6AddressId,omitempty"`
	// The ID of the IPv6 gateway.
	Ipv6GatewayId *string `json:"Ipv6GatewayId,omitempty" xml:"Ipv6GatewayId,omitempty"`
	OwnerAccount  *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region where the IPv6 gateway is deployed. You can call the [DescribeRegions](~~36063~~) operation to obtain the region ID.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s AllocateIpv6InternetBandwidthRequest) String() string {
	return tea.Prettify(s)
}

func (s AllocateIpv6InternetBandwidthRequest) GoString() string {
	return s.String()
}

func (s *AllocateIpv6InternetBandwidthRequest) SetBandwidth(v int32) *AllocateIpv6InternetBandwidthRequest {
	s.Bandwidth = &v
	return s
}

func (s *AllocateIpv6InternetBandwidthRequest) SetClientToken(v string) *AllocateIpv6InternetBandwidthRequest {
	s.ClientToken = &v
	return s
}

func (s *AllocateIpv6InternetBandwidthRequest) SetInternetChargeType(v string) *AllocateIpv6InternetBandwidthRequest {
	s.InternetChargeType = &v
	return s
}

func (s *AllocateIpv6InternetBandwidthRequest) SetIpv6AddressId(v string) *AllocateIpv6InternetBandwidthRequest {
	s.Ipv6AddressId = &v
	return s
}

func (s *AllocateIpv6InternetBandwidthRequest) SetIpv6GatewayId(v string) *AllocateIpv6InternetBandwidthRequest {
	s.Ipv6GatewayId = &v
	return s
}

func (s *AllocateIpv6InternetBandwidthRequest) SetOwnerAccount(v string) *AllocateIpv6InternetBandwidthRequest {
	s.OwnerAccount = &v
	return s
}

func (s *AllocateIpv6InternetBandwidthRequest) SetOwnerId(v int64) *AllocateIpv6InternetBandwidthRequest {
	s.OwnerId = &v
	return s
}

func (s *AllocateIpv6InternetBandwidthRequest) SetRegionId(v string) *AllocateIpv6InternetBandwidthRequest {
	s.RegionId = &v
	return s
}

func (s *AllocateIpv6InternetBandwidthRequest) SetResourceOwnerAccount(v string) *AllocateIpv6InternetBandwidthRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *AllocateIpv6InternetBandwidthRequest) SetResourceOwnerId(v int64) *AllocateIpv6InternetBandwidthRequest {
	s.ResourceOwnerId = &v
	return s
}

type AllocateIpv6InternetBandwidthResponseBody struct {
	// The ID of the Internet bandwidth that you purchased for the IPv6 gateway.
	InternetBandwidthId *string `json:"InternetBandwidthId,omitempty" xml:"InternetBandwidthId,omitempty"`
	// The ID of the IPv6 address.
	Ipv6AddressId *string `json:"Ipv6AddressId,omitempty" xml:"Ipv6AddressId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AllocateIpv6InternetBandwidthResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AllocateIpv6InternetBandwidthResponseBody) GoString() string {
	return s.String()
}

func (s *AllocateIpv6InternetBandwidthResponseBody) SetInternetBandwidthId(v string) *AllocateIpv6InternetBandwidthResponseBody {
	s.InternetBandwidthId = &v
	return s
}

func (s *AllocateIpv6InternetBandwidthResponseBody) SetIpv6AddressId(v string) *AllocateIpv6InternetBandwidthResponseBody {
	s.Ipv6AddressId = &v
	return s
}

func (s *AllocateIpv6InternetBandwidthResponseBody) SetRequestId(v string) *AllocateIpv6InternetBandwidthResponseBody {
	s.RequestId = &v
	return s
}

type AllocateIpv6InternetBandwidthResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AllocateIpv6InternetBandwidthResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AllocateIpv6InternetBandwidthResponse) String() string {
	return tea.Prettify(s)
}

func (s AllocateIpv6InternetBandwidthResponse) GoString() string {
	return s.String()
}

func (s *AllocateIpv6InternetBandwidthResponse) SetHeaders(v map[string]*string) *AllocateIpv6InternetBandwidthResponse {
	s.Headers = v
	return s
}

func (s *AllocateIpv6InternetBandwidthResponse) SetStatusCode(v int32) *AllocateIpv6InternetBandwidthResponse {
	s.StatusCode = &v
	return s
}

func (s *AllocateIpv6InternetBandwidthResponse) SetBody(v *AllocateIpv6InternetBandwidthResponseBody) *AllocateIpv6InternetBandwidthResponse {
	s.Body = v
	return s
}

type AllocateVpcIpv6CidrRequest struct {
	// The type of the IPv6 address pool. Set the value to **custom**.
	//
	// >  This parameter is required.
	AddressPoolType *string `json:"AddressPoolType,omitempty" xml:"AddressPoolType,omitempty"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that it is unique among different requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, the system automatically uses **RequestId** as **ClientToken**. **RequestId** of each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The IPv6 CIDR block that you want to reserve.
	Ipv6CidrBlock *string `json:"Ipv6CidrBlock,omitempty" xml:"Ipv6CidrBlock,omitempty"`
	// The type of the IPv6 CIDR block. Valid values:
	//
	// *   **BGP**: Alibaba Cloud Border Gateway Protocol (BGP) IPv6. This is the default value.
	// *   **ChinaMobile**: China Mobile (single ISP).
	// *   **ChinaUnicom**: China Unicom (single ISP).
	// *   **ChinaTelecom**: China Telecom (single ISP).
	//
	// >
	//
	// *   If your Alibaba Cloud account is allowed to use single-ISP bandwidth, valid values are: **ChinaTelecom**, **ChinaUnicom**, and **ChinaMobile**.
	// *   You can reserve only one IPv6 CIDR block of each type. After a reserved IPv6 CIDR block of a type is allocated to a VPC, you can reserve another IPv6 CIDR of the type.
	Ipv6Isp      *string `json:"Ipv6Isp,omitempty" xml:"Ipv6Isp,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region to which the VPC belongs.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s AllocateVpcIpv6CidrRequest) String() string {
	return tea.Prettify(s)
}

func (s AllocateVpcIpv6CidrRequest) GoString() string {
	return s.String()
}

func (s *AllocateVpcIpv6CidrRequest) SetAddressPoolType(v string) *AllocateVpcIpv6CidrRequest {
	s.AddressPoolType = &v
	return s
}

func (s *AllocateVpcIpv6CidrRequest) SetClientToken(v string) *AllocateVpcIpv6CidrRequest {
	s.ClientToken = &v
	return s
}

func (s *AllocateVpcIpv6CidrRequest) SetIpv6CidrBlock(v string) *AllocateVpcIpv6CidrRequest {
	s.Ipv6CidrBlock = &v
	return s
}

func (s *AllocateVpcIpv6CidrRequest) SetIpv6Isp(v string) *AllocateVpcIpv6CidrRequest {
	s.Ipv6Isp = &v
	return s
}

func (s *AllocateVpcIpv6CidrRequest) SetOwnerAccount(v string) *AllocateVpcIpv6CidrRequest {
	s.OwnerAccount = &v
	return s
}

func (s *AllocateVpcIpv6CidrRequest) SetOwnerId(v int64) *AllocateVpcIpv6CidrRequest {
	s.OwnerId = &v
	return s
}

func (s *AllocateVpcIpv6CidrRequest) SetRegionId(v string) *AllocateVpcIpv6CidrRequest {
	s.RegionId = &v
	return s
}

func (s *AllocateVpcIpv6CidrRequest) SetResourceOwnerAccount(v string) *AllocateVpcIpv6CidrRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *AllocateVpcIpv6CidrRequest) SetResourceOwnerId(v int64) *AllocateVpcIpv6CidrRequest {
	s.ResourceOwnerId = &v
	return s
}

type AllocateVpcIpv6CidrResponseBody struct {
	// The IPv6 CIDR block that is reserved.
	Ipv6CidrBlock *string `json:"Ipv6CidrBlock,omitempty" xml:"Ipv6CidrBlock,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AllocateVpcIpv6CidrResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AllocateVpcIpv6CidrResponseBody) GoString() string {
	return s.String()
}

func (s *AllocateVpcIpv6CidrResponseBody) SetIpv6CidrBlock(v string) *AllocateVpcIpv6CidrResponseBody {
	s.Ipv6CidrBlock = &v
	return s
}

func (s *AllocateVpcIpv6CidrResponseBody) SetRequestId(v string) *AllocateVpcIpv6CidrResponseBody {
	s.RequestId = &v
	return s
}

type AllocateVpcIpv6CidrResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AllocateVpcIpv6CidrResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AllocateVpcIpv6CidrResponse) String() string {
	return tea.Prettify(s)
}

func (s AllocateVpcIpv6CidrResponse) GoString() string {
	return s.String()
}

func (s *AllocateVpcIpv6CidrResponse) SetHeaders(v map[string]*string) *AllocateVpcIpv6CidrResponse {
	s.Headers = v
	return s
}

func (s *AllocateVpcIpv6CidrResponse) SetStatusCode(v int32) *AllocateVpcIpv6CidrResponse {
	s.StatusCode = &v
	return s
}

func (s *AllocateVpcIpv6CidrResponse) SetBody(v *AllocateVpcIpv6CidrResponseBody) *AllocateVpcIpv6CidrResponse {
	s.Body = v
	return s
}

type ApplyPhysicalConnectionLOARequest struct {
	// The bandwidth of the Express Connect circuit. Unit: Mbit/s.
	//
	// Valid values: **2** to **10240**.
	Bandwidth *int32 `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among all requests. ClientToken can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The name of the customer company that requires the Express Connect circuit.
	CompanyName *string `json:"CompanyName,omitempty" xml:"CompanyName,omitempty"`
	// The time when construction started. Specify the time in the ISO 8601 standard in the YYYY-MM-DDThh:mm:ssZ format. The time must be in UTC.
	ConstructionTime *string `json:"ConstructionTime,omitempty" xml:"ConstructionTime,omitempty"`
	// The ID of the Express Connect circuit.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The type of Express Connect circuit. Valid values:
	//
	// *   **MSTP**: MSTP line
	// *   **MPLSVPN**: MPLSVPN line
	// *   **FIBRE**: fiber line
	// *   **Other**: other types
	LineType     *string                                    `json:"LineType,omitempty" xml:"LineType,omitempty"`
	OwnerAccount *string                                    `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64                                     `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	PMInfo       []*ApplyPhysicalConnectionLOARequestPMInfo `json:"PMInfo,omitempty" xml:"PMInfo,omitempty" type:"Repeated"`
	// The geographical location where the Express Connect circuit is deployed.
	PeerLocation *string `json:"PeerLocation,omitempty" xml:"PeerLocation,omitempty"`
	// The region ID of the Express Connect circuit.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The construction company.
	Si *string `json:"Si,omitempty" xml:"Si,omitempty"`
}

func (s ApplyPhysicalConnectionLOARequest) String() string {
	return tea.Prettify(s)
}

func (s ApplyPhysicalConnectionLOARequest) GoString() string {
	return s.String()
}

func (s *ApplyPhysicalConnectionLOARequest) SetBandwidth(v int32) *ApplyPhysicalConnectionLOARequest {
	s.Bandwidth = &v
	return s
}

func (s *ApplyPhysicalConnectionLOARequest) SetClientToken(v string) *ApplyPhysicalConnectionLOARequest {
	s.ClientToken = &v
	return s
}

func (s *ApplyPhysicalConnectionLOARequest) SetCompanyName(v string) *ApplyPhysicalConnectionLOARequest {
	s.CompanyName = &v
	return s
}

func (s *ApplyPhysicalConnectionLOARequest) SetConstructionTime(v string) *ApplyPhysicalConnectionLOARequest {
	s.ConstructionTime = &v
	return s
}

func (s *ApplyPhysicalConnectionLOARequest) SetInstanceId(v string) *ApplyPhysicalConnectionLOARequest {
	s.InstanceId = &v
	return s
}

func (s *ApplyPhysicalConnectionLOARequest) SetLineType(v string) *ApplyPhysicalConnectionLOARequest {
	s.LineType = &v
	return s
}

func (s *ApplyPhysicalConnectionLOARequest) SetOwnerAccount(v string) *ApplyPhysicalConnectionLOARequest {
	s.OwnerAccount = &v
	return s
}

func (s *ApplyPhysicalConnectionLOARequest) SetOwnerId(v int64) *ApplyPhysicalConnectionLOARequest {
	s.OwnerId = &v
	return s
}

func (s *ApplyPhysicalConnectionLOARequest) SetPMInfo(v []*ApplyPhysicalConnectionLOARequestPMInfo) *ApplyPhysicalConnectionLOARequest {
	s.PMInfo = v
	return s
}

func (s *ApplyPhysicalConnectionLOARequest) SetPeerLocation(v string) *ApplyPhysicalConnectionLOARequest {
	s.PeerLocation = &v
	return s
}

func (s *ApplyPhysicalConnectionLOARequest) SetRegionId(v string) *ApplyPhysicalConnectionLOARequest {
	s.RegionId = &v
	return s
}

func (s *ApplyPhysicalConnectionLOARequest) SetResourceOwnerAccount(v string) *ApplyPhysicalConnectionLOARequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ApplyPhysicalConnectionLOARequest) SetResourceOwnerId(v int64) *ApplyPhysicalConnectionLOARequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ApplyPhysicalConnectionLOARequest) SetSi(v string) *ApplyPhysicalConnectionLOARequest {
	s.Si = &v
	return s
}

type ApplyPhysicalConnectionLOARequestPMInfo struct {
	// The ID number of the construction engineer. You can specify the ID number of an ID card or an international passport.
	//
	// You can configure information for up to 16 construction engineers.
	PMCertificateNo *string `json:"PMCertificateNo,omitempty" xml:"PMCertificateNo,omitempty"`
	// The type of the identity document of the construction engineer. Valid values:
	//
	// *   **IDCard**: identity card
	// *   **Passport**: international passport
	PMCertificateType *string `json:"PMCertificateType,omitempty" xml:"PMCertificateType,omitempty"`
	// The contact information about the construction engineer.
	PMContactInfo *string `json:"PMContactInfo,omitempty" xml:"PMContactInfo,omitempty"`
	// The gender of the construction engineer.
	PMGender *string `json:"PMGender,omitempty" xml:"PMGender,omitempty"`
	// The name of the construction engineer.
	PMName *string `json:"PMName,omitempty" xml:"PMName,omitempty"`
}

func (s ApplyPhysicalConnectionLOARequestPMInfo) String() string {
	return tea.Prettify(s)
}

func (s ApplyPhysicalConnectionLOARequestPMInfo) GoString() string {
	return s.String()
}

func (s *ApplyPhysicalConnectionLOARequestPMInfo) SetPMCertificateNo(v string) *ApplyPhysicalConnectionLOARequestPMInfo {
	s.PMCertificateNo = &v
	return s
}

func (s *ApplyPhysicalConnectionLOARequestPMInfo) SetPMCertificateType(v string) *ApplyPhysicalConnectionLOARequestPMInfo {
	s.PMCertificateType = &v
	return s
}

func (s *ApplyPhysicalConnectionLOARequestPMInfo) SetPMContactInfo(v string) *ApplyPhysicalConnectionLOARequestPMInfo {
	s.PMContactInfo = &v
	return s
}

func (s *ApplyPhysicalConnectionLOARequestPMInfo) SetPMGender(v string) *ApplyPhysicalConnectionLOARequestPMInfo {
	s.PMGender = &v
	return s
}

func (s *ApplyPhysicalConnectionLOARequestPMInfo) SetPMName(v string) *ApplyPhysicalConnectionLOARequestPMInfo {
	s.PMName = &v
	return s
}

type ApplyPhysicalConnectionLOAResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ApplyPhysicalConnectionLOAResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ApplyPhysicalConnectionLOAResponseBody) GoString() string {
	return s.String()
}

func (s *ApplyPhysicalConnectionLOAResponseBody) SetRequestId(v string) *ApplyPhysicalConnectionLOAResponseBody {
	s.RequestId = &v
	return s
}

type ApplyPhysicalConnectionLOAResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ApplyPhysicalConnectionLOAResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ApplyPhysicalConnectionLOAResponse) String() string {
	return tea.Prettify(s)
}

func (s ApplyPhysicalConnectionLOAResponse) GoString() string {
	return s.String()
}

func (s *ApplyPhysicalConnectionLOAResponse) SetHeaders(v map[string]*string) *ApplyPhysicalConnectionLOAResponse {
	s.Headers = v
	return s
}

func (s *ApplyPhysicalConnectionLOAResponse) SetStatusCode(v int32) *ApplyPhysicalConnectionLOAResponse {
	s.StatusCode = &v
	return s
}

func (s *ApplyPhysicalConnectionLOAResponse) SetBody(v *ApplyPhysicalConnectionLOAResponseBody) *ApplyPhysicalConnectionLOAResponse {
	s.Body = v
	return s
}

type AssociateEipAddressRequest struct {
	// The ID of the EIP that you want to associate with an instance.
	AllocationId *string `json:"AllocationId,omitempty" xml:"AllocationId,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. ClientToken can contain only ASCII characters.
	//
	// >  If you do not set this parameter, the system sets **ClientToken** to the value of **RequestId**. The value of **RequestId** for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the instance with which you want to associate the EIP.
	//
	// You can enter the ID of a NAT gateway, CLB instance, ECS instance, secondary ENI, HAVIP, or IP address.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The region ID of the instance with which you want to associate the EIP.
	//
	// >  This parameter is required only when the EIP is associated with a shared-bandwidth Global Accelerator (GA) instance.
	InstanceRegionId *string `json:"InstanceRegionId,omitempty" xml:"InstanceRegionId,omitempty"`
	// The type of instance with which you want to associate the EIP. Valid values:
	//
	// *   **Nat**: a NAT gateway
	// *   **SlbInstance**: a CLB instance
	// *   **EcsInstance** (default): an ECS instance in a VPC
	// *   **NetworkInterface**: a secondary ENI
	// *   **HaVip**: an HAVIP
	// *   **IpAddress**: an IP address
	//
	// >  If you do not set this parameter, the type of the instance with which you want to associate the EIP is **EcsInstance**. If the type of the instance with which you want to associate the EIP is not **EcsInstance**, this parameter is required.
	InstanceType *string `json:"InstanceType,omitempty" xml:"InstanceType,omitempty"`
	// The association mode. Valid values:
	//
	// *   **NAT** (default): NAT mode
	// *   **MULTI_BINDED**: multi-EIP-to-ENI mode
	// *   **BINDED**: cut-through mode
	//
	// >  This parameter is required only when **InstanceType** is set to **NetworkInterface**.
	Mode         *string `json:"Mode,omitempty" xml:"Mode,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// An IP address in the CIDR block of the vSwitch.
	//
	// If you do not set this parameter, the system allocates a private IP address based on the VPC ID and vSwitch ID.
	PrivateIpAddress *string `json:"PrivateIpAddress,omitempty" xml:"PrivateIpAddress,omitempty"`
	// The ID of the region to which the EIP belongs.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the VPC that has IPv4 gateways enabled and that is deployed in the same region as the EIP.
	//
	// When you associate an EIP with an IP address, the system can enable the IP address to access the Internet based on VPC route configurations.
	//
	// >  This parameter is required if **InstanceType** is set to **IpAddress**. In this case, the EIP is associated with an IP address.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s AssociateEipAddressRequest) String() string {
	return tea.Prettify(s)
}

func (s AssociateEipAddressRequest) GoString() string {
	return s.String()
}

func (s *AssociateEipAddressRequest) SetAllocationId(v string) *AssociateEipAddressRequest {
	s.AllocationId = &v
	return s
}

func (s *AssociateEipAddressRequest) SetClientToken(v string) *AssociateEipAddressRequest {
	s.ClientToken = &v
	return s
}

func (s *AssociateEipAddressRequest) SetInstanceId(v string) *AssociateEipAddressRequest {
	s.InstanceId = &v
	return s
}

func (s *AssociateEipAddressRequest) SetInstanceRegionId(v string) *AssociateEipAddressRequest {
	s.InstanceRegionId = &v
	return s
}

func (s *AssociateEipAddressRequest) SetInstanceType(v string) *AssociateEipAddressRequest {
	s.InstanceType = &v
	return s
}

func (s *AssociateEipAddressRequest) SetMode(v string) *AssociateEipAddressRequest {
	s.Mode = &v
	return s
}

func (s *AssociateEipAddressRequest) SetOwnerAccount(v string) *AssociateEipAddressRequest {
	s.OwnerAccount = &v
	return s
}

func (s *AssociateEipAddressRequest) SetOwnerId(v int64) *AssociateEipAddressRequest {
	s.OwnerId = &v
	return s
}

func (s *AssociateEipAddressRequest) SetPrivateIpAddress(v string) *AssociateEipAddressRequest {
	s.PrivateIpAddress = &v
	return s
}

func (s *AssociateEipAddressRequest) SetRegionId(v string) *AssociateEipAddressRequest {
	s.RegionId = &v
	return s
}

func (s *AssociateEipAddressRequest) SetResourceOwnerAccount(v string) *AssociateEipAddressRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *AssociateEipAddressRequest) SetResourceOwnerId(v int64) *AssociateEipAddressRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *AssociateEipAddressRequest) SetVpcId(v string) *AssociateEipAddressRequest {
	s.VpcId = &v
	return s
}

type AssociateEipAddressResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AssociateEipAddressResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AssociateEipAddressResponseBody) GoString() string {
	return s.String()
}

func (s *AssociateEipAddressResponseBody) SetRequestId(v string) *AssociateEipAddressResponseBody {
	s.RequestId = &v
	return s
}

type AssociateEipAddressResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AssociateEipAddressResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AssociateEipAddressResponse) String() string {
	return tea.Prettify(s)
}

func (s AssociateEipAddressResponse) GoString() string {
	return s.String()
}

func (s *AssociateEipAddressResponse) SetHeaders(v map[string]*string) *AssociateEipAddressResponse {
	s.Headers = v
	return s
}

func (s *AssociateEipAddressResponse) SetStatusCode(v int32) *AssociateEipAddressResponse {
	s.StatusCode = &v
	return s
}

func (s *AssociateEipAddressResponse) SetBody(v *AssociateEipAddressResponseBody) *AssociateEipAddressResponse {
	s.Body = v
	return s
}

type AssociateEipAddressBatchRequest struct {
	// The ID of the instance to be associated with EIPs.
	//
	// The instance can be a NAT gateway or a secondary ENI.
	BindedInstanceId *string `json:"BindedInstanceId,omitempty" xml:"BindedInstanceId,omitempty"`
	// The type of instance with which you want to associate the EIPs. Valid values:
	//
	// *   **Nat**: a NAT gateway
	// *   **NetworkInterface**: a secondary ENI
	BindedInstanceType *string `json:"BindedInstanceType,omitempty" xml:"BindedInstanceType,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among all requests. The token can only contain ASCII characters.
	//
	// >  If you do not specify this parameter, the system automatically uses **RequestId** as **ClientToken**. **RequestId** might be different for each API request.
	ClientToken *string   `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	InstanceIds []*string `json:"InstanceIds,omitempty" xml:"InstanceIds,omitempty" type:"Repeated"`
	// The association mode. Set the value to **MULTI_BINDED**, which specifies the Multi-EIP-to-ENI mode.
	//
	// This parameter is required only if **InstanceType** is set to **NetworkInterface**.
	Mode    *string `json:"Mode,omitempty" xml:"Mode,omitempty"`
	OwnerId *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region to which the EIPs belong.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to obtain the region ID.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s AssociateEipAddressBatchRequest) String() string {
	return tea.Prettify(s)
}

func (s AssociateEipAddressBatchRequest) GoString() string {
	return s.String()
}

func (s *AssociateEipAddressBatchRequest) SetBindedInstanceId(v string) *AssociateEipAddressBatchRequest {
	s.BindedInstanceId = &v
	return s
}

func (s *AssociateEipAddressBatchRequest) SetBindedInstanceType(v string) *AssociateEipAddressBatchRequest {
	s.BindedInstanceType = &v
	return s
}

func (s *AssociateEipAddressBatchRequest) SetClientToken(v string) *AssociateEipAddressBatchRequest {
	s.ClientToken = &v
	return s
}

func (s *AssociateEipAddressBatchRequest) SetInstanceIds(v []*string) *AssociateEipAddressBatchRequest {
	s.InstanceIds = v
	return s
}

func (s *AssociateEipAddressBatchRequest) SetMode(v string) *AssociateEipAddressBatchRequest {
	s.Mode = &v
	return s
}

func (s *AssociateEipAddressBatchRequest) SetOwnerId(v int64) *AssociateEipAddressBatchRequest {
	s.OwnerId = &v
	return s
}

func (s *AssociateEipAddressBatchRequest) SetRegionId(v string) *AssociateEipAddressBatchRequest {
	s.RegionId = &v
	return s
}

func (s *AssociateEipAddressBatchRequest) SetResourceOwnerAccount(v string) *AssociateEipAddressBatchRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *AssociateEipAddressBatchRequest) SetResourceOwnerId(v int64) *AssociateEipAddressBatchRequest {
	s.ResourceOwnerId = &v
	return s
}

type AssociateEipAddressBatchResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AssociateEipAddressBatchResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AssociateEipAddressBatchResponseBody) GoString() string {
	return s.String()
}

func (s *AssociateEipAddressBatchResponseBody) SetRequestId(v string) *AssociateEipAddressBatchResponseBody {
	s.RequestId = &v
	return s
}

type AssociateEipAddressBatchResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AssociateEipAddressBatchResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AssociateEipAddressBatchResponse) String() string {
	return tea.Prettify(s)
}

func (s AssociateEipAddressBatchResponse) GoString() string {
	return s.String()
}

func (s *AssociateEipAddressBatchResponse) SetHeaders(v map[string]*string) *AssociateEipAddressBatchResponse {
	s.Headers = v
	return s
}

func (s *AssociateEipAddressBatchResponse) SetStatusCode(v int32) *AssociateEipAddressBatchResponse {
	s.StatusCode = &v
	return s
}

func (s *AssociateEipAddressBatchResponse) SetBody(v *AssociateEipAddressBatchResponseBody) *AssociateEipAddressBatchResponse {
	s.Body = v
	return s
}

type AssociateGlobalAccelerationInstanceRequest struct {
	// The ID of the backend server.
	BackendServerId *string `json:"BackendServerId,omitempty" xml:"BackendServerId,omitempty"`
	// The region of the backend server. The region must belong to the service area of the GA instance.
	BackendServerRegionId *string `json:"BackendServerRegionId,omitempty" xml:"BackendServerRegionId,omitempty"`
	// The backend server type. Valid values:
	//
	// *   **EcsInstance** (default): ECS instance
	// *   **SlbInstance**: SLB instance
	BackendServerType *string `json:"BackendServerType,omitempty" xml:"BackendServerType,omitempty"`
	// The ID of the GA instance.
	GlobalAccelerationInstanceId *string `json:"GlobalAccelerationInstanceId,omitempty" xml:"GlobalAccelerationInstanceId,omitempty"`
	OwnerAccount                 *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId                      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the GA instance. You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s AssociateGlobalAccelerationInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s AssociateGlobalAccelerationInstanceRequest) GoString() string {
	return s.String()
}

func (s *AssociateGlobalAccelerationInstanceRequest) SetBackendServerId(v string) *AssociateGlobalAccelerationInstanceRequest {
	s.BackendServerId = &v
	return s
}

func (s *AssociateGlobalAccelerationInstanceRequest) SetBackendServerRegionId(v string) *AssociateGlobalAccelerationInstanceRequest {
	s.BackendServerRegionId = &v
	return s
}

func (s *AssociateGlobalAccelerationInstanceRequest) SetBackendServerType(v string) *AssociateGlobalAccelerationInstanceRequest {
	s.BackendServerType = &v
	return s
}

func (s *AssociateGlobalAccelerationInstanceRequest) SetGlobalAccelerationInstanceId(v string) *AssociateGlobalAccelerationInstanceRequest {
	s.GlobalAccelerationInstanceId = &v
	return s
}

func (s *AssociateGlobalAccelerationInstanceRequest) SetOwnerAccount(v string) *AssociateGlobalAccelerationInstanceRequest {
	s.OwnerAccount = &v
	return s
}

func (s *AssociateGlobalAccelerationInstanceRequest) SetOwnerId(v int64) *AssociateGlobalAccelerationInstanceRequest {
	s.OwnerId = &v
	return s
}

func (s *AssociateGlobalAccelerationInstanceRequest) SetRegionId(v string) *AssociateGlobalAccelerationInstanceRequest {
	s.RegionId = &v
	return s
}

func (s *AssociateGlobalAccelerationInstanceRequest) SetResourceOwnerAccount(v string) *AssociateGlobalAccelerationInstanceRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *AssociateGlobalAccelerationInstanceRequest) SetResourceOwnerId(v int64) *AssociateGlobalAccelerationInstanceRequest {
	s.ResourceOwnerId = &v
	return s
}

type AssociateGlobalAccelerationInstanceResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AssociateGlobalAccelerationInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AssociateGlobalAccelerationInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *AssociateGlobalAccelerationInstanceResponseBody) SetRequestId(v string) *AssociateGlobalAccelerationInstanceResponseBody {
	s.RequestId = &v
	return s
}

type AssociateGlobalAccelerationInstanceResponse struct {
	Headers    map[string]*string                               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AssociateGlobalAccelerationInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AssociateGlobalAccelerationInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s AssociateGlobalAccelerationInstanceResponse) GoString() string {
	return s.String()
}

func (s *AssociateGlobalAccelerationInstanceResponse) SetHeaders(v map[string]*string) *AssociateGlobalAccelerationInstanceResponse {
	s.Headers = v
	return s
}

func (s *AssociateGlobalAccelerationInstanceResponse) SetStatusCode(v int32) *AssociateGlobalAccelerationInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *AssociateGlobalAccelerationInstanceResponse) SetBody(v *AssociateGlobalAccelerationInstanceResponseBody) *AssociateGlobalAccelerationInstanceResponse {
	s.Body = v
	return s
}

type AssociateHaVipRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, the system uses **RequestId** as **ClientToken**. The value of **RequestId** in each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the HAVIP.
	HaVipId *string `json:"HaVipId,omitempty" xml:"HaVipId,omitempty"`
	// The ID of the ECS instance to be associated with the HAVIP.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The type of the instance to be associated with the HAVIP. Valid values:
	//
	// *   **EcsInstance**: an ECS instance
	// *   **NetworkInterface**: an ENI. If you want to associate the HAVIP with an ENI, this parameter is required.
	InstanceType *string `json:"InstanceType,omitempty" xml:"InstanceType,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region to which the HAVIP belongs.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s AssociateHaVipRequest) String() string {
	return tea.Prettify(s)
}

func (s AssociateHaVipRequest) GoString() string {
	return s.String()
}

func (s *AssociateHaVipRequest) SetClientToken(v string) *AssociateHaVipRequest {
	s.ClientToken = &v
	return s
}

func (s *AssociateHaVipRequest) SetHaVipId(v string) *AssociateHaVipRequest {
	s.HaVipId = &v
	return s
}

func (s *AssociateHaVipRequest) SetInstanceId(v string) *AssociateHaVipRequest {
	s.InstanceId = &v
	return s
}

func (s *AssociateHaVipRequest) SetInstanceType(v string) *AssociateHaVipRequest {
	s.InstanceType = &v
	return s
}

func (s *AssociateHaVipRequest) SetOwnerAccount(v string) *AssociateHaVipRequest {
	s.OwnerAccount = &v
	return s
}

func (s *AssociateHaVipRequest) SetOwnerId(v int64) *AssociateHaVipRequest {
	s.OwnerId = &v
	return s
}

func (s *AssociateHaVipRequest) SetRegionId(v string) *AssociateHaVipRequest {
	s.RegionId = &v
	return s
}

func (s *AssociateHaVipRequest) SetResourceOwnerAccount(v string) *AssociateHaVipRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *AssociateHaVipRequest) SetResourceOwnerId(v int64) *AssociateHaVipRequest {
	s.ResourceOwnerId = &v
	return s
}

type AssociateHaVipResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AssociateHaVipResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AssociateHaVipResponseBody) GoString() string {
	return s.String()
}

func (s *AssociateHaVipResponseBody) SetRequestId(v string) *AssociateHaVipResponseBody {
	s.RequestId = &v
	return s
}

type AssociateHaVipResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AssociateHaVipResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AssociateHaVipResponse) String() string {
	return tea.Prettify(s)
}

func (s AssociateHaVipResponse) GoString() string {
	return s.String()
}

func (s *AssociateHaVipResponse) SetHeaders(v map[string]*string) *AssociateHaVipResponse {
	s.Headers = v
	return s
}

func (s *AssociateHaVipResponse) SetStatusCode(v int32) *AssociateHaVipResponse {
	s.StatusCode = &v
	return s
}

func (s *AssociateHaVipResponse) SetBody(v *AssociateHaVipResponseBody) *AssociateHaVipResponse {
	s.Body = v
	return s
}

type AssociateNetworkAclRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among all requests. ClientToken can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the network ACL.
	NetworkAclId *string `json:"NetworkAclId,omitempty" xml:"NetworkAclId,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the network ACL. You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string                               `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	Resource             []*AssociateNetworkAclRequestResource `json:"Resource,omitempty" xml:"Resource,omitempty" type:"Repeated"`
	ResourceOwnerAccount *string                               `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64                                `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s AssociateNetworkAclRequest) String() string {
	return tea.Prettify(s)
}

func (s AssociateNetworkAclRequest) GoString() string {
	return s.String()
}

func (s *AssociateNetworkAclRequest) SetClientToken(v string) *AssociateNetworkAclRequest {
	s.ClientToken = &v
	return s
}

func (s *AssociateNetworkAclRequest) SetNetworkAclId(v string) *AssociateNetworkAclRequest {
	s.NetworkAclId = &v
	return s
}

func (s *AssociateNetworkAclRequest) SetOwnerId(v int64) *AssociateNetworkAclRequest {
	s.OwnerId = &v
	return s
}

func (s *AssociateNetworkAclRequest) SetRegionId(v string) *AssociateNetworkAclRequest {
	s.RegionId = &v
	return s
}

func (s *AssociateNetworkAclRequest) SetResource(v []*AssociateNetworkAclRequestResource) *AssociateNetworkAclRequest {
	s.Resource = v
	return s
}

func (s *AssociateNetworkAclRequest) SetResourceOwnerAccount(v string) *AssociateNetworkAclRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *AssociateNetworkAclRequest) SetResourceOwnerId(v int64) *AssociateNetworkAclRequest {
	s.ResourceOwnerId = &v
	return s
}

type AssociateNetworkAclRequestResource struct {
	// The ID of the resource with which you want to associate the network ACL.
	ResourceId *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	// The type of resource with which you want to associate the network ACL. Set the value to **VSwitch**.
	//
	// Valid values of **N**: **0** to **29**. You can associate a network ACL with up to 30 vSwitches.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
}

func (s AssociateNetworkAclRequestResource) String() string {
	return tea.Prettify(s)
}

func (s AssociateNetworkAclRequestResource) GoString() string {
	return s.String()
}

func (s *AssociateNetworkAclRequestResource) SetResourceId(v string) *AssociateNetworkAclRequestResource {
	s.ResourceId = &v
	return s
}

func (s *AssociateNetworkAclRequestResource) SetResourceType(v string) *AssociateNetworkAclRequestResource {
	s.ResourceType = &v
	return s
}

type AssociateNetworkAclResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AssociateNetworkAclResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AssociateNetworkAclResponseBody) GoString() string {
	return s.String()
}

func (s *AssociateNetworkAclResponseBody) SetRequestId(v string) *AssociateNetworkAclResponseBody {
	s.RequestId = &v
	return s
}

type AssociateNetworkAclResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AssociateNetworkAclResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AssociateNetworkAclResponse) String() string {
	return tea.Prettify(s)
}

func (s AssociateNetworkAclResponse) GoString() string {
	return s.String()
}

func (s *AssociateNetworkAclResponse) SetHeaders(v map[string]*string) *AssociateNetworkAclResponse {
	s.Headers = v
	return s
}

func (s *AssociateNetworkAclResponse) SetStatusCode(v int32) *AssociateNetworkAclResponse {
	s.StatusCode = &v
	return s
}

func (s *AssociateNetworkAclResponse) SetBody(v *AssociateNetworkAclResponseBody) *AssociateNetworkAclResponse {
	s.Body = v
	return s
}

type AssociatePhysicalConnectionToVirtualBorderRouterRequest struct {
	// The circuit code of the Express Connect circuit. The circuit code is provided by the connectivity provider.
	//
	// >  Only the owner of the Express Connect circuit can set this parameter.
	CircuitCode *string `json:"CircuitCode,omitempty" xml:"CircuitCode,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	//
	// >  If you do not set this parameter, the system automatically uses **RequestId** as **ClientToken**. **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to enable IPv6. Valid values:
	//
	// *   **true**: enables IPv6
	// *   **false** (default): disables IPv6
	EnableIpv6 *string `json:"EnableIpv6,omitempty" xml:"EnableIpv6,omitempty"`
	// The IP address of the VBR.
	LocalGatewayIp *string `json:"LocalGatewayIp,omitempty" xml:"LocalGatewayIp,omitempty"`
	// The IPv6 address of the VBR.
	LocalIpv6GatewayIp *string `json:"LocalIpv6GatewayIp,omitempty" xml:"LocalIpv6GatewayIp,omitempty"`
	OwnerAccount       *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId            *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The IP address of the gateway device in the data center.
	//
	// *   Only the owner of the VBR can set or modify this parameter.
	// *   When you create a VBR for the owner of the Express Connect circuit, this parameter is required.
	PeerGatewayIp *string `json:"PeerGatewayIp,omitempty" xml:"PeerGatewayIp,omitempty"`
	// The IPv6 address of the gateway device in the data center.
	//
	// *   Only the owner of the VBR can set or modify this parameter.
	// *   When you create a VBR for the owner of the Express Connect circuit, this parameter is required.
	PeerIpv6GatewayIp *string `json:"PeerIpv6GatewayIp,omitempty" xml:"PeerIpv6GatewayIp,omitempty"`
	// The subnet mask of the IPv6 addresses of the VBR and the gateway device in the data center.
	//
	// The two IPv6 addresses must fall within the same subnet.
	PeeringIpv6SubnetMask *string `json:"PeeringIpv6SubnetMask,omitempty" xml:"PeeringIpv6SubnetMask,omitempty"`
	// The subnet mask of the IP addresses of the VBR and the gateway device in the data center.
	//
	// The two IP addresses must fall within the same subnet.
	PeeringSubnetMask *string `json:"PeeringSubnetMask,omitempty" xml:"PeeringSubnetMask,omitempty"`
	// The ID of the Express Connect circuit.
	PhysicalConnectionId *string `json:"PhysicalConnectionId,omitempty" xml:"PhysicalConnectionId,omitempty"`
	// The ID of the region where the Express Connect circuit is deployed.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the VBR.
	VbrId *string `json:"VbrId,omitempty" xml:"VbrId,omitempty"`
	// The VLAN ID of the VBR. Valid values: **0 to 2999**.
	//
	// >  Only the owner of the Express Connect circuit can set this parameter. The VLAN IDs of two VBRs of the same the Express Connect circuit must be different.
	VlanId *string `json:"VlanId,omitempty" xml:"VlanId,omitempty"`
}

func (s AssociatePhysicalConnectionToVirtualBorderRouterRequest) String() string {
	return tea.Prettify(s)
}

func (s AssociatePhysicalConnectionToVirtualBorderRouterRequest) GoString() string {
	return s.String()
}

func (s *AssociatePhysicalConnectionToVirtualBorderRouterRequest) SetCircuitCode(v string) *AssociatePhysicalConnectionToVirtualBorderRouterRequest {
	s.CircuitCode = &v
	return s
}

func (s *AssociatePhysicalConnectionToVirtualBorderRouterRequest) SetClientToken(v string) *AssociatePhysicalConnectionToVirtualBorderRouterRequest {
	s.ClientToken = &v
	return s
}

func (s *AssociatePhysicalConnectionToVirtualBorderRouterRequest) SetEnableIpv6(v string) *AssociatePhysicalConnectionToVirtualBorderRouterRequest {
	s.EnableIpv6 = &v
	return s
}

func (s *AssociatePhysicalConnectionToVirtualBorderRouterRequest) SetLocalGatewayIp(v string) *AssociatePhysicalConnectionToVirtualBorderRouterRequest {
	s.LocalGatewayIp = &v
	return s
}

func (s *AssociatePhysicalConnectionToVirtualBorderRouterRequest) SetLocalIpv6GatewayIp(v string) *AssociatePhysicalConnectionToVirtualBorderRouterRequest {
	s.LocalIpv6GatewayIp = &v
	return s
}

func (s *AssociatePhysicalConnectionToVirtualBorderRouterRequest) SetOwnerAccount(v string) *AssociatePhysicalConnectionToVirtualBorderRouterRequest {
	s.OwnerAccount = &v
	return s
}

func (s *AssociatePhysicalConnectionToVirtualBorderRouterRequest) SetOwnerId(v int64) *AssociatePhysicalConnectionToVirtualBorderRouterRequest {
	s.OwnerId = &v
	return s
}

func (s *AssociatePhysicalConnectionToVirtualBorderRouterRequest) SetPeerGatewayIp(v string) *AssociatePhysicalConnectionToVirtualBorderRouterRequest {
	s.PeerGatewayIp = &v
	return s
}

func (s *AssociatePhysicalConnectionToVirtualBorderRouterRequest) SetPeerIpv6GatewayIp(v string) *AssociatePhysicalConnectionToVirtualBorderRouterRequest {
	s.PeerIpv6GatewayIp = &v
	return s
}

func (s *AssociatePhysicalConnectionToVirtualBorderRouterRequest) SetPeeringIpv6SubnetMask(v string) *AssociatePhysicalConnectionToVirtualBorderRouterRequest {
	s.PeeringIpv6SubnetMask = &v
	return s
}

func (s *AssociatePhysicalConnectionToVirtualBorderRouterRequest) SetPeeringSubnetMask(v string) *AssociatePhysicalConnectionToVirtualBorderRouterRequest {
	s.PeeringSubnetMask = &v
	return s
}

func (s *AssociatePhysicalConnectionToVirtualBorderRouterRequest) SetPhysicalConnectionId(v string) *AssociatePhysicalConnectionToVirtualBorderRouterRequest {
	s.PhysicalConnectionId = &v
	return s
}

func (s *AssociatePhysicalConnectionToVirtualBorderRouterRequest) SetRegionId(v string) *AssociatePhysicalConnectionToVirtualBorderRouterRequest {
	s.RegionId = &v
	return s
}

func (s *AssociatePhysicalConnectionToVirtualBorderRouterRequest) SetResourceOwnerAccount(v string) *AssociatePhysicalConnectionToVirtualBorderRouterRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *AssociatePhysicalConnectionToVirtualBorderRouterRequest) SetResourceOwnerId(v int64) *AssociatePhysicalConnectionToVirtualBorderRouterRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *AssociatePhysicalConnectionToVirtualBorderRouterRequest) SetVbrId(v string) *AssociatePhysicalConnectionToVirtualBorderRouterRequest {
	s.VbrId = &v
	return s
}

func (s *AssociatePhysicalConnectionToVirtualBorderRouterRequest) SetVlanId(v string) *AssociatePhysicalConnectionToVirtualBorderRouterRequest {
	s.VlanId = &v
	return s
}

type AssociatePhysicalConnectionToVirtualBorderRouterResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AssociatePhysicalConnectionToVirtualBorderRouterResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AssociatePhysicalConnectionToVirtualBorderRouterResponseBody) GoString() string {
	return s.String()
}

func (s *AssociatePhysicalConnectionToVirtualBorderRouterResponseBody) SetRequestId(v string) *AssociatePhysicalConnectionToVirtualBorderRouterResponseBody {
	s.RequestId = &v
	return s
}

type AssociatePhysicalConnectionToVirtualBorderRouterResponse struct {
	Headers    map[string]*string                                            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AssociatePhysicalConnectionToVirtualBorderRouterResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AssociatePhysicalConnectionToVirtualBorderRouterResponse) String() string {
	return tea.Prettify(s)
}

func (s AssociatePhysicalConnectionToVirtualBorderRouterResponse) GoString() string {
	return s.String()
}

func (s *AssociatePhysicalConnectionToVirtualBorderRouterResponse) SetHeaders(v map[string]*string) *AssociatePhysicalConnectionToVirtualBorderRouterResponse {
	s.Headers = v
	return s
}

func (s *AssociatePhysicalConnectionToVirtualBorderRouterResponse) SetStatusCode(v int32) *AssociatePhysicalConnectionToVirtualBorderRouterResponse {
	s.StatusCode = &v
	return s
}

func (s *AssociatePhysicalConnectionToVirtualBorderRouterResponse) SetBody(v *AssociatePhysicalConnectionToVirtualBorderRouterResponseBody) *AssociatePhysicalConnectionToVirtualBorderRouterResponse {
	s.Body = v
	return s
}

type AssociateRouteTableRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among all requests. The token can contain only ASCII characters.
	//
	// >  If you do not specify this parameter, **ClientToken** is set to the value of **RequestId**. **RequestId** might be different for each API request.
	ClientToken  *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the VPC to which the route table belongs.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the route table.
	RouteTableId *string `json:"RouteTableId,omitempty" xml:"RouteTableId,omitempty"`
	// The ID of the vSwitch.
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
}

func (s AssociateRouteTableRequest) String() string {
	return tea.Prettify(s)
}

func (s AssociateRouteTableRequest) GoString() string {
	return s.String()
}

func (s *AssociateRouteTableRequest) SetClientToken(v string) *AssociateRouteTableRequest {
	s.ClientToken = &v
	return s
}

func (s *AssociateRouteTableRequest) SetOwnerAccount(v string) *AssociateRouteTableRequest {
	s.OwnerAccount = &v
	return s
}

func (s *AssociateRouteTableRequest) SetOwnerId(v int64) *AssociateRouteTableRequest {
	s.OwnerId = &v
	return s
}

func (s *AssociateRouteTableRequest) SetRegionId(v string) *AssociateRouteTableRequest {
	s.RegionId = &v
	return s
}

func (s *AssociateRouteTableRequest) SetResourceOwnerAccount(v string) *AssociateRouteTableRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *AssociateRouteTableRequest) SetResourceOwnerId(v int64) *AssociateRouteTableRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *AssociateRouteTableRequest) SetRouteTableId(v string) *AssociateRouteTableRequest {
	s.RouteTableId = &v
	return s
}

func (s *AssociateRouteTableRequest) SetVSwitchId(v string) *AssociateRouteTableRequest {
	s.VSwitchId = &v
	return s
}

type AssociateRouteTableResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AssociateRouteTableResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AssociateRouteTableResponseBody) GoString() string {
	return s.String()
}

func (s *AssociateRouteTableResponseBody) SetRequestId(v string) *AssociateRouteTableResponseBody {
	s.RequestId = &v
	return s
}

type AssociateRouteTableResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AssociateRouteTableResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AssociateRouteTableResponse) String() string {
	return tea.Prettify(s)
}

func (s AssociateRouteTableResponse) GoString() string {
	return s.String()
}

func (s *AssociateRouteTableResponse) SetHeaders(v map[string]*string) *AssociateRouteTableResponse {
	s.Headers = v
	return s
}

func (s *AssociateRouteTableResponse) SetStatusCode(v int32) *AssociateRouteTableResponse {
	s.StatusCode = &v
	return s
}

func (s *AssociateRouteTableResponse) SetBody(v *AssociateRouteTableResponseBody) *AssociateRouteTableResponse {
	s.Body = v
	return s
}

type AssociateRouteTableWithGatewayRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	//
	// >  If you do not set this parameter, the system automatically uses **RequestId** as **ClientToken**. **RequestId** of each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to check the request without performing the operation. Valid values:
	//
	// *   **true**: prechecks the request without performing the operation. The system prechecks the required parameters, request syntax, and limits. If the request fails the precheck, an error message is returned. If the request passes the precheck, the `DryRunOperation` error code is returned.
	// *   **false** (default): sends the request. After the request passes the precheck, a 2xx HTTP status code is returned and the operation is performed.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The ID of the IPv4 gateway.
	//
	// The IPv4 gateway must be in the **Activated** state.
	GatewayId    *string `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the IPv4 gateway with which you want to associate the gateway route table.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the gateway route table.
	RouteTableId *string `json:"RouteTableId,omitempty" xml:"RouteTableId,omitempty"`
}

func (s AssociateRouteTableWithGatewayRequest) String() string {
	return tea.Prettify(s)
}

func (s AssociateRouteTableWithGatewayRequest) GoString() string {
	return s.String()
}

func (s *AssociateRouteTableWithGatewayRequest) SetClientToken(v string) *AssociateRouteTableWithGatewayRequest {
	s.ClientToken = &v
	return s
}

func (s *AssociateRouteTableWithGatewayRequest) SetDryRun(v bool) *AssociateRouteTableWithGatewayRequest {
	s.DryRun = &v
	return s
}

func (s *AssociateRouteTableWithGatewayRequest) SetGatewayId(v string) *AssociateRouteTableWithGatewayRequest {
	s.GatewayId = &v
	return s
}

func (s *AssociateRouteTableWithGatewayRequest) SetOwnerAccount(v string) *AssociateRouteTableWithGatewayRequest {
	s.OwnerAccount = &v
	return s
}

func (s *AssociateRouteTableWithGatewayRequest) SetOwnerId(v int64) *AssociateRouteTableWithGatewayRequest {
	s.OwnerId = &v
	return s
}

func (s *AssociateRouteTableWithGatewayRequest) SetRegionId(v string) *AssociateRouteTableWithGatewayRequest {
	s.RegionId = &v
	return s
}

func (s *AssociateRouteTableWithGatewayRequest) SetResourceOwnerAccount(v string) *AssociateRouteTableWithGatewayRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *AssociateRouteTableWithGatewayRequest) SetResourceOwnerId(v int64) *AssociateRouteTableWithGatewayRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *AssociateRouteTableWithGatewayRequest) SetRouteTableId(v string) *AssociateRouteTableWithGatewayRequest {
	s.RouteTableId = &v
	return s
}

type AssociateRouteTableWithGatewayResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AssociateRouteTableWithGatewayResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AssociateRouteTableWithGatewayResponseBody) GoString() string {
	return s.String()
}

func (s *AssociateRouteTableWithGatewayResponseBody) SetRequestId(v string) *AssociateRouteTableWithGatewayResponseBody {
	s.RequestId = &v
	return s
}

type AssociateRouteTableWithGatewayResponse struct {
	Headers    map[string]*string                          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AssociateRouteTableWithGatewayResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AssociateRouteTableWithGatewayResponse) String() string {
	return tea.Prettify(s)
}

func (s AssociateRouteTableWithGatewayResponse) GoString() string {
	return s.String()
}

func (s *AssociateRouteTableWithGatewayResponse) SetHeaders(v map[string]*string) *AssociateRouteTableWithGatewayResponse {
	s.Headers = v
	return s
}

func (s *AssociateRouteTableWithGatewayResponse) SetStatusCode(v int32) *AssociateRouteTableWithGatewayResponse {
	s.StatusCode = &v
	return s
}

func (s *AssociateRouteTableWithGatewayResponse) SetBody(v *AssociateRouteTableWithGatewayResponseBody) *AssociateRouteTableWithGatewayResponse {
	s.Body = v
	return s
}

type AssociateRouteTablesWithVpcGatewayEndpointRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate a client token. Make sure that a unique client token is used for each request. The **client token** can contain only ASCII characters and cannot exceed 64 characters in length.
	//
	// >  If you do not set this parameter, the system uses **RequestId** as **ClientToken**. The value of **RequestId** of each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to perform a dry run. Valid values:
	//
	// *   **true**: performs a dry run. The system checks your AccessKey pair, the RAM user permissions, and the required parameters. If the request fails the dry run, an error message is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
	// *   **false** (default): performs a dry run and sends the request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The ID of the gateway endpoint to be associated with the route table.
	EndpointId   *string `json:"EndpointId,omitempty" xml:"EndpointId,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the gateway endpoint.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string   `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string   `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64    `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	RouteTableIds        []*string `json:"RouteTableIds,omitempty" xml:"RouteTableIds,omitempty" type:"Repeated"`
}

func (s AssociateRouteTablesWithVpcGatewayEndpointRequest) String() string {
	return tea.Prettify(s)
}

func (s AssociateRouteTablesWithVpcGatewayEndpointRequest) GoString() string {
	return s.String()
}

func (s *AssociateRouteTablesWithVpcGatewayEndpointRequest) SetClientToken(v string) *AssociateRouteTablesWithVpcGatewayEndpointRequest {
	s.ClientToken = &v
	return s
}

func (s *AssociateRouteTablesWithVpcGatewayEndpointRequest) SetDryRun(v bool) *AssociateRouteTablesWithVpcGatewayEndpointRequest {
	s.DryRun = &v
	return s
}

func (s *AssociateRouteTablesWithVpcGatewayEndpointRequest) SetEndpointId(v string) *AssociateRouteTablesWithVpcGatewayEndpointRequest {
	s.EndpointId = &v
	return s
}

func (s *AssociateRouteTablesWithVpcGatewayEndpointRequest) SetOwnerAccount(v string) *AssociateRouteTablesWithVpcGatewayEndpointRequest {
	s.OwnerAccount = &v
	return s
}

func (s *AssociateRouteTablesWithVpcGatewayEndpointRequest) SetOwnerId(v int64) *AssociateRouteTablesWithVpcGatewayEndpointRequest {
	s.OwnerId = &v
	return s
}

func (s *AssociateRouteTablesWithVpcGatewayEndpointRequest) SetRegionId(v string) *AssociateRouteTablesWithVpcGatewayEndpointRequest {
	s.RegionId = &v
	return s
}

func (s *AssociateRouteTablesWithVpcGatewayEndpointRequest) SetResourceOwnerAccount(v string) *AssociateRouteTablesWithVpcGatewayEndpointRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *AssociateRouteTablesWithVpcGatewayEndpointRequest) SetResourceOwnerId(v int64) *AssociateRouteTablesWithVpcGatewayEndpointRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *AssociateRouteTablesWithVpcGatewayEndpointRequest) SetRouteTableIds(v []*string) *AssociateRouteTablesWithVpcGatewayEndpointRequest {
	s.RouteTableIds = v
	return s
}

type AssociateRouteTablesWithVpcGatewayEndpointResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AssociateRouteTablesWithVpcGatewayEndpointResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AssociateRouteTablesWithVpcGatewayEndpointResponseBody) GoString() string {
	return s.String()
}

func (s *AssociateRouteTablesWithVpcGatewayEndpointResponseBody) SetRequestId(v string) *AssociateRouteTablesWithVpcGatewayEndpointResponseBody {
	s.RequestId = &v
	return s
}

type AssociateRouteTablesWithVpcGatewayEndpointResponse struct {
	Headers    map[string]*string                                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AssociateRouteTablesWithVpcGatewayEndpointResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AssociateRouteTablesWithVpcGatewayEndpointResponse) String() string {
	return tea.Prettify(s)
}

func (s AssociateRouteTablesWithVpcGatewayEndpointResponse) GoString() string {
	return s.String()
}

func (s *AssociateRouteTablesWithVpcGatewayEndpointResponse) SetHeaders(v map[string]*string) *AssociateRouteTablesWithVpcGatewayEndpointResponse {
	s.Headers = v
	return s
}

func (s *AssociateRouteTablesWithVpcGatewayEndpointResponse) SetStatusCode(v int32) *AssociateRouteTablesWithVpcGatewayEndpointResponse {
	s.StatusCode = &v
	return s
}

func (s *AssociateRouteTablesWithVpcGatewayEndpointResponse) SetBody(v *AssociateRouteTablesWithVpcGatewayEndpointResponseBody) *AssociateRouteTablesWithVpcGatewayEndpointResponse {
	s.Body = v
	return s
}

type AssociateVpcCidrBlockRequest struct {
	// The IPv6 CIDR block.
	//
	// >  You must set one of the **SecondaryCidrBlock** and **Ipv6CidrBlock** parameters.
	IPv6CidrBlock *string `json:"IPv6CidrBlock,omitempty" xml:"IPv6CidrBlock,omitempty"`
	// The IP version. Valid values:
	//
	// *   **IPV4**: IPv4
	// *   **IPV6**: IPv6. If you set **IpVersion** to **IPV6** and do not set **SecondaryCidrBlock**, you can add IPv6 CIDR blocks to the VPC.
	IpVersion  *string `json:"IpVersion,omitempty" xml:"IpVersion,omitempty"`
	IpamPoolId *string `json:"IpamPoolId,omitempty" xml:"IpamPoolId,omitempty"`
	// The type of the IPv6 CIDR block. Valid values:
	//
	// *   **BGP** (default): Alibaba Cloud Border Gateway Protocol (BGP) IPv6
	// *   **ChinaMobile**: China Mobile (single line)
	// *   **ChinaUnicom**: China Unicom (single line)
	// *   **ChinaTelecom**: China Telecom (single line)
	//
	// >  If your Alibaba Cloud account is allowed to use single-ISP bandwidth, valid values are: **ChinaTelecom**, **ChinaUnicom**, and **ChinaMobile**.
	Ipv6Isp      *string `json:"Ipv6Isp,omitempty" xml:"Ipv6Isp,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the VPC to which you want to add a secondary CIDR block.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The secondary IPv4 CIDR block. Take note of the following requirements:
	//
	// *   You can specify one of the following standard IPv4 CIDR blocks or their subnets as the secondary IPv4 CIDR block: 192.168.0.0/16, 172.16.0.0/12, and 10.0.0.0/8.
	// *   You can also use a custom CIDR block other than 100.64.0.0/10, 224.0.0.0/4, 127.0.0.0/8, 169.254.0.0/16, or their subnets as the secondary IPv4 CIDR block of the VPC.
	//
	// In addition, the following requirements must be met:
	//
	// *   The CIDR block cannot start with 0. The subnet mask must be 8 to 28 bits in length.
	// *   The secondary CIDR block cannot overlap with the primary CIDR block or an existing secondary CIDR block.
	//
	// >  You must set one of the **SecondaryCidrBlock** and **Ipv6CidrBlock** parameters.
	SecondaryCidrBlock *string `json:"SecondaryCidrBlock,omitempty" xml:"SecondaryCidrBlock,omitempty"`
	// The ID of the VPC.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s AssociateVpcCidrBlockRequest) String() string {
	return tea.Prettify(s)
}

func (s AssociateVpcCidrBlockRequest) GoString() string {
	return s.String()
}

func (s *AssociateVpcCidrBlockRequest) SetIPv6CidrBlock(v string) *AssociateVpcCidrBlockRequest {
	s.IPv6CidrBlock = &v
	return s
}

func (s *AssociateVpcCidrBlockRequest) SetIpVersion(v string) *AssociateVpcCidrBlockRequest {
	s.IpVersion = &v
	return s
}

func (s *AssociateVpcCidrBlockRequest) SetIpamPoolId(v string) *AssociateVpcCidrBlockRequest {
	s.IpamPoolId = &v
	return s
}

func (s *AssociateVpcCidrBlockRequest) SetIpv6Isp(v string) *AssociateVpcCidrBlockRequest {
	s.Ipv6Isp = &v
	return s
}

func (s *AssociateVpcCidrBlockRequest) SetOwnerAccount(v string) *AssociateVpcCidrBlockRequest {
	s.OwnerAccount = &v
	return s
}

func (s *AssociateVpcCidrBlockRequest) SetOwnerId(v int64) *AssociateVpcCidrBlockRequest {
	s.OwnerId = &v
	return s
}

func (s *AssociateVpcCidrBlockRequest) SetRegionId(v string) *AssociateVpcCidrBlockRequest {
	s.RegionId = &v
	return s
}

func (s *AssociateVpcCidrBlockRequest) SetResourceOwnerAccount(v string) *AssociateVpcCidrBlockRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *AssociateVpcCidrBlockRequest) SetResourceOwnerId(v int64) *AssociateVpcCidrBlockRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *AssociateVpcCidrBlockRequest) SetSecondaryCidrBlock(v string) *AssociateVpcCidrBlockRequest {
	s.SecondaryCidrBlock = &v
	return s
}

func (s *AssociateVpcCidrBlockRequest) SetVpcId(v string) *AssociateVpcCidrBlockRequest {
	s.VpcId = &v
	return s
}

type AssociateVpcCidrBlockResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AssociateVpcCidrBlockResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AssociateVpcCidrBlockResponseBody) GoString() string {
	return s.String()
}

func (s *AssociateVpcCidrBlockResponseBody) SetRequestId(v string) *AssociateVpcCidrBlockResponseBody {
	s.RequestId = &v
	return s
}

type AssociateVpcCidrBlockResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AssociateVpcCidrBlockResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AssociateVpcCidrBlockResponse) String() string {
	return tea.Prettify(s)
}

func (s AssociateVpcCidrBlockResponse) GoString() string {
	return s.String()
}

func (s *AssociateVpcCidrBlockResponse) SetHeaders(v map[string]*string) *AssociateVpcCidrBlockResponse {
	s.Headers = v
	return s
}

func (s *AssociateVpcCidrBlockResponse) SetStatusCode(v int32) *AssociateVpcCidrBlockResponse {
	s.StatusCode = &v
	return s
}

func (s *AssociateVpcCidrBlockResponse) SetBody(v *AssociateVpcCidrBlockResponseBody) *AssociateVpcCidrBlockResponse {
	s.Body = v
	return s
}

type AssociateVpnGatewayWithCertificateRequest struct {
	// The ID of the certificate.
	CertificateId *string `json:"CertificateId,omitempty" xml:"CertificateId,omitempty"`
	// The type of the certificate. Valid values:
	//
	// *   **Encryption**
	// *   **Signature**
	CertificateType *string `json:"CertificateType,omitempty" xml:"CertificateType,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among different requests. The client token can contain only ASCII characters.
	//
	// > If you do not specify this parameter, the system automatically uses the **request ID** as the **client token**. The **request ID** may be different for each request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to perform a dry run, without performing the actual request. Valid values:
	//
	// *   **true**: performs a dry run. The system checks the request for potential issues, including missing parameter values, incorrect request syntax, and service limits. If the request passes the dry run, a request ID is returned. Otherwise, an error message is returned.
	// *   **false** (default): performs a dry run and performs the actual request. If the request passes the dry run, the operation is performed.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The region ID of the VPN gateway.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the VPN gateway.
	//
	// > You can associate only VPN gateways of the SM type with certificates.
	VpnGatewayId *string `json:"VpnGatewayId,omitempty" xml:"VpnGatewayId,omitempty"`
}

func (s AssociateVpnGatewayWithCertificateRequest) String() string {
	return tea.Prettify(s)
}

func (s AssociateVpnGatewayWithCertificateRequest) GoString() string {
	return s.String()
}

func (s *AssociateVpnGatewayWithCertificateRequest) SetCertificateId(v string) *AssociateVpnGatewayWithCertificateRequest {
	s.CertificateId = &v
	return s
}

func (s *AssociateVpnGatewayWithCertificateRequest) SetCertificateType(v string) *AssociateVpnGatewayWithCertificateRequest {
	s.CertificateType = &v
	return s
}

func (s *AssociateVpnGatewayWithCertificateRequest) SetClientToken(v string) *AssociateVpnGatewayWithCertificateRequest {
	s.ClientToken = &v
	return s
}

func (s *AssociateVpnGatewayWithCertificateRequest) SetDryRun(v bool) *AssociateVpnGatewayWithCertificateRequest {
	s.DryRun = &v
	return s
}

func (s *AssociateVpnGatewayWithCertificateRequest) SetRegionId(v string) *AssociateVpnGatewayWithCertificateRequest {
	s.RegionId = &v
	return s
}

func (s *AssociateVpnGatewayWithCertificateRequest) SetVpnGatewayId(v string) *AssociateVpnGatewayWithCertificateRequest {
	s.VpnGatewayId = &v
	return s
}

type AssociateVpnGatewayWithCertificateResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AssociateVpnGatewayWithCertificateResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AssociateVpnGatewayWithCertificateResponseBody) GoString() string {
	return s.String()
}

func (s *AssociateVpnGatewayWithCertificateResponseBody) SetRequestId(v string) *AssociateVpnGatewayWithCertificateResponseBody {
	s.RequestId = &v
	return s
}

type AssociateVpnGatewayWithCertificateResponse struct {
	Headers    map[string]*string                              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AssociateVpnGatewayWithCertificateResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AssociateVpnGatewayWithCertificateResponse) String() string {
	return tea.Prettify(s)
}

func (s AssociateVpnGatewayWithCertificateResponse) GoString() string {
	return s.String()
}

func (s *AssociateVpnGatewayWithCertificateResponse) SetHeaders(v map[string]*string) *AssociateVpnGatewayWithCertificateResponse {
	s.Headers = v
	return s
}

func (s *AssociateVpnGatewayWithCertificateResponse) SetStatusCode(v int32) *AssociateVpnGatewayWithCertificateResponse {
	s.StatusCode = &v
	return s
}

func (s *AssociateVpnGatewayWithCertificateResponse) SetBody(v *AssociateVpnGatewayWithCertificateResponseBody) *AssociateVpnGatewayWithCertificateResponse {
	s.Body = v
	return s
}

type AttachDhcpOptionsSetToVpcRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, the system uses **RequestId** as **ClientToken**. **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the DHCP options set.
	DhcpOptionsSetId *string `json:"DhcpOptionsSetId,omitempty" xml:"DhcpOptionsSetId,omitempty"`
	// Specifies whether to check the request without performing the operation. Valid values:
	//
	// **true**: checks the request without performing the operation. The system checks whether your AccessKey pair is valid, whether the Resource Access Management (RAM) user is authorized, and whether the required parameters are set. If the request fails to pass the check, the corresponding error message is returned. If the request passes the check, the `DryRunOperation` error code is returned.
	//
	// **false** (default): sends the request. If the request passes the check, a 2XX HTTP status code is returned and the operation is performed.
	DryRun       *bool   `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region to which the DHCP options set belongs. You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the VPC to be associated with the DHCP options set.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s AttachDhcpOptionsSetToVpcRequest) String() string {
	return tea.Prettify(s)
}

func (s AttachDhcpOptionsSetToVpcRequest) GoString() string {
	return s.String()
}

func (s *AttachDhcpOptionsSetToVpcRequest) SetClientToken(v string) *AttachDhcpOptionsSetToVpcRequest {
	s.ClientToken = &v
	return s
}

func (s *AttachDhcpOptionsSetToVpcRequest) SetDhcpOptionsSetId(v string) *AttachDhcpOptionsSetToVpcRequest {
	s.DhcpOptionsSetId = &v
	return s
}

func (s *AttachDhcpOptionsSetToVpcRequest) SetDryRun(v bool) *AttachDhcpOptionsSetToVpcRequest {
	s.DryRun = &v
	return s
}

func (s *AttachDhcpOptionsSetToVpcRequest) SetOwnerAccount(v string) *AttachDhcpOptionsSetToVpcRequest {
	s.OwnerAccount = &v
	return s
}

func (s *AttachDhcpOptionsSetToVpcRequest) SetOwnerId(v int64) *AttachDhcpOptionsSetToVpcRequest {
	s.OwnerId = &v
	return s
}

func (s *AttachDhcpOptionsSetToVpcRequest) SetRegionId(v string) *AttachDhcpOptionsSetToVpcRequest {
	s.RegionId = &v
	return s
}

func (s *AttachDhcpOptionsSetToVpcRequest) SetResourceOwnerAccount(v string) *AttachDhcpOptionsSetToVpcRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *AttachDhcpOptionsSetToVpcRequest) SetResourceOwnerId(v int64) *AttachDhcpOptionsSetToVpcRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *AttachDhcpOptionsSetToVpcRequest) SetVpcId(v string) *AttachDhcpOptionsSetToVpcRequest {
	s.VpcId = &v
	return s
}

type AttachDhcpOptionsSetToVpcResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AttachDhcpOptionsSetToVpcResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AttachDhcpOptionsSetToVpcResponseBody) GoString() string {
	return s.String()
}

func (s *AttachDhcpOptionsSetToVpcResponseBody) SetRequestId(v string) *AttachDhcpOptionsSetToVpcResponseBody {
	s.RequestId = &v
	return s
}

type AttachDhcpOptionsSetToVpcResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AttachDhcpOptionsSetToVpcResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AttachDhcpOptionsSetToVpcResponse) String() string {
	return tea.Prettify(s)
}

func (s AttachDhcpOptionsSetToVpcResponse) GoString() string {
	return s.String()
}

func (s *AttachDhcpOptionsSetToVpcResponse) SetHeaders(v map[string]*string) *AttachDhcpOptionsSetToVpcResponse {
	s.Headers = v
	return s
}

func (s *AttachDhcpOptionsSetToVpcResponse) SetStatusCode(v int32) *AttachDhcpOptionsSetToVpcResponse {
	s.StatusCode = &v
	return s
}

func (s *AttachDhcpOptionsSetToVpcResponse) SetBody(v *AttachDhcpOptionsSetToVpcResponseBody) *AttachDhcpOptionsSetToVpcResponse {
	s.Body = v
	return s
}

type AttachVbrToVpconnRequest struct {
	// Specifies whether to precheck the request only. Valid values:
	//
	// *   **true**: only prechecks the request but does not associate the VBR with the hosted connection. The system prechecks the request syntax, instance status, and whether the required parameters are specified. An error message is returned if the request fails to pass the precheck. If the request passes the precheck, the system returns the ID of the request.
	// *   **false** (default): sends the request. If the request passes the precheck, the VBR is associated with the hosted connection.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The region ID of the hosted connection.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// The client token must be unique among different requests. It can contain only ASCII characters and cannot exceed 64 characters in length.
	Token *string `json:"Token,omitempty" xml:"Token,omitempty"`
	// The ID of the VBR.
	VbrId *string `json:"VbrId,omitempty" xml:"VbrId,omitempty"`
	// The ID of the hosted connection.
	VpconnId *string `json:"VpconnId,omitempty" xml:"VpconnId,omitempty"`
}

func (s AttachVbrToVpconnRequest) String() string {
	return tea.Prettify(s)
}

func (s AttachVbrToVpconnRequest) GoString() string {
	return s.String()
}

func (s *AttachVbrToVpconnRequest) SetDryRun(v bool) *AttachVbrToVpconnRequest {
	s.DryRun = &v
	return s
}

func (s *AttachVbrToVpconnRequest) SetRegionId(v string) *AttachVbrToVpconnRequest {
	s.RegionId = &v
	return s
}

func (s *AttachVbrToVpconnRequest) SetToken(v string) *AttachVbrToVpconnRequest {
	s.Token = &v
	return s
}

func (s *AttachVbrToVpconnRequest) SetVbrId(v string) *AttachVbrToVpconnRequest {
	s.VbrId = &v
	return s
}

func (s *AttachVbrToVpconnRequest) SetVpconnId(v string) *AttachVbrToVpconnRequest {
	s.VpconnId = &v
	return s
}

type AttachVbrToVpconnResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the hosted connection.
	VirtualPhysicalConnection *string `json:"VirtualPhysicalConnection,omitempty" xml:"VirtualPhysicalConnection,omitempty"`
}

func (s AttachVbrToVpconnResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AttachVbrToVpconnResponseBody) GoString() string {
	return s.String()
}

func (s *AttachVbrToVpconnResponseBody) SetRequestId(v string) *AttachVbrToVpconnResponseBody {
	s.RequestId = &v
	return s
}

func (s *AttachVbrToVpconnResponseBody) SetVirtualPhysicalConnection(v string) *AttachVbrToVpconnResponseBody {
	s.VirtualPhysicalConnection = &v
	return s
}

type AttachVbrToVpconnResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AttachVbrToVpconnResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AttachVbrToVpconnResponse) String() string {
	return tea.Prettify(s)
}

func (s AttachVbrToVpconnResponse) GoString() string {
	return s.String()
}

func (s *AttachVbrToVpconnResponse) SetHeaders(v map[string]*string) *AttachVbrToVpconnResponse {
	s.Headers = v
	return s
}

func (s *AttachVbrToVpconnResponse) SetStatusCode(v int32) *AttachVbrToVpconnResponse {
	s.StatusCode = &v
	return s
}

func (s *AttachVbrToVpconnResponse) SetBody(v *AttachVbrToVpconnResponseBody) *AttachVbrToVpconnResponse {
	s.Body = v
	return s
}

type CancelCommonBandwidthPackageIpBandwidthRequest struct {
	// The ID of the EIP bandwidth plan.
	BandwidthPackageId *string `json:"BandwidthPackageId,omitempty" xml:"BandwidthPackageId,omitempty"`
	// The ID of the EIP that is associated with the EIP bandwidth plan.
	EipId        *string `json:"EipId,omitempty" xml:"EipId,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the EIP bandwidth plan. You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s CancelCommonBandwidthPackageIpBandwidthRequest) String() string {
	return tea.Prettify(s)
}

func (s CancelCommonBandwidthPackageIpBandwidthRequest) GoString() string {
	return s.String()
}

func (s *CancelCommonBandwidthPackageIpBandwidthRequest) SetBandwidthPackageId(v string) *CancelCommonBandwidthPackageIpBandwidthRequest {
	s.BandwidthPackageId = &v
	return s
}

func (s *CancelCommonBandwidthPackageIpBandwidthRequest) SetEipId(v string) *CancelCommonBandwidthPackageIpBandwidthRequest {
	s.EipId = &v
	return s
}

func (s *CancelCommonBandwidthPackageIpBandwidthRequest) SetOwnerAccount(v string) *CancelCommonBandwidthPackageIpBandwidthRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CancelCommonBandwidthPackageIpBandwidthRequest) SetOwnerId(v int64) *CancelCommonBandwidthPackageIpBandwidthRequest {
	s.OwnerId = &v
	return s
}

func (s *CancelCommonBandwidthPackageIpBandwidthRequest) SetRegionId(v string) *CancelCommonBandwidthPackageIpBandwidthRequest {
	s.RegionId = &v
	return s
}

func (s *CancelCommonBandwidthPackageIpBandwidthRequest) SetResourceOwnerAccount(v string) *CancelCommonBandwidthPackageIpBandwidthRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CancelCommonBandwidthPackageIpBandwidthRequest) SetResourceOwnerId(v int64) *CancelCommonBandwidthPackageIpBandwidthRequest {
	s.ResourceOwnerId = &v
	return s
}

type CancelCommonBandwidthPackageIpBandwidthResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CancelCommonBandwidthPackageIpBandwidthResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CancelCommonBandwidthPackageIpBandwidthResponseBody) GoString() string {
	return s.String()
}

func (s *CancelCommonBandwidthPackageIpBandwidthResponseBody) SetRequestId(v string) *CancelCommonBandwidthPackageIpBandwidthResponseBody {
	s.RequestId = &v
	return s
}

type CancelCommonBandwidthPackageIpBandwidthResponse struct {
	Headers    map[string]*string                                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CancelCommonBandwidthPackageIpBandwidthResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CancelCommonBandwidthPackageIpBandwidthResponse) String() string {
	return tea.Prettify(s)
}

func (s CancelCommonBandwidthPackageIpBandwidthResponse) GoString() string {
	return s.String()
}

func (s *CancelCommonBandwidthPackageIpBandwidthResponse) SetHeaders(v map[string]*string) *CancelCommonBandwidthPackageIpBandwidthResponse {
	s.Headers = v
	return s
}

func (s *CancelCommonBandwidthPackageIpBandwidthResponse) SetStatusCode(v int32) *CancelCommonBandwidthPackageIpBandwidthResponse {
	s.StatusCode = &v
	return s
}

func (s *CancelCommonBandwidthPackageIpBandwidthResponse) SetBody(v *CancelCommonBandwidthPackageIpBandwidthResponseBody) *CancelCommonBandwidthPackageIpBandwidthResponse {
	s.Body = v
	return s
}

type CancelPhysicalConnectionRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken  *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the Express Connect circuit.
	PhysicalConnectionId *string `json:"PhysicalConnectionId,omitempty" xml:"PhysicalConnectionId,omitempty"`
	// The region ID of the Express Connect circuit.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s CancelPhysicalConnectionRequest) String() string {
	return tea.Prettify(s)
}

func (s CancelPhysicalConnectionRequest) GoString() string {
	return s.String()
}

func (s *CancelPhysicalConnectionRequest) SetClientToken(v string) *CancelPhysicalConnectionRequest {
	s.ClientToken = &v
	return s
}

func (s *CancelPhysicalConnectionRequest) SetOwnerAccount(v string) *CancelPhysicalConnectionRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CancelPhysicalConnectionRequest) SetOwnerId(v int64) *CancelPhysicalConnectionRequest {
	s.OwnerId = &v
	return s
}

func (s *CancelPhysicalConnectionRequest) SetPhysicalConnectionId(v string) *CancelPhysicalConnectionRequest {
	s.PhysicalConnectionId = &v
	return s
}

func (s *CancelPhysicalConnectionRequest) SetRegionId(v string) *CancelPhysicalConnectionRequest {
	s.RegionId = &v
	return s
}

func (s *CancelPhysicalConnectionRequest) SetResourceOwnerAccount(v string) *CancelPhysicalConnectionRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CancelPhysicalConnectionRequest) SetResourceOwnerId(v int64) *CancelPhysicalConnectionRequest {
	s.ResourceOwnerId = &v
	return s
}

type CancelPhysicalConnectionResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CancelPhysicalConnectionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CancelPhysicalConnectionResponseBody) GoString() string {
	return s.String()
}

func (s *CancelPhysicalConnectionResponseBody) SetRequestId(v string) *CancelPhysicalConnectionResponseBody {
	s.RequestId = &v
	return s
}

type CancelPhysicalConnectionResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CancelPhysicalConnectionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CancelPhysicalConnectionResponse) String() string {
	return tea.Prettify(s)
}

func (s CancelPhysicalConnectionResponse) GoString() string {
	return s.String()
}

func (s *CancelPhysicalConnectionResponse) SetHeaders(v map[string]*string) *CancelPhysicalConnectionResponse {
	s.Headers = v
	return s
}

func (s *CancelPhysicalConnectionResponse) SetStatusCode(v int32) *CancelPhysicalConnectionResponse {
	s.StatusCode = &v
	return s
}

func (s *CancelPhysicalConnectionResponse) SetBody(v *CancelPhysicalConnectionResponseBody) *CancelPhysicalConnectionResponse {
	s.Body = v
	return s
}

type ChangeResourceGroupRequest struct {
	// The ID of the new resource group.
	//
	// >  You can use resource groups to manage resources owned by your Alibaba Cloud account. Resource groups simplify the resource and permission management of your Alibaba Cloud account. For more information, see [What is resource management?](~~94475~~).
	NewResourceGroupId *string `json:"NewResourceGroupId,omitempty" xml:"NewResourceGroupId,omitempty"`
	// The region ID of the resource group.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query available regions.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the Express Connect circuit.
	ResourceId *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	// The type of the resource. Set the value to **PHYSICALCONNECTION**, which specifies an Express Connect circuit.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
}

func (s ChangeResourceGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s ChangeResourceGroupRequest) GoString() string {
	return s.String()
}

func (s *ChangeResourceGroupRequest) SetNewResourceGroupId(v string) *ChangeResourceGroupRequest {
	s.NewResourceGroupId = &v
	return s
}

func (s *ChangeResourceGroupRequest) SetRegionId(v string) *ChangeResourceGroupRequest {
	s.RegionId = &v
	return s
}

func (s *ChangeResourceGroupRequest) SetResourceId(v string) *ChangeResourceGroupRequest {
	s.ResourceId = &v
	return s
}

func (s *ChangeResourceGroupRequest) SetResourceType(v string) *ChangeResourceGroupRequest {
	s.ResourceType = &v
	return s
}

type ChangeResourceGroupResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ChangeResourceGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ChangeResourceGroupResponseBody) GoString() string {
	return s.String()
}

func (s *ChangeResourceGroupResponseBody) SetRequestId(v string) *ChangeResourceGroupResponseBody {
	s.RequestId = &v
	return s
}

type ChangeResourceGroupResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ChangeResourceGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ChangeResourceGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s ChangeResourceGroupResponse) GoString() string {
	return s.String()
}

func (s *ChangeResourceGroupResponse) SetHeaders(v map[string]*string) *ChangeResourceGroupResponse {
	s.Headers = v
	return s
}

func (s *ChangeResourceGroupResponse) SetStatusCode(v int32) *ChangeResourceGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *ChangeResourceGroupResponse) SetBody(v *ChangeResourceGroupResponseBody) *ChangeResourceGroupResponse {
	s.Body = v
	return s
}

type CheckCanAllocateVpcPrivateIpAddressRequest struct {
	// The version of the private IP address. Valid values:
	//
	// *   **ipv4**: IPv4 If you want to query an IPv4 address, this parameter is optional.
	// *   **ipv6**: IPv6 If you want to query an IPv6 address, this parameter is required.
	IpVersion    *string `json:"IpVersion,omitempty" xml:"IpVersion,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// To query whether a private IP address is available, the private IP address must belong to the vSwitch specified by the **VSwitchId** parameter.
	PrivateIpAddress *string `json:"PrivateIpAddress,omitempty" xml:"PrivateIpAddress,omitempty"`
	// The region ID of the vSwitch to which the private IP address that you want to query belongs.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the vSwitch to which the private IP address to be queried belongs.
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
}

func (s CheckCanAllocateVpcPrivateIpAddressRequest) String() string {
	return tea.Prettify(s)
}

func (s CheckCanAllocateVpcPrivateIpAddressRequest) GoString() string {
	return s.String()
}

func (s *CheckCanAllocateVpcPrivateIpAddressRequest) SetIpVersion(v string) *CheckCanAllocateVpcPrivateIpAddressRequest {
	s.IpVersion = &v
	return s
}

func (s *CheckCanAllocateVpcPrivateIpAddressRequest) SetOwnerAccount(v string) *CheckCanAllocateVpcPrivateIpAddressRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CheckCanAllocateVpcPrivateIpAddressRequest) SetOwnerId(v int64) *CheckCanAllocateVpcPrivateIpAddressRequest {
	s.OwnerId = &v
	return s
}

func (s *CheckCanAllocateVpcPrivateIpAddressRequest) SetPrivateIpAddress(v string) *CheckCanAllocateVpcPrivateIpAddressRequest {
	s.PrivateIpAddress = &v
	return s
}

func (s *CheckCanAllocateVpcPrivateIpAddressRequest) SetRegionId(v string) *CheckCanAllocateVpcPrivateIpAddressRequest {
	s.RegionId = &v
	return s
}

func (s *CheckCanAllocateVpcPrivateIpAddressRequest) SetResourceOwnerAccount(v string) *CheckCanAllocateVpcPrivateIpAddressRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CheckCanAllocateVpcPrivateIpAddressRequest) SetResourceOwnerId(v int64) *CheckCanAllocateVpcPrivateIpAddressRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CheckCanAllocateVpcPrivateIpAddressRequest) SetVSwitchId(v string) *CheckCanAllocateVpcPrivateIpAddressRequest {
	s.VSwitchId = &v
	return s
}

type CheckCanAllocateVpcPrivateIpAddressResponseBody struct {
	// Indicates whether the private IP address is available. Valid values:
	//
	// *   **true**: yes
	// *   **false**: no
	CanAllocate *bool `json:"CanAllocate,omitempty" xml:"CanAllocate,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CheckCanAllocateVpcPrivateIpAddressResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CheckCanAllocateVpcPrivateIpAddressResponseBody) GoString() string {
	return s.String()
}

func (s *CheckCanAllocateVpcPrivateIpAddressResponseBody) SetCanAllocate(v bool) *CheckCanAllocateVpcPrivateIpAddressResponseBody {
	s.CanAllocate = &v
	return s
}

func (s *CheckCanAllocateVpcPrivateIpAddressResponseBody) SetRequestId(v string) *CheckCanAllocateVpcPrivateIpAddressResponseBody {
	s.RequestId = &v
	return s
}

type CheckCanAllocateVpcPrivateIpAddressResponse struct {
	Headers    map[string]*string                               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CheckCanAllocateVpcPrivateIpAddressResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CheckCanAllocateVpcPrivateIpAddressResponse) String() string {
	return tea.Prettify(s)
}

func (s CheckCanAllocateVpcPrivateIpAddressResponse) GoString() string {
	return s.String()
}

func (s *CheckCanAllocateVpcPrivateIpAddressResponse) SetHeaders(v map[string]*string) *CheckCanAllocateVpcPrivateIpAddressResponse {
	s.Headers = v
	return s
}

func (s *CheckCanAllocateVpcPrivateIpAddressResponse) SetStatusCode(v int32) *CheckCanAllocateVpcPrivateIpAddressResponse {
	s.StatusCode = &v
	return s
}

func (s *CheckCanAllocateVpcPrivateIpAddressResponse) SetBody(v *CheckCanAllocateVpcPrivateIpAddressResponseBody) *CheckCanAllocateVpcPrivateIpAddressResponse {
	s.Body = v
	return s
}

type CheckVpnBgpEnabledRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. ClientToken can contain only ASCII characters.
	//
	// >  If you do not set this parameter, the system automatically uses **RequestId** as **ClientToken**. **RequestId** of each API request may be different.
	ClientToken  *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	// The ID of the region to which the IPsec-VPN connection belongs.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s CheckVpnBgpEnabledRequest) String() string {
	return tea.Prettify(s)
}

func (s CheckVpnBgpEnabledRequest) GoString() string {
	return s.String()
}

func (s *CheckVpnBgpEnabledRequest) SetClientToken(v string) *CheckVpnBgpEnabledRequest {
	s.ClientToken = &v
	return s
}

func (s *CheckVpnBgpEnabledRequest) SetOwnerAccount(v string) *CheckVpnBgpEnabledRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CheckVpnBgpEnabledRequest) SetRegionId(v string) *CheckVpnBgpEnabledRequest {
	s.RegionId = &v
	return s
}

func (s *CheckVpnBgpEnabledRequest) SetResourceOwnerAccount(v string) *CheckVpnBgpEnabledRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CheckVpnBgpEnabledRequest) SetResourceOwnerId(v int64) *CheckVpnBgpEnabledRequest {
	s.ResourceOwnerId = &v
	return s
}

type CheckVpnBgpEnabledResponseBody struct {
	// Indicates whether the BGP feature is supported in the current region.
	//
	// *   **true**: supported.
	// *   **false**: not supported.
	BgpEnabled *bool `json:"BgpEnabled,omitempty" xml:"BgpEnabled,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CheckVpnBgpEnabledResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CheckVpnBgpEnabledResponseBody) GoString() string {
	return s.String()
}

func (s *CheckVpnBgpEnabledResponseBody) SetBgpEnabled(v bool) *CheckVpnBgpEnabledResponseBody {
	s.BgpEnabled = &v
	return s
}

func (s *CheckVpnBgpEnabledResponseBody) SetRequestId(v string) *CheckVpnBgpEnabledResponseBody {
	s.RequestId = &v
	return s
}

type CheckVpnBgpEnabledResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CheckVpnBgpEnabledResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CheckVpnBgpEnabledResponse) String() string {
	return tea.Prettify(s)
}

func (s CheckVpnBgpEnabledResponse) GoString() string {
	return s.String()
}

func (s *CheckVpnBgpEnabledResponse) SetHeaders(v map[string]*string) *CheckVpnBgpEnabledResponse {
	s.Headers = v
	return s
}

func (s *CheckVpnBgpEnabledResponse) SetStatusCode(v int32) *CheckVpnBgpEnabledResponse {
	s.StatusCode = &v
	return s
}

func (s *CheckVpnBgpEnabledResponse) SetBody(v *CheckVpnBgpEnabledResponseBody) *CheckVpnBgpEnabledResponse {
	s.Body = v
	return s
}

type CompletePhysicalConnectionLOARequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must ensure that it is unique among different requests.
	//
	// >  If you do not set this parameter, the system automatically uses **RequestId** as **ClientToken**. **RequestId** of each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the Express Connect circuit.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The circuit code provided by the connectivity provider.
	LineCode *string `json:"LineCode,omitempty" xml:"LineCode,omitempty"`
	// The label of the cable in the data center.
	LineLabel    *string `json:"LineLabel,omitempty" xml:"LineLabel,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the Express Connect circuit.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s CompletePhysicalConnectionLOARequest) String() string {
	return tea.Prettify(s)
}

func (s CompletePhysicalConnectionLOARequest) GoString() string {
	return s.String()
}

func (s *CompletePhysicalConnectionLOARequest) SetClientToken(v string) *CompletePhysicalConnectionLOARequest {
	s.ClientToken = &v
	return s
}

func (s *CompletePhysicalConnectionLOARequest) SetInstanceId(v string) *CompletePhysicalConnectionLOARequest {
	s.InstanceId = &v
	return s
}

func (s *CompletePhysicalConnectionLOARequest) SetLineCode(v string) *CompletePhysicalConnectionLOARequest {
	s.LineCode = &v
	return s
}

func (s *CompletePhysicalConnectionLOARequest) SetLineLabel(v string) *CompletePhysicalConnectionLOARequest {
	s.LineLabel = &v
	return s
}

func (s *CompletePhysicalConnectionLOARequest) SetOwnerAccount(v string) *CompletePhysicalConnectionLOARequest {
	s.OwnerAccount = &v
	return s
}

func (s *CompletePhysicalConnectionLOARequest) SetOwnerId(v int64) *CompletePhysicalConnectionLOARequest {
	s.OwnerId = &v
	return s
}

func (s *CompletePhysicalConnectionLOARequest) SetRegionId(v string) *CompletePhysicalConnectionLOARequest {
	s.RegionId = &v
	return s
}

func (s *CompletePhysicalConnectionLOARequest) SetResourceOwnerAccount(v string) *CompletePhysicalConnectionLOARequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CompletePhysicalConnectionLOARequest) SetResourceOwnerId(v int64) *CompletePhysicalConnectionLOARequest {
	s.ResourceOwnerId = &v
	return s
}

type CompletePhysicalConnectionLOAResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CompletePhysicalConnectionLOAResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CompletePhysicalConnectionLOAResponseBody) GoString() string {
	return s.String()
}

func (s *CompletePhysicalConnectionLOAResponseBody) SetRequestId(v string) *CompletePhysicalConnectionLOAResponseBody {
	s.RequestId = &v
	return s
}

type CompletePhysicalConnectionLOAResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CompletePhysicalConnectionLOAResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CompletePhysicalConnectionLOAResponse) String() string {
	return tea.Prettify(s)
}

func (s CompletePhysicalConnectionLOAResponse) GoString() string {
	return s.String()
}

func (s *CompletePhysicalConnectionLOAResponse) SetHeaders(v map[string]*string) *CompletePhysicalConnectionLOAResponse {
	s.Headers = v
	return s
}

func (s *CompletePhysicalConnectionLOAResponse) SetStatusCode(v int32) *CompletePhysicalConnectionLOAResponse {
	s.StatusCode = &v
	return s
}

func (s *CompletePhysicalConnectionLOAResponse) SetBody(v *CompletePhysicalConnectionLOAResponseBody) *CompletePhysicalConnectionLOAResponse {
	s.Body = v
	return s
}

type ConfirmPhysicalConnectionRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	//
	// >  If you do not set this parameter, the system uses **RequestId** as **ClientToken**. **RequestId** may be different for each API request.
	ClientToken  *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the Express Connect circuit.
	PhysicalConnectionId *string `json:"PhysicalConnectionId,omitempty" xml:"PhysicalConnectionId,omitempty"`
	// The region ID of the Express Connect circuit.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ConfirmPhysicalConnectionRequest) String() string {
	return tea.Prettify(s)
}

func (s ConfirmPhysicalConnectionRequest) GoString() string {
	return s.String()
}

func (s *ConfirmPhysicalConnectionRequest) SetClientToken(v string) *ConfirmPhysicalConnectionRequest {
	s.ClientToken = &v
	return s
}

func (s *ConfirmPhysicalConnectionRequest) SetOwnerAccount(v string) *ConfirmPhysicalConnectionRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ConfirmPhysicalConnectionRequest) SetOwnerId(v int64) *ConfirmPhysicalConnectionRequest {
	s.OwnerId = &v
	return s
}

func (s *ConfirmPhysicalConnectionRequest) SetPhysicalConnectionId(v string) *ConfirmPhysicalConnectionRequest {
	s.PhysicalConnectionId = &v
	return s
}

func (s *ConfirmPhysicalConnectionRequest) SetRegionId(v string) *ConfirmPhysicalConnectionRequest {
	s.RegionId = &v
	return s
}

func (s *ConfirmPhysicalConnectionRequest) SetResourceOwnerAccount(v string) *ConfirmPhysicalConnectionRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ConfirmPhysicalConnectionRequest) SetResourceOwnerId(v int64) *ConfirmPhysicalConnectionRequest {
	s.ResourceOwnerId = &v
	return s
}

type ConfirmPhysicalConnectionResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ConfirmPhysicalConnectionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ConfirmPhysicalConnectionResponseBody) GoString() string {
	return s.String()
}

func (s *ConfirmPhysicalConnectionResponseBody) SetRequestId(v string) *ConfirmPhysicalConnectionResponseBody {
	s.RequestId = &v
	return s
}

type ConfirmPhysicalConnectionResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ConfirmPhysicalConnectionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ConfirmPhysicalConnectionResponse) String() string {
	return tea.Prettify(s)
}

func (s ConfirmPhysicalConnectionResponse) GoString() string {
	return s.String()
}

func (s *ConfirmPhysicalConnectionResponse) SetHeaders(v map[string]*string) *ConfirmPhysicalConnectionResponse {
	s.Headers = v
	return s
}

func (s *ConfirmPhysicalConnectionResponse) SetStatusCode(v int32) *ConfirmPhysicalConnectionResponse {
	s.StatusCode = &v
	return s
}

func (s *ConfirmPhysicalConnectionResponse) SetBody(v *ConfirmPhysicalConnectionResponseBody) *ConfirmPhysicalConnectionResponse {
	s.Body = v
	return s
}

type ConnectRouterInterfaceRequest struct {
	OwnerId *int64 `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region where the router interface is deployed.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the initiator router interface.
	RouterInterfaceId *string `json:"RouterInterfaceId,omitempty" xml:"RouterInterfaceId,omitempty"`
}

func (s ConnectRouterInterfaceRequest) String() string {
	return tea.Prettify(s)
}

func (s ConnectRouterInterfaceRequest) GoString() string {
	return s.String()
}

func (s *ConnectRouterInterfaceRequest) SetOwnerId(v int64) *ConnectRouterInterfaceRequest {
	s.OwnerId = &v
	return s
}

func (s *ConnectRouterInterfaceRequest) SetRegionId(v string) *ConnectRouterInterfaceRequest {
	s.RegionId = &v
	return s
}

func (s *ConnectRouterInterfaceRequest) SetResourceOwnerAccount(v string) *ConnectRouterInterfaceRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ConnectRouterInterfaceRequest) SetResourceOwnerId(v int64) *ConnectRouterInterfaceRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ConnectRouterInterfaceRequest) SetRouterInterfaceId(v string) *ConnectRouterInterfaceRequest {
	s.RouterInterfaceId = &v
	return s
}

type ConnectRouterInterfaceResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ConnectRouterInterfaceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ConnectRouterInterfaceResponseBody) GoString() string {
	return s.String()
}

func (s *ConnectRouterInterfaceResponseBody) SetRequestId(v string) *ConnectRouterInterfaceResponseBody {
	s.RequestId = &v
	return s
}

type ConnectRouterInterfaceResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ConnectRouterInterfaceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ConnectRouterInterfaceResponse) String() string {
	return tea.Prettify(s)
}

func (s ConnectRouterInterfaceResponse) GoString() string {
	return s.String()
}

func (s *ConnectRouterInterfaceResponse) SetHeaders(v map[string]*string) *ConnectRouterInterfaceResponse {
	s.Headers = v
	return s
}

func (s *ConnectRouterInterfaceResponse) SetStatusCode(v int32) *ConnectRouterInterfaceResponse {
	s.StatusCode = &v
	return s
}

func (s *ConnectRouterInterfaceResponse) SetBody(v *ConnectRouterInterfaceResponseBody) *ConnectRouterInterfaceResponse {
	s.Body = v
	return s
}

type ConvertBandwidthPackageRequest struct {
	// The ID of the NAT bandwidth package.
	BandwidthPackageId *string `json:"BandwidthPackageId,omitempty" xml:"BandwidthPackageId,omitempty"`
	// The client token that guarantees the idempotence of the request. The value of this parameter is generated by the client and is unique among different requests. The **ClientToken** value is 1 to 64 ASCII characters in length. For more information, see [How to ensure idempotence](~~36569~~).
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	OwnerId     *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region to which the NAT Gateway belongs. To query the region ID, call [DescribeRegions](~~36063~~).
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ConvertBandwidthPackageRequest) String() string {
	return tea.Prettify(s)
}

func (s ConvertBandwidthPackageRequest) GoString() string {
	return s.String()
}

func (s *ConvertBandwidthPackageRequest) SetBandwidthPackageId(v string) *ConvertBandwidthPackageRequest {
	s.BandwidthPackageId = &v
	return s
}

func (s *ConvertBandwidthPackageRequest) SetClientToken(v string) *ConvertBandwidthPackageRequest {
	s.ClientToken = &v
	return s
}

func (s *ConvertBandwidthPackageRequest) SetOwnerId(v int64) *ConvertBandwidthPackageRequest {
	s.OwnerId = &v
	return s
}

func (s *ConvertBandwidthPackageRequest) SetRegionId(v string) *ConvertBandwidthPackageRequest {
	s.RegionId = &v
	return s
}

func (s *ConvertBandwidthPackageRequest) SetResourceOwnerAccount(v string) *ConvertBandwidthPackageRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ConvertBandwidthPackageRequest) SetResourceOwnerId(v int64) *ConvertBandwidthPackageRequest {
	s.ResourceOwnerId = &v
	return s
}

type ConvertBandwidthPackageResponseBody struct {
	// The ID of the Internet Shared Bandwidth instance after the conversion.
	ConvertInstanceId *string `json:"ConvertInstanceId,omitempty" xml:"ConvertInstanceId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ConvertBandwidthPackageResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ConvertBandwidthPackageResponseBody) GoString() string {
	return s.String()
}

func (s *ConvertBandwidthPackageResponseBody) SetConvertInstanceId(v string) *ConvertBandwidthPackageResponseBody {
	s.ConvertInstanceId = &v
	return s
}

func (s *ConvertBandwidthPackageResponseBody) SetRequestId(v string) *ConvertBandwidthPackageResponseBody {
	s.RequestId = &v
	return s
}

type ConvertBandwidthPackageResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ConvertBandwidthPackageResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ConvertBandwidthPackageResponse) String() string {
	return tea.Prettify(s)
}

func (s ConvertBandwidthPackageResponse) GoString() string {
	return s.String()
}

func (s *ConvertBandwidthPackageResponse) SetHeaders(v map[string]*string) *ConvertBandwidthPackageResponse {
	s.Headers = v
	return s
}

func (s *ConvertBandwidthPackageResponse) SetStatusCode(v int32) *ConvertBandwidthPackageResponse {
	s.StatusCode = &v
	return s
}

func (s *ConvertBandwidthPackageResponse) SetBody(v *ConvertBandwidthPackageResponseBody) *ConvertBandwidthPackageResponse {
	s.Body = v
	return s
}

type CopyNetworkAclEntriesRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, the system uses **RequestId** as **ClientToken**. **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the network ACL.
	NetworkAclId *string `json:"NetworkAclId,omitempty" xml:"NetworkAclId,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region where the network ACL is deployed. You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the network ACL whose rules you want to copy.
	SourceNetworkAclId *string `json:"SourceNetworkAclId,omitempty" xml:"SourceNetworkAclId,omitempty"`
}

func (s CopyNetworkAclEntriesRequest) String() string {
	return tea.Prettify(s)
}

func (s CopyNetworkAclEntriesRequest) GoString() string {
	return s.String()
}

func (s *CopyNetworkAclEntriesRequest) SetClientToken(v string) *CopyNetworkAclEntriesRequest {
	s.ClientToken = &v
	return s
}

func (s *CopyNetworkAclEntriesRequest) SetNetworkAclId(v string) *CopyNetworkAclEntriesRequest {
	s.NetworkAclId = &v
	return s
}

func (s *CopyNetworkAclEntriesRequest) SetOwnerId(v int64) *CopyNetworkAclEntriesRequest {
	s.OwnerId = &v
	return s
}

func (s *CopyNetworkAclEntriesRequest) SetRegionId(v string) *CopyNetworkAclEntriesRequest {
	s.RegionId = &v
	return s
}

func (s *CopyNetworkAclEntriesRequest) SetResourceOwnerAccount(v string) *CopyNetworkAclEntriesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CopyNetworkAclEntriesRequest) SetResourceOwnerId(v int64) *CopyNetworkAclEntriesRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CopyNetworkAclEntriesRequest) SetSourceNetworkAclId(v string) *CopyNetworkAclEntriesRequest {
	s.SourceNetworkAclId = &v
	return s
}

type CopyNetworkAclEntriesResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CopyNetworkAclEntriesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CopyNetworkAclEntriesResponseBody) GoString() string {
	return s.String()
}

func (s *CopyNetworkAclEntriesResponseBody) SetRequestId(v string) *CopyNetworkAclEntriesResponseBody {
	s.RequestId = &v
	return s
}

type CopyNetworkAclEntriesResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CopyNetworkAclEntriesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CopyNetworkAclEntriesResponse) String() string {
	return tea.Prettify(s)
}

func (s CopyNetworkAclEntriesResponse) GoString() string {
	return s.String()
}

func (s *CopyNetworkAclEntriesResponse) SetHeaders(v map[string]*string) *CopyNetworkAclEntriesResponse {
	s.Headers = v
	return s
}

func (s *CopyNetworkAclEntriesResponse) SetStatusCode(v int32) *CopyNetworkAclEntriesResponse {
	s.StatusCode = &v
	return s
}

func (s *CopyNetworkAclEntriesResponse) SetBody(v *CopyNetworkAclEntriesResponseBody) *CopyNetworkAclEntriesResponse {
	s.Body = v
	return s
}

type CreateBgpGroupRequest struct {
	// The authentication key of the BGP group.
	AuthKey *string `json:"AuthKey,omitempty" xml:"AuthKey,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among all requests. ClientToken can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The description of the BGP group.
	//
	// The description must be 2 to 256 characters in length. It must start with a letter and cannot start with `http://` or `https://`.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The IP version. Valid values:
	//
	// *   **IPv4**: This is the default value.
	// *   **IPv6**: IPv6 is supported only if the VBR for which you want to create the BGP group has IPv6 enabled.
	IpVersion *string `json:"IpVersion,omitempty" xml:"IpVersion,omitempty"`
	// Specifies whether to use a fake ASN. Valid values:
	//
	// *   **false** (default): no
	// *   **true**: yes
	//
	// >  In most cases, a router that runs BGP belongs to only one AS. If you want to use a different ASN to communicate with the peer but you cannot modify the BGP configuration because it may cause service downtime, you can use a fake ASN. For example, you can use a fake ASN to communicate with the peer when you migrate or merge ASs. This prevents service interruptions.
	IsFakeAsn *bool `json:"IsFakeAsn,omitempty" xml:"IsFakeAsn,omitempty"`
	// The custom ASN on the Alibaba Cloud side. Valid values:
	//
	// *   **45104**
	// *   **64512~65534**
	// *   **4200000000~4294967294**
	//
	// >  **65025** is reserved by Alibaba Cloud. By default, Alibaba Cloud uses **45104** as **LocalAsn**. If you use a custom **LocalAsn** in scenarios where multiple connections are used, BGP loops may occur. Proceed with caution.
	LocalAsn *int64 `json:"LocalAsn,omitempty" xml:"LocalAsn,omitempty"`
	// The name of the BGP group.
	//
	// The name must be 2 to 128 characters in length, and can contain letters, digits, periods (.), underscores (\_), and hyphens (-). The name must start with a letter.
	Name         *string `json:"Name,omitempty" xml:"Name,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ASN of the gateway device in the data center.
	PeerAsn *int64 `json:"PeerAsn,omitempty" xml:"PeerAsn,omitempty"`
	// The region ID of the VBR.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The maximum number of routes supported by a BGP peer. Default value: **110**.
	RouteQuota *int32 `json:"RouteQuota,omitempty" xml:"RouteQuota,omitempty"`
	// The ID of the VBR.
	RouterId *string `json:"RouterId,omitempty" xml:"RouterId,omitempty"`
}

func (s CreateBgpGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateBgpGroupRequest) GoString() string {
	return s.String()
}

func (s *CreateBgpGroupRequest) SetAuthKey(v string) *CreateBgpGroupRequest {
	s.AuthKey = &v
	return s
}

func (s *CreateBgpGroupRequest) SetClientToken(v string) *CreateBgpGroupRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateBgpGroupRequest) SetDescription(v string) *CreateBgpGroupRequest {
	s.Description = &v
	return s
}

func (s *CreateBgpGroupRequest) SetIpVersion(v string) *CreateBgpGroupRequest {
	s.IpVersion = &v
	return s
}

func (s *CreateBgpGroupRequest) SetIsFakeAsn(v bool) *CreateBgpGroupRequest {
	s.IsFakeAsn = &v
	return s
}

func (s *CreateBgpGroupRequest) SetLocalAsn(v int64) *CreateBgpGroupRequest {
	s.LocalAsn = &v
	return s
}

func (s *CreateBgpGroupRequest) SetName(v string) *CreateBgpGroupRequest {
	s.Name = &v
	return s
}

func (s *CreateBgpGroupRequest) SetOwnerAccount(v string) *CreateBgpGroupRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateBgpGroupRequest) SetOwnerId(v int64) *CreateBgpGroupRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateBgpGroupRequest) SetPeerAsn(v int64) *CreateBgpGroupRequest {
	s.PeerAsn = &v
	return s
}

func (s *CreateBgpGroupRequest) SetRegionId(v string) *CreateBgpGroupRequest {
	s.RegionId = &v
	return s
}

func (s *CreateBgpGroupRequest) SetResourceOwnerAccount(v string) *CreateBgpGroupRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateBgpGroupRequest) SetResourceOwnerId(v int64) *CreateBgpGroupRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreateBgpGroupRequest) SetRouteQuota(v int32) *CreateBgpGroupRequest {
	s.RouteQuota = &v
	return s
}

func (s *CreateBgpGroupRequest) SetRouterId(v string) *CreateBgpGroupRequest {
	s.RouterId = &v
	return s
}

type CreateBgpGroupResponseBody struct {
	// The ID of the BGP group.
	BgpGroupId *string `json:"BgpGroupId,omitempty" xml:"BgpGroupId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateBgpGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateBgpGroupResponseBody) GoString() string {
	return s.String()
}

func (s *CreateBgpGroupResponseBody) SetBgpGroupId(v string) *CreateBgpGroupResponseBody {
	s.BgpGroupId = &v
	return s
}

func (s *CreateBgpGroupResponseBody) SetRequestId(v string) *CreateBgpGroupResponseBody {
	s.RequestId = &v
	return s
}

type CreateBgpGroupResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateBgpGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateBgpGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateBgpGroupResponse) GoString() string {
	return s.String()
}

func (s *CreateBgpGroupResponse) SetHeaders(v map[string]*string) *CreateBgpGroupResponse {
	s.Headers = v
	return s
}

func (s *CreateBgpGroupResponse) SetStatusCode(v int32) *CreateBgpGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateBgpGroupResponse) SetBody(v *CreateBgpGroupResponseBody) *CreateBgpGroupResponse {
	s.Body = v
	return s
}

type CreateBgpPeerRequest struct {
	// The BFD hop count. Valid values: **1** to **255**.
	//
	// This parameter is required only if you enable BFD.
	//
	// The parameter specifies the maximum number of network devices that a packet can traverse from the source to the destination. Set a value based on your network topology.
	BfdMultiHop *int32 `json:"BfdMultiHop,omitempty" xml:"BfdMultiHop,omitempty"`
	// The ID of the BGP group.
	BgpGroupId *string `json:"BgpGroupId,omitempty" xml:"BgpGroupId,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that the value is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	//
	// >  If you do not set this parameter, the system uses the value of **RequestId** as **ClientToken**. The value of **RequestId** for each API request is different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to enable the Bidirectional Forwarding Detection (BFD) feature. Valid values:
	//
	// *   **true**: enables BFD.
	// *   **false**: disables BFD.
	EnableBfd *bool `json:"EnableBfd,omitempty" xml:"EnableBfd,omitempty"`
	// The IP version. Valid values:
	//
	// *   **IPv4**: This is the default value.
	// *   **IPv6**: IPv6 is supported only if the VBR for which you want to create the BGP group has IPv6 enabled.
	IpVersion    *string `json:"IpVersion,omitempty" xml:"IpVersion,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The IP address of the BGP peer.
	PeerIpAddress *string `json:"PeerIpAddress,omitempty" xml:"PeerIpAddress,omitempty"`
	// The ID of the region to which the BGP group belongs.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s CreateBgpPeerRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateBgpPeerRequest) GoString() string {
	return s.String()
}

func (s *CreateBgpPeerRequest) SetBfdMultiHop(v int32) *CreateBgpPeerRequest {
	s.BfdMultiHop = &v
	return s
}

func (s *CreateBgpPeerRequest) SetBgpGroupId(v string) *CreateBgpPeerRequest {
	s.BgpGroupId = &v
	return s
}

func (s *CreateBgpPeerRequest) SetClientToken(v string) *CreateBgpPeerRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateBgpPeerRequest) SetEnableBfd(v bool) *CreateBgpPeerRequest {
	s.EnableBfd = &v
	return s
}

func (s *CreateBgpPeerRequest) SetIpVersion(v string) *CreateBgpPeerRequest {
	s.IpVersion = &v
	return s
}

func (s *CreateBgpPeerRequest) SetOwnerAccount(v string) *CreateBgpPeerRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateBgpPeerRequest) SetOwnerId(v int64) *CreateBgpPeerRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateBgpPeerRequest) SetPeerIpAddress(v string) *CreateBgpPeerRequest {
	s.PeerIpAddress = &v
	return s
}

func (s *CreateBgpPeerRequest) SetRegionId(v string) *CreateBgpPeerRequest {
	s.RegionId = &v
	return s
}

func (s *CreateBgpPeerRequest) SetResourceOwnerAccount(v string) *CreateBgpPeerRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateBgpPeerRequest) SetResourceOwnerId(v int64) *CreateBgpPeerRequest {
	s.ResourceOwnerId = &v
	return s
}

type CreateBgpPeerResponseBody struct {
	// The ID of the BGP peer.
	BgpPeerId *string `json:"BgpPeerId,omitempty" xml:"BgpPeerId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateBgpPeerResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateBgpPeerResponseBody) GoString() string {
	return s.String()
}

func (s *CreateBgpPeerResponseBody) SetBgpPeerId(v string) *CreateBgpPeerResponseBody {
	s.BgpPeerId = &v
	return s
}

func (s *CreateBgpPeerResponseBody) SetRequestId(v string) *CreateBgpPeerResponseBody {
	s.RequestId = &v
	return s
}

type CreateBgpPeerResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateBgpPeerResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateBgpPeerResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateBgpPeerResponse) GoString() string {
	return s.String()
}

func (s *CreateBgpPeerResponse) SetHeaders(v map[string]*string) *CreateBgpPeerResponse {
	s.Headers = v
	return s
}

func (s *CreateBgpPeerResponse) SetStatusCode(v int32) *CreateBgpPeerResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateBgpPeerResponse) SetBody(v *CreateBgpPeerResponseBody) *CreateBgpPeerResponse {
	s.Body = v
	return s
}

type CreateCommonBandwidthPackageRequest struct {
	// The maximum bandwidth of the EIP bandwidth plan.
	//
	// Valid values: **1** to **1000**. Unit: Mbit/s.
	Bandwidth *int32 `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, the system automatically sets the **ClientToken** parameter to the value of **RequestId**. The value of **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The description of the EIP bandwidth plan.
	//
	// The description must be 2 to 256 characters in length. It must start with a letter but cannot start with `http://` or `https://`.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The line type. Valid values:
	//
	// *   **BGP**: BGP (Multi-ISP) lines. BGP (Multi-ISP) lines are available in all regions.
	// *   **BGP_PRO**: BGP (Multi-ISP) Pro lines. BGP (Multi-ISP) Pro is available only in the China (Hong Kong), Singapore, Philippines (Manila), Malaysia (Kuala Lumpur), Indonesia (Jakarta), and Thailand (Bangkok) regions.
	//
	// If you are allowed to use single-ISP bandwidth, you can also choose one of the following values:
	//
	// *   **ChinaTelecom**: China Telecom
	// *   **ChinaUnicom**: China Unicom
	// *   **ChinaMobile**: China Mobile
	// *   **ChinaTelecom_L2**: China Telecom L2
	// *   **ChinaUnicom_L2**: China Unicom L2
	// *   **ChinaMobile_L2**: China Mobile L2
	//
	// If your services are deployed in China East 1 Finance, you must set this parameter to **BGP_FinanceCloud**.
	ISP *string `json:"ISP,omitempty" xml:"ISP,omitempty"`
	// The billing method of the EIP bandwidth plan. Set the value to **PayByTraffic**, which refers to the pay-by-data-transfer metering method.
	InternetChargeType *string `json:"InternetChargeType,omitempty" xml:"InternetChargeType,omitempty"`
	// The name of the EIP bandwidth plan.
	//
	// The name must be 2 to 128 characters in length, and can contain letters, digits, underscores (\_), and hyphens (-). The name must start with a letter.
	Name         *string `json:"Name,omitempty" xml:"Name,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The percentage of the minimum bandwidth commitment. Set the parameter to **20**.
	//
	// >  This parameter is available only on the Alibaba Cloud China site.
	Ratio *int32 `json:"Ratio,omitempty" xml:"Ratio,omitempty"`
	// The region ID of the EIP bandwidth plan.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to obtain the region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId         *string   `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount    *string   `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId         *int64    `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	SecurityProtectionTypes []*string `json:"SecurityProtectionTypes,omitempty" xml:"SecurityProtectionTypes,omitempty" type:"Repeated"`
	// The zone of the EIP bandwidth plan.
	//
	// You do not need to set this parameter.
	Zone *string `json:"Zone,omitempty" xml:"Zone,omitempty"`
}

func (s CreateCommonBandwidthPackageRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateCommonBandwidthPackageRequest) GoString() string {
	return s.String()
}

func (s *CreateCommonBandwidthPackageRequest) SetBandwidth(v int32) *CreateCommonBandwidthPackageRequest {
	s.Bandwidth = &v
	return s
}

func (s *CreateCommonBandwidthPackageRequest) SetClientToken(v string) *CreateCommonBandwidthPackageRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateCommonBandwidthPackageRequest) SetDescription(v string) *CreateCommonBandwidthPackageRequest {
	s.Description = &v
	return s
}

func (s *CreateCommonBandwidthPackageRequest) SetISP(v string) *CreateCommonBandwidthPackageRequest {
	s.ISP = &v
	return s
}

func (s *CreateCommonBandwidthPackageRequest) SetInternetChargeType(v string) *CreateCommonBandwidthPackageRequest {
	s.InternetChargeType = &v
	return s
}

func (s *CreateCommonBandwidthPackageRequest) SetName(v string) *CreateCommonBandwidthPackageRequest {
	s.Name = &v
	return s
}

func (s *CreateCommonBandwidthPackageRequest) SetOwnerAccount(v string) *CreateCommonBandwidthPackageRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateCommonBandwidthPackageRequest) SetOwnerId(v int64) *CreateCommonBandwidthPackageRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateCommonBandwidthPackageRequest) SetRatio(v int32) *CreateCommonBandwidthPackageRequest {
	s.Ratio = &v
	return s
}

func (s *CreateCommonBandwidthPackageRequest) SetRegionId(v string) *CreateCommonBandwidthPackageRequest {
	s.RegionId = &v
	return s
}

func (s *CreateCommonBandwidthPackageRequest) SetResourceGroupId(v string) *CreateCommonBandwidthPackageRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *CreateCommonBandwidthPackageRequest) SetResourceOwnerAccount(v string) *CreateCommonBandwidthPackageRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateCommonBandwidthPackageRequest) SetResourceOwnerId(v int64) *CreateCommonBandwidthPackageRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreateCommonBandwidthPackageRequest) SetSecurityProtectionTypes(v []*string) *CreateCommonBandwidthPackageRequest {
	s.SecurityProtectionTypes = v
	return s
}

func (s *CreateCommonBandwidthPackageRequest) SetZone(v string) *CreateCommonBandwidthPackageRequest {
	s.Zone = &v
	return s
}

type CreateCommonBandwidthPackageResponseBody struct {
	// The ID of the EIP bandwidth plan.
	BandwidthPackageId *string `json:"BandwidthPackageId,omitempty" xml:"BandwidthPackageId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
}

func (s CreateCommonBandwidthPackageResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateCommonBandwidthPackageResponseBody) GoString() string {
	return s.String()
}

func (s *CreateCommonBandwidthPackageResponseBody) SetBandwidthPackageId(v string) *CreateCommonBandwidthPackageResponseBody {
	s.BandwidthPackageId = &v
	return s
}

func (s *CreateCommonBandwidthPackageResponseBody) SetRequestId(v string) *CreateCommonBandwidthPackageResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateCommonBandwidthPackageResponseBody) SetResourceGroupId(v string) *CreateCommonBandwidthPackageResponseBody {
	s.ResourceGroupId = &v
	return s
}

type CreateCommonBandwidthPackageResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateCommonBandwidthPackageResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateCommonBandwidthPackageResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateCommonBandwidthPackageResponse) GoString() string {
	return s.String()
}

func (s *CreateCommonBandwidthPackageResponse) SetHeaders(v map[string]*string) *CreateCommonBandwidthPackageResponse {
	s.Headers = v
	return s
}

func (s *CreateCommonBandwidthPackageResponse) SetStatusCode(v int32) *CreateCommonBandwidthPackageResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateCommonBandwidthPackageResponse) SetBody(v *CreateCommonBandwidthPackageResponseBody) *CreateCommonBandwidthPackageResponse {
	s.Body = v
	return s
}

type CreateCustomerGatewayRequest struct {
	// The autonomous system number (ASN) of the gateway device in the data center.
	//
	// **Asn** is a 4-byte number. You can enter the number in two segments and separate the first 16 bits from the following 16 bits with a period (.). Enter the number in each segment in the decimal format.
	//
	// For example, if you enter 123.456, the ASN is: 123 × 65536 + 456 = 8061384.
	Asn *string `json:"Asn,omitempty" xml:"Asn,omitempty"`
	// The authentication key of the BGP routing protocol for the gateway device in the data center.
	//
	// The key must be 1 to 64 characters in length. It can contain only ASCII characters and cannot contain spaces or question marks (?).
	AuthKey *string `json:"AuthKey,omitempty" xml:"AuthKey,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	//
	// > If you do not specify this parameter, the system automatically uses the **request ID** as the **client token**. The **request ID** may be different for each request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The description of the customer gateway.
	//
	// The description must be 1 to 100 characters in length, and cannot start with `http://` or `https://`.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The public IP address of the gateway device in the data center.
	IpAddress *string `json:"IpAddress,omitempty" xml:"IpAddress,omitempty"`
	// The name of the customer gateway.
	//
	// The name must be 1 to 100 characters in length, and cannot start with `http://` or `https://`.
	Name         *string `json:"Name,omitempty" xml:"Name,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the customer gateway.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The tag value.
	//
	// The tag value can be an empty string and cannot exceed 128 characters in length. It cannot start with `aliyun` or `acs:`, and cannot contain `http://` or `https://`.
	//
	// Each tag key corresponds to one tag value. You can specify up to 20 tag values in each call.
	Tags []*CreateCustomerGatewayRequestTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
}

func (s CreateCustomerGatewayRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateCustomerGatewayRequest) GoString() string {
	return s.String()
}

func (s *CreateCustomerGatewayRequest) SetAsn(v string) *CreateCustomerGatewayRequest {
	s.Asn = &v
	return s
}

func (s *CreateCustomerGatewayRequest) SetAuthKey(v string) *CreateCustomerGatewayRequest {
	s.AuthKey = &v
	return s
}

func (s *CreateCustomerGatewayRequest) SetClientToken(v string) *CreateCustomerGatewayRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateCustomerGatewayRequest) SetDescription(v string) *CreateCustomerGatewayRequest {
	s.Description = &v
	return s
}

func (s *CreateCustomerGatewayRequest) SetIpAddress(v string) *CreateCustomerGatewayRequest {
	s.IpAddress = &v
	return s
}

func (s *CreateCustomerGatewayRequest) SetName(v string) *CreateCustomerGatewayRequest {
	s.Name = &v
	return s
}

func (s *CreateCustomerGatewayRequest) SetOwnerAccount(v string) *CreateCustomerGatewayRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateCustomerGatewayRequest) SetOwnerId(v int64) *CreateCustomerGatewayRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateCustomerGatewayRequest) SetRegionId(v string) *CreateCustomerGatewayRequest {
	s.RegionId = &v
	return s
}

func (s *CreateCustomerGatewayRequest) SetResourceOwnerAccount(v string) *CreateCustomerGatewayRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateCustomerGatewayRequest) SetResourceOwnerId(v int64) *CreateCustomerGatewayRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreateCustomerGatewayRequest) SetTags(v []*CreateCustomerGatewayRequestTags) *CreateCustomerGatewayRequest {
	s.Tags = v
	return s
}

type CreateCustomerGatewayRequestTags struct {
	// The tag key. The tag key cannot be an empty string.
	//
	// It can be at most 64 characters in length, and cannot contain `http://` or `https://`. It cannot start with `aliyun` or `acs:`.
	//
	// You can specify at most 20 tag keys in each call.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value.
	//
	// The tag value can be an empty string and cannot exceed 128 characters in length. It cannot start with `aliyun` or `acs:`, and cannot contain `http://` or `https://`.
	//
	// Each tag key corresponds to one tag value. You can specify at most 20 tag values in each call.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateCustomerGatewayRequestTags) String() string {
	return tea.Prettify(s)
}

func (s CreateCustomerGatewayRequestTags) GoString() string {
	return s.String()
}

func (s *CreateCustomerGatewayRequestTags) SetKey(v string) *CreateCustomerGatewayRequestTags {
	s.Key = &v
	return s
}

func (s *CreateCustomerGatewayRequestTags) SetValue(v string) *CreateCustomerGatewayRequestTags {
	s.Value = &v
	return s
}

type CreateCustomerGatewayResponseBody struct {
	// The timestamp generated when the customer gateway was created. Unit: milliseconds.
	//
	// This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The ID of the customer gateway.
	CustomerGatewayId *string `json:"CustomerGatewayId,omitempty" xml:"CustomerGatewayId,omitempty"`
	// The description of the customer gateway.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The public IP address of the gateway device in the data center.
	IpAddress *string `json:"IpAddress,omitempty" xml:"IpAddress,omitempty"`
	// The name of the customer gateway.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateCustomerGatewayResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateCustomerGatewayResponseBody) GoString() string {
	return s.String()
}

func (s *CreateCustomerGatewayResponseBody) SetCreateTime(v int64) *CreateCustomerGatewayResponseBody {
	s.CreateTime = &v
	return s
}

func (s *CreateCustomerGatewayResponseBody) SetCustomerGatewayId(v string) *CreateCustomerGatewayResponseBody {
	s.CustomerGatewayId = &v
	return s
}

func (s *CreateCustomerGatewayResponseBody) SetDescription(v string) *CreateCustomerGatewayResponseBody {
	s.Description = &v
	return s
}

func (s *CreateCustomerGatewayResponseBody) SetIpAddress(v string) *CreateCustomerGatewayResponseBody {
	s.IpAddress = &v
	return s
}

func (s *CreateCustomerGatewayResponseBody) SetName(v string) *CreateCustomerGatewayResponseBody {
	s.Name = &v
	return s
}

func (s *CreateCustomerGatewayResponseBody) SetRequestId(v string) *CreateCustomerGatewayResponseBody {
	s.RequestId = &v
	return s
}

type CreateCustomerGatewayResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateCustomerGatewayResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateCustomerGatewayResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateCustomerGatewayResponse) GoString() string {
	return s.String()
}

func (s *CreateCustomerGatewayResponse) SetHeaders(v map[string]*string) *CreateCustomerGatewayResponse {
	s.Headers = v
	return s
}

func (s *CreateCustomerGatewayResponse) SetStatusCode(v int32) *CreateCustomerGatewayResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateCustomerGatewayResponse) SetBody(v *CreateCustomerGatewayResponseBody) *CreateCustomerGatewayResponse {
	s.Body = v
	return s
}

type CreateDefaultVSwitchRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, the system automatically uses the **request ID** as the **client token**. The **request ID** may be different for each request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The last eight bits of the IPv6 CIDR block of the vSwitch. Valid values: **0** to **255**.
	Ipv6CidrBlock *int32  `json:"Ipv6CidrBlock,omitempty" xml:"Ipv6CidrBlock,omitempty"`
	OwnerAccount  *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the default vSwitch.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The zone ID of the default vSwitch.
	//
	// You can call the [DescribeZones](~~36064~~) operation to query the most recent zone list.
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
}

func (s CreateDefaultVSwitchRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateDefaultVSwitchRequest) GoString() string {
	return s.String()
}

func (s *CreateDefaultVSwitchRequest) SetClientToken(v string) *CreateDefaultVSwitchRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateDefaultVSwitchRequest) SetIpv6CidrBlock(v int32) *CreateDefaultVSwitchRequest {
	s.Ipv6CidrBlock = &v
	return s
}

func (s *CreateDefaultVSwitchRequest) SetOwnerAccount(v string) *CreateDefaultVSwitchRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateDefaultVSwitchRequest) SetOwnerId(v int64) *CreateDefaultVSwitchRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateDefaultVSwitchRequest) SetRegionId(v string) *CreateDefaultVSwitchRequest {
	s.RegionId = &v
	return s
}

func (s *CreateDefaultVSwitchRequest) SetResourceOwnerAccount(v string) *CreateDefaultVSwitchRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateDefaultVSwitchRequest) SetResourceOwnerId(v int64) *CreateDefaultVSwitchRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreateDefaultVSwitchRequest) SetZoneId(v string) *CreateDefaultVSwitchRequest {
	s.ZoneId = &v
	return s
}

type CreateDefaultVSwitchResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the default vSwitch.
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
}

func (s CreateDefaultVSwitchResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateDefaultVSwitchResponseBody) GoString() string {
	return s.String()
}

func (s *CreateDefaultVSwitchResponseBody) SetRequestId(v string) *CreateDefaultVSwitchResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateDefaultVSwitchResponseBody) SetVSwitchId(v string) *CreateDefaultVSwitchResponseBody {
	s.VSwitchId = &v
	return s
}

type CreateDefaultVSwitchResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateDefaultVSwitchResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateDefaultVSwitchResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateDefaultVSwitchResponse) GoString() string {
	return s.String()
}

func (s *CreateDefaultVSwitchResponse) SetHeaders(v map[string]*string) *CreateDefaultVSwitchResponse {
	s.Headers = v
	return s
}

func (s *CreateDefaultVSwitchResponse) SetStatusCode(v int32) *CreateDefaultVSwitchResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateDefaultVSwitchResponse) SetBody(v *CreateDefaultVSwitchResponseBody) *CreateDefaultVSwitchResponse {
	s.Body = v
	return s
}

type CreateDefaultVpcRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters.
	//
	// > If you do not specify this parameter, the system automatically uses the **request ID** as the **client token**. The **request ID** may be different for each request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to enable IPv6. Valid values:
	//
	// *   **false** (default)
	// *   **true**
	EnableIpv6 *bool `json:"EnableIpv6,omitempty" xml:"EnableIpv6,omitempty"`
	// The IPv6 CIDR block of the default VPC.
	//
	// > When **EnableIpv6** is set to **true**, this parameter is required.
	Ipv6CidrBlock *string `json:"Ipv6CidrBlock,omitempty" xml:"Ipv6CidrBlock,omitempty"`
	OwnerAccount  *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region to which the default VPC belongs.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s CreateDefaultVpcRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateDefaultVpcRequest) GoString() string {
	return s.String()
}

func (s *CreateDefaultVpcRequest) SetClientToken(v string) *CreateDefaultVpcRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateDefaultVpcRequest) SetEnableIpv6(v bool) *CreateDefaultVpcRequest {
	s.EnableIpv6 = &v
	return s
}

func (s *CreateDefaultVpcRequest) SetIpv6CidrBlock(v string) *CreateDefaultVpcRequest {
	s.Ipv6CidrBlock = &v
	return s
}

func (s *CreateDefaultVpcRequest) SetOwnerAccount(v string) *CreateDefaultVpcRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateDefaultVpcRequest) SetOwnerId(v int64) *CreateDefaultVpcRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateDefaultVpcRequest) SetRegionId(v string) *CreateDefaultVpcRequest {
	s.RegionId = &v
	return s
}

func (s *CreateDefaultVpcRequest) SetResourceGroupId(v string) *CreateDefaultVpcRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *CreateDefaultVpcRequest) SetResourceOwnerAccount(v string) *CreateDefaultVpcRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateDefaultVpcRequest) SetResourceOwnerId(v int64) *CreateDefaultVpcRequest {
	s.ResourceOwnerId = &v
	return s
}

type CreateDefaultVpcResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The route table ID that is automatically created by the system after you create a default VPC.
	RouteTableId *string `json:"RouteTableId,omitempty" xml:"RouteTableId,omitempty"`
	// The vRouter ID that is automatically created by the system after you create a default VPC.
	VRouterId *string `json:"VRouterId,omitempty" xml:"VRouterId,omitempty"`
	// The ID of the default VPC.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s CreateDefaultVpcResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateDefaultVpcResponseBody) GoString() string {
	return s.String()
}

func (s *CreateDefaultVpcResponseBody) SetRequestId(v string) *CreateDefaultVpcResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateDefaultVpcResponseBody) SetRouteTableId(v string) *CreateDefaultVpcResponseBody {
	s.RouteTableId = &v
	return s
}

func (s *CreateDefaultVpcResponseBody) SetVRouterId(v string) *CreateDefaultVpcResponseBody {
	s.VRouterId = &v
	return s
}

func (s *CreateDefaultVpcResponseBody) SetVpcId(v string) *CreateDefaultVpcResponseBody {
	s.VpcId = &v
	return s
}

type CreateDefaultVpcResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateDefaultVpcResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateDefaultVpcResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateDefaultVpcResponse) GoString() string {
	return s.String()
}

func (s *CreateDefaultVpcResponse) SetHeaders(v map[string]*string) *CreateDefaultVpcResponse {
	s.Headers = v
	return s
}

func (s *CreateDefaultVpcResponse) SetStatusCode(v int32) *CreateDefaultVpcResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateDefaultVpcResponse) SetBody(v *CreateDefaultVpcResponseBody) *CreateDefaultVpcResponse {
	s.Body = v
	return s
}

type CreateDhcpOptionsSetRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that the value is unique among different requests. The token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, the system uses **RequestId** as **ClientToken**. **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The description of the DHCP options set.
	//
	// The description must be 2 to 256 characters in length. It must start with a letter and cannot start with `http://` or `https://`. You can also leave the description empty.
	DhcpOptionsSetDescription *string `json:"DhcpOptionsSetDescription,omitempty" xml:"DhcpOptionsSetDescription,omitempty"`
	// The name of the DHCP options set.
	//
	// The name must be 2 to 128 characters in length, and can contain letters, digits, underscores (\_), and hyphens (-). The name must start with a letter.
	DhcpOptionsSetName *string `json:"DhcpOptionsSetName,omitempty" xml:"DhcpOptionsSetName,omitempty"`
	// The root domain. For example, you can set the value to example.com.
	//
	// After a DHCP options set is associated with a virtual private cloud (VPC), the root domain in the DHCP options set is automatically synchronized with the ECS instances in the VPC.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The IP address of the DNS server. You can enter at most four DNS server IP addresses. Separate IP addresses with commas (,).
	//
	// >  If you do not specify a DNS server IP address, Elastic Compute Service (ECS) instances use the IP addresses of the Alibaba Cloud DNS servers, which are 100.100.2.136 and 100.100.2.138.
	DomainNameServers *string `json:"DomainNameServers,omitempty" xml:"DomainNameServers,omitempty"`
	// Specifies whether to perform a dry run. Valid values:
	//
	// **true**: performs a dry run. The system checks the required parameters, request format, and limits. If the request fails the dry run, an error message is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
	//
	// **false** (default): performs a dry run and sends the request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The lease time of the IPv6 addresses for the DHCP options set.
	//
	// *   If you use hours as the unit, valid values are **24h to 1176h** and **87600h to 175200h**. Default value: **87600h**.
	// *   If you use days as the unit, valid values are **1d to 49d** and **3650d to 7300d**. Default value: **3650d**.
	//
	// >  When you specify a value, you must also specify the unit.
	Ipv6LeaseTime *string `json:"Ipv6LeaseTime,omitempty" xml:"Ipv6LeaseTime,omitempty"`
	// The lease time of the IPv4 addresses for the DHCP options set.
	//
	// *   If you use hours as the unit, valid values are **24h to 1176h** and **87600h to 175200h**. Default value: **87600h**.
	// *   If you use days as the unit, valid values are **1d to 49d** and **3650d to 7300d**. Default value: **3650d**.
	//
	// >  When you specify a value, you must also specify the unit.
	LeaseTime    *string `json:"LeaseTime,omitempty" xml:"LeaseTime,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region to which the DHCP options set belongs.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string                           `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceGroupId      *string                           `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string                           `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64                            `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	Tag                  []*CreateDhcpOptionsSetRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s CreateDhcpOptionsSetRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateDhcpOptionsSetRequest) GoString() string {
	return s.String()
}

func (s *CreateDhcpOptionsSetRequest) SetClientToken(v string) *CreateDhcpOptionsSetRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateDhcpOptionsSetRequest) SetDhcpOptionsSetDescription(v string) *CreateDhcpOptionsSetRequest {
	s.DhcpOptionsSetDescription = &v
	return s
}

func (s *CreateDhcpOptionsSetRequest) SetDhcpOptionsSetName(v string) *CreateDhcpOptionsSetRequest {
	s.DhcpOptionsSetName = &v
	return s
}

func (s *CreateDhcpOptionsSetRequest) SetDomainName(v string) *CreateDhcpOptionsSetRequest {
	s.DomainName = &v
	return s
}

func (s *CreateDhcpOptionsSetRequest) SetDomainNameServers(v string) *CreateDhcpOptionsSetRequest {
	s.DomainNameServers = &v
	return s
}

func (s *CreateDhcpOptionsSetRequest) SetDryRun(v bool) *CreateDhcpOptionsSetRequest {
	s.DryRun = &v
	return s
}

func (s *CreateDhcpOptionsSetRequest) SetIpv6LeaseTime(v string) *CreateDhcpOptionsSetRequest {
	s.Ipv6LeaseTime = &v
	return s
}

func (s *CreateDhcpOptionsSetRequest) SetLeaseTime(v string) *CreateDhcpOptionsSetRequest {
	s.LeaseTime = &v
	return s
}

func (s *CreateDhcpOptionsSetRequest) SetOwnerAccount(v string) *CreateDhcpOptionsSetRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateDhcpOptionsSetRequest) SetOwnerId(v int64) *CreateDhcpOptionsSetRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateDhcpOptionsSetRequest) SetRegionId(v string) *CreateDhcpOptionsSetRequest {
	s.RegionId = &v
	return s
}

func (s *CreateDhcpOptionsSetRequest) SetResourceGroupId(v string) *CreateDhcpOptionsSetRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *CreateDhcpOptionsSetRequest) SetResourceOwnerAccount(v string) *CreateDhcpOptionsSetRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateDhcpOptionsSetRequest) SetResourceOwnerId(v int64) *CreateDhcpOptionsSetRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreateDhcpOptionsSetRequest) SetTag(v []*CreateDhcpOptionsSetRequestTag) *CreateDhcpOptionsSetRequest {
	s.Tag = v
	return s
}

type CreateDhcpOptionsSetRequestTag struct {
	Key   *string `json:"Key,omitempty" xml:"Key,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateDhcpOptionsSetRequestTag) String() string {
	return tea.Prettify(s)
}

func (s CreateDhcpOptionsSetRequestTag) GoString() string {
	return s.String()
}

func (s *CreateDhcpOptionsSetRequestTag) SetKey(v string) *CreateDhcpOptionsSetRequestTag {
	s.Key = &v
	return s
}

func (s *CreateDhcpOptionsSetRequestTag) SetValue(v string) *CreateDhcpOptionsSetRequestTag {
	s.Value = &v
	return s
}

type CreateDhcpOptionsSetResponseBody struct {
	// The ID of the DHCP options set that is created.
	DhcpOptionsSetId *string `json:"DhcpOptionsSetId,omitempty" xml:"DhcpOptionsSetId,omitempty"`
	// The ID of the request.
	RequestId       *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
}

func (s CreateDhcpOptionsSetResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateDhcpOptionsSetResponseBody) GoString() string {
	return s.String()
}

func (s *CreateDhcpOptionsSetResponseBody) SetDhcpOptionsSetId(v string) *CreateDhcpOptionsSetResponseBody {
	s.DhcpOptionsSetId = &v
	return s
}

func (s *CreateDhcpOptionsSetResponseBody) SetRequestId(v string) *CreateDhcpOptionsSetResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateDhcpOptionsSetResponseBody) SetResourceGroupId(v string) *CreateDhcpOptionsSetResponseBody {
	s.ResourceGroupId = &v
	return s
}

type CreateDhcpOptionsSetResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateDhcpOptionsSetResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateDhcpOptionsSetResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateDhcpOptionsSetResponse) GoString() string {
	return s.String()
}

func (s *CreateDhcpOptionsSetResponse) SetHeaders(v map[string]*string) *CreateDhcpOptionsSetResponse {
	s.Headers = v
	return s
}

func (s *CreateDhcpOptionsSetResponse) SetStatusCode(v int32) *CreateDhcpOptionsSetResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateDhcpOptionsSetResponse) SetBody(v *CreateDhcpOptionsSetResponseBody) *CreateDhcpOptionsSetResponse {
	s.Body = v
	return s
}

type CreateExpressCloudConnectionRequest struct {
	// The bandwidth for ECC, which corresponds to the bandwidth for the underlying circuit.
	//
	// Unit: Mbit/s.
	Bandwidth *int32 `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	// The email address of the contact who applies for ECC.
	ContactMail *string `json:"ContactMail,omitempty" xml:"ContactMail,omitempty"`
	// The phone number of the contact who applies for ECC.
	ContactTel *string `json:"ContactTel,omitempty" xml:"ContactTel,omitempty"`
	// The description of ECC.
	//
	// The description must be 2 to 256 characters in length. It must start with a letter but cannot start with `http://` or `https://`.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID card number of the contact who applies for ECC.
	IDCardNo *string `json:"IDCardNo,omitempty" xml:"IDCardNo,omitempty"`
	// The Internet service provider (ISP) for the data center.
	IdcSP *string `json:"IdcSP,omitempty" xml:"IdcSP,omitempty"`
	// The name of the ECC instance.
	//
	// The name must be 2 to 128 characters in length and can contain letters, digits, periods (.), underscores (\_), and hyphens (-). It must start with a letter but cannot start with `http://` or `https://`.
	Name         *string `json:"Name,omitempty" xml:"Name,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The city where the data center is located.
	PeerCity *string `json:"PeerCity,omitempty" xml:"PeerCity,omitempty"`
	// The geographical location of the data center.
	//
	// > It must be accurate to house number-floor-room number-server rack number.
	PeerLocation *string `json:"PeerLocation,omitempty" xml:"PeerLocation,omitempty"`
	// The port of the Express Connect circuit. Valid values:
	//
	// *   100Base-T
	// *   1000Base-T
	// *   1000Base-LX
	// *   10GBase-T
	// *   10GBase-LR
	PortType *string `json:"PortType,omitempty" xml:"PortType,omitempty"`
	// The ID of the standby Express Connect circuit.
	RedundantEccId *string `json:"RedundantEccId,omitempty" xml:"RedundantEccId,omitempty"`
	// The region ID of the ECC instance.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s CreateExpressCloudConnectionRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateExpressCloudConnectionRequest) GoString() string {
	return s.String()
}

func (s *CreateExpressCloudConnectionRequest) SetBandwidth(v int32) *CreateExpressCloudConnectionRequest {
	s.Bandwidth = &v
	return s
}

func (s *CreateExpressCloudConnectionRequest) SetContactMail(v string) *CreateExpressCloudConnectionRequest {
	s.ContactMail = &v
	return s
}

func (s *CreateExpressCloudConnectionRequest) SetContactTel(v string) *CreateExpressCloudConnectionRequest {
	s.ContactTel = &v
	return s
}

func (s *CreateExpressCloudConnectionRequest) SetDescription(v string) *CreateExpressCloudConnectionRequest {
	s.Description = &v
	return s
}

func (s *CreateExpressCloudConnectionRequest) SetIDCardNo(v string) *CreateExpressCloudConnectionRequest {
	s.IDCardNo = &v
	return s
}

func (s *CreateExpressCloudConnectionRequest) SetIdcSP(v string) *CreateExpressCloudConnectionRequest {
	s.IdcSP = &v
	return s
}

func (s *CreateExpressCloudConnectionRequest) SetName(v string) *CreateExpressCloudConnectionRequest {
	s.Name = &v
	return s
}

func (s *CreateExpressCloudConnectionRequest) SetOwnerAccount(v string) *CreateExpressCloudConnectionRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateExpressCloudConnectionRequest) SetOwnerId(v int64) *CreateExpressCloudConnectionRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateExpressCloudConnectionRequest) SetPeerCity(v string) *CreateExpressCloudConnectionRequest {
	s.PeerCity = &v
	return s
}

func (s *CreateExpressCloudConnectionRequest) SetPeerLocation(v string) *CreateExpressCloudConnectionRequest {
	s.PeerLocation = &v
	return s
}

func (s *CreateExpressCloudConnectionRequest) SetPortType(v string) *CreateExpressCloudConnectionRequest {
	s.PortType = &v
	return s
}

func (s *CreateExpressCloudConnectionRequest) SetRedundantEccId(v string) *CreateExpressCloudConnectionRequest {
	s.RedundantEccId = &v
	return s
}

func (s *CreateExpressCloudConnectionRequest) SetRegionId(v string) *CreateExpressCloudConnectionRequest {
	s.RegionId = &v
	return s
}

func (s *CreateExpressCloudConnectionRequest) SetResourceOwnerAccount(v string) *CreateExpressCloudConnectionRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateExpressCloudConnectionRequest) SetResourceOwnerId(v int64) *CreateExpressCloudConnectionRequest {
	s.ResourceOwnerId = &v
	return s
}

type CreateExpressCloudConnectionResponseBody struct {
	// The ID of the ECC instance.
	EccId *string `json:"EccId,omitempty" xml:"EccId,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateExpressCloudConnectionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateExpressCloudConnectionResponseBody) GoString() string {
	return s.String()
}

func (s *CreateExpressCloudConnectionResponseBody) SetEccId(v string) *CreateExpressCloudConnectionResponseBody {
	s.EccId = &v
	return s
}

func (s *CreateExpressCloudConnectionResponseBody) SetRequestId(v string) *CreateExpressCloudConnectionResponseBody {
	s.RequestId = &v
	return s
}

type CreateExpressCloudConnectionResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateExpressCloudConnectionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateExpressCloudConnectionResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateExpressCloudConnectionResponse) GoString() string {
	return s.String()
}

func (s *CreateExpressCloudConnectionResponse) SetHeaders(v map[string]*string) *CreateExpressCloudConnectionResponse {
	s.Headers = v
	return s
}

func (s *CreateExpressCloudConnectionResponse) SetStatusCode(v int32) *CreateExpressCloudConnectionResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateExpressCloudConnectionResponse) SetBody(v *CreateExpressCloudConnectionResponseBody) *CreateExpressCloudConnectionResponse {
	s.Body = v
	return s
}

type CreateFlowLogRequest struct {
	// The sampling interval of the flow log. Unit: seconds. Valid values: **1**, **5**, and **10** (default).
	AggregationInterval *int32 `json:"AggregationInterval,omitempty" xml:"AggregationInterval,omitempty"`
	// The description of the flow log.
	//
	// The description must be 1 to 256 characters in length and cannot start with `http://` or `https://`.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The name of the flow log.
	//
	// The name must be 1 to 128 characters in length and cannot start with `http://` or `https://`.
	FlowLogName *string `json:"FlowLogName,omitempty" xml:"FlowLogName,omitempty"`
	// The name of the Logstore that stores the captured traffic data.
	//
	// *   The name can contain only lowercase letters, digits, hyphens (-), and underscores (\_).
	// *   The name must start and end with a lowercase letter or a digit.
	// *   The name must be 3 to 63 characters in length.
	LogStoreName *string `json:"LogStoreName,omitempty" xml:"LogStoreName,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The name of the project that stores the captured traffic data.
	//
	// *   The name can contain only lowercase letters, digits, and hyphens (-).
	// *   The name must start and end with a lowercase letter or a digit.
	// *   The name must be 3 to 63 characters in length.
	ProjectName *string `json:"ProjectName,omitempty" xml:"ProjectName,omitempty"`
	// The ID of the region where you want to create the flow log. You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The ID of the resource whose traffic you want to capture.
	ResourceId           *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The type of the resource whose traffic you want to capture. Valid values:
	//
	// *   **NetworkInterface**: elastic network interface (ENI)
	// *   **VSwitch**: all ENIs in a vSwitch
	// *   **VPC**: all ENIs in a virtual private cloud (VPC)
	ResourceType *string                    `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	Tag          []*CreateFlowLogRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
	TrafficPath  []*string                  `json:"TrafficPath,omitempty" xml:"TrafficPath,omitempty" type:"Repeated"`
	// The type of traffic that you want to capture. Valid values:
	//
	// *   **All**: all traffic
	// *   **Allow**: traffic that is allowed
	// *   **Drop**: traffic that is rejected
	TrafficType *string `json:"TrafficType,omitempty" xml:"TrafficType,omitempty"`
}

func (s CreateFlowLogRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateFlowLogRequest) GoString() string {
	return s.String()
}

func (s *CreateFlowLogRequest) SetAggregationInterval(v int32) *CreateFlowLogRequest {
	s.AggregationInterval = &v
	return s
}

func (s *CreateFlowLogRequest) SetDescription(v string) *CreateFlowLogRequest {
	s.Description = &v
	return s
}

func (s *CreateFlowLogRequest) SetFlowLogName(v string) *CreateFlowLogRequest {
	s.FlowLogName = &v
	return s
}

func (s *CreateFlowLogRequest) SetLogStoreName(v string) *CreateFlowLogRequest {
	s.LogStoreName = &v
	return s
}

func (s *CreateFlowLogRequest) SetOwnerAccount(v string) *CreateFlowLogRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateFlowLogRequest) SetOwnerId(v int64) *CreateFlowLogRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateFlowLogRequest) SetProjectName(v string) *CreateFlowLogRequest {
	s.ProjectName = &v
	return s
}

func (s *CreateFlowLogRequest) SetRegionId(v string) *CreateFlowLogRequest {
	s.RegionId = &v
	return s
}

func (s *CreateFlowLogRequest) SetResourceGroupId(v string) *CreateFlowLogRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *CreateFlowLogRequest) SetResourceId(v string) *CreateFlowLogRequest {
	s.ResourceId = &v
	return s
}

func (s *CreateFlowLogRequest) SetResourceOwnerAccount(v string) *CreateFlowLogRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateFlowLogRequest) SetResourceOwnerId(v int64) *CreateFlowLogRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreateFlowLogRequest) SetResourceType(v string) *CreateFlowLogRequest {
	s.ResourceType = &v
	return s
}

func (s *CreateFlowLogRequest) SetTag(v []*CreateFlowLogRequestTag) *CreateFlowLogRequest {
	s.Tag = v
	return s
}

func (s *CreateFlowLogRequest) SetTrafficPath(v []*string) *CreateFlowLogRequest {
	s.TrafficPath = v
	return s
}

func (s *CreateFlowLogRequest) SetTrafficType(v string) *CreateFlowLogRequest {
	s.TrafficType = &v
	return s
}

type CreateFlowLogRequestTag struct {
	Key   *string `json:"Key,omitempty" xml:"Key,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateFlowLogRequestTag) String() string {
	return tea.Prettify(s)
}

func (s CreateFlowLogRequestTag) GoString() string {
	return s.String()
}

func (s *CreateFlowLogRequestTag) SetKey(v string) *CreateFlowLogRequestTag {
	s.Key = &v
	return s
}

func (s *CreateFlowLogRequestTag) SetValue(v string) *CreateFlowLogRequestTag {
	s.Value = &v
	return s
}

type CreateFlowLogResponseBody struct {
	// The ID of the flow log.
	FlowLogId *string `json:"FlowLogId,omitempty" xml:"FlowLogId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// Indicates whether the operation is successful. Valid values:
	//
	// *   **true**: yes
	// *   **false**: no
	Success *string `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateFlowLogResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateFlowLogResponseBody) GoString() string {
	return s.String()
}

func (s *CreateFlowLogResponseBody) SetFlowLogId(v string) *CreateFlowLogResponseBody {
	s.FlowLogId = &v
	return s
}

func (s *CreateFlowLogResponseBody) SetRequestId(v string) *CreateFlowLogResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateFlowLogResponseBody) SetResourceGroupId(v string) *CreateFlowLogResponseBody {
	s.ResourceGroupId = &v
	return s
}

func (s *CreateFlowLogResponseBody) SetSuccess(v string) *CreateFlowLogResponseBody {
	s.Success = &v
	return s
}

type CreateFlowLogResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateFlowLogResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateFlowLogResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateFlowLogResponse) GoString() string {
	return s.String()
}

func (s *CreateFlowLogResponse) SetHeaders(v map[string]*string) *CreateFlowLogResponse {
	s.Headers = v
	return s
}

func (s *CreateFlowLogResponse) SetStatusCode(v int32) *CreateFlowLogResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateFlowLogResponse) SetBody(v *CreateFlowLogResponseBody) *CreateFlowLogResponse {
	s.Body = v
	return s
}

type CreateForwardEntryRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, the system automatically uses **RequestId** as **ClientToken**. The value of **RequestId** in each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// *   The EIP that can be accessed over the Internet when you configure a DNAT entry for an Internet NAT gateway.
	// *   The NAT IP address that can be accessed by external networks when you configure a DNAT entry for a VPC NAT gateway.
	ExternalIp *string `json:"ExternalIp,omitempty" xml:"ExternalIp,omitempty"`
	// *   The external port range that is used for port forwarding when you configure a DNAT entry for an Internet NAT gateway.
	//
	//     *   Valid values: **1** to **65535**.
	//     *   To specify a port range, separate the first port and the last port with a forward slash (/), for example, `10/20`.
	//     *   If you set **ExternalPort** to a port range, you must also set **InternalPort** to a port range, and the number of ports specified by these parameters must be the same. For example, if you set **ExternalPort** to `10/20`, you can set **InternalPort** to `80/90`.
	//
	// *   The port that can be accessed by external networks when you configure a DNAT entry for a VPC NAT gateway. Valid values: **1** to **65535**.
	ExternalPort *string `json:"ExternalPort,omitempty" xml:"ExternalPort,omitempty"`
	// The name of the DNAT entry.
	//
	// The name must be 2 to 128 characters in length. It must start with a letter but cannot start with `http://` or `https://`.
	ForwardEntryName *string `json:"ForwardEntryName,omitempty" xml:"ForwardEntryName,omitempty"`
	// The ID of the DNAT table.
	ForwardTableId *string `json:"ForwardTableId,omitempty" xml:"ForwardTableId,omitempty"`
	// *   The private IP address of the ECS instance that needs to communicate with the Internet when you configure a DNAT entry for an Internet NAT gateway. The private IP address must meet the following requirements:
	//
	//     *   It must belong to the CIDR block of the VPC where the NAT gateway is deployed.
	//     *   The DNAT entry takes effect only if the private IP address is assigned to an ECS instance and the ECS instance is not associated with an EIP.
	//
	// *   The private IP address that uses DNAT when you add a DNAT entry to a VPC NAT gateway.
	InternalIp *string `json:"InternalIp,omitempty" xml:"InternalIp,omitempty"`
	// *   The internal port or port range that is used for port forwarding when you configure a DNAT entry for an Internet NAT gateway. Valid values: **1** to **65535**.
	// *   The port of the destination ECS instance to be mapped when you configure a DNAT entry for a VPC NAT gateway. Valid values: **1** to **65535**.
	InternalPort *string `json:"InternalPort,omitempty" xml:"InternalPort,omitempty"`
	// The protocol. Valid values:
	//
	// *   **TCP**: The NAT gateway forwards TCP packets.
	// *   **UDP**: The NAT gateway forwards UDP packets.
	// *   **Any**: The NAT gateway forwards packets of all protocols. If you set **IpProtocol** to **Any**, you must also set **ExternalPort** and **InternalPort** to **Any** to implement DNAT IP mapping.
	IpProtocol   *string `json:"IpProtocol,omitempty" xml:"IpProtocol,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// Specifies whether to remove limits on the port range. Valid values:
	//
	// *   **true**: yes
	// *   **false** (default): no
	//
	// >  If an SNAT entry and a DNAT entry use the same public IP address, and you want to specify a port number greater than 1024, set **Portbreak** to **true**.
	PortBreak *bool `json:"PortBreak,omitempty" xml:"PortBreak,omitempty"`
	// The region ID of the NAT gateway.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s CreateForwardEntryRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateForwardEntryRequest) GoString() string {
	return s.String()
}

func (s *CreateForwardEntryRequest) SetClientToken(v string) *CreateForwardEntryRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateForwardEntryRequest) SetExternalIp(v string) *CreateForwardEntryRequest {
	s.ExternalIp = &v
	return s
}

func (s *CreateForwardEntryRequest) SetExternalPort(v string) *CreateForwardEntryRequest {
	s.ExternalPort = &v
	return s
}

func (s *CreateForwardEntryRequest) SetForwardEntryName(v string) *CreateForwardEntryRequest {
	s.ForwardEntryName = &v
	return s
}

func (s *CreateForwardEntryRequest) SetForwardTableId(v string) *CreateForwardEntryRequest {
	s.ForwardTableId = &v
	return s
}

func (s *CreateForwardEntryRequest) SetInternalIp(v string) *CreateForwardEntryRequest {
	s.InternalIp = &v
	return s
}

func (s *CreateForwardEntryRequest) SetInternalPort(v string) *CreateForwardEntryRequest {
	s.InternalPort = &v
	return s
}

func (s *CreateForwardEntryRequest) SetIpProtocol(v string) *CreateForwardEntryRequest {
	s.IpProtocol = &v
	return s
}

func (s *CreateForwardEntryRequest) SetOwnerAccount(v string) *CreateForwardEntryRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateForwardEntryRequest) SetOwnerId(v int64) *CreateForwardEntryRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateForwardEntryRequest) SetPortBreak(v bool) *CreateForwardEntryRequest {
	s.PortBreak = &v
	return s
}

func (s *CreateForwardEntryRequest) SetRegionId(v string) *CreateForwardEntryRequest {
	s.RegionId = &v
	return s
}

func (s *CreateForwardEntryRequest) SetResourceOwnerAccount(v string) *CreateForwardEntryRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateForwardEntryRequest) SetResourceOwnerId(v int64) *CreateForwardEntryRequest {
	s.ResourceOwnerId = &v
	return s
}

type CreateForwardEntryResponseBody struct {
	// The ID of the DNAT entry.
	ForwardEntryId *string `json:"ForwardEntryId,omitempty" xml:"ForwardEntryId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateForwardEntryResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateForwardEntryResponseBody) GoString() string {
	return s.String()
}

func (s *CreateForwardEntryResponseBody) SetForwardEntryId(v string) *CreateForwardEntryResponseBody {
	s.ForwardEntryId = &v
	return s
}

func (s *CreateForwardEntryResponseBody) SetRequestId(v string) *CreateForwardEntryResponseBody {
	s.RequestId = &v
	return s
}

type CreateForwardEntryResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateForwardEntryResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateForwardEntryResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateForwardEntryResponse) GoString() string {
	return s.String()
}

func (s *CreateForwardEntryResponse) SetHeaders(v map[string]*string) *CreateForwardEntryResponse {
	s.Headers = v
	return s
}

func (s *CreateForwardEntryResponse) SetStatusCode(v int32) *CreateForwardEntryResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateForwardEntryResponse) SetBody(v *CreateForwardEntryResponseBody) *CreateForwardEntryResponse {
	s.Body = v
	return s
}

type CreateFullNatEntryRequest struct {
	// The backend IP address to be modified in FULLNAT address translation.
	AccessIp *string `json:"AccessIp,omitempty" xml:"AccessIp,omitempty"`
	// The backend port to be modified in FULLNAT port mapping. Valid values: **1** to **65535**.
	AccessPort *string `json:"AccessPort,omitempty" xml:"AccessPort,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether only to precheck this request. Valid values:
	//
	// *   **true**: prechecks the request but does not add the FULLNAT entry. The system checks your AccessKey pair, the RAM user permissions, and the required parameters. If the request fails the precheck, an error code is returned. If the request passes the check, the `DryRunOperation` error code is returned.
	// *   **false**: sends the API request. After the request passes the precheck, a 2XX HTTP status code is returned and the FULLNAT entry is added. This is the default value.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The description of the FULLNAT entry.
	//
	// This parameter is optional. If you enter a description, the description must be 2 to 256 characters in length, and cannot start with `http://` or `https://`.
	FullNatEntryDescription *string `json:"FullNatEntryDescription,omitempty" xml:"FullNatEntryDescription,omitempty"`
	// The name of the FULLNAT entry. The name must be 2 to 128 characters in length. It must start with a letter but cannot start with http:// or https://.
	FullNatEntryName *string `json:"FullNatEntryName,omitempty" xml:"FullNatEntryName,omitempty"`
	// The ID of the FULLNAT table to which the FULLNAT entry belongs.
	FullNatTableId *string `json:"FullNatTableId,omitempty" xml:"FullNatTableId,omitempty"`
	// The protocol of the packets that are forwarded by the port. Valid values:
	//
	// *   **TCP**: forwards TCP packets.
	// *   **UDP**: forwards UDP packets.
	IpProtocol *string `json:"IpProtocol,omitempty" xml:"IpProtocol,omitempty"`
	// The NAT IP address that provides address translation.
	NatIp *string `json:"NatIp,omitempty" xml:"NatIp,omitempty"`
	// The frontend port to be modified in FULLNAT port mapping. Valid values: **1** to **65535**.
	NatIpPort *string `json:"NatIpPort,omitempty" xml:"NatIpPort,omitempty"`
	// The ID of the elastic network interface (ENI).
	NetworkInterfaceId *string `json:"NetworkInterfaceId,omitempty" xml:"NetworkInterfaceId,omitempty"`
	OwnerAccount       *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId            *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the Virtual Private Cloud (VPC) NAT gateway to which the FULLNAT entry to be added belongs.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s CreateFullNatEntryRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateFullNatEntryRequest) GoString() string {
	return s.String()
}

func (s *CreateFullNatEntryRequest) SetAccessIp(v string) *CreateFullNatEntryRequest {
	s.AccessIp = &v
	return s
}

func (s *CreateFullNatEntryRequest) SetAccessPort(v string) *CreateFullNatEntryRequest {
	s.AccessPort = &v
	return s
}

func (s *CreateFullNatEntryRequest) SetClientToken(v string) *CreateFullNatEntryRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateFullNatEntryRequest) SetDryRun(v bool) *CreateFullNatEntryRequest {
	s.DryRun = &v
	return s
}

func (s *CreateFullNatEntryRequest) SetFullNatEntryDescription(v string) *CreateFullNatEntryRequest {
	s.FullNatEntryDescription = &v
	return s
}

func (s *CreateFullNatEntryRequest) SetFullNatEntryName(v string) *CreateFullNatEntryRequest {
	s.FullNatEntryName = &v
	return s
}

func (s *CreateFullNatEntryRequest) SetFullNatTableId(v string) *CreateFullNatEntryRequest {
	s.FullNatTableId = &v
	return s
}

func (s *CreateFullNatEntryRequest) SetIpProtocol(v string) *CreateFullNatEntryRequest {
	s.IpProtocol = &v
	return s
}

func (s *CreateFullNatEntryRequest) SetNatIp(v string) *CreateFullNatEntryRequest {
	s.NatIp = &v
	return s
}

func (s *CreateFullNatEntryRequest) SetNatIpPort(v string) *CreateFullNatEntryRequest {
	s.NatIpPort = &v
	return s
}

func (s *CreateFullNatEntryRequest) SetNetworkInterfaceId(v string) *CreateFullNatEntryRequest {
	s.NetworkInterfaceId = &v
	return s
}

func (s *CreateFullNatEntryRequest) SetOwnerAccount(v string) *CreateFullNatEntryRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateFullNatEntryRequest) SetOwnerId(v int64) *CreateFullNatEntryRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateFullNatEntryRequest) SetRegionId(v string) *CreateFullNatEntryRequest {
	s.RegionId = &v
	return s
}

func (s *CreateFullNatEntryRequest) SetResourceOwnerAccount(v string) *CreateFullNatEntryRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateFullNatEntryRequest) SetResourceOwnerId(v int64) *CreateFullNatEntryRequest {
	s.ResourceOwnerId = &v
	return s
}

type CreateFullNatEntryResponseBody struct {
	// The ID of the FULLNAT entry.
	FullNatEntryId *string `json:"FullNatEntryId,omitempty" xml:"FullNatEntryId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateFullNatEntryResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateFullNatEntryResponseBody) GoString() string {
	return s.String()
}

func (s *CreateFullNatEntryResponseBody) SetFullNatEntryId(v string) *CreateFullNatEntryResponseBody {
	s.FullNatEntryId = &v
	return s
}

func (s *CreateFullNatEntryResponseBody) SetRequestId(v string) *CreateFullNatEntryResponseBody {
	s.RequestId = &v
	return s
}

type CreateFullNatEntryResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateFullNatEntryResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateFullNatEntryResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateFullNatEntryResponse) GoString() string {
	return s.String()
}

func (s *CreateFullNatEntryResponse) SetHeaders(v map[string]*string) *CreateFullNatEntryResponse {
	s.Headers = v
	return s
}

func (s *CreateFullNatEntryResponse) SetStatusCode(v int32) *CreateFullNatEntryResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateFullNatEntryResponse) SetBody(v *CreateFullNatEntryResponseBody) *CreateFullNatEntryResponse {
	s.Body = v
	return s
}

type CreateGlobalAccelerationInstanceRequest struct {
	// The maximum bandwidth of the GA instance. Set the value to **10**. Unit: Mbit/s.
	Bandwidth *string `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	// The bandwidth type. Valid values:
	//
	// *   **Sharing**
	// *   **Exclusive**
	BandwidthType *string `json:"BandwidthType,omitempty" xml:"BandwidthType,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The description of the GA instance.
	//
	// The description must be 2 to 256 characters in length. It must start with a letter but cannot start with `http://` or `https://`.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The name of the GA instance.
	//
	// The name must be 2 to 128 characters in length and can contain letters, digits, periods (.), underscores (\_), and hyphens (-). It must start with a letter and cannot start with `http://` or `https://`.
	Name         *string `json:"Name,omitempty" xml:"Name,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the GA instance.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The acceleration area. Valid values:
	//
	// *   **china-mainland**
	// *   **north-america**
	// *   **asia-pacific**
	// *   **europe**
	ServiceLocation *string `json:"ServiceLocation,omitempty" xml:"ServiceLocation,omitempty"`
}

func (s CreateGlobalAccelerationInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateGlobalAccelerationInstanceRequest) GoString() string {
	return s.String()
}

func (s *CreateGlobalAccelerationInstanceRequest) SetBandwidth(v string) *CreateGlobalAccelerationInstanceRequest {
	s.Bandwidth = &v
	return s
}

func (s *CreateGlobalAccelerationInstanceRequest) SetBandwidthType(v string) *CreateGlobalAccelerationInstanceRequest {
	s.BandwidthType = &v
	return s
}

func (s *CreateGlobalAccelerationInstanceRequest) SetClientToken(v string) *CreateGlobalAccelerationInstanceRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateGlobalAccelerationInstanceRequest) SetDescription(v string) *CreateGlobalAccelerationInstanceRequest {
	s.Description = &v
	return s
}

func (s *CreateGlobalAccelerationInstanceRequest) SetName(v string) *CreateGlobalAccelerationInstanceRequest {
	s.Name = &v
	return s
}

func (s *CreateGlobalAccelerationInstanceRequest) SetOwnerAccount(v string) *CreateGlobalAccelerationInstanceRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateGlobalAccelerationInstanceRequest) SetOwnerId(v int64) *CreateGlobalAccelerationInstanceRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateGlobalAccelerationInstanceRequest) SetRegionId(v string) *CreateGlobalAccelerationInstanceRequest {
	s.RegionId = &v
	return s
}

func (s *CreateGlobalAccelerationInstanceRequest) SetResourceOwnerAccount(v string) *CreateGlobalAccelerationInstanceRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateGlobalAccelerationInstanceRequest) SetResourceOwnerId(v int64) *CreateGlobalAccelerationInstanceRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreateGlobalAccelerationInstanceRequest) SetServiceLocation(v string) *CreateGlobalAccelerationInstanceRequest {
	s.ServiceLocation = &v
	return s
}

type CreateGlobalAccelerationInstanceResponseBody struct {
	// The ID of the GA instance.
	GlobalAccelerationInstanceId *string `json:"GlobalAccelerationInstanceId,omitempty" xml:"GlobalAccelerationInstanceId,omitempty"`
	// The public IP address of the GA instance.
	//
	// If **BandwidthType** is set to **Sharing**, this parameter is not returned.
	IpAddress *string `json:"IpAddress,omitempty" xml:"IpAddress,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateGlobalAccelerationInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateGlobalAccelerationInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *CreateGlobalAccelerationInstanceResponseBody) SetGlobalAccelerationInstanceId(v string) *CreateGlobalAccelerationInstanceResponseBody {
	s.GlobalAccelerationInstanceId = &v
	return s
}

func (s *CreateGlobalAccelerationInstanceResponseBody) SetIpAddress(v string) *CreateGlobalAccelerationInstanceResponseBody {
	s.IpAddress = &v
	return s
}

func (s *CreateGlobalAccelerationInstanceResponseBody) SetRequestId(v string) *CreateGlobalAccelerationInstanceResponseBody {
	s.RequestId = &v
	return s
}

type CreateGlobalAccelerationInstanceResponse struct {
	Headers    map[string]*string                            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateGlobalAccelerationInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateGlobalAccelerationInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateGlobalAccelerationInstanceResponse) GoString() string {
	return s.String()
}

func (s *CreateGlobalAccelerationInstanceResponse) SetHeaders(v map[string]*string) *CreateGlobalAccelerationInstanceResponse {
	s.Headers = v
	return s
}

func (s *CreateGlobalAccelerationInstanceResponse) SetStatusCode(v int32) *CreateGlobalAccelerationInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateGlobalAccelerationInstanceResponse) SetBody(v *CreateGlobalAccelerationInstanceResponseBody) *CreateGlobalAccelerationInstanceResponse {
	s.Body = v
	return s
}

type CreateHaVipRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that the value is unique among all requests. The token can contain only ASCII characters.
	//
	// >  If you do not specify this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The description of the HAVIP.
	//
	// The description must be 1 to 256 characters in length and cannot start with `http://` or `https://`.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The IP address of the HAVIP.
	//
	// The specified IP address must be an idle IP address that falls within the CIDR block of the vSwitch. If this parameter is not set, an idle IP address from the CIDR block of the vSwitch is randomly assigned to the HAVIP.
	IpAddress *string `json:"IpAddress,omitempty" xml:"IpAddress,omitempty"`
	// The name of the HAVIP.
	//
	// The name must be 1 to 128 characters in length, and cannot start with `http://` or `https://`.
	Name         *string `json:"Name,omitempty" xml:"Name,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the HAVIP. You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group to which the HAVIP belongs.
	ResourceGroupId      *string                  `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string                  `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64                   `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	Tag                  []*CreateHaVipRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
	// The ID of the vSwitch to which the HAVIP belongs.
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
}

func (s CreateHaVipRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateHaVipRequest) GoString() string {
	return s.String()
}

func (s *CreateHaVipRequest) SetClientToken(v string) *CreateHaVipRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateHaVipRequest) SetDescription(v string) *CreateHaVipRequest {
	s.Description = &v
	return s
}

func (s *CreateHaVipRequest) SetIpAddress(v string) *CreateHaVipRequest {
	s.IpAddress = &v
	return s
}

func (s *CreateHaVipRequest) SetName(v string) *CreateHaVipRequest {
	s.Name = &v
	return s
}

func (s *CreateHaVipRequest) SetOwnerAccount(v string) *CreateHaVipRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateHaVipRequest) SetOwnerId(v int64) *CreateHaVipRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateHaVipRequest) SetRegionId(v string) *CreateHaVipRequest {
	s.RegionId = &v
	return s
}

func (s *CreateHaVipRequest) SetResourceGroupId(v string) *CreateHaVipRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *CreateHaVipRequest) SetResourceOwnerAccount(v string) *CreateHaVipRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateHaVipRequest) SetResourceOwnerId(v int64) *CreateHaVipRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreateHaVipRequest) SetTag(v []*CreateHaVipRequestTag) *CreateHaVipRequest {
	s.Tag = v
	return s
}

func (s *CreateHaVipRequest) SetVSwitchId(v string) *CreateHaVipRequest {
	s.VSwitchId = &v
	return s
}

type CreateHaVipRequestTag struct {
	Key   *string `json:"Key,omitempty" xml:"Key,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateHaVipRequestTag) String() string {
	return tea.Prettify(s)
}

func (s CreateHaVipRequestTag) GoString() string {
	return s.String()
}

func (s *CreateHaVipRequestTag) SetKey(v string) *CreateHaVipRequestTag {
	s.Key = &v
	return s
}

func (s *CreateHaVipRequestTag) SetValue(v string) *CreateHaVipRequestTag {
	s.Value = &v
	return s
}

type CreateHaVipResponseBody struct {
	// The ID of the HAVIP.
	HaVipId *string `json:"HaVipId,omitempty" xml:"HaVipId,omitempty"`
	// The IP address of the HAVIP.
	IpAddress *string `json:"IpAddress,omitempty" xml:"IpAddress,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateHaVipResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateHaVipResponseBody) GoString() string {
	return s.String()
}

func (s *CreateHaVipResponseBody) SetHaVipId(v string) *CreateHaVipResponseBody {
	s.HaVipId = &v
	return s
}

func (s *CreateHaVipResponseBody) SetIpAddress(v string) *CreateHaVipResponseBody {
	s.IpAddress = &v
	return s
}

func (s *CreateHaVipResponseBody) SetRequestId(v string) *CreateHaVipResponseBody {
	s.RequestId = &v
	return s
}

type CreateHaVipResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateHaVipResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateHaVipResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateHaVipResponse) GoString() string {
	return s.String()
}

func (s *CreateHaVipResponse) SetHeaders(v map[string]*string) *CreateHaVipResponse {
	s.Headers = v
	return s
}

func (s *CreateHaVipResponse) SetStatusCode(v int32) *CreateHaVipResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateHaVipResponse) SetBody(v *CreateHaVipResponseBody) *CreateHaVipResponse {
	s.Body = v
	return s
}

type CreateIPv6TranslatorRequest struct {
	// Specifies whether to enable automatic payment. Valid values: **true and false**.
	AutoPay *bool `json:"AutoPay,omitempty" xml:"AutoPay,omitempty"`
	// The bandwidth of the IPv6 Translation Service instance. Unit: Mbit/s. Valid values: **1** to **200**. If you do not specify the bandwidth for the mapping entry, the bandwidth is shared with the mapping entry.
	//
	// > If you do not specify this parameter, the default bandwidth is 10 Mbit/s.
	Bandwidth *int32 `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The subscription duration.
	//
	// *   If the billing cycle is **Month**, valid values are **1** to **9**.
	// *   If the billing cycle is **Year**, set the value to **3**.
	Duration *int32 `json:"Duration,omitempty" xml:"Duration,omitempty"`
	// The name of the IPv6 Translation Service instance. The default name is the instance ID. It must be 2 to 100 characters in length and must start with a letter. It can contain letters, digits, periods (.), underscores (\_), and hyphens (-). It cannot start with `http://` or `https://`.
	Name         *string `json:"Name,omitempty" xml:"Name,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The billing method of the IPv6 Translation Service instance. Valid values:
	//
	// *   **PREPAY**: subscription
	// *   **POSTPAY**: pay-as-you-go
	PayType *string `json:"PayType,omitempty" xml:"PayType,omitempty"`
	// The billing cycle of the subscription. Valid values:
	//
	// *   **Month** (default)
	// *   **Year**
	PricingCycle *string `json:"PricingCycle,omitempty" xml:"PricingCycle,omitempty"`
	// The region of the IPv6 Translation Service instance. You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The specification of the IPv6 Translation Service instance. Set the value to **small**.
	Spec *string `json:"Spec,omitempty" xml:"Spec,omitempty"`
}

func (s CreateIPv6TranslatorRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateIPv6TranslatorRequest) GoString() string {
	return s.String()
}

func (s *CreateIPv6TranslatorRequest) SetAutoPay(v bool) *CreateIPv6TranslatorRequest {
	s.AutoPay = &v
	return s
}

func (s *CreateIPv6TranslatorRequest) SetBandwidth(v int32) *CreateIPv6TranslatorRequest {
	s.Bandwidth = &v
	return s
}

func (s *CreateIPv6TranslatorRequest) SetClientToken(v string) *CreateIPv6TranslatorRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateIPv6TranslatorRequest) SetDuration(v int32) *CreateIPv6TranslatorRequest {
	s.Duration = &v
	return s
}

func (s *CreateIPv6TranslatorRequest) SetName(v string) *CreateIPv6TranslatorRequest {
	s.Name = &v
	return s
}

func (s *CreateIPv6TranslatorRequest) SetOwnerAccount(v string) *CreateIPv6TranslatorRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateIPv6TranslatorRequest) SetOwnerId(v int64) *CreateIPv6TranslatorRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateIPv6TranslatorRequest) SetPayType(v string) *CreateIPv6TranslatorRequest {
	s.PayType = &v
	return s
}

func (s *CreateIPv6TranslatorRequest) SetPricingCycle(v string) *CreateIPv6TranslatorRequest {
	s.PricingCycle = &v
	return s
}

func (s *CreateIPv6TranslatorRequest) SetRegionId(v string) *CreateIPv6TranslatorRequest {
	s.RegionId = &v
	return s
}

func (s *CreateIPv6TranslatorRequest) SetResourceOwnerAccount(v string) *CreateIPv6TranslatorRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateIPv6TranslatorRequest) SetResourceOwnerId(v int64) *CreateIPv6TranslatorRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreateIPv6TranslatorRequest) SetSpec(v string) *CreateIPv6TranslatorRequest {
	s.Spec = &v
	return s
}

type CreateIPv6TranslatorResponseBody struct {
	// The ID of the IPv6 Translation Service instance.
	Ipv6TranslatorId *string `json:"Ipv6TranslatorId,omitempty" xml:"Ipv6TranslatorId,omitempty"`
	// The name of the IPv6 Translation Service instance.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The order ID.
	OrderId *int64 `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The specification of the IPv6 Translation Service instance.
	Spec *string `json:"Spec,omitempty" xml:"Spec,omitempty"`
}

func (s CreateIPv6TranslatorResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateIPv6TranslatorResponseBody) GoString() string {
	return s.String()
}

func (s *CreateIPv6TranslatorResponseBody) SetIpv6TranslatorId(v string) *CreateIPv6TranslatorResponseBody {
	s.Ipv6TranslatorId = &v
	return s
}

func (s *CreateIPv6TranslatorResponseBody) SetName(v string) *CreateIPv6TranslatorResponseBody {
	s.Name = &v
	return s
}

func (s *CreateIPv6TranslatorResponseBody) SetOrderId(v int64) *CreateIPv6TranslatorResponseBody {
	s.OrderId = &v
	return s
}

func (s *CreateIPv6TranslatorResponseBody) SetRequestId(v string) *CreateIPv6TranslatorResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateIPv6TranslatorResponseBody) SetSpec(v string) *CreateIPv6TranslatorResponseBody {
	s.Spec = &v
	return s
}

type CreateIPv6TranslatorResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateIPv6TranslatorResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateIPv6TranslatorResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateIPv6TranslatorResponse) GoString() string {
	return s.String()
}

func (s *CreateIPv6TranslatorResponse) SetHeaders(v map[string]*string) *CreateIPv6TranslatorResponse {
	s.Headers = v
	return s
}

func (s *CreateIPv6TranslatorResponse) SetStatusCode(v int32) *CreateIPv6TranslatorResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateIPv6TranslatorResponse) SetBody(v *CreateIPv6TranslatorResponseBody) *CreateIPv6TranslatorResponse {
	s.Body = v
	return s
}

type CreateIPv6TranslatorAclListRequest struct {
	// The ACL name.
	AclName      *string `json:"AclName,omitempty" xml:"AclName,omitempty"`
	ClientToken  *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region of the IPv6 Translation Service instance. You can call the DescribeRegions operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s CreateIPv6TranslatorAclListRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateIPv6TranslatorAclListRequest) GoString() string {
	return s.String()
}

func (s *CreateIPv6TranslatorAclListRequest) SetAclName(v string) *CreateIPv6TranslatorAclListRequest {
	s.AclName = &v
	return s
}

func (s *CreateIPv6TranslatorAclListRequest) SetClientToken(v string) *CreateIPv6TranslatorAclListRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateIPv6TranslatorAclListRequest) SetOwnerAccount(v string) *CreateIPv6TranslatorAclListRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateIPv6TranslatorAclListRequest) SetOwnerId(v int64) *CreateIPv6TranslatorAclListRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateIPv6TranslatorAclListRequest) SetRegionId(v string) *CreateIPv6TranslatorAclListRequest {
	s.RegionId = &v
	return s
}

func (s *CreateIPv6TranslatorAclListRequest) SetResourceOwnerAccount(v string) *CreateIPv6TranslatorAclListRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateIPv6TranslatorAclListRequest) SetResourceOwnerId(v int64) *CreateIPv6TranslatorAclListRequest {
	s.ResourceOwnerId = &v
	return s
}

type CreateIPv6TranslatorAclListResponseBody struct {
	// The ACL ID.
	AclId *string `json:"AclId,omitempty" xml:"AclId,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateIPv6TranslatorAclListResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateIPv6TranslatorAclListResponseBody) GoString() string {
	return s.String()
}

func (s *CreateIPv6TranslatorAclListResponseBody) SetAclId(v string) *CreateIPv6TranslatorAclListResponseBody {
	s.AclId = &v
	return s
}

func (s *CreateIPv6TranslatorAclListResponseBody) SetRequestId(v string) *CreateIPv6TranslatorAclListResponseBody {
	s.RequestId = &v
	return s
}

type CreateIPv6TranslatorAclListResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateIPv6TranslatorAclListResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateIPv6TranslatorAclListResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateIPv6TranslatorAclListResponse) GoString() string {
	return s.String()
}

func (s *CreateIPv6TranslatorAclListResponse) SetHeaders(v map[string]*string) *CreateIPv6TranslatorAclListResponse {
	s.Headers = v
	return s
}

func (s *CreateIPv6TranslatorAclListResponse) SetStatusCode(v int32) *CreateIPv6TranslatorAclListResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateIPv6TranslatorAclListResponse) SetBody(v *CreateIPv6TranslatorAclListResponseBody) *CreateIPv6TranslatorAclListResponse {
	s.Body = v
	return s
}

type CreateIPv6TranslatorEntryRequest struct {
	// The ID of the associated ACL.
	AclId *string `json:"AclId,omitempty" xml:"AclId,omitempty"`
	// Specifies whether to enable access control lists (ACLs). Valid values:
	//
	// *   **on**
	// *   **off**
	AclStatus *string `json:"AclStatus,omitempty" xml:"AclStatus,omitempty"`
	// Specifies whether to enable ACLs. Valid values:
	//
	// *   **white**: a whitelist. IPv6 addresses in the ACL are allowed to access backend services.
	// *   **black**: a blacklist. IPv6 addresses in the ACL are not allowed to access backend services.
	AclType *string `json:"AclType,omitempty" xml:"AclType,omitempty"`
	// The port that is used by the IPv6 address allocated to the IPv6 Translation Service instance.
	AllocateIpv6Port *int32 `json:"AllocateIpv6Port,omitempty" xml:"AllocateIpv6Port,omitempty"`
	// The public IPv4 address that needs to provide IPv6 services.
	BackendIpv4Addr *string `json:"BackendIpv4Addr,omitempty" xml:"BackendIpv4Addr,omitempty"`
	// The port of the public IPv4 address that needs to provide IPv6 services.
	BackendIpv4Port *int32 `json:"BackendIpv4Port,omitempty" xml:"BackendIpv4Port,omitempty"`
	// The maximum bandwidth specified in the IPv6 mapping entry. Valid values:
	//
	// *   \-1 (default): does not limit the maximum bandwidth specified in the IPv6 mapping entry.
	// *   1 to 200: the bandwidth value specified in the IPv6 mapping entry. Unit: Mbit/s.
	//
	// > The sum of the maximum bandwidth values specified in all IPv6 entries cannot exceed the maximum bandwidth supported by the instance.
	EntryBandwidth *int32 `json:"EntryBandwidth,omitempty" xml:"EntryBandwidth,omitempty"`
	// The description of the IPv6 mapping entry.
	EntryDescription *string `json:"EntryDescription,omitempty" xml:"EntryDescription,omitempty"`
	// The name of the IPv6 mapping entry. It must be 2 to 100 characters in length and can contain letters, digits, periods (.), underscores (\_), and hyphens (-). It must start with a letter. It cannot start with `http://` or `https://`.
	EntryName *string `json:"EntryName,omitempty" xml:"EntryName,omitempty"`
	// The ID of the IPv6 Translation Service instance.
	Ipv6TranslatorId *string `json:"Ipv6TranslatorId,omitempty" xml:"Ipv6TranslatorId,omitempty"`
	OwnerAccount     *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId          *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region of the IPv6 Translation Service instance. You can call the **DescribeRegions** operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The protocol. Valid values:
	//
	// *   **tcp**
	// *   **udp**
	TransProtocol *string `json:"TransProtocol,omitempty" xml:"TransProtocol,omitempty"`
}

func (s CreateIPv6TranslatorEntryRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateIPv6TranslatorEntryRequest) GoString() string {
	return s.String()
}

func (s *CreateIPv6TranslatorEntryRequest) SetAclId(v string) *CreateIPv6TranslatorEntryRequest {
	s.AclId = &v
	return s
}

func (s *CreateIPv6TranslatorEntryRequest) SetAclStatus(v string) *CreateIPv6TranslatorEntryRequest {
	s.AclStatus = &v
	return s
}

func (s *CreateIPv6TranslatorEntryRequest) SetAclType(v string) *CreateIPv6TranslatorEntryRequest {
	s.AclType = &v
	return s
}

func (s *CreateIPv6TranslatorEntryRequest) SetAllocateIpv6Port(v int32) *CreateIPv6TranslatorEntryRequest {
	s.AllocateIpv6Port = &v
	return s
}

func (s *CreateIPv6TranslatorEntryRequest) SetBackendIpv4Addr(v string) *CreateIPv6TranslatorEntryRequest {
	s.BackendIpv4Addr = &v
	return s
}

func (s *CreateIPv6TranslatorEntryRequest) SetBackendIpv4Port(v int32) *CreateIPv6TranslatorEntryRequest {
	s.BackendIpv4Port = &v
	return s
}

func (s *CreateIPv6TranslatorEntryRequest) SetEntryBandwidth(v int32) *CreateIPv6TranslatorEntryRequest {
	s.EntryBandwidth = &v
	return s
}

func (s *CreateIPv6TranslatorEntryRequest) SetEntryDescription(v string) *CreateIPv6TranslatorEntryRequest {
	s.EntryDescription = &v
	return s
}

func (s *CreateIPv6TranslatorEntryRequest) SetEntryName(v string) *CreateIPv6TranslatorEntryRequest {
	s.EntryName = &v
	return s
}

func (s *CreateIPv6TranslatorEntryRequest) SetIpv6TranslatorId(v string) *CreateIPv6TranslatorEntryRequest {
	s.Ipv6TranslatorId = &v
	return s
}

func (s *CreateIPv6TranslatorEntryRequest) SetOwnerAccount(v string) *CreateIPv6TranslatorEntryRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateIPv6TranslatorEntryRequest) SetOwnerId(v int64) *CreateIPv6TranslatorEntryRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateIPv6TranslatorEntryRequest) SetRegionId(v string) *CreateIPv6TranslatorEntryRequest {
	s.RegionId = &v
	return s
}

func (s *CreateIPv6TranslatorEntryRequest) SetResourceOwnerAccount(v string) *CreateIPv6TranslatorEntryRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateIPv6TranslatorEntryRequest) SetResourceOwnerId(v int64) *CreateIPv6TranslatorEntryRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreateIPv6TranslatorEntryRequest) SetTransProtocol(v string) *CreateIPv6TranslatorEntryRequest {
	s.TransProtocol = &v
	return s
}

type CreateIPv6TranslatorEntryResponseBody struct {
	// The ID of the IPv6 Translation Service instance.
	Ipv6TranslatorEntryId *string `json:"Ipv6TranslatorEntryId,omitempty" xml:"Ipv6TranslatorEntryId,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateIPv6TranslatorEntryResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateIPv6TranslatorEntryResponseBody) GoString() string {
	return s.String()
}

func (s *CreateIPv6TranslatorEntryResponseBody) SetIpv6TranslatorEntryId(v string) *CreateIPv6TranslatorEntryResponseBody {
	s.Ipv6TranslatorEntryId = &v
	return s
}

func (s *CreateIPv6TranslatorEntryResponseBody) SetRequestId(v string) *CreateIPv6TranslatorEntryResponseBody {
	s.RequestId = &v
	return s
}

type CreateIPv6TranslatorEntryResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateIPv6TranslatorEntryResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateIPv6TranslatorEntryResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateIPv6TranslatorEntryResponse) GoString() string {
	return s.String()
}

func (s *CreateIPv6TranslatorEntryResponse) SetHeaders(v map[string]*string) *CreateIPv6TranslatorEntryResponse {
	s.Headers = v
	return s
}

func (s *CreateIPv6TranslatorEntryResponse) SetStatusCode(v int32) *CreateIPv6TranslatorEntryResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateIPv6TranslatorEntryResponse) SetBody(v *CreateIPv6TranslatorEntryResponseBody) *CreateIPv6TranslatorEntryResponse {
	s.Body = v
	return s
}

type CreateIpsecServerRequest struct {
	// The client CIDR block. It refers to the CIDR block that is used to allocate an IP address to the client.
	//
	// >  The client CIDR block must not overlap with the CIDR block of the virtual private cloud (VPC).
	ClientIpPool *string `json:"ClientIpPool,omitempty" xml:"ClientIpPool,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. ClientToken can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to check the request without performing the operation. Valid values:
	//
	// *   **true**: only prechecks the request. After the request passes the precheck, the system does not create the IPsec server. The system checks the required parameters, the request format, and the service limits. If the request fails the precheck, an error code is returned. If the request passes the precheck, the `DryRunOperation` error code is returned.
	// *   **false** (default): prechecks the request. After the request passes the precheck, the system creates the IPsec server.
	DryRun *string `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// Specifies whether you want the configuration to immediately take effect. Valid values:
	//
	// *   **true**: initiates negotiations after the configuration is completed.
	// *   **false** (default): initiates negotiations when inbound traffic is detected.
	EffectImmediately *bool `json:"EffectImmediately,omitempty" xml:"EffectImmediately,omitempty"`
	// The configuration of Phase 1 negotiations. Valid values:
	//
	// *   **IkeVersion**: the IKE version. Valid values: **ikev1** and **ikev2**. Default value: **ikev2**.
	// *   **IkeMode**: the IKE negotiation mode. Default value: **main**.
	// *   **IkeEncAlg**: the encryption algorithm that is used in Phase 1 negotiations. Default value: **aes**.
	// *   **IkeAuthAlg**: the authentication algorithm that is used in Phase 1 negotiations. Default value: **sha1**.
	// *   **IkePfs**: the Diffie-Hellman key exchange algorithm that is used in Phase 1 negotiations. Default value: **group2**.
	// *   **IkeLifetime**: the security association (SA) lifetime determined by Phase 1 negotiations. Unit: seconds. Valid values: **0** to **86400**. Default value: **86400**.
	// *   **LocalId**: the identifier of the IPsec server. The value can be a fully qualified domain name (FQDN) or an IP address. The default value is the public IP address of the VPN gateway.
	// *   **RemoteId**: the identifier of the peer. The value can be an FQDN or an IP address. By default, this parameter is not specified.
	IkeConfig *string `json:"IkeConfig,omitempty" xml:"IkeConfig,omitempty"`
	// The name of the IPsec server.
	//
	// The name must be 1 to 100 characters in length and cannot start with `http://` or `https://`.
	IpSecServerName *string `json:"IpSecServerName,omitempty" xml:"IpSecServerName,omitempty"`
	// The configuration of Phase 2 negotiations. Valid values:
	//
	// *   **IpsecEncAlg**: the encryption algorithm that is used in Phase 2 negotiations. Default value: **aes**.
	// *   **IpsecAuthAlg**: the authentication algorithm that is used in Phase 2 negotiations. Default value: **sha1**.
	// *   **IpsecPfs**: forwards packets of all protocols. The Diffie-Hellman key exchange algorithm used in Phase 2 negotiations. Default value: **group2**.
	// *   **IpsecLifetime**: the SA lifetime determined by Phase 2 negotiations. Unit: seconds. Valid values: **0** to **86400**. Default value: **86400**.
	IpsecConfig *string `json:"IpsecConfig,omitempty" xml:"IpsecConfig,omitempty"`
	// The local CIDR blocks, which refer to the CIDR blocks on the virtual private cloud (VPC) side.
	//
	// Separate multiple CIDR blocks with commas (,). Example: 192.168.1.0/24,192.168.2.0/24.
	LocalSubnet *string `json:"LocalSubnet,omitempty" xml:"LocalSubnet,omitempty"`
	// The pre-shared key.
	//
	// The pre-shared key is used for identity authentication between the IPsec server and the client. The key must be 1 to 100 characters in length.
	//
	// If you do not specify a pre-shared key, the system randomly generates a 16-character string as the pre-shared key. You can call the [ListIpsecServers](~~205453~~) operation to query the pre-shared keys that are generated by the system.
	//
	// >  The pre-shared key of the IPsec server must be the same as the authentication key of the client. Otherwise, a connection cannot be established between the IPsec server and the client.
	Psk *string `json:"Psk,omitempty" xml:"Psk,omitempty"`
	// Specifies whether to enable pre-shared key authentication. If you set the value to **true**, pre-shared key authentication is enabled.
	PskEnabled *bool `json:"PskEnabled,omitempty" xml:"PskEnabled,omitempty"`
	// The ID of the region where the VPN gateway is deployed.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the VPN gateway.
	VpnGatewayId *string `json:"VpnGatewayId,omitempty" xml:"VpnGatewayId,omitempty"`
}

func (s CreateIpsecServerRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateIpsecServerRequest) GoString() string {
	return s.String()
}

func (s *CreateIpsecServerRequest) SetClientIpPool(v string) *CreateIpsecServerRequest {
	s.ClientIpPool = &v
	return s
}

func (s *CreateIpsecServerRequest) SetClientToken(v string) *CreateIpsecServerRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateIpsecServerRequest) SetDryRun(v string) *CreateIpsecServerRequest {
	s.DryRun = &v
	return s
}

func (s *CreateIpsecServerRequest) SetEffectImmediately(v bool) *CreateIpsecServerRequest {
	s.EffectImmediately = &v
	return s
}

func (s *CreateIpsecServerRequest) SetIkeConfig(v string) *CreateIpsecServerRequest {
	s.IkeConfig = &v
	return s
}

func (s *CreateIpsecServerRequest) SetIpSecServerName(v string) *CreateIpsecServerRequest {
	s.IpSecServerName = &v
	return s
}

func (s *CreateIpsecServerRequest) SetIpsecConfig(v string) *CreateIpsecServerRequest {
	s.IpsecConfig = &v
	return s
}

func (s *CreateIpsecServerRequest) SetLocalSubnet(v string) *CreateIpsecServerRequest {
	s.LocalSubnet = &v
	return s
}

func (s *CreateIpsecServerRequest) SetPsk(v string) *CreateIpsecServerRequest {
	s.Psk = &v
	return s
}

func (s *CreateIpsecServerRequest) SetPskEnabled(v bool) *CreateIpsecServerRequest {
	s.PskEnabled = &v
	return s
}

func (s *CreateIpsecServerRequest) SetRegionId(v string) *CreateIpsecServerRequest {
	s.RegionId = &v
	return s
}

func (s *CreateIpsecServerRequest) SetVpnGatewayId(v string) *CreateIpsecServerRequest {
	s.VpnGatewayId = &v
	return s
}

type CreateIpsecServerResponseBody struct {
	// The time when the IPsec server was created.
	//
	// T is used as a delimiter. Z indicates that the time is in UTC.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The ID of the IPsec server.
	IpsecServerId *string `json:"IpsecServerId,omitempty" xml:"IpsecServerId,omitempty"`
	// The name of the IPsec server.
	IpsecServerName *string `json:"IpsecServerName,omitempty" xml:"IpsecServerName,omitempty"`
	// The ID of the region where the VPN gateway is deployed.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the VPN gateway.
	VpnGatewayId *string `json:"VpnGatewayId,omitempty" xml:"VpnGatewayId,omitempty"`
}

func (s CreateIpsecServerResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateIpsecServerResponseBody) GoString() string {
	return s.String()
}

func (s *CreateIpsecServerResponseBody) SetCreationTime(v string) *CreateIpsecServerResponseBody {
	s.CreationTime = &v
	return s
}

func (s *CreateIpsecServerResponseBody) SetIpsecServerId(v string) *CreateIpsecServerResponseBody {
	s.IpsecServerId = &v
	return s
}

func (s *CreateIpsecServerResponseBody) SetIpsecServerName(v string) *CreateIpsecServerResponseBody {
	s.IpsecServerName = &v
	return s
}

func (s *CreateIpsecServerResponseBody) SetRegionId(v string) *CreateIpsecServerResponseBody {
	s.RegionId = &v
	return s
}

func (s *CreateIpsecServerResponseBody) SetRequestId(v string) *CreateIpsecServerResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateIpsecServerResponseBody) SetVpnGatewayId(v string) *CreateIpsecServerResponseBody {
	s.VpnGatewayId = &v
	return s
}

type CreateIpsecServerResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateIpsecServerResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateIpsecServerResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateIpsecServerResponse) GoString() string {
	return s.String()
}

func (s *CreateIpsecServerResponse) SetHeaders(v map[string]*string) *CreateIpsecServerResponse {
	s.Headers = v
	return s
}

func (s *CreateIpsecServerResponse) SetStatusCode(v int32) *CreateIpsecServerResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateIpsecServerResponse) SetBody(v *CreateIpsecServerResponseBody) *CreateIpsecServerResponse {
	s.Body = v
	return s
}

type CreateIpv4GatewayRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. ClientToken can contain only ASCII characters.
	//
	// >  If you do not set this parameter, the system sets **ClientToken** to the value of **RequestId**. The value of **RequestId** for each API request is different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to perform a dry run. Valid values:
	//
	// *   **true**: performs a dry run. The system checks the required parameters, request syntax, and limits. If the request fails the dry run, an error message is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
	// *   **false** (default): performs a dry run and sends the request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The description of the IPv4 gateway.
	//
	// The description must be 1 to 256 characters in length and cannot start with `http://` or `https://`.
	Ipv4GatewayDescription *string `json:"Ipv4GatewayDescription,omitempty" xml:"Ipv4GatewayDescription,omitempty"`
	// The name of the IPv4 gateway.
	//
	// The name must be 1 to 128 characters in length, and cannot start with `http://` or `https://`.
	Ipv4GatewayName *string `json:"Ipv4GatewayName,omitempty" xml:"Ipv4GatewayName,omitempty"`
	OwnerAccount    *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId         *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region where you want to create the IPv4 gateway.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId      *string                        `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string                        `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64                         `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	Tag                  []*CreateIpv4GatewayRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
	// The ID of the VPC where you want to create the IPv4 gateway.
	//
	// You can create only one IPv4 gateway in a VPC.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s CreateIpv4GatewayRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateIpv4GatewayRequest) GoString() string {
	return s.String()
}

func (s *CreateIpv4GatewayRequest) SetClientToken(v string) *CreateIpv4GatewayRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateIpv4GatewayRequest) SetDryRun(v bool) *CreateIpv4GatewayRequest {
	s.DryRun = &v
	return s
}

func (s *CreateIpv4GatewayRequest) SetIpv4GatewayDescription(v string) *CreateIpv4GatewayRequest {
	s.Ipv4GatewayDescription = &v
	return s
}

func (s *CreateIpv4GatewayRequest) SetIpv4GatewayName(v string) *CreateIpv4GatewayRequest {
	s.Ipv4GatewayName = &v
	return s
}

func (s *CreateIpv4GatewayRequest) SetOwnerAccount(v string) *CreateIpv4GatewayRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateIpv4GatewayRequest) SetOwnerId(v int64) *CreateIpv4GatewayRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateIpv4GatewayRequest) SetRegionId(v string) *CreateIpv4GatewayRequest {
	s.RegionId = &v
	return s
}

func (s *CreateIpv4GatewayRequest) SetResourceGroupId(v string) *CreateIpv4GatewayRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *CreateIpv4GatewayRequest) SetResourceOwnerAccount(v string) *CreateIpv4GatewayRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateIpv4GatewayRequest) SetResourceOwnerId(v int64) *CreateIpv4GatewayRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreateIpv4GatewayRequest) SetTag(v []*CreateIpv4GatewayRequestTag) *CreateIpv4GatewayRequest {
	s.Tag = v
	return s
}

func (s *CreateIpv4GatewayRequest) SetVpcId(v string) *CreateIpv4GatewayRequest {
	s.VpcId = &v
	return s
}

type CreateIpv4GatewayRequestTag struct {
	Key   *string `json:"Key,omitempty" xml:"Key,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateIpv4GatewayRequestTag) String() string {
	return tea.Prettify(s)
}

func (s CreateIpv4GatewayRequestTag) GoString() string {
	return s.String()
}

func (s *CreateIpv4GatewayRequestTag) SetKey(v string) *CreateIpv4GatewayRequestTag {
	s.Key = &v
	return s
}

func (s *CreateIpv4GatewayRequestTag) SetValue(v string) *CreateIpv4GatewayRequestTag {
	s.Value = &v
	return s
}

type CreateIpv4GatewayResponseBody struct {
	// The ID of the IPv4 gateway.
	Ipv4GatewayId *string `json:"Ipv4GatewayId,omitempty" xml:"Ipv4GatewayId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
}

func (s CreateIpv4GatewayResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateIpv4GatewayResponseBody) GoString() string {
	return s.String()
}

func (s *CreateIpv4GatewayResponseBody) SetIpv4GatewayId(v string) *CreateIpv4GatewayResponseBody {
	s.Ipv4GatewayId = &v
	return s
}

func (s *CreateIpv4GatewayResponseBody) SetRequestId(v string) *CreateIpv4GatewayResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateIpv4GatewayResponseBody) SetResourceGroupId(v string) *CreateIpv4GatewayResponseBody {
	s.ResourceGroupId = &v
	return s
}

type CreateIpv4GatewayResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateIpv4GatewayResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateIpv4GatewayResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateIpv4GatewayResponse) GoString() string {
	return s.String()
}

func (s *CreateIpv4GatewayResponse) SetHeaders(v map[string]*string) *CreateIpv4GatewayResponse {
	s.Headers = v
	return s
}

func (s *CreateIpv4GatewayResponse) SetStatusCode(v int32) *CreateIpv4GatewayResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateIpv4GatewayResponse) SetBody(v *CreateIpv4GatewayResponseBody) *CreateIpv4GatewayResponse {
	s.Body = v
	return s
}

type CreateIpv6EgressOnlyRuleRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that the value is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	//
	// >  If you do not specify this parameter, the system automatically uses the request ID as the client token. The value of RequestId for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The description of the egress-only rule.
	//
	// The description must be 2 to 256 characters in length and cannot start with `http://` or `https://`.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the IPv6 address for which you want to create an egress-only rule.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The type of the instance for which you want to create an egress-only rule.
	//
	// Set the value to **Ipv6Address** (default). This value specifies the IPv6 address type.
	InstanceType *string `json:"InstanceType,omitempty" xml:"InstanceType,omitempty"`
	// The ID of the IPv6 gateway.
	Ipv6GatewayId *string `json:"Ipv6GatewayId,omitempty" xml:"Ipv6GatewayId,omitempty"`
	// The name of the egress-only rule.
	//
	// The name must be 2 to 128 characters in length, and can contain letters, digits, underscores (\_), and hyphens (-). The name must start with a letter but cannot start with `http://` or `https://`.
	Name         *string `json:"Name,omitempty" xml:"Name,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the IPv6 gateway.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s CreateIpv6EgressOnlyRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateIpv6EgressOnlyRuleRequest) GoString() string {
	return s.String()
}

func (s *CreateIpv6EgressOnlyRuleRequest) SetClientToken(v string) *CreateIpv6EgressOnlyRuleRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateIpv6EgressOnlyRuleRequest) SetDescription(v string) *CreateIpv6EgressOnlyRuleRequest {
	s.Description = &v
	return s
}

func (s *CreateIpv6EgressOnlyRuleRequest) SetInstanceId(v string) *CreateIpv6EgressOnlyRuleRequest {
	s.InstanceId = &v
	return s
}

func (s *CreateIpv6EgressOnlyRuleRequest) SetInstanceType(v string) *CreateIpv6EgressOnlyRuleRequest {
	s.InstanceType = &v
	return s
}

func (s *CreateIpv6EgressOnlyRuleRequest) SetIpv6GatewayId(v string) *CreateIpv6EgressOnlyRuleRequest {
	s.Ipv6GatewayId = &v
	return s
}

func (s *CreateIpv6EgressOnlyRuleRequest) SetName(v string) *CreateIpv6EgressOnlyRuleRequest {
	s.Name = &v
	return s
}

func (s *CreateIpv6EgressOnlyRuleRequest) SetOwnerAccount(v string) *CreateIpv6EgressOnlyRuleRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateIpv6EgressOnlyRuleRequest) SetOwnerId(v int64) *CreateIpv6EgressOnlyRuleRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateIpv6EgressOnlyRuleRequest) SetRegionId(v string) *CreateIpv6EgressOnlyRuleRequest {
	s.RegionId = &v
	return s
}

func (s *CreateIpv6EgressOnlyRuleRequest) SetResourceOwnerAccount(v string) *CreateIpv6EgressOnlyRuleRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateIpv6EgressOnlyRuleRequest) SetResourceOwnerId(v int64) *CreateIpv6EgressOnlyRuleRequest {
	s.ResourceOwnerId = &v
	return s
}

type CreateIpv6EgressOnlyRuleResponseBody struct {
	// The ID of the egress-only rule.
	Ipv6EgressRuleId *string `json:"Ipv6EgressRuleId,omitempty" xml:"Ipv6EgressRuleId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateIpv6EgressOnlyRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateIpv6EgressOnlyRuleResponseBody) GoString() string {
	return s.String()
}

func (s *CreateIpv6EgressOnlyRuleResponseBody) SetIpv6EgressRuleId(v string) *CreateIpv6EgressOnlyRuleResponseBody {
	s.Ipv6EgressRuleId = &v
	return s
}

func (s *CreateIpv6EgressOnlyRuleResponseBody) SetRequestId(v string) *CreateIpv6EgressOnlyRuleResponseBody {
	s.RequestId = &v
	return s
}

type CreateIpv6EgressOnlyRuleResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateIpv6EgressOnlyRuleResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateIpv6EgressOnlyRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateIpv6EgressOnlyRuleResponse) GoString() string {
	return s.String()
}

func (s *CreateIpv6EgressOnlyRuleResponse) SetHeaders(v map[string]*string) *CreateIpv6EgressOnlyRuleResponse {
	s.Headers = v
	return s
}

func (s *CreateIpv6EgressOnlyRuleResponse) SetStatusCode(v int32) *CreateIpv6EgressOnlyRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateIpv6EgressOnlyRuleResponse) SetBody(v *CreateIpv6EgressOnlyRuleResponseBody) *CreateIpv6EgressOnlyRuleResponse {
	s.Body = v
	return s
}

type CreateIpv6GatewayRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must ensure that the value is unique among different requests. ClientToken can contain only ASCII characters.
	//
	// >  If you do not set this parameter, the system sets **ClientToken** to the value of **RequestId**. The value of **RequestId** for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The description of the IPv6 gateway.
	//
	// The description must be 2 to 256 characters in length and cannot start with `http://` or `https://`.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The name of the IPv6 gateway.
	//
	// The name must be 2 to 128 characters in length, and can contain letters, digits, underscores (\_), and hyphens (-). The name must start with a letter but cannot start with `http://` or `https://`.
	Name         *string `json:"Name,omitempty" xml:"Name,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region where the IPv6 gateway is deployed. You can call the [DescribeRegions](~~36063~~) operation to obtain the region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId      *string                        `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string                        `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64                         `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	Tag                  []*CreateIpv6GatewayRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
	// The ID of the VPC for which you want to create the IPv6 gateway.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s CreateIpv6GatewayRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateIpv6GatewayRequest) GoString() string {
	return s.String()
}

func (s *CreateIpv6GatewayRequest) SetClientToken(v string) *CreateIpv6GatewayRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateIpv6GatewayRequest) SetDescription(v string) *CreateIpv6GatewayRequest {
	s.Description = &v
	return s
}

func (s *CreateIpv6GatewayRequest) SetName(v string) *CreateIpv6GatewayRequest {
	s.Name = &v
	return s
}

func (s *CreateIpv6GatewayRequest) SetOwnerAccount(v string) *CreateIpv6GatewayRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateIpv6GatewayRequest) SetOwnerId(v int64) *CreateIpv6GatewayRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateIpv6GatewayRequest) SetRegionId(v string) *CreateIpv6GatewayRequest {
	s.RegionId = &v
	return s
}

func (s *CreateIpv6GatewayRequest) SetResourceGroupId(v string) *CreateIpv6GatewayRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *CreateIpv6GatewayRequest) SetResourceOwnerAccount(v string) *CreateIpv6GatewayRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateIpv6GatewayRequest) SetResourceOwnerId(v int64) *CreateIpv6GatewayRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreateIpv6GatewayRequest) SetTag(v []*CreateIpv6GatewayRequestTag) *CreateIpv6GatewayRequest {
	s.Tag = v
	return s
}

func (s *CreateIpv6GatewayRequest) SetVpcId(v string) *CreateIpv6GatewayRequest {
	s.VpcId = &v
	return s
}

type CreateIpv6GatewayRequestTag struct {
	Key   *string `json:"Key,omitempty" xml:"Key,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateIpv6GatewayRequestTag) String() string {
	return tea.Prettify(s)
}

func (s CreateIpv6GatewayRequestTag) GoString() string {
	return s.String()
}

func (s *CreateIpv6GatewayRequestTag) SetKey(v string) *CreateIpv6GatewayRequestTag {
	s.Key = &v
	return s
}

func (s *CreateIpv6GatewayRequestTag) SetValue(v string) *CreateIpv6GatewayRequestTag {
	s.Value = &v
	return s
}

type CreateIpv6GatewayResponseBody struct {
	// The ID of the IPv6 gateway.
	Ipv6GatewayId *string `json:"Ipv6GatewayId,omitempty" xml:"Ipv6GatewayId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
}

func (s CreateIpv6GatewayResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateIpv6GatewayResponseBody) GoString() string {
	return s.String()
}

func (s *CreateIpv6GatewayResponseBody) SetIpv6GatewayId(v string) *CreateIpv6GatewayResponseBody {
	s.Ipv6GatewayId = &v
	return s
}

func (s *CreateIpv6GatewayResponseBody) SetRequestId(v string) *CreateIpv6GatewayResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateIpv6GatewayResponseBody) SetResourceGroupId(v string) *CreateIpv6GatewayResponseBody {
	s.ResourceGroupId = &v
	return s
}

type CreateIpv6GatewayResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateIpv6GatewayResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateIpv6GatewayResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateIpv6GatewayResponse) GoString() string {
	return s.String()
}

func (s *CreateIpv6GatewayResponse) SetHeaders(v map[string]*string) *CreateIpv6GatewayResponse {
	s.Headers = v
	return s
}

func (s *CreateIpv6GatewayResponse) SetStatusCode(v int32) *CreateIpv6GatewayResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateIpv6GatewayResponse) SetBody(v *CreateIpv6GatewayResponseBody) *CreateIpv6GatewayResponse {
	s.Body = v
	return s
}

type CreateNatGatewayRequest struct {
	// Subscription Internet NAT gateways are no longer available for purchase. Ignore this parameter.
	AutoPay *bool `json:"AutoPay,omitempty" xml:"AutoPay,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among different requests.
	//
	// >  If you do not specify this parameter, the system automatically sets **ClientToken** to the value of **RequestId**. **RequestId** might be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The description of the NAT gateway.
	//
	// You can leave this parameter empty or enter a description. If you enter a description, the description must be 2 to 256 characters in length and cannot start with `http://` or `https://`.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// Subscription Internet NAT gateways are no longer available for purchase. Ignore this parameter.
	Duration *string `json:"Duration,omitempty" xml:"Duration,omitempty"`
	// The mode in which the EIP is associated with the NAT gateway. Valid values:
	//
	// *   **MULTI_BINDED** (default): Multi-EIP-to-ENI mode.
	//
	// *   **NAT**: NAT mode. IPv4 gateways are supported.
	//
	// > If you use the NAT mode, the EIP occupies one private IP address on the vSwitch of the NAT gateway. Make sure that the vSwitch has sufficient private IP addresses. Otherwise, the NAT gateway fails to be associated with the EIP. In NAT mode, you can associate a NAT gateway with at most 50 EIPs.
	EipBindMode *string `json:"EipBindMode,omitempty" xml:"EipBindMode,omitempty"`
	// Specifies whether to enable the ICMP non-retrieval feature. Valid values:
	//
	// *   **false** (default): no
	// *   **true**: yes
	IcmpReplyEnabled *bool `json:"IcmpReplyEnabled,omitempty" xml:"IcmpReplyEnabled,omitempty"`
	// The billing method of the NAT gateway.
	//
	// Set the value to **PostPaid** (pay-as-you-go), which is the default value.
	//
	// For more information, see [Internet NAT gateway billing](~~48126~~) and [VPC NAT gateway billing](~~270913~~).
	InstanceChargeType *string `json:"InstanceChargeType,omitempty" xml:"InstanceChargeType,omitempty"`
	// The metering method of the NAT gateway. Set the value to **PayByLcu**, which specifies the pay-by-CU metering method.
	InternetChargeType *string `json:"InternetChargeType,omitempty" xml:"InternetChargeType,omitempty"`
	// The name of the NAT gateway.
	//
	// The name must be 2 to 128 characters in length and can contain letters, digits, underscores (\_), and hyphens (-). The name must start with a letter.
	//
	// If this parameter is not set, the system assigns a default name to the NAT gateway.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The type of NAT gateway. Set the value to **Enhanced** (enhanced NAT gateway).
	NatType *string `json:"NatType,omitempty" xml:"NatType,omitempty"`
	// The network type of the NAT gateway. Valid values:
	//
	// *   **internet**: an Internet NAT gateway
	// *   **intranet**: a VPC NAT gateway
	NetworkType  *string `json:"NetworkType,omitempty" xml:"NetworkType,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// Subscription Internet NAT gateways are no longer available for purchase. Ignore this parameter.
	PricingCycle *string `json:"PricingCycle,omitempty" xml:"PricingCycle,omitempty"`
	// The ID of the region where you want to create the NAT gateway.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// Specifies whether to enable the firewall feature. Valid values:
	//
	// *   **false** (default): no
	// *   **true**: yes
	SecurityProtectionEnabled *bool `json:"SecurityProtectionEnabled,omitempty" xml:"SecurityProtectionEnabled,omitempty"`
	// Subscription Internet NAT gateways are no longer available for purchase. Ignore this parameter.
	Spec *string `json:"Spec,omitempty" xml:"Spec,omitempty"`
	// The list of Tag entries.
	Tag []*CreateNatGatewayRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
	// The ID of the vSwitch to which the NAT gateway is attached.
	//
	// When you create a NAT gateway, you must specify a vSwitch for the NAT gateway. Then, the system assigns an idle private IP address from the vSwitch to the NAT gateway.
	//
	// *   To attach the NAT gateway to an existing vSwitch, make sure that the zone to which the vSwitch belongs supports NAT gateways. In addition, the vSwitch must have idle IP addresses.
	// *   If no vSwitch exists in the VPC, create a vSwitch in a zone that supports NAT gateways. Then, specify the vSwitch for the NAT gateway.
	//
	// >  You can query the zones that support NAT gateways by calling the [ListEnhanhcedNatGatewayAvailableZones](~~182292~~) operation. You can query the number of available IP addresses in a vSwitch by calling the [DescribeVSwitches](~~35748~~) operation.
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
	// The ID of the VPC where you want to create the NAT gateway.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s CreateNatGatewayRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateNatGatewayRequest) GoString() string {
	return s.String()
}

func (s *CreateNatGatewayRequest) SetAutoPay(v bool) *CreateNatGatewayRequest {
	s.AutoPay = &v
	return s
}

func (s *CreateNatGatewayRequest) SetClientToken(v string) *CreateNatGatewayRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateNatGatewayRequest) SetDescription(v string) *CreateNatGatewayRequest {
	s.Description = &v
	return s
}

func (s *CreateNatGatewayRequest) SetDuration(v string) *CreateNatGatewayRequest {
	s.Duration = &v
	return s
}

func (s *CreateNatGatewayRequest) SetEipBindMode(v string) *CreateNatGatewayRequest {
	s.EipBindMode = &v
	return s
}

func (s *CreateNatGatewayRequest) SetIcmpReplyEnabled(v bool) *CreateNatGatewayRequest {
	s.IcmpReplyEnabled = &v
	return s
}

func (s *CreateNatGatewayRequest) SetInstanceChargeType(v string) *CreateNatGatewayRequest {
	s.InstanceChargeType = &v
	return s
}

func (s *CreateNatGatewayRequest) SetInternetChargeType(v string) *CreateNatGatewayRequest {
	s.InternetChargeType = &v
	return s
}

func (s *CreateNatGatewayRequest) SetName(v string) *CreateNatGatewayRequest {
	s.Name = &v
	return s
}

func (s *CreateNatGatewayRequest) SetNatType(v string) *CreateNatGatewayRequest {
	s.NatType = &v
	return s
}

func (s *CreateNatGatewayRequest) SetNetworkType(v string) *CreateNatGatewayRequest {
	s.NetworkType = &v
	return s
}

func (s *CreateNatGatewayRequest) SetOwnerAccount(v string) *CreateNatGatewayRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateNatGatewayRequest) SetOwnerId(v int64) *CreateNatGatewayRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateNatGatewayRequest) SetPricingCycle(v string) *CreateNatGatewayRequest {
	s.PricingCycle = &v
	return s
}

func (s *CreateNatGatewayRequest) SetRegionId(v string) *CreateNatGatewayRequest {
	s.RegionId = &v
	return s
}

func (s *CreateNatGatewayRequest) SetResourceOwnerAccount(v string) *CreateNatGatewayRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateNatGatewayRequest) SetResourceOwnerId(v int64) *CreateNatGatewayRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreateNatGatewayRequest) SetSecurityProtectionEnabled(v bool) *CreateNatGatewayRequest {
	s.SecurityProtectionEnabled = &v
	return s
}

func (s *CreateNatGatewayRequest) SetSpec(v string) *CreateNatGatewayRequest {
	s.Spec = &v
	return s
}

func (s *CreateNatGatewayRequest) SetTag(v []*CreateNatGatewayRequestTag) *CreateNatGatewayRequest {
	s.Tag = v
	return s
}

func (s *CreateNatGatewayRequest) SetVSwitchId(v string) *CreateNatGatewayRequest {
	s.VSwitchId = &v
	return s
}

func (s *CreateNatGatewayRequest) SetVpcId(v string) *CreateNatGatewayRequest {
	s.VpcId = &v
	return s
}

type CreateNatGatewayRequestTag struct {
	// The tag key. The format of Tag.N.Key when you call the operation. Valid values of N: 1 to 20. It cannot be an empty string. It can be up to 128 characters in length and cannot start with acs: or aliyun. It cannot contain http:// or https://.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value. The format of Tag.N.Value when you call the operation. Valid values of N: 1 to 20. It cannot be an empty string. It can be up to 128 characters in length and cannot start with acs: or aliyun. It cannot contain http:// or https://.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateNatGatewayRequestTag) String() string {
	return tea.Prettify(s)
}

func (s CreateNatGatewayRequestTag) GoString() string {
	return s.String()
}

func (s *CreateNatGatewayRequestTag) SetKey(v string) *CreateNatGatewayRequestTag {
	s.Key = &v
	return s
}

func (s *CreateNatGatewayRequestTag) SetValue(v string) *CreateNatGatewayRequestTag {
	s.Value = &v
	return s
}

type CreateNatGatewayResponseBody struct {
	// The list of DNAT entries.
	ForwardTableIds *CreateNatGatewayResponseBodyForwardTableIds `json:"ForwardTableIds,omitempty" xml:"ForwardTableIds,omitempty" type:"Struct"`
	// The list of FULLNAT entries.
	FullNatTableIds *CreateNatGatewayResponseBodyFullNatTableIds `json:"FullNatTableIds,omitempty" xml:"FullNatTableIds,omitempty" type:"Struct"`
	// The ID of the NAT gateway.
	NatGatewayId *string `json:"NatGatewayId,omitempty" xml:"NatGatewayId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The list of SNAT entries.
	SnatTableIds *CreateNatGatewayResponseBodySnatTableIds `json:"SnatTableIds,omitempty" xml:"SnatTableIds,omitempty" type:"Struct"`
}

func (s CreateNatGatewayResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateNatGatewayResponseBody) GoString() string {
	return s.String()
}

func (s *CreateNatGatewayResponseBody) SetForwardTableIds(v *CreateNatGatewayResponseBodyForwardTableIds) *CreateNatGatewayResponseBody {
	s.ForwardTableIds = v
	return s
}

func (s *CreateNatGatewayResponseBody) SetFullNatTableIds(v *CreateNatGatewayResponseBodyFullNatTableIds) *CreateNatGatewayResponseBody {
	s.FullNatTableIds = v
	return s
}

func (s *CreateNatGatewayResponseBody) SetNatGatewayId(v string) *CreateNatGatewayResponseBody {
	s.NatGatewayId = &v
	return s
}

func (s *CreateNatGatewayResponseBody) SetRequestId(v string) *CreateNatGatewayResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateNatGatewayResponseBody) SetSnatTableIds(v *CreateNatGatewayResponseBodySnatTableIds) *CreateNatGatewayResponseBody {
	s.SnatTableIds = v
	return s
}

type CreateNatGatewayResponseBodyForwardTableIds struct {
	ForwardTableId []*string `json:"ForwardTableId,omitempty" xml:"ForwardTableId,omitempty" type:"Repeated"`
}

func (s CreateNatGatewayResponseBodyForwardTableIds) String() string {
	return tea.Prettify(s)
}

func (s CreateNatGatewayResponseBodyForwardTableIds) GoString() string {
	return s.String()
}

func (s *CreateNatGatewayResponseBodyForwardTableIds) SetForwardTableId(v []*string) *CreateNatGatewayResponseBodyForwardTableIds {
	s.ForwardTableId = v
	return s
}

type CreateNatGatewayResponseBodyFullNatTableIds struct {
	FullNatTableId []*string `json:"FullNatTableId,omitempty" xml:"FullNatTableId,omitempty" type:"Repeated"`
}

func (s CreateNatGatewayResponseBodyFullNatTableIds) String() string {
	return tea.Prettify(s)
}

func (s CreateNatGatewayResponseBodyFullNatTableIds) GoString() string {
	return s.String()
}

func (s *CreateNatGatewayResponseBodyFullNatTableIds) SetFullNatTableId(v []*string) *CreateNatGatewayResponseBodyFullNatTableIds {
	s.FullNatTableId = v
	return s
}

type CreateNatGatewayResponseBodySnatTableIds struct {
	SnatTableId []*string `json:"SnatTableId,omitempty" xml:"SnatTableId,omitempty" type:"Repeated"`
}

func (s CreateNatGatewayResponseBodySnatTableIds) String() string {
	return tea.Prettify(s)
}

func (s CreateNatGatewayResponseBodySnatTableIds) GoString() string {
	return s.String()
}

func (s *CreateNatGatewayResponseBodySnatTableIds) SetSnatTableId(v []*string) *CreateNatGatewayResponseBodySnatTableIds {
	s.SnatTableId = v
	return s
}

type CreateNatGatewayResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateNatGatewayResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateNatGatewayResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateNatGatewayResponse) GoString() string {
	return s.String()
}

func (s *CreateNatGatewayResponse) SetHeaders(v map[string]*string) *CreateNatGatewayResponse {
	s.Headers = v
	return s
}

func (s *CreateNatGatewayResponse) SetStatusCode(v int32) *CreateNatGatewayResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateNatGatewayResponse) SetBody(v *CreateNatGatewayResponseBody) *CreateNatGatewayResponse {
	s.Body = v
	return s
}

type CreateNatIpRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether only to precheck this request. Valid values:
	//
	// *   **true**: sends the precheck request but does not create the NAT IP address. The system checks your AccessKey pair, the Resource Access Management (RAM) user permissions, and the required parameters. If the request fails the precheck, an error message is returned. If the request passes the precheck, the `DryRunOperation` error code is returned.
	// *   **false** (default): sends the request. If the request passes the precheck, a 2xx HTTP status code is returned and the NAT IP address is created.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The ID of the Virtual Private Cloud (VPC) NAT gateway for which you want to create the NAT IP address.
	NatGatewayId *string `json:"NatGatewayId,omitempty" xml:"NatGatewayId,omitempty"`
	// The NAT IP address that you want to create.
	//
	// If you do not specify an IP address, the system selects a random IP address from the specified CIDR block.
	NatIp *string `json:"NatIp,omitempty" xml:"NatIp,omitempty"`
	// The CIDR block to which the NAT IP address belongs.
	NatIpCidr *string `json:"NatIpCidr,omitempty" xml:"NatIpCidr,omitempty"`
	// The description of the NAT IP address.
	//
	// The description must be 2 to 256 characters in length. It must start with a letter but cannot start with `http://` or `https://`.
	NatIpDescription *string `json:"NatIpDescription,omitempty" xml:"NatIpDescription,omitempty"`
	// The name of the NAT IP address.
	//
	// The name must be 2 to 128 characters in length, and can contain letters, digits, periods (.), underscores (\_), and hyphens (-). It must start with a letter. It cannot start with `http://` or `https://`.
	NatIpName    *string `json:"NatIpName,omitempty" xml:"NatIpName,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the NAT gateway to which the NAT IP address that you want to create belongs.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s CreateNatIpRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateNatIpRequest) GoString() string {
	return s.String()
}

func (s *CreateNatIpRequest) SetClientToken(v string) *CreateNatIpRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateNatIpRequest) SetDryRun(v bool) *CreateNatIpRequest {
	s.DryRun = &v
	return s
}

func (s *CreateNatIpRequest) SetNatGatewayId(v string) *CreateNatIpRequest {
	s.NatGatewayId = &v
	return s
}

func (s *CreateNatIpRequest) SetNatIp(v string) *CreateNatIpRequest {
	s.NatIp = &v
	return s
}

func (s *CreateNatIpRequest) SetNatIpCidr(v string) *CreateNatIpRequest {
	s.NatIpCidr = &v
	return s
}

func (s *CreateNatIpRequest) SetNatIpDescription(v string) *CreateNatIpRequest {
	s.NatIpDescription = &v
	return s
}

func (s *CreateNatIpRequest) SetNatIpName(v string) *CreateNatIpRequest {
	s.NatIpName = &v
	return s
}

func (s *CreateNatIpRequest) SetOwnerAccount(v string) *CreateNatIpRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateNatIpRequest) SetOwnerId(v int64) *CreateNatIpRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateNatIpRequest) SetRegionId(v string) *CreateNatIpRequest {
	s.RegionId = &v
	return s
}

func (s *CreateNatIpRequest) SetResourceOwnerAccount(v string) *CreateNatIpRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateNatIpRequest) SetResourceOwnerId(v int64) *CreateNatIpRequest {
	s.ResourceOwnerId = &v
	return s
}

type CreateNatIpResponseBody struct {
	// The NAT IP address.
	NatIp *string `json:"NatIp,omitempty" xml:"NatIp,omitempty"`
	// The ID of the NAT IP address.
	NatIpId *string `json:"NatIpId,omitempty" xml:"NatIpId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateNatIpResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateNatIpResponseBody) GoString() string {
	return s.String()
}

func (s *CreateNatIpResponseBody) SetNatIp(v string) *CreateNatIpResponseBody {
	s.NatIp = &v
	return s
}

func (s *CreateNatIpResponseBody) SetNatIpId(v string) *CreateNatIpResponseBody {
	s.NatIpId = &v
	return s
}

func (s *CreateNatIpResponseBody) SetRequestId(v string) *CreateNatIpResponseBody {
	s.RequestId = &v
	return s
}

type CreateNatIpResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateNatIpResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateNatIpResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateNatIpResponse) GoString() string {
	return s.String()
}

func (s *CreateNatIpResponse) SetHeaders(v map[string]*string) *CreateNatIpResponse {
	s.Headers = v
	return s
}

func (s *CreateNatIpResponse) SetStatusCode(v int32) *CreateNatIpResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateNatIpResponse) SetBody(v *CreateNatIpResponseBody) *CreateNatIpResponse {
	s.Body = v
	return s
}

type CreateNatIpCidrRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, the system automatically uses **RequestId** as **ClientToken**. **RequestId** of each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to check the request without performing the operation. Valid values:
	//
	// *   **true**: prechecks the request but does not create the NAT CIDR block. The system checks the required parameters, request syntax, and limits. If the request fails check, an error message is returned. If the request passes the check, the `DryRunOperation` error code is returned.
	// *   **false** (default): sends the request. If the request passes the check, an HTTP 2xx status code is returned and the NAT CIDR block is created.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The ID of the Virtual Private Cloud (VPC) NAT gateway with which you want to associate the CIDR block.
	NatGatewayId *string `json:"NatGatewayId,omitempty" xml:"NatGatewayId,omitempty"`
	// The NAT CIDR block that you want to associate with the NAT gateway.
	//
	// The NAT CIDR block must meet the following conditions:
	//
	// *   The NAT CIDR block must fall within 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16, or their subnets.
	// *   The subnet mask must be 16 to 32 bits in length.
	// *   The NAT CIDR block cannot overlap with the private CIDR block of the VPC to which the NAT gateway belongs. If you want to use other IP addresses from the private CIDR block of the VPC to provide NAT services, create a vSwitch and attach the vSwitch to another VPC NAT gateway.
	// *   If you want to use public IP addresses to provide NAT services, make sure that the public IP addresses fall within a customer CIDR block of the VPC to which the VPC NAT gateway belongs. For more information, see [What is customer CIDR block?](~~185311~~).
	NatIpCidr *string `json:"NatIpCidr,omitempty" xml:"NatIpCidr,omitempty"`
	// The description of the NAT CIDR block.
	//
	// The description must be 2 to 256 characters in length. It must start with a letter but cannot start with `http://` or `https://`.
	NatIpCidrDescription *string `json:"NatIpCidrDescription,omitempty" xml:"NatIpCidrDescription,omitempty"`
	// The name of the CIDR block.
	//
	// The name must be 2 to 128 characters in length, and can contain letters, digits, periods (.), underscores (\_), and hyphens (-). It must start with a letter. It cannot start with `http://` or `https://`.
	NatIpCidrName *string `json:"NatIpCidrName,omitempty" xml:"NatIpCidrName,omitempty"`
	OwnerAccount  *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the NAT gateway with which you want to associate the CIDR block.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s CreateNatIpCidrRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateNatIpCidrRequest) GoString() string {
	return s.String()
}

func (s *CreateNatIpCidrRequest) SetClientToken(v string) *CreateNatIpCidrRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateNatIpCidrRequest) SetDryRun(v bool) *CreateNatIpCidrRequest {
	s.DryRun = &v
	return s
}

func (s *CreateNatIpCidrRequest) SetNatGatewayId(v string) *CreateNatIpCidrRequest {
	s.NatGatewayId = &v
	return s
}

func (s *CreateNatIpCidrRequest) SetNatIpCidr(v string) *CreateNatIpCidrRequest {
	s.NatIpCidr = &v
	return s
}

func (s *CreateNatIpCidrRequest) SetNatIpCidrDescription(v string) *CreateNatIpCidrRequest {
	s.NatIpCidrDescription = &v
	return s
}

func (s *CreateNatIpCidrRequest) SetNatIpCidrName(v string) *CreateNatIpCidrRequest {
	s.NatIpCidrName = &v
	return s
}

func (s *CreateNatIpCidrRequest) SetOwnerAccount(v string) *CreateNatIpCidrRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateNatIpCidrRequest) SetOwnerId(v int64) *CreateNatIpCidrRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateNatIpCidrRequest) SetRegionId(v string) *CreateNatIpCidrRequest {
	s.RegionId = &v
	return s
}

func (s *CreateNatIpCidrRequest) SetResourceOwnerAccount(v string) *CreateNatIpCidrRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateNatIpCidrRequest) SetResourceOwnerId(v int64) *CreateNatIpCidrRequest {
	s.ResourceOwnerId = &v
	return s
}

type CreateNatIpCidrResponseBody struct {
	// The ID of the NAT CIDR block.
	NatIpCidrId *string `json:"NatIpCidrId,omitempty" xml:"NatIpCidrId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateNatIpCidrResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateNatIpCidrResponseBody) GoString() string {
	return s.String()
}

func (s *CreateNatIpCidrResponseBody) SetNatIpCidrId(v string) *CreateNatIpCidrResponseBody {
	s.NatIpCidrId = &v
	return s
}

func (s *CreateNatIpCidrResponseBody) SetRequestId(v string) *CreateNatIpCidrResponseBody {
	s.RequestId = &v
	return s
}

type CreateNatIpCidrResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateNatIpCidrResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateNatIpCidrResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateNatIpCidrResponse) GoString() string {
	return s.String()
}

func (s *CreateNatIpCidrResponse) SetHeaders(v map[string]*string) *CreateNatIpCidrResponse {
	s.Headers = v
	return s
}

func (s *CreateNatIpCidrResponse) SetStatusCode(v int32) *CreateNatIpCidrResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateNatIpCidrResponse) SetBody(v *CreateNatIpCidrResponseBody) *CreateNatIpCidrResponse {
	s.Body = v
	return s
}

type CreateNetworkAclRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can contain only ASCII characters.
	//
	// >  If you do not specify this parameter, the system uses **RequestId** as **ClientToken**. **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The description of the network ACL.
	//
	// The description must be 1 to 256 characters in length and cannot start with `http://` or `https://`.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The name of the network ACL.
	//
	// The name must be 1 to 128 characters in length and cannot start with `http://` or `https://`.
	NetworkAclName *string `json:"NetworkAclName,omitempty" xml:"NetworkAclName,omitempty"`
	OwnerId        *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the network ACL.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string                       `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string                       `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64                        `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	Tag                  []*CreateNetworkAclRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
	// The ID of the virtual private cloud (VPC) to which the network ACL belongs.
	//
	// If the VPC contains Elastic Compute Service (ECS) instances of the following instance families, you must upgrade the ECS instances or release the ECS instances. Otherwise, you cannot create a network ACL for the VPC.
	//
	// ecs.c1, ecs.c2, ecs.c4, ecs.c5, ecs.ce4, ecs.cm4, ecs.d1, ecs.e3, ecs.e4, ecs.ga1, ecs.gn4, ecs.gn5, ecs.i1, ecs.m1, ecs.m2, ecs.mn4, ecs.n1, ecs.n2, ecs.n4, ecs.s1, ecs.s2, ecs.s3, ecs.se1, ecs.sn1, ecs.sn2, ecs.t1, and ecs.xn4.
	//
	// *   For more information about how to upgrade an ECS instance, see [Upgrade subscription instances](~~25438~~) and [Change the specifications of pay-as-you-go instances](~~60051~~).
	// *   For more information about how to release an ECS instance, see [Release an ECS instance](~~25442~~).
	//
	// >  If your VPC contains ECS instances of the preceding instance families and you create a network ACL for the VPC, you must upgrade the ECS instances. Otherwise, the network ACL cannot work as expected.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s CreateNetworkAclRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateNetworkAclRequest) GoString() string {
	return s.String()
}

func (s *CreateNetworkAclRequest) SetClientToken(v string) *CreateNetworkAclRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateNetworkAclRequest) SetDescription(v string) *CreateNetworkAclRequest {
	s.Description = &v
	return s
}

func (s *CreateNetworkAclRequest) SetNetworkAclName(v string) *CreateNetworkAclRequest {
	s.NetworkAclName = &v
	return s
}

func (s *CreateNetworkAclRequest) SetOwnerId(v int64) *CreateNetworkAclRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateNetworkAclRequest) SetRegionId(v string) *CreateNetworkAclRequest {
	s.RegionId = &v
	return s
}

func (s *CreateNetworkAclRequest) SetResourceOwnerAccount(v string) *CreateNetworkAclRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateNetworkAclRequest) SetResourceOwnerId(v int64) *CreateNetworkAclRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreateNetworkAclRequest) SetTag(v []*CreateNetworkAclRequestTag) *CreateNetworkAclRequest {
	s.Tag = v
	return s
}

func (s *CreateNetworkAclRequest) SetVpcId(v string) *CreateNetworkAclRequest {
	s.VpcId = &v
	return s
}

type CreateNetworkAclRequestTag struct {
	Key   *string `json:"Key,omitempty" xml:"Key,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateNetworkAclRequestTag) String() string {
	return tea.Prettify(s)
}

func (s CreateNetworkAclRequestTag) GoString() string {
	return s.String()
}

func (s *CreateNetworkAclRequestTag) SetKey(v string) *CreateNetworkAclRequestTag {
	s.Key = &v
	return s
}

func (s *CreateNetworkAclRequestTag) SetValue(v string) *CreateNetworkAclRequestTag {
	s.Value = &v
	return s
}

type CreateNetworkAclResponseBody struct {
	// The attributes of the network ACL.
	NetworkAclAttribute *CreateNetworkAclResponseBodyNetworkAclAttribute `json:"NetworkAclAttribute,omitempty" xml:"NetworkAclAttribute,omitempty" type:"Struct"`
	// The ID of the network ACL.
	NetworkAclId *string `json:"NetworkAclId,omitempty" xml:"NetworkAclId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateNetworkAclResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateNetworkAclResponseBody) GoString() string {
	return s.String()
}

func (s *CreateNetworkAclResponseBody) SetNetworkAclAttribute(v *CreateNetworkAclResponseBodyNetworkAclAttribute) *CreateNetworkAclResponseBody {
	s.NetworkAclAttribute = v
	return s
}

func (s *CreateNetworkAclResponseBody) SetNetworkAclId(v string) *CreateNetworkAclResponseBody {
	s.NetworkAclId = &v
	return s
}

func (s *CreateNetworkAclResponseBody) SetRequestId(v string) *CreateNetworkAclResponseBody {
	s.RequestId = &v
	return s
}

type CreateNetworkAclResponseBodyNetworkAclAttribute struct {
	// The time when the network ACL was created.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The description of the network ACL.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The details about the outbound rule.
	EgressAclEntries *CreateNetworkAclResponseBodyNetworkAclAttributeEgressAclEntries `json:"EgressAclEntries,omitempty" xml:"EgressAclEntries,omitempty" type:"Struct"`
	// The details about the inbound rule.
	IngressAclEntries *CreateNetworkAclResponseBodyNetworkAclAttributeIngressAclEntries `json:"IngressAclEntries,omitempty" xml:"IngressAclEntries,omitempty" type:"Struct"`
	// The ID of the network ACL.
	NetworkAclId *string `json:"NetworkAclId,omitempty" xml:"NetworkAclId,omitempty"`
	// The name of the network ACL.
	NetworkAclName *string `json:"NetworkAclName,omitempty" xml:"NetworkAclName,omitempty"`
	// The region ID of the network ACL.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The details about the resource that is associated with the network ACL.
	Resources *CreateNetworkAclResponseBodyNetworkAclAttributeResources `json:"Resources,omitempty" xml:"Resources,omitempty" type:"Struct"`
	// The status of the network ACL. Valid values:
	//
	// *   **Available**: The network ACL is available.
	// *   **Modifying**: The network ACL is being configured.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The ID of the VPC to which the network ACL belongs.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s CreateNetworkAclResponseBodyNetworkAclAttribute) String() string {
	return tea.Prettify(s)
}

func (s CreateNetworkAclResponseBodyNetworkAclAttribute) GoString() string {
	return s.String()
}

func (s *CreateNetworkAclResponseBodyNetworkAclAttribute) SetCreationTime(v string) *CreateNetworkAclResponseBodyNetworkAclAttribute {
	s.CreationTime = &v
	return s
}

func (s *CreateNetworkAclResponseBodyNetworkAclAttribute) SetDescription(v string) *CreateNetworkAclResponseBodyNetworkAclAttribute {
	s.Description = &v
	return s
}

func (s *CreateNetworkAclResponseBodyNetworkAclAttribute) SetEgressAclEntries(v *CreateNetworkAclResponseBodyNetworkAclAttributeEgressAclEntries) *CreateNetworkAclResponseBodyNetworkAclAttribute {
	s.EgressAclEntries = v
	return s
}

func (s *CreateNetworkAclResponseBodyNetworkAclAttribute) SetIngressAclEntries(v *CreateNetworkAclResponseBodyNetworkAclAttributeIngressAclEntries) *CreateNetworkAclResponseBodyNetworkAclAttribute {
	s.IngressAclEntries = v
	return s
}

func (s *CreateNetworkAclResponseBodyNetworkAclAttribute) SetNetworkAclId(v string) *CreateNetworkAclResponseBodyNetworkAclAttribute {
	s.NetworkAclId = &v
	return s
}

func (s *CreateNetworkAclResponseBodyNetworkAclAttribute) SetNetworkAclName(v string) *CreateNetworkAclResponseBodyNetworkAclAttribute {
	s.NetworkAclName = &v
	return s
}

func (s *CreateNetworkAclResponseBodyNetworkAclAttribute) SetRegionId(v string) *CreateNetworkAclResponseBodyNetworkAclAttribute {
	s.RegionId = &v
	return s
}

func (s *CreateNetworkAclResponseBodyNetworkAclAttribute) SetResources(v *CreateNetworkAclResponseBodyNetworkAclAttributeResources) *CreateNetworkAclResponseBodyNetworkAclAttribute {
	s.Resources = v
	return s
}

func (s *CreateNetworkAclResponseBodyNetworkAclAttribute) SetStatus(v string) *CreateNetworkAclResponseBodyNetworkAclAttribute {
	s.Status = &v
	return s
}

func (s *CreateNetworkAclResponseBodyNetworkAclAttribute) SetVpcId(v string) *CreateNetworkAclResponseBodyNetworkAclAttribute {
	s.VpcId = &v
	return s
}

type CreateNetworkAclResponseBodyNetworkAclAttributeEgressAclEntries struct {
	EgressAclEntry []*CreateNetworkAclResponseBodyNetworkAclAttributeEgressAclEntriesEgressAclEntry `json:"EgressAclEntry,omitempty" xml:"EgressAclEntry,omitempty" type:"Repeated"`
}

func (s CreateNetworkAclResponseBodyNetworkAclAttributeEgressAclEntries) String() string {
	return tea.Prettify(s)
}

func (s CreateNetworkAclResponseBodyNetworkAclAttributeEgressAclEntries) GoString() string {
	return s.String()
}

func (s *CreateNetworkAclResponseBodyNetworkAclAttributeEgressAclEntries) SetEgressAclEntry(v []*CreateNetworkAclResponseBodyNetworkAclAttributeEgressAclEntriesEgressAclEntry) *CreateNetworkAclResponseBodyNetworkAclAttributeEgressAclEntries {
	s.EgressAclEntry = v
	return s
}

type CreateNetworkAclResponseBodyNetworkAclAttributeEgressAclEntriesEgressAclEntry struct {
	// The description of the outbound rule.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The destination CIDR block.
	DestinationCidrIp *string `json:"DestinationCidrIp,omitempty" xml:"DestinationCidrIp,omitempty"`
	// The ID of the outbound rule.
	NetworkAclEntryId *string `json:"NetworkAclEntryId,omitempty" xml:"NetworkAclEntryId,omitempty"`
	// The name of the outbound rule.
	NetworkAclEntryName *string `json:"NetworkAclEntryName,omitempty" xml:"NetworkAclEntryName,omitempty"`
	// The action that is performed on network traffic that matches the rule. Valid values:
	//
	// - **accept**: allows the network traffic.
	// - **drop**: blocks the network traffic.
	Policy *string `json:"Policy,omitempty" xml:"Policy,omitempty"`
	// The destination port range of the outbound rule.
	//
	// - If **Protocol** of the outbound rule is set to **all**, **icmp**, or **gre**, the port range is **-1/-1**, which indicates all ports.
	// - If **Protocol** of the outbound rule is set to **tcp** or **udp**, the port range is in the following format: **1/200** or **80/80**. 1/200 indicates port 1 to port 200. 80/80 indicates port 80. Valid values for a port: **1** to **65535**.
	Port *string `json:"Port,omitempty" xml:"Port,omitempty"`
	// The protocol type. Valid values:
	//
	// - **icmp**: ICMP
	// - **gre**: GRE
	// - **tcp**: TCP
	// - **udp**: UDP
	// - **all**: all protocols
	Protocol *string `json:"Protocol,omitempty" xml:"Protocol,omitempty"`
}

func (s CreateNetworkAclResponseBodyNetworkAclAttributeEgressAclEntriesEgressAclEntry) String() string {
	return tea.Prettify(s)
}

func (s CreateNetworkAclResponseBodyNetworkAclAttributeEgressAclEntriesEgressAclEntry) GoString() string {
	return s.String()
}

func (s *CreateNetworkAclResponseBodyNetworkAclAttributeEgressAclEntriesEgressAclEntry) SetDescription(v string) *CreateNetworkAclResponseBodyNetworkAclAttributeEgressAclEntriesEgressAclEntry {
	s.Description = &v
	return s
}

func (s *CreateNetworkAclResponseBodyNetworkAclAttributeEgressAclEntriesEgressAclEntry) SetDestinationCidrIp(v string) *CreateNetworkAclResponseBodyNetworkAclAttributeEgressAclEntriesEgressAclEntry {
	s.DestinationCidrIp = &v
	return s
}

func (s *CreateNetworkAclResponseBodyNetworkAclAttributeEgressAclEntriesEgressAclEntry) SetNetworkAclEntryId(v string) *CreateNetworkAclResponseBodyNetworkAclAttributeEgressAclEntriesEgressAclEntry {
	s.NetworkAclEntryId = &v
	return s
}

func (s *CreateNetworkAclResponseBodyNetworkAclAttributeEgressAclEntriesEgressAclEntry) SetNetworkAclEntryName(v string) *CreateNetworkAclResponseBodyNetworkAclAttributeEgressAclEntriesEgressAclEntry {
	s.NetworkAclEntryName = &v
	return s
}

func (s *CreateNetworkAclResponseBodyNetworkAclAttributeEgressAclEntriesEgressAclEntry) SetPolicy(v string) *CreateNetworkAclResponseBodyNetworkAclAttributeEgressAclEntriesEgressAclEntry {
	s.Policy = &v
	return s
}

func (s *CreateNetworkAclResponseBodyNetworkAclAttributeEgressAclEntriesEgressAclEntry) SetPort(v string) *CreateNetworkAclResponseBodyNetworkAclAttributeEgressAclEntriesEgressAclEntry {
	s.Port = &v
	return s
}

func (s *CreateNetworkAclResponseBodyNetworkAclAttributeEgressAclEntriesEgressAclEntry) SetProtocol(v string) *CreateNetworkAclResponseBodyNetworkAclAttributeEgressAclEntriesEgressAclEntry {
	s.Protocol = &v
	return s
}

type CreateNetworkAclResponseBodyNetworkAclAttributeIngressAclEntries struct {
	IngressAclEntry []*CreateNetworkAclResponseBodyNetworkAclAttributeIngressAclEntriesIngressAclEntry `json:"IngressAclEntry,omitempty" xml:"IngressAclEntry,omitempty" type:"Repeated"`
}

func (s CreateNetworkAclResponseBodyNetworkAclAttributeIngressAclEntries) String() string {
	return tea.Prettify(s)
}

func (s CreateNetworkAclResponseBodyNetworkAclAttributeIngressAclEntries) GoString() string {
	return s.String()
}

func (s *CreateNetworkAclResponseBodyNetworkAclAttributeIngressAclEntries) SetIngressAclEntry(v []*CreateNetworkAclResponseBodyNetworkAclAttributeIngressAclEntriesIngressAclEntry) *CreateNetworkAclResponseBodyNetworkAclAttributeIngressAclEntries {
	s.IngressAclEntry = v
	return s
}

type CreateNetworkAclResponseBodyNetworkAclAttributeIngressAclEntriesIngressAclEntry struct {
	// The description of the inbound rule.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the inbound rule.
	NetworkAclEntryId *string `json:"NetworkAclEntryId,omitempty" xml:"NetworkAclEntryId,omitempty"`
	// The name of the inbound rule.
	NetworkAclEntryName *string `json:"NetworkAclEntryName,omitempty" xml:"NetworkAclEntryName,omitempty"`
	// The action that is performed on network traffic that matches the rule. Valid values:
	//
	// *   **accept**: allows the network traffic.
	// *   **drop**: blocks the network traffic.
	Policy *string `json:"Policy,omitempty" xml:"Policy,omitempty"`
	// The destination port range of the inbound rule.
	//
	// *   If **Protocol** of the inbound rule is set to **all**, **icmp**, or **gre**, the port range is **-1/-1**, which indicates all ports.
	// *   If **Protocol** of the inbound rule is set to **tcp** or **udp**, the port range is in the following format: **1/200** or **80/80**. 1/200 indicates port 1 to port 200. 80/80 indicates port 80. Valid values for a port: **1** to **65535**.
	Port *string `json:"Port,omitempty" xml:"Port,omitempty"`
	// The protocol type. Valid values:
	//
	// *   **icmp**: ICMP
	// *   **gre**: GRE
	// *   **tcp**: TCP
	// *   **udp**: UDP
	// *   **all**: all protocols
	Protocol *string `json:"Protocol,omitempty" xml:"Protocol,omitempty"`
	// The source CIDR block.
	SourceCidrIp *string `json:"SourceCidrIp,omitempty" xml:"SourceCidrIp,omitempty"`
}

func (s CreateNetworkAclResponseBodyNetworkAclAttributeIngressAclEntriesIngressAclEntry) String() string {
	return tea.Prettify(s)
}

func (s CreateNetworkAclResponseBodyNetworkAclAttributeIngressAclEntriesIngressAclEntry) GoString() string {
	return s.String()
}

func (s *CreateNetworkAclResponseBodyNetworkAclAttributeIngressAclEntriesIngressAclEntry) SetDescription(v string) *CreateNetworkAclResponseBodyNetworkAclAttributeIngressAclEntriesIngressAclEntry {
	s.Description = &v
	return s
}

func (s *CreateNetworkAclResponseBodyNetworkAclAttributeIngressAclEntriesIngressAclEntry) SetNetworkAclEntryId(v string) *CreateNetworkAclResponseBodyNetworkAclAttributeIngressAclEntriesIngressAclEntry {
	s.NetworkAclEntryId = &v
	return s
}

func (s *CreateNetworkAclResponseBodyNetworkAclAttributeIngressAclEntriesIngressAclEntry) SetNetworkAclEntryName(v string) *CreateNetworkAclResponseBodyNetworkAclAttributeIngressAclEntriesIngressAclEntry {
	s.NetworkAclEntryName = &v
	return s
}

func (s *CreateNetworkAclResponseBodyNetworkAclAttributeIngressAclEntriesIngressAclEntry) SetPolicy(v string) *CreateNetworkAclResponseBodyNetworkAclAttributeIngressAclEntriesIngressAclEntry {
	s.Policy = &v
	return s
}

func (s *CreateNetworkAclResponseBodyNetworkAclAttributeIngressAclEntriesIngressAclEntry) SetPort(v string) *CreateNetworkAclResponseBodyNetworkAclAttributeIngressAclEntriesIngressAclEntry {
	s.Port = &v
	return s
}

func (s *CreateNetworkAclResponseBodyNetworkAclAttributeIngressAclEntriesIngressAclEntry) SetProtocol(v string) *CreateNetworkAclResponseBodyNetworkAclAttributeIngressAclEntriesIngressAclEntry {
	s.Protocol = &v
	return s
}

func (s *CreateNetworkAclResponseBodyNetworkAclAttributeIngressAclEntriesIngressAclEntry) SetSourceCidrIp(v string) *CreateNetworkAclResponseBodyNetworkAclAttributeIngressAclEntriesIngressAclEntry {
	s.SourceCidrIp = &v
	return s
}

type CreateNetworkAclResponseBodyNetworkAclAttributeResources struct {
	Resource []*CreateNetworkAclResponseBodyNetworkAclAttributeResourcesResource `json:"Resource,omitempty" xml:"Resource,omitempty" type:"Repeated"`
}

func (s CreateNetworkAclResponseBodyNetworkAclAttributeResources) String() string {
	return tea.Prettify(s)
}

func (s CreateNetworkAclResponseBodyNetworkAclAttributeResources) GoString() string {
	return s.String()
}

func (s *CreateNetworkAclResponseBodyNetworkAclAttributeResources) SetResource(v []*CreateNetworkAclResponseBodyNetworkAclAttributeResourcesResource) *CreateNetworkAclResponseBodyNetworkAclAttributeResources {
	s.Resource = v
	return s
}

type CreateNetworkAclResponseBodyNetworkAclAttributeResourcesResource struct {
	// The ID of the associated resource.
	ResourceId *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	// The type of the associated resource.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The association status of the resource. Valid values:
	//
	// - **BINDED**: The resource is associated with the network ACL.
	// - **BINDING**: The resource is being associated with the network ACL.
	// - **UNBINDING**: The resource is disassociated from the network ACL.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s CreateNetworkAclResponseBodyNetworkAclAttributeResourcesResource) String() string {
	return tea.Prettify(s)
}

func (s CreateNetworkAclResponseBodyNetworkAclAttributeResourcesResource) GoString() string {
	return s.String()
}

func (s *CreateNetworkAclResponseBodyNetworkAclAttributeResourcesResource) SetResourceId(v string) *CreateNetworkAclResponseBodyNetworkAclAttributeResourcesResource {
	s.ResourceId = &v
	return s
}

func (s *CreateNetworkAclResponseBodyNetworkAclAttributeResourcesResource) SetResourceType(v string) *CreateNetworkAclResponseBodyNetworkAclAttributeResourcesResource {
	s.ResourceType = &v
	return s
}

func (s *CreateNetworkAclResponseBodyNetworkAclAttributeResourcesResource) SetStatus(v string) *CreateNetworkAclResponseBodyNetworkAclAttributeResourcesResource {
	s.Status = &v
	return s
}

type CreateNetworkAclResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateNetworkAclResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateNetworkAclResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateNetworkAclResponse) GoString() string {
	return s.String()
}

func (s *CreateNetworkAclResponse) SetHeaders(v map[string]*string) *CreateNetworkAclResponse {
	s.Headers = v
	return s
}

func (s *CreateNetworkAclResponse) SetStatusCode(v int32) *CreateNetworkAclResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateNetworkAclResponse) SetBody(v *CreateNetworkAclResponseBody) *CreateNetworkAclResponse {
	s.Body = v
	return s
}

type CreatePhysicalConnectionRequest struct {
	// The access point ID of the Express Connect circuit.
	AccessPointId *string `json:"AccessPointId,omitempty" xml:"AccessPointId,omitempty"`
	// The circuit code of the Express Connect circuit. The circuit code is provided by the connectivity provider.
	CircuitCode *string `json:"CircuitCode,omitempty" xml:"CircuitCode,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must ensure that the value is unique among all requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, the system uses **RequestId** as **ClientToken**. **RequestId** might be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The description of the Express Connect circuit.
	//
	// The description must be 2 to 256 characters in length. The description must start with a letter but cannot start with `http://` or `https://`.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The connectivity provider of the Express Connect circuit. Valid values:
	//
	// *   **CT**: China Telecom
	// *   **CU**: China Unicom
	// *   **CM**: China Mobile
	// *   **CO**: other connectivity providers in the Chinese mainland
	// *   **Equinix**: Equinix
	// *   **Other**: other connectivity providers outside the Chinese mainland
	LineOperator *string `json:"LineOperator,omitempty" xml:"LineOperator,omitempty"`
	// The name of the Express Connect circuit.
	//
	// The name must be 2 to 128 characters in length, and can contain letters, digits, underscores (\_), and hyphens (-). The name must start with a letter but cannot start with `http://` or `https://`.
	Name         *string `json:"Name,omitempty" xml:"Name,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The geographical location of the data center.
	PeerLocation *string `json:"PeerLocation,omitempty" xml:"PeerLocation,omitempty"`
	// The port type of the Express Connect circuit. Valid values:
	//
	// *   **100Base-T**: 100 Mbit/s copper Ethernet port
	// *   **1000Base-T**: 1,000 Mbit/s copper Ethernet port
	// *   **1000Base-LX**: 1,000 Mbit/s single-mode optical port (10 km)
	// *   **10GBase-T**: 10,000 Mbit/s copper Ethernet port
	// *   **10GBase-LR**: 10,000 Mbit/s single-mode optical port (10 kilometers)
	// *   **40GBase-LR**: 40,000 Mbit/s single-mode optical port
	// *   **100GBase-LR**: 100,000 Mbit/s single-mode optical port
	//
	// >  If you want to use the 40GBase-LR or 100GBase-LR port for an Express Connect circuit, you must first contact your account manager to obtain information about resource supplies.
	PortType *string `json:"PortType,omitempty" xml:"PortType,omitempty"`
	// The ID of the redundant Express Connect circuit. The redundant Express Connect circuit must be in the **Allocated**, **Confirmed**, or **Enabled** state.
	RedundantPhysicalConnectionId *string `json:"RedundantPhysicalConnectionId,omitempty" xml:"RedundantPhysicalConnectionId,omitempty"`
	// The region ID of the Express Connect circuit.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group to which the Express Connect circuit belongs.
	ResourceGroupId      *string                               `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string                               `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64                                `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	Tag                  []*CreatePhysicalConnectionRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
	// The type of the Express Connect circuit. Default value: **VPC**.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The maximum bandwidth of the hosted connection. Unit: Mbit/s.
	//
	// Valid values: **50**, **100**, **200**, **300**, **400**, **500**, **1000**, **2000**, **4000**, **5000**, **8000**, and **10000**.
	Bandwidth *int32 `json:"bandwidth,omitempty" xml:"bandwidth,omitempty"`
}

func (s CreatePhysicalConnectionRequest) String() string {
	return tea.Prettify(s)
}

func (s CreatePhysicalConnectionRequest) GoString() string {
	return s.String()
}

func (s *CreatePhysicalConnectionRequest) SetAccessPointId(v string) *CreatePhysicalConnectionRequest {
	s.AccessPointId = &v
	return s
}

func (s *CreatePhysicalConnectionRequest) SetCircuitCode(v string) *CreatePhysicalConnectionRequest {
	s.CircuitCode = &v
	return s
}

func (s *CreatePhysicalConnectionRequest) SetClientToken(v string) *CreatePhysicalConnectionRequest {
	s.ClientToken = &v
	return s
}

func (s *CreatePhysicalConnectionRequest) SetDescription(v string) *CreatePhysicalConnectionRequest {
	s.Description = &v
	return s
}

func (s *CreatePhysicalConnectionRequest) SetLineOperator(v string) *CreatePhysicalConnectionRequest {
	s.LineOperator = &v
	return s
}

func (s *CreatePhysicalConnectionRequest) SetName(v string) *CreatePhysicalConnectionRequest {
	s.Name = &v
	return s
}

func (s *CreatePhysicalConnectionRequest) SetOwnerAccount(v string) *CreatePhysicalConnectionRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreatePhysicalConnectionRequest) SetOwnerId(v int64) *CreatePhysicalConnectionRequest {
	s.OwnerId = &v
	return s
}

func (s *CreatePhysicalConnectionRequest) SetPeerLocation(v string) *CreatePhysicalConnectionRequest {
	s.PeerLocation = &v
	return s
}

func (s *CreatePhysicalConnectionRequest) SetPortType(v string) *CreatePhysicalConnectionRequest {
	s.PortType = &v
	return s
}

func (s *CreatePhysicalConnectionRequest) SetRedundantPhysicalConnectionId(v string) *CreatePhysicalConnectionRequest {
	s.RedundantPhysicalConnectionId = &v
	return s
}

func (s *CreatePhysicalConnectionRequest) SetRegionId(v string) *CreatePhysicalConnectionRequest {
	s.RegionId = &v
	return s
}

func (s *CreatePhysicalConnectionRequest) SetResourceGroupId(v string) *CreatePhysicalConnectionRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *CreatePhysicalConnectionRequest) SetResourceOwnerAccount(v string) *CreatePhysicalConnectionRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreatePhysicalConnectionRequest) SetResourceOwnerId(v int64) *CreatePhysicalConnectionRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreatePhysicalConnectionRequest) SetTag(v []*CreatePhysicalConnectionRequestTag) *CreatePhysicalConnectionRequest {
	s.Tag = v
	return s
}

func (s *CreatePhysicalConnectionRequest) SetType(v string) *CreatePhysicalConnectionRequest {
	s.Type = &v
	return s
}

func (s *CreatePhysicalConnectionRequest) SetBandwidth(v int32) *CreatePhysicalConnectionRequest {
	s.Bandwidth = &v
	return s
}

type CreatePhysicalConnectionRequestTag struct {
	Key   *string `json:"Key,omitempty" xml:"Key,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreatePhysicalConnectionRequestTag) String() string {
	return tea.Prettify(s)
}

func (s CreatePhysicalConnectionRequestTag) GoString() string {
	return s.String()
}

func (s *CreatePhysicalConnectionRequestTag) SetKey(v string) *CreatePhysicalConnectionRequestTag {
	s.Key = &v
	return s
}

func (s *CreatePhysicalConnectionRequestTag) SetValue(v string) *CreatePhysicalConnectionRequestTag {
	s.Value = &v
	return s
}

type CreatePhysicalConnectionResponseBody struct {
	// The ID of the Express Connect circuit.
	PhysicalConnectionId *string `json:"PhysicalConnectionId,omitempty" xml:"PhysicalConnectionId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreatePhysicalConnectionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreatePhysicalConnectionResponseBody) GoString() string {
	return s.String()
}

func (s *CreatePhysicalConnectionResponseBody) SetPhysicalConnectionId(v string) *CreatePhysicalConnectionResponseBody {
	s.PhysicalConnectionId = &v
	return s
}

func (s *CreatePhysicalConnectionResponseBody) SetRequestId(v string) *CreatePhysicalConnectionResponseBody {
	s.RequestId = &v
	return s
}

type CreatePhysicalConnectionResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreatePhysicalConnectionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreatePhysicalConnectionResponse) String() string {
	return tea.Prettify(s)
}

func (s CreatePhysicalConnectionResponse) GoString() string {
	return s.String()
}

func (s *CreatePhysicalConnectionResponse) SetHeaders(v map[string]*string) *CreatePhysicalConnectionResponse {
	s.Headers = v
	return s
}

func (s *CreatePhysicalConnectionResponse) SetStatusCode(v int32) *CreatePhysicalConnectionResponse {
	s.StatusCode = &v
	return s
}

func (s *CreatePhysicalConnectionResponse) SetBody(v *CreatePhysicalConnectionResponseBody) *CreatePhysicalConnectionResponse {
	s.Body = v
	return s
}

type CreatePhysicalConnectionOccupancyOrderRequest struct {
	// Specifies whether to enable automatic payments. Valid values:
	//
	// *   **true**: yes Make sure that you have a sufficient balance in your account. Otherwise, your order becomes invalid and is automatically canceled.
	// *   **false**: disables automatic payment. This is the default value.
	AutoPay *bool `json:"AutoPay,omitempty" xml:"AutoPay,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must ensure that it is unique among different requests.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The billing method of the Express Connect circuit. Set the value to
	//
	// **PrePaid**, which specifies the subscription billing method. If you choose this billing method, make sure that your Alibaba Cloud account supports balance payments or credit payments.
	InstanceChargeType *string `json:"InstanceChargeType,omitempty" xml:"InstanceChargeType,omitempty"`
	OwnerAccount       *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId            *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The subscription duration.
	//
	// *   If **PricingCycle** is set to **Month**, set **Period** to a value from **1 to 9**.
	// *   If **PricingCycle** is set to **Year**, set **Period** to a value from **1 to 5**.
	Period *int32 `json:"Period,omitempty" xml:"Period,omitempty"`
	// The ID of the Express Connect circuit.
	PhysicalConnectionId *string `json:"PhysicalConnectionId,omitempty" xml:"PhysicalConnectionId,omitempty"`
	// The billing cycle of the subscription. Valid values:
	//
	// *   **Month**: Bills are paid on a monthly basis. This is the default value.
	// *   **Year**: Bills are paid on an annual basis.
	PricingCycle *string `json:"PricingCycle,omitempty" xml:"PricingCycle,omitempty"`
	// The region ID of the Express Connect circuit.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s CreatePhysicalConnectionOccupancyOrderRequest) String() string {
	return tea.Prettify(s)
}

func (s CreatePhysicalConnectionOccupancyOrderRequest) GoString() string {
	return s.String()
}

func (s *CreatePhysicalConnectionOccupancyOrderRequest) SetAutoPay(v bool) *CreatePhysicalConnectionOccupancyOrderRequest {
	s.AutoPay = &v
	return s
}

func (s *CreatePhysicalConnectionOccupancyOrderRequest) SetClientToken(v string) *CreatePhysicalConnectionOccupancyOrderRequest {
	s.ClientToken = &v
	return s
}

func (s *CreatePhysicalConnectionOccupancyOrderRequest) SetInstanceChargeType(v string) *CreatePhysicalConnectionOccupancyOrderRequest {
	s.InstanceChargeType = &v
	return s
}

func (s *CreatePhysicalConnectionOccupancyOrderRequest) SetOwnerAccount(v string) *CreatePhysicalConnectionOccupancyOrderRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreatePhysicalConnectionOccupancyOrderRequest) SetOwnerId(v int64) *CreatePhysicalConnectionOccupancyOrderRequest {
	s.OwnerId = &v
	return s
}

func (s *CreatePhysicalConnectionOccupancyOrderRequest) SetPeriod(v int32) *CreatePhysicalConnectionOccupancyOrderRequest {
	s.Period = &v
	return s
}

func (s *CreatePhysicalConnectionOccupancyOrderRequest) SetPhysicalConnectionId(v string) *CreatePhysicalConnectionOccupancyOrderRequest {
	s.PhysicalConnectionId = &v
	return s
}

func (s *CreatePhysicalConnectionOccupancyOrderRequest) SetPricingCycle(v string) *CreatePhysicalConnectionOccupancyOrderRequest {
	s.PricingCycle = &v
	return s
}

func (s *CreatePhysicalConnectionOccupancyOrderRequest) SetRegionId(v string) *CreatePhysicalConnectionOccupancyOrderRequest {
	s.RegionId = &v
	return s
}

func (s *CreatePhysicalConnectionOccupancyOrderRequest) SetResourceOwnerAccount(v string) *CreatePhysicalConnectionOccupancyOrderRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreatePhysicalConnectionOccupancyOrderRequest) SetResourceOwnerId(v int64) *CreatePhysicalConnectionOccupancyOrderRequest {
	s.ResourceOwnerId = &v
	return s
}

type CreatePhysicalConnectionOccupancyOrderResponseBody struct {
	// The details.
	Data *CreatePhysicalConnectionOccupancyOrderResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreatePhysicalConnectionOccupancyOrderResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreatePhysicalConnectionOccupancyOrderResponseBody) GoString() string {
	return s.String()
}

func (s *CreatePhysicalConnectionOccupancyOrderResponseBody) SetData(v *CreatePhysicalConnectionOccupancyOrderResponseBodyData) *CreatePhysicalConnectionOccupancyOrderResponseBody {
	s.Data = v
	return s
}

func (s *CreatePhysicalConnectionOccupancyOrderResponseBody) SetRequestId(v string) *CreatePhysicalConnectionOccupancyOrderResponseBody {
	s.RequestId = &v
	return s
}

type CreatePhysicalConnectionOccupancyOrderResponseBodyData struct {
	// The ID of the order that is placed.
	OrderId *string `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
}

func (s CreatePhysicalConnectionOccupancyOrderResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s CreatePhysicalConnectionOccupancyOrderResponseBodyData) GoString() string {
	return s.String()
}

func (s *CreatePhysicalConnectionOccupancyOrderResponseBodyData) SetOrderId(v string) *CreatePhysicalConnectionOccupancyOrderResponseBodyData {
	s.OrderId = &v
	return s
}

type CreatePhysicalConnectionOccupancyOrderResponse struct {
	Headers    map[string]*string                                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreatePhysicalConnectionOccupancyOrderResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreatePhysicalConnectionOccupancyOrderResponse) String() string {
	return tea.Prettify(s)
}

func (s CreatePhysicalConnectionOccupancyOrderResponse) GoString() string {
	return s.String()
}

func (s *CreatePhysicalConnectionOccupancyOrderResponse) SetHeaders(v map[string]*string) *CreatePhysicalConnectionOccupancyOrderResponse {
	s.Headers = v
	return s
}

func (s *CreatePhysicalConnectionOccupancyOrderResponse) SetStatusCode(v int32) *CreatePhysicalConnectionOccupancyOrderResponse {
	s.StatusCode = &v
	return s
}

func (s *CreatePhysicalConnectionOccupancyOrderResponse) SetBody(v *CreatePhysicalConnectionOccupancyOrderResponseBody) *CreatePhysicalConnectionOccupancyOrderResponse {
	s.Body = v
	return s
}

type CreatePhysicalConnectionSetupOrderRequest struct {
	// The ID of the access point.
	AccessPointId *string `json:"AccessPointId,omitempty" xml:"AccessPointId,omitempty"`
	// Specifies whether to enable automatic payment. Valid values:
	//
	// *   **false** (default): disables automatic payment.
	// *   **true**: enables automatic payment.
	AutoPay *bool `json:"AutoPay,omitempty" xml:"AutoPay,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. ClientToken can contain only ASCII characters.
	//
	// >  If you do not set this parameter, the system automatically uses **RequestId** as **ClientToken**. **RequestId** of each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The connectivity provider of the Express Connect circuit. Valid values:
	//
	// *   **CT**: China Telecom
	// *   **CU**: China Unicom
	// *   **CM**: China Mobile
	// *   **CO**: other connectivity providers in the Chinese mainland
	// *   **Equinix**: Equinix
	// *   **Other**: other connectivity providers outside the Chinese mainland
	LineOperator *string `json:"LineOperator,omitempty" xml:"LineOperator,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The port type. Valid values:
	//
	// *   **100Base-T**: 100 Mbit/s copper Ethernet port
	// *   **1000Base-T** (default): 1,000 Mbit/s copper Ethernet port
	// *   **1000Base-LX**: 1,000 Mbit/s single-mode optical port (10 km)
	// *   **10GBase-T**: 10,000 Mbit/s copper Ethernet port
	// *   **10GBase-LR**: 10,000 Mbit/s single-mode optical port (10 km)
	// *   **40GBase-LR**: 40,000 Mbit/s single-mode optical port
	// *   **100GBase-LR**: 100,000 Mbit/s single-mode optical port
	//
	// >  Whether 40GBase-LR and 100GBase-LR ports can be created is based on resource supplies. For more information, contact your business manager.
	PortType *string `json:"PortType,omitempty" xml:"PortType,omitempty"`
	// The ID of the redundant Express Connect circuit. The redundant Express Connect circuit must be in the **Allocated**, **Confirmed**, or **Enabled** state.
	RedundantPhysicalConnectionId *string `json:"RedundantPhysicalConnectionId,omitempty" xml:"RedundantPhysicalConnectionId,omitempty"`
	// The region ID of the Express Connect circuit.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s CreatePhysicalConnectionSetupOrderRequest) String() string {
	return tea.Prettify(s)
}

func (s CreatePhysicalConnectionSetupOrderRequest) GoString() string {
	return s.String()
}

func (s *CreatePhysicalConnectionSetupOrderRequest) SetAccessPointId(v string) *CreatePhysicalConnectionSetupOrderRequest {
	s.AccessPointId = &v
	return s
}

func (s *CreatePhysicalConnectionSetupOrderRequest) SetAutoPay(v bool) *CreatePhysicalConnectionSetupOrderRequest {
	s.AutoPay = &v
	return s
}

func (s *CreatePhysicalConnectionSetupOrderRequest) SetClientToken(v string) *CreatePhysicalConnectionSetupOrderRequest {
	s.ClientToken = &v
	return s
}

func (s *CreatePhysicalConnectionSetupOrderRequest) SetLineOperator(v string) *CreatePhysicalConnectionSetupOrderRequest {
	s.LineOperator = &v
	return s
}

func (s *CreatePhysicalConnectionSetupOrderRequest) SetOwnerAccount(v string) *CreatePhysicalConnectionSetupOrderRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreatePhysicalConnectionSetupOrderRequest) SetOwnerId(v int64) *CreatePhysicalConnectionSetupOrderRequest {
	s.OwnerId = &v
	return s
}

func (s *CreatePhysicalConnectionSetupOrderRequest) SetPortType(v string) *CreatePhysicalConnectionSetupOrderRequest {
	s.PortType = &v
	return s
}

func (s *CreatePhysicalConnectionSetupOrderRequest) SetRedundantPhysicalConnectionId(v string) *CreatePhysicalConnectionSetupOrderRequest {
	s.RedundantPhysicalConnectionId = &v
	return s
}

func (s *CreatePhysicalConnectionSetupOrderRequest) SetRegionId(v string) *CreatePhysicalConnectionSetupOrderRequest {
	s.RegionId = &v
	return s
}

func (s *CreatePhysicalConnectionSetupOrderRequest) SetResourceOwnerAccount(v string) *CreatePhysicalConnectionSetupOrderRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreatePhysicalConnectionSetupOrderRequest) SetResourceOwnerId(v int64) *CreatePhysicalConnectionSetupOrderRequest {
	s.ResourceOwnerId = &v
	return s
}

type CreatePhysicalConnectionSetupOrderResponseBody struct {
	// The ID of the order.
	OrderId *string `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The ID of the Express Connect circuit.
	PhysicalConnectionId *string `json:"PhysicalConnectionId,omitempty" xml:"PhysicalConnectionId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreatePhysicalConnectionSetupOrderResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreatePhysicalConnectionSetupOrderResponseBody) GoString() string {
	return s.String()
}

func (s *CreatePhysicalConnectionSetupOrderResponseBody) SetOrderId(v string) *CreatePhysicalConnectionSetupOrderResponseBody {
	s.OrderId = &v
	return s
}

func (s *CreatePhysicalConnectionSetupOrderResponseBody) SetPhysicalConnectionId(v string) *CreatePhysicalConnectionSetupOrderResponseBody {
	s.PhysicalConnectionId = &v
	return s
}

func (s *CreatePhysicalConnectionSetupOrderResponseBody) SetRequestId(v string) *CreatePhysicalConnectionSetupOrderResponseBody {
	s.RequestId = &v
	return s
}

type CreatePhysicalConnectionSetupOrderResponse struct {
	Headers    map[string]*string                              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreatePhysicalConnectionSetupOrderResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreatePhysicalConnectionSetupOrderResponse) String() string {
	return tea.Prettify(s)
}

func (s CreatePhysicalConnectionSetupOrderResponse) GoString() string {
	return s.String()
}

func (s *CreatePhysicalConnectionSetupOrderResponse) SetHeaders(v map[string]*string) *CreatePhysicalConnectionSetupOrderResponse {
	s.Headers = v
	return s
}

func (s *CreatePhysicalConnectionSetupOrderResponse) SetStatusCode(v int32) *CreatePhysicalConnectionSetupOrderResponse {
	s.StatusCode = &v
	return s
}

func (s *CreatePhysicalConnectionSetupOrderResponse) SetBody(v *CreatePhysicalConnectionSetupOrderResponseBody) *CreatePhysicalConnectionSetupOrderResponse {
	s.Body = v
	return s
}

type CreatePublicIpAddressPoolRequest struct {
	// The client token that you want to use to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that the value is unique among all requests. ClientToken can contain only ASCII characters.
	//
	// >  If you do not specify this parameter, the system uses **RequestId** as **ClientToken**. The value of **RequestId** for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The description of the IP address pool.
	//
	// This parameter is optional. The description must be 2 to 256 characters in length, and cannot start with http:// or https://.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// Specifies whether to perform a dry run. Valid values:
	//
	// *   **true**: performs a dry run. The system checks the required parameters, request syntax, and limits. If the request fails the dry run, an error message is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
	// *   **false** (default): performs a dry run and sends the request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The line type. Valid values:
	//
	// *   **BGP** (default): BGP (Multi-ISP) lines.
	// *   **BGP_PRO**: BGP (Multi-ISP) Pro lines
	//
	// For more information about BGP (Multi-ISP) and BGP (Multi-ISP) Pro, see [EIP line types](~~32321~~).
	//
	// *   If you are allowed to use single-ISP bandwidth, you can also choose one of the following values:
	//
	//     *   **ChinaTelecom**: China Telecom
	//     *   **ChinaUnicom**: China Unicom
	//     *   **ChinaMobile**: China Mobile
	//     *   **ChinaTelecom_L2**: China Telecom L2
	//     *   **ChinaUnicom_L2**: China Unicom L2
	//     *   **ChinaMobile_L2**: China Mobile L2
	//
	// *   If your services are deployed in China East 1 Finance, this parameter is required and you must set the value to **BGP_FinanceCloud**.
	Isp *string `json:"Isp,omitempty" xml:"Isp,omitempty"`
	// The name of the IP address pool.
	//
	// This parameter is optional. The name must be 1 to 128 characters in length, and can contain digits, periods (.), underscores (\_), and hyphens (-). The name must start with a letter but cannot start with `http://` or `https://`.
	Name         *string `json:"Name,omitempty" xml:"Name,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region where you want to create the IP address pool.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group to which the IP address pool belongs.
	ResourceGroupId      *string                                `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string                                `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64                                 `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	Tag                  []*CreatePublicIpAddressPoolRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s CreatePublicIpAddressPoolRequest) String() string {
	return tea.Prettify(s)
}

func (s CreatePublicIpAddressPoolRequest) GoString() string {
	return s.String()
}

func (s *CreatePublicIpAddressPoolRequest) SetClientToken(v string) *CreatePublicIpAddressPoolRequest {
	s.ClientToken = &v
	return s
}

func (s *CreatePublicIpAddressPoolRequest) SetDescription(v string) *CreatePublicIpAddressPoolRequest {
	s.Description = &v
	return s
}

func (s *CreatePublicIpAddressPoolRequest) SetDryRun(v bool) *CreatePublicIpAddressPoolRequest {
	s.DryRun = &v
	return s
}

func (s *CreatePublicIpAddressPoolRequest) SetIsp(v string) *CreatePublicIpAddressPoolRequest {
	s.Isp = &v
	return s
}

func (s *CreatePublicIpAddressPoolRequest) SetName(v string) *CreatePublicIpAddressPoolRequest {
	s.Name = &v
	return s
}

func (s *CreatePublicIpAddressPoolRequest) SetOwnerAccount(v string) *CreatePublicIpAddressPoolRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreatePublicIpAddressPoolRequest) SetOwnerId(v int64) *CreatePublicIpAddressPoolRequest {
	s.OwnerId = &v
	return s
}

func (s *CreatePublicIpAddressPoolRequest) SetRegionId(v string) *CreatePublicIpAddressPoolRequest {
	s.RegionId = &v
	return s
}

func (s *CreatePublicIpAddressPoolRequest) SetResourceGroupId(v string) *CreatePublicIpAddressPoolRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *CreatePublicIpAddressPoolRequest) SetResourceOwnerAccount(v string) *CreatePublicIpAddressPoolRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreatePublicIpAddressPoolRequest) SetResourceOwnerId(v int64) *CreatePublicIpAddressPoolRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreatePublicIpAddressPoolRequest) SetTag(v []*CreatePublicIpAddressPoolRequestTag) *CreatePublicIpAddressPoolRequest {
	s.Tag = v
	return s
}

type CreatePublicIpAddressPoolRequestTag struct {
	Key   *string `json:"Key,omitempty" xml:"Key,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreatePublicIpAddressPoolRequestTag) String() string {
	return tea.Prettify(s)
}

func (s CreatePublicIpAddressPoolRequestTag) GoString() string {
	return s.String()
}

func (s *CreatePublicIpAddressPoolRequestTag) SetKey(v string) *CreatePublicIpAddressPoolRequestTag {
	s.Key = &v
	return s
}

func (s *CreatePublicIpAddressPoolRequestTag) SetValue(v string) *CreatePublicIpAddressPoolRequestTag {
	s.Value = &v
	return s
}

type CreatePublicIpAddressPoolResponseBody struct {
	// The ID of the IP address pool.
	PulbicIpAddressPoolId *string `json:"PulbicIpAddressPoolId,omitempty" xml:"PulbicIpAddressPoolId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the resource group to which the IP address pool belongs.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
}

func (s CreatePublicIpAddressPoolResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreatePublicIpAddressPoolResponseBody) GoString() string {
	return s.String()
}

func (s *CreatePublicIpAddressPoolResponseBody) SetPulbicIpAddressPoolId(v string) *CreatePublicIpAddressPoolResponseBody {
	s.PulbicIpAddressPoolId = &v
	return s
}

func (s *CreatePublicIpAddressPoolResponseBody) SetRequestId(v string) *CreatePublicIpAddressPoolResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreatePublicIpAddressPoolResponseBody) SetResourceGroupId(v string) *CreatePublicIpAddressPoolResponseBody {
	s.ResourceGroupId = &v
	return s
}

type CreatePublicIpAddressPoolResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreatePublicIpAddressPoolResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreatePublicIpAddressPoolResponse) String() string {
	return tea.Prettify(s)
}

func (s CreatePublicIpAddressPoolResponse) GoString() string {
	return s.String()
}

func (s *CreatePublicIpAddressPoolResponse) SetHeaders(v map[string]*string) *CreatePublicIpAddressPoolResponse {
	s.Headers = v
	return s
}

func (s *CreatePublicIpAddressPoolResponse) SetStatusCode(v int32) *CreatePublicIpAddressPoolResponse {
	s.StatusCode = &v
	return s
}

func (s *CreatePublicIpAddressPoolResponse) SetBody(v *CreatePublicIpAddressPoolResponseBody) *CreatePublicIpAddressPoolResponse {
	s.Body = v
	return s
}

type CreateRouteEntriesRequest struct {
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region where the route table is created.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string                                  `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string                                  `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64                                   `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	RouteEntries         []*CreateRouteEntriesRequestRouteEntries `json:"RouteEntries,omitempty" xml:"RouteEntries,omitempty" type:"Repeated"`
}

func (s CreateRouteEntriesRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateRouteEntriesRequest) GoString() string {
	return s.String()
}

func (s *CreateRouteEntriesRequest) SetOwnerAccount(v string) *CreateRouteEntriesRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateRouteEntriesRequest) SetOwnerId(v int64) *CreateRouteEntriesRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateRouteEntriesRequest) SetRegionId(v string) *CreateRouteEntriesRequest {
	s.RegionId = &v
	return s
}

func (s *CreateRouteEntriesRequest) SetResourceOwnerAccount(v string) *CreateRouteEntriesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateRouteEntriesRequest) SetResourceOwnerId(v int64) *CreateRouteEntriesRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreateRouteEntriesRequest) SetRouteEntries(v []*CreateRouteEntriesRequestRouteEntries) *CreateRouteEntriesRequest {
	s.RouteEntries = v
	return s
}

type CreateRouteEntriesRequestRouteEntries struct {
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The destination CIDR block of the custom route entry. Both IPv4 and IPv6 CIDR blocks are supported. You can specify up to 50 destination CIDR blocks. Make sure that the destination CIDR block meets the following requirements:
	//
	// *   The destination CIDR block is not 100.64.0.0/10 or a subset of 100.64.0.0/10.
	// *   The destination CIDR block of the custom route entry is different from the destination CIDR blocks of other route entries in the same route table.
	DstCidrBlock *string `json:"DstCidrBlock,omitempty" xml:"DstCidrBlock,omitempty"`
	// The version of the IP protocol. You can specify up to 50 IP protocol versions. Valid values:
	//
	// *   **IPv4**
	// *   **IPv6**
	IpVersion *int32 `json:"IpVersion,omitempty" xml:"IpVersion,omitempty"`
	// The name of the custom route entry that you want to add. You can specify up to 50 names.
	//
	// The name must be 1 to 128 characters in length, and cannot start with `http://` or `https://`.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the next hop of the custom route entry. You can specify up to 50 next hop IDs.
	NextHop *string `json:"NextHop,omitempty" xml:"NextHop,omitempty"`
	// The type of next hop. You can specify up to 50 next hop types. Valid values:
	//
	// *   **Instance**: Elastic Compute Service (ECS) instance. This is the default value.
	// *   **HaVip**: high-availability virtual IP address (HAVIP).
	// *   **RouterInterface**: router interface.
	// *   **NetworkInterface**: elastic network interface (ENI).
	// *   **VpnGateway**: VPN gateway.
	// *   **IPv6Gateway**: IPv6 gateway.
	// *   **NatGateway**: NAT gateway.
	// *   **Attachment**: transit router.
	// *   **VpcPeer**: VPC peering connection.
	NextHopType *string `json:"NextHopType,omitempty" xml:"NextHopType,omitempty"`
	// The ID of the route table to which you want to add the custom route entry. You can specify up to 50 route table IDs.
	RouteTableId *string `json:"RouteTableId,omitempty" xml:"RouteTableId,omitempty"`
}

func (s CreateRouteEntriesRequestRouteEntries) String() string {
	return tea.Prettify(s)
}

func (s CreateRouteEntriesRequestRouteEntries) GoString() string {
	return s.String()
}

func (s *CreateRouteEntriesRequestRouteEntries) SetDescription(v string) *CreateRouteEntriesRequestRouteEntries {
	s.Description = &v
	return s
}

func (s *CreateRouteEntriesRequestRouteEntries) SetDstCidrBlock(v string) *CreateRouteEntriesRequestRouteEntries {
	s.DstCidrBlock = &v
	return s
}

func (s *CreateRouteEntriesRequestRouteEntries) SetIpVersion(v int32) *CreateRouteEntriesRequestRouteEntries {
	s.IpVersion = &v
	return s
}

func (s *CreateRouteEntriesRequestRouteEntries) SetName(v string) *CreateRouteEntriesRequestRouteEntries {
	s.Name = &v
	return s
}

func (s *CreateRouteEntriesRequestRouteEntries) SetNextHop(v string) *CreateRouteEntriesRequestRouteEntries {
	s.NextHop = &v
	return s
}

func (s *CreateRouteEntriesRequestRouteEntries) SetNextHopType(v string) *CreateRouteEntriesRequestRouteEntries {
	s.NextHopType = &v
	return s
}

func (s *CreateRouteEntriesRequestRouteEntries) SetRouteTableId(v string) *CreateRouteEntriesRequestRouteEntries {
	s.RouteTableId = &v
	return s
}

type CreateRouteEntriesResponseBody struct {
	// The number of custom route entries that failed to be added.
	FailedCount *int32 `json:"FailedCount,omitempty" xml:"FailedCount,omitempty"`
	// The details about the custom route entry that failed to be added.
	FailedRouteEntries []*CreateRouteEntriesResponseBodyFailedRouteEntries `json:"FailedRouteEntries,omitempty" xml:"FailedRouteEntries,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the custom route entry that was successfully added.
	RouteEntryIds []*string `json:"RouteEntryIds,omitempty" xml:"RouteEntryIds,omitempty" type:"Repeated"`
	// The number of custom route entries that were successfully added.
	SuccessCount *int32 `json:"SuccessCount,omitempty" xml:"SuccessCount,omitempty"`
}

func (s CreateRouteEntriesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateRouteEntriesResponseBody) GoString() string {
	return s.String()
}

func (s *CreateRouteEntriesResponseBody) SetFailedCount(v int32) *CreateRouteEntriesResponseBody {
	s.FailedCount = &v
	return s
}

func (s *CreateRouteEntriesResponseBody) SetFailedRouteEntries(v []*CreateRouteEntriesResponseBodyFailedRouteEntries) *CreateRouteEntriesResponseBody {
	s.FailedRouteEntries = v
	return s
}

func (s *CreateRouteEntriesResponseBody) SetRequestId(v string) *CreateRouteEntriesResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateRouteEntriesResponseBody) SetRouteEntryIds(v []*string) *CreateRouteEntriesResponseBody {
	s.RouteEntryIds = v
	return s
}

func (s *CreateRouteEntriesResponseBody) SetSuccessCount(v int32) *CreateRouteEntriesResponseBody {
	s.SuccessCount = &v
	return s
}

type CreateRouteEntriesResponseBodyFailedRouteEntries struct {
	// The destination CIDR block of the custom route entry that failed to be added.
	DstCidrBlock *string `json:"DstCidrBlock,omitempty" xml:"DstCidrBlock,omitempty"`
	// The error code.
	FailedCode *string `json:"FailedCode,omitempty" xml:"FailedCode,omitempty"`
	// The error message.
	FailedMessage *string `json:"FailedMessage,omitempty" xml:"FailedMessage,omitempty"`
	// The ID of the next hop of the custom route entry that failed to be added.
	NextHop *string `json:"NextHop,omitempty" xml:"NextHop,omitempty"`
}

func (s CreateRouteEntriesResponseBodyFailedRouteEntries) String() string {
	return tea.Prettify(s)
}

func (s CreateRouteEntriesResponseBodyFailedRouteEntries) GoString() string {
	return s.String()
}

func (s *CreateRouteEntriesResponseBodyFailedRouteEntries) SetDstCidrBlock(v string) *CreateRouteEntriesResponseBodyFailedRouteEntries {
	s.DstCidrBlock = &v
	return s
}

func (s *CreateRouteEntriesResponseBodyFailedRouteEntries) SetFailedCode(v string) *CreateRouteEntriesResponseBodyFailedRouteEntries {
	s.FailedCode = &v
	return s
}

func (s *CreateRouteEntriesResponseBodyFailedRouteEntries) SetFailedMessage(v string) *CreateRouteEntriesResponseBodyFailedRouteEntries {
	s.FailedMessage = &v
	return s
}

func (s *CreateRouteEntriesResponseBodyFailedRouteEntries) SetNextHop(v string) *CreateRouteEntriesResponseBodyFailedRouteEntries {
	s.NextHop = &v
	return s
}

type CreateRouteEntriesResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateRouteEntriesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateRouteEntriesResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateRouteEntriesResponse) GoString() string {
	return s.String()
}

func (s *CreateRouteEntriesResponse) SetHeaders(v map[string]*string) *CreateRouteEntriesResponse {
	s.Headers = v
	return s
}

func (s *CreateRouteEntriesResponse) SetStatusCode(v int32) *CreateRouteEntriesResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateRouteEntriesResponse) SetBody(v *CreateRouteEntriesResponseBody) *CreateRouteEntriesResponse {
	s.Body = v
	return s
}

type CreateRouteEntryRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that the value is unique among different requests. The ClientToken value can contain only ASCII characters.
	//
	// >  If you do not specify this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The description of the custom route entry.
	//
	// The description must be 1 to 256 characters in length, and cannot start with `http://` or `https://`.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The destination CIDR block of the custom route entry. Both IPv4 and IPv6 CIDR blocks are supported. Make sure that the destination CIDR block meets the following requirements:
	//
	// *   The destination CIDR block is not 100.64.0.0/10 or a subset of 100.64.0.0/10.
	// *   The destination CIDR block of the custom route entry is different from the destination CIDR blocks of other route entries in the same route table.
	DestinationCidrBlock *string `json:"DestinationCidrBlock,omitempty" xml:"DestinationCidrBlock,omitempty"`
	// The ID of the next hop.
	NextHopId   *string                               `json:"NextHopId,omitempty" xml:"NextHopId,omitempty"`
	NextHopList []*CreateRouteEntryRequestNextHopList `json:"NextHopList,omitempty" xml:"NextHopList,omitempty" type:"Repeated"`
	// The type of next hop of the custom route entry. Valid values:
	//
	// *   **Instance**: an Elastic Compute Service (ECS) instance. This is the default value.
	// *   **HaVip**: a high-availability virtual IP address (HAVIP).
	// *   **RouterInterface**: a router interface.
	// *   **NetworkInterface**: an elastic network interface (ENI).
	// *   **VpnGateway**: a VPN gateway.
	// *   **IPv6Gateway**: an IPv6 gateway.
	// *   **NatGateway**: a NAT gateway.
	// *   **Attachment**: a transit router.
	// *   **VpcPeer**: a VPC peering connection.
	NextHopType  *string `json:"NextHopType,omitempty" xml:"NextHopType,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the route table.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The name of the custom route entry that you want to add.
	//
	// The name must be 1 to 128 characters in length, and cannot start with `http://` or `https://`.
	RouteEntryName *string `json:"RouteEntryName,omitempty" xml:"RouteEntryName,omitempty"`
	// The ID of the route table to which you want to add a custom route entry.
	RouteTableId *string `json:"RouteTableId,omitempty" xml:"RouteTableId,omitempty"`
}

func (s CreateRouteEntryRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateRouteEntryRequest) GoString() string {
	return s.String()
}

func (s *CreateRouteEntryRequest) SetClientToken(v string) *CreateRouteEntryRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateRouteEntryRequest) SetDescription(v string) *CreateRouteEntryRequest {
	s.Description = &v
	return s
}

func (s *CreateRouteEntryRequest) SetDestinationCidrBlock(v string) *CreateRouteEntryRequest {
	s.DestinationCidrBlock = &v
	return s
}

func (s *CreateRouteEntryRequest) SetNextHopId(v string) *CreateRouteEntryRequest {
	s.NextHopId = &v
	return s
}

func (s *CreateRouteEntryRequest) SetNextHopList(v []*CreateRouteEntryRequestNextHopList) *CreateRouteEntryRequest {
	s.NextHopList = v
	return s
}

func (s *CreateRouteEntryRequest) SetNextHopType(v string) *CreateRouteEntryRequest {
	s.NextHopType = &v
	return s
}

func (s *CreateRouteEntryRequest) SetOwnerAccount(v string) *CreateRouteEntryRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateRouteEntryRequest) SetOwnerId(v int64) *CreateRouteEntryRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateRouteEntryRequest) SetRegionId(v string) *CreateRouteEntryRequest {
	s.RegionId = &v
	return s
}

func (s *CreateRouteEntryRequest) SetResourceOwnerAccount(v string) *CreateRouteEntryRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateRouteEntryRequest) SetResourceOwnerId(v int64) *CreateRouteEntryRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreateRouteEntryRequest) SetRouteEntryName(v string) *CreateRouteEntryRequest {
	s.RouteEntryName = &v
	return s
}

func (s *CreateRouteEntryRequest) SetRouteTableId(v string) *CreateRouteEntryRequest {
	s.RouteTableId = &v
	return s
}

type CreateRouteEntryRequestNextHopList struct {
	// The ID of the next hop of the ECMP route.
	NextHopId *string `json:"NextHopId,omitempty" xml:"NextHopId,omitempty"`
	// The type of next hop of the ECMP route entry. Set the value to **RouterInterface**.
	NextHopType *string `json:"NextHopType,omitempty" xml:"NextHopType,omitempty"`
	// The weight of the next hop of the ECMP route entry.
	Weight *int32 `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s CreateRouteEntryRequestNextHopList) String() string {
	return tea.Prettify(s)
}

func (s CreateRouteEntryRequestNextHopList) GoString() string {
	return s.String()
}

func (s *CreateRouteEntryRequestNextHopList) SetNextHopId(v string) *CreateRouteEntryRequestNextHopList {
	s.NextHopId = &v
	return s
}

func (s *CreateRouteEntryRequestNextHopList) SetNextHopType(v string) *CreateRouteEntryRequestNextHopList {
	s.NextHopType = &v
	return s
}

func (s *CreateRouteEntryRequestNextHopList) SetWeight(v int32) *CreateRouteEntryRequestNextHopList {
	s.Weight = &v
	return s
}

type CreateRouteEntryResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the custom route entry.
	RouteEntryId *string `json:"RouteEntryId,omitempty" xml:"RouteEntryId,omitempty"`
}

func (s CreateRouteEntryResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateRouteEntryResponseBody) GoString() string {
	return s.String()
}

func (s *CreateRouteEntryResponseBody) SetRequestId(v string) *CreateRouteEntryResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateRouteEntryResponseBody) SetRouteEntryId(v string) *CreateRouteEntryResponseBody {
	s.RouteEntryId = &v
	return s
}

type CreateRouteEntryResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateRouteEntryResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateRouteEntryResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateRouteEntryResponse) GoString() string {
	return s.String()
}

func (s *CreateRouteEntryResponse) SetHeaders(v map[string]*string) *CreateRouteEntryResponse {
	s.Headers = v
	return s
}

func (s *CreateRouteEntryResponse) SetStatusCode(v int32) *CreateRouteEntryResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateRouteEntryResponse) SetBody(v *CreateRouteEntryResponseBody) *CreateRouteEntryResponse {
	s.Body = v
	return s
}

type CreateRouteTableRequest struct {
	// The type of the route table. Valid values:
	//
	// *   **VSwitch** (default): vSwitch route table
	// *   **Gateway**: gateway route table
	AssociateType *string `json:"AssociateType,omitempty" xml:"AssociateType,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can contain only ASCII characters.
	//
	// >  If you do not specify this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** in each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The description of the route table.
	//
	// The description must be 1 to 256 characters in length, and cannot start with `http://` or `https://`.
	Description  *string `json:"Description,omitempty" xml:"Description,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the virtual private cloud (VPC) to which the custom route table belongs.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The name of the route table.
	//
	// The name must be 1 to 128 characters in length, and cannot start with `http://` or `https://`.
	RouteTableName *string                       `json:"RouteTableName,omitempty" xml:"RouteTableName,omitempty"`
	Tag            []*CreateRouteTableRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
	// The ID of the VPC to which the custom route table belongs.
	//
	// If a VPC contains an Elastic Compute Service (ECS) instance that belongs to one of the following instance families, you cannot create a custom route table for the VPC:
	//
	// ecs.c1, ecs.c2, ecs.c4, ecs.ce4, ecs.cm4, ecs.d1, ecs.e3, ecs.e4, ecs.ga1, ecs.gn4, ecs.gn5, ecs.i1, ecs.m1, ecs.m2, ecs.mn4, ecs.n1, ecs.n2, ecs.n4, ecs.s1, ecs.s2, ecs.s3, ecs.se1, ecs.sn1, ecs.sn2, ecs.t1, and ecs.xn4
	//
	// You must upgrade or release the ECS instance before you can create a custom route table for the VPC.
	//
	// *   For more information about how to upgrade an ECS instance, see [Upgrade subscription instances](~~25438~~) and [Change specifications of pay-as-you-go instances](~~60051~~).
	// *   For more information about how to release an ECS instance, see [Release an ECS instance](~~25442~~).
	//
	// >  If a custom route table is created for a VPC that contains an ECS instance from one of the preceding instance families, you must upgrade or release the ECS instance. Otherwise, the custom route table cannot work as expected.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s CreateRouteTableRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateRouteTableRequest) GoString() string {
	return s.String()
}

func (s *CreateRouteTableRequest) SetAssociateType(v string) *CreateRouteTableRequest {
	s.AssociateType = &v
	return s
}

func (s *CreateRouteTableRequest) SetClientToken(v string) *CreateRouteTableRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateRouteTableRequest) SetDescription(v string) *CreateRouteTableRequest {
	s.Description = &v
	return s
}

func (s *CreateRouteTableRequest) SetOwnerAccount(v string) *CreateRouteTableRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateRouteTableRequest) SetOwnerId(v int64) *CreateRouteTableRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateRouteTableRequest) SetRegionId(v string) *CreateRouteTableRequest {
	s.RegionId = &v
	return s
}

func (s *CreateRouteTableRequest) SetResourceOwnerAccount(v string) *CreateRouteTableRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateRouteTableRequest) SetResourceOwnerId(v int64) *CreateRouteTableRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreateRouteTableRequest) SetRouteTableName(v string) *CreateRouteTableRequest {
	s.RouteTableName = &v
	return s
}

func (s *CreateRouteTableRequest) SetTag(v []*CreateRouteTableRequestTag) *CreateRouteTableRequest {
	s.Tag = v
	return s
}

func (s *CreateRouteTableRequest) SetVpcId(v string) *CreateRouteTableRequest {
	s.VpcId = &v
	return s
}

type CreateRouteTableRequestTag struct {
	Key   *string `json:"Key,omitempty" xml:"Key,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateRouteTableRequestTag) String() string {
	return tea.Prettify(s)
}

func (s CreateRouteTableRequestTag) GoString() string {
	return s.String()
}

func (s *CreateRouteTableRequestTag) SetKey(v string) *CreateRouteTableRequestTag {
	s.Key = &v
	return s
}

func (s *CreateRouteTableRequestTag) SetValue(v string) *CreateRouteTableRequestTag {
	s.Value = &v
	return s
}

type CreateRouteTableResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The IDs of the route tables.
	RouteTableId *string `json:"RouteTableId,omitempty" xml:"RouteTableId,omitempty"`
}

func (s CreateRouteTableResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateRouteTableResponseBody) GoString() string {
	return s.String()
}

func (s *CreateRouteTableResponseBody) SetRequestId(v string) *CreateRouteTableResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateRouteTableResponseBody) SetRouteTableId(v string) *CreateRouteTableResponseBody {
	s.RouteTableId = &v
	return s
}

type CreateRouteTableResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateRouteTableResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateRouteTableResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateRouteTableResponse) GoString() string {
	return s.String()
}

func (s *CreateRouteTableResponse) SetHeaders(v map[string]*string) *CreateRouteTableResponse {
	s.Headers = v
	return s
}

func (s *CreateRouteTableResponse) SetStatusCode(v int32) *CreateRouteTableResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateRouteTableResponse) SetBody(v *CreateRouteTableResponseBody) *CreateRouteTableResponse {
	s.Body = v
	return s
}

type CreateRouterInterfaceRequest struct {
	// The ID of the access point to which the VBR belongs.
	//
	// You can call the [DescribeAccessPoints](~~36062~~) operation to query the most recent access point list.
	//
	// >  This parameter is required if an Express Connect circuit is used.
	AccessPointId *string `json:"AccessPointId,omitempty" xml:"AccessPointId,omitempty"`
	// Specifies whether to enable automatic payment. Valid values:
	//
	// *   **false** (default): disables automatic payment. If you select this option, you must go to the Order Center to complete the payment after an order is generated.
	// *   **true**: enables automatic payment. Payments are automatically completed.
	//
	// >  This parameter is required if **InstanceChargeType** is set to **PrePaid**.
	AutoPay   *bool `json:"AutoPay,omitempty" xml:"AutoPay,omitempty"`
	AutoRenew *bool `json:"AutoRenew,omitempty" xml:"AutoRenew,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests.
	//
	// >  If you do not set this parameter, ClientToken is set to the value of RequestId. The value of RequestId for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The description of the router interface.
	//
	// The description must be 2 to 256 characters in length. The description must start with a letter but cannot start with `http://` or `https://`.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// Indicates whether the VBR that is created in the Fast Link mode is uplinked to the router interface. The Fast Link mode helps automatically connect router interfaces that are created for the VBR and its peer VPC. Valid values:
	//
	// *   **true**: yes
	// *   **false**: no
	//
	// >
	// *   This parameter takes effect only if **RouterType** is set to **VBR** and **OppositeRouterType** is set to **VRouter**.
	// *   If **FastLinkMode** is set to **true**, **Role** must be set to **InitiatingSide**. **AccessPointId**, **OppositeRouterType**, **OpppsiteRouterId**, and **OppositeInterfaceOwnerId** are required.
	FastLinkMode *bool `json:"FastLinkMode,omitempty" xml:"FastLinkMode,omitempty"`
	// The source IP address that is used to perform health checks. The source IP address must be an idle IP address of the local virtual private cloud (VPC).
	//
	// >  You can set this parameter if an Express Connect circuit is used.
	HealthCheckSourceIp *string `json:"HealthCheckSourceIp,omitempty" xml:"HealthCheckSourceIp,omitempty"`
	// The destination IP address that is used to perform health checks.
	//
	// >  This parameter is required if the **HealthCheckSourceIp** parameter is set.
	HealthCheckTargetIp *string `json:"HealthCheckTargetIp,omitempty" xml:"HealthCheckTargetIp,omitempty"`
	// The billing method of the router interface. Valid values:
	//
	// *   **PrePaid**: subscription
	// *   **PostPaid**: pay-as-you-go
	InstanceChargeType *string `json:"InstanceChargeType,omitempty" xml:"InstanceChargeType,omitempty"`
	// The name of the router interface.
	//
	// The name must be 2 to 128 characters in length and can contain letters, digits, periods (.), underscores (\_), and hyphens (-). The name must start with a letter.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the access point to which the peer belongs.
	//
	// >  This parameter is required if the peer router interface is associated with a VBR. The specified value cannot be changed after the router interface is created.
	OppositeAccessPointId *string `json:"OppositeAccessPointId,omitempty" xml:"OppositeAccessPointId,omitempty"`
	// The ID of the peer router interface.
	OppositeInterfaceId *string `json:"OppositeInterfaceId,omitempty" xml:"OppositeInterfaceId,omitempty"`
	// The ID of the Alibaba Cloud account to which the peer router interface belongs.
	OppositeInterfaceOwnerId *string `json:"OppositeInterfaceOwnerId,omitempty" xml:"OppositeInterfaceOwnerId,omitempty"`
	// The ID of the region where the acceptor is deployed.
	OppositeRegionId *string `json:"OppositeRegionId,omitempty" xml:"OppositeRegionId,omitempty"`
	// The ID of the peer router.
	OppositeRouterId *string `json:"OppositeRouterId,omitempty" xml:"OppositeRouterId,omitempty"`
	// The type of router that is associated with the peer router interface. Valid values:
	//
	// *   **VRouter**
	// *   **VBR**
	OppositeRouterType *string `json:"OppositeRouterType,omitempty" xml:"OppositeRouterType,omitempty"`
	OwnerAccount       *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId            *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The subscription duration. Valid values:
	//
	// *   Valid values if the PricingCycle parameter is set to Month: **1 to 9**.
	// *   Valid values if the PricingCycle parameter is set to Year: **1 to 3**.
	//
	// >  This parameter is required if **InstanceChargeType** is set to **PrePaid**.
	Period *int32 `json:"Period,omitempty" xml:"Period,omitempty"`
	// The billing cycle of the subscription. Valid values:
	//
	// *   **Month** (default): monthly subscription
	// *   **Year**: annual subscription
	//
	// >  This parameter is required if **InstanceChargeType** is set to **PrePaid**.
	PricingCycle *string `json:"PricingCycle,omitempty" xml:"PricingCycle,omitempty"`
	// The ID of the region to which the router interface belongs.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The role of the router interface. Valid values:
	//
	// *   **InitiatingSide**: requester
	// *   **AcceptingSide**: acceptor
	Role *string `json:"Role,omitempty" xml:"Role,omitempty"`
	// The ID of the router that is associated with the router interface.
	RouterId *string `json:"RouterId,omitempty" xml:"RouterId,omitempty"`
	// The type of router associated with the router interface. Valid values:
	//
	// *   **VRouter**
	// *   **VBR**
	RouterType *string `json:"RouterType,omitempty" xml:"RouterType,omitempty"`
	// The specification of the router interface. Valid specifications and bandwidth values:
	//
	// *   **Mini.2**: 2 Mbit/s
	// *   **Mini.5**: 5 Mbit/s
	// *   **Small.1**: 10 Mbit/s
	// *   **Small.2**: 20 Mbit/s
	// *   **Small.5**: 50 Mbit/s
	// *   **Middle.1**: 100 Mbit/s
	// *   **Middle.2**: 200 Mbit/s
	// *   **Middle.5**: 500 Mbit/s
	// *   **Large.1**: 1,000 Mbit/s
	// *   **Large.2**: 2,000 Mbit/s
	// *   **Large.5**: 5,000 Mbit/s
	// *   **Xlarge.1**: 10,000 Mbit/s
	//
	// >  If **Role** is set to **AcceptingSide** (acceptor), set **Spec** to **Negative**. You do not need to specify specifications when you create an acceptor router interface.
	Spec *string                             `json:"Spec,omitempty" xml:"Spec,omitempty"`
	Tags []*CreateRouterInterfaceRequestTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
}

func (s CreateRouterInterfaceRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateRouterInterfaceRequest) GoString() string {
	return s.String()
}

func (s *CreateRouterInterfaceRequest) SetAccessPointId(v string) *CreateRouterInterfaceRequest {
	s.AccessPointId = &v
	return s
}

func (s *CreateRouterInterfaceRequest) SetAutoPay(v bool) *CreateRouterInterfaceRequest {
	s.AutoPay = &v
	return s
}

func (s *CreateRouterInterfaceRequest) SetAutoRenew(v bool) *CreateRouterInterfaceRequest {
	s.AutoRenew = &v
	return s
}

func (s *CreateRouterInterfaceRequest) SetClientToken(v string) *CreateRouterInterfaceRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateRouterInterfaceRequest) SetDescription(v string) *CreateRouterInterfaceRequest {
	s.Description = &v
	return s
}

func (s *CreateRouterInterfaceRequest) SetFastLinkMode(v bool) *CreateRouterInterfaceRequest {
	s.FastLinkMode = &v
	return s
}

func (s *CreateRouterInterfaceRequest) SetHealthCheckSourceIp(v string) *CreateRouterInterfaceRequest {
	s.HealthCheckSourceIp = &v
	return s
}

func (s *CreateRouterInterfaceRequest) SetHealthCheckTargetIp(v string) *CreateRouterInterfaceRequest {
	s.HealthCheckTargetIp = &v
	return s
}

func (s *CreateRouterInterfaceRequest) SetInstanceChargeType(v string) *CreateRouterInterfaceRequest {
	s.InstanceChargeType = &v
	return s
}

func (s *CreateRouterInterfaceRequest) SetName(v string) *CreateRouterInterfaceRequest {
	s.Name = &v
	return s
}

func (s *CreateRouterInterfaceRequest) SetOppositeAccessPointId(v string) *CreateRouterInterfaceRequest {
	s.OppositeAccessPointId = &v
	return s
}

func (s *CreateRouterInterfaceRequest) SetOppositeInterfaceId(v string) *CreateRouterInterfaceRequest {
	s.OppositeInterfaceId = &v
	return s
}

func (s *CreateRouterInterfaceRequest) SetOppositeInterfaceOwnerId(v string) *CreateRouterInterfaceRequest {
	s.OppositeInterfaceOwnerId = &v
	return s
}

func (s *CreateRouterInterfaceRequest) SetOppositeRegionId(v string) *CreateRouterInterfaceRequest {
	s.OppositeRegionId = &v
	return s
}

func (s *CreateRouterInterfaceRequest) SetOppositeRouterId(v string) *CreateRouterInterfaceRequest {
	s.OppositeRouterId = &v
	return s
}

func (s *CreateRouterInterfaceRequest) SetOppositeRouterType(v string) *CreateRouterInterfaceRequest {
	s.OppositeRouterType = &v
	return s
}

func (s *CreateRouterInterfaceRequest) SetOwnerAccount(v string) *CreateRouterInterfaceRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateRouterInterfaceRequest) SetOwnerId(v int64) *CreateRouterInterfaceRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateRouterInterfaceRequest) SetPeriod(v int32) *CreateRouterInterfaceRequest {
	s.Period = &v
	return s
}

func (s *CreateRouterInterfaceRequest) SetPricingCycle(v string) *CreateRouterInterfaceRequest {
	s.PricingCycle = &v
	return s
}

func (s *CreateRouterInterfaceRequest) SetRegionId(v string) *CreateRouterInterfaceRequest {
	s.RegionId = &v
	return s
}

func (s *CreateRouterInterfaceRequest) SetResourceGroupId(v string) *CreateRouterInterfaceRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *CreateRouterInterfaceRequest) SetResourceOwnerAccount(v string) *CreateRouterInterfaceRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateRouterInterfaceRequest) SetResourceOwnerId(v int64) *CreateRouterInterfaceRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreateRouterInterfaceRequest) SetRole(v string) *CreateRouterInterfaceRequest {
	s.Role = &v
	return s
}

func (s *CreateRouterInterfaceRequest) SetRouterId(v string) *CreateRouterInterfaceRequest {
	s.RouterId = &v
	return s
}

func (s *CreateRouterInterfaceRequest) SetRouterType(v string) *CreateRouterInterfaceRequest {
	s.RouterType = &v
	return s
}

func (s *CreateRouterInterfaceRequest) SetSpec(v string) *CreateRouterInterfaceRequest {
	s.Spec = &v
	return s
}

func (s *CreateRouterInterfaceRequest) SetTags(v []*CreateRouterInterfaceRequestTags) *CreateRouterInterfaceRequest {
	s.Tags = v
	return s
}

type CreateRouterInterfaceRequestTags struct {
	Key   *string `json:"Key,omitempty" xml:"Key,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateRouterInterfaceRequestTags) String() string {
	return tea.Prettify(s)
}

func (s CreateRouterInterfaceRequestTags) GoString() string {
	return s.String()
}

func (s *CreateRouterInterfaceRequestTags) SetKey(v string) *CreateRouterInterfaceRequestTags {
	s.Key = &v
	return s
}

func (s *CreateRouterInterfaceRequestTags) SetValue(v string) *CreateRouterInterfaceRequestTags {
	s.Value = &v
	return s
}

type CreateRouterInterfaceResponseBody struct {
	// The order number. This parameter is returned if InstanceChargeType is set to PrePaid.
	OrderId *int64 `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the router interface.
	RouterInterfaceId *string `json:"RouterInterfaceId,omitempty" xml:"RouterInterfaceId,omitempty"`
}

func (s CreateRouterInterfaceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateRouterInterfaceResponseBody) GoString() string {
	return s.String()
}

func (s *CreateRouterInterfaceResponseBody) SetOrderId(v int64) *CreateRouterInterfaceResponseBody {
	s.OrderId = &v
	return s
}

func (s *CreateRouterInterfaceResponseBody) SetRequestId(v string) *CreateRouterInterfaceResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateRouterInterfaceResponseBody) SetRouterInterfaceId(v string) *CreateRouterInterfaceResponseBody {
	s.RouterInterfaceId = &v
	return s
}

type CreateRouterInterfaceResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateRouterInterfaceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateRouterInterfaceResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateRouterInterfaceResponse) GoString() string {
	return s.String()
}

func (s *CreateRouterInterfaceResponse) SetHeaders(v map[string]*string) *CreateRouterInterfaceResponse {
	s.Headers = v
	return s
}

func (s *CreateRouterInterfaceResponse) SetStatusCode(v int32) *CreateRouterInterfaceResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateRouterInterfaceResponse) SetBody(v *CreateRouterInterfaceResponseBody) *CreateRouterInterfaceResponse {
	s.Body = v
	return s
}

type CreateSnatEntryRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. `The token can contain only ASCII characters.`
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to enable EIP affinity. Valid values:
	//
	// *   **0**: no
	// *   **1**: yes
	//
	// >  If EIP affinity is enabled and the SNAT entry is associated with multiple EIPs, a client uses the same EIP to access the Internet. Otherwise, the client uses an EIP selected from the associated EIPs to access the Internet.
	EipAffinity  *int32  `json:"EipAffinity,omitempty" xml:"EipAffinity,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region where the NAT gateway is deployed.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// Enter a name for the SNAT entry.
	//
	// The name must be 2 to 128 characters in length. It must start with a letter but cannot start with `http://` or `https://`.
	SnatEntryName *string `json:"SnatEntryName,omitempty" xml:"SnatEntryName,omitempty"`
	// *   The EIPs in the SNAT entry when you add an SNAT entry to an Internet NAT gateway. Separate EIPs with commas (,).
	//
	// >  If you select multiple EIPs to create an SNAT address pool, connections are hashed to these EIPs. Network traffic may not be evenly distributed to the EIPs because the amount of traffic that passes through each connection varies. We recommend that you associate these EIPs with the same EIP bandwidth plan to prevent service interruptions due to the bandwidth limit of an individual EIP.
	//
	// *   When you add an SNAT entry to a VPC NAT gateway, this parameter specifies the NAT IP address in the SNAT entry.
	SnatIp *string `json:"SnatIp,omitempty" xml:"SnatIp,omitempty"`
	// The ID of the SNAT table.
	SnatTableId *string `json:"SnatTableId,omitempty" xml:"SnatTableId,omitempty"`
	// You can specify the CIDR block of a VPC, a vSwitch, or an ECS instance or enter a custom CIDR block.
	//
	// You can specify an SNAT entry in the following ways:
	//
	// *   You can specify the CIDR block of the VPC where the NAT gateway is deployed. Then, all ECS instances in the VPC can access the Internet or external networks by using SNAT.
	// *   You can specify the CIDR block of a vSwitch, for example, 192.168.1.0/24. Then, the ECS instances in the vSwitch can access the Internet or external networks by using SNAT.
	// *   You can specify the IP address of an ECS instance, for example, 192.168.1.1/32. Then, the ECS instance can access the Internet or external networks by using SNAT.
	// *   You can specify a custom CIDR block. Then, all ECS instances within the specified CIDR block can access the Internet or external networks by using SNAT.
	//
	// When you add an SNAT entry to an Internet NAT gateway, if **SnatIp** is set to an EIP, the ECS instance uses the specified EIP to access the Internet.
	//
	// If **SnatIp** is set to multiple EIPs, the ECS instance randomly selects an EIP specified in the **SnatIp** parameter to access the Internet.
	//
	// You cannot set this parameter and **SourceVSwtichId** at the same time. If the **SourceVSwitchId** parameter is set, you cannot set the **SourceCIDR** parameter. If the **SourceCIDR** parameter is set, you cannot set the **SourceVSwitchId** parameter.
	SourceCIDR *string `json:"SourceCIDR,omitempty" xml:"SourceCIDR,omitempty"`
	// The ID of the vSwitch.
	//
	// *   When you add an SNAT entry to an Internet NAT gateway, this parameter specifies that ECS instances in the vSwitch can use the SNAT entry to access the Internet. If you select multiple elastic IP addresses (EIPs) to create an SNAT address pool, connections are hashed to these EIPs. Network traffic may not be evenly distributed to the EIPs because the amount of traffic that passes through each connection varies. We recommend that you associate these EIPs with the same EIP bandwidth plan to prevent service interruptions due to the bandwidth limits on individual EIPs.
	// *   When you add an SNAT entry to a VPC NAT gateway, this parameter specifies that ECS instances in the vSwitch can use the SNAT entry to access external networks.
	SourceVSwitchId *string `json:"SourceVSwitchId,omitempty" xml:"SourceVSwitchId,omitempty"`
}

func (s CreateSnatEntryRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateSnatEntryRequest) GoString() string {
	return s.String()
}

func (s *CreateSnatEntryRequest) SetClientToken(v string) *CreateSnatEntryRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateSnatEntryRequest) SetEipAffinity(v int32) *CreateSnatEntryRequest {
	s.EipAffinity = &v
	return s
}

func (s *CreateSnatEntryRequest) SetOwnerAccount(v string) *CreateSnatEntryRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateSnatEntryRequest) SetOwnerId(v int64) *CreateSnatEntryRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateSnatEntryRequest) SetRegionId(v string) *CreateSnatEntryRequest {
	s.RegionId = &v
	return s
}

func (s *CreateSnatEntryRequest) SetResourceOwnerAccount(v string) *CreateSnatEntryRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateSnatEntryRequest) SetResourceOwnerId(v int64) *CreateSnatEntryRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreateSnatEntryRequest) SetSnatEntryName(v string) *CreateSnatEntryRequest {
	s.SnatEntryName = &v
	return s
}

func (s *CreateSnatEntryRequest) SetSnatIp(v string) *CreateSnatEntryRequest {
	s.SnatIp = &v
	return s
}

func (s *CreateSnatEntryRequest) SetSnatTableId(v string) *CreateSnatEntryRequest {
	s.SnatTableId = &v
	return s
}

func (s *CreateSnatEntryRequest) SetSourceCIDR(v string) *CreateSnatEntryRequest {
	s.SourceCIDR = &v
	return s
}

func (s *CreateSnatEntryRequest) SetSourceVSwitchId(v string) *CreateSnatEntryRequest {
	s.SourceVSwitchId = &v
	return s
}

type CreateSnatEntryResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the SNAT entry.
	SnatEntryId *string `json:"SnatEntryId,omitempty" xml:"SnatEntryId,omitempty"`
}

func (s CreateSnatEntryResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateSnatEntryResponseBody) GoString() string {
	return s.String()
}

func (s *CreateSnatEntryResponseBody) SetRequestId(v string) *CreateSnatEntryResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateSnatEntryResponseBody) SetSnatEntryId(v string) *CreateSnatEntryResponseBody {
	s.SnatEntryId = &v
	return s
}

type CreateSnatEntryResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateSnatEntryResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateSnatEntryResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateSnatEntryResponse) GoString() string {
	return s.String()
}

func (s *CreateSnatEntryResponse) SetHeaders(v map[string]*string) *CreateSnatEntryResponse {
	s.Headers = v
	return s
}

func (s *CreateSnatEntryResponse) SetStatusCode(v int32) *CreateSnatEntryResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateSnatEntryResponse) SetBody(v *CreateSnatEntryResponseBody) *CreateSnatEntryResponse {
	s.Body = v
	return s
}

type CreateSslVpnClientCertRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The name of the SSL client certificate.
	//
	// The name must be 1 to 100 characters in length, and cannot start with `http://` or `https://`.
	Name         *string `json:"Name,omitempty" xml:"Name,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region where the VPN gateway is created.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the SSL server.
	SslVpnServerId *string `json:"SslVpnServerId,omitempty" xml:"SslVpnServerId,omitempty"`
}

func (s CreateSslVpnClientCertRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateSslVpnClientCertRequest) GoString() string {
	return s.String()
}

func (s *CreateSslVpnClientCertRequest) SetClientToken(v string) *CreateSslVpnClientCertRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateSslVpnClientCertRequest) SetName(v string) *CreateSslVpnClientCertRequest {
	s.Name = &v
	return s
}

func (s *CreateSslVpnClientCertRequest) SetOwnerAccount(v string) *CreateSslVpnClientCertRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateSslVpnClientCertRequest) SetOwnerId(v int64) *CreateSslVpnClientCertRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateSslVpnClientCertRequest) SetRegionId(v string) *CreateSslVpnClientCertRequest {
	s.RegionId = &v
	return s
}

func (s *CreateSslVpnClientCertRequest) SetResourceOwnerAccount(v string) *CreateSslVpnClientCertRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateSslVpnClientCertRequest) SetResourceOwnerId(v int64) *CreateSslVpnClientCertRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreateSslVpnClientCertRequest) SetSslVpnServerId(v string) *CreateSslVpnClientCertRequest {
	s.SslVpnServerId = &v
	return s
}

type CreateSslVpnClientCertResponseBody struct {
	// The name of the SSL client certificate.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the SSL client certificate.
	SslVpnClientCertId *string `json:"SslVpnClientCertId,omitempty" xml:"SslVpnClientCertId,omitempty"`
}

func (s CreateSslVpnClientCertResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateSslVpnClientCertResponseBody) GoString() string {
	return s.String()
}

func (s *CreateSslVpnClientCertResponseBody) SetName(v string) *CreateSslVpnClientCertResponseBody {
	s.Name = &v
	return s
}

func (s *CreateSslVpnClientCertResponseBody) SetRequestId(v string) *CreateSslVpnClientCertResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateSslVpnClientCertResponseBody) SetSslVpnClientCertId(v string) *CreateSslVpnClientCertResponseBody {
	s.SslVpnClientCertId = &v
	return s
}

type CreateSslVpnClientCertResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateSslVpnClientCertResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateSslVpnClientCertResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateSslVpnClientCertResponse) GoString() string {
	return s.String()
}

func (s *CreateSslVpnClientCertResponse) SetHeaders(v map[string]*string) *CreateSslVpnClientCertResponse {
	s.Headers = v
	return s
}

func (s *CreateSslVpnClientCertResponse) SetStatusCode(v int32) *CreateSslVpnClientCertResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateSslVpnClientCertResponse) SetBody(v *CreateSslVpnClientCertResponseBody) *CreateSslVpnClientCertResponse {
	s.Body = v
	return s
}

type CreateSslVpnServerRequest struct {
	// The encryption algorithm that is used in the SSL-VPN connection. Valid values:
	//
	// *   **AES-128-CBC** (default): AES-128-CBC
	// *   **AES-192-CBC**: AES-192-CBC
	// *   **AES-256-CBC**: AES-256-CBC
	// *   **none**: does not use an encryption algorithm.
	Cipher *string `json:"Cipher,omitempty" xml:"Cipher,omitempty"`
	// The client CIDR block.
	//
	// The CIDR block that is allocated to the virtual network interface of the client. It is not the CIDR block where the client resides.
	//
	// When the client accesses the destination network through an SSL-VPN connection, the VPN gateway allocates an IP address from the client CIDR block to the client.
	//
	// >  This CIDR block cannot conflict with the CIDR block specified by **LocalSubnet**.
	ClientIpPool *string `json:"ClientIpPool,omitempty" xml:"ClientIpPool,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. ClientToken can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to enable data compression. Valid values:
	//
	// *   **true**: yes
	// *   **false** (default): no
	Compress *bool `json:"Compress,omitempty" xml:"Compress,omitempty"`
	// Specifies whether to enable two-factor authentication. Valid values:
	//
	// *   **true**: yes
	// *   **false** (default): no
	//
	// >  To enable two-factor authentication, make sure that the VPN gateway was created after 00:00:00 (UTC+8), March 5, 2020. Otherwise, two-factor authentication is not supported.
	EnableMultiFactorAuth *bool `json:"EnableMultiFactorAuth,omitempty" xml:"EnableMultiFactorAuth,omitempty"`
	// The ID of the IDaaS instance.
	IDaaSInstanceId *string `json:"IDaaSInstanceId,omitempty" xml:"IDaaSInstanceId,omitempty"`
	// The ID of the region where the IDaaS instance is created.
	IDaaSRegionId *string `json:"IDaaSRegionId,omitempty" xml:"IDaaSRegionId,omitempty"`
	// The local CIDR block.
	//
	// The CIDR block to be accessed by the client through the SSL-VPN connection.
	//
	// This value can be the CIDR block of a virtual private cloud (VPC), a vSwitch, a data center that is connected to a VPC through an Express Connect circuit, or Object Storage Service (OSS).
	LocalSubnet *string `json:"LocalSubnet,omitempty" xml:"LocalSubnet,omitempty"`
	// The name of the SSL server.
	//
	// The name must be 1 to 100 characters in length, and cannot start with `http://` or `https://`.
	Name         *string `json:"Name,omitempty" xml:"Name,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The port used by the SSL server. Default value: **1194**. The following ports cannot be used:
	//
	// **22, 2222, 22222, 9000, 9001, 9002, 7505, 80, 443, 53, 68, 123, 4510, 4560, 500, and 4500**.
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
	// The protocol that is used by the SSL server. Valid values:
	//
	// *   **TCP**: TCP
	// *   **UDP** (default): UDP
	Proto *string `json:"Proto,omitempty" xml:"Proto,omitempty"`
	// The ID of the region where the VPN gateway is created.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the VPN gateway.
	VpnGatewayId *string `json:"VpnGatewayId,omitempty" xml:"VpnGatewayId,omitempty"`
}

func (s CreateSslVpnServerRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateSslVpnServerRequest) GoString() string {
	return s.String()
}

func (s *CreateSslVpnServerRequest) SetCipher(v string) *CreateSslVpnServerRequest {
	s.Cipher = &v
	return s
}

func (s *CreateSslVpnServerRequest) SetClientIpPool(v string) *CreateSslVpnServerRequest {
	s.ClientIpPool = &v
	return s
}

func (s *CreateSslVpnServerRequest) SetClientToken(v string) *CreateSslVpnServerRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateSslVpnServerRequest) SetCompress(v bool) *CreateSslVpnServerRequest {
	s.Compress = &v
	return s
}

func (s *CreateSslVpnServerRequest) SetEnableMultiFactorAuth(v bool) *CreateSslVpnServerRequest {
	s.EnableMultiFactorAuth = &v
	return s
}

func (s *CreateSslVpnServerRequest) SetIDaaSInstanceId(v string) *CreateSslVpnServerRequest {
	s.IDaaSInstanceId = &v
	return s
}

func (s *CreateSslVpnServerRequest) SetIDaaSRegionId(v string) *CreateSslVpnServerRequest {
	s.IDaaSRegionId = &v
	return s
}

func (s *CreateSslVpnServerRequest) SetLocalSubnet(v string) *CreateSslVpnServerRequest {
	s.LocalSubnet = &v
	return s
}

func (s *CreateSslVpnServerRequest) SetName(v string) *CreateSslVpnServerRequest {
	s.Name = &v
	return s
}

func (s *CreateSslVpnServerRequest) SetOwnerAccount(v string) *CreateSslVpnServerRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateSslVpnServerRequest) SetOwnerId(v int64) *CreateSslVpnServerRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateSslVpnServerRequest) SetPort(v int32) *CreateSslVpnServerRequest {
	s.Port = &v
	return s
}

func (s *CreateSslVpnServerRequest) SetProto(v string) *CreateSslVpnServerRequest {
	s.Proto = &v
	return s
}

func (s *CreateSslVpnServerRequest) SetRegionId(v string) *CreateSslVpnServerRequest {
	s.RegionId = &v
	return s
}

func (s *CreateSslVpnServerRequest) SetResourceOwnerAccount(v string) *CreateSslVpnServerRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateSslVpnServerRequest) SetResourceOwnerId(v int64) *CreateSslVpnServerRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreateSslVpnServerRequest) SetVpnGatewayId(v string) *CreateSslVpnServerRequest {
	s.VpnGatewayId = &v
	return s
}

type CreateSslVpnServerResponseBody struct {
	// The name of the SSL server.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the SSL server.
	SslVpnServerId *string `json:"SslVpnServerId,omitempty" xml:"SslVpnServerId,omitempty"`
}

func (s CreateSslVpnServerResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateSslVpnServerResponseBody) GoString() string {
	return s.String()
}

func (s *CreateSslVpnServerResponseBody) SetName(v string) *CreateSslVpnServerResponseBody {
	s.Name = &v
	return s
}

func (s *CreateSslVpnServerResponseBody) SetRequestId(v string) *CreateSslVpnServerResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateSslVpnServerResponseBody) SetSslVpnServerId(v string) *CreateSslVpnServerResponseBody {
	s.SslVpnServerId = &v
	return s
}

type CreateSslVpnServerResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateSslVpnServerResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateSslVpnServerResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateSslVpnServerResponse) GoString() string {
	return s.String()
}

func (s *CreateSslVpnServerResponse) SetHeaders(v map[string]*string) *CreateSslVpnServerResponse {
	s.Headers = v
	return s
}

func (s *CreateSslVpnServerResponse) SetStatusCode(v int32) *CreateSslVpnServerResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateSslVpnServerResponse) SetBody(v *CreateSslVpnServerResponseBody) *CreateSslVpnServerResponse {
	s.Body = v
	return s
}

type CreateTrafficMirrorFilterRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must ensure that the value is unique among all requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, the system uses **RequestId** as **ClientToken**. **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to perform a dry run. Valid values:
	//
	// *   **true**: performs a dry run. The system checks the required parameters, request syntax, and limits. If the request fails the dry run, an error message is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
	// *   **false**: performs a dry run and sends the request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed. This is the default value.
	DryRun       *bool                                           `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	EgressRules  []*CreateTrafficMirrorFilterRequestEgressRules  `json:"EgressRules,omitempty" xml:"EgressRules,omitempty" type:"Repeated"`
	IngressRules []*CreateTrafficMirrorFilterRequestIngressRules `json:"IngressRules,omitempty" xml:"IngressRules,omitempty" type:"Repeated"`
	OwnerAccount *string                                         `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64                                          `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region to which the mirrored traffic belongs.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list. For more information about regions that support traffic mirroring, see [Overview of traffic mirroring](~~207513~~).
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group to which the mirrored traffic belongs.
	ResourceGroupId      *string                                `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string                                `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64                                 `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	Tag                  []*CreateTrafficMirrorFilterRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
	// The description of the filter.
	//
	// The description must be 1 to 256 characters in length and cannot start with `http://` or `https://`.
	TrafficMirrorFilterDescription *string `json:"TrafficMirrorFilterDescription,omitempty" xml:"TrafficMirrorFilterDescription,omitempty"`
	// The name of the filter.
	//
	// The name must be 1 to 128 characters in length, and cannot start with `http://` or `https://`.
	TrafficMirrorFilterName *string `json:"TrafficMirrorFilterName,omitempty" xml:"TrafficMirrorFilterName,omitempty"`
}

func (s CreateTrafficMirrorFilterRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateTrafficMirrorFilterRequest) GoString() string {
	return s.String()
}

func (s *CreateTrafficMirrorFilterRequest) SetClientToken(v string) *CreateTrafficMirrorFilterRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateTrafficMirrorFilterRequest) SetDryRun(v bool) *CreateTrafficMirrorFilterRequest {
	s.DryRun = &v
	return s
}

func (s *CreateTrafficMirrorFilterRequest) SetEgressRules(v []*CreateTrafficMirrorFilterRequestEgressRules) *CreateTrafficMirrorFilterRequest {
	s.EgressRules = v
	return s
}

func (s *CreateTrafficMirrorFilterRequest) SetIngressRules(v []*CreateTrafficMirrorFilterRequestIngressRules) *CreateTrafficMirrorFilterRequest {
	s.IngressRules = v
	return s
}

func (s *CreateTrafficMirrorFilterRequest) SetOwnerAccount(v string) *CreateTrafficMirrorFilterRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateTrafficMirrorFilterRequest) SetOwnerId(v int64) *CreateTrafficMirrorFilterRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateTrafficMirrorFilterRequest) SetRegionId(v string) *CreateTrafficMirrorFilterRequest {
	s.RegionId = &v
	return s
}

func (s *CreateTrafficMirrorFilterRequest) SetResourceGroupId(v string) *CreateTrafficMirrorFilterRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *CreateTrafficMirrorFilterRequest) SetResourceOwnerAccount(v string) *CreateTrafficMirrorFilterRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateTrafficMirrorFilterRequest) SetResourceOwnerId(v int64) *CreateTrafficMirrorFilterRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreateTrafficMirrorFilterRequest) SetTag(v []*CreateTrafficMirrorFilterRequestTag) *CreateTrafficMirrorFilterRequest {
	s.Tag = v
	return s
}

func (s *CreateTrafficMirrorFilterRequest) SetTrafficMirrorFilterDescription(v string) *CreateTrafficMirrorFilterRequest {
	s.TrafficMirrorFilterDescription = &v
	return s
}

func (s *CreateTrafficMirrorFilterRequest) SetTrafficMirrorFilterName(v string) *CreateTrafficMirrorFilterRequest {
	s.TrafficMirrorFilterName = &v
	return s
}

type CreateTrafficMirrorFilterRequestEgressRules struct {
	// The action of the outbound rule. Valid values:
	//
	// *   **accept**: collects network traffic.
	// *   **drop**: does not collect network traffic.
	Action *string `json:"Action,omitempty" xml:"Action,omitempty"`
	// The destination CIDR block of the outbound traffic.
	DestinationCidrBlock *string `json:"DestinationCidrBlock,omitempty" xml:"DestinationCidrBlock,omitempty"`
	// The destination port range of the outbound traffic. Valid values for a port: **1** to **65535**. Separate the first port and the last port with a forward slash (/). Examples: **1/200** and **80/80**. You cannot set this parameter to only **-1/-1**. The value -1/-1 specifies all ports.
	//
	// >  If you set **EgressRules.N.Protocol** to **ALL** or **ICMP**, you do not need to set this parameter. In this case, all ports are available.
	DestinationPortRange *string `json:"DestinationPortRange,omitempty" xml:"DestinationPortRange,omitempty"`
	// The priority of the outbound rule. A smaller value indicates a higher priority.
	//
	// The maximum value of **N** is **10**. You can configure up to 10 outbound rules for a filter.
	Priority *int32 `json:"Priority,omitempty" xml:"Priority,omitempty"`
	// The protocol that is used by the outbound traffic to be mirrored. Valid values:
	//
	// *   **ALL**: all protocols
	// *   **ICMP**: ICMP
	// *   **TCP**: TCP
	// *   **UDP**: UDP
	Protocol *string `json:"Protocol,omitempty" xml:"Protocol,omitempty"`
	// The source CIDR block of the outbound traffic.
	SourceCidrBlock *string `json:"SourceCidrBlock,omitempty" xml:"SourceCidrBlock,omitempty"`
	// The source port range of the outbound traffic. Valid values for a port: **1** to **65535**. Separate the first port and the last port with a forward slash (/). Examples: **1/200** and **80/80**. You cannot set this parameter to only **-1/-1**. The value -1/-1 specifies all ports.
	//
	// >  If you set **EgressRules.N.Protocol** to **ALL** or **ICMP**, you do not need to set this parameter. In this case, all ports are available.
	SourcePortRange *string `json:"SourcePortRange,omitempty" xml:"SourcePortRange,omitempty"`
}

func (s CreateTrafficMirrorFilterRequestEgressRules) String() string {
	return tea.Prettify(s)
}

func (s CreateTrafficMirrorFilterRequestEgressRules) GoString() string {
	return s.String()
}

func (s *CreateTrafficMirrorFilterRequestEgressRules) SetAction(v string) *CreateTrafficMirrorFilterRequestEgressRules {
	s.Action = &v
	return s
}

func (s *CreateTrafficMirrorFilterRequestEgressRules) SetDestinationCidrBlock(v string) *CreateTrafficMirrorFilterRequestEgressRules {
	s.DestinationCidrBlock = &v
	return s
}

func (s *CreateTrafficMirrorFilterRequestEgressRules) SetDestinationPortRange(v string) *CreateTrafficMirrorFilterRequestEgressRules {
	s.DestinationPortRange = &v
	return s
}

func (s *CreateTrafficMirrorFilterRequestEgressRules) SetPriority(v int32) *CreateTrafficMirrorFilterRequestEgressRules {
	s.Priority = &v
	return s
}

func (s *CreateTrafficMirrorFilterRequestEgressRules) SetProtocol(v string) *CreateTrafficMirrorFilterRequestEgressRules {
	s.Protocol = &v
	return s
}

func (s *CreateTrafficMirrorFilterRequestEgressRules) SetSourceCidrBlock(v string) *CreateTrafficMirrorFilterRequestEgressRules {
	s.SourceCidrBlock = &v
	return s
}

func (s *CreateTrafficMirrorFilterRequestEgressRules) SetSourcePortRange(v string) *CreateTrafficMirrorFilterRequestEgressRules {
	s.SourcePortRange = &v
	return s
}

type CreateTrafficMirrorFilterRequestIngressRules struct {
	// The action of the inbound rule. Valid values:
	//
	// *   **accept**: collects network traffic.
	// *   **drop**: does not collect network traffic.
	Action *string `json:"Action,omitempty" xml:"Action,omitempty"`
	// The destination CIDR block of the inbound traffic.
	DestinationCidrBlock *string `json:"DestinationCidrBlock,omitempty" xml:"DestinationCidrBlock,omitempty"`
	// The destination port range of the inbound traffic. Valid values for a port: **1** to **65535**. Separate the first port and the last port with a forward slash (/). Examples: **1/200** and **80/80**.
	//
	// >  If you set **IngressRules.N.Protocol** to **ALL** or **ICMP**, you do not need to set this parameter. In this case, all ports are available.
	DestinationPortRange *string `json:"DestinationPortRange,omitempty" xml:"DestinationPortRange,omitempty"`
	// The priority of the inbound rule. A smaller value indicates a higher priority.
	//
	// The maximum value of **N** is **10**. You can configure up to 10 inbound rules for a filter.
	Priority *int32 `json:"Priority,omitempty" xml:"Priority,omitempty"`
	// The protocol that is used by the inbound traffic to be mirrored. Valid values:
	//
	// *   **ALL**: all protocols
	// *   **ICMP**: ICMP
	// *   **TCP**: TCP
	// *   **UDP**: UDP
	Protocol *string `json:"Protocol,omitempty" xml:"Protocol,omitempty"`
	// The source CIDR block of the inbound traffic.
	SourceCidrBlock *string `json:"SourceCidrBlock,omitempty" xml:"SourceCidrBlock,omitempty"`
	// The source port range of the inbound traffic. Valid values for a port: **1** to **65535**. Separate the first port and the last port with a forward slash (/). Examples: **1/200** and **80/80**.
	//
	// >  If you set **IngressRules.N.Protocol** to **ALL** or **ICMP**, you do not need to set this parameter. In this case, all ports are available.
	SourcePortRange *string `json:"SourcePortRange,omitempty" xml:"SourcePortRange,omitempty"`
}

func (s CreateTrafficMirrorFilterRequestIngressRules) String() string {
	return tea.Prettify(s)
}

func (s CreateTrafficMirrorFilterRequestIngressRules) GoString() string {
	return s.String()
}

func (s *CreateTrafficMirrorFilterRequestIngressRules) SetAction(v string) *CreateTrafficMirrorFilterRequestIngressRules {
	s.Action = &v
	return s
}

func (s *CreateTrafficMirrorFilterRequestIngressRules) SetDestinationCidrBlock(v string) *CreateTrafficMirrorFilterRequestIngressRules {
	s.DestinationCidrBlock = &v
	return s
}

func (s *CreateTrafficMirrorFilterRequestIngressRules) SetDestinationPortRange(v string) *CreateTrafficMirrorFilterRequestIngressRules {
	s.DestinationPortRange = &v
	return s
}

func (s *CreateTrafficMirrorFilterRequestIngressRules) SetPriority(v int32) *CreateTrafficMirrorFilterRequestIngressRules {
	s.Priority = &v
	return s
}

func (s *CreateTrafficMirrorFilterRequestIngressRules) SetProtocol(v string) *CreateTrafficMirrorFilterRequestIngressRules {
	s.Protocol = &v
	return s
}

func (s *CreateTrafficMirrorFilterRequestIngressRules) SetSourceCidrBlock(v string) *CreateTrafficMirrorFilterRequestIngressRules {
	s.SourceCidrBlock = &v
	return s
}

func (s *CreateTrafficMirrorFilterRequestIngressRules) SetSourcePortRange(v string) *CreateTrafficMirrorFilterRequestIngressRules {
	s.SourcePortRange = &v
	return s
}

type CreateTrafficMirrorFilterRequestTag struct {
	Key   *string `json:"Key,omitempty" xml:"Key,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateTrafficMirrorFilterRequestTag) String() string {
	return tea.Prettify(s)
}

func (s CreateTrafficMirrorFilterRequestTag) GoString() string {
	return s.String()
}

func (s *CreateTrafficMirrorFilterRequestTag) SetKey(v string) *CreateTrafficMirrorFilterRequestTag {
	s.Key = &v
	return s
}

func (s *CreateTrafficMirrorFilterRequestTag) SetValue(v string) *CreateTrafficMirrorFilterRequestTag {
	s.Value = &v
	return s
}

type CreateTrafficMirrorFilterResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the resource group to which the mirrored traffic belongs.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The ID of the filter.
	TrafficMirrorFilterId *string `json:"TrafficMirrorFilterId,omitempty" xml:"TrafficMirrorFilterId,omitempty"`
}

func (s CreateTrafficMirrorFilterResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateTrafficMirrorFilterResponseBody) GoString() string {
	return s.String()
}

func (s *CreateTrafficMirrorFilterResponseBody) SetRequestId(v string) *CreateTrafficMirrorFilterResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateTrafficMirrorFilterResponseBody) SetResourceGroupId(v string) *CreateTrafficMirrorFilterResponseBody {
	s.ResourceGroupId = &v
	return s
}

func (s *CreateTrafficMirrorFilterResponseBody) SetTrafficMirrorFilterId(v string) *CreateTrafficMirrorFilterResponseBody {
	s.TrafficMirrorFilterId = &v
	return s
}

type CreateTrafficMirrorFilterResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateTrafficMirrorFilterResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateTrafficMirrorFilterResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateTrafficMirrorFilterResponse) GoString() string {
	return s.String()
}

func (s *CreateTrafficMirrorFilterResponse) SetHeaders(v map[string]*string) *CreateTrafficMirrorFilterResponse {
	s.Headers = v
	return s
}

func (s *CreateTrafficMirrorFilterResponse) SetStatusCode(v int32) *CreateTrafficMirrorFilterResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateTrafficMirrorFilterResponse) SetBody(v *CreateTrafficMirrorFilterResponseBody) *CreateTrafficMirrorFilterResponse {
	s.Body = v
	return s
}

type CreateTrafficMirrorFilterRulesRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, the system uses **RequestId** as **ClientToken**. **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to check the request without performing the operation. Valid values:
	//
	// *   **true**: checks the request without performing the operation. The system checks the required parameters, request format, and limits. If the request fails the precheck, an error message is returned. If the request passes the precheck, the `DryRunOperation` error code is returned.
	// *   **false** (default): sends the request. After the request passes the check, the operation is performed.
	DryRun       *bool                                                `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	EgressRules  []*CreateTrafficMirrorFilterRulesRequestEgressRules  `json:"EgressRules,omitempty" xml:"EgressRules,omitempty" type:"Repeated"`
	IngressRules []*CreateTrafficMirrorFilterRulesRequestIngressRules `json:"IngressRules,omitempty" xml:"IngressRules,omitempty" type:"Repeated"`
	OwnerAccount *string                                              `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64                                               `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region to which the mirrored traffic belongs.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list. For more information about regions that support traffic mirroring, see [Overview of traffic mirroring](~~207513~~).
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the filter.
	TrafficMirrorFilterId *string `json:"TrafficMirrorFilterId,omitempty" xml:"TrafficMirrorFilterId,omitempty"`
}

func (s CreateTrafficMirrorFilterRulesRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateTrafficMirrorFilterRulesRequest) GoString() string {
	return s.String()
}

func (s *CreateTrafficMirrorFilterRulesRequest) SetClientToken(v string) *CreateTrafficMirrorFilterRulesRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateTrafficMirrorFilterRulesRequest) SetDryRun(v bool) *CreateTrafficMirrorFilterRulesRequest {
	s.DryRun = &v
	return s
}

func (s *CreateTrafficMirrorFilterRulesRequest) SetEgressRules(v []*CreateTrafficMirrorFilterRulesRequestEgressRules) *CreateTrafficMirrorFilterRulesRequest {
	s.EgressRules = v
	return s
}

func (s *CreateTrafficMirrorFilterRulesRequest) SetIngressRules(v []*CreateTrafficMirrorFilterRulesRequestIngressRules) *CreateTrafficMirrorFilterRulesRequest {
	s.IngressRules = v
	return s
}

func (s *CreateTrafficMirrorFilterRulesRequest) SetOwnerAccount(v string) *CreateTrafficMirrorFilterRulesRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateTrafficMirrorFilterRulesRequest) SetOwnerId(v int64) *CreateTrafficMirrorFilterRulesRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateTrafficMirrorFilterRulesRequest) SetRegionId(v string) *CreateTrafficMirrorFilterRulesRequest {
	s.RegionId = &v
	return s
}

func (s *CreateTrafficMirrorFilterRulesRequest) SetResourceOwnerAccount(v string) *CreateTrafficMirrorFilterRulesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateTrafficMirrorFilterRulesRequest) SetResourceOwnerId(v int64) *CreateTrafficMirrorFilterRulesRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreateTrafficMirrorFilterRulesRequest) SetTrafficMirrorFilterId(v string) *CreateTrafficMirrorFilterRulesRequest {
	s.TrafficMirrorFilterId = &v
	return s
}

type CreateTrafficMirrorFilterRulesRequestEgressRules struct {
	// The action of the outbound rule. Valid values:
	//
	// *   **accept**: accepts network traffic.
	// *   **drop**: drops network traffic.
	Action *string `json:"Action,omitempty" xml:"Action,omitempty"`
	// The destination CIDR block of the outbound traffic.
	DestinationCidrBlock *string `json:"DestinationCidrBlock,omitempty" xml:"DestinationCidrBlock,omitempty"`
	// The destination port range of the outbound traffic. Valid values for a port: **1** to **65535**. Separate the first port and the last port with a forward slash (/). Examples: **1/200** and **80/80**. You cannot set this parameter to only **-1/-1**, which specifies all ports.
	//
	// >  If you set **EgressRules.N.Protocol** to **ALL** or **ICMP**, you do not need to set this parameter. In this case, all ports are available.
	DestinationPortRange *string `json:"DestinationPortRange,omitempty" xml:"DestinationPortRange,omitempty"`
	// The priority of the outbound rule. A smaller value indicates a higher priority. The maximum value of **N** is **10**. You can configure up to 10 outbound rules for a filter.
	Priority *int32 `json:"Priority,omitempty" xml:"Priority,omitempty"`
	// The protocol that is used by the outbound traffic to be mirrored. Valid values:
	//
	// *   **ALL**: all protocols
	// *   **ICMP**: ICMP
	// *   **TCP**: TCP
	// *   **UDP**: UDP
	Protocol *string `json:"Protocol,omitempty" xml:"Protocol,omitempty"`
	// The source CIDR block of the outbound traffic.
	SourceCidrBlock *string `json:"SourceCidrBlock,omitempty" xml:"SourceCidrBlock,omitempty"`
	// The source port range of the outbound traffic. Valid values for a port: **1** to **65535**. Separate the first port and the last port with a forward slash (/). Examples: **1/200** and **80/80**. You cannot set this parameter to only **-1/-1**, which specifies all ports.
	//
	// >  If you set **EgressRules.N.Protocol** to **ALL** or **ICMP**, you do not need to set this parameter. In this case, all ports are available.
	SourcePortRange *string `json:"SourcePortRange,omitempty" xml:"SourcePortRange,omitempty"`
}

func (s CreateTrafficMirrorFilterRulesRequestEgressRules) String() string {
	return tea.Prettify(s)
}

func (s CreateTrafficMirrorFilterRulesRequestEgressRules) GoString() string {
	return s.String()
}

func (s *CreateTrafficMirrorFilterRulesRequestEgressRules) SetAction(v string) *CreateTrafficMirrorFilterRulesRequestEgressRules {
	s.Action = &v
	return s
}

func (s *CreateTrafficMirrorFilterRulesRequestEgressRules) SetDestinationCidrBlock(v string) *CreateTrafficMirrorFilterRulesRequestEgressRules {
	s.DestinationCidrBlock = &v
	return s
}

func (s *CreateTrafficMirrorFilterRulesRequestEgressRules) SetDestinationPortRange(v string) *CreateTrafficMirrorFilterRulesRequestEgressRules {
	s.DestinationPortRange = &v
	return s
}

func (s *CreateTrafficMirrorFilterRulesRequestEgressRules) SetPriority(v int32) *CreateTrafficMirrorFilterRulesRequestEgressRules {
	s.Priority = &v
	return s
}

func (s *CreateTrafficMirrorFilterRulesRequestEgressRules) SetProtocol(v string) *CreateTrafficMirrorFilterRulesRequestEgressRules {
	s.Protocol = &v
	return s
}

func (s *CreateTrafficMirrorFilterRulesRequestEgressRules) SetSourceCidrBlock(v string) *CreateTrafficMirrorFilterRulesRequestEgressRules {
	s.SourceCidrBlock = &v
	return s
}

func (s *CreateTrafficMirrorFilterRulesRequestEgressRules) SetSourcePortRange(v string) *CreateTrafficMirrorFilterRulesRequestEgressRules {
	s.SourcePortRange = &v
	return s
}

type CreateTrafficMirrorFilterRulesRequestIngressRules struct {
	// The action of the inbound rule. Valid values:
	//
	// *   **accept**: accepts network traffic.
	// *   **drop**: drops network traffic.
	Action *string `json:"Action,omitempty" xml:"Action,omitempty"`
	// The destination CIDR block of the inbound traffic.
	DestinationCidrBlock *string `json:"DestinationCidrBlock,omitempty" xml:"DestinationCidrBlock,omitempty"`
	// The destination port range of the inbound traffic. Valid values for a port: **1** to **65535**. Separate the first port and the last port with a forward slash (/). Examples: **1/200** and **80/80**.
	//
	// >  If you set **IngressRules.N.Protocol** to **ALL** or **ICMP**, you do not need to set this parameter. In this case, all ports are available.
	DestinationPortRange *string `json:"DestinationPortRange,omitempty" xml:"DestinationPortRange,omitempty"`
	// The priority of the inbound rule. A smaller value indicates a higher priority. The maximum value of **N** is **10**. You can configure up to 10 inbound rules for a filter.
	Priority *int32 `json:"Priority,omitempty" xml:"Priority,omitempty"`
	// The protocol that is used by the inbound traffic to be mirrored. Valid values:
	//
	// *   **ALL**: all protocols
	// *   **ICMP**: Internet Control Message Protocol (ICMP)
	// *   **TCP**: TCP
	// *   **UDP**: User Datagram Protocol (UDP)
	Protocol *string `json:"Protocol,omitempty" xml:"Protocol,omitempty"`
	// The source CIDR block of the inbound traffic.
	SourceCidrBlock *string `json:"SourceCidrBlock,omitempty" xml:"SourceCidrBlock,omitempty"`
	// The source port range of the inbound traffic. Valid values for a port: **1** to **65535**. Separate the first port and the last port with a forward slash (/). Examples: **1/200** and **80/80**. You cannot set this parameter to only **-1/-1**, which specifies all ports.
	//
	// >  If you set **IngressRules.N.Protocol** to **ALL** or **ICMP**, you do not need to set this parameter. In this case, all ports are available.
	SourcePortRange *string `json:"SourcePortRange,omitempty" xml:"SourcePortRange,omitempty"`
}

func (s CreateTrafficMirrorFilterRulesRequestIngressRules) String() string {
	return tea.Prettify(s)
}

func (s CreateTrafficMirrorFilterRulesRequestIngressRules) GoString() string {
	return s.String()
}

func (s *CreateTrafficMirrorFilterRulesRequestIngressRules) SetAction(v string) *CreateTrafficMirrorFilterRulesRequestIngressRules {
	s.Action = &v
	return s
}

func (s *CreateTrafficMirrorFilterRulesRequestIngressRules) SetDestinationCidrBlock(v string) *CreateTrafficMirrorFilterRulesRequestIngressRules {
	s.DestinationCidrBlock = &v
	return s
}

func (s *CreateTrafficMirrorFilterRulesRequestIngressRules) SetDestinationPortRange(v string) *CreateTrafficMirrorFilterRulesRequestIngressRules {
	s.DestinationPortRange = &v
	return s
}

func (s *CreateTrafficMirrorFilterRulesRequestIngressRules) SetPriority(v int32) *CreateTrafficMirrorFilterRulesRequestIngressRules {
	s.Priority = &v
	return s
}

func (s *CreateTrafficMirrorFilterRulesRequestIngressRules) SetProtocol(v string) *CreateTrafficMirrorFilterRulesRequestIngressRules {
	s.Protocol = &v
	return s
}

func (s *CreateTrafficMirrorFilterRulesRequestIngressRules) SetSourceCidrBlock(v string) *CreateTrafficMirrorFilterRulesRequestIngressRules {
	s.SourceCidrBlock = &v
	return s
}

func (s *CreateTrafficMirrorFilterRulesRequestIngressRules) SetSourcePortRange(v string) *CreateTrafficMirrorFilterRulesRequestIngressRules {
	s.SourcePortRange = &v
	return s
}

type CreateTrafficMirrorFilterRulesResponseBody struct {
	// The list of outbound rules.
	EgressRules []*CreateTrafficMirrorFilterRulesResponseBodyEgressRules `json:"EgressRules,omitempty" xml:"EgressRules,omitempty" type:"Repeated"`
	// The list of inbound rules.
	IngressRules []*CreateTrafficMirrorFilterRulesResponseBodyIngressRules `json:"IngressRules,omitempty" xml:"IngressRules,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateTrafficMirrorFilterRulesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateTrafficMirrorFilterRulesResponseBody) GoString() string {
	return s.String()
}

func (s *CreateTrafficMirrorFilterRulesResponseBody) SetEgressRules(v []*CreateTrafficMirrorFilterRulesResponseBodyEgressRules) *CreateTrafficMirrorFilterRulesResponseBody {
	s.EgressRules = v
	return s
}

func (s *CreateTrafficMirrorFilterRulesResponseBody) SetIngressRules(v []*CreateTrafficMirrorFilterRulesResponseBodyIngressRules) *CreateTrafficMirrorFilterRulesResponseBody {
	s.IngressRules = v
	return s
}

func (s *CreateTrafficMirrorFilterRulesResponseBody) SetRequestId(v string) *CreateTrafficMirrorFilterRulesResponseBody {
	s.RequestId = &v
	return s
}

type CreateTrafficMirrorFilterRulesResponseBodyEgressRules struct {
	// The ID of the outbound rule.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
}

func (s CreateTrafficMirrorFilterRulesResponseBodyEgressRules) String() string {
	return tea.Prettify(s)
}

func (s CreateTrafficMirrorFilterRulesResponseBodyEgressRules) GoString() string {
	return s.String()
}

func (s *CreateTrafficMirrorFilterRulesResponseBodyEgressRules) SetInstanceId(v string) *CreateTrafficMirrorFilterRulesResponseBodyEgressRules {
	s.InstanceId = &v
	return s
}

type CreateTrafficMirrorFilterRulesResponseBodyIngressRules struct {
	// The ID of the inbound rule.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
}

func (s CreateTrafficMirrorFilterRulesResponseBodyIngressRules) String() string {
	return tea.Prettify(s)
}

func (s CreateTrafficMirrorFilterRulesResponseBodyIngressRules) GoString() string {
	return s.String()
}

func (s *CreateTrafficMirrorFilterRulesResponseBodyIngressRules) SetInstanceId(v string) *CreateTrafficMirrorFilterRulesResponseBodyIngressRules {
	s.InstanceId = &v
	return s
}

type CreateTrafficMirrorFilterRulesResponse struct {
	Headers    map[string]*string                          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateTrafficMirrorFilterRulesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateTrafficMirrorFilterRulesResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateTrafficMirrorFilterRulesResponse) GoString() string {
	return s.String()
}

func (s *CreateTrafficMirrorFilterRulesResponse) SetHeaders(v map[string]*string) *CreateTrafficMirrorFilterRulesResponse {
	s.Headers = v
	return s
}

func (s *CreateTrafficMirrorFilterRulesResponse) SetStatusCode(v int32) *CreateTrafficMirrorFilterRulesResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateTrafficMirrorFilterRulesResponse) SetBody(v *CreateTrafficMirrorFilterRulesResponseBody) *CreateTrafficMirrorFilterRulesResponse {
	s.Body = v
	return s
}

type CreateTrafficMirrorSessionRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must ensure that the value is unique among all requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, the system uses **RequestId** as **ClientToken**. **RequestId** might be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to perform a dry run. Valid values:
	//
	// *   **true**: performs a dry run. The system checks the required parameters, request format, and limits. If the request fails the dry run, an error message is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
	// *   **false** (default): performs a dry run and sends the request. If the request passes the dry run, the operation is performed.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// Specifies whether to enable the traffic mirror session. Valid values:
	//
	// *   **false** (default): does not enable the traffic mirror session.
	// *   **true**: enables the traffic mirror session.
	Enabled      *bool   `json:"Enabled,omitempty" xml:"Enabled,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The maximum transmission unit (MTU). Default value: **1500**.
	PacketLength *int32 `json:"PacketLength,omitempty" xml:"PacketLength,omitempty"`
	// The priority of the traffic mirror session. Valid values: **1** to **32766**.
	//
	// A smaller value indicates a higher priority. You cannot specify identical priorities for traffic mirror sessions that are created in the same region by using the same account.
	Priority *int32 `json:"Priority,omitempty" xml:"Priority,omitempty"`
	// The ID of the region to which the traffic mirror session belongs. You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list. For more information about regions that support traffic mirroring, see [Overview of traffic mirroring](~~207513~~).
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group to which the mirrored traffic belongs.
	ResourceGroupId      *string                                 `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string                                 `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64                                  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	Tag                  []*CreateTrafficMirrorSessionRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
	// The ID of the filter.
	TrafficMirrorFilterId *string `json:"TrafficMirrorFilterId,omitempty" xml:"TrafficMirrorFilterId,omitempty"`
	// The description of the traffic mirror session.
	//
	// The description must be 1 to 256 characters in length and cannot start with `http://` or `https://`.
	TrafficMirrorSessionDescription *string `json:"TrafficMirrorSessionDescription,omitempty" xml:"TrafficMirrorSessionDescription,omitempty"`
	// The name of the traffic mirror session.
	//
	// The name must be 1 to 128 characters in length, and cannot start with `http://` or `https://`.
	TrafficMirrorSessionName *string   `json:"TrafficMirrorSessionName,omitempty" xml:"TrafficMirrorSessionName,omitempty"`
	TrafficMirrorSourceIds   []*string `json:"TrafficMirrorSourceIds,omitempty" xml:"TrafficMirrorSourceIds,omitempty" type:"Repeated"`
	// The ID of the traffic mirror destination. You can specify only an elastic network interface (ENI) or a Server Load Balancer (SLB) instance as a traffic mirror destination.
	TrafficMirrorTargetId *string `json:"TrafficMirrorTargetId,omitempty" xml:"TrafficMirrorTargetId,omitempty"`
	// The type of the traffic mirror destination. Valid values:
	//
	// *   **NetworkInterface**: an ENI
	// *   **SLB**: an SLB instance
	TrafficMirrorTargetType *string `json:"TrafficMirrorTargetType,omitempty" xml:"TrafficMirrorTargetType,omitempty"`
	// The VXLAN network identifier (VNI). Valid values: **0** to **16777215**.
	//
	// You can use VNIs to identify mirrored traffic from different sessions at the traffic mirror destination. You can specify a custom VNI or use a random VNI allocated by the system. If you want the system to randomly allocate a VNI, do not enter a value.
	VirtualNetworkId *int32 `json:"VirtualNetworkId,omitempty" xml:"VirtualNetworkId,omitempty"`
}

func (s CreateTrafficMirrorSessionRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateTrafficMirrorSessionRequest) GoString() string {
	return s.String()
}

func (s *CreateTrafficMirrorSessionRequest) SetClientToken(v string) *CreateTrafficMirrorSessionRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateTrafficMirrorSessionRequest) SetDryRun(v bool) *CreateTrafficMirrorSessionRequest {
	s.DryRun = &v
	return s
}

func (s *CreateTrafficMirrorSessionRequest) SetEnabled(v bool) *CreateTrafficMirrorSessionRequest {
	s.Enabled = &v
	return s
}

func (s *CreateTrafficMirrorSessionRequest) SetOwnerAccount(v string) *CreateTrafficMirrorSessionRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateTrafficMirrorSessionRequest) SetOwnerId(v int64) *CreateTrafficMirrorSessionRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateTrafficMirrorSessionRequest) SetPacketLength(v int32) *CreateTrafficMirrorSessionRequest {
	s.PacketLength = &v
	return s
}

func (s *CreateTrafficMirrorSessionRequest) SetPriority(v int32) *CreateTrafficMirrorSessionRequest {
	s.Priority = &v
	return s
}

func (s *CreateTrafficMirrorSessionRequest) SetRegionId(v string) *CreateTrafficMirrorSessionRequest {
	s.RegionId = &v
	return s
}

func (s *CreateTrafficMirrorSessionRequest) SetResourceGroupId(v string) *CreateTrafficMirrorSessionRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *CreateTrafficMirrorSessionRequest) SetResourceOwnerAccount(v string) *CreateTrafficMirrorSessionRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateTrafficMirrorSessionRequest) SetResourceOwnerId(v int64) *CreateTrafficMirrorSessionRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreateTrafficMirrorSessionRequest) SetTag(v []*CreateTrafficMirrorSessionRequestTag) *CreateTrafficMirrorSessionRequest {
	s.Tag = v
	return s
}

func (s *CreateTrafficMirrorSessionRequest) SetTrafficMirrorFilterId(v string) *CreateTrafficMirrorSessionRequest {
	s.TrafficMirrorFilterId = &v
	return s
}

func (s *CreateTrafficMirrorSessionRequest) SetTrafficMirrorSessionDescription(v string) *CreateTrafficMirrorSessionRequest {
	s.TrafficMirrorSessionDescription = &v
	return s
}

func (s *CreateTrafficMirrorSessionRequest) SetTrafficMirrorSessionName(v string) *CreateTrafficMirrorSessionRequest {
	s.TrafficMirrorSessionName = &v
	return s
}

func (s *CreateTrafficMirrorSessionRequest) SetTrafficMirrorSourceIds(v []*string) *CreateTrafficMirrorSessionRequest {
	s.TrafficMirrorSourceIds = v
	return s
}

func (s *CreateTrafficMirrorSessionRequest) SetTrafficMirrorTargetId(v string) *CreateTrafficMirrorSessionRequest {
	s.TrafficMirrorTargetId = &v
	return s
}

func (s *CreateTrafficMirrorSessionRequest) SetTrafficMirrorTargetType(v string) *CreateTrafficMirrorSessionRequest {
	s.TrafficMirrorTargetType = &v
	return s
}

func (s *CreateTrafficMirrorSessionRequest) SetVirtualNetworkId(v int32) *CreateTrafficMirrorSessionRequest {
	s.VirtualNetworkId = &v
	return s
}

type CreateTrafficMirrorSessionRequestTag struct {
	Key   *string `json:"Key,omitempty" xml:"Key,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateTrafficMirrorSessionRequestTag) String() string {
	return tea.Prettify(s)
}

func (s CreateTrafficMirrorSessionRequestTag) GoString() string {
	return s.String()
}

func (s *CreateTrafficMirrorSessionRequestTag) SetKey(v string) *CreateTrafficMirrorSessionRequestTag {
	s.Key = &v
	return s
}

func (s *CreateTrafficMirrorSessionRequestTag) SetValue(v string) *CreateTrafficMirrorSessionRequestTag {
	s.Value = &v
	return s
}

type CreateTrafficMirrorSessionResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the resource group to which the mirrored traffic belongs.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The ID of the traffic mirror session.
	TrafficMirrorSessionId *string `json:"TrafficMirrorSessionId,omitempty" xml:"TrafficMirrorSessionId,omitempty"`
}

func (s CreateTrafficMirrorSessionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateTrafficMirrorSessionResponseBody) GoString() string {
	return s.String()
}

func (s *CreateTrafficMirrorSessionResponseBody) SetRequestId(v string) *CreateTrafficMirrorSessionResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateTrafficMirrorSessionResponseBody) SetResourceGroupId(v string) *CreateTrafficMirrorSessionResponseBody {
	s.ResourceGroupId = &v
	return s
}

func (s *CreateTrafficMirrorSessionResponseBody) SetTrafficMirrorSessionId(v string) *CreateTrafficMirrorSessionResponseBody {
	s.TrafficMirrorSessionId = &v
	return s
}

type CreateTrafficMirrorSessionResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateTrafficMirrorSessionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateTrafficMirrorSessionResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateTrafficMirrorSessionResponse) GoString() string {
	return s.String()
}

func (s *CreateTrafficMirrorSessionResponse) SetHeaders(v map[string]*string) *CreateTrafficMirrorSessionResponse {
	s.Headers = v
	return s
}

func (s *CreateTrafficMirrorSessionResponse) SetStatusCode(v int32) *CreateTrafficMirrorSessionResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateTrafficMirrorSessionResponse) SetBody(v *CreateTrafficMirrorSessionResponseBody) *CreateTrafficMirrorSessionResponse {
	s.Body = v
	return s
}

type CreateVSwitchRequest struct {
	// The CIDR block of the vSwitch. Take note of the following limits:
	//
	// *   The subnet mask of the CIDR block must be 16 to 29 bits in length.
	// *   The CIDR block of the vSwitch must fall within the CIDR block of the VPC to which the vSwitch belongs.
	// *   The CIDR block of a vSwitch cannot be the same as the destination CIDR block in a route entry of the VPC. However, it can be a subset of the destination CIDR block.
	CidrBlock *string `json:"CidrBlock,omitempty" xml:"CidrBlock,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among all requests. The token can contain only ASCII characters.
	//
	// >  If you do not specify this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The description of the vSwitch.
	//
	// The description must be 1 to 256 characters in length and cannot start with `http://` or `https://`.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The last eight bits of the IPv6 CIDR block of the vSwitch. Valid values: **0** to **255**.
	Ipv6CidrBlock *int32  `json:"Ipv6CidrBlock,omitempty" xml:"Ipv6CidrBlock,omitempty"`
	OwnerAccount  *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the vSwitch.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string                    `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string                    `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64                     `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	Tag                  []*CreateVSwitchRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
	// The name of the vSwitch.
	//
	// The name must be 1 to 128 characters in length, and cannot start with `http://` or `https://`.
	VSwitchName *string `json:"VSwitchName,omitempty" xml:"VSwitchName,omitempty"`
	// The ID of the VPC where you want to create the vSwitch.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
	// The IPv6 CIDR block of the VPC.
	VpcIpv6CidrBlock *string `json:"VpcIpv6CidrBlock,omitempty" xml:"VpcIpv6CidrBlock,omitempty"`
	// The zone ID of the vSwitch.
	//
	// You can call the [DescribeZones](~~36064~~) operation to query the most recent zone list.
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
}

func (s CreateVSwitchRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateVSwitchRequest) GoString() string {
	return s.String()
}

func (s *CreateVSwitchRequest) SetCidrBlock(v string) *CreateVSwitchRequest {
	s.CidrBlock = &v
	return s
}

func (s *CreateVSwitchRequest) SetClientToken(v string) *CreateVSwitchRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateVSwitchRequest) SetDescription(v string) *CreateVSwitchRequest {
	s.Description = &v
	return s
}

func (s *CreateVSwitchRequest) SetIpv6CidrBlock(v int32) *CreateVSwitchRequest {
	s.Ipv6CidrBlock = &v
	return s
}

func (s *CreateVSwitchRequest) SetOwnerAccount(v string) *CreateVSwitchRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateVSwitchRequest) SetOwnerId(v int64) *CreateVSwitchRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateVSwitchRequest) SetRegionId(v string) *CreateVSwitchRequest {
	s.RegionId = &v
	return s
}

func (s *CreateVSwitchRequest) SetResourceOwnerAccount(v string) *CreateVSwitchRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateVSwitchRequest) SetResourceOwnerId(v int64) *CreateVSwitchRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreateVSwitchRequest) SetTag(v []*CreateVSwitchRequestTag) *CreateVSwitchRequest {
	s.Tag = v
	return s
}

func (s *CreateVSwitchRequest) SetVSwitchName(v string) *CreateVSwitchRequest {
	s.VSwitchName = &v
	return s
}

func (s *CreateVSwitchRequest) SetVpcId(v string) *CreateVSwitchRequest {
	s.VpcId = &v
	return s
}

func (s *CreateVSwitchRequest) SetVpcIpv6CidrBlock(v string) *CreateVSwitchRequest {
	s.VpcIpv6CidrBlock = &v
	return s
}

func (s *CreateVSwitchRequest) SetZoneId(v string) *CreateVSwitchRequest {
	s.ZoneId = &v
	return s
}

type CreateVSwitchRequestTag struct {
	Key   *string `json:"Key,omitempty" xml:"Key,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateVSwitchRequestTag) String() string {
	return tea.Prettify(s)
}

func (s CreateVSwitchRequestTag) GoString() string {
	return s.String()
}

func (s *CreateVSwitchRequestTag) SetKey(v string) *CreateVSwitchRequestTag {
	s.Key = &v
	return s
}

func (s *CreateVSwitchRequestTag) SetValue(v string) *CreateVSwitchRequestTag {
	s.Value = &v
	return s
}

type CreateVSwitchResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the vSwitch.
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
}

func (s CreateVSwitchResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateVSwitchResponseBody) GoString() string {
	return s.String()
}

func (s *CreateVSwitchResponseBody) SetRequestId(v string) *CreateVSwitchResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateVSwitchResponseBody) SetVSwitchId(v string) *CreateVSwitchResponseBody {
	s.VSwitchId = &v
	return s
}

type CreateVSwitchResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateVSwitchResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateVSwitchResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateVSwitchResponse) GoString() string {
	return s.String()
}

func (s *CreateVSwitchResponse) SetHeaders(v map[string]*string) *CreateVSwitchResponse {
	s.Headers = v
	return s
}

func (s *CreateVSwitchResponse) SetStatusCode(v int32) *CreateVSwitchResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateVSwitchResponse) SetBody(v *CreateVSwitchResponseBody) *CreateVSwitchResponse {
	s.Body = v
	return s
}

type CreateVbrHaRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// The client token must be unique among different requests. It can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The description of the VBR failover group.
	//
	// The description must be 2 to 256 characters in length. It must start with a letter and cannot start with `http://`or `https://`.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// Specifies whether to precheck the request. Valid values:
	//
	// *   **true**: prechecks the request without performing the operation. The system checks the request format, instance status, and whether the required parameters are specified. An error message is returned if the request fails the precheck. If the request passes the precheck, `DRYRUN.SUCCESS` is returned.
	// *   **false**: prechecks the request. After the request passes the precheck, the operation is performed.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The name of the VBR failover group.
	Name         *string `json:"Name,omitempty" xml:"Name,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the other VBR in the VBR failover group.
	PeerVbrId *string `json:"PeerVbrId,omitempty" xml:"PeerVbrId,omitempty"`
	// The ID of the region where the VBR is deployed.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the VBR.
	VbrId *string `json:"VbrId,omitempty" xml:"VbrId,omitempty"`
}

func (s CreateVbrHaRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateVbrHaRequest) GoString() string {
	return s.String()
}

func (s *CreateVbrHaRequest) SetClientToken(v string) *CreateVbrHaRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateVbrHaRequest) SetDescription(v string) *CreateVbrHaRequest {
	s.Description = &v
	return s
}

func (s *CreateVbrHaRequest) SetDryRun(v bool) *CreateVbrHaRequest {
	s.DryRun = &v
	return s
}

func (s *CreateVbrHaRequest) SetName(v string) *CreateVbrHaRequest {
	s.Name = &v
	return s
}

func (s *CreateVbrHaRequest) SetOwnerAccount(v string) *CreateVbrHaRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateVbrHaRequest) SetOwnerId(v int64) *CreateVbrHaRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateVbrHaRequest) SetPeerVbrId(v string) *CreateVbrHaRequest {
	s.PeerVbrId = &v
	return s
}

func (s *CreateVbrHaRequest) SetRegionId(v string) *CreateVbrHaRequest {
	s.RegionId = &v
	return s
}

func (s *CreateVbrHaRequest) SetResourceOwnerAccount(v string) *CreateVbrHaRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateVbrHaRequest) SetResourceOwnerId(v int64) *CreateVbrHaRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreateVbrHaRequest) SetVbrId(v string) *CreateVbrHaRequest {
	s.VbrId = &v
	return s
}

type CreateVbrHaResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the VBR failover group.
	VbrHaId *string `json:"VbrHaId,omitempty" xml:"VbrHaId,omitempty"`
}

func (s CreateVbrHaResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateVbrHaResponseBody) GoString() string {
	return s.String()
}

func (s *CreateVbrHaResponseBody) SetRequestId(v string) *CreateVbrHaResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateVbrHaResponseBody) SetVbrHaId(v string) *CreateVbrHaResponseBody {
	s.VbrHaId = &v
	return s
}

type CreateVbrHaResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateVbrHaResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateVbrHaResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateVbrHaResponse) GoString() string {
	return s.String()
}

func (s *CreateVbrHaResponse) SetHeaders(v map[string]*string) *CreateVbrHaResponse {
	s.Headers = v
	return s
}

func (s *CreateVbrHaResponse) SetStatusCode(v int32) *CreateVbrHaResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateVbrHaResponse) SetBody(v *CreateVbrHaResponseBody) *CreateVbrHaResponse {
	s.Body = v
	return s
}

type CreateVcoRouteEntryRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among all requests. The token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The description of the destination-based route.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The next hop of the destination-based route.
	NextHop *string `json:"NextHop,omitempty" xml:"NextHop,omitempty"`
	// The tunneling protocol. Set the value to **Ipsec**, which specifies the IPsec tunneling protocol.
	OverlayMode  *string `json:"OverlayMode,omitempty" xml:"OverlayMode,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	// The region ID of the IPsec-VPN connection.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The destination CIDR block of the destination-based route.
	RouteDest *string `json:"RouteDest,omitempty" xml:"RouteDest,omitempty"`
	// The ID of the IPsec-VPN connection.
	VpnConnectionId *string `json:"VpnConnectionId,omitempty" xml:"VpnConnectionId,omitempty"`
	// The weight of the destination-based route. Valid values:
	//
	// *   **0**: a low priority
	// *   **100**: a high priority
	Weight *int32 `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s CreateVcoRouteEntryRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateVcoRouteEntryRequest) GoString() string {
	return s.String()
}

func (s *CreateVcoRouteEntryRequest) SetClientToken(v string) *CreateVcoRouteEntryRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateVcoRouteEntryRequest) SetDescription(v string) *CreateVcoRouteEntryRequest {
	s.Description = &v
	return s
}

func (s *CreateVcoRouteEntryRequest) SetNextHop(v string) *CreateVcoRouteEntryRequest {
	s.NextHop = &v
	return s
}

func (s *CreateVcoRouteEntryRequest) SetOverlayMode(v string) *CreateVcoRouteEntryRequest {
	s.OverlayMode = &v
	return s
}

func (s *CreateVcoRouteEntryRequest) SetOwnerAccount(v string) *CreateVcoRouteEntryRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateVcoRouteEntryRequest) SetRegionId(v string) *CreateVcoRouteEntryRequest {
	s.RegionId = &v
	return s
}

func (s *CreateVcoRouteEntryRequest) SetResourceOwnerAccount(v string) *CreateVcoRouteEntryRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateVcoRouteEntryRequest) SetResourceOwnerId(v int64) *CreateVcoRouteEntryRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreateVcoRouteEntryRequest) SetRouteDest(v string) *CreateVcoRouteEntryRequest {
	s.RouteDest = &v
	return s
}

func (s *CreateVcoRouteEntryRequest) SetVpnConnectionId(v string) *CreateVcoRouteEntryRequest {
	s.VpnConnectionId = &v
	return s
}

func (s *CreateVcoRouteEntryRequest) SetWeight(v int32) *CreateVcoRouteEntryRequest {
	s.Weight = &v
	return s
}

type CreateVcoRouteEntryResponseBody struct {
	// The timestamp when the destination-based route was created. Unit: milliseconds.
	//
	// This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The description of the destination-based route.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The next hop of the destination-based route.
	NextHop *string `json:"NextHop,omitempty" xml:"NextHop,omitempty"`
	// The tunneling protocol.
	//
	// The value is set to **Ipsec**, which indicates the IPsec tunneling protocol.
	OverlayMode *string `json:"OverlayMode,omitempty" xml:"OverlayMode,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The destination CIDR block of the destination-based route.
	RouteDest *string `json:"RouteDest,omitempty" xml:"RouteDest,omitempty"`
	// The status of the destination-based route.
	//
	// Only **published** is returned, which indicates that the current route is published to the transit router.
	State *string `json:"State,omitempty" xml:"State,omitempty"`
	// The ID of the IPsec-VPN connection.
	VpnConnectionId *string `json:"VpnConnectionId,omitempty" xml:"VpnConnectionId,omitempty"`
	// The weight of the destination-based route.
	//
	// *   **0**: a low priority
	// *   **100**: a high priority
	Weight *int32 `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s CreateVcoRouteEntryResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateVcoRouteEntryResponseBody) GoString() string {
	return s.String()
}

func (s *CreateVcoRouteEntryResponseBody) SetCreateTime(v int64) *CreateVcoRouteEntryResponseBody {
	s.CreateTime = &v
	return s
}

func (s *CreateVcoRouteEntryResponseBody) SetDescription(v string) *CreateVcoRouteEntryResponseBody {
	s.Description = &v
	return s
}

func (s *CreateVcoRouteEntryResponseBody) SetNextHop(v string) *CreateVcoRouteEntryResponseBody {
	s.NextHop = &v
	return s
}

func (s *CreateVcoRouteEntryResponseBody) SetOverlayMode(v string) *CreateVcoRouteEntryResponseBody {
	s.OverlayMode = &v
	return s
}

func (s *CreateVcoRouteEntryResponseBody) SetRequestId(v string) *CreateVcoRouteEntryResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateVcoRouteEntryResponseBody) SetRouteDest(v string) *CreateVcoRouteEntryResponseBody {
	s.RouteDest = &v
	return s
}

func (s *CreateVcoRouteEntryResponseBody) SetState(v string) *CreateVcoRouteEntryResponseBody {
	s.State = &v
	return s
}

func (s *CreateVcoRouteEntryResponseBody) SetVpnConnectionId(v string) *CreateVcoRouteEntryResponseBody {
	s.VpnConnectionId = &v
	return s
}

func (s *CreateVcoRouteEntryResponseBody) SetWeight(v int32) *CreateVcoRouteEntryResponseBody {
	s.Weight = &v
	return s
}

type CreateVcoRouteEntryResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateVcoRouteEntryResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateVcoRouteEntryResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateVcoRouteEntryResponse) GoString() string {
	return s.String()
}

func (s *CreateVcoRouteEntryResponse) SetHeaders(v map[string]*string) *CreateVcoRouteEntryResponse {
	s.Headers = v
	return s
}

func (s *CreateVcoRouteEntryResponse) SetStatusCode(v int32) *CreateVcoRouteEntryResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateVcoRouteEntryResponse) SetBody(v *CreateVcoRouteEntryResponseBody) *CreateVcoRouteEntryResponse {
	s.Body = v
	return s
}

type CreateVirtualBorderRouterRequest struct {
	// The bandwidth of the VBR. Unit: Mbit/s.
	//
	// *   When you create a VBR for a dedicated connection, valid values are **50**, **100**, **200**, **300**, **400**, **500**, **1000**, **2048**, **5120**, **8192**, **10240**, **20480**, **40960**, **50120**, **61440**, and **102400**.
	// *   You do not need to set this parameter when you create a VBR for a hosted connection. The bandwidth is already configured when the hosted connection is created.
	Bandwidth *int64 `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	// The circuit code of the Express Connect circuit. The circuit code is provided by the connectivity provider.
	//
	// >  Only the owner of the Express Connect circuit can set this parameter.
	CircuitCode *string `json:"CircuitCode,omitempty" xml:"CircuitCode,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests.
	//
	// >  If you do not set this parameter, the system automatically sets **ClientToken** to the value of **RequestId**. The value of **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The description of the VBR.
	//
	// The description must be 2 to 256 characters in length. The description must start with a letter but cannot start with `http://` or `https://`.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// Specifies whether to enable IPv6. Valid values:
	//
	// *   **true**: enables IPv6.
	// *   **false** (default): disables IPv6.
	EnableIpv6 *bool `json:"EnableIpv6,omitempty" xml:"EnableIpv6,omitempty"`
	// The IP address of the VBR. Only the owner of the VBR can set or modify this parameter.
	//
	// When you create a VBR for the owner of the Express Connect circuit, this parameter is required.
	LocalGatewayIp *string `json:"LocalGatewayIp,omitempty" xml:"LocalGatewayIp,omitempty"`
	// The IPv6 address of the VBR. Only the owner of the VBR can set or modify this parameter.
	//
	// When you create a VBR for the owner of the Express Connect circuit, this parameter is required.
	LocalIpv6GatewayIp *string `json:"LocalIpv6GatewayIp,omitempty" xml:"LocalIpv6GatewayIp,omitempty"`
	// The name of the VBR.
	//
	// The name must be 2 to 128 characters in length, and can contain letters, digits, underscores (\_), and hyphens (-). The name must start with a letter.
	Name         *string `json:"Name,omitempty" xml:"Name,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The IP address of the gateway device in the data center. Only the owner of the VBR can set or modify this parameter.
	//
	// When you create a VBR for the owner of the Express Connect circuit, this parameter is required.
	PeerGatewayIp *string `json:"PeerGatewayIp,omitempty" xml:"PeerGatewayIp,omitempty"`
	// The IPv6 address of the gateway device in the data center. Only the owner of the VBR can set or modify this parameter.
	//
	// When you create a VBR for the owner of the Express Connect circuit, this parameter is required.
	PeerIpv6GatewayIp *string `json:"PeerIpv6GatewayIp,omitempty" xml:"PeerIpv6GatewayIp,omitempty"`
	// The subnet mask of the IPv6 addresses of the VBR and the gateway device in the data center.
	//
	// The two IPv6 addresses must fall within the same subnet.
	PeeringIpv6SubnetMask *string `json:"PeeringIpv6SubnetMask,omitempty" xml:"PeeringIpv6SubnetMask,omitempty"`
	// The subnet mask of the IP addresses of the VBR and the gateway device in the data center.
	//
	// The two IP addresses must fall within the same subnet.
	PeeringSubnetMask *string `json:"PeeringSubnetMask,omitempty" xml:"PeeringSubnetMask,omitempty"`
	// The ID of the Express Connect circuit.
	//
	// You can create a VBR for a dedicated connection or a hosted connection.
	PhysicalConnectionId *string `json:"PhysicalConnectionId,omitempty" xml:"PhysicalConnectionId,omitempty"`
	// The region ID of the Express Connect circuit.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string                                 `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceGroupId      *string                                 `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string                                 `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64                                  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	Tags                 []*CreateVirtualBorderRouterRequestTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
	// The account ID of the VBR owner.
	//
	// The default value is the ID of the current Alibaba Cloud account.
	VbrOwnerId *int64 `json:"VbrOwnerId,omitempty" xml:"VbrOwnerId,omitempty"`
	// The VLAN ID of the VBR. Valid values: **0 to 2999**.
	//
	// >  Only the owner of the Express Connect circuit can set this parameter. The VLAN IDs of two VBRs of the same the Express Connect circuit must be different.
	VlanId *int32 `json:"VlanId,omitempty" xml:"VlanId,omitempty"`
}

func (s CreateVirtualBorderRouterRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateVirtualBorderRouterRequest) GoString() string {
	return s.String()
}

func (s *CreateVirtualBorderRouterRequest) SetBandwidth(v int64) *CreateVirtualBorderRouterRequest {
	s.Bandwidth = &v
	return s
}

func (s *CreateVirtualBorderRouterRequest) SetCircuitCode(v string) *CreateVirtualBorderRouterRequest {
	s.CircuitCode = &v
	return s
}

func (s *CreateVirtualBorderRouterRequest) SetClientToken(v string) *CreateVirtualBorderRouterRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateVirtualBorderRouterRequest) SetDescription(v string) *CreateVirtualBorderRouterRequest {
	s.Description = &v
	return s
}

func (s *CreateVirtualBorderRouterRequest) SetEnableIpv6(v bool) *CreateVirtualBorderRouterRequest {
	s.EnableIpv6 = &v
	return s
}

func (s *CreateVirtualBorderRouterRequest) SetLocalGatewayIp(v string) *CreateVirtualBorderRouterRequest {
	s.LocalGatewayIp = &v
	return s
}

func (s *CreateVirtualBorderRouterRequest) SetLocalIpv6GatewayIp(v string) *CreateVirtualBorderRouterRequest {
	s.LocalIpv6GatewayIp = &v
	return s
}

func (s *CreateVirtualBorderRouterRequest) SetName(v string) *CreateVirtualBorderRouterRequest {
	s.Name = &v
	return s
}

func (s *CreateVirtualBorderRouterRequest) SetOwnerAccount(v string) *CreateVirtualBorderRouterRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateVirtualBorderRouterRequest) SetOwnerId(v int64) *CreateVirtualBorderRouterRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateVirtualBorderRouterRequest) SetPeerGatewayIp(v string) *CreateVirtualBorderRouterRequest {
	s.PeerGatewayIp = &v
	return s
}

func (s *CreateVirtualBorderRouterRequest) SetPeerIpv6GatewayIp(v string) *CreateVirtualBorderRouterRequest {
	s.PeerIpv6GatewayIp = &v
	return s
}

func (s *CreateVirtualBorderRouterRequest) SetPeeringIpv6SubnetMask(v string) *CreateVirtualBorderRouterRequest {
	s.PeeringIpv6SubnetMask = &v
	return s
}

func (s *CreateVirtualBorderRouterRequest) SetPeeringSubnetMask(v string) *CreateVirtualBorderRouterRequest {
	s.PeeringSubnetMask = &v
	return s
}

func (s *CreateVirtualBorderRouterRequest) SetPhysicalConnectionId(v string) *CreateVirtualBorderRouterRequest {
	s.PhysicalConnectionId = &v
	return s
}

func (s *CreateVirtualBorderRouterRequest) SetRegionId(v string) *CreateVirtualBorderRouterRequest {
	s.RegionId = &v
	return s
}

func (s *CreateVirtualBorderRouterRequest) SetResourceGroupId(v string) *CreateVirtualBorderRouterRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *CreateVirtualBorderRouterRequest) SetResourceOwnerAccount(v string) *CreateVirtualBorderRouterRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateVirtualBorderRouterRequest) SetResourceOwnerId(v int64) *CreateVirtualBorderRouterRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreateVirtualBorderRouterRequest) SetTags(v []*CreateVirtualBorderRouterRequestTags) *CreateVirtualBorderRouterRequest {
	s.Tags = v
	return s
}

func (s *CreateVirtualBorderRouterRequest) SetVbrOwnerId(v int64) *CreateVirtualBorderRouterRequest {
	s.VbrOwnerId = &v
	return s
}

func (s *CreateVirtualBorderRouterRequest) SetVlanId(v int32) *CreateVirtualBorderRouterRequest {
	s.VlanId = &v
	return s
}

type CreateVirtualBorderRouterRequestTags struct {
	Key   *string `json:"Key,omitempty" xml:"Key,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateVirtualBorderRouterRequestTags) String() string {
	return tea.Prettify(s)
}

func (s CreateVirtualBorderRouterRequestTags) GoString() string {
	return s.String()
}

func (s *CreateVirtualBorderRouterRequestTags) SetKey(v string) *CreateVirtualBorderRouterRequestTags {
	s.Key = &v
	return s
}

func (s *CreateVirtualBorderRouterRequestTags) SetValue(v string) *CreateVirtualBorderRouterRequestTags {
	s.Value = &v
	return s
}

type CreateVirtualBorderRouterResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the VBR.
	VbrId *string `json:"VbrId,omitempty" xml:"VbrId,omitempty"`
}

func (s CreateVirtualBorderRouterResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateVirtualBorderRouterResponseBody) GoString() string {
	return s.String()
}

func (s *CreateVirtualBorderRouterResponseBody) SetRequestId(v string) *CreateVirtualBorderRouterResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateVirtualBorderRouterResponseBody) SetVbrId(v string) *CreateVirtualBorderRouterResponseBody {
	s.VbrId = &v
	return s
}

type CreateVirtualBorderRouterResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateVirtualBorderRouterResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateVirtualBorderRouterResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateVirtualBorderRouterResponse) GoString() string {
	return s.String()
}

func (s *CreateVirtualBorderRouterResponse) SetHeaders(v map[string]*string) *CreateVirtualBorderRouterResponse {
	s.Headers = v
	return s
}

func (s *CreateVirtualBorderRouterResponse) SetStatusCode(v int32) *CreateVirtualBorderRouterResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateVirtualBorderRouterResponse) SetBody(v *CreateVirtualBorderRouterResponseBody) *CreateVirtualBorderRouterResponse {
	s.Body = v
	return s
}

type CreateVirtualPhysicalConnectionRequest struct {
	// The description of the hosted connection.
	//
	// The description must be 2 to 256 characters in length. The description must start with a letter but cannot start with `http://` or `https://`.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// Specifies whether to check the request without performing the operation. Valid values:
	//
	// *   **true**: checks the request without performing the operation. The hosted connection is not created. The system checks the required parameters, request syntax, and instance status. If the request fails the check, an error message is returned. If the request passes the check, `DRYRUN.SUCCESS` is returned.
	// *   **false**: sends the request. If the request passes the check, the hosted connection is created. This is the default value.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The name of the hosted connection.
	//
	// The name must be 2 to 128 characters in length, and can contain letters, digits, underscores (\_), and hyphens (-). The name must start with a letter but cannot start with `http://` or `https://`.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The payer for the hosted connection. Valid values:
	//
	// *   **PayByPhysicalConnectionOwner**: The partner pays for the hosted connection.
	// *   **PayByVirtualPhysicalConnectionOwner**: The tenant pays for the hosted connection.
	OrderMode *string `json:"OrderMode,omitempty" xml:"OrderMode,omitempty"`
	// The ID of the Express Connect circuit over which the hosted connection is created.
	PhysicalConnectionId *string `json:"PhysicalConnectionId,omitempty" xml:"PhysicalConnectionId,omitempty"`
	// The region ID of the hosted connection.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to obtain the region ID.
	RegionId        *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The bandwidth value of the hosted connection.
	//
	// Valid values: **50M**, **100M**, **200M**, **300M**, **400M**, **500M**, **1G**, **2G**, **5G**, **8G**, and **10G**.
	//
	// >  By default, the values of **2G**, **5G**, **8G**, and **10G** are unavailable. If you want to specify these values, contact your customer manager.
	//
	// **M** indicates Mbit/s, and **G** indicates Gbit/s.
	Spec *string                                      `json:"Spec,omitempty" xml:"Spec,omitempty"`
	Tag  []*CreateVirtualPhysicalConnectionRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that the value is unique among different requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, the system automatically sets **ClientToken** to the value of **RequestId**. The value of **RequestId** may be different for each API request.
	Token *string `json:"Token,omitempty" xml:"Token,omitempty"`
	// The virtual local area network (VLAN) ID of the hosted connection. Valid values: **0** to **2999**.
	//
	// *   If the VLAN ID is set to **0**, it indicates that the switch port of the virtual border router (VBR) is a Layer 3 router interface instead of a VLAN interface. When a Layer 3 router interface is used, each Express Connect circuit corresponds to a VBR.
	// *   If the VLAN ID is set to a value from **1** to **2999**, the switch port of the VBR is a Layer 3 VLAN subinterface. When a Layer 3 VLAN subinterface is used, each VLAN ID corresponds to one VBR. In this case, the Express Connect circuit with which the VBR is associated can be used to connect to VPCs that belong to different Alibaba Cloud accounts. VBRs in different VLANs are isolated from each other at Layer 2.
	VlanId *int64 `json:"VlanId,omitempty" xml:"VlanId,omitempty"`
	// The Alibaba Cloud account ID of the tenant.
	VpconnAliUid *int64 `json:"VpconnAliUid,omitempty" xml:"VpconnAliUid,omitempty"`
}

func (s CreateVirtualPhysicalConnectionRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateVirtualPhysicalConnectionRequest) GoString() string {
	return s.String()
}

func (s *CreateVirtualPhysicalConnectionRequest) SetDescription(v string) *CreateVirtualPhysicalConnectionRequest {
	s.Description = &v
	return s
}

func (s *CreateVirtualPhysicalConnectionRequest) SetDryRun(v bool) *CreateVirtualPhysicalConnectionRequest {
	s.DryRun = &v
	return s
}

func (s *CreateVirtualPhysicalConnectionRequest) SetName(v string) *CreateVirtualPhysicalConnectionRequest {
	s.Name = &v
	return s
}

func (s *CreateVirtualPhysicalConnectionRequest) SetOrderMode(v string) *CreateVirtualPhysicalConnectionRequest {
	s.OrderMode = &v
	return s
}

func (s *CreateVirtualPhysicalConnectionRequest) SetPhysicalConnectionId(v string) *CreateVirtualPhysicalConnectionRequest {
	s.PhysicalConnectionId = &v
	return s
}

func (s *CreateVirtualPhysicalConnectionRequest) SetRegionId(v string) *CreateVirtualPhysicalConnectionRequest {
	s.RegionId = &v
	return s
}

func (s *CreateVirtualPhysicalConnectionRequest) SetResourceGroupId(v string) *CreateVirtualPhysicalConnectionRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *CreateVirtualPhysicalConnectionRequest) SetSpec(v string) *CreateVirtualPhysicalConnectionRequest {
	s.Spec = &v
	return s
}

func (s *CreateVirtualPhysicalConnectionRequest) SetTag(v []*CreateVirtualPhysicalConnectionRequestTag) *CreateVirtualPhysicalConnectionRequest {
	s.Tag = v
	return s
}

func (s *CreateVirtualPhysicalConnectionRequest) SetToken(v string) *CreateVirtualPhysicalConnectionRequest {
	s.Token = &v
	return s
}

func (s *CreateVirtualPhysicalConnectionRequest) SetVlanId(v int64) *CreateVirtualPhysicalConnectionRequest {
	s.VlanId = &v
	return s
}

func (s *CreateVirtualPhysicalConnectionRequest) SetVpconnAliUid(v int64) *CreateVirtualPhysicalConnectionRequest {
	s.VpconnAliUid = &v
	return s
}

type CreateVirtualPhysicalConnectionRequestTag struct {
	Key   *string `json:"Key,omitempty" xml:"Key,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateVirtualPhysicalConnectionRequestTag) String() string {
	return tea.Prettify(s)
}

func (s CreateVirtualPhysicalConnectionRequestTag) GoString() string {
	return s.String()
}

func (s *CreateVirtualPhysicalConnectionRequestTag) SetKey(v string) *CreateVirtualPhysicalConnectionRequestTag {
	s.Key = &v
	return s
}

func (s *CreateVirtualPhysicalConnectionRequestTag) SetValue(v string) *CreateVirtualPhysicalConnectionRequestTag {
	s.Value = &v
	return s
}

type CreateVirtualPhysicalConnectionResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the hosted connection.
	VirtualPhysicalConnection *string `json:"VirtualPhysicalConnection,omitempty" xml:"VirtualPhysicalConnection,omitempty"`
}

func (s CreateVirtualPhysicalConnectionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateVirtualPhysicalConnectionResponseBody) GoString() string {
	return s.String()
}

func (s *CreateVirtualPhysicalConnectionResponseBody) SetRequestId(v string) *CreateVirtualPhysicalConnectionResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateVirtualPhysicalConnectionResponseBody) SetVirtualPhysicalConnection(v string) *CreateVirtualPhysicalConnectionResponseBody {
	s.VirtualPhysicalConnection = &v
	return s
}

type CreateVirtualPhysicalConnectionResponse struct {
	Headers    map[string]*string                           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateVirtualPhysicalConnectionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateVirtualPhysicalConnectionResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateVirtualPhysicalConnectionResponse) GoString() string {
	return s.String()
}

func (s *CreateVirtualPhysicalConnectionResponse) SetHeaders(v map[string]*string) *CreateVirtualPhysicalConnectionResponse {
	s.Headers = v
	return s
}

func (s *CreateVirtualPhysicalConnectionResponse) SetStatusCode(v int32) *CreateVirtualPhysicalConnectionResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateVirtualPhysicalConnectionResponse) SetBody(v *CreateVirtualPhysicalConnectionResponseBody) *CreateVirtualPhysicalConnectionResponse {
	s.Body = v
	return s
}

type CreateVpcRequest struct {
	// The CIDR block of the VPC.
	//
	// *   You can specify one of the following CIDR blocks or their subsets as the primary IPv4 CIDR block of the VPC: 192.168.0.0/16, 172.16.0.0/12, and 10.0.0.0/8. These CIDR blocks are standard private CIDR blocks as defined by Request for Comments (RFC) documents. The subnet mask must be 8 to 28 bits in length.
	// *   You can also use a custom CIDR block other than 100.64.0.0/10, 224.0.0.0/4, 127.0.0.0/8, 169.254.0.0/16, and their subnets as the primary IPv4 CIDR block of the VPC.
	CidrBlock *string `json:"CidrBlock,omitempty" xml:"CidrBlock,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must ensure that it is unique among all requests. ClientToken can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The description of the VPC.
	//
	// The description must be 1 to 256 characters in length and cannot start with `http://` or `https://`.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// Specifies whether to perform a dry run. Valid values:
	//
	// *   **true**: performs a dry run. The system checks the required parameters, request syntax, and limits. If the request fails the dry run, an error message is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
	// *   **false** (default): performs a dry run and sends the request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// Specifies whether to enable IPv6. Valid values:
	//
	// *   **false** (default): no
	// *   **true**: yes
	EnableIpv6     *bool   `json:"EnableIpv6,omitempty" xml:"EnableIpv6,omitempty"`
	Ipv4IpamPoolId *string `json:"Ipv4IpamPoolId,omitempty" xml:"Ipv4IpamPoolId,omitempty"`
	// The IPv6 CIDR blocks of the VPC.
	Ipv6CidrBlock *string `json:"Ipv6CidrBlock,omitempty" xml:"Ipv6CidrBlock,omitempty"`
	// The type of the IPv6 CIDR block. Valid values:
	//
	// *   **BGP** (default): Alibaba Cloud Border Gateway Protocol (BGP)
	// *   **ChinaMobile**: China Mobile (single ISP).
	// *   **ChinaUnicom**: China Unicom (single ISP).
	// *   **ChinaTelecom**: China Telecom (single ISP).
	//
	// >  If your Alibaba Cloud account is allowed to use single-ISP bandwidth, you can set this parameter to **ChinaTelecom**, **ChinaUnicom**, or **ChinaMobile**.
	Ipv6Isp      *string `json:"Ipv6Isp,omitempty" xml:"Ipv6Isp,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region to which the VPC belongs.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group.
	//
	// For more information about resource groups, see [What is a resource group?](~~94475~~)
	ResourceGroupId      *string                `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string                `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64                 `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	Tag                  []*CreateVpcRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
	// The user CIDR block. Separate user CIDR blocks with commas (,). You can specify up to three user CIDR blocks.
	//
	// For more information about user CIDR blocks, see the `What is a user CIDR block?` section in [VPC FAQ](~~185311~~).
	UserCidr *string `json:"UserCidr,omitempty" xml:"UserCidr,omitempty"`
	// The name of the VPC.
	//
	// The name must be 1 to 128 characters in length and cannot start with `http://` or `https://`.
	VpcName *string `json:"VpcName,omitempty" xml:"VpcName,omitempty"`
}

func (s CreateVpcRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateVpcRequest) GoString() string {
	return s.String()
}

func (s *CreateVpcRequest) SetCidrBlock(v string) *CreateVpcRequest {
	s.CidrBlock = &v
	return s
}

func (s *CreateVpcRequest) SetClientToken(v string) *CreateVpcRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateVpcRequest) SetDescription(v string) *CreateVpcRequest {
	s.Description = &v
	return s
}

func (s *CreateVpcRequest) SetDryRun(v bool) *CreateVpcRequest {
	s.DryRun = &v
	return s
}

func (s *CreateVpcRequest) SetEnableIpv6(v bool) *CreateVpcRequest {
	s.EnableIpv6 = &v
	return s
}

func (s *CreateVpcRequest) SetIpv4IpamPoolId(v string) *CreateVpcRequest {
	s.Ipv4IpamPoolId = &v
	return s
}

func (s *CreateVpcRequest) SetIpv6CidrBlock(v string) *CreateVpcRequest {
	s.Ipv6CidrBlock = &v
	return s
}

func (s *CreateVpcRequest) SetIpv6Isp(v string) *CreateVpcRequest {
	s.Ipv6Isp = &v
	return s
}

func (s *CreateVpcRequest) SetOwnerAccount(v string) *CreateVpcRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateVpcRequest) SetOwnerId(v int64) *CreateVpcRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateVpcRequest) SetRegionId(v string) *CreateVpcRequest {
	s.RegionId = &v
	return s
}

func (s *CreateVpcRequest) SetResourceGroupId(v string) *CreateVpcRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *CreateVpcRequest) SetResourceOwnerAccount(v string) *CreateVpcRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateVpcRequest) SetResourceOwnerId(v int64) *CreateVpcRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreateVpcRequest) SetTag(v []*CreateVpcRequestTag) *CreateVpcRequest {
	s.Tag = v
	return s
}

func (s *CreateVpcRequest) SetUserCidr(v string) *CreateVpcRequest {
	s.UserCidr = &v
	return s
}

func (s *CreateVpcRequest) SetVpcName(v string) *CreateVpcRequest {
	s.VpcName = &v
	return s
}

type CreateVpcRequestTag struct {
	Key   *string `json:"Key,omitempty" xml:"Key,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateVpcRequestTag) String() string {
	return tea.Prettify(s)
}

func (s CreateVpcRequestTag) GoString() string {
	return s.String()
}

func (s *CreateVpcRequestTag) SetKey(v string) *CreateVpcRequestTag {
	s.Key = &v
	return s
}

func (s *CreateVpcRequestTag) SetValue(v string) *CreateVpcRequestTag {
	s.Value = &v
	return s
}

type CreateVpcResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The ID of the route table that is automatically created by the system after the VPC is created.
	RouteTableId *string `json:"RouteTableId,omitempty" xml:"RouteTableId,omitempty"`
	// The ID of the vRouter that is automatically created by the system after the VPC is created.
	VRouterId *string `json:"VRouterId,omitempty" xml:"VRouterId,omitempty"`
	// The ID of the created VPC.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s CreateVpcResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateVpcResponseBody) GoString() string {
	return s.String()
}

func (s *CreateVpcResponseBody) SetRequestId(v string) *CreateVpcResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateVpcResponseBody) SetResourceGroupId(v string) *CreateVpcResponseBody {
	s.ResourceGroupId = &v
	return s
}

func (s *CreateVpcResponseBody) SetRouteTableId(v string) *CreateVpcResponseBody {
	s.RouteTableId = &v
	return s
}

func (s *CreateVpcResponseBody) SetVRouterId(v string) *CreateVpcResponseBody {
	s.VRouterId = &v
	return s
}

func (s *CreateVpcResponseBody) SetVpcId(v string) *CreateVpcResponseBody {
	s.VpcId = &v
	return s
}

type CreateVpcResponse struct {
	Headers    map[string]*string     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateVpcResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateVpcResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateVpcResponse) GoString() string {
	return s.String()
}

func (s *CreateVpcResponse) SetHeaders(v map[string]*string) *CreateVpcResponse {
	s.Headers = v
	return s
}

func (s *CreateVpcResponse) SetStatusCode(v int32) *CreateVpcResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateVpcResponse) SetBody(v *CreateVpcResponseBody) *CreateVpcResponse {
	s.Body = v
	return s
}

type CreateVpcGatewayEndpointRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. **ClientToken** can contain only ASCII characters and cannot exceed 64 characters in length.
	//
	// >  If you do not set this parameter, the system uses **RequestId** as **ClientToken**. The value of **RequestId** of each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to perform a dry run. Valid values:
	//
	// *   **true**: performs a dry run. The system checks your AccessKey pair, the RAM user permissions, and the required parameters If the request fails the dry run, the corresponding error message is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
	// *   **false** (default): performs a dry run and sends the request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The description of the gateway endpoint.
	//
	// The description must be 1 to 255 characters in length.
	EndpointDescription *string `json:"EndpointDescription,omitempty" xml:"EndpointDescription,omitempty"`
	// The name of the gateway endpoint.
	//
	// The name must be 1 to 128 characters in length.
	EndpointName *string `json:"EndpointName,omitempty" xml:"EndpointName,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The access policy for the cloud service.
	//
	// For more information about the syntax and structure of the access policy, see [Policy syntax and structure](~~93739~~).
	PolicyDocument *string `json:"PolicyDocument,omitempty" xml:"PolicyDocument,omitempty"`
	// The region ID of the gateway endpoint.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The name of the endpoint service.
	ServiceName *string                               `json:"ServiceName,omitempty" xml:"ServiceName,omitempty"`
	Tag         []*CreateVpcGatewayEndpointRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
	// The ID of the virtual private cloud (VPC) where you want to create the gateway endpoint.
	//
	// The VPC and gateway endpoint must be deployed in the same region.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s CreateVpcGatewayEndpointRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateVpcGatewayEndpointRequest) GoString() string {
	return s.String()
}

func (s *CreateVpcGatewayEndpointRequest) SetClientToken(v string) *CreateVpcGatewayEndpointRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateVpcGatewayEndpointRequest) SetDryRun(v bool) *CreateVpcGatewayEndpointRequest {
	s.DryRun = &v
	return s
}

func (s *CreateVpcGatewayEndpointRequest) SetEndpointDescription(v string) *CreateVpcGatewayEndpointRequest {
	s.EndpointDescription = &v
	return s
}

func (s *CreateVpcGatewayEndpointRequest) SetEndpointName(v string) *CreateVpcGatewayEndpointRequest {
	s.EndpointName = &v
	return s
}

func (s *CreateVpcGatewayEndpointRequest) SetOwnerAccount(v string) *CreateVpcGatewayEndpointRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateVpcGatewayEndpointRequest) SetOwnerId(v int64) *CreateVpcGatewayEndpointRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateVpcGatewayEndpointRequest) SetPolicyDocument(v string) *CreateVpcGatewayEndpointRequest {
	s.PolicyDocument = &v
	return s
}

func (s *CreateVpcGatewayEndpointRequest) SetRegionId(v string) *CreateVpcGatewayEndpointRequest {
	s.RegionId = &v
	return s
}

func (s *CreateVpcGatewayEndpointRequest) SetResourceGroupId(v string) *CreateVpcGatewayEndpointRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *CreateVpcGatewayEndpointRequest) SetResourceOwnerAccount(v string) *CreateVpcGatewayEndpointRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateVpcGatewayEndpointRequest) SetResourceOwnerId(v int64) *CreateVpcGatewayEndpointRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreateVpcGatewayEndpointRequest) SetServiceName(v string) *CreateVpcGatewayEndpointRequest {
	s.ServiceName = &v
	return s
}

func (s *CreateVpcGatewayEndpointRequest) SetTag(v []*CreateVpcGatewayEndpointRequestTag) *CreateVpcGatewayEndpointRequest {
	s.Tag = v
	return s
}

func (s *CreateVpcGatewayEndpointRequest) SetVpcId(v string) *CreateVpcGatewayEndpointRequest {
	s.VpcId = &v
	return s
}

type CreateVpcGatewayEndpointRequestTag struct {
	Key   *string `json:"Key,omitempty" xml:"Key,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateVpcGatewayEndpointRequestTag) String() string {
	return tea.Prettify(s)
}

func (s CreateVpcGatewayEndpointRequestTag) GoString() string {
	return s.String()
}

func (s *CreateVpcGatewayEndpointRequestTag) SetKey(v string) *CreateVpcGatewayEndpointRequestTag {
	s.Key = &v
	return s
}

func (s *CreateVpcGatewayEndpointRequestTag) SetValue(v string) *CreateVpcGatewayEndpointRequestTag {
	s.Value = &v
	return s
}

type CreateVpcGatewayEndpointResponseBody struct {
	// The time when the gateway endpoint was created. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ssZ format. The time must be in UTC.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The ID of the gateway endpoint.
	EndpointId *string `json:"EndpointId,omitempty" xml:"EndpointId,omitempty"`
	// The name of the gateway endpoint.
	EndpointName *string `json:"EndpointName,omitempty" xml:"EndpointName,omitempty"`
	// The ID of the request.
	RequestId       *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The name of the endpoint service.
	ServiceName *string `json:"ServiceName,omitempty" xml:"ServiceName,omitempty"`
}

func (s CreateVpcGatewayEndpointResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateVpcGatewayEndpointResponseBody) GoString() string {
	return s.String()
}

func (s *CreateVpcGatewayEndpointResponseBody) SetCreationTime(v string) *CreateVpcGatewayEndpointResponseBody {
	s.CreationTime = &v
	return s
}

func (s *CreateVpcGatewayEndpointResponseBody) SetEndpointId(v string) *CreateVpcGatewayEndpointResponseBody {
	s.EndpointId = &v
	return s
}

func (s *CreateVpcGatewayEndpointResponseBody) SetEndpointName(v string) *CreateVpcGatewayEndpointResponseBody {
	s.EndpointName = &v
	return s
}

func (s *CreateVpcGatewayEndpointResponseBody) SetRequestId(v string) *CreateVpcGatewayEndpointResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateVpcGatewayEndpointResponseBody) SetResourceGroupId(v string) *CreateVpcGatewayEndpointResponseBody {
	s.ResourceGroupId = &v
	return s
}

func (s *CreateVpcGatewayEndpointResponseBody) SetServiceName(v string) *CreateVpcGatewayEndpointResponseBody {
	s.ServiceName = &v
	return s
}

type CreateVpcGatewayEndpointResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateVpcGatewayEndpointResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateVpcGatewayEndpointResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateVpcGatewayEndpointResponse) GoString() string {
	return s.String()
}

func (s *CreateVpcGatewayEndpointResponse) SetHeaders(v map[string]*string) *CreateVpcGatewayEndpointResponse {
	s.Headers = v
	return s
}

func (s *CreateVpcGatewayEndpointResponse) SetStatusCode(v int32) *CreateVpcGatewayEndpointResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateVpcGatewayEndpointResponse) SetBody(v *CreateVpcGatewayEndpointResponseBody) *CreateVpcGatewayEndpointResponse {
	s.Body = v
	return s
}

type CreateVpcPrefixListRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among all requests. ClientToken can contain only ASCII characters.
	//
	// >  If you do not specify this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to perform a dry run. Valid values:
	//
	// *   **true**: performs a dry run. The system checks the required parameters, request syntax, and limits. If the request fails the dry run, an error message is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
	// *   **false** (default): performs a dry run and sends the request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The IP version. Valid values:
	//
	// *   **IPv4** (default)
	// *   **IPv6**
	IpVersion *string `json:"IpVersion,omitempty" xml:"IpVersion,omitempty"`
	// The maximum number of CIDR blocks that you can specify in the prefix list. Default value: 50.
	MaxEntries   *int32  `json:"MaxEntries,omitempty" xml:"MaxEntries,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The description of the prefix list.
	//
	// The description must be 1 to 256 characters in length and cannot start with `http://` or `https://`.
	PrefixListDescription *string                                        `json:"PrefixListDescription,omitempty" xml:"PrefixListDescription,omitempty"`
	PrefixListEntries     []*CreateVpcPrefixListRequestPrefixListEntries `json:"PrefixListEntries,omitempty" xml:"PrefixListEntries,omitempty" type:"Repeated"`
	// The name of the prefix list.
	//
	// The name must be 1 to 128 characters in length, and cannot start with `http://` or `https://`.
	PrefixListName *string `json:"PrefixListName,omitempty" xml:"PrefixListName,omitempty"`
	// The ID of the region where you want to create the prefix list.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group to which the prefix list belongs.
	ResourceGroupId      *string                          `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string                          `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64                           `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	Tag                  []*CreateVpcPrefixListRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s CreateVpcPrefixListRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateVpcPrefixListRequest) GoString() string {
	return s.String()
}

func (s *CreateVpcPrefixListRequest) SetClientToken(v string) *CreateVpcPrefixListRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateVpcPrefixListRequest) SetDryRun(v bool) *CreateVpcPrefixListRequest {
	s.DryRun = &v
	return s
}

func (s *CreateVpcPrefixListRequest) SetIpVersion(v string) *CreateVpcPrefixListRequest {
	s.IpVersion = &v
	return s
}

func (s *CreateVpcPrefixListRequest) SetMaxEntries(v int32) *CreateVpcPrefixListRequest {
	s.MaxEntries = &v
	return s
}

func (s *CreateVpcPrefixListRequest) SetOwnerAccount(v string) *CreateVpcPrefixListRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateVpcPrefixListRequest) SetOwnerId(v int64) *CreateVpcPrefixListRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateVpcPrefixListRequest) SetPrefixListDescription(v string) *CreateVpcPrefixListRequest {
	s.PrefixListDescription = &v
	return s
}

func (s *CreateVpcPrefixListRequest) SetPrefixListEntries(v []*CreateVpcPrefixListRequestPrefixListEntries) *CreateVpcPrefixListRequest {
	s.PrefixListEntries = v
	return s
}

func (s *CreateVpcPrefixListRequest) SetPrefixListName(v string) *CreateVpcPrefixListRequest {
	s.PrefixListName = &v
	return s
}

func (s *CreateVpcPrefixListRequest) SetRegionId(v string) *CreateVpcPrefixListRequest {
	s.RegionId = &v
	return s
}

func (s *CreateVpcPrefixListRequest) SetResourceGroupId(v string) *CreateVpcPrefixListRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *CreateVpcPrefixListRequest) SetResourceOwnerAccount(v string) *CreateVpcPrefixListRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateVpcPrefixListRequest) SetResourceOwnerId(v int64) *CreateVpcPrefixListRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreateVpcPrefixListRequest) SetTag(v []*CreateVpcPrefixListRequestTag) *CreateVpcPrefixListRequest {
	s.Tag = v
	return s
}

type CreateVpcPrefixListRequestPrefixListEntries struct {
	// The CIDR block specified in the prefix list.
	Cidr *string `json:"Cidr,omitempty" xml:"Cidr,omitempty"`
	// The description of the CIDR block specified in the prefix list.
	//
	// The description must be 1 to 256 characters in length and cannot start with `http://` or `https://`.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
}

func (s CreateVpcPrefixListRequestPrefixListEntries) String() string {
	return tea.Prettify(s)
}

func (s CreateVpcPrefixListRequestPrefixListEntries) GoString() string {
	return s.String()
}

func (s *CreateVpcPrefixListRequestPrefixListEntries) SetCidr(v string) *CreateVpcPrefixListRequestPrefixListEntries {
	s.Cidr = &v
	return s
}

func (s *CreateVpcPrefixListRequestPrefixListEntries) SetDescription(v string) *CreateVpcPrefixListRequestPrefixListEntries {
	s.Description = &v
	return s
}

type CreateVpcPrefixListRequestTag struct {
	Key   *string `json:"Key,omitempty" xml:"Key,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateVpcPrefixListRequestTag) String() string {
	return tea.Prettify(s)
}

func (s CreateVpcPrefixListRequestTag) GoString() string {
	return s.String()
}

func (s *CreateVpcPrefixListRequestTag) SetKey(v string) *CreateVpcPrefixListRequestTag {
	s.Key = &v
	return s
}

func (s *CreateVpcPrefixListRequestTag) SetValue(v string) *CreateVpcPrefixListRequestTag {
	s.Value = &v
	return s
}

type CreateVpcPrefixListResponseBody struct {
	// The ID of the prefix list.
	PrefixListId *string `json:"PrefixListId,omitempty" xml:"PrefixListId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the resource group to which the prefix list belongs.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
}

func (s CreateVpcPrefixListResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateVpcPrefixListResponseBody) GoString() string {
	return s.String()
}

func (s *CreateVpcPrefixListResponseBody) SetPrefixListId(v string) *CreateVpcPrefixListResponseBody {
	s.PrefixListId = &v
	return s
}

func (s *CreateVpcPrefixListResponseBody) SetRequestId(v string) *CreateVpcPrefixListResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateVpcPrefixListResponseBody) SetResourceGroupId(v string) *CreateVpcPrefixListResponseBody {
	s.ResourceGroupId = &v
	return s
}

type CreateVpcPrefixListResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateVpcPrefixListResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateVpcPrefixListResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateVpcPrefixListResponse) GoString() string {
	return s.String()
}

func (s *CreateVpcPrefixListResponse) SetHeaders(v map[string]*string) *CreateVpcPrefixListResponse {
	s.Headers = v
	return s
}

func (s *CreateVpcPrefixListResponse) SetStatusCode(v int32) *CreateVpcPrefixListResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateVpcPrefixListResponse) SetBody(v *CreateVpcPrefixListResponseBody) *CreateVpcPrefixListResponse {
	s.Body = v
	return s
}

type CreateVpconnFromVbrRequest struct {
	// Specifies whether to only precheck the request. Valid values:
	//
	// *   **true**: checks the API request. If the request passes the precheck, the operation is not performed. Check items include the request format, instance status, and whether the required parameters are specified. If the request fails the precheck, the system returns an error. If the request passes the precheck, the system returns the ID of the request.
	// *   **false** (default): sends the API request. If the request passes the precheck, the operation is performed.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// Specifies the party that must pay for the shared Express Connect circuit. Valid values:
	//
	// *   **PayByPhysicalConnectionOwner**: If you set the value to PayByPhysicalConnectionOwner, the Express Connect partner must pay for the shared Express Connect circuit.
	// *   **PayByVirtualPhysicalConnectionOwner**: If you set the value to PayByVirtualPhysicalConnectionOwner, the tenant must pay for the shared Express Connect circuit.
	OrderMode *string `json:"OrderMode,omitempty" xml:"OrderMode,omitempty"`
	// The region ID of the shared Express Connect circuit.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	Token *string `json:"Token,omitempty" xml:"Token,omitempty"`
	// The ID of the associated VBR.
	VbrId *string `json:"VbrId,omitempty" xml:"VbrId,omitempty"`
}

func (s CreateVpconnFromVbrRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateVpconnFromVbrRequest) GoString() string {
	return s.String()
}

func (s *CreateVpconnFromVbrRequest) SetDryRun(v bool) *CreateVpconnFromVbrRequest {
	s.DryRun = &v
	return s
}

func (s *CreateVpconnFromVbrRequest) SetOrderMode(v string) *CreateVpconnFromVbrRequest {
	s.OrderMode = &v
	return s
}

func (s *CreateVpconnFromVbrRequest) SetRegionId(v string) *CreateVpconnFromVbrRequest {
	s.RegionId = &v
	return s
}

func (s *CreateVpconnFromVbrRequest) SetToken(v string) *CreateVpconnFromVbrRequest {
	s.Token = &v
	return s
}

func (s *CreateVpconnFromVbrRequest) SetVbrId(v string) *CreateVpconnFromVbrRequest {
	s.VbrId = &v
	return s
}

type CreateVpconnFromVbrResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the shared Express Connect circuit.
	VirtualPhysicalConnection *string `json:"VirtualPhysicalConnection,omitempty" xml:"VirtualPhysicalConnection,omitempty"`
}

func (s CreateVpconnFromVbrResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateVpconnFromVbrResponseBody) GoString() string {
	return s.String()
}

func (s *CreateVpconnFromVbrResponseBody) SetRequestId(v string) *CreateVpconnFromVbrResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateVpconnFromVbrResponseBody) SetVirtualPhysicalConnection(v string) *CreateVpconnFromVbrResponseBody {
	s.VirtualPhysicalConnection = &v
	return s
}

type CreateVpconnFromVbrResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateVpconnFromVbrResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateVpconnFromVbrResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateVpconnFromVbrResponse) GoString() string {
	return s.String()
}

func (s *CreateVpconnFromVbrResponse) SetHeaders(v map[string]*string) *CreateVpconnFromVbrResponse {
	s.Headers = v
	return s
}

func (s *CreateVpconnFromVbrResponse) SetStatusCode(v int32) *CreateVpconnFromVbrResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateVpconnFromVbrResponse) SetBody(v *CreateVpconnFromVbrResponseBody) *CreateVpconnFromVbrResponse {
	s.Body = v
	return s
}

type CreateVpnAttachmentRequest struct {
	// Specifies whether to automatically configure routes. Valid values:
	//
	// *   **true** (default)
	// *   **false**
	AutoConfigRoute *bool `json:"AutoConfigRoute,omitempty" xml:"AutoConfigRoute,omitempty"`
	// The Border Gateway Protocol (BGP) configuration:
	//
	// *   **BgpConfig.EnableBgp**: specifies whether to enable BGP. Valid values: **true** and **false**. Default value: false.
	// *   **BgpConfig.LocalAsn**: the ASN on the Alibaba Cloud side. Valid values: **1** to **4294967295**. Default value: **45104**.
	// *   **BgpConfig.TunnelCidr**: the CIDR block of the IPsec tunnel. The CIDR block must fall within 169.254.0.0/16. The subnet mask of the CIDR block must be 30 bits in length.
	// *   **LocalBgpIp**: the BGP IP address on the Alibaba Cloud side. This IP address must fall within the CIDR block of the IPsec tunnel.
	//
	// >
	//
	// *   Before you configure BGP, we recommend that you learn about how BGP works and its limits. For more information, see Notice of BGP dynamic routing.
	//
	// *   We recommend that you use a private ASN to establish a connection with Alibaba Cloud over BGP. Refer to the relevant documentation for the private ASN range.
	BgpConfig *string `json:"BgpConfig,omitempty" xml:"BgpConfig,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters.
	//
	// > If you do not specify this parameter, the system automatically uses the **request ID** as the **client token**. The **request ID** may be different for each request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the customer gateway.
	CustomerGatewayId *string `json:"CustomerGatewayId,omitempty" xml:"CustomerGatewayId,omitempty"`
	// Specifies whether to immediately start IPsec negotiations after the configuration takes effect. Valid values:
	//
	// *   **true**: immediately starts IPsec negotiations after the configuration is complete.
	// *   **false** (default): starts IPsec negotiations when inbound traffic is received.
	EffectImmediately *bool `json:"EffectImmediately,omitempty" xml:"EffectImmediately,omitempty"`
	// Specifies whether to enable the dead peer detection (DPD) feature. Valid values:
	//
	// *   **true** (default) The initiator of the IPsec-VPN connection sends DPD packets to verify the existence and availability of the peer. If no response is received from the peer within a specified period of time, the connection fails. ISAKMP SAs and IPsec SAs are deleted. The IPsec tunnel is also deleted.
	// *   **false**
	EnableDpd *bool `json:"EnableDpd,omitempty" xml:"EnableDpd,omitempty"`
	// Specifies whether to enable NAT traversal. Valid values:
	//
	// *   **true** (default) After NAT traversal is enabled, the initiator does not check the UDP ports during IKE negotiations and can automatically discover NAT gateway devices along the VPN tunnel.
	// *   **false**
	EnableNatTraversal *bool `json:"EnableNatTraversal,omitempty" xml:"EnableNatTraversal,omitempty"`
	// The health check configuration:
	//
	// *   **HealthCheckConfig.enable**: specifies whether to enable health checks. Valid values: **true** and **false**. Default value: false.
	//
	// *   **HealthCheckConfig.dip**: the destination IP address that is used for health checks. Enter the IP address on the data center side that the VPC can communicate with through the IPsec-VPN connection.
	//
	// *   **HealthCheckConfig.sip**: the source IP address that is used for health checks. Enter the IP address on the VPC side that the data center can communicate with through the IPsec-VPN connection.
	//
	// *   **HealthCheckConfig.interval**: the interval between two consecutive health checks. Unit: seconds. Default value: **3**.
	//
	// *   **HealthCheckConfig.retry**: the maximum number of health check retries. Default value: **3**.
	//
	// *   **HealthCheckConfig.Policy**: specifies whether to withdraw published routes when health checks fail. Valid values:
	//
	//         - **revoke_route**(default): revokes published routes.
	//           - **reserve_route**: does not revoke published routes.
	HealthCheckConfig *string `json:"HealthCheckConfig,omitempty" xml:"HealthCheckConfig,omitempty"`
	// The configuration of Phase 1 negotiations:
	//
	// *   **IkeConfig.Psk**: The pre-shared key that is used for authentication between the VPN gateway and the data center. The key must be 1 to 100 characters in length.
	//
	//         If you do not specify a pre-shared key, the system generates a random 16-character string as the pre-shared key. You can call the DescribeVpnConnection operation to query the pre-shared key generated by the system.
	//
	//           The pre-shared key of the IPsec-VPN connection must be the same as the authentication key of the data center. Otherwise, the connection between the data center and the VPN gateway cannot be established.
	//
	// *   **IkeConfig.IkeVersion**: the IKE version. Valid values: **ikev1** and **ikev2**. Default value: **ikev1**.
	//
	// *   **IkeConfig.IkeMode**: the negotiation mode. Valid values: **main** and **aggressive**. Default value: **main**.
	//
	// *   **IkeConfig.IkeEncAlg**: the encryption algorithm that is used in Phase 1 negotiations. Valid values: **aes**, **aes192**, **aes256**, **des**, and **3des**. Default value: **aes**.
	//
	// *   **IkeConfig.IkeAuthAlg**: the authentication algorithm that is used in Phase 1 negotiations. Valid values: **md5**, **sha1**, **sha256**, **sha384**, and **sha512**. Default value: **md5**.
	//
	// *   **IkeConfig.IkePfs**: The Diffie-Hellman key exchange algorithm that is used in Phase 1 negotiations. Valid values: **group1**, **group2**, **group5**, and **group14**. Default value: **group2**.
	//
	// *   **IkeConfig.IkeLifetime**: the SA lifetime determined by Phase 1 negotiations. Unit: seconds. Valid values: **0** to **86400**. Default value: **86400**.
	//
	// *   **IkeConfig.LocalId**: the identifier on the Alibaba Cloud side. The identifier cannot exceed 100 characters in length. This parameter is empty by default.
	//
	// *   **IkeConfig.RemoteId**: the identifier on the data center side. The identifier cannot exceed 100 characters in length. The default value is the IP address of the customer gateway.
	IkeConfig *string `json:"IkeConfig,omitempty" xml:"IkeConfig,omitempty"`
	// The configurations of Phase 2 negotiations:
	//
	// *   **IpsecConfig.IpsecEncAlg**: the encryption algorithm that is used in Phase 2 negotiations. Valid values: **aes**, **aes192**, **aes256**, **des**, and **3des**. Default value: **aes**.
	// *   **IpsecConfig. IpsecAuthAlg**: the authentication algorithm that is used in Phase 2 negotiations. Valid values: **md5**, **sha1**, **sha256**, **sha384**, and **sha512**. Default value: **md5**.
	// *   **IpsecConfig. IpsecPfs**: the Diffie-Hellman key exchange algorithm that is used in Phase 2 negotiations. Valid values: **disabled**, **group1**, **group2**, **group5**, and **group14**. Default value: **group2**.
	// *   **IpsecConfig. IpsecLifetime**: the SA lifetime that is determined by Phase 2 negotiations. Unit: seconds. Valid values: **0** to **86400**. Default value: **86400**.
	IpsecConfig *string `json:"IpsecConfig,omitempty" xml:"IpsecConfig,omitempty"`
	// The CIDR block on the VPC side. The CIDR block is used in Phase 2 negotiations.
	//
	// Separate multiple CIDR blocks with commas (,). Example: 192.168.1.0/24,192.168.2.0/24.
	//
	// The following routing modes are supported:
	//
	// *   If you set **LocalSubnet** and **RemoteSubnet** to 0.0.0.0/0, the routing mode of the IPsec-VPN connection is set to Destination Routing Mode.
	// *   If you set **LocalSubnet** and **RemoteSubnet** to specific CIDR blocks, the routing mode of the IPsec-VPN connection is set to Protected Data Flows.
	LocalSubnet *string `json:"LocalSubnet,omitempty" xml:"LocalSubnet,omitempty"`
	// The name of the IPsec-VPN connection.
	//
	// The name must be 1 to 100 characters in length and cannot start with `http://` or `https://`.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The network type of the IPsec-VPN connection. Valid values:
	//
	// *   **public** (default)
	// *   **private**
	NetworkType  *string `json:"NetworkType,omitempty" xml:"NetworkType,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	// The ID of the region where the IPsec-VPN connection is established.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent list of regions.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The peer CA certificate when a ShangMi (SM) VPN gateway is used to create the IPsec-VPN connection.
	RemoteCaCert *string `json:"RemoteCaCert,omitempty" xml:"RemoteCaCert,omitempty"`
	// The CIDR block on the data center side. This CIDR block is used in Phase 2 negotiations.
	//
	// Separate multiple CIDR blocks with commas (,). Example: 192.168.3.0/24,192.168.4.0/24.
	//
	// The following routing modes are supported:
	//
	// *   If you set **LocalSubnet** and **RemoteSubnet** to 0.0.0.0/0, the routing mode of the IPsec-VPN connection is set to Destination Routing Mode.
	// *   If you set **LocalSubnet** and **RemoteSubnet** to specific CIDR blocks, the routing mode of the IPsec-VPN connection is set to Protected Data Flows.
	RemoteSubnet         *string `json:"RemoteSubnet,omitempty" xml:"RemoteSubnet,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The tag value.
	//
	// The tag value can be an empty string and cannot exceed 128 characters in length. It cannot start with `aliyun` or `acs:`, and cannot contain `http://` or `https://`.
	//
	// Each tag key corresponds to one tag value. You can specify up to 20 tag values in each call.
	Tags []*CreateVpnAttachmentRequestTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
}

func (s CreateVpnAttachmentRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateVpnAttachmentRequest) GoString() string {
	return s.String()
}

func (s *CreateVpnAttachmentRequest) SetAutoConfigRoute(v bool) *CreateVpnAttachmentRequest {
	s.AutoConfigRoute = &v
	return s
}

func (s *CreateVpnAttachmentRequest) SetBgpConfig(v string) *CreateVpnAttachmentRequest {
	s.BgpConfig = &v
	return s
}

func (s *CreateVpnAttachmentRequest) SetClientToken(v string) *CreateVpnAttachmentRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateVpnAttachmentRequest) SetCustomerGatewayId(v string) *CreateVpnAttachmentRequest {
	s.CustomerGatewayId = &v
	return s
}

func (s *CreateVpnAttachmentRequest) SetEffectImmediately(v bool) *CreateVpnAttachmentRequest {
	s.EffectImmediately = &v
	return s
}

func (s *CreateVpnAttachmentRequest) SetEnableDpd(v bool) *CreateVpnAttachmentRequest {
	s.EnableDpd = &v
	return s
}

func (s *CreateVpnAttachmentRequest) SetEnableNatTraversal(v bool) *CreateVpnAttachmentRequest {
	s.EnableNatTraversal = &v
	return s
}

func (s *CreateVpnAttachmentRequest) SetHealthCheckConfig(v string) *CreateVpnAttachmentRequest {
	s.HealthCheckConfig = &v
	return s
}

func (s *CreateVpnAttachmentRequest) SetIkeConfig(v string) *CreateVpnAttachmentRequest {
	s.IkeConfig = &v
	return s
}

func (s *CreateVpnAttachmentRequest) SetIpsecConfig(v string) *CreateVpnAttachmentRequest {
	s.IpsecConfig = &v
	return s
}

func (s *CreateVpnAttachmentRequest) SetLocalSubnet(v string) *CreateVpnAttachmentRequest {
	s.LocalSubnet = &v
	return s
}

func (s *CreateVpnAttachmentRequest) SetName(v string) *CreateVpnAttachmentRequest {
	s.Name = &v
	return s
}

func (s *CreateVpnAttachmentRequest) SetNetworkType(v string) *CreateVpnAttachmentRequest {
	s.NetworkType = &v
	return s
}

func (s *CreateVpnAttachmentRequest) SetOwnerAccount(v string) *CreateVpnAttachmentRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateVpnAttachmentRequest) SetRegionId(v string) *CreateVpnAttachmentRequest {
	s.RegionId = &v
	return s
}

func (s *CreateVpnAttachmentRequest) SetRemoteCaCert(v string) *CreateVpnAttachmentRequest {
	s.RemoteCaCert = &v
	return s
}

func (s *CreateVpnAttachmentRequest) SetRemoteSubnet(v string) *CreateVpnAttachmentRequest {
	s.RemoteSubnet = &v
	return s
}

func (s *CreateVpnAttachmentRequest) SetResourceOwnerAccount(v string) *CreateVpnAttachmentRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateVpnAttachmentRequest) SetResourceOwnerId(v int64) *CreateVpnAttachmentRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreateVpnAttachmentRequest) SetTags(v []*CreateVpnAttachmentRequestTags) *CreateVpnAttachmentRequest {
	s.Tags = v
	return s
}

type CreateVpnAttachmentRequestTags struct {
	// The tag key. The tag key cannot be an empty string.
	//
	// It can be at most 64 characters in length, and cannot contain `http://` or `https://`. It cannot start with `aliyun` or `acs:`.
	//
	// You can specify at most 20 tag keys in each call.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value.
	//
	// The tag value can be an empty string and cannot exceed 128 characters in length. It cannot start with `aliyun` or `acs:`, and cannot contain `http://` or `https://`.
	//
	// Each tag key corresponds to one tag value. You can specify at most 20 tag values in each call.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateVpnAttachmentRequestTags) String() string {
	return tea.Prettify(s)
}

func (s CreateVpnAttachmentRequestTags) GoString() string {
	return s.String()
}

func (s *CreateVpnAttachmentRequestTags) SetKey(v string) *CreateVpnAttachmentRequestTags {
	s.Key = &v
	return s
}

func (s *CreateVpnAttachmentRequestTags) SetValue(v string) *CreateVpnAttachmentRequestTags {
	s.Value = &v
	return s
}

type CreateVpnAttachmentResponseBody struct {
	// The status code returned by the current operation. **200** indicates that the operation is successful.
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The timestamp generated when the IPsec-VPN connection was established. Unit: milliseconds.
	//
	// This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The information returned by the current operation.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The name of the IPsec-VPN connection.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the current operation is successful.
	//
	// *   **true**
	// *   **false**
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The ID of the IPsec-VPN connection.
	VpnConnectionId *string `json:"VpnConnectionId,omitempty" xml:"VpnConnectionId,omitempty"`
}

func (s CreateVpnAttachmentResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateVpnAttachmentResponseBody) GoString() string {
	return s.String()
}

func (s *CreateVpnAttachmentResponseBody) SetCode(v string) *CreateVpnAttachmentResponseBody {
	s.Code = &v
	return s
}

func (s *CreateVpnAttachmentResponseBody) SetCreateTime(v int64) *CreateVpnAttachmentResponseBody {
	s.CreateTime = &v
	return s
}

func (s *CreateVpnAttachmentResponseBody) SetMessage(v string) *CreateVpnAttachmentResponseBody {
	s.Message = &v
	return s
}

func (s *CreateVpnAttachmentResponseBody) SetName(v string) *CreateVpnAttachmentResponseBody {
	s.Name = &v
	return s
}

func (s *CreateVpnAttachmentResponseBody) SetRequestId(v string) *CreateVpnAttachmentResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateVpnAttachmentResponseBody) SetSuccess(v bool) *CreateVpnAttachmentResponseBody {
	s.Success = &v
	return s
}

func (s *CreateVpnAttachmentResponseBody) SetVpnConnectionId(v string) *CreateVpnAttachmentResponseBody {
	s.VpnConnectionId = &v
	return s
}

type CreateVpnAttachmentResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateVpnAttachmentResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateVpnAttachmentResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateVpnAttachmentResponse) GoString() string {
	return s.String()
}

func (s *CreateVpnAttachmentResponse) SetHeaders(v map[string]*string) *CreateVpnAttachmentResponse {
	s.Headers = v
	return s
}

func (s *CreateVpnAttachmentResponse) SetStatusCode(v int32) *CreateVpnAttachmentResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateVpnAttachmentResponse) SetBody(v *CreateVpnAttachmentResponseBody) *CreateVpnAttachmentResponse {
	s.Body = v
	return s
}

type CreateVpnConnectionRequest struct {
	// Specifies whether to automatically configure routes. Valid values:
	//
	// *   **true** (default)
	// *   **false**
	AutoConfigRoute *bool `json:"AutoConfigRoute,omitempty" xml:"AutoConfigRoute,omitempty"`
	// The Border Gateway Protocol (BGP) configuration:
	//
	// *   **BgpConfig.EnableBgp**: specifies whether to enable BGP. Valid values: **true** and **false**. Default value: false.
	// *   **BgpConfig.LocalAsn**: the ASN on the Alibaba Cloud side. Valid values: **1** to **4294967295**. Default value: **45104**.
	// *   **BgpConfig.TunnelCidr**: the CIDR block of the IPsec tunnel. The CIDR block must fall within 169.254.0.0/16. The subnet mask of the CIDR block must be 30 bits in length.
	// *   **LocalBgpIp**: the BGP IP address on the Alibaba Cloud side. This IP address must fall within the CIDR block of the IPsec tunnel.
	//
	// >
	//
	// *   This parameter is required when the VPN gateway has dynamic BGP enabled.
	//
	// *   Before you configure BGP, we recommend that you learn about how BGP works and its limits. For more information, see [VPN Gateway supports BGP dynamic routing](~~170235~~).
	// *   We recommend that you use a private ASN to establish a connection with Alibaba Cloud over BGP. Refer to the relevant documentation for the private ASN range.
	BgpConfig *string `json:"BgpConfig,omitempty" xml:"BgpConfig,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters.
	//
	// > If you do not specify this parameter, the system automatically uses the **request ID** as the **client token**. The **request ID** may be different for each request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the customer gateway.
	CustomerGatewayId *string `json:"CustomerGatewayId,omitempty" xml:"CustomerGatewayId,omitempty"`
	// Specify whether to immediately start IPsec negotiations after the configuration takes effect. Valid values:
	//
	// *   **true**: immediately starts IPsec negotiations after the configuration is complete.
	// *   **false** (default): starts IPsec negotiations when inbound traffic is received.
	EffectImmediately *bool `json:"EffectImmediately,omitempty" xml:"EffectImmediately,omitempty"`
	// Specifies whether to enable the dead peer detection (DPD) feature. Valid values:
	//
	// *   **true** (default) The initiator of the IPsec-VPN connection sends DPD packets to verify the existence and availability of the peer. If no response is received from the peer within a specified period of time, the connection fails. ISAKMP SAs and IPsec SAs are deleted. The IPsec tunnel is also deleted.
	// *   **false**: disables DPD. The IPsec initiator does not send DPD packets.
	EnableDpd *bool `json:"EnableDpd,omitempty" xml:"EnableDpd,omitempty"`
	// Specifies whether to enable NAT traversal. Valid values:
	//
	// *   **true** (default) After NAT traversal is enabled, the initiator does not check the UDP ports during IKE negotiations and can automatically discover NAT gateway devices along the VPN tunnel.
	// *   **false**
	EnableNatTraversal *bool `json:"EnableNatTraversal,omitempty" xml:"EnableNatTraversal,omitempty"`
	// 是否为隧道开启BGP功能。取值：**true**或**false**（默认值）。
	EnableTunnelsBgp *bool `json:"EnableTunnelsBgp,omitempty" xml:"EnableTunnelsBgp,omitempty"`
	// The health check configuration:
	//
	// *   **HealthCheckConfig.enable**: specifies whether to enable health checks. Valid values: **true** and **false**. Default value: false.
	// *   **HealthCheckConfig.dip**: the destination IP address configured for health checks.
	// *   **HealthCheckConfig.sip:** the source IP address that is used for health checks.
	// *   **HealthCheckConfig.interval**: the time interval of health check retries. Unit: seconds. Default value: **3**.
	// *   **HealthCheckConfig.retry**: the maximum number of health check retries. Default value: **3**.
	HealthCheckConfig *string `json:"HealthCheckConfig,omitempty" xml:"HealthCheckConfig,omitempty"`
	// The configuration of Phase 1 negotiations:
	//
	// *   **IkeConfig.Psk**: The pre-shared key that is used for authentication between the VPN gateway and the data center. The key must be 1 to 100 characters in length.
	//
	//         If you do not specify a pre-shared key, the system generates a random 16-character string as the pre-shared key. You can call the DescribeVpnConnection operation to query the pre-shared key generated by the system.
	//
	//           The pre-shared key of the IPsec-VPN connection must be the same as the authentication key of the data center. Otherwise, the connection between the data center and the VPN gateway cannot be established.
	//
	// *   **IkeConfig.IkeVersion**: the IKE version. Valid values: **ikev1** and **ikev2**. Default value: **ikev1**.
	//
	// *   **IkeConfig.IkeMode**: the negotiation mode of IKEv1. Valid values: **main** and **aggressive**. Default value: **main**.
	//
	// *   **IkeConfig.IkeEncAlg**: the encryption algorithm that is used in Phase 1 negotiations. Valid values: **aes**, **aes192**, **aes256**, **des**, and **3des**. Default value: **aes**.
	//
	// *   **IkeConfig.IkeAuthAlg**: the authentication algorithm that is used in Phase 1 negotiations. Valid values: **md5**, **sha1**, **sha256**, **sha384**, and **sha512**. Default value: **md5**.
	//
	// *   **IkeConfig.IkePfs**: The Diffie-Hellman (DH) key exchange algorithm that is used in Phase 1 negotiations. Valid values: **group1**, **group2**, **group5**, and **group14**. Default value: **group2**.
	//
	// *   **IkeConfig.IkeLifetime**: the SA lifetime determined by Phase 1 negotiations. Unit: seconds. Valid values: **0** to **86400**. Default value: **86400**.
	//
	// *   **IkeConfig.LocalId**: the identifier of the VPN gateway. The identifier of the VPN gateway cannot exceed 100 characters in length. The default value is the IP address of the VPN gateway.
	//
	// *   **IkeConfig.RemoteId**: the identifier of the customer gateway. The identifier of the customer gateway cannot exceed 100 characters in length. The default value is the IP address of the customer gateway.
	IkeConfig *string `json:"IkeConfig,omitempty" xml:"IkeConfig,omitempty"`
	// The configurations of Phase 2 negotiations:
	//
	// *   **IpsecConfig.IpsecEncAlg**: the encryption algorithm that is used in Phase 2 negotiations. Valid values: **aes**, **aes192**, **aes256**, **des**, and **3des**. Default value: **aes**.
	// *   **IpsecConfig. IpsecAuthAlg**: the authentication algorithm that is used in Phase 2 negotiations. Valid values: **md5**, **sha1**, **sha256**, **sha384**, and **sha512**. Default value: **md5**.
	// *   **IpsecConfig. IpsecPfs**: the Diffie-Hellman key exchange algorithm that is used in Phase 2 negotiations. Valid values: **disabled**, **group1**, **group2**, **group5**, and **group14**. Default value: **group2**.
	// *   **IpsecConfig. IpsecLifetime**: the SA lifetime that is determined by Phase 2 negotiations. Unit: seconds. Valid values: **0** to **86400**. Default value: **86400**.
	IpsecConfig *string `json:"IpsecConfig,omitempty" xml:"IpsecConfig,omitempty"`
	// The CIDR block on the virtual private cloud (VPC) side. The CIDR block is used in Phase 2 negotiations.
	//
	// Separate CIDR blocks with commas (,). Example: 192.168.1.0/24,192.168.2.0/24.
	//
	// The following routing modes are supported:
	//
	// *   If you set **LocalSubnet** and **RemoteSubnet** to 0.0.0.0/0, the routing mode of the IPsec-VPN connection is set to Destination Routing Mode.
	// *   If you set **LocalSubnet** and **RemoteSubnet** to specific CIDR blocks, the routing mode of the IPsec-VPN connection is set to Protected Data Flows.
	LocalSubnet *string `json:"LocalSubnet,omitempty" xml:"LocalSubnet,omitempty"`
	// The name of the IPsec-VPN connection.
	//
	// The name must be 1 to 100 characters in length and cannot start with `http://` or `https://`.
	Name         *string `json:"Name,omitempty" xml:"Name,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region where the IPsec-VPN connection is created. You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The peer CA certificate when a ShangMi (SM) VPN gateway is used to establish the IPsec-VPN connection.
	//
	// *   This parameter is required when an SM VPN gateway is used to establish the IPsec-VPN connection.
	// *   You can ignore this parameter when a standard VPN gateway is used to create the IPsec-VPN connection.
	RemoteCaCertificate *string `json:"RemoteCaCertificate,omitempty" xml:"RemoteCaCertificate,omitempty"`
	// The CIDR block on the data center side. This CIDR block is used in Phase 2 negotiations.
	//
	// Separate CIDR blocks with commas (,). Example: 192.168.3.0/24,192.168.4.0/24.
	//
	// The following routing modes are supported:
	//
	// *   If you set **LocalSubnet** and **RemoteSubnet** to 0.0.0.0/0, the routing mode of the IPsec-VPN connection is set to Destination Routing Mode.
	// *   If you set **LocalSubnet** and **RemoteSubnet** to specific CIDR blocks, the routing mode of the IPsec-VPN connection is set to Protected Data Flows.
	RemoteSubnet         *string `json:"RemoteSubnet,omitempty" xml:"RemoteSubnet,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The tag value.
	//
	// The tag value can be an empty string and cannot exceed 128 characters in length. It cannot start with `aliyun` or `acs:`, and cannot contain `http://` or `https://`.
	//
	// Each tag key corresponds to one tag value. You can specify up to 20 tag values in each call.
	Tags []*CreateVpnConnectionRequestTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
	// 配置隧道。
	//
	// 如果当前VPN网关实例支持创建双隧道模式的IPsec-VPN连接，您必须同时为IPsec-VPN连接添加主隧道和备隧道的配置（即配置**TunnelOptionsSpecification**数组下的参数）。一个IPsec-VPN连接下仅支持添加主备两条隧道。
	TunnelOptionsSpecification []*CreateVpnConnectionRequestTunnelOptionsSpecification `json:"TunnelOptionsSpecification,omitempty" xml:"TunnelOptionsSpecification,omitempty" type:"Repeated"`
	// The ID of the VPN gateway.
	VpnGatewayId *string `json:"VpnGatewayId,omitempty" xml:"VpnGatewayId,omitempty"`
}

func (s CreateVpnConnectionRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateVpnConnectionRequest) GoString() string {
	return s.String()
}

func (s *CreateVpnConnectionRequest) SetAutoConfigRoute(v bool) *CreateVpnConnectionRequest {
	s.AutoConfigRoute = &v
	return s
}

func (s *CreateVpnConnectionRequest) SetBgpConfig(v string) *CreateVpnConnectionRequest {
	s.BgpConfig = &v
	return s
}

func (s *CreateVpnConnectionRequest) SetClientToken(v string) *CreateVpnConnectionRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateVpnConnectionRequest) SetCustomerGatewayId(v string) *CreateVpnConnectionRequest {
	s.CustomerGatewayId = &v
	return s
}

func (s *CreateVpnConnectionRequest) SetEffectImmediately(v bool) *CreateVpnConnectionRequest {
	s.EffectImmediately = &v
	return s
}

func (s *CreateVpnConnectionRequest) SetEnableDpd(v bool) *CreateVpnConnectionRequest {
	s.EnableDpd = &v
	return s
}

func (s *CreateVpnConnectionRequest) SetEnableNatTraversal(v bool) *CreateVpnConnectionRequest {
	s.EnableNatTraversal = &v
	return s
}

func (s *CreateVpnConnectionRequest) SetEnableTunnelsBgp(v bool) *CreateVpnConnectionRequest {
	s.EnableTunnelsBgp = &v
	return s
}

func (s *CreateVpnConnectionRequest) SetHealthCheckConfig(v string) *CreateVpnConnectionRequest {
	s.HealthCheckConfig = &v
	return s
}

func (s *CreateVpnConnectionRequest) SetIkeConfig(v string) *CreateVpnConnectionRequest {
	s.IkeConfig = &v
	return s
}

func (s *CreateVpnConnectionRequest) SetIpsecConfig(v string) *CreateVpnConnectionRequest {
	s.IpsecConfig = &v
	return s
}

func (s *CreateVpnConnectionRequest) SetLocalSubnet(v string) *CreateVpnConnectionRequest {
	s.LocalSubnet = &v
	return s
}

func (s *CreateVpnConnectionRequest) SetName(v string) *CreateVpnConnectionRequest {
	s.Name = &v
	return s
}

func (s *CreateVpnConnectionRequest) SetOwnerAccount(v string) *CreateVpnConnectionRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateVpnConnectionRequest) SetOwnerId(v int64) *CreateVpnConnectionRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateVpnConnectionRequest) SetRegionId(v string) *CreateVpnConnectionRequest {
	s.RegionId = &v
	return s
}

func (s *CreateVpnConnectionRequest) SetRemoteCaCertificate(v string) *CreateVpnConnectionRequest {
	s.RemoteCaCertificate = &v
	return s
}

func (s *CreateVpnConnectionRequest) SetRemoteSubnet(v string) *CreateVpnConnectionRequest {
	s.RemoteSubnet = &v
	return s
}

func (s *CreateVpnConnectionRequest) SetResourceOwnerAccount(v string) *CreateVpnConnectionRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateVpnConnectionRequest) SetResourceOwnerId(v int64) *CreateVpnConnectionRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreateVpnConnectionRequest) SetTags(v []*CreateVpnConnectionRequestTags) *CreateVpnConnectionRequest {
	s.Tags = v
	return s
}

func (s *CreateVpnConnectionRequest) SetTunnelOptionsSpecification(v []*CreateVpnConnectionRequestTunnelOptionsSpecification) *CreateVpnConnectionRequest {
	s.TunnelOptionsSpecification = v
	return s
}

func (s *CreateVpnConnectionRequest) SetVpnGatewayId(v string) *CreateVpnConnectionRequest {
	s.VpnGatewayId = &v
	return s
}

type CreateVpnConnectionRequestTags struct {
	// The tag key. The tag key cannot be an empty string.
	//
	// It can be at most 64 characters in length, and cannot contain `http://` or `https://`. It cannot start with `aliyun` or `acs:`.
	//
	// You can specify at most 20 tag keys in each call.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value.
	//
	// The tag value can be an empty string and cannot exceed 128 characters in length. It cannot start with `aliyun` or `acs:`, and cannot contain `http://` or `https://`.
	//
	// Each tag key corresponds to one tag value. You can specify at most 20 tag values in each call.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateVpnConnectionRequestTags) String() string {
	return tea.Prettify(s)
}

func (s CreateVpnConnectionRequestTags) GoString() string {
	return s.String()
}

func (s *CreateVpnConnectionRequestTags) SetKey(v string) *CreateVpnConnectionRequestTags {
	s.Key = &v
	return s
}

func (s *CreateVpnConnectionRequestTags) SetValue(v string) *CreateVpnConnectionRequestTags {
	s.Value = &v
	return s
}

type CreateVpnConnectionRequestTunnelOptionsSpecification struct {
	// 隧道关联的用户网关ID。
	//
	// > - 在VPN网关实例支持创建双隧道模式的IPsec-VPN连接的场景下，本参数必填。
	// - 如果当前VPN网关实例支持创建双隧道模式的IPsec-VPN连接，您必须同时为IPsec-VPN连接添加主隧道和备隧道的配置（即配置**TunnelOptionsSpecification**数组下的参数）。一个IPsec-VPN连接仅支持添加主备两条隧道。
	CustomerGatewayId *string `json:"CustomerGatewayId,omitempty" xml:"CustomerGatewayId,omitempty"`
	// 是否为隧道开启DPD（对等体存活检测）功能。取值：
	//
	// - **true**（默认值）：开启DPD功能。IPsec发起端会发送DPD报文用来检测对端的设备是否存活，如果在设定时间内未收到正确回应则认为对端已经断线，IPsec将删除ISAKMP SA和相应的IPsec SA，安全隧道同样也会被删除。
	//
	// - **false**：不开启DPD功能，IPsec发起端不会发送DPD探测报文。
	EnableDpd *bool `json:"EnableDpd,omitempty" xml:"EnableDpd,omitempty"`
	// 是否为隧道开启NAT穿越功能。取值：
	//
	// - **true**（默认值）：开启NAT穿越功能。开启后，IKE协商过程会删除对UDP端口号的验证过程，同时实现对隧道中NAT网关设备的发现功能。
	//
	// - **false**：不开启NAT穿越功能。
	EnableNatTraversal *bool `json:"EnableNatTraversal,omitempty" xml:"EnableNatTraversal,omitempty"`
	// 如果当前VPN网关实例为国密型VPN网关，您需要为隧道配置对端的CA证书。
	//
	// - 对于国密型VPN网关，此项必填。
	//
	// - 对于普通型VPN网关，此项需要为空。
	RemoteCaCertificate *string `json:"RemoteCaCertificate,omitempty" xml:"RemoteCaCertificate,omitempty"`
	// 隧道的角色。取值：
	//
	// - **master**：表示当前隧道为主隧道。
	// - **slave**：表示当前隧道为备隧道。
	Role *string `json:"Role,omitempty" xml:"Role,omitempty"`
	// 为隧道添加BGP配置。
	TunnelBgpConfig *CreateVpnConnectionRequestTunnelOptionsSpecificationTunnelBgpConfig `json:"TunnelBgpConfig,omitempty" xml:"TunnelBgpConfig,omitempty" type:"Struct"`
	// 第一阶段协商的配置信息。
	TunnelIkeConfig *CreateVpnConnectionRequestTunnelOptionsSpecificationTunnelIkeConfig `json:"TunnelIkeConfig,omitempty" xml:"TunnelIkeConfig,omitempty" type:"Struct"`
	// 第二阶段协商的配置信息。
	TunnelIpsecConfig *CreateVpnConnectionRequestTunnelOptionsSpecificationTunnelIpsecConfig `json:"TunnelIpsecConfig,omitempty" xml:"TunnelIpsecConfig,omitempty" type:"Struct"`
}

func (s CreateVpnConnectionRequestTunnelOptionsSpecification) String() string {
	return tea.Prettify(s)
}

func (s CreateVpnConnectionRequestTunnelOptionsSpecification) GoString() string {
	return s.String()
}

func (s *CreateVpnConnectionRequestTunnelOptionsSpecification) SetCustomerGatewayId(v string) *CreateVpnConnectionRequestTunnelOptionsSpecification {
	s.CustomerGatewayId = &v
	return s
}

func (s *CreateVpnConnectionRequestTunnelOptionsSpecification) SetEnableDpd(v bool) *CreateVpnConnectionRequestTunnelOptionsSpecification {
	s.EnableDpd = &v
	return s
}

func (s *CreateVpnConnectionRequestTunnelOptionsSpecification) SetEnableNatTraversal(v bool) *CreateVpnConnectionRequestTunnelOptionsSpecification {
	s.EnableNatTraversal = &v
	return s
}

func (s *CreateVpnConnectionRequestTunnelOptionsSpecification) SetRemoteCaCertificate(v string) *CreateVpnConnectionRequestTunnelOptionsSpecification {
	s.RemoteCaCertificate = &v
	return s
}

func (s *CreateVpnConnectionRequestTunnelOptionsSpecification) SetRole(v string) *CreateVpnConnectionRequestTunnelOptionsSpecification {
	s.Role = &v
	return s
}

func (s *CreateVpnConnectionRequestTunnelOptionsSpecification) SetTunnelBgpConfig(v *CreateVpnConnectionRequestTunnelOptionsSpecificationTunnelBgpConfig) *CreateVpnConnectionRequestTunnelOptionsSpecification {
	s.TunnelBgpConfig = v
	return s
}

func (s *CreateVpnConnectionRequestTunnelOptionsSpecification) SetTunnelIkeConfig(v *CreateVpnConnectionRequestTunnelOptionsSpecificationTunnelIkeConfig) *CreateVpnConnectionRequestTunnelOptionsSpecification {
	s.TunnelIkeConfig = v
	return s
}

func (s *CreateVpnConnectionRequestTunnelOptionsSpecification) SetTunnelIpsecConfig(v *CreateVpnConnectionRequestTunnelOptionsSpecificationTunnelIpsecConfig) *CreateVpnConnectionRequestTunnelOptionsSpecification {
	s.TunnelIpsecConfig = v
	return s
}

type CreateVpnConnectionRequestTunnelOptionsSpecificationTunnelBgpConfig struct {
	// 隧道本端（阿里云侧）的自治系统号。自治系统号取值范围：**1**~**4294967295**。默认值：**45104**。
	//
	// > - 当您为IPsec连接开启BGP功能后（即指定**EnableTunnelsBgp**参数的值为**true**）需要配置该参数。
	// - 在添加BGP配置前，建议您先了解BGP动态路由功能的工作机制和使用限制。更多信息，请参见[VPN网关支持BGP动态路由公告](~~170235~~)。
	// - 建议您使用自治系统号的私有号码与阿里云建立BGP连接。自治系统号的私有号码范围请自行查阅文档。
	LocalAsn *int64 `json:"LocalAsn,omitempty" xml:"LocalAsn,omitempty"`
	// 隧道本端（阿里云侧）的BGP地址。该地址为BGP网段内的一个IP地址。
	LocalBgpIp *string `json:"LocalBgpIp,omitempty" xml:"LocalBgpIp,omitempty"`
	// 隧道的BGP网段。该网段需是一个在169.254.0.0/16内的掩码长度为30的网段。
	//
	// >在一个VPN网关实例下，每个隧道的BGP网段需保持唯一。
	TunnelCidr *string `json:"TunnelCidr,omitempty" xml:"TunnelCidr,omitempty"`
}

func (s CreateVpnConnectionRequestTunnelOptionsSpecificationTunnelBgpConfig) String() string {
	return tea.Prettify(s)
}

func (s CreateVpnConnectionRequestTunnelOptionsSpecificationTunnelBgpConfig) GoString() string {
	return s.String()
}

func (s *CreateVpnConnectionRequestTunnelOptionsSpecificationTunnelBgpConfig) SetLocalAsn(v int64) *CreateVpnConnectionRequestTunnelOptionsSpecificationTunnelBgpConfig {
	s.LocalAsn = &v
	return s
}

func (s *CreateVpnConnectionRequestTunnelOptionsSpecificationTunnelBgpConfig) SetLocalBgpIp(v string) *CreateVpnConnectionRequestTunnelOptionsSpecificationTunnelBgpConfig {
	s.LocalBgpIp = &v
	return s
}

func (s *CreateVpnConnectionRequestTunnelOptionsSpecificationTunnelBgpConfig) SetTunnelCidr(v string) *CreateVpnConnectionRequestTunnelOptionsSpecificationTunnelBgpConfig {
	s.TunnelCidr = &v
	return s
}

type CreateVpnConnectionRequestTunnelOptionsSpecificationTunnelIkeConfig struct {
	// 第一阶段协商的认证算法。
	//
	// <props="intl"><ph>取值：**md5**、**sha1**、**sha256**、**sha384**、**sha512**。默认值：**md5**。</ph></props>
	//
	// <props="china"><ph>如果VPN网关实例类型为普通型，则取值：**md5**、**sha1**、**sha256**、**sha384**、**sha512**。默认值：**md5**。</ph></props>
	//
	// <props="china"><ph>如果VPN网关实例类型为国密型，则取值为**sm3**（默认值）。</ph></props>
	IkeAuthAlg *string `json:"IkeAuthAlg,omitempty" xml:"IkeAuthAlg,omitempty"`
	// 第一阶段协商的加密算法。
	//
	// <props="intl"><ph>取值：**aes**、**aes192**、**aes256**、**des**或**3des**。默认值：**aes**。 </ph></props>
	//
	// <props="china"><ph>如果VPN网关实例类型为普通型，则取值为**aes**、**aes192**、**aes256**、**des**或**3des**。默认值：**aes**。</ph></props>
	//
	// <props="china"><ph>如果VPN网关实例类型为国密型，则取值为**sm4**（默认值）。</ph></props>
	IkeEncAlg *string `json:"IkeEncAlg,omitempty" xml:"IkeEncAlg,omitempty"`
	// 第一阶段协商出的SA的生存周期。单位：秒。
	//
	// 取值范围：**0**~**86400**。默认值：**86400**。
	IkeLifetime *int64 `json:"IkeLifetime,omitempty" xml:"IkeLifetime,omitempty"`
	// IKE版本的协商模式。取值：**main**或**aggressive**。默认值：**main**。
	//
	// - **main**：主模式，协商过程安全性高。
	// - **aggressive**：野蛮模式，协商快速且协商成功率高。
	//
	// <props="china"><ph>如果VPN网关实例类型为国密型，则协商模式仅支持**main**。</ph></props>
	IkeMode *string `json:"IkeMode,omitempty" xml:"IkeMode,omitempty"`
	// 第一阶段协商使用的Diffie-Hellman密钥交换算法。默认值：**group2**。
	// 取值：**group1**、**group2**、**group5**、**group14**。
	IkePfs *string `json:"IkePfs,omitempty" xml:"IkePfs,omitempty"`
	// IKE协议的版本。取值：**ikev1**或**ikev2**。默认值：**ikev1**。
	//
	// 相对于IKEv1版本，IKEv2版本简化了SA的协商过程并且对于多网段的场景提供了更好的支持。
	//
	// <props="china"><ph>如果VPN网关实例类型为国密型，则IKE版本仅支持**ikev1**。</ph></props>
	IkeVersion *string `json:"IkeVersion,omitempty" xml:"IkeVersion,omitempty"`
	// 隧道本端（阿里云侧）的标识，用于第一阶段的协商。长度限制为100个字符。默认值为隧道的IP地址。
	//
	// **LocalId**支持FQDN格式，如果您使用FQDN格式，协商模式建议选择为**aggressive**（野蛮模式）。
	LocalId *string `json:"LocalId,omitempty" xml:"LocalId,omitempty"`
	// 预共享密钥，用于隧道与隧道对端之间的身份认证。
	//
	//     - 密钥长度为1~100个字符，支持数字、大小写英文字母以及以下字符。```~!\`@#$%^&*()_-+={}[]|;:\",.<>/?```
	//     - 若您未指定预共享密钥，系统会随机生成一个16位的字符串作为预共享密钥。您可以调用[DescribeVpnConnection](~~120374~~)接口查询系统自动生成的预共享密钥。
	//
	//         > 隧道及隧道对端的预共享密钥需一致，否则系统无法正常建立隧道。
	Psk *string `json:"Psk,omitempty" xml:"Psk,omitempty"`
	// 隧道对端的标识，用于第一阶段的协商。长度限制为100个字符。默认值为隧道关联的用户网关的IP地址。
	//
	// **RemoteId**支持FQDN格式，如果您使用FQDN格式，协商模式建议选择为**aggressive**（野蛮模式）。
	RemoteId *string `json:"RemoteId,omitempty" xml:"RemoteId,omitempty"`
}

func (s CreateVpnConnectionRequestTunnelOptionsSpecificationTunnelIkeConfig) String() string {
	return tea.Prettify(s)
}

func (s CreateVpnConnectionRequestTunnelOptionsSpecificationTunnelIkeConfig) GoString() string {
	return s.String()
}

func (s *CreateVpnConnectionRequestTunnelOptionsSpecificationTunnelIkeConfig) SetIkeAuthAlg(v string) *CreateVpnConnectionRequestTunnelOptionsSpecificationTunnelIkeConfig {
	s.IkeAuthAlg = &v
	return s
}

func (s *CreateVpnConnectionRequestTunnelOptionsSpecificationTunnelIkeConfig) SetIkeEncAlg(v string) *CreateVpnConnectionRequestTunnelOptionsSpecificationTunnelIkeConfig {
	s.IkeEncAlg = &v
	return s
}

func (s *CreateVpnConnectionRequestTunnelOptionsSpecificationTunnelIkeConfig) SetIkeLifetime(v int64) *CreateVpnConnectionRequestTunnelOptionsSpecificationTunnelIkeConfig {
	s.IkeLifetime = &v
	return s
}

func (s *CreateVpnConnectionRequestTunnelOptionsSpecificationTunnelIkeConfig) SetIkeMode(v string) *CreateVpnConnectionRequestTunnelOptionsSpecificationTunnelIkeConfig {
	s.IkeMode = &v
	return s
}

func (s *CreateVpnConnectionRequestTunnelOptionsSpecificationTunnelIkeConfig) SetIkePfs(v string) *CreateVpnConnectionRequestTunnelOptionsSpecificationTunnelIkeConfig {
	s.IkePfs = &v
	return s
}

func (s *CreateVpnConnectionRequestTunnelOptionsSpecificationTunnelIkeConfig) SetIkeVersion(v string) *CreateVpnConnectionRequestTunnelOptionsSpecificationTunnelIkeConfig {
	s.IkeVersion = &v
	return s
}

func (s *CreateVpnConnectionRequestTunnelOptionsSpecificationTunnelIkeConfig) SetLocalId(v string) *CreateVpnConnectionRequestTunnelOptionsSpecificationTunnelIkeConfig {
	s.LocalId = &v
	return s
}

func (s *CreateVpnConnectionRequestTunnelOptionsSpecificationTunnelIkeConfig) SetPsk(v string) *CreateVpnConnectionRequestTunnelOptionsSpecificationTunnelIkeConfig {
	s.Psk = &v
	return s
}

func (s *CreateVpnConnectionRequestTunnelOptionsSpecificationTunnelIkeConfig) SetRemoteId(v string) *CreateVpnConnectionRequestTunnelOptionsSpecificationTunnelIkeConfig {
	s.RemoteId = &v
	return s
}

type CreateVpnConnectionRequestTunnelOptionsSpecificationTunnelIpsecConfig struct {
	// 第二阶段协商的认证算法。
	//
	// <props="intl"><ph>取值：**md5**、**sha1**、**sha256**、**sha384**、**sha512**。默认值：**md5**。</ph></props>
	//
	// <props="china"><ph>如果VPN网关实例类型为普通型，则取值：**md5**、**sha1**、**sha256**、**sha384**、**sha512**。默认值：**md5**。</ph></props>
	//
	// <props="china"><ph>如果VPN网关实例类型为国密型，则取值为**sm3**（默认值）。</ph></props>
	IpsecAuthAlg *string `json:"IpsecAuthAlg,omitempty" xml:"IpsecAuthAlg,omitempty"`
	// 第二阶段协商的加密算法。
	//
	// <props="intl"><ph>取值：**aes**、**aes192**、**aes256**、**des**或**3des**。默认值：**aes**。 </ph></props>
	//
	// <props="china"><ph>如果VPN网关实例类型为普通型，则取值为**aes**、**aes192**、**aes256**、**des**或**3des**。默认值：**aes**。</ph></props>
	//
	// <props="china"><ph>如果VPN网关实例类型为国密型，则取值为**sm4**（默认值）。</ph></props>
	IpsecEncAlg *string `json:"IpsecEncAlg,omitempty" xml:"IpsecEncAlg,omitempty"`
	// 第二阶段协商出的SA的生存周期。单位：秒。
	//
	// 取值范围：**0**~**86400**。默认值：**86400**。
	IpsecLifetime *int64 `json:"IpsecLifetime,omitempty" xml:"IpsecLifetime,omitempty"`
	// 第二阶段协商使用的Diffie-Hellman密钥交换算法。默认值：**group2**。
	//
	// 取值：**disabled**、**group1**、**group2**、**group5**、**group14**。
	IpsecPfs *string `json:"IpsecPfs,omitempty" xml:"IpsecPfs,omitempty"`
}

func (s CreateVpnConnectionRequestTunnelOptionsSpecificationTunnelIpsecConfig) String() string {
	return tea.Prettify(s)
}

func (s CreateVpnConnectionRequestTunnelOptionsSpecificationTunnelIpsecConfig) GoString() string {
	return s.String()
}

func (s *CreateVpnConnectionRequestTunnelOptionsSpecificationTunnelIpsecConfig) SetIpsecAuthAlg(v string) *CreateVpnConnectionRequestTunnelOptionsSpecificationTunnelIpsecConfig {
	s.IpsecAuthAlg = &v
	return s
}

func (s *CreateVpnConnectionRequestTunnelOptionsSpecificationTunnelIpsecConfig) SetIpsecEncAlg(v string) *CreateVpnConnectionRequestTunnelOptionsSpecificationTunnelIpsecConfig {
	s.IpsecEncAlg = &v
	return s
}

func (s *CreateVpnConnectionRequestTunnelOptionsSpecificationTunnelIpsecConfig) SetIpsecLifetime(v int64) *CreateVpnConnectionRequestTunnelOptionsSpecificationTunnelIpsecConfig {
	s.IpsecLifetime = &v
	return s
}

func (s *CreateVpnConnectionRequestTunnelOptionsSpecificationTunnelIpsecConfig) SetIpsecPfs(v string) *CreateVpnConnectionRequestTunnelOptionsSpecificationTunnelIpsecConfig {
	s.IpsecPfs = &v
	return s
}

type CreateVpnConnectionResponseBody struct {
	// The timestamp generated when the IPsec-VPN connection was established. Unit: milliseconds.
	//
	// This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The name of the IPsec-VPN connection.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the IPsec-VPN connection.
	VpnConnectionId *string `json:"VpnConnectionId,omitempty" xml:"VpnConnectionId,omitempty"`
}

func (s CreateVpnConnectionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateVpnConnectionResponseBody) GoString() string {
	return s.String()
}

func (s *CreateVpnConnectionResponseBody) SetCreateTime(v int64) *CreateVpnConnectionResponseBody {
	s.CreateTime = &v
	return s
}

func (s *CreateVpnConnectionResponseBody) SetName(v string) *CreateVpnConnectionResponseBody {
	s.Name = &v
	return s
}

func (s *CreateVpnConnectionResponseBody) SetRequestId(v string) *CreateVpnConnectionResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateVpnConnectionResponseBody) SetVpnConnectionId(v string) *CreateVpnConnectionResponseBody {
	s.VpnConnectionId = &v
	return s
}

type CreateVpnConnectionResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateVpnConnectionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateVpnConnectionResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateVpnConnectionResponse) GoString() string {
	return s.String()
}

func (s *CreateVpnConnectionResponse) SetHeaders(v map[string]*string) *CreateVpnConnectionResponse {
	s.Headers = v
	return s
}

func (s *CreateVpnConnectionResponse) SetStatusCode(v int32) *CreateVpnConnectionResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateVpnConnectionResponse) SetBody(v *CreateVpnConnectionResponseBody) *CreateVpnConnectionResponse {
	s.Body = v
	return s
}

type CreateVpnGatewayRequest struct {
	// Specifies whether to enable automatic payment for the VPN gateway. Valid values:
	//
	// *   **true**
	// *   **false** (default)
	AutoPay *bool `json:"AutoPay,omitempty" xml:"AutoPay,omitempty"`
	// The maximum bandwidth of the VPN gateway. Unit: Mbit/s.
	//
	// *   If you want to create a public VPN gateway, valid values are **10**, **100**, **200**, **500**, and **1000**.
	// *   If you want to create a private VPN gateway, valid values are **200** and **1000**.
	//
	// >  The maximum bandwidth supported by VPN gateways in some regions is 200 Mbit/s. For more information, see [VPN gateway limits](~~65290~~).
	Bandwidth *int32 `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters.
	//
	// > If you do not specify this parameter, the system automatically uses the **request ID** as the **client token**. The **request ID** may be different for each request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// 指定VPN网关实例关联的第二个交换机实例。
	//
	// - 如果当前地域支持创建双隧道模式的IPsec-VPN连接，则本参数必填。
	// - 您需要从VPN网关实例关联的VPC实例下指定两个分布在不同可用区的交换机实例，以实现IPsec-VPN连接可用区级别的容灾。
	// - 对于仅支持一个可用区的地域 ，不支持可用区级别的容灾，建议您在该可用区下指定两个不同的交换机实例以实现IPsec-VPN连接的高可用，支持指定相同的交换机实例。
	//
	// 关于支持双隧道模式IPsec-VPN连接的地域和可用区的信息，请参见[IPsec-VPN连接升级为双隧道模式](~~2358946~~)。
	DisasterRecoveryVSwitchId *string `json:"DisasterRecoveryVSwitchId,omitempty" xml:"DisasterRecoveryVSwitchId,omitempty"`
	// Specifies whether to enable the IPsec-VPN feature. Valid values:
	//
	// *   **true** (default)
	// *   **false**
	EnableIpsec *bool `json:"EnableIpsec,omitempty" xml:"EnableIpsec,omitempty"`
	// Specifies whether to enable the SSL-VPN feature for the VPN gateway. Valid values:
	//
	// *   **true**
	// *   **false** (default)
	EnableSsl *bool `json:"EnableSsl,omitempty" xml:"EnableSsl,omitempty"`
	// The billing method of the VPN gateway. Set the value to **POSTPAY**, which specifies the pay-as-you-go billing method.
	//
	// >  This parameter is required when you create a VPN gateway.
	InstanceChargeType *string `json:"InstanceChargeType,omitempty" xml:"InstanceChargeType,omitempty"`
	// The name of the VPN gateway. The default value is the ID of the VPN gateway.
	//
	// The name must be 1 to 100 characters in length and cannot start with `http://` or `https://`.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The network type of the VPN gateway. Valid values:
	//
	// *   **public** (default)
	// *   **private**
	NetworkType  *string `json:"NetworkType,omitempty" xml:"NetworkType,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The subscription duration. Unit: month. Valid values: **1** to **9**, **12**, **24**, and **36**.
	Period *int32 `json:"Period,omitempty" xml:"Period,omitempty"`
	// The region ID of the VPN gateway. You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The maximum number of clients that can be connected at the same time. Valid values: **5** (default), **10**, **20**, **50**, **100**, **200**, **500**, and **1000**.
	SslConnections *int32 `json:"SslConnections,omitempty" xml:"SslConnections,omitempty"`
	// The ID of the vSwitch to which the VPN gateway belongs.
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
	// The ID of the virtual private cloud (VPC) where you want to create the VPN gateway.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
	// The type of the VPN gateway.
	//
	// Set the value to **Normal** (default), which specifies a standard NAT gateway.
	VpnType *string `json:"VpnType,omitempty" xml:"VpnType,omitempty"`
}

func (s CreateVpnGatewayRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateVpnGatewayRequest) GoString() string {
	return s.String()
}

func (s *CreateVpnGatewayRequest) SetAutoPay(v bool) *CreateVpnGatewayRequest {
	s.AutoPay = &v
	return s
}

func (s *CreateVpnGatewayRequest) SetBandwidth(v int32) *CreateVpnGatewayRequest {
	s.Bandwidth = &v
	return s
}

func (s *CreateVpnGatewayRequest) SetClientToken(v string) *CreateVpnGatewayRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateVpnGatewayRequest) SetDisasterRecoveryVSwitchId(v string) *CreateVpnGatewayRequest {
	s.DisasterRecoveryVSwitchId = &v
	return s
}

func (s *CreateVpnGatewayRequest) SetEnableIpsec(v bool) *CreateVpnGatewayRequest {
	s.EnableIpsec = &v
	return s
}

func (s *CreateVpnGatewayRequest) SetEnableSsl(v bool) *CreateVpnGatewayRequest {
	s.EnableSsl = &v
	return s
}

func (s *CreateVpnGatewayRequest) SetInstanceChargeType(v string) *CreateVpnGatewayRequest {
	s.InstanceChargeType = &v
	return s
}

func (s *CreateVpnGatewayRequest) SetName(v string) *CreateVpnGatewayRequest {
	s.Name = &v
	return s
}

func (s *CreateVpnGatewayRequest) SetNetworkType(v string) *CreateVpnGatewayRequest {
	s.NetworkType = &v
	return s
}

func (s *CreateVpnGatewayRequest) SetOwnerAccount(v string) *CreateVpnGatewayRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateVpnGatewayRequest) SetOwnerId(v int64) *CreateVpnGatewayRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateVpnGatewayRequest) SetPeriod(v int32) *CreateVpnGatewayRequest {
	s.Period = &v
	return s
}

func (s *CreateVpnGatewayRequest) SetRegionId(v string) *CreateVpnGatewayRequest {
	s.RegionId = &v
	return s
}

func (s *CreateVpnGatewayRequest) SetResourceOwnerAccount(v string) *CreateVpnGatewayRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateVpnGatewayRequest) SetResourceOwnerId(v int64) *CreateVpnGatewayRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreateVpnGatewayRequest) SetSslConnections(v int32) *CreateVpnGatewayRequest {
	s.SslConnections = &v
	return s
}

func (s *CreateVpnGatewayRequest) SetVSwitchId(v string) *CreateVpnGatewayRequest {
	s.VSwitchId = &v
	return s
}

func (s *CreateVpnGatewayRequest) SetVpcId(v string) *CreateVpnGatewayRequest {
	s.VpcId = &v
	return s
}

func (s *CreateVpnGatewayRequest) SetVpnType(v string) *CreateVpnGatewayRequest {
	s.VpnType = &v
	return s
}

type CreateVpnGatewayResponseBody struct {
	// The name of the VPN gateway.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The order ID.
	//
	// If automatic payment is disabled, you must manually complete the payment for the VPN gateway in the [Alibaba Cloud Management console](https://usercenter2-intl.aliyun.com/billing/#/account/overview).
	OrderId *int64 `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the VPN gateway.
	VpnGatewayId *string `json:"VpnGatewayId,omitempty" xml:"VpnGatewayId,omitempty"`
}

func (s CreateVpnGatewayResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateVpnGatewayResponseBody) GoString() string {
	return s.String()
}

func (s *CreateVpnGatewayResponseBody) SetName(v string) *CreateVpnGatewayResponseBody {
	s.Name = &v
	return s
}

func (s *CreateVpnGatewayResponseBody) SetOrderId(v int64) *CreateVpnGatewayResponseBody {
	s.OrderId = &v
	return s
}

func (s *CreateVpnGatewayResponseBody) SetRequestId(v string) *CreateVpnGatewayResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateVpnGatewayResponseBody) SetVpnGatewayId(v string) *CreateVpnGatewayResponseBody {
	s.VpnGatewayId = &v
	return s
}

type CreateVpnGatewayResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateVpnGatewayResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateVpnGatewayResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateVpnGatewayResponse) GoString() string {
	return s.String()
}

func (s *CreateVpnGatewayResponse) SetHeaders(v map[string]*string) *CreateVpnGatewayResponse {
	s.Headers = v
	return s
}

func (s *CreateVpnGatewayResponse) SetStatusCode(v int32) *CreateVpnGatewayResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateVpnGatewayResponse) SetBody(v *CreateVpnGatewayResponseBody) *CreateVpnGatewayResponse {
	s.Body = v
	return s
}

type CreateVpnPbrRouteEntryRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that the value is unique among different requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The description of the policy-based route.
	//
	// The description must be 1 to 100 characters in length, and cannot start with http:// or https://.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The next hop of the policy-based route.
	NextHop *string `json:"NextHop,omitempty" xml:"NextHop,omitempty"`
	// The tunneling protocol. Set the value to **Ipsec**.
	OverlayMode  *string `json:"OverlayMode,omitempty" xml:"OverlayMode,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The priority of the policy-based route. Valid values: **1** to **100**. Default value: **10**.
	//
	// A smaller value indicates a higher priority.
	//
	// >  Only some VPN gateways in specific regions allow you to configure priorities for policy-based routes. For more information about the regions, see [Match rules of policy-based routes](~~110777~~).
	Priority *int32 `json:"Priority,omitempty" xml:"Priority,omitempty"`
	// Specifies whether to advertise the policy-based route to a virtual private cloud (VPC) route table. Valid values:
	//
	// *   **true**: yes
	// *   **false**: no
	PublishVpc *bool `json:"PublishVpc,omitempty" xml:"PublishVpc,omitempty"`
	// The ID of the region where the VPN gateway is created. You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The destination CIDR block of the policy-based route.
	RouteDest *string `json:"RouteDest,omitempty" xml:"RouteDest,omitempty"`
	// The source CIDR block of the policy-based route.
	RouteSource *string `json:"RouteSource,omitempty" xml:"RouteSource,omitempty"`
	// The ID of the VPN gateway.
	VpnGatewayId *string `json:"VpnGatewayId,omitempty" xml:"VpnGatewayId,omitempty"`
	// The weight of the policy-based route.
	//
	// If you use the same VPN gateway to establish active/standby IPsec-VPN connections, you can configure route weights to specify which connection is active. A value of 100 specifies the active connection while a value of 0 specifies the standby connection.
	//
	// You can configure health checks to automatically check the connection connectivity. If the active connection is down, the standby connection automatically takes over. For more information, see [CreateVpnConnection](~~120391~~).
	//
	// *   **100**: The IPsec-VPN connection associated with the policy-based route serves as an active connection.
	// *   **0**: The IPsec-VPN connection associated with the policy-based route serves as a standby connection.
	//
	// >  When you specify the active or standby connection, the primary route and secondary route must use the same source CIDR block and destination CIDR block.
	Weight *int32 `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s CreateVpnPbrRouteEntryRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateVpnPbrRouteEntryRequest) GoString() string {
	return s.String()
}

func (s *CreateVpnPbrRouteEntryRequest) SetClientToken(v string) *CreateVpnPbrRouteEntryRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateVpnPbrRouteEntryRequest) SetDescription(v string) *CreateVpnPbrRouteEntryRequest {
	s.Description = &v
	return s
}

func (s *CreateVpnPbrRouteEntryRequest) SetNextHop(v string) *CreateVpnPbrRouteEntryRequest {
	s.NextHop = &v
	return s
}

func (s *CreateVpnPbrRouteEntryRequest) SetOverlayMode(v string) *CreateVpnPbrRouteEntryRequest {
	s.OverlayMode = &v
	return s
}

func (s *CreateVpnPbrRouteEntryRequest) SetOwnerAccount(v string) *CreateVpnPbrRouteEntryRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateVpnPbrRouteEntryRequest) SetOwnerId(v int64) *CreateVpnPbrRouteEntryRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateVpnPbrRouteEntryRequest) SetPriority(v int32) *CreateVpnPbrRouteEntryRequest {
	s.Priority = &v
	return s
}

func (s *CreateVpnPbrRouteEntryRequest) SetPublishVpc(v bool) *CreateVpnPbrRouteEntryRequest {
	s.PublishVpc = &v
	return s
}

func (s *CreateVpnPbrRouteEntryRequest) SetRegionId(v string) *CreateVpnPbrRouteEntryRequest {
	s.RegionId = &v
	return s
}

func (s *CreateVpnPbrRouteEntryRequest) SetResourceOwnerAccount(v string) *CreateVpnPbrRouteEntryRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateVpnPbrRouteEntryRequest) SetResourceOwnerId(v int64) *CreateVpnPbrRouteEntryRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreateVpnPbrRouteEntryRequest) SetRouteDest(v string) *CreateVpnPbrRouteEntryRequest {
	s.RouteDest = &v
	return s
}

func (s *CreateVpnPbrRouteEntryRequest) SetRouteSource(v string) *CreateVpnPbrRouteEntryRequest {
	s.RouteSource = &v
	return s
}

func (s *CreateVpnPbrRouteEntryRequest) SetVpnGatewayId(v string) *CreateVpnPbrRouteEntryRequest {
	s.VpnGatewayId = &v
	return s
}

func (s *CreateVpnPbrRouteEntryRequest) SetWeight(v int32) *CreateVpnPbrRouteEntryRequest {
	s.Weight = &v
	return s
}

type CreateVpnPbrRouteEntryResponseBody struct {
	// The timestamp generated when the policy-based route was created. Unit: milliseconds.
	//
	// This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The description of the policy-based route.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The next hop of the policy-based route.
	NextHop *string `json:"NextHop,omitempty" xml:"NextHop,omitempty"`
	// The tunneling protocol. The value is set to **Ipsec**, which indicates the IPsec tunneling protocol.
	OverlayMode *string `json:"OverlayMode,omitempty" xml:"OverlayMode,omitempty"`
	// The priority of the policy-based route.
	Priority *int32 `json:"Priority,omitempty" xml:"Priority,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The destination CIDR block of the policy-based route.
	RouteDest *string `json:"RouteDest,omitempty" xml:"RouteDest,omitempty"`
	// The source CIDR block of the policy-based route.
	RouteSource *string `json:"RouteSource,omitempty" xml:"RouteSource,omitempty"`
	// The status of the policy-based route. Valid values:
	//
	// *   **published**: advertised to the VPC route table.
	// *   **normal**: not advertised to the VPC route table.
	State *string `json:"State,omitempty" xml:"State,omitempty"`
	// The ID of the VPN gateway.
	VpnInstanceId *string `json:"VpnInstanceId,omitempty" xml:"VpnInstanceId,omitempty"`
	// The weight of the policy-based route.
	//
	// *   **100**: The IPsec-VPN connection associated with the policy-based route serves as an active connection.
	// *   **0**: The IPsec-VPN connection associated with the policy-based route serves as a standby connection.
	Weight *int32 `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s CreateVpnPbrRouteEntryResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateVpnPbrRouteEntryResponseBody) GoString() string {
	return s.String()
}

func (s *CreateVpnPbrRouteEntryResponseBody) SetCreateTime(v int64) *CreateVpnPbrRouteEntryResponseBody {
	s.CreateTime = &v
	return s
}

func (s *CreateVpnPbrRouteEntryResponseBody) SetDescription(v string) *CreateVpnPbrRouteEntryResponseBody {
	s.Description = &v
	return s
}

func (s *CreateVpnPbrRouteEntryResponseBody) SetNextHop(v string) *CreateVpnPbrRouteEntryResponseBody {
	s.NextHop = &v
	return s
}

func (s *CreateVpnPbrRouteEntryResponseBody) SetOverlayMode(v string) *CreateVpnPbrRouteEntryResponseBody {
	s.OverlayMode = &v
	return s
}

func (s *CreateVpnPbrRouteEntryResponseBody) SetPriority(v int32) *CreateVpnPbrRouteEntryResponseBody {
	s.Priority = &v
	return s
}

func (s *CreateVpnPbrRouteEntryResponseBody) SetRequestId(v string) *CreateVpnPbrRouteEntryResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateVpnPbrRouteEntryResponseBody) SetRouteDest(v string) *CreateVpnPbrRouteEntryResponseBody {
	s.RouteDest = &v
	return s
}

func (s *CreateVpnPbrRouteEntryResponseBody) SetRouteSource(v string) *CreateVpnPbrRouteEntryResponseBody {
	s.RouteSource = &v
	return s
}

func (s *CreateVpnPbrRouteEntryResponseBody) SetState(v string) *CreateVpnPbrRouteEntryResponseBody {
	s.State = &v
	return s
}

func (s *CreateVpnPbrRouteEntryResponseBody) SetVpnInstanceId(v string) *CreateVpnPbrRouteEntryResponseBody {
	s.VpnInstanceId = &v
	return s
}

func (s *CreateVpnPbrRouteEntryResponseBody) SetWeight(v int32) *CreateVpnPbrRouteEntryResponseBody {
	s.Weight = &v
	return s
}

type CreateVpnPbrRouteEntryResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateVpnPbrRouteEntryResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateVpnPbrRouteEntryResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateVpnPbrRouteEntryResponse) GoString() string {
	return s.String()
}

func (s *CreateVpnPbrRouteEntryResponse) SetHeaders(v map[string]*string) *CreateVpnPbrRouteEntryResponse {
	s.Headers = v
	return s
}

func (s *CreateVpnPbrRouteEntryResponse) SetStatusCode(v int32) *CreateVpnPbrRouteEntryResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateVpnPbrRouteEntryResponse) SetBody(v *CreateVpnPbrRouteEntryResponseBody) *CreateVpnPbrRouteEntryResponse {
	s.Body = v
	return s
}

type CreateVpnRouteEntryRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that the value is unique among different requests. The client token can contain only ASCII characters.
	//
	// >  If you do not specify this parameter, the system automatically uses **RequestId** as **ClientToken**. The value of **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The description of the destination-based route.
	//
	// The description must be **1** to **100** characters in length, and cannot start with `http://` or `https://`.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The next hop of the destination-based route.
	NextHop *string `json:"NextHop,omitempty" xml:"NextHop,omitempty"`
	// The tunneling protocol. Set the value to **Ipsec**.
	OverlayMode  *string `json:"OverlayMode,omitempty" xml:"OverlayMode,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// Specifies whether to advertise the destination-based route to a virtual private cloud (VPC) route table. Valid values:
	//
	// *   **true**: yes
	// *   **false**: no
	PublishVpc *bool `json:"PublishVpc,omitempty" xml:"PublishVpc,omitempty"`
	// The ID of the region where the VPN gateway is created.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The destination CIDR block of the destination-based route.
	RouteDest *string `json:"RouteDest,omitempty" xml:"RouteDest,omitempty"`
	// The ID of the VPN gateway.
	VpnGatewayId *string `json:"VpnGatewayId,omitempty" xml:"VpnGatewayId,omitempty"`
	// The weight of the destination-based route. Valid values:
	//
	// *   **100**: a high priority
	// *   **0**: a low priority
	Weight *int32 `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s CreateVpnRouteEntryRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateVpnRouteEntryRequest) GoString() string {
	return s.String()
}

func (s *CreateVpnRouteEntryRequest) SetClientToken(v string) *CreateVpnRouteEntryRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateVpnRouteEntryRequest) SetDescription(v string) *CreateVpnRouteEntryRequest {
	s.Description = &v
	return s
}

func (s *CreateVpnRouteEntryRequest) SetNextHop(v string) *CreateVpnRouteEntryRequest {
	s.NextHop = &v
	return s
}

func (s *CreateVpnRouteEntryRequest) SetOverlayMode(v string) *CreateVpnRouteEntryRequest {
	s.OverlayMode = &v
	return s
}

func (s *CreateVpnRouteEntryRequest) SetOwnerAccount(v string) *CreateVpnRouteEntryRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateVpnRouteEntryRequest) SetOwnerId(v int64) *CreateVpnRouteEntryRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateVpnRouteEntryRequest) SetPublishVpc(v bool) *CreateVpnRouteEntryRequest {
	s.PublishVpc = &v
	return s
}

func (s *CreateVpnRouteEntryRequest) SetRegionId(v string) *CreateVpnRouteEntryRequest {
	s.RegionId = &v
	return s
}

func (s *CreateVpnRouteEntryRequest) SetResourceOwnerAccount(v string) *CreateVpnRouteEntryRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateVpnRouteEntryRequest) SetResourceOwnerId(v int64) *CreateVpnRouteEntryRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreateVpnRouteEntryRequest) SetRouteDest(v string) *CreateVpnRouteEntryRequest {
	s.RouteDest = &v
	return s
}

func (s *CreateVpnRouteEntryRequest) SetVpnGatewayId(v string) *CreateVpnRouteEntryRequest {
	s.VpnGatewayId = &v
	return s
}

func (s *CreateVpnRouteEntryRequest) SetWeight(v int32) *CreateVpnRouteEntryRequest {
	s.Weight = &v
	return s
}

type CreateVpnRouteEntryResponseBody struct {
	// The timestamp when the destination-based route was created. Unit: milliseconds.
	//
	// This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The description of the destination-based route.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The next hop of the destination-based route.
	NextHop *string `json:"NextHop,omitempty" xml:"NextHop,omitempty"`
	// The tunneling protocol. The value is set to **Ipsec**, which indicates the IPsec tunneling protocol.
	OverlayMode *string `json:"OverlayMode,omitempty" xml:"OverlayMode,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The destination CIDR block of the destination-based route.
	RouteDest *string `json:"RouteDest,omitempty" xml:"RouteDest,omitempty"`
	// The status of the destination-based route.
	//
	// *   **published**: advertised to the VPC route table.
	// *   **normal**: not advertised to the VPC route table.
	State *string `json:"State,omitempty" xml:"State,omitempty"`
	// The ID of the VPN gateway.
	VpnInstanceId *string `json:"VpnInstanceId,omitempty" xml:"VpnInstanceId,omitempty"`
	// The weight of the destination-based route. Valid values:
	//
	// *   **100**: a high priority
	// *   **0**: a low priority
	Weight *int32 `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s CreateVpnRouteEntryResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateVpnRouteEntryResponseBody) GoString() string {
	return s.String()
}

func (s *CreateVpnRouteEntryResponseBody) SetCreateTime(v int64) *CreateVpnRouteEntryResponseBody {
	s.CreateTime = &v
	return s
}

func (s *CreateVpnRouteEntryResponseBody) SetDescription(v string) *CreateVpnRouteEntryResponseBody {
	s.Description = &v
	return s
}

func (s *CreateVpnRouteEntryResponseBody) SetNextHop(v string) *CreateVpnRouteEntryResponseBody {
	s.NextHop = &v
	return s
}

func (s *CreateVpnRouteEntryResponseBody) SetOverlayMode(v string) *CreateVpnRouteEntryResponseBody {
	s.OverlayMode = &v
	return s
}

func (s *CreateVpnRouteEntryResponseBody) SetRequestId(v string) *CreateVpnRouteEntryResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateVpnRouteEntryResponseBody) SetRouteDest(v string) *CreateVpnRouteEntryResponseBody {
	s.RouteDest = &v
	return s
}

func (s *CreateVpnRouteEntryResponseBody) SetState(v string) *CreateVpnRouteEntryResponseBody {
	s.State = &v
	return s
}

func (s *CreateVpnRouteEntryResponseBody) SetVpnInstanceId(v string) *CreateVpnRouteEntryResponseBody {
	s.VpnInstanceId = &v
	return s
}

func (s *CreateVpnRouteEntryResponseBody) SetWeight(v int32) *CreateVpnRouteEntryResponseBody {
	s.Weight = &v
	return s
}

type CreateVpnRouteEntryResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateVpnRouteEntryResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateVpnRouteEntryResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateVpnRouteEntryResponse) GoString() string {
	return s.String()
}

func (s *CreateVpnRouteEntryResponse) SetHeaders(v map[string]*string) *CreateVpnRouteEntryResponse {
	s.Headers = v
	return s
}

func (s *CreateVpnRouteEntryResponse) SetStatusCode(v int32) *CreateVpnRouteEntryResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateVpnRouteEntryResponse) SetBody(v *CreateVpnRouteEntryResponseBody) *CreateVpnRouteEntryResponse {
	s.Body = v
	return s
}

type DeactivateRouterInterfaceRequest struct {
	OwnerId *int64 `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region where the router interface is deployed.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the router interface.
	RouterInterfaceId *string `json:"RouterInterfaceId,omitempty" xml:"RouterInterfaceId,omitempty"`
}

func (s DeactivateRouterInterfaceRequest) String() string {
	return tea.Prettify(s)
}

func (s DeactivateRouterInterfaceRequest) GoString() string {
	return s.String()
}

func (s *DeactivateRouterInterfaceRequest) SetOwnerId(v int64) *DeactivateRouterInterfaceRequest {
	s.OwnerId = &v
	return s
}

func (s *DeactivateRouterInterfaceRequest) SetRegionId(v string) *DeactivateRouterInterfaceRequest {
	s.RegionId = &v
	return s
}

func (s *DeactivateRouterInterfaceRequest) SetResourceOwnerAccount(v string) *DeactivateRouterInterfaceRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeactivateRouterInterfaceRequest) SetResourceOwnerId(v int64) *DeactivateRouterInterfaceRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DeactivateRouterInterfaceRequest) SetRouterInterfaceId(v string) *DeactivateRouterInterfaceRequest {
	s.RouterInterfaceId = &v
	return s
}

type DeactivateRouterInterfaceResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeactivateRouterInterfaceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeactivateRouterInterfaceResponseBody) GoString() string {
	return s.String()
}

func (s *DeactivateRouterInterfaceResponseBody) SetRequestId(v string) *DeactivateRouterInterfaceResponseBody {
	s.RequestId = &v
	return s
}

type DeactivateRouterInterfaceResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeactivateRouterInterfaceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeactivateRouterInterfaceResponse) String() string {
	return tea.Prettify(s)
}

func (s DeactivateRouterInterfaceResponse) GoString() string {
	return s.String()
}

func (s *DeactivateRouterInterfaceResponse) SetHeaders(v map[string]*string) *DeactivateRouterInterfaceResponse {
	s.Headers = v
	return s
}

func (s *DeactivateRouterInterfaceResponse) SetStatusCode(v int32) *DeactivateRouterInterfaceResponse {
	s.StatusCode = &v
	return s
}

func (s *DeactivateRouterInterfaceResponse) SetBody(v *DeactivateRouterInterfaceResponseBody) *DeactivateRouterInterfaceResponse {
	s.Body = v
	return s
}

type DeactiveFlowLogRequest struct {
	// The ID of the flow log.
	FlowLogId    *string `json:"FlowLogId,omitempty" xml:"FlowLogId,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region where you want to create the flow log. You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DeactiveFlowLogRequest) String() string {
	return tea.Prettify(s)
}

func (s DeactiveFlowLogRequest) GoString() string {
	return s.String()
}

func (s *DeactiveFlowLogRequest) SetFlowLogId(v string) *DeactiveFlowLogRequest {
	s.FlowLogId = &v
	return s
}

func (s *DeactiveFlowLogRequest) SetOwnerAccount(v string) *DeactiveFlowLogRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeactiveFlowLogRequest) SetOwnerId(v int64) *DeactiveFlowLogRequest {
	s.OwnerId = &v
	return s
}

func (s *DeactiveFlowLogRequest) SetRegionId(v string) *DeactiveFlowLogRequest {
	s.RegionId = &v
	return s
}

func (s *DeactiveFlowLogRequest) SetResourceOwnerAccount(v string) *DeactiveFlowLogRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeactiveFlowLogRequest) SetResourceOwnerId(v int64) *DeactiveFlowLogRequest {
	s.ResourceOwnerId = &v
	return s
}

type DeactiveFlowLogResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the operation is successful. Valid values:
	//
	// *   **true**: yes
	// *   **false**: no
	Success *string `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeactiveFlowLogResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeactiveFlowLogResponseBody) GoString() string {
	return s.String()
}

func (s *DeactiveFlowLogResponseBody) SetRequestId(v string) *DeactiveFlowLogResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeactiveFlowLogResponseBody) SetSuccess(v string) *DeactiveFlowLogResponseBody {
	s.Success = &v
	return s
}

type DeactiveFlowLogResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeactiveFlowLogResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeactiveFlowLogResponse) String() string {
	return tea.Prettify(s)
}

func (s DeactiveFlowLogResponse) GoString() string {
	return s.String()
}

func (s *DeactiveFlowLogResponse) SetHeaders(v map[string]*string) *DeactiveFlowLogResponse {
	s.Headers = v
	return s
}

func (s *DeactiveFlowLogResponse) SetStatusCode(v int32) *DeactiveFlowLogResponse {
	s.StatusCode = &v
	return s
}

func (s *DeactiveFlowLogResponse) SetBody(v *DeactiveFlowLogResponseBody) *DeactiveFlowLogResponse {
	s.Body = v
	return s
}

type DeleteBgpGroupRequest struct {
	// The ID of the BGP group.
	BgpGroupId *string `json:"BgpGroupId,omitempty" xml:"BgpGroupId,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can contain only ASCII characters.
	//
	// >  If you do not specify this parameter, the system uses **RequestId** as **ClientToken**. **RequestId** may be different for each API request.
	ClientToken  *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the BGP group.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DeleteBgpGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteBgpGroupRequest) GoString() string {
	return s.String()
}

func (s *DeleteBgpGroupRequest) SetBgpGroupId(v string) *DeleteBgpGroupRequest {
	s.BgpGroupId = &v
	return s
}

func (s *DeleteBgpGroupRequest) SetClientToken(v string) *DeleteBgpGroupRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteBgpGroupRequest) SetOwnerAccount(v string) *DeleteBgpGroupRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteBgpGroupRequest) SetOwnerId(v int64) *DeleteBgpGroupRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteBgpGroupRequest) SetRegionId(v string) *DeleteBgpGroupRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteBgpGroupRequest) SetResourceOwnerAccount(v string) *DeleteBgpGroupRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteBgpGroupRequest) SetResourceOwnerId(v int64) *DeleteBgpGroupRequest {
	s.ResourceOwnerId = &v
	return s
}

type DeleteBgpGroupResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteBgpGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteBgpGroupResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteBgpGroupResponseBody) SetRequestId(v string) *DeleteBgpGroupResponseBody {
	s.RequestId = &v
	return s
}

type DeleteBgpGroupResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteBgpGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteBgpGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteBgpGroupResponse) GoString() string {
	return s.String()
}

func (s *DeleteBgpGroupResponse) SetHeaders(v map[string]*string) *DeleteBgpGroupResponse {
	s.Headers = v
	return s
}

func (s *DeleteBgpGroupResponse) SetStatusCode(v int32) *DeleteBgpGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteBgpGroupResponse) SetBody(v *DeleteBgpGroupResponseBody) *DeleteBgpGroupResponse {
	s.Body = v
	return s
}

type DeleteBgpNetworkRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can contain only ASCII characters.
	//
	// >  If you do not specify this parameter, the system uses **RequestId** as **ClientToken**. **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The CIDR block of the virtual private cloud (VPC) or vSwitch that you want to connect to a data center.
	DstCidrBlock *string `json:"DstCidrBlock,omitempty" xml:"DstCidrBlock,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the BGP group.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the virtual border router (VBR).
	RouterId *string `json:"RouterId,omitempty" xml:"RouterId,omitempty"`
}

func (s DeleteBgpNetworkRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteBgpNetworkRequest) GoString() string {
	return s.String()
}

func (s *DeleteBgpNetworkRequest) SetClientToken(v string) *DeleteBgpNetworkRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteBgpNetworkRequest) SetDstCidrBlock(v string) *DeleteBgpNetworkRequest {
	s.DstCidrBlock = &v
	return s
}

func (s *DeleteBgpNetworkRequest) SetOwnerAccount(v string) *DeleteBgpNetworkRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteBgpNetworkRequest) SetOwnerId(v int64) *DeleteBgpNetworkRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteBgpNetworkRequest) SetRegionId(v string) *DeleteBgpNetworkRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteBgpNetworkRequest) SetResourceOwnerAccount(v string) *DeleteBgpNetworkRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteBgpNetworkRequest) SetResourceOwnerId(v int64) *DeleteBgpNetworkRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DeleteBgpNetworkRequest) SetRouterId(v string) *DeleteBgpNetworkRequest {
	s.RouterId = &v
	return s
}

type DeleteBgpNetworkResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteBgpNetworkResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteBgpNetworkResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteBgpNetworkResponseBody) SetRequestId(v string) *DeleteBgpNetworkResponseBody {
	s.RequestId = &v
	return s
}

type DeleteBgpNetworkResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteBgpNetworkResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteBgpNetworkResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteBgpNetworkResponse) GoString() string {
	return s.String()
}

func (s *DeleteBgpNetworkResponse) SetHeaders(v map[string]*string) *DeleteBgpNetworkResponse {
	s.Headers = v
	return s
}

func (s *DeleteBgpNetworkResponse) SetStatusCode(v int32) *DeleteBgpNetworkResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteBgpNetworkResponse) SetBody(v *DeleteBgpNetworkResponseBody) *DeleteBgpNetworkResponse {
	s.Body = v
	return s
}

type DeleteBgpPeerRequest struct {
	// The ID of the BGP peer.
	BgpPeerId *string `json:"BgpPeerId,omitempty" xml:"BgpPeerId,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among all requests. The token can contain only ASCII characters.
	//
	// >  If you do not specify this parameter, the system automatically uses **RequestId** as **ClientToken**. **RequestId** may be different for each API request.
	ClientToken  *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the BGP group.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DeleteBgpPeerRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteBgpPeerRequest) GoString() string {
	return s.String()
}

func (s *DeleteBgpPeerRequest) SetBgpPeerId(v string) *DeleteBgpPeerRequest {
	s.BgpPeerId = &v
	return s
}

func (s *DeleteBgpPeerRequest) SetClientToken(v string) *DeleteBgpPeerRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteBgpPeerRequest) SetOwnerAccount(v string) *DeleteBgpPeerRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteBgpPeerRequest) SetOwnerId(v int64) *DeleteBgpPeerRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteBgpPeerRequest) SetRegionId(v string) *DeleteBgpPeerRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteBgpPeerRequest) SetResourceOwnerAccount(v string) *DeleteBgpPeerRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteBgpPeerRequest) SetResourceOwnerId(v int64) *DeleteBgpPeerRequest {
	s.ResourceOwnerId = &v
	return s
}

type DeleteBgpPeerResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteBgpPeerResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteBgpPeerResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteBgpPeerResponseBody) SetRequestId(v string) *DeleteBgpPeerResponseBody {
	s.RequestId = &v
	return s
}

type DeleteBgpPeerResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteBgpPeerResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteBgpPeerResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteBgpPeerResponse) GoString() string {
	return s.String()
}

func (s *DeleteBgpPeerResponse) SetHeaders(v map[string]*string) *DeleteBgpPeerResponse {
	s.Headers = v
	return s
}

func (s *DeleteBgpPeerResponse) SetStatusCode(v int32) *DeleteBgpPeerResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteBgpPeerResponse) SetBody(v *DeleteBgpPeerResponseBody) *DeleteBgpPeerResponse {
	s.Body = v
	return s
}

type DeleteCommonBandwidthPackageRequest struct {
	// The ID of the EIP bandwidth plan.
	BandwidthPackageId *string `json:"BandwidthPackageId,omitempty" xml:"BandwidthPackageId,omitempty"`
	// Specifies whether to forcibly delete the EIP bandwidth plan. Valid values:
	//
	// *   **false** (default): deletes the EIP bandwidth plan only when no EIPs are associated with the EIP bandwidth plan.
	// *   **true**: disassociates all EIPs from the EIP bandwidth plan and deletes the EIP bandwidth plan.
	Force        *string `json:"Force,omitempty" xml:"Force,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region where the EIP bandwidth plan is created.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DeleteCommonBandwidthPackageRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteCommonBandwidthPackageRequest) GoString() string {
	return s.String()
}

func (s *DeleteCommonBandwidthPackageRequest) SetBandwidthPackageId(v string) *DeleteCommonBandwidthPackageRequest {
	s.BandwidthPackageId = &v
	return s
}

func (s *DeleteCommonBandwidthPackageRequest) SetForce(v string) *DeleteCommonBandwidthPackageRequest {
	s.Force = &v
	return s
}

func (s *DeleteCommonBandwidthPackageRequest) SetOwnerAccount(v string) *DeleteCommonBandwidthPackageRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteCommonBandwidthPackageRequest) SetOwnerId(v int64) *DeleteCommonBandwidthPackageRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteCommonBandwidthPackageRequest) SetRegionId(v string) *DeleteCommonBandwidthPackageRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteCommonBandwidthPackageRequest) SetResourceOwnerAccount(v string) *DeleteCommonBandwidthPackageRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteCommonBandwidthPackageRequest) SetResourceOwnerId(v int64) *DeleteCommonBandwidthPackageRequest {
	s.ResourceOwnerId = &v
	return s
}

type DeleteCommonBandwidthPackageResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteCommonBandwidthPackageResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteCommonBandwidthPackageResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteCommonBandwidthPackageResponseBody) SetRequestId(v string) *DeleteCommonBandwidthPackageResponseBody {
	s.RequestId = &v
	return s
}

type DeleteCommonBandwidthPackageResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteCommonBandwidthPackageResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteCommonBandwidthPackageResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteCommonBandwidthPackageResponse) GoString() string {
	return s.String()
}

func (s *DeleteCommonBandwidthPackageResponse) SetHeaders(v map[string]*string) *DeleteCommonBandwidthPackageResponse {
	s.Headers = v
	return s
}

func (s *DeleteCommonBandwidthPackageResponse) SetStatusCode(v int32) *DeleteCommonBandwidthPackageResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteCommonBandwidthPackageResponse) SetBody(v *DeleteCommonBandwidthPackageResponseBody) *DeleteCommonBandwidthPackageResponse {
	s.Body = v
	return s
}

type DeleteCustomerGatewayRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	//
	// >  If you do not set this parameter, the system automatically uses **RequestId** as **ClientToken**. **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the customer gateway.
	CustomerGatewayId *string `json:"CustomerGatewayId,omitempty" xml:"CustomerGatewayId,omitempty"`
	OwnerAccount      *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId           *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the customer gateway. You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DeleteCustomerGatewayRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteCustomerGatewayRequest) GoString() string {
	return s.String()
}

func (s *DeleteCustomerGatewayRequest) SetClientToken(v string) *DeleteCustomerGatewayRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteCustomerGatewayRequest) SetCustomerGatewayId(v string) *DeleteCustomerGatewayRequest {
	s.CustomerGatewayId = &v
	return s
}

func (s *DeleteCustomerGatewayRequest) SetOwnerAccount(v string) *DeleteCustomerGatewayRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteCustomerGatewayRequest) SetOwnerId(v int64) *DeleteCustomerGatewayRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteCustomerGatewayRequest) SetRegionId(v string) *DeleteCustomerGatewayRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteCustomerGatewayRequest) SetResourceOwnerAccount(v string) *DeleteCustomerGatewayRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteCustomerGatewayRequest) SetResourceOwnerId(v int64) *DeleteCustomerGatewayRequest {
	s.ResourceOwnerId = &v
	return s
}

type DeleteCustomerGatewayResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteCustomerGatewayResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteCustomerGatewayResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteCustomerGatewayResponseBody) SetRequestId(v string) *DeleteCustomerGatewayResponseBody {
	s.RequestId = &v
	return s
}

type DeleteCustomerGatewayResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteCustomerGatewayResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteCustomerGatewayResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteCustomerGatewayResponse) GoString() string {
	return s.String()
}

func (s *DeleteCustomerGatewayResponse) SetHeaders(v map[string]*string) *DeleteCustomerGatewayResponse {
	s.Headers = v
	return s
}

func (s *DeleteCustomerGatewayResponse) SetStatusCode(v int32) *DeleteCustomerGatewayResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteCustomerGatewayResponse) SetBody(v *DeleteCustomerGatewayResponseBody) *DeleteCustomerGatewayResponse {
	s.Body = v
	return s
}

type DeleteDhcpOptionsSetRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, the system uses **RequestId** as **ClientToken**. **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the DHCP options set to be deleted.
	DhcpOptionsSetId *string `json:"DhcpOptionsSetId,omitempty" xml:"DhcpOptionsSetId,omitempty"`
	// Specifies whether to check the request without performing the operation. Valid values:
	//
	// **true**: checks the request without performing the operation. The system checks the required parameters, request format, and limits. If the request fails the check, an error message is returned. If the request passes the check, the `DryRunOperation` error code is returned.
	//
	// **false** (default): sends the request. After the request passes the check, the operation is performed.
	DryRun       *bool   `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region of the DHCP options set to be deleted. You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DeleteDhcpOptionsSetRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteDhcpOptionsSetRequest) GoString() string {
	return s.String()
}

func (s *DeleteDhcpOptionsSetRequest) SetClientToken(v string) *DeleteDhcpOptionsSetRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteDhcpOptionsSetRequest) SetDhcpOptionsSetId(v string) *DeleteDhcpOptionsSetRequest {
	s.DhcpOptionsSetId = &v
	return s
}

func (s *DeleteDhcpOptionsSetRequest) SetDryRun(v bool) *DeleteDhcpOptionsSetRequest {
	s.DryRun = &v
	return s
}

func (s *DeleteDhcpOptionsSetRequest) SetOwnerAccount(v string) *DeleteDhcpOptionsSetRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteDhcpOptionsSetRequest) SetOwnerId(v int64) *DeleteDhcpOptionsSetRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteDhcpOptionsSetRequest) SetRegionId(v string) *DeleteDhcpOptionsSetRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteDhcpOptionsSetRequest) SetResourceOwnerAccount(v string) *DeleteDhcpOptionsSetRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteDhcpOptionsSetRequest) SetResourceOwnerId(v int64) *DeleteDhcpOptionsSetRequest {
	s.ResourceOwnerId = &v
	return s
}

type DeleteDhcpOptionsSetResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteDhcpOptionsSetResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteDhcpOptionsSetResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteDhcpOptionsSetResponseBody) SetRequestId(v string) *DeleteDhcpOptionsSetResponseBody {
	s.RequestId = &v
	return s
}

type DeleteDhcpOptionsSetResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteDhcpOptionsSetResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteDhcpOptionsSetResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteDhcpOptionsSetResponse) GoString() string {
	return s.String()
}

func (s *DeleteDhcpOptionsSetResponse) SetHeaders(v map[string]*string) *DeleteDhcpOptionsSetResponse {
	s.Headers = v
	return s
}

func (s *DeleteDhcpOptionsSetResponse) SetStatusCode(v int32) *DeleteDhcpOptionsSetResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteDhcpOptionsSetResponse) SetBody(v *DeleteDhcpOptionsSetResponseBody) *DeleteDhcpOptionsSetResponse {
	s.Body = v
	return s
}

type DeleteFlowLogRequest struct {
	// The ID of the flow log.
	FlowLogId    *string `json:"FlowLogId,omitempty" xml:"FlowLogId,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the flow log. You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DeleteFlowLogRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteFlowLogRequest) GoString() string {
	return s.String()
}

func (s *DeleteFlowLogRequest) SetFlowLogId(v string) *DeleteFlowLogRequest {
	s.FlowLogId = &v
	return s
}

func (s *DeleteFlowLogRequest) SetOwnerAccount(v string) *DeleteFlowLogRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteFlowLogRequest) SetOwnerId(v int64) *DeleteFlowLogRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteFlowLogRequest) SetRegionId(v string) *DeleteFlowLogRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteFlowLogRequest) SetResourceOwnerAccount(v string) *DeleteFlowLogRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteFlowLogRequest) SetResourceOwnerId(v int64) *DeleteFlowLogRequest {
	s.ResourceOwnerId = &v
	return s
}

type DeleteFlowLogResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the operation is successful. Valid values:
	//
	// *   **true**: yes
	// *   **false**: no
	Success *string `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteFlowLogResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteFlowLogResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteFlowLogResponseBody) SetRequestId(v string) *DeleteFlowLogResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteFlowLogResponseBody) SetSuccess(v string) *DeleteFlowLogResponseBody {
	s.Success = &v
	return s
}

type DeleteFlowLogResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteFlowLogResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteFlowLogResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteFlowLogResponse) GoString() string {
	return s.String()
}

func (s *DeleteFlowLogResponse) SetHeaders(v map[string]*string) *DeleteFlowLogResponse {
	s.Headers = v
	return s
}

func (s *DeleteFlowLogResponse) SetStatusCode(v int32) *DeleteFlowLogResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteFlowLogResponse) SetBody(v *DeleteFlowLogResponseBody) *DeleteFlowLogResponse {
	s.Body = v
	return s
}

type DeleteForwardEntryRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can contain only ASCII characters.
	//
	// >  If you do not specify this parameter, the system uses **RequestId** as **ClientToken**. **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the DNAT entry to be deleted.
	ForwardEntryId *string `json:"ForwardEntryId,omitempty" xml:"ForwardEntryId,omitempty"`
	// The ID of the DNAT table to which the DNAT entry belongs.
	ForwardTableId *string `json:"ForwardTableId,omitempty" xml:"ForwardTableId,omitempty"`
	OwnerAccount   *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId        *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the NAT gateway.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DeleteForwardEntryRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteForwardEntryRequest) GoString() string {
	return s.String()
}

func (s *DeleteForwardEntryRequest) SetClientToken(v string) *DeleteForwardEntryRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteForwardEntryRequest) SetForwardEntryId(v string) *DeleteForwardEntryRequest {
	s.ForwardEntryId = &v
	return s
}

func (s *DeleteForwardEntryRequest) SetForwardTableId(v string) *DeleteForwardEntryRequest {
	s.ForwardTableId = &v
	return s
}

func (s *DeleteForwardEntryRequest) SetOwnerAccount(v string) *DeleteForwardEntryRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteForwardEntryRequest) SetOwnerId(v int64) *DeleteForwardEntryRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteForwardEntryRequest) SetRegionId(v string) *DeleteForwardEntryRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteForwardEntryRequest) SetResourceOwnerAccount(v string) *DeleteForwardEntryRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteForwardEntryRequest) SetResourceOwnerId(v int64) *DeleteForwardEntryRequest {
	s.ResourceOwnerId = &v
	return s
}

type DeleteForwardEntryResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteForwardEntryResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteForwardEntryResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteForwardEntryResponseBody) SetRequestId(v string) *DeleteForwardEntryResponseBody {
	s.RequestId = &v
	return s
}

type DeleteForwardEntryResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteForwardEntryResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteForwardEntryResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteForwardEntryResponse) GoString() string {
	return s.String()
}

func (s *DeleteForwardEntryResponse) SetHeaders(v map[string]*string) *DeleteForwardEntryResponse {
	s.Headers = v
	return s
}

func (s *DeleteForwardEntryResponse) SetStatusCode(v int32) *DeleteForwardEntryResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteForwardEntryResponse) SetBody(v *DeleteForwardEntryResponseBody) *DeleteForwardEntryResponse {
	s.Body = v
	return s
}

type DeleteFullNatEntryRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among all requests. The token can only contain ASCII characters.
	//
	// >  If you do not specify this parameter, the system automatically uses **RequestId** as **ClientToken**. **RequestId** might be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to to perform a dry run. Valid values:
	//
	// *   **true**: performs a dry run. The system checks your AccessKey pair, the RAM user permissions, and the required parameters. If the request fails the dry run, an error message is returned. If the request passes the dry run, the DryRunOperation error code is returned.
	// *   **false** (default): performs a dry run and sends the request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The ID of the FULLNAT entry that you want to delete.
	FullNatEntryId *string `json:"FullNatEntryId,omitempty" xml:"FullNatEntryId,omitempty"`
	// The ID of the FULLNAT table to which the FULLNAT entry to be deleted belongs.
	FullNatTableId *string `json:"FullNatTableId,omitempty" xml:"FullNatTableId,omitempty"`
	OwnerAccount   *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId        *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the VPC NAT gateway to which the FULLNAT entry to be deleted belongs.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DeleteFullNatEntryRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteFullNatEntryRequest) GoString() string {
	return s.String()
}

func (s *DeleteFullNatEntryRequest) SetClientToken(v string) *DeleteFullNatEntryRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteFullNatEntryRequest) SetDryRun(v bool) *DeleteFullNatEntryRequest {
	s.DryRun = &v
	return s
}

func (s *DeleteFullNatEntryRequest) SetFullNatEntryId(v string) *DeleteFullNatEntryRequest {
	s.FullNatEntryId = &v
	return s
}

func (s *DeleteFullNatEntryRequest) SetFullNatTableId(v string) *DeleteFullNatEntryRequest {
	s.FullNatTableId = &v
	return s
}

func (s *DeleteFullNatEntryRequest) SetOwnerAccount(v string) *DeleteFullNatEntryRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteFullNatEntryRequest) SetOwnerId(v int64) *DeleteFullNatEntryRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteFullNatEntryRequest) SetRegionId(v string) *DeleteFullNatEntryRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteFullNatEntryRequest) SetResourceOwnerAccount(v string) *DeleteFullNatEntryRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteFullNatEntryRequest) SetResourceOwnerId(v int64) *DeleteFullNatEntryRequest {
	s.ResourceOwnerId = &v
	return s
}

type DeleteFullNatEntryResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteFullNatEntryResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteFullNatEntryResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteFullNatEntryResponseBody) SetRequestId(v string) *DeleteFullNatEntryResponseBody {
	s.RequestId = &v
	return s
}

type DeleteFullNatEntryResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteFullNatEntryResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteFullNatEntryResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteFullNatEntryResponse) GoString() string {
	return s.String()
}

func (s *DeleteFullNatEntryResponse) SetHeaders(v map[string]*string) *DeleteFullNatEntryResponse {
	s.Headers = v
	return s
}

func (s *DeleteFullNatEntryResponse) SetStatusCode(v int32) *DeleteFullNatEntryResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteFullNatEntryResponse) SetBody(v *DeleteFullNatEntryResponseBody) *DeleteFullNatEntryResponse {
	s.Body = v
	return s
}

type DeleteGlobalAccelerationInstanceRequest struct {
	// The ID of the GA instance.
	GlobalAccelerationInstanceId *string `json:"GlobalAccelerationInstanceId,omitempty" xml:"GlobalAccelerationInstanceId,omitempty"`
	OwnerAccount                 *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId                      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the GA instance.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DeleteGlobalAccelerationInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteGlobalAccelerationInstanceRequest) GoString() string {
	return s.String()
}

func (s *DeleteGlobalAccelerationInstanceRequest) SetGlobalAccelerationInstanceId(v string) *DeleteGlobalAccelerationInstanceRequest {
	s.GlobalAccelerationInstanceId = &v
	return s
}

func (s *DeleteGlobalAccelerationInstanceRequest) SetOwnerAccount(v string) *DeleteGlobalAccelerationInstanceRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteGlobalAccelerationInstanceRequest) SetOwnerId(v int64) *DeleteGlobalAccelerationInstanceRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteGlobalAccelerationInstanceRequest) SetRegionId(v string) *DeleteGlobalAccelerationInstanceRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteGlobalAccelerationInstanceRequest) SetResourceOwnerAccount(v string) *DeleteGlobalAccelerationInstanceRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteGlobalAccelerationInstanceRequest) SetResourceOwnerId(v int64) *DeleteGlobalAccelerationInstanceRequest {
	s.ResourceOwnerId = &v
	return s
}

type DeleteGlobalAccelerationInstanceResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteGlobalAccelerationInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteGlobalAccelerationInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteGlobalAccelerationInstanceResponseBody) SetRequestId(v string) *DeleteGlobalAccelerationInstanceResponseBody {
	s.RequestId = &v
	return s
}

type DeleteGlobalAccelerationInstanceResponse struct {
	Headers    map[string]*string                            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteGlobalAccelerationInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteGlobalAccelerationInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteGlobalAccelerationInstanceResponse) GoString() string {
	return s.String()
}

func (s *DeleteGlobalAccelerationInstanceResponse) SetHeaders(v map[string]*string) *DeleteGlobalAccelerationInstanceResponse {
	s.Headers = v
	return s
}

func (s *DeleteGlobalAccelerationInstanceResponse) SetStatusCode(v int32) *DeleteGlobalAccelerationInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteGlobalAccelerationInstanceResponse) SetBody(v *DeleteGlobalAccelerationInstanceResponseBody) *DeleteGlobalAccelerationInstanceResponse {
	s.Body = v
	return s
}

type DeleteHaVipRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, the system uses **RequestId** as **ClientToken**. The value of **RequestId** in each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the HAVIP that you want to delete.
	HaVipId      *string `json:"HaVipId,omitempty" xml:"HaVipId,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region where the HAVIP is deployed. You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DeleteHaVipRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteHaVipRequest) GoString() string {
	return s.String()
}

func (s *DeleteHaVipRequest) SetClientToken(v string) *DeleteHaVipRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteHaVipRequest) SetHaVipId(v string) *DeleteHaVipRequest {
	s.HaVipId = &v
	return s
}

func (s *DeleteHaVipRequest) SetOwnerAccount(v string) *DeleteHaVipRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteHaVipRequest) SetOwnerId(v int64) *DeleteHaVipRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteHaVipRequest) SetRegionId(v string) *DeleteHaVipRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteHaVipRequest) SetResourceOwnerAccount(v string) *DeleteHaVipRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteHaVipRequest) SetResourceOwnerId(v int64) *DeleteHaVipRequest {
	s.ResourceOwnerId = &v
	return s
}

type DeleteHaVipResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteHaVipResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteHaVipResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteHaVipResponseBody) SetRequestId(v string) *DeleteHaVipResponseBody {
	s.RequestId = &v
	return s
}

type DeleteHaVipResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteHaVipResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteHaVipResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteHaVipResponse) GoString() string {
	return s.String()
}

func (s *DeleteHaVipResponse) SetHeaders(v map[string]*string) *DeleteHaVipResponse {
	s.Headers = v
	return s
}

func (s *DeleteHaVipResponse) SetStatusCode(v int32) *DeleteHaVipResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteHaVipResponse) SetBody(v *DeleteHaVipResponseBody) *DeleteHaVipResponse {
	s.Body = v
	return s
}

type DeleteIPv6TranslatorRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the IPv6 Translation Service instance.
	Ipv6TranslatorId *string `json:"Ipv6TranslatorId,omitempty" xml:"Ipv6TranslatorId,omitempty"`
	OwnerAccount     *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId          *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the IPv6 Translation Service instance.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DeleteIPv6TranslatorRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteIPv6TranslatorRequest) GoString() string {
	return s.String()
}

func (s *DeleteIPv6TranslatorRequest) SetClientToken(v string) *DeleteIPv6TranslatorRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteIPv6TranslatorRequest) SetIpv6TranslatorId(v string) *DeleteIPv6TranslatorRequest {
	s.Ipv6TranslatorId = &v
	return s
}

func (s *DeleteIPv6TranslatorRequest) SetOwnerAccount(v string) *DeleteIPv6TranslatorRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteIPv6TranslatorRequest) SetOwnerId(v int64) *DeleteIPv6TranslatorRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteIPv6TranslatorRequest) SetRegionId(v string) *DeleteIPv6TranslatorRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteIPv6TranslatorRequest) SetResourceOwnerAccount(v string) *DeleteIPv6TranslatorRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteIPv6TranslatorRequest) SetResourceOwnerId(v int64) *DeleteIPv6TranslatorRequest {
	s.ResourceOwnerId = &v
	return s
}

type DeleteIPv6TranslatorResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteIPv6TranslatorResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteIPv6TranslatorResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteIPv6TranslatorResponseBody) SetRequestId(v string) *DeleteIPv6TranslatorResponseBody {
	s.RequestId = &v
	return s
}

type DeleteIPv6TranslatorResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteIPv6TranslatorResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteIPv6TranslatorResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteIPv6TranslatorResponse) GoString() string {
	return s.String()
}

func (s *DeleteIPv6TranslatorResponse) SetHeaders(v map[string]*string) *DeleteIPv6TranslatorResponse {
	s.Headers = v
	return s
}

func (s *DeleteIPv6TranslatorResponse) SetStatusCode(v int32) *DeleteIPv6TranslatorResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteIPv6TranslatorResponse) SetBody(v *DeleteIPv6TranslatorResponseBody) *DeleteIPv6TranslatorResponse {
	s.Body = v
	return s
}

type DeleteIPv6TranslatorAclListRequest struct {
	// The ID of the ACL that you want to delete.
	AclId *string `json:"AclId,omitempty" xml:"AclId,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among all requests. The token can contain only ASCII characters.
	ClientToken  *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region of the IPv6 translation service instance.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DeleteIPv6TranslatorAclListRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteIPv6TranslatorAclListRequest) GoString() string {
	return s.String()
}

func (s *DeleteIPv6TranslatorAclListRequest) SetAclId(v string) *DeleteIPv6TranslatorAclListRequest {
	s.AclId = &v
	return s
}

func (s *DeleteIPv6TranslatorAclListRequest) SetClientToken(v string) *DeleteIPv6TranslatorAclListRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteIPv6TranslatorAclListRequest) SetOwnerAccount(v string) *DeleteIPv6TranslatorAclListRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteIPv6TranslatorAclListRequest) SetOwnerId(v int64) *DeleteIPv6TranslatorAclListRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteIPv6TranslatorAclListRequest) SetRegionId(v string) *DeleteIPv6TranslatorAclListRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteIPv6TranslatorAclListRequest) SetResourceOwnerAccount(v string) *DeleteIPv6TranslatorAclListRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteIPv6TranslatorAclListRequest) SetResourceOwnerId(v int64) *DeleteIPv6TranslatorAclListRequest {
	s.ResourceOwnerId = &v
	return s
}

type DeleteIPv6TranslatorAclListResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteIPv6TranslatorAclListResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteIPv6TranslatorAclListResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteIPv6TranslatorAclListResponseBody) SetRequestId(v string) *DeleteIPv6TranslatorAclListResponseBody {
	s.RequestId = &v
	return s
}

type DeleteIPv6TranslatorAclListResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteIPv6TranslatorAclListResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteIPv6TranslatorAclListResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteIPv6TranslatorAclListResponse) GoString() string {
	return s.String()
}

func (s *DeleteIPv6TranslatorAclListResponse) SetHeaders(v map[string]*string) *DeleteIPv6TranslatorAclListResponse {
	s.Headers = v
	return s
}

func (s *DeleteIPv6TranslatorAclListResponse) SetStatusCode(v int32) *DeleteIPv6TranslatorAclListResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteIPv6TranslatorAclListResponse) SetBody(v *DeleteIPv6TranslatorAclListResponseBody) *DeleteIPv6TranslatorAclListResponse {
	s.Body = v
	return s
}

type DeleteIPv6TranslatorEntryRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the IPv6 mapping entry to be deleted.
	Ipv6TranslatorEntryId *string `json:"Ipv6TranslatorEntryId,omitempty" xml:"Ipv6TranslatorEntryId,omitempty"`
	// The ID of the IPv6 Translation Service instance.
	//
	// > If you do not specify **Ipv6TranslatorEntryId**, all mapping entries in the specified instance are deleted.
	Ipv6TranslatorId *string `json:"Ipv6TranslatorId,omitempty" xml:"Ipv6TranslatorId,omitempty"`
	OwnerAccount     *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId          *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region of the IPv6 Translation Service instance. You can call the **DescribeRegions** operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DeleteIPv6TranslatorEntryRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteIPv6TranslatorEntryRequest) GoString() string {
	return s.String()
}

func (s *DeleteIPv6TranslatorEntryRequest) SetClientToken(v string) *DeleteIPv6TranslatorEntryRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteIPv6TranslatorEntryRequest) SetIpv6TranslatorEntryId(v string) *DeleteIPv6TranslatorEntryRequest {
	s.Ipv6TranslatorEntryId = &v
	return s
}

func (s *DeleteIPv6TranslatorEntryRequest) SetIpv6TranslatorId(v string) *DeleteIPv6TranslatorEntryRequest {
	s.Ipv6TranslatorId = &v
	return s
}

func (s *DeleteIPv6TranslatorEntryRequest) SetOwnerAccount(v string) *DeleteIPv6TranslatorEntryRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteIPv6TranslatorEntryRequest) SetOwnerId(v int64) *DeleteIPv6TranslatorEntryRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteIPv6TranslatorEntryRequest) SetRegionId(v string) *DeleteIPv6TranslatorEntryRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteIPv6TranslatorEntryRequest) SetResourceOwnerAccount(v string) *DeleteIPv6TranslatorEntryRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteIPv6TranslatorEntryRequest) SetResourceOwnerId(v int64) *DeleteIPv6TranslatorEntryRequest {
	s.ResourceOwnerId = &v
	return s
}

type DeleteIPv6TranslatorEntryResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteIPv6TranslatorEntryResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteIPv6TranslatorEntryResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteIPv6TranslatorEntryResponseBody) SetRequestId(v string) *DeleteIPv6TranslatorEntryResponseBody {
	s.RequestId = &v
	return s
}

type DeleteIPv6TranslatorEntryResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteIPv6TranslatorEntryResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteIPv6TranslatorEntryResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteIPv6TranslatorEntryResponse) GoString() string {
	return s.String()
}

func (s *DeleteIPv6TranslatorEntryResponse) SetHeaders(v map[string]*string) *DeleteIPv6TranslatorEntryResponse {
	s.Headers = v
	return s
}

func (s *DeleteIPv6TranslatorEntryResponse) SetStatusCode(v int32) *DeleteIPv6TranslatorEntryResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteIPv6TranslatorEntryResponse) SetBody(v *DeleteIPv6TranslatorEntryResponseBody) *DeleteIPv6TranslatorEntryResponse {
	s.Body = v
	return s
}

type DeleteIpsecServerRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether only to precheck this request. Valid values:
	//
	// *   **true**: only prechecks the request. After the request passes the precheck, the system does not delete the IPsec server. The system checks the required parameters, the request format, and the service limits. If the request fails the precheck, an error code is returned. If the request passes the precheck, the `DryRunOperation` error code is returned.
	// *   **false** (default): prechecks the request. After the request passes the precheck, the system deletes the IPsec server.
	DryRun *string `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The ID of the IPsec server.
	IpsecServerId *string `json:"IpsecServerId,omitempty" xml:"IpsecServerId,omitempty"`
	// The ID of the region where the IPsec server is created.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DeleteIpsecServerRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteIpsecServerRequest) GoString() string {
	return s.String()
}

func (s *DeleteIpsecServerRequest) SetClientToken(v string) *DeleteIpsecServerRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteIpsecServerRequest) SetDryRun(v string) *DeleteIpsecServerRequest {
	s.DryRun = &v
	return s
}

func (s *DeleteIpsecServerRequest) SetIpsecServerId(v string) *DeleteIpsecServerRequest {
	s.IpsecServerId = &v
	return s
}

func (s *DeleteIpsecServerRequest) SetRegionId(v string) *DeleteIpsecServerRequest {
	s.RegionId = &v
	return s
}

type DeleteIpsecServerResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteIpsecServerResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteIpsecServerResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteIpsecServerResponseBody) SetRequestId(v string) *DeleteIpsecServerResponseBody {
	s.RequestId = &v
	return s
}

type DeleteIpsecServerResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteIpsecServerResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteIpsecServerResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteIpsecServerResponse) GoString() string {
	return s.String()
}

func (s *DeleteIpsecServerResponse) SetHeaders(v map[string]*string) *DeleteIpsecServerResponse {
	s.Headers = v
	return s
}

func (s *DeleteIpsecServerResponse) SetStatusCode(v int32) *DeleteIpsecServerResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteIpsecServerResponse) SetBody(v *DeleteIpsecServerResponseBody) *DeleteIpsecServerResponse {
	s.Body = v
	return s
}

type DeleteIpv4GatewayRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The client token can contain only ASCII characters.
	//
	// >  If you do not specify this parameter, the system uses **RequestId** as **ClientToken**. **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to only precheck the request. Valid values:
	//
	// *   **true**: prechecks the request without performing the operation. The system prechecks the required parameters, request syntax, and limits. If the request fails to pass the precheck, an error message is returned. If the request passes the precheck, the `DryRunOperation` error code is returned.
	// *   **false** (default): sends the API request. After the request passes the precheck, a 2xx HTTP status code is returned, and the operation is performed.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The ID of the IPv4 gateway that you want to delete.
	Ipv4GatewayId *string `json:"Ipv4GatewayId,omitempty" xml:"Ipv4GatewayId,omitempty"`
	OwnerAccount  *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the IPv4 gateway that you want to delete.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DeleteIpv4GatewayRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteIpv4GatewayRequest) GoString() string {
	return s.String()
}

func (s *DeleteIpv4GatewayRequest) SetClientToken(v string) *DeleteIpv4GatewayRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteIpv4GatewayRequest) SetDryRun(v bool) *DeleteIpv4GatewayRequest {
	s.DryRun = &v
	return s
}

func (s *DeleteIpv4GatewayRequest) SetIpv4GatewayId(v string) *DeleteIpv4GatewayRequest {
	s.Ipv4GatewayId = &v
	return s
}

func (s *DeleteIpv4GatewayRequest) SetOwnerAccount(v string) *DeleteIpv4GatewayRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteIpv4GatewayRequest) SetOwnerId(v int64) *DeleteIpv4GatewayRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteIpv4GatewayRequest) SetRegionId(v string) *DeleteIpv4GatewayRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteIpv4GatewayRequest) SetResourceOwnerAccount(v string) *DeleteIpv4GatewayRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteIpv4GatewayRequest) SetResourceOwnerId(v int64) *DeleteIpv4GatewayRequest {
	s.ResourceOwnerId = &v
	return s
}

type DeleteIpv4GatewayResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteIpv4GatewayResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteIpv4GatewayResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteIpv4GatewayResponseBody) SetRequestId(v string) *DeleteIpv4GatewayResponseBody {
	s.RequestId = &v
	return s
}

type DeleteIpv4GatewayResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteIpv4GatewayResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteIpv4GatewayResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteIpv4GatewayResponse) GoString() string {
	return s.String()
}

func (s *DeleteIpv4GatewayResponse) SetHeaders(v map[string]*string) *DeleteIpv4GatewayResponse {
	s.Headers = v
	return s
}

func (s *DeleteIpv4GatewayResponse) SetStatusCode(v int32) *DeleteIpv4GatewayResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteIpv4GatewayResponse) SetBody(v *DeleteIpv4GatewayResponseBody) *DeleteIpv4GatewayResponse {
	s.Body = v
	return s
}

type DeleteIpv6EgressOnlyRuleRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate a value, but you must make sure that the value is unique among all requests. The token can contain only ASCII characters.
	//
	// >  If you do not specify this parameter, the system uses **RequestId** as **ClientToken**. **RequestId** might be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the egress-only rule that you want to delete.
	Ipv6EgressOnlyRuleId *string `json:"Ipv6EgressOnlyRuleId,omitempty" xml:"Ipv6EgressOnlyRuleId,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the IPv6 gateway.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DeleteIpv6EgressOnlyRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteIpv6EgressOnlyRuleRequest) GoString() string {
	return s.String()
}

func (s *DeleteIpv6EgressOnlyRuleRequest) SetClientToken(v string) *DeleteIpv6EgressOnlyRuleRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteIpv6EgressOnlyRuleRequest) SetIpv6EgressOnlyRuleId(v string) *DeleteIpv6EgressOnlyRuleRequest {
	s.Ipv6EgressOnlyRuleId = &v
	return s
}

func (s *DeleteIpv6EgressOnlyRuleRequest) SetOwnerAccount(v string) *DeleteIpv6EgressOnlyRuleRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteIpv6EgressOnlyRuleRequest) SetOwnerId(v int64) *DeleteIpv6EgressOnlyRuleRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteIpv6EgressOnlyRuleRequest) SetRegionId(v string) *DeleteIpv6EgressOnlyRuleRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteIpv6EgressOnlyRuleRequest) SetResourceOwnerAccount(v string) *DeleteIpv6EgressOnlyRuleRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteIpv6EgressOnlyRuleRequest) SetResourceOwnerId(v int64) *DeleteIpv6EgressOnlyRuleRequest {
	s.ResourceOwnerId = &v
	return s
}

type DeleteIpv6EgressOnlyRuleResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteIpv6EgressOnlyRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteIpv6EgressOnlyRuleResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteIpv6EgressOnlyRuleResponseBody) SetRequestId(v string) *DeleteIpv6EgressOnlyRuleResponseBody {
	s.RequestId = &v
	return s
}

type DeleteIpv6EgressOnlyRuleResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteIpv6EgressOnlyRuleResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteIpv6EgressOnlyRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteIpv6EgressOnlyRuleResponse) GoString() string {
	return s.String()
}

func (s *DeleteIpv6EgressOnlyRuleResponse) SetHeaders(v map[string]*string) *DeleteIpv6EgressOnlyRuleResponse {
	s.Headers = v
	return s
}

func (s *DeleteIpv6EgressOnlyRuleResponse) SetStatusCode(v int32) *DeleteIpv6EgressOnlyRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteIpv6EgressOnlyRuleResponse) SetBody(v *DeleteIpv6EgressOnlyRuleResponseBody) *DeleteIpv6EgressOnlyRuleResponse {
	s.Body = v
	return s
}

type DeleteIpv6GatewayRequest struct {
	// The ID of the IPv6 gateway that you want to delete.
	Ipv6GatewayId *string `json:"Ipv6GatewayId,omitempty" xml:"Ipv6GatewayId,omitempty"`
	OwnerAccount  *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the IPv6 gateway. You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DeleteIpv6GatewayRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteIpv6GatewayRequest) GoString() string {
	return s.String()
}

func (s *DeleteIpv6GatewayRequest) SetIpv6GatewayId(v string) *DeleteIpv6GatewayRequest {
	s.Ipv6GatewayId = &v
	return s
}

func (s *DeleteIpv6GatewayRequest) SetOwnerAccount(v string) *DeleteIpv6GatewayRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteIpv6GatewayRequest) SetOwnerId(v int64) *DeleteIpv6GatewayRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteIpv6GatewayRequest) SetRegionId(v string) *DeleteIpv6GatewayRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteIpv6GatewayRequest) SetResourceOwnerAccount(v string) *DeleteIpv6GatewayRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteIpv6GatewayRequest) SetResourceOwnerId(v int64) *DeleteIpv6GatewayRequest {
	s.ResourceOwnerId = &v
	return s
}

type DeleteIpv6GatewayResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteIpv6GatewayResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteIpv6GatewayResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteIpv6GatewayResponseBody) SetRequestId(v string) *DeleteIpv6GatewayResponseBody {
	s.RequestId = &v
	return s
}

type DeleteIpv6GatewayResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteIpv6GatewayResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteIpv6GatewayResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteIpv6GatewayResponse) GoString() string {
	return s.String()
}

func (s *DeleteIpv6GatewayResponse) SetHeaders(v map[string]*string) *DeleteIpv6GatewayResponse {
	s.Headers = v
	return s
}

func (s *DeleteIpv6GatewayResponse) SetStatusCode(v int32) *DeleteIpv6GatewayResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteIpv6GatewayResponse) SetBody(v *DeleteIpv6GatewayResponseBody) *DeleteIpv6GatewayResponse {
	s.Body = v
	return s
}

type DeleteIpv6InternetBandwidthRequest struct {
	// The ID of the IPv6 address.
	//
	// >  You must set one of the **Ipv6AddressId** and **Ipv6InternetBandwidthId** parameters.
	Ipv6AddressId *string `json:"Ipv6AddressId,omitempty" xml:"Ipv6AddressId,omitempty"`
	// The ID of the Internet bandwidth that you purchase for the IPv6 gateway.
	//
	// >  You must set one of the **Ipv6AddressId** and **Ipv6InternetBandwidthId** parameters.
	Ipv6InternetBandwidthId *string `json:"Ipv6InternetBandwidthId,omitempty" xml:"Ipv6InternetBandwidthId,omitempty"`
	OwnerAccount            *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId                 *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region where the IPv6 gateway is deployed.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to obtain the region ID.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DeleteIpv6InternetBandwidthRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteIpv6InternetBandwidthRequest) GoString() string {
	return s.String()
}

func (s *DeleteIpv6InternetBandwidthRequest) SetIpv6AddressId(v string) *DeleteIpv6InternetBandwidthRequest {
	s.Ipv6AddressId = &v
	return s
}

func (s *DeleteIpv6InternetBandwidthRequest) SetIpv6InternetBandwidthId(v string) *DeleteIpv6InternetBandwidthRequest {
	s.Ipv6InternetBandwidthId = &v
	return s
}

func (s *DeleteIpv6InternetBandwidthRequest) SetOwnerAccount(v string) *DeleteIpv6InternetBandwidthRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteIpv6InternetBandwidthRequest) SetOwnerId(v int64) *DeleteIpv6InternetBandwidthRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteIpv6InternetBandwidthRequest) SetRegionId(v string) *DeleteIpv6InternetBandwidthRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteIpv6InternetBandwidthRequest) SetResourceOwnerAccount(v string) *DeleteIpv6InternetBandwidthRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteIpv6InternetBandwidthRequest) SetResourceOwnerId(v int64) *DeleteIpv6InternetBandwidthRequest {
	s.ResourceOwnerId = &v
	return s
}

type DeleteIpv6InternetBandwidthResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteIpv6InternetBandwidthResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteIpv6InternetBandwidthResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteIpv6InternetBandwidthResponseBody) SetRequestId(v string) *DeleteIpv6InternetBandwidthResponseBody {
	s.RequestId = &v
	return s
}

type DeleteIpv6InternetBandwidthResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteIpv6InternetBandwidthResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteIpv6InternetBandwidthResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteIpv6InternetBandwidthResponse) GoString() string {
	return s.String()
}

func (s *DeleteIpv6InternetBandwidthResponse) SetHeaders(v map[string]*string) *DeleteIpv6InternetBandwidthResponse {
	s.Headers = v
	return s
}

func (s *DeleteIpv6InternetBandwidthResponse) SetStatusCode(v int32) *DeleteIpv6InternetBandwidthResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteIpv6InternetBandwidthResponse) SetBody(v *DeleteIpv6InternetBandwidthResponseBody) *DeleteIpv6InternetBandwidthResponse {
	s.Body = v
	return s
}

type DeleteNatGatewayRequest struct {
	// Specifies whether to forcefully delete the NAT gateway. Valid values:
	//
	// *   **true**: yes If you set the value to **true**:
	//
	//     *   If the NAT gateway has SNAT entries, the system automatically deletes them.
	//     *   If the NAT gateway has DNAT entries, the system automatically deletes them.
	//     *   If the NAT gateway is associated with an elastic IP address (EIP), the system automatically disassociates the EIP from the NAT gateway.
	//     *   If the NAT gateway is associated with a NAT bandwidth plan, the system automatically disassociates the NAT bandwidth plan from the NAT gateway.
	//
	// *   **false**(default): no If you set the value to **false**:
	//
	//     *   If the NAT gateway is associated with a NAT bandwidth plan, disassociate the NAT gateway from the NAT bandwidth plan first.
	//     *   If the NAT gateway has SNAT entries, delete them first.
	//     *   If the NAT gateway has DNAT entries, delete them first.
	//     *   If the NAT gateway is associated with an EIP, disassociate the EIP from the NAT gateway first.
	Force *bool `json:"Force,omitempty" xml:"Force,omitempty"`
	// The ID of the NAT gateway that you want to delete.
	NatGatewayId *string `json:"NatGatewayId,omitempty" xml:"NatGatewayId,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region where the NAT gateway is deployed.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DeleteNatGatewayRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteNatGatewayRequest) GoString() string {
	return s.String()
}

func (s *DeleteNatGatewayRequest) SetForce(v bool) *DeleteNatGatewayRequest {
	s.Force = &v
	return s
}

func (s *DeleteNatGatewayRequest) SetNatGatewayId(v string) *DeleteNatGatewayRequest {
	s.NatGatewayId = &v
	return s
}

func (s *DeleteNatGatewayRequest) SetOwnerAccount(v string) *DeleteNatGatewayRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteNatGatewayRequest) SetOwnerId(v int64) *DeleteNatGatewayRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteNatGatewayRequest) SetRegionId(v string) *DeleteNatGatewayRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteNatGatewayRequest) SetResourceOwnerAccount(v string) *DeleteNatGatewayRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteNatGatewayRequest) SetResourceOwnerId(v int64) *DeleteNatGatewayRequest {
	s.ResourceOwnerId = &v
	return s
}

type DeleteNatGatewayResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteNatGatewayResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteNatGatewayResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteNatGatewayResponseBody) SetRequestId(v string) *DeleteNatGatewayResponseBody {
	s.RequestId = &v
	return s
}

type DeleteNatGatewayResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteNatGatewayResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteNatGatewayResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteNatGatewayResponse) GoString() string {
	return s.String()
}

func (s *DeleteNatGatewayResponse) SetHeaders(v map[string]*string) *DeleteNatGatewayResponse {
	s.Headers = v
	return s
}

func (s *DeleteNatGatewayResponse) SetStatusCode(v int32) *DeleteNatGatewayResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteNatGatewayResponse) SetBody(v *DeleteNatGatewayResponseBody) *DeleteNatGatewayResponse {
	s.Body = v
	return s
}

type DeleteNatIpRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. **RequestId** of each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to check the request without performing the operation. Valid values:
	//
	// *   **true**: checks the request without performing the operation. The system checks your AccessKey pair, the RAM user permissions, and the required parameters If the request fails to pass the check, the corresponding error message is returned. If the request passes the check, the `DryRunOperation` error code is returned.
	// *   **false**: sends the request. This is the default value. After the request passes the precheck, a 2XX HTTP status code is returned and the NAT IP address is deleted.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The ID of the NAT IP address that you want to delete.
	NatIpId      *string `json:"NatIpId,omitempty" xml:"NatIpId,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the NAT gateway to which the NAT IP address that you want to delete belongs.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DeleteNatIpRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteNatIpRequest) GoString() string {
	return s.String()
}

func (s *DeleteNatIpRequest) SetClientToken(v string) *DeleteNatIpRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteNatIpRequest) SetDryRun(v bool) *DeleteNatIpRequest {
	s.DryRun = &v
	return s
}

func (s *DeleteNatIpRequest) SetNatIpId(v string) *DeleteNatIpRequest {
	s.NatIpId = &v
	return s
}

func (s *DeleteNatIpRequest) SetOwnerAccount(v string) *DeleteNatIpRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteNatIpRequest) SetOwnerId(v int64) *DeleteNatIpRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteNatIpRequest) SetRegionId(v string) *DeleteNatIpRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteNatIpRequest) SetResourceOwnerAccount(v string) *DeleteNatIpRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteNatIpRequest) SetResourceOwnerId(v int64) *DeleteNatIpRequest {
	s.ResourceOwnerId = &v
	return s
}

type DeleteNatIpResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteNatIpResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteNatIpResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteNatIpResponseBody) SetRequestId(v string) *DeleteNatIpResponseBody {
	s.RequestId = &v
	return s
}

type DeleteNatIpResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteNatIpResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteNatIpResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteNatIpResponse) GoString() string {
	return s.String()
}

func (s *DeleteNatIpResponse) SetHeaders(v map[string]*string) *DeleteNatIpResponse {
	s.Headers = v
	return s
}

func (s *DeleteNatIpResponse) SetStatusCode(v int32) *DeleteNatIpResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteNatIpResponse) SetBody(v *DeleteNatIpResponseBody) *DeleteNatIpResponse {
	s.Body = v
	return s
}

type DeleteNatIpCidrRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether only to precheck this request. Valid values:
	//
	// *   **true**: sends the precheck request but does delete the NAT CIDR block. The system checks your AccessKey pair, the RAM user permissions, and the required parameters. If the request fails the precheck, an error code is returned. If the request passes the check, the `DryRunOperation` error code is returned.
	// *   **false**: sends the API request. This is the default value. If the request passes the precheck, a 2XX HTTP status code is returned and the NAT CIDR block is deleted.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The ID of the NAT gateway to which the NAT CIDR block to be deleted belongs.
	NatGatewayId *string `json:"NatGatewayId,omitempty" xml:"NatGatewayId,omitempty"`
	// The NAT CIDR block to be deleted.
	//
	// *   Before you delete a NAT CIDR block, you must delete all NAT IP addresses from the CIDR block.
	// *   The default NAT CIDR block cannot be deleted.
	NatIpCidr    *string `json:"NatIpCidr,omitempty" xml:"NatIpCidr,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the NAT gateway to which the NAT CIDR block to be deleted belongs.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DeleteNatIpCidrRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteNatIpCidrRequest) GoString() string {
	return s.String()
}

func (s *DeleteNatIpCidrRequest) SetClientToken(v string) *DeleteNatIpCidrRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteNatIpCidrRequest) SetDryRun(v bool) *DeleteNatIpCidrRequest {
	s.DryRun = &v
	return s
}

func (s *DeleteNatIpCidrRequest) SetNatGatewayId(v string) *DeleteNatIpCidrRequest {
	s.NatGatewayId = &v
	return s
}

func (s *DeleteNatIpCidrRequest) SetNatIpCidr(v string) *DeleteNatIpCidrRequest {
	s.NatIpCidr = &v
	return s
}

func (s *DeleteNatIpCidrRequest) SetOwnerAccount(v string) *DeleteNatIpCidrRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteNatIpCidrRequest) SetOwnerId(v int64) *DeleteNatIpCidrRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteNatIpCidrRequest) SetRegionId(v string) *DeleteNatIpCidrRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteNatIpCidrRequest) SetResourceOwnerAccount(v string) *DeleteNatIpCidrRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteNatIpCidrRequest) SetResourceOwnerId(v int64) *DeleteNatIpCidrRequest {
	s.ResourceOwnerId = &v
	return s
}

type DeleteNatIpCidrResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteNatIpCidrResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteNatIpCidrResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteNatIpCidrResponseBody) SetRequestId(v string) *DeleteNatIpCidrResponseBody {
	s.RequestId = &v
	return s
}

type DeleteNatIpCidrResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteNatIpCidrResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteNatIpCidrResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteNatIpCidrResponse) GoString() string {
	return s.String()
}

func (s *DeleteNatIpCidrResponse) SetHeaders(v map[string]*string) *DeleteNatIpCidrResponse {
	s.Headers = v
	return s
}

func (s *DeleteNatIpCidrResponse) SetStatusCode(v int32) *DeleteNatIpCidrResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteNatIpCidrResponse) SetBody(v *DeleteNatIpCidrResponseBody) *DeleteNatIpCidrResponse {
	s.Body = v
	return s
}

type DeleteNetworkAclRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, the system uses **RequestId** as **ClientToken**. **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the network ACL.
	NetworkAclId *string `json:"NetworkAclId,omitempty" xml:"NetworkAclId,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the network ACL.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DeleteNetworkAclRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteNetworkAclRequest) GoString() string {
	return s.String()
}

func (s *DeleteNetworkAclRequest) SetClientToken(v string) *DeleteNetworkAclRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteNetworkAclRequest) SetNetworkAclId(v string) *DeleteNetworkAclRequest {
	s.NetworkAclId = &v
	return s
}

func (s *DeleteNetworkAclRequest) SetOwnerId(v int64) *DeleteNetworkAclRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteNetworkAclRequest) SetRegionId(v string) *DeleteNetworkAclRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteNetworkAclRequest) SetResourceOwnerAccount(v string) *DeleteNetworkAclRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteNetworkAclRequest) SetResourceOwnerId(v int64) *DeleteNetworkAclRequest {
	s.ResourceOwnerId = &v
	return s
}

type DeleteNetworkAclResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteNetworkAclResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteNetworkAclResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteNetworkAclResponseBody) SetRequestId(v string) *DeleteNetworkAclResponseBody {
	s.RequestId = &v
	return s
}

type DeleteNetworkAclResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteNetworkAclResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteNetworkAclResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteNetworkAclResponse) GoString() string {
	return s.String()
}

func (s *DeleteNetworkAclResponse) SetHeaders(v map[string]*string) *DeleteNetworkAclResponse {
	s.Headers = v
	return s
}

func (s *DeleteNetworkAclResponse) SetStatusCode(v int32) *DeleteNetworkAclResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteNetworkAclResponse) SetBody(v *DeleteNetworkAclResponseBody) *DeleteNetworkAclResponse {
	s.Body = v
	return s
}

type DeletePhysicalConnectionRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken  *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the Express Connect circuit.
	PhysicalConnectionId *string `json:"PhysicalConnectionId,omitempty" xml:"PhysicalConnectionId,omitempty"`
	// The region ID of the Express Connect circuit.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DeletePhysicalConnectionRequest) String() string {
	return tea.Prettify(s)
}

func (s DeletePhysicalConnectionRequest) GoString() string {
	return s.String()
}

func (s *DeletePhysicalConnectionRequest) SetClientToken(v string) *DeletePhysicalConnectionRequest {
	s.ClientToken = &v
	return s
}

func (s *DeletePhysicalConnectionRequest) SetOwnerAccount(v string) *DeletePhysicalConnectionRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeletePhysicalConnectionRequest) SetOwnerId(v int64) *DeletePhysicalConnectionRequest {
	s.OwnerId = &v
	return s
}

func (s *DeletePhysicalConnectionRequest) SetPhysicalConnectionId(v string) *DeletePhysicalConnectionRequest {
	s.PhysicalConnectionId = &v
	return s
}

func (s *DeletePhysicalConnectionRequest) SetRegionId(v string) *DeletePhysicalConnectionRequest {
	s.RegionId = &v
	return s
}

func (s *DeletePhysicalConnectionRequest) SetResourceOwnerAccount(v string) *DeletePhysicalConnectionRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeletePhysicalConnectionRequest) SetResourceOwnerId(v int64) *DeletePhysicalConnectionRequest {
	s.ResourceOwnerId = &v
	return s
}

type DeletePhysicalConnectionResponseBody struct {
	// The ID of the request
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeletePhysicalConnectionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeletePhysicalConnectionResponseBody) GoString() string {
	return s.String()
}

func (s *DeletePhysicalConnectionResponseBody) SetRequestId(v string) *DeletePhysicalConnectionResponseBody {
	s.RequestId = &v
	return s
}

type DeletePhysicalConnectionResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeletePhysicalConnectionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeletePhysicalConnectionResponse) String() string {
	return tea.Prettify(s)
}

func (s DeletePhysicalConnectionResponse) GoString() string {
	return s.String()
}

func (s *DeletePhysicalConnectionResponse) SetHeaders(v map[string]*string) *DeletePhysicalConnectionResponse {
	s.Headers = v
	return s
}

func (s *DeletePhysicalConnectionResponse) SetStatusCode(v int32) *DeletePhysicalConnectionResponse {
	s.StatusCode = &v
	return s
}

func (s *DeletePhysicalConnectionResponse) SetBody(v *DeletePhysicalConnectionResponseBody) *DeletePhysicalConnectionResponse {
	s.Body = v
	return s
}

type DeletePublicIpAddressPoolRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The client token can contain only ASCII characters.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to perform a dry run. Valid values:
	//
	// *   **true**: performs a dry run. The system checks the required parameters, request syntax, and limits. If the request fails the dry run, an error message is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
	// *   **false** (default): performs a dry run and sends the request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed.
	DryRun       *bool   `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the IP address pool.
	PublicIpAddressPoolId *string `json:"PublicIpAddressPoolId,omitempty" xml:"PublicIpAddressPoolId,omitempty"`
	// The ID of the region where you want to create the IP address pool.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DeletePublicIpAddressPoolRequest) String() string {
	return tea.Prettify(s)
}

func (s DeletePublicIpAddressPoolRequest) GoString() string {
	return s.String()
}

func (s *DeletePublicIpAddressPoolRequest) SetClientToken(v string) *DeletePublicIpAddressPoolRequest {
	s.ClientToken = &v
	return s
}

func (s *DeletePublicIpAddressPoolRequest) SetDryRun(v bool) *DeletePublicIpAddressPoolRequest {
	s.DryRun = &v
	return s
}

func (s *DeletePublicIpAddressPoolRequest) SetOwnerAccount(v string) *DeletePublicIpAddressPoolRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeletePublicIpAddressPoolRequest) SetOwnerId(v int64) *DeletePublicIpAddressPoolRequest {
	s.OwnerId = &v
	return s
}

func (s *DeletePublicIpAddressPoolRequest) SetPublicIpAddressPoolId(v string) *DeletePublicIpAddressPoolRequest {
	s.PublicIpAddressPoolId = &v
	return s
}

func (s *DeletePublicIpAddressPoolRequest) SetRegionId(v string) *DeletePublicIpAddressPoolRequest {
	s.RegionId = &v
	return s
}

func (s *DeletePublicIpAddressPoolRequest) SetResourceOwnerAccount(v string) *DeletePublicIpAddressPoolRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeletePublicIpAddressPoolRequest) SetResourceOwnerId(v int64) *DeletePublicIpAddressPoolRequest {
	s.ResourceOwnerId = &v
	return s
}

type DeletePublicIpAddressPoolResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeletePublicIpAddressPoolResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeletePublicIpAddressPoolResponseBody) GoString() string {
	return s.String()
}

func (s *DeletePublicIpAddressPoolResponseBody) SetRequestId(v string) *DeletePublicIpAddressPoolResponseBody {
	s.RequestId = &v
	return s
}

type DeletePublicIpAddressPoolResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeletePublicIpAddressPoolResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeletePublicIpAddressPoolResponse) String() string {
	return tea.Prettify(s)
}

func (s DeletePublicIpAddressPoolResponse) GoString() string {
	return s.String()
}

func (s *DeletePublicIpAddressPoolResponse) SetHeaders(v map[string]*string) *DeletePublicIpAddressPoolResponse {
	s.Headers = v
	return s
}

func (s *DeletePublicIpAddressPoolResponse) SetStatusCode(v int32) *DeletePublicIpAddressPoolResponse {
	s.StatusCode = &v
	return s
}

func (s *DeletePublicIpAddressPoolResponse) SetBody(v *DeletePublicIpAddressPoolResponseBody) *DeletePublicIpAddressPoolResponse {
	s.Body = v
	return s
}

type DeletePublicIpAddressPoolCidrBlockRequest struct {
	// The CIDR block.
	CidrBlock *string `json:"CidrBlock,omitempty" xml:"CidrBlock,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The client token can contain only ASCII characters.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to perform a dry run. Valid values:
	//
	// *   **true**: performs a dry run. The system checks the required parameters, request syntax, and limits. If the request fails the dry run, an error message is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
	// *   **false** (default): performs a dry run and sends the request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed.
	DryRun       *bool   `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the IP address pool.
	PublicIpAddressPoolId *string `json:"PublicIpAddressPoolId,omitempty" xml:"PublicIpAddressPoolId,omitempty"`
	// The region ID of the IP address pool from which you want to delete a CIDR block.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DeletePublicIpAddressPoolCidrBlockRequest) String() string {
	return tea.Prettify(s)
}

func (s DeletePublicIpAddressPoolCidrBlockRequest) GoString() string {
	return s.String()
}

func (s *DeletePublicIpAddressPoolCidrBlockRequest) SetCidrBlock(v string) *DeletePublicIpAddressPoolCidrBlockRequest {
	s.CidrBlock = &v
	return s
}

func (s *DeletePublicIpAddressPoolCidrBlockRequest) SetClientToken(v string) *DeletePublicIpAddressPoolCidrBlockRequest {
	s.ClientToken = &v
	return s
}

func (s *DeletePublicIpAddressPoolCidrBlockRequest) SetDryRun(v bool) *DeletePublicIpAddressPoolCidrBlockRequest {
	s.DryRun = &v
	return s
}

func (s *DeletePublicIpAddressPoolCidrBlockRequest) SetOwnerAccount(v string) *DeletePublicIpAddressPoolCidrBlockRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeletePublicIpAddressPoolCidrBlockRequest) SetOwnerId(v int64) *DeletePublicIpAddressPoolCidrBlockRequest {
	s.OwnerId = &v
	return s
}

func (s *DeletePublicIpAddressPoolCidrBlockRequest) SetPublicIpAddressPoolId(v string) *DeletePublicIpAddressPoolCidrBlockRequest {
	s.PublicIpAddressPoolId = &v
	return s
}

func (s *DeletePublicIpAddressPoolCidrBlockRequest) SetRegionId(v string) *DeletePublicIpAddressPoolCidrBlockRequest {
	s.RegionId = &v
	return s
}

func (s *DeletePublicIpAddressPoolCidrBlockRequest) SetResourceOwnerAccount(v string) *DeletePublicIpAddressPoolCidrBlockRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeletePublicIpAddressPoolCidrBlockRequest) SetResourceOwnerId(v int64) *DeletePublicIpAddressPoolCidrBlockRequest {
	s.ResourceOwnerId = &v
	return s
}

type DeletePublicIpAddressPoolCidrBlockResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeletePublicIpAddressPoolCidrBlockResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeletePublicIpAddressPoolCidrBlockResponseBody) GoString() string {
	return s.String()
}

func (s *DeletePublicIpAddressPoolCidrBlockResponseBody) SetRequestId(v string) *DeletePublicIpAddressPoolCidrBlockResponseBody {
	s.RequestId = &v
	return s
}

type DeletePublicIpAddressPoolCidrBlockResponse struct {
	Headers    map[string]*string                              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeletePublicIpAddressPoolCidrBlockResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeletePublicIpAddressPoolCidrBlockResponse) String() string {
	return tea.Prettify(s)
}

func (s DeletePublicIpAddressPoolCidrBlockResponse) GoString() string {
	return s.String()
}

func (s *DeletePublicIpAddressPoolCidrBlockResponse) SetHeaders(v map[string]*string) *DeletePublicIpAddressPoolCidrBlockResponse {
	s.Headers = v
	return s
}

func (s *DeletePublicIpAddressPoolCidrBlockResponse) SetStatusCode(v int32) *DeletePublicIpAddressPoolCidrBlockResponse {
	s.StatusCode = &v
	return s
}

func (s *DeletePublicIpAddressPoolCidrBlockResponse) SetBody(v *DeletePublicIpAddressPoolCidrBlockResponseBody) *DeletePublicIpAddressPoolCidrBlockResponse {
	s.Body = v
	return s
}

type DeleteRouteEntriesRequest struct {
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the route table.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string                                  `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string                                  `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64                                   `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	RouteEntries         []*DeleteRouteEntriesRequestRouteEntries `json:"RouteEntries,omitempty" xml:"RouteEntries,omitempty" type:"Repeated"`
}

func (s DeleteRouteEntriesRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteRouteEntriesRequest) GoString() string {
	return s.String()
}

func (s *DeleteRouteEntriesRequest) SetOwnerAccount(v string) *DeleteRouteEntriesRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteRouteEntriesRequest) SetOwnerId(v int64) *DeleteRouteEntriesRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteRouteEntriesRequest) SetRegionId(v string) *DeleteRouteEntriesRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteRouteEntriesRequest) SetResourceOwnerAccount(v string) *DeleteRouteEntriesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteRouteEntriesRequest) SetResourceOwnerId(v int64) *DeleteRouteEntriesRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DeleteRouteEntriesRequest) SetRouteEntries(v []*DeleteRouteEntriesRequestRouteEntries) *DeleteRouteEntriesRequest {
	s.RouteEntries = v
	return s
}

type DeleteRouteEntriesRequestRouteEntries struct {
	// The destination CIDR block of the route entry that you want to delete. IPv4 and IPv6 CIDR blocks are supported. You can specify up to 50 destination CIDR blocks.
	//
	// >  If the **RouteEntryId** parameter is not specified, you must specify the **DstCidrBlock** and **NextHop** parameters.
	DstCidrBlock *string `json:"DstCidrBlock,omitempty" xml:"DstCidrBlock,omitempty"`
	// The ID of the next hop that you want to delete. You can specify up to 50 next hop IDs.
	//
	// >  If the **RouteEntryId** parameter is not specified, you must specify the **DstCidrBlock** and **NextHop** parameters.
	NextHop *string `json:"NextHop,omitempty" xml:"NextHop,omitempty"`
	// The ID of the route entry that you want to delete. You can specify up to 50 route entry IDs.
	//
	// >  If the **RouteEntryId** parameter is not specified, you must specify the **DstCidrBlock** and **NextHop** parameters.
	RouteEntryId *string `json:"RouteEntryId,omitempty" xml:"RouteEntryId,omitempty"`
	// The ID of the route table in which the route entry to be deleted resides. You can specify up to 50 route table IDs.
	RouteTableId *string `json:"RouteTableId,omitempty" xml:"RouteTableId,omitempty"`
}

func (s DeleteRouteEntriesRequestRouteEntries) String() string {
	return tea.Prettify(s)
}

func (s DeleteRouteEntriesRequestRouteEntries) GoString() string {
	return s.String()
}

func (s *DeleteRouteEntriesRequestRouteEntries) SetDstCidrBlock(v string) *DeleteRouteEntriesRequestRouteEntries {
	s.DstCidrBlock = &v
	return s
}

func (s *DeleteRouteEntriesRequestRouteEntries) SetNextHop(v string) *DeleteRouteEntriesRequestRouteEntries {
	s.NextHop = &v
	return s
}

func (s *DeleteRouteEntriesRequestRouteEntries) SetRouteEntryId(v string) *DeleteRouteEntriesRequestRouteEntries {
	s.RouteEntryId = &v
	return s
}

func (s *DeleteRouteEntriesRequestRouteEntries) SetRouteTableId(v string) *DeleteRouteEntriesRequestRouteEntries {
	s.RouteTableId = &v
	return s
}

type DeleteRouteEntriesResponseBody struct {
	// The number of route entries that failed to be deleted.
	FailedCount *int32 `json:"FailedCount,omitempty" xml:"FailedCount,omitempty"`
	// The information about the route entry that failed to be deleted.
	FailedRouteEntries []*DeleteRouteEntriesResponseBodyFailedRouteEntries `json:"FailedRouteEntries,omitempty" xml:"FailedRouteEntries,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The number of route entries that were deleted.
	SuccessCount *int32 `json:"SuccessCount,omitempty" xml:"SuccessCount,omitempty"`
}

func (s DeleteRouteEntriesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteRouteEntriesResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteRouteEntriesResponseBody) SetFailedCount(v int32) *DeleteRouteEntriesResponseBody {
	s.FailedCount = &v
	return s
}

func (s *DeleteRouteEntriesResponseBody) SetFailedRouteEntries(v []*DeleteRouteEntriesResponseBodyFailedRouteEntries) *DeleteRouteEntriesResponseBody {
	s.FailedRouteEntries = v
	return s
}

func (s *DeleteRouteEntriesResponseBody) SetRequestId(v string) *DeleteRouteEntriesResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteRouteEntriesResponseBody) SetSuccessCount(v int32) *DeleteRouteEntriesResponseBody {
	s.SuccessCount = &v
	return s
}

type DeleteRouteEntriesResponseBodyFailedRouteEntries struct {
	// The destination CIDR block of the route entry that failed to be deleted. IPv4 and IPv6 CIDR blocks are supported.
	DstCidrBlock *string `json:"DstCidrBlock,omitempty" xml:"DstCidrBlock,omitempty"`
	// The error code.
	FailedCode *string `json:"FailedCode,omitempty" xml:"FailedCode,omitempty"`
	// The error message.
	FailedMessage *string `json:"FailedMessage,omitempty" xml:"FailedMessage,omitempty"`
	// The ID of the next hop that failed to be deleted.
	NextHop *string `json:"NextHop,omitempty" xml:"NextHop,omitempty"`
	// The ID of the route entry that failed to be deleted.
	RouteEntryId *string `json:"RouteEntryId,omitempty" xml:"RouteEntryId,omitempty"`
}

func (s DeleteRouteEntriesResponseBodyFailedRouteEntries) String() string {
	return tea.Prettify(s)
}

func (s DeleteRouteEntriesResponseBodyFailedRouteEntries) GoString() string {
	return s.String()
}

func (s *DeleteRouteEntriesResponseBodyFailedRouteEntries) SetDstCidrBlock(v string) *DeleteRouteEntriesResponseBodyFailedRouteEntries {
	s.DstCidrBlock = &v
	return s
}

func (s *DeleteRouteEntriesResponseBodyFailedRouteEntries) SetFailedCode(v string) *DeleteRouteEntriesResponseBodyFailedRouteEntries {
	s.FailedCode = &v
	return s
}

func (s *DeleteRouteEntriesResponseBodyFailedRouteEntries) SetFailedMessage(v string) *DeleteRouteEntriesResponseBodyFailedRouteEntries {
	s.FailedMessage = &v
	return s
}

func (s *DeleteRouteEntriesResponseBodyFailedRouteEntries) SetNextHop(v string) *DeleteRouteEntriesResponseBodyFailedRouteEntries {
	s.NextHop = &v
	return s
}

func (s *DeleteRouteEntriesResponseBodyFailedRouteEntries) SetRouteEntryId(v string) *DeleteRouteEntriesResponseBodyFailedRouteEntries {
	s.RouteEntryId = &v
	return s
}

type DeleteRouteEntriesResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteRouteEntriesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteRouteEntriesResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteRouteEntriesResponse) GoString() string {
	return s.String()
}

func (s *DeleteRouteEntriesResponse) SetHeaders(v map[string]*string) *DeleteRouteEntriesResponse {
	s.Headers = v
	return s
}

func (s *DeleteRouteEntriesResponse) SetStatusCode(v int32) *DeleteRouteEntriesResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteRouteEntriesResponse) SetBody(v *DeleteRouteEntriesResponseBody) *DeleteRouteEntriesResponse {
	s.Body = v
	return s
}

type DeleteRouteEntryRequest struct {
	// The destination CIDR block of the route entry. IPv4 and IPv6 CIDR blocks are supported.
	DestinationCidrBlock *string `json:"DestinationCidrBlock,omitempty" xml:"DestinationCidrBlock,omitempty"`
	// The ID of the next hop.
	//
	// *   To delete a route other than an equal-cost multi-path (ECMP) route, set the **NextHopId** parameter and ignore the **NextHopList** parameter.
	// *   To delete an ECMP route, set the **NextHopList** parameter and ignore the **NextHopId** parameter.
	NextHopId    *string                               `json:"NextHopId,omitempty" xml:"NextHopId,omitempty"`
	NextHopList  []*DeleteRouteEntryRequestNextHopList `json:"NextHopList,omitempty" xml:"NextHopList,omitempty" type:"Repeated"`
	OwnerAccount *string                               `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64                                `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the route table.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the route that you want to delete.
	RouteEntryId *string `json:"RouteEntryId,omitempty" xml:"RouteEntryId,omitempty"`
	// The ID of the route table to which the route belongs.
	RouteTableId *string `json:"RouteTableId,omitempty" xml:"RouteTableId,omitempty"`
}

func (s DeleteRouteEntryRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteRouteEntryRequest) GoString() string {
	return s.String()
}

func (s *DeleteRouteEntryRequest) SetDestinationCidrBlock(v string) *DeleteRouteEntryRequest {
	s.DestinationCidrBlock = &v
	return s
}

func (s *DeleteRouteEntryRequest) SetNextHopId(v string) *DeleteRouteEntryRequest {
	s.NextHopId = &v
	return s
}

func (s *DeleteRouteEntryRequest) SetNextHopList(v []*DeleteRouteEntryRequestNextHopList) *DeleteRouteEntryRequest {
	s.NextHopList = v
	return s
}

func (s *DeleteRouteEntryRequest) SetOwnerAccount(v string) *DeleteRouteEntryRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteRouteEntryRequest) SetOwnerId(v int64) *DeleteRouteEntryRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteRouteEntryRequest) SetRegionId(v string) *DeleteRouteEntryRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteRouteEntryRequest) SetResourceOwnerAccount(v string) *DeleteRouteEntryRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteRouteEntryRequest) SetResourceOwnerId(v int64) *DeleteRouteEntryRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DeleteRouteEntryRequest) SetRouteEntryId(v string) *DeleteRouteEntryRequest {
	s.RouteEntryId = &v
	return s
}

func (s *DeleteRouteEntryRequest) SetRouteTableId(v string) *DeleteRouteEntryRequest {
	s.RouteTableId = &v
	return s
}

type DeleteRouteEntryRequestNextHopList struct {
	// The ID of the next hop that is configured for ECMP routing. You can specify information about at most 16 next hops.
	NextHopId *string `json:"NextHopId,omitempty" xml:"NextHopId,omitempty"`
	// The type of the next hop that is configured for ECMP routing. Set the value to **RouterInterface**. You can specify information about at most 16 next hops.
	NextHopType *string `json:"NextHopType,omitempty" xml:"NextHopType,omitempty"`
}

func (s DeleteRouteEntryRequestNextHopList) String() string {
	return tea.Prettify(s)
}

func (s DeleteRouteEntryRequestNextHopList) GoString() string {
	return s.String()
}

func (s *DeleteRouteEntryRequestNextHopList) SetNextHopId(v string) *DeleteRouteEntryRequestNextHopList {
	s.NextHopId = &v
	return s
}

func (s *DeleteRouteEntryRequestNextHopList) SetNextHopType(v string) *DeleteRouteEntryRequestNextHopList {
	s.NextHopType = &v
	return s
}

type DeleteRouteEntryResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteRouteEntryResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteRouteEntryResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteRouteEntryResponseBody) SetRequestId(v string) *DeleteRouteEntryResponseBody {
	s.RequestId = &v
	return s
}

type DeleteRouteEntryResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteRouteEntryResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteRouteEntryResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteRouteEntryResponse) GoString() string {
	return s.String()
}

func (s *DeleteRouteEntryResponse) SetHeaders(v map[string]*string) *DeleteRouteEntryResponse {
	s.Headers = v
	return s
}

func (s *DeleteRouteEntryResponse) SetStatusCode(v int32) *DeleteRouteEntryResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteRouteEntryResponse) SetBody(v *DeleteRouteEntryResponseBody) *DeleteRouteEntryResponse {
	s.Body = v
	return s
}

type DeleteRouteTableRequest struct {
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the virtual private cloud (VPC) to which the custom route table belongs.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the custom route table.
	RouteTableId *string `json:"RouteTableId,omitempty" xml:"RouteTableId,omitempty"`
}

func (s DeleteRouteTableRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteRouteTableRequest) GoString() string {
	return s.String()
}

func (s *DeleteRouteTableRequest) SetOwnerAccount(v string) *DeleteRouteTableRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteRouteTableRequest) SetOwnerId(v int64) *DeleteRouteTableRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteRouteTableRequest) SetRegionId(v string) *DeleteRouteTableRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteRouteTableRequest) SetResourceOwnerAccount(v string) *DeleteRouteTableRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteRouteTableRequest) SetResourceOwnerId(v int64) *DeleteRouteTableRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DeleteRouteTableRequest) SetRouteTableId(v string) *DeleteRouteTableRequest {
	s.RouteTableId = &v
	return s
}

type DeleteRouteTableResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteRouteTableResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteRouteTableResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteRouteTableResponseBody) SetRequestId(v string) *DeleteRouteTableResponseBody {
	s.RequestId = &v
	return s
}

type DeleteRouteTableResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteRouteTableResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteRouteTableResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteRouteTableResponse) GoString() string {
	return s.String()
}

func (s *DeleteRouteTableResponse) SetHeaders(v map[string]*string) *DeleteRouteTableResponse {
	s.Headers = v
	return s
}

func (s *DeleteRouteTableResponse) SetStatusCode(v int32) *DeleteRouteTableResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteRouteTableResponse) SetBody(v *DeleteRouteTableResponseBody) *DeleteRouteTableResponse {
	s.Body = v
	return s
}

type DeleteRouterInterfaceRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, the system uses **RequestId** as **ClientToken**. The value of **RequestId** in each API request may be different.
	ClientToken  *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region where the router interface is deployed.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the router interface.
	RouterInterfaceId *string `json:"RouterInterfaceId,omitempty" xml:"RouterInterfaceId,omitempty"`
}

func (s DeleteRouterInterfaceRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteRouterInterfaceRequest) GoString() string {
	return s.String()
}

func (s *DeleteRouterInterfaceRequest) SetClientToken(v string) *DeleteRouterInterfaceRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteRouterInterfaceRequest) SetOwnerAccount(v string) *DeleteRouterInterfaceRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteRouterInterfaceRequest) SetOwnerId(v int64) *DeleteRouterInterfaceRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteRouterInterfaceRequest) SetRegionId(v string) *DeleteRouterInterfaceRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteRouterInterfaceRequest) SetResourceOwnerAccount(v string) *DeleteRouterInterfaceRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteRouterInterfaceRequest) SetResourceOwnerId(v int64) *DeleteRouterInterfaceRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DeleteRouterInterfaceRequest) SetRouterInterfaceId(v string) *DeleteRouterInterfaceRequest {
	s.RouterInterfaceId = &v
	return s
}

type DeleteRouterInterfaceResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteRouterInterfaceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteRouterInterfaceResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteRouterInterfaceResponseBody) SetRequestId(v string) *DeleteRouterInterfaceResponseBody {
	s.RequestId = &v
	return s
}

type DeleteRouterInterfaceResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteRouterInterfaceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteRouterInterfaceResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteRouterInterfaceResponse) GoString() string {
	return s.String()
}

func (s *DeleteRouterInterfaceResponse) SetHeaders(v map[string]*string) *DeleteRouterInterfaceResponse {
	s.Headers = v
	return s
}

func (s *DeleteRouterInterfaceResponse) SetStatusCode(v int32) *DeleteRouterInterfaceResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteRouterInterfaceResponse) SetBody(v *DeleteRouterInterfaceResponseBody) *DeleteRouterInterfaceResponse {
	s.Body = v
	return s
}

type DeleteSnatEntryRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, the system automatically uses **RequestId** as **ClientToken**. **RequestId** may be different for each API request.
	ClientToken  *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the NAT gateway.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the SNAT entry that you want to delete.
	SnatEntryId *string `json:"SnatEntryId,omitempty" xml:"SnatEntryId,omitempty"`
	// The ID of the SNAT table to which the SNAT entry belongs.
	SnatTableId *string `json:"SnatTableId,omitempty" xml:"SnatTableId,omitempty"`
}

func (s DeleteSnatEntryRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteSnatEntryRequest) GoString() string {
	return s.String()
}

func (s *DeleteSnatEntryRequest) SetClientToken(v string) *DeleteSnatEntryRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteSnatEntryRequest) SetOwnerAccount(v string) *DeleteSnatEntryRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteSnatEntryRequest) SetOwnerId(v int64) *DeleteSnatEntryRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteSnatEntryRequest) SetRegionId(v string) *DeleteSnatEntryRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteSnatEntryRequest) SetResourceOwnerAccount(v string) *DeleteSnatEntryRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteSnatEntryRequest) SetResourceOwnerId(v int64) *DeleteSnatEntryRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DeleteSnatEntryRequest) SetSnatEntryId(v string) *DeleteSnatEntryRequest {
	s.SnatEntryId = &v
	return s
}

func (s *DeleteSnatEntryRequest) SetSnatTableId(v string) *DeleteSnatEntryRequest {
	s.SnatTableId = &v
	return s
}

type DeleteSnatEntryResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteSnatEntryResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteSnatEntryResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteSnatEntryResponseBody) SetRequestId(v string) *DeleteSnatEntryResponseBody {
	s.RequestId = &v
	return s
}

type DeleteSnatEntryResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteSnatEntryResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteSnatEntryResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteSnatEntryResponse) GoString() string {
	return s.String()
}

func (s *DeleteSnatEntryResponse) SetHeaders(v map[string]*string) *DeleteSnatEntryResponse {
	s.Headers = v
	return s
}

func (s *DeleteSnatEntryResponse) SetStatusCode(v int32) *DeleteSnatEntryResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteSnatEntryResponse) SetBody(v *DeleteSnatEntryResponseBody) *DeleteSnatEntryResponse {
	s.Body = v
	return s
}

type DeleteSslVpnClientCertRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, the system automatically uses **RequestId** as **ClientToken**. **RequestId** of each API request may be different.
	ClientToken  *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region where the SSL client certificate is created.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the SSL client certificate.
	SslVpnClientCertId *string `json:"SslVpnClientCertId,omitempty" xml:"SslVpnClientCertId,omitempty"`
}

func (s DeleteSslVpnClientCertRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteSslVpnClientCertRequest) GoString() string {
	return s.String()
}

func (s *DeleteSslVpnClientCertRequest) SetClientToken(v string) *DeleteSslVpnClientCertRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteSslVpnClientCertRequest) SetOwnerAccount(v string) *DeleteSslVpnClientCertRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteSslVpnClientCertRequest) SetOwnerId(v int64) *DeleteSslVpnClientCertRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteSslVpnClientCertRequest) SetRegionId(v string) *DeleteSslVpnClientCertRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteSslVpnClientCertRequest) SetResourceOwnerAccount(v string) *DeleteSslVpnClientCertRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteSslVpnClientCertRequest) SetResourceOwnerId(v int64) *DeleteSslVpnClientCertRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DeleteSslVpnClientCertRequest) SetSslVpnClientCertId(v string) *DeleteSslVpnClientCertRequest {
	s.SslVpnClientCertId = &v
	return s
}

type DeleteSslVpnClientCertResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteSslVpnClientCertResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteSslVpnClientCertResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteSslVpnClientCertResponseBody) SetRequestId(v string) *DeleteSslVpnClientCertResponseBody {
	s.RequestId = &v
	return s
}

type DeleteSslVpnClientCertResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteSslVpnClientCertResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteSslVpnClientCertResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteSslVpnClientCertResponse) GoString() string {
	return s.String()
}

func (s *DeleteSslVpnClientCertResponse) SetHeaders(v map[string]*string) *DeleteSslVpnClientCertResponse {
	s.Headers = v
	return s
}

func (s *DeleteSslVpnClientCertResponse) SetStatusCode(v int32) *DeleteSslVpnClientCertResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteSslVpnClientCertResponse) SetBody(v *DeleteSslVpnClientCertResponseBody) *DeleteSslVpnClientCertResponse {
	s.Body = v
	return s
}

type DeleteSslVpnServerRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, the system automatically uses **RequestId** as **ClientToken**. **RequestId** of each API request may be different.
	ClientToken  *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region where the SSL servers are created.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the SSL server.
	SslVpnServerId *string `json:"SslVpnServerId,omitempty" xml:"SslVpnServerId,omitempty"`
}

func (s DeleteSslVpnServerRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteSslVpnServerRequest) GoString() string {
	return s.String()
}

func (s *DeleteSslVpnServerRequest) SetClientToken(v string) *DeleteSslVpnServerRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteSslVpnServerRequest) SetOwnerAccount(v string) *DeleteSslVpnServerRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteSslVpnServerRequest) SetOwnerId(v int64) *DeleteSslVpnServerRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteSslVpnServerRequest) SetRegionId(v string) *DeleteSslVpnServerRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteSslVpnServerRequest) SetResourceOwnerAccount(v string) *DeleteSslVpnServerRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteSslVpnServerRequest) SetResourceOwnerId(v int64) *DeleteSslVpnServerRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DeleteSslVpnServerRequest) SetSslVpnServerId(v string) *DeleteSslVpnServerRequest {
	s.SslVpnServerId = &v
	return s
}

type DeleteSslVpnServerResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteSslVpnServerResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteSslVpnServerResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteSslVpnServerResponseBody) SetRequestId(v string) *DeleteSslVpnServerResponseBody {
	s.RequestId = &v
	return s
}

type DeleteSslVpnServerResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteSslVpnServerResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteSslVpnServerResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteSslVpnServerResponse) GoString() string {
	return s.String()
}

func (s *DeleteSslVpnServerResponse) SetHeaders(v map[string]*string) *DeleteSslVpnServerResponse {
	s.Headers = v
	return s
}

func (s *DeleteSslVpnServerResponse) SetStatusCode(v int32) *DeleteSslVpnServerResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteSslVpnServerResponse) SetBody(v *DeleteSslVpnServerResponseBody) *DeleteSslVpnServerResponse {
	s.Body = v
	return s
}

type DeleteTrafficMirrorFilterRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, the system uses **RequestId** as **ClientToken**. **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to check the request without performing the operation. Valid values:
	//
	// *   **true**: checks the request without performing the operation. The system checks the required parameters, request format, and limits. If the request fails the check, an error message is returned. If the request passes the check, the `DryRunOperation` error code is returned.
	// *   **false** (default): sends the request. After the request passes the check, the operation is performed.
	DryRun       *bool   `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region to which the mirrored traffic belongs. You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list. For more information about regions that support traffic mirroring, see [Overview of traffic mirroring](~~207513~~).
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the filter.
	TrafficMirrorFilterId *string `json:"TrafficMirrorFilterId,omitempty" xml:"TrafficMirrorFilterId,omitempty"`
}

func (s DeleteTrafficMirrorFilterRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteTrafficMirrorFilterRequest) GoString() string {
	return s.String()
}

func (s *DeleteTrafficMirrorFilterRequest) SetClientToken(v string) *DeleteTrafficMirrorFilterRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteTrafficMirrorFilterRequest) SetDryRun(v bool) *DeleteTrafficMirrorFilterRequest {
	s.DryRun = &v
	return s
}

func (s *DeleteTrafficMirrorFilterRequest) SetOwnerAccount(v string) *DeleteTrafficMirrorFilterRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteTrafficMirrorFilterRequest) SetOwnerId(v int64) *DeleteTrafficMirrorFilterRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteTrafficMirrorFilterRequest) SetRegionId(v string) *DeleteTrafficMirrorFilterRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteTrafficMirrorFilterRequest) SetResourceOwnerAccount(v string) *DeleteTrafficMirrorFilterRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteTrafficMirrorFilterRequest) SetResourceOwnerId(v int64) *DeleteTrafficMirrorFilterRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DeleteTrafficMirrorFilterRequest) SetTrafficMirrorFilterId(v string) *DeleteTrafficMirrorFilterRequest {
	s.TrafficMirrorFilterId = &v
	return s
}

type DeleteTrafficMirrorFilterResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteTrafficMirrorFilterResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteTrafficMirrorFilterResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteTrafficMirrorFilterResponseBody) SetRequestId(v string) *DeleteTrafficMirrorFilterResponseBody {
	s.RequestId = &v
	return s
}

type DeleteTrafficMirrorFilterResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteTrafficMirrorFilterResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteTrafficMirrorFilterResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteTrafficMirrorFilterResponse) GoString() string {
	return s.String()
}

func (s *DeleteTrafficMirrorFilterResponse) SetHeaders(v map[string]*string) *DeleteTrafficMirrorFilterResponse {
	s.Headers = v
	return s
}

func (s *DeleteTrafficMirrorFilterResponse) SetStatusCode(v int32) *DeleteTrafficMirrorFilterResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteTrafficMirrorFilterResponse) SetBody(v *DeleteTrafficMirrorFilterResponseBody) *DeleteTrafficMirrorFilterResponse {
	s.Body = v
	return s
}

type DeleteTrafficMirrorFilterRulesRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, the system uses **RequestId** as **ClientToken**. **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to check the request without performing the operation. Valid values:
	//
	// *   **true**: checks the API request without performing the operation. The system checks the required parameters, request format, and limits. If the request fails the check, an error message is returned. If the request passes the check, the `DryRunOperation` error code is returned.
	// *   **false** (default): sends the request. After the request passes the check, the operation is performed.
	DryRun       *bool   `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region to which the mirrored traffic belongs. You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list. For more information about regions that support traffic mirroring, see [Overview of traffic mirroring](~~207513~~).
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the filter.
	TrafficMirrorFilterId      *string   `json:"TrafficMirrorFilterId,omitempty" xml:"TrafficMirrorFilterId,omitempty"`
	TrafficMirrorFilterRuleIds []*string `json:"TrafficMirrorFilterRuleIds,omitempty" xml:"TrafficMirrorFilterRuleIds,omitempty" type:"Repeated"`
}

func (s DeleteTrafficMirrorFilterRulesRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteTrafficMirrorFilterRulesRequest) GoString() string {
	return s.String()
}

func (s *DeleteTrafficMirrorFilterRulesRequest) SetClientToken(v string) *DeleteTrafficMirrorFilterRulesRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteTrafficMirrorFilterRulesRequest) SetDryRun(v bool) *DeleteTrafficMirrorFilterRulesRequest {
	s.DryRun = &v
	return s
}

func (s *DeleteTrafficMirrorFilterRulesRequest) SetOwnerAccount(v string) *DeleteTrafficMirrorFilterRulesRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteTrafficMirrorFilterRulesRequest) SetOwnerId(v int64) *DeleteTrafficMirrorFilterRulesRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteTrafficMirrorFilterRulesRequest) SetRegionId(v string) *DeleteTrafficMirrorFilterRulesRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteTrafficMirrorFilterRulesRequest) SetResourceOwnerAccount(v string) *DeleteTrafficMirrorFilterRulesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteTrafficMirrorFilterRulesRequest) SetResourceOwnerId(v int64) *DeleteTrafficMirrorFilterRulesRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DeleteTrafficMirrorFilterRulesRequest) SetTrafficMirrorFilterId(v string) *DeleteTrafficMirrorFilterRulesRequest {
	s.TrafficMirrorFilterId = &v
	return s
}

func (s *DeleteTrafficMirrorFilterRulesRequest) SetTrafficMirrorFilterRuleIds(v []*string) *DeleteTrafficMirrorFilterRulesRequest {
	s.TrafficMirrorFilterRuleIds = v
	return s
}

type DeleteTrafficMirrorFilterRulesResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteTrafficMirrorFilterRulesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteTrafficMirrorFilterRulesResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteTrafficMirrorFilterRulesResponseBody) SetRequestId(v string) *DeleteTrafficMirrorFilterRulesResponseBody {
	s.RequestId = &v
	return s
}

type DeleteTrafficMirrorFilterRulesResponse struct {
	Headers    map[string]*string                          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteTrafficMirrorFilterRulesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteTrafficMirrorFilterRulesResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteTrafficMirrorFilterRulesResponse) GoString() string {
	return s.String()
}

func (s *DeleteTrafficMirrorFilterRulesResponse) SetHeaders(v map[string]*string) *DeleteTrafficMirrorFilterRulesResponse {
	s.Headers = v
	return s
}

func (s *DeleteTrafficMirrorFilterRulesResponse) SetStatusCode(v int32) *DeleteTrafficMirrorFilterRulesResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteTrafficMirrorFilterRulesResponse) SetBody(v *DeleteTrafficMirrorFilterRulesResponseBody) *DeleteTrafficMirrorFilterRulesResponse {
	s.Body = v
	return s
}

type DeleteTrafficMirrorSessionRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among all requests. ClientToken can contain only ASCII characters.
	//
	// >  If you do not specify this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to to perform a dry run. Valid values:
	//
	// *   **true**: performs a dry run. The system checks the required parameters, request format, and limits. If the request fails the dry run, an error message is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
	// *   **false** (default): performs a dry run and sends the request. If the request passes the dry run, the operation is performed.
	DryRun       *bool   `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region to which the traffic mirror session belongs. You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list. For more information about regions that support traffic mirroring, see [Overview of traffic mirroring](~~207513~~).
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the traffic mirror session.
	TrafficMirrorSessionId *string `json:"TrafficMirrorSessionId,omitempty" xml:"TrafficMirrorSessionId,omitempty"`
}

func (s DeleteTrafficMirrorSessionRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteTrafficMirrorSessionRequest) GoString() string {
	return s.String()
}

func (s *DeleteTrafficMirrorSessionRequest) SetClientToken(v string) *DeleteTrafficMirrorSessionRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteTrafficMirrorSessionRequest) SetDryRun(v bool) *DeleteTrafficMirrorSessionRequest {
	s.DryRun = &v
	return s
}

func (s *DeleteTrafficMirrorSessionRequest) SetOwnerAccount(v string) *DeleteTrafficMirrorSessionRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteTrafficMirrorSessionRequest) SetOwnerId(v int64) *DeleteTrafficMirrorSessionRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteTrafficMirrorSessionRequest) SetRegionId(v string) *DeleteTrafficMirrorSessionRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteTrafficMirrorSessionRequest) SetResourceOwnerAccount(v string) *DeleteTrafficMirrorSessionRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteTrafficMirrorSessionRequest) SetResourceOwnerId(v int64) *DeleteTrafficMirrorSessionRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DeleteTrafficMirrorSessionRequest) SetTrafficMirrorSessionId(v string) *DeleteTrafficMirrorSessionRequest {
	s.TrafficMirrorSessionId = &v
	return s
}

type DeleteTrafficMirrorSessionResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteTrafficMirrorSessionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteTrafficMirrorSessionResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteTrafficMirrorSessionResponseBody) SetRequestId(v string) *DeleteTrafficMirrorSessionResponseBody {
	s.RequestId = &v
	return s
}

type DeleteTrafficMirrorSessionResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteTrafficMirrorSessionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteTrafficMirrorSessionResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteTrafficMirrorSessionResponse) GoString() string {
	return s.String()
}

func (s *DeleteTrafficMirrorSessionResponse) SetHeaders(v map[string]*string) *DeleteTrafficMirrorSessionResponse {
	s.Headers = v
	return s
}

func (s *DeleteTrafficMirrorSessionResponse) SetStatusCode(v int32) *DeleteTrafficMirrorSessionResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteTrafficMirrorSessionResponse) SetBody(v *DeleteTrafficMirrorSessionResponseBody) *DeleteTrafficMirrorSessionResponse {
	s.Body = v
	return s
}

type DeleteVSwitchRequest struct {
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the vSwitch.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the vSwitch that you want to delete.
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
}

func (s DeleteVSwitchRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteVSwitchRequest) GoString() string {
	return s.String()
}

func (s *DeleteVSwitchRequest) SetOwnerAccount(v string) *DeleteVSwitchRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteVSwitchRequest) SetOwnerId(v int64) *DeleteVSwitchRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteVSwitchRequest) SetRegionId(v string) *DeleteVSwitchRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteVSwitchRequest) SetResourceOwnerAccount(v string) *DeleteVSwitchRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteVSwitchRequest) SetResourceOwnerId(v int64) *DeleteVSwitchRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DeleteVSwitchRequest) SetVSwitchId(v string) *DeleteVSwitchRequest {
	s.VSwitchId = &v
	return s
}

type DeleteVSwitchResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteVSwitchResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteVSwitchResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteVSwitchResponseBody) SetRequestId(v string) *DeleteVSwitchResponseBody {
	s.RequestId = &v
	return s
}

type DeleteVSwitchResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteVSwitchResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteVSwitchResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteVSwitchResponse) GoString() string {
	return s.String()
}

func (s *DeleteVSwitchResponse) SetHeaders(v map[string]*string) *DeleteVSwitchResponse {
	s.Headers = v
	return s
}

func (s *DeleteVSwitchResponse) SetStatusCode(v int32) *DeleteVSwitchResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteVSwitchResponse) SetBody(v *DeleteVSwitchResponseBody) *DeleteVSwitchResponse {
	s.Body = v
	return s
}

type DeleteVbrHaRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the VBR failover group.
	InstanceId   *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region where the VBR is deployed.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DeleteVbrHaRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteVbrHaRequest) GoString() string {
	return s.String()
}

func (s *DeleteVbrHaRequest) SetClientToken(v string) *DeleteVbrHaRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteVbrHaRequest) SetInstanceId(v string) *DeleteVbrHaRequest {
	s.InstanceId = &v
	return s
}

func (s *DeleteVbrHaRequest) SetOwnerAccount(v string) *DeleteVbrHaRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteVbrHaRequest) SetOwnerId(v int64) *DeleteVbrHaRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteVbrHaRequest) SetRegionId(v string) *DeleteVbrHaRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteVbrHaRequest) SetResourceOwnerAccount(v string) *DeleteVbrHaRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteVbrHaRequest) SetResourceOwnerId(v int64) *DeleteVbrHaRequest {
	s.ResourceOwnerId = &v
	return s
}

type DeleteVbrHaResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteVbrHaResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteVbrHaResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteVbrHaResponseBody) SetRequestId(v string) *DeleteVbrHaResponseBody {
	s.RequestId = &v
	return s
}

type DeleteVbrHaResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteVbrHaResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteVbrHaResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteVbrHaResponse) GoString() string {
	return s.String()
}

func (s *DeleteVbrHaResponse) SetHeaders(v map[string]*string) *DeleteVbrHaResponse {
	s.Headers = v
	return s
}

func (s *DeleteVbrHaResponse) SetStatusCode(v int32) *DeleteVbrHaResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteVbrHaResponse) SetBody(v *DeleteVbrHaResponseBody) *DeleteVbrHaResponse {
	s.Body = v
	return s
}

type DeleteVcoRouteEntryRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, the system automatically uses **RequestId** as **ClientToken**. **RequestId** of each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The next hop of the destination-based route that you want to delete.
	NextHop *string `json:"NextHop,omitempty" xml:"NextHop,omitempty"`
	// The tunneling protocol. Set the value to **Ipsec**, which specifies the IPsec tunneling protocol.
	OverlayMode  *string `json:"OverlayMode,omitempty" xml:"OverlayMode,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	// The ID of the region to which the IPsec-VPN connection belongs.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The destination CIDR block of the destination-based route that you want to delete.
	RouteDest *string `json:"RouteDest,omitempty" xml:"RouteDest,omitempty"`
	// The ID of the IPsec-VPN connection.
	VpnConnectionId *string `json:"VpnConnectionId,omitempty" xml:"VpnConnectionId,omitempty"`
	// The weight of the destination-based route that you want to delete. Valid values:
	//
	// *   **0**: a low priority
	// *   **100**: a high priority
	Weight *int32 `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s DeleteVcoRouteEntryRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteVcoRouteEntryRequest) GoString() string {
	return s.String()
}

func (s *DeleteVcoRouteEntryRequest) SetClientToken(v string) *DeleteVcoRouteEntryRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteVcoRouteEntryRequest) SetNextHop(v string) *DeleteVcoRouteEntryRequest {
	s.NextHop = &v
	return s
}

func (s *DeleteVcoRouteEntryRequest) SetOverlayMode(v string) *DeleteVcoRouteEntryRequest {
	s.OverlayMode = &v
	return s
}

func (s *DeleteVcoRouteEntryRequest) SetOwnerAccount(v string) *DeleteVcoRouteEntryRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteVcoRouteEntryRequest) SetRegionId(v string) *DeleteVcoRouteEntryRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteVcoRouteEntryRequest) SetResourceOwnerAccount(v string) *DeleteVcoRouteEntryRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteVcoRouteEntryRequest) SetResourceOwnerId(v int64) *DeleteVcoRouteEntryRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DeleteVcoRouteEntryRequest) SetRouteDest(v string) *DeleteVcoRouteEntryRequest {
	s.RouteDest = &v
	return s
}

func (s *DeleteVcoRouteEntryRequest) SetVpnConnectionId(v string) *DeleteVcoRouteEntryRequest {
	s.VpnConnectionId = &v
	return s
}

func (s *DeleteVcoRouteEntryRequest) SetWeight(v int32) *DeleteVcoRouteEntryRequest {
	s.Weight = &v
	return s
}

type DeleteVcoRouteEntryResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteVcoRouteEntryResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteVcoRouteEntryResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteVcoRouteEntryResponseBody) SetRequestId(v string) *DeleteVcoRouteEntryResponseBody {
	s.RequestId = &v
	return s
}

type DeleteVcoRouteEntryResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteVcoRouteEntryResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteVcoRouteEntryResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteVcoRouteEntryResponse) GoString() string {
	return s.String()
}

func (s *DeleteVcoRouteEntryResponse) SetHeaders(v map[string]*string) *DeleteVcoRouteEntryResponse {
	s.Headers = v
	return s
}

func (s *DeleteVcoRouteEntryResponse) SetStatusCode(v int32) *DeleteVcoRouteEntryResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteVcoRouteEntryResponse) SetBody(v *DeleteVcoRouteEntryResponseBody) *DeleteVcoRouteEntryResponse {
	s.Body = v
	return s
}

type DeleteVirtualBorderRouterRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken  *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region where the VBR is deployed. You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the VBR.
	VbrId *string `json:"VbrId,omitempty" xml:"VbrId,omitempty"`
}

func (s DeleteVirtualBorderRouterRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteVirtualBorderRouterRequest) GoString() string {
	return s.String()
}

func (s *DeleteVirtualBorderRouterRequest) SetClientToken(v string) *DeleteVirtualBorderRouterRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteVirtualBorderRouterRequest) SetOwnerAccount(v string) *DeleteVirtualBorderRouterRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteVirtualBorderRouterRequest) SetOwnerId(v int64) *DeleteVirtualBorderRouterRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteVirtualBorderRouterRequest) SetRegionId(v string) *DeleteVirtualBorderRouterRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteVirtualBorderRouterRequest) SetResourceOwnerAccount(v string) *DeleteVirtualBorderRouterRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteVirtualBorderRouterRequest) SetResourceOwnerId(v int64) *DeleteVirtualBorderRouterRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DeleteVirtualBorderRouterRequest) SetVbrId(v string) *DeleteVirtualBorderRouterRequest {
	s.VbrId = &v
	return s
}

type DeleteVirtualBorderRouterResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteVirtualBorderRouterResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteVirtualBorderRouterResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteVirtualBorderRouterResponseBody) SetRequestId(v string) *DeleteVirtualBorderRouterResponseBody {
	s.RequestId = &v
	return s
}

type DeleteVirtualBorderRouterResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteVirtualBorderRouterResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteVirtualBorderRouterResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteVirtualBorderRouterResponse) GoString() string {
	return s.String()
}

func (s *DeleteVirtualBorderRouterResponse) SetHeaders(v map[string]*string) *DeleteVirtualBorderRouterResponse {
	s.Headers = v
	return s
}

func (s *DeleteVirtualBorderRouterResponse) SetStatusCode(v int32) *DeleteVirtualBorderRouterResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteVirtualBorderRouterResponse) SetBody(v *DeleteVirtualBorderRouterResponseBody) *DeleteVirtualBorderRouterResponse {
	s.Body = v
	return s
}

type DeleteVpcRequest struct {
	// Specifies whether to perform a dry run. Valid values:
	//
	// - **true**: performs a dry run. The system checks the required parameters, request syntax, and limits. If the request fails the dry run, an error message is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
	// - **false** (default): performs a dry run and sends the request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// Specifies whether to forcefully delete the VPC. Valid values:
	//
	// - **true**: yes
	// - **false** (default): no
	//
	// You can forcefully delete a VPC in the following scenarios:
	//
	// - Only an IPv4 gateway and routes that point to the IPv4 gateway exist in the VPC.
	// - Only an IPv6 gateway and routes that point to the IPv6 gateway exist in the VPC.
	ForceDelete  *bool   `json:"ForceDelete,omitempty" xml:"ForceDelete,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region where the VPC is deployed.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the VPC that you want to delete.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s DeleteVpcRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteVpcRequest) GoString() string {
	return s.String()
}

func (s *DeleteVpcRequest) SetDryRun(v bool) *DeleteVpcRequest {
	s.DryRun = &v
	return s
}

func (s *DeleteVpcRequest) SetForceDelete(v bool) *DeleteVpcRequest {
	s.ForceDelete = &v
	return s
}

func (s *DeleteVpcRequest) SetOwnerAccount(v string) *DeleteVpcRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteVpcRequest) SetOwnerId(v int64) *DeleteVpcRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteVpcRequest) SetRegionId(v string) *DeleteVpcRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteVpcRequest) SetResourceOwnerAccount(v string) *DeleteVpcRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteVpcRequest) SetResourceOwnerId(v int64) *DeleteVpcRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DeleteVpcRequest) SetVpcId(v string) *DeleteVpcRequest {
	s.VpcId = &v
	return s
}

type DeleteVpcResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteVpcResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteVpcResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteVpcResponseBody) SetRequestId(v string) *DeleteVpcResponseBody {
	s.RequestId = &v
	return s
}

type DeleteVpcResponse struct {
	Headers    map[string]*string     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteVpcResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteVpcResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteVpcResponse) GoString() string {
	return s.String()
}

func (s *DeleteVpcResponse) SetHeaders(v map[string]*string) *DeleteVpcResponse {
	s.Headers = v
	return s
}

func (s *DeleteVpcResponse) SetStatusCode(v int32) *DeleteVpcResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteVpcResponse) SetBody(v *DeleteVpcResponseBody) *DeleteVpcResponse {
	s.Body = v
	return s
}

type DeleteVpcGatewayEndpointRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The **token** can contain only ASCII characters and cannot exceed 64 characters in length.
	//
	// > If you do not specify this parameter, the system automatically uses the request ID as the client token. The request ID may be different for each request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to perform only a dry run, without performing the actual request. Valid values:
	//
	// *   **true**: performs a dry run. The system checks the request for potential issues, including the AccessKey pair, the permissions of the RAM user, and the required parameters. If the request fails the dry run, an error message is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
	// *   **false** (default): performs a dry run and performs the actual request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The ID of the gateway endpoint.
	EndpointId   *string `json:"EndpointId,omitempty" xml:"EndpointId,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the gateway endpoint.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DeleteVpcGatewayEndpointRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteVpcGatewayEndpointRequest) GoString() string {
	return s.String()
}

func (s *DeleteVpcGatewayEndpointRequest) SetClientToken(v string) *DeleteVpcGatewayEndpointRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteVpcGatewayEndpointRequest) SetDryRun(v bool) *DeleteVpcGatewayEndpointRequest {
	s.DryRun = &v
	return s
}

func (s *DeleteVpcGatewayEndpointRequest) SetEndpointId(v string) *DeleteVpcGatewayEndpointRequest {
	s.EndpointId = &v
	return s
}

func (s *DeleteVpcGatewayEndpointRequest) SetOwnerAccount(v string) *DeleteVpcGatewayEndpointRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteVpcGatewayEndpointRequest) SetOwnerId(v int64) *DeleteVpcGatewayEndpointRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteVpcGatewayEndpointRequest) SetRegionId(v string) *DeleteVpcGatewayEndpointRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteVpcGatewayEndpointRequest) SetResourceOwnerAccount(v string) *DeleteVpcGatewayEndpointRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteVpcGatewayEndpointRequest) SetResourceOwnerId(v int64) *DeleteVpcGatewayEndpointRequest {
	s.ResourceOwnerId = &v
	return s
}

type DeleteVpcGatewayEndpointResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteVpcGatewayEndpointResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteVpcGatewayEndpointResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteVpcGatewayEndpointResponseBody) SetRequestId(v string) *DeleteVpcGatewayEndpointResponseBody {
	s.RequestId = &v
	return s
}

type DeleteVpcGatewayEndpointResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteVpcGatewayEndpointResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteVpcGatewayEndpointResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteVpcGatewayEndpointResponse) GoString() string {
	return s.String()
}

func (s *DeleteVpcGatewayEndpointResponse) SetHeaders(v map[string]*string) *DeleteVpcGatewayEndpointResponse {
	s.Headers = v
	return s
}

func (s *DeleteVpcGatewayEndpointResponse) SetStatusCode(v int32) *DeleteVpcGatewayEndpointResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteVpcGatewayEndpointResponse) SetBody(v *DeleteVpcGatewayEndpointResponseBody) *DeleteVpcGatewayEndpointResponse {
	s.Body = v
	return s
}

type DeleteVpcPrefixListRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, the system uses **RequestId** as **ClientToken**. **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to check the request without performing the operation. Valid values:
	//
	// *   **true**: checks the request without performing the operation. The system checks the required parameters, request syntax, and limits. If the request fails to pass the check, an error message is returned. If the request passes the check, the `DryRunOperation` error code is returned.
	// *   **false** (default): sends the request. If the request passes the check, a 2xx HTTP status code is returned and the operation is performed.
	DryRun       *bool   `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the prefix list that you want to delete.
	PrefixListId *string `json:"PrefixListId,omitempty" xml:"PrefixListId,omitempty"`
	// The region ID of the prefix list.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DeleteVpcPrefixListRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteVpcPrefixListRequest) GoString() string {
	return s.String()
}

func (s *DeleteVpcPrefixListRequest) SetClientToken(v string) *DeleteVpcPrefixListRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteVpcPrefixListRequest) SetDryRun(v bool) *DeleteVpcPrefixListRequest {
	s.DryRun = &v
	return s
}

func (s *DeleteVpcPrefixListRequest) SetOwnerAccount(v string) *DeleteVpcPrefixListRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteVpcPrefixListRequest) SetOwnerId(v int64) *DeleteVpcPrefixListRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteVpcPrefixListRequest) SetPrefixListId(v string) *DeleteVpcPrefixListRequest {
	s.PrefixListId = &v
	return s
}

func (s *DeleteVpcPrefixListRequest) SetRegionId(v string) *DeleteVpcPrefixListRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteVpcPrefixListRequest) SetResourceOwnerAccount(v string) *DeleteVpcPrefixListRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteVpcPrefixListRequest) SetResourceOwnerId(v int64) *DeleteVpcPrefixListRequest {
	s.ResourceOwnerId = &v
	return s
}

type DeleteVpcPrefixListResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteVpcPrefixListResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteVpcPrefixListResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteVpcPrefixListResponseBody) SetRequestId(v string) *DeleteVpcPrefixListResponseBody {
	s.RequestId = &v
	return s
}

type DeleteVpcPrefixListResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteVpcPrefixListResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteVpcPrefixListResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteVpcPrefixListResponse) GoString() string {
	return s.String()
}

func (s *DeleteVpcPrefixListResponse) SetHeaders(v map[string]*string) *DeleteVpcPrefixListResponse {
	s.Headers = v
	return s
}

func (s *DeleteVpcPrefixListResponse) SetStatusCode(v int32) *DeleteVpcPrefixListResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteVpcPrefixListResponse) SetBody(v *DeleteVpcPrefixListResponseBody) *DeleteVpcPrefixListResponse {
	s.Body = v
	return s
}

type DeleteVpnAttachmentRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. ClientToken can contain only ASCII characters.
	//
	// >  If you do not set this parameter, the system automatically uses **RequestId** as **ClientToken**. **RequestId** of each API request may be different.
	ClientToken  *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	// The ID of the region to which the IPsec-VPN connection belongs.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the IPsec-VPN connection.
	VpnConnectionId *string `json:"VpnConnectionId,omitempty" xml:"VpnConnectionId,omitempty"`
}

func (s DeleteVpnAttachmentRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteVpnAttachmentRequest) GoString() string {
	return s.String()
}

func (s *DeleteVpnAttachmentRequest) SetClientToken(v string) *DeleteVpnAttachmentRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteVpnAttachmentRequest) SetOwnerAccount(v string) *DeleteVpnAttachmentRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteVpnAttachmentRequest) SetRegionId(v string) *DeleteVpnAttachmentRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteVpnAttachmentRequest) SetResourceOwnerAccount(v string) *DeleteVpnAttachmentRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteVpnAttachmentRequest) SetResourceOwnerId(v int64) *DeleteVpnAttachmentRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DeleteVpnAttachmentRequest) SetVpnConnectionId(v string) *DeleteVpnAttachmentRequest {
	s.VpnConnectionId = &v
	return s
}

type DeleteVpnAttachmentResponseBody struct {
	// The status code returned for the operation. A value of **200** indicates that the operation is performed.
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The information returned for the operation.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the operation is performed.
	//
	// *   **true**: yes
	// *   **false**: no
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteVpnAttachmentResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteVpnAttachmentResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteVpnAttachmentResponseBody) SetCode(v string) *DeleteVpnAttachmentResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteVpnAttachmentResponseBody) SetMessage(v string) *DeleteVpnAttachmentResponseBody {
	s.Message = &v
	return s
}

func (s *DeleteVpnAttachmentResponseBody) SetRequestId(v string) *DeleteVpnAttachmentResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteVpnAttachmentResponseBody) SetSuccess(v bool) *DeleteVpnAttachmentResponseBody {
	s.Success = &v
	return s
}

type DeleteVpnAttachmentResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteVpnAttachmentResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteVpnAttachmentResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteVpnAttachmentResponse) GoString() string {
	return s.String()
}

func (s *DeleteVpnAttachmentResponse) SetHeaders(v map[string]*string) *DeleteVpnAttachmentResponse {
	s.Headers = v
	return s
}

func (s *DeleteVpnAttachmentResponse) SetStatusCode(v int32) *DeleteVpnAttachmentResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteVpnAttachmentResponse) SetBody(v *DeleteVpnAttachmentResponseBody) *DeleteVpnAttachmentResponse {
	s.Body = v
	return s
}

type DeleteVpnConnectionRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, the system automatically uses **RequestId** as **ClientToken**. **RequestId** of each API request may be different.
	ClientToken  *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the IPsec-VPN connection.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the IPsec-VPN connection.
	VpnConnectionId *string `json:"VpnConnectionId,omitempty" xml:"VpnConnectionId,omitempty"`
}

func (s DeleteVpnConnectionRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteVpnConnectionRequest) GoString() string {
	return s.String()
}

func (s *DeleteVpnConnectionRequest) SetClientToken(v string) *DeleteVpnConnectionRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteVpnConnectionRequest) SetOwnerAccount(v string) *DeleteVpnConnectionRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteVpnConnectionRequest) SetOwnerId(v int64) *DeleteVpnConnectionRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteVpnConnectionRequest) SetRegionId(v string) *DeleteVpnConnectionRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteVpnConnectionRequest) SetResourceOwnerAccount(v string) *DeleteVpnConnectionRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteVpnConnectionRequest) SetResourceOwnerId(v int64) *DeleteVpnConnectionRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DeleteVpnConnectionRequest) SetVpnConnectionId(v string) *DeleteVpnConnectionRequest {
	s.VpnConnectionId = &v
	return s
}

type DeleteVpnConnectionResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteVpnConnectionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteVpnConnectionResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteVpnConnectionResponseBody) SetRequestId(v string) *DeleteVpnConnectionResponseBody {
	s.RequestId = &v
	return s
}

type DeleteVpnConnectionResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteVpnConnectionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteVpnConnectionResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteVpnConnectionResponse) GoString() string {
	return s.String()
}

func (s *DeleteVpnConnectionResponse) SetHeaders(v map[string]*string) *DeleteVpnConnectionResponse {
	s.Headers = v
	return s
}

func (s *DeleteVpnConnectionResponse) SetStatusCode(v int32) *DeleteVpnConnectionResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteVpnConnectionResponse) SetBody(v *DeleteVpnConnectionResponseBody) *DeleteVpnConnectionResponse {
	s.Body = v
	return s
}

type DeleteVpnGatewayRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** may be different for each API request.
	ClientToken  *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region where the VPN gateway is created.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the VPN gateway.
	VpnGatewayId *string `json:"VpnGatewayId,omitempty" xml:"VpnGatewayId,omitempty"`
}

func (s DeleteVpnGatewayRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteVpnGatewayRequest) GoString() string {
	return s.String()
}

func (s *DeleteVpnGatewayRequest) SetClientToken(v string) *DeleteVpnGatewayRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteVpnGatewayRequest) SetOwnerAccount(v string) *DeleteVpnGatewayRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteVpnGatewayRequest) SetOwnerId(v int64) *DeleteVpnGatewayRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteVpnGatewayRequest) SetRegionId(v string) *DeleteVpnGatewayRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteVpnGatewayRequest) SetResourceOwnerAccount(v string) *DeleteVpnGatewayRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteVpnGatewayRequest) SetResourceOwnerId(v int64) *DeleteVpnGatewayRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DeleteVpnGatewayRequest) SetVpnGatewayId(v string) *DeleteVpnGatewayRequest {
	s.VpnGatewayId = &v
	return s
}

type DeleteVpnGatewayResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteVpnGatewayResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteVpnGatewayResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteVpnGatewayResponseBody) SetRequestId(v string) *DeleteVpnGatewayResponseBody {
	s.RequestId = &v
	return s
}

type DeleteVpnGatewayResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteVpnGatewayResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteVpnGatewayResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteVpnGatewayResponse) GoString() string {
	return s.String()
}

func (s *DeleteVpnGatewayResponse) SetHeaders(v map[string]*string) *DeleteVpnGatewayResponse {
	s.Headers = v
	return s
}

func (s *DeleteVpnGatewayResponse) SetStatusCode(v int32) *DeleteVpnGatewayResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteVpnGatewayResponse) SetBody(v *DeleteVpnGatewayResponseBody) *DeleteVpnGatewayResponse {
	s.Body = v
	return s
}

type DeleteVpnPbrRouteEntryRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that the value is unique among different requests. The client token can contain only ASCII characters.
	//
	// >  If you do not specify this parameter, the system automatically uses **RequestId** as **ClientToken**. The value of **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The next hop of the policy-based route.
	NextHop *string `json:"NextHop,omitempty" xml:"NextHop,omitempty"`
	// The tunneling protocol. Set the value to **Ipsec**.
	OverlayMode  *string `json:"OverlayMode,omitempty" xml:"OverlayMode,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The priority of the policy-based route.
	//
	// *   If the route was not assigned a priority, this parameter is optional.
	//
	// *   If the route was assigned a priority, this parameter is optional.
	//
	//     If you set this parameter, set the value to the priority that was assigned to the route. Otherwise, the operation fails.
	Priority *int32 `json:"Priority,omitempty" xml:"Priority,omitempty"`
	// The ID of the region where the VPN gateway is created. You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The destination CIDR block of the policy-based route.
	RouteDest *string `json:"RouteDest,omitempty" xml:"RouteDest,omitempty"`
	// The source CIDR block of the policy-based route.
	RouteSource *string `json:"RouteSource,omitempty" xml:"RouteSource,omitempty"`
	// The ID of the VPN gateway.
	VpnGatewayId *string `json:"VpnGatewayId,omitempty" xml:"VpnGatewayId,omitempty"`
	// The weight of the policy-based route.
	Weight *int32 `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s DeleteVpnPbrRouteEntryRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteVpnPbrRouteEntryRequest) GoString() string {
	return s.String()
}

func (s *DeleteVpnPbrRouteEntryRequest) SetClientToken(v string) *DeleteVpnPbrRouteEntryRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteVpnPbrRouteEntryRequest) SetNextHop(v string) *DeleteVpnPbrRouteEntryRequest {
	s.NextHop = &v
	return s
}

func (s *DeleteVpnPbrRouteEntryRequest) SetOverlayMode(v string) *DeleteVpnPbrRouteEntryRequest {
	s.OverlayMode = &v
	return s
}

func (s *DeleteVpnPbrRouteEntryRequest) SetOwnerAccount(v string) *DeleteVpnPbrRouteEntryRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteVpnPbrRouteEntryRequest) SetOwnerId(v int64) *DeleteVpnPbrRouteEntryRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteVpnPbrRouteEntryRequest) SetPriority(v int32) *DeleteVpnPbrRouteEntryRequest {
	s.Priority = &v
	return s
}

func (s *DeleteVpnPbrRouteEntryRequest) SetRegionId(v string) *DeleteVpnPbrRouteEntryRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteVpnPbrRouteEntryRequest) SetResourceOwnerAccount(v string) *DeleteVpnPbrRouteEntryRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteVpnPbrRouteEntryRequest) SetResourceOwnerId(v int64) *DeleteVpnPbrRouteEntryRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DeleteVpnPbrRouteEntryRequest) SetRouteDest(v string) *DeleteVpnPbrRouteEntryRequest {
	s.RouteDest = &v
	return s
}

func (s *DeleteVpnPbrRouteEntryRequest) SetRouteSource(v string) *DeleteVpnPbrRouteEntryRequest {
	s.RouteSource = &v
	return s
}

func (s *DeleteVpnPbrRouteEntryRequest) SetVpnGatewayId(v string) *DeleteVpnPbrRouteEntryRequest {
	s.VpnGatewayId = &v
	return s
}

func (s *DeleteVpnPbrRouteEntryRequest) SetWeight(v int32) *DeleteVpnPbrRouteEntryRequest {
	s.Weight = &v
	return s
}

type DeleteVpnPbrRouteEntryResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteVpnPbrRouteEntryResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteVpnPbrRouteEntryResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteVpnPbrRouteEntryResponseBody) SetRequestId(v string) *DeleteVpnPbrRouteEntryResponseBody {
	s.RequestId = &v
	return s
}

type DeleteVpnPbrRouteEntryResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteVpnPbrRouteEntryResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteVpnPbrRouteEntryResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteVpnPbrRouteEntryResponse) GoString() string {
	return s.String()
}

func (s *DeleteVpnPbrRouteEntryResponse) SetHeaders(v map[string]*string) *DeleteVpnPbrRouteEntryResponse {
	s.Headers = v
	return s
}

func (s *DeleteVpnPbrRouteEntryResponse) SetStatusCode(v int32) *DeleteVpnPbrRouteEntryResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteVpnPbrRouteEntryResponse) SetBody(v *DeleteVpnPbrRouteEntryResponseBody) *DeleteVpnPbrRouteEntryResponse {
	s.Body = v
	return s
}

type DeleteVpnRouteEntryRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The next hop of the destination-based route.
	NextHop *string `json:"NextHop,omitempty" xml:"NextHop,omitempty"`
	// The tunnel protocol. Set the value to **Ipsec**.
	OverlayMode  *string `json:"OverlayMode,omitempty" xml:"OverlayMode,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region where the VPN gateway is created. You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The destination CIDR block of the destination-based route.
	RouteDest *string `json:"RouteDest,omitempty" xml:"RouteDest,omitempty"`
	// The ID of the VPN gateway.
	VpnGatewayId *string `json:"VpnGatewayId,omitempty" xml:"VpnGatewayId,omitempty"`
	// The weight of the destination-based route. Valid values:
	//
	// *   **0**: a low priority
	// *   **100**: a high priority
	Weight *int32 `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s DeleteVpnRouteEntryRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteVpnRouteEntryRequest) GoString() string {
	return s.String()
}

func (s *DeleteVpnRouteEntryRequest) SetClientToken(v string) *DeleteVpnRouteEntryRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteVpnRouteEntryRequest) SetNextHop(v string) *DeleteVpnRouteEntryRequest {
	s.NextHop = &v
	return s
}

func (s *DeleteVpnRouteEntryRequest) SetOverlayMode(v string) *DeleteVpnRouteEntryRequest {
	s.OverlayMode = &v
	return s
}

func (s *DeleteVpnRouteEntryRequest) SetOwnerAccount(v string) *DeleteVpnRouteEntryRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteVpnRouteEntryRequest) SetOwnerId(v int64) *DeleteVpnRouteEntryRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteVpnRouteEntryRequest) SetRegionId(v string) *DeleteVpnRouteEntryRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteVpnRouteEntryRequest) SetResourceOwnerAccount(v string) *DeleteVpnRouteEntryRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteVpnRouteEntryRequest) SetResourceOwnerId(v int64) *DeleteVpnRouteEntryRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DeleteVpnRouteEntryRequest) SetRouteDest(v string) *DeleteVpnRouteEntryRequest {
	s.RouteDest = &v
	return s
}

func (s *DeleteVpnRouteEntryRequest) SetVpnGatewayId(v string) *DeleteVpnRouteEntryRequest {
	s.VpnGatewayId = &v
	return s
}

func (s *DeleteVpnRouteEntryRequest) SetWeight(v int32) *DeleteVpnRouteEntryRequest {
	s.Weight = &v
	return s
}

type DeleteVpnRouteEntryResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteVpnRouteEntryResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteVpnRouteEntryResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteVpnRouteEntryResponseBody) SetRequestId(v string) *DeleteVpnRouteEntryResponseBody {
	s.RequestId = &v
	return s
}

type DeleteVpnRouteEntryResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteVpnRouteEntryResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteVpnRouteEntryResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteVpnRouteEntryResponse) GoString() string {
	return s.String()
}

func (s *DeleteVpnRouteEntryResponse) SetHeaders(v map[string]*string) *DeleteVpnRouteEntryResponse {
	s.Headers = v
	return s
}

func (s *DeleteVpnRouteEntryResponse) SetStatusCode(v int32) *DeleteVpnRouteEntryResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteVpnRouteEntryResponse) SetBody(v *DeleteVpnRouteEntryResponseBody) *DeleteVpnRouteEntryResponse {
	s.Body = v
	return s
}

type DeletionProtectionRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among all requests. ClientToken can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the instance for which you want to enable deletion protection.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	OwnerId    *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// Specifies whether to enable deletion protection. Valid values:
	//
	// *   **true**: yes
	// *   **false**: no
	ProtectionEnable *bool `json:"ProtectionEnable,omitempty" xml:"ProtectionEnable,omitempty"`
	// The ID of the region where the instance for which you want to enable deletion protection is deployed. You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The type of instance. Valid values:
	//
	// *   **EIP**: Elastic IP Address (EIP)
	// *   **CBWP**: EIP bandwidth plan
	// *   **NATGW**: NAT gateway
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s DeletionProtectionRequest) String() string {
	return tea.Prettify(s)
}

func (s DeletionProtectionRequest) GoString() string {
	return s.String()
}

func (s *DeletionProtectionRequest) SetClientToken(v string) *DeletionProtectionRequest {
	s.ClientToken = &v
	return s
}

func (s *DeletionProtectionRequest) SetInstanceId(v string) *DeletionProtectionRequest {
	s.InstanceId = &v
	return s
}

func (s *DeletionProtectionRequest) SetOwnerId(v int64) *DeletionProtectionRequest {
	s.OwnerId = &v
	return s
}

func (s *DeletionProtectionRequest) SetProtectionEnable(v bool) *DeletionProtectionRequest {
	s.ProtectionEnable = &v
	return s
}

func (s *DeletionProtectionRequest) SetRegionId(v string) *DeletionProtectionRequest {
	s.RegionId = &v
	return s
}

func (s *DeletionProtectionRequest) SetResourceOwnerAccount(v string) *DeletionProtectionRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeletionProtectionRequest) SetResourceOwnerId(v int64) *DeletionProtectionRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DeletionProtectionRequest) SetType(v string) *DeletionProtectionRequest {
	s.Type = &v
	return s
}

type DeletionProtectionResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeletionProtectionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeletionProtectionResponseBody) GoString() string {
	return s.String()
}

func (s *DeletionProtectionResponseBody) SetRequestId(v string) *DeletionProtectionResponseBody {
	s.RequestId = &v
	return s
}

type DeletionProtectionResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeletionProtectionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeletionProtectionResponse) String() string {
	return tea.Prettify(s)
}

func (s DeletionProtectionResponse) GoString() string {
	return s.String()
}

func (s *DeletionProtectionResponse) SetHeaders(v map[string]*string) *DeletionProtectionResponse {
	s.Headers = v
	return s
}

func (s *DeletionProtectionResponse) SetStatusCode(v int32) *DeletionProtectionResponse {
	s.StatusCode = &v
	return s
}

func (s *DeletionProtectionResponse) SetBody(v *DeletionProtectionResponseBody) *DeletionProtectionResponse {
	s.Body = v
	return s
}

type DescribeAccessPointsRequest struct {
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	OwnerId        *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of the page to return. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Maximum value: **50**. Default value: **10**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The region ID of the access point.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeAccessPointsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeAccessPointsRequest) GoString() string {
	return s.String()
}

func (s *DescribeAccessPointsRequest) SetAcceptLanguage(v string) *DescribeAccessPointsRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *DescribeAccessPointsRequest) SetOwnerId(v int64) *DescribeAccessPointsRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeAccessPointsRequest) SetPageNumber(v int32) *DescribeAccessPointsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeAccessPointsRequest) SetPageSize(v int32) *DescribeAccessPointsRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeAccessPointsRequest) SetRegionId(v string) *DescribeAccessPointsRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeAccessPointsRequest) SetResourceOwnerAccount(v string) *DescribeAccessPointsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeAccessPointsRequest) SetResourceOwnerId(v int64) *DescribeAccessPointsRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeAccessPointsResponseBody struct {
	// The information about the access point.
	AccessPointSet *DescribeAccessPointsResponseBodyAccessPointSet `json:"AccessPointSet,omitempty" xml:"AccessPointSet,omitempty" type:"Struct"`
	// The number of the returned page. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned on each page. Maximum value: **50**. Default value: **10**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeAccessPointsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeAccessPointsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeAccessPointsResponseBody) SetAccessPointSet(v *DescribeAccessPointsResponseBodyAccessPointSet) *DescribeAccessPointsResponseBody {
	s.AccessPointSet = v
	return s
}

func (s *DescribeAccessPointsResponseBody) SetPageNumber(v int32) *DescribeAccessPointsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeAccessPointsResponseBody) SetPageSize(v int32) *DescribeAccessPointsResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeAccessPointsResponseBody) SetRequestId(v string) *DescribeAccessPointsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeAccessPointsResponseBody) SetTotalCount(v int32) *DescribeAccessPointsResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeAccessPointsResponseBodyAccessPointSet struct {
	AccessPointType []*DescribeAccessPointsResponseBodyAccessPointSetAccessPointType `json:"AccessPointType,omitempty" xml:"AccessPointType,omitempty" type:"Repeated"`
}

func (s DescribeAccessPointsResponseBodyAccessPointSet) String() string {
	return tea.Prettify(s)
}

func (s DescribeAccessPointsResponseBodyAccessPointSet) GoString() string {
	return s.String()
}

func (s *DescribeAccessPointsResponseBodyAccessPointSet) SetAccessPointType(v []*DescribeAccessPointsResponseBodyAccessPointSetAccessPointType) *DescribeAccessPointsResponseBodyAccessPointSet {
	s.AccessPointType = v
	return s
}

type DescribeAccessPointsResponseBodyAccessPointSetAccessPointType struct {
	// The feature model of the access point.
	AccessPointFeatureModels *DescribeAccessPointsResponseBodyAccessPointSetAccessPointTypeAccessPointFeatureModels `json:"AccessPointFeatureModels,omitempty" xml:"AccessPointFeatureModels,omitempty" type:"Struct"`
	// The ID of the access point.
	AccessPointId *string `json:"AccessPointId,omitempty" xml:"AccessPointId,omitempty"`
	// The region ID of the access point.
	AttachedRegionNo *string `json:"AttachedRegionNo,omitempty" xml:"AttachedRegionNo,omitempty"`
	// The description of the access point.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The colocation provider of the access point.
	HostOperator *string `json:"HostOperator,omitempty" xml:"HostOperator,omitempty"`
	// The location of the access point.
	Location *string `json:"Location,omitempty" xml:"Location,omitempty"`
	// The name of the access point.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The status of the access point. Valid values:
	//
	// *   **Recommended**: The access point is ready for use.
	// *   **hot**: A large number of Express Connect circuits are connected to the access point.
	// *   **full**: The number of Express Connect circuits connected to the access point has reached the upper limit.
	// *   **disabled**: The access point is unavailable.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The network type of the Express Connect circuit. Default value: **VPC**.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s DescribeAccessPointsResponseBodyAccessPointSetAccessPointType) String() string {
	return tea.Prettify(s)
}

func (s DescribeAccessPointsResponseBodyAccessPointSetAccessPointType) GoString() string {
	return s.String()
}

func (s *DescribeAccessPointsResponseBodyAccessPointSetAccessPointType) SetAccessPointFeatureModels(v *DescribeAccessPointsResponseBodyAccessPointSetAccessPointTypeAccessPointFeatureModels) *DescribeAccessPointsResponseBodyAccessPointSetAccessPointType {
	s.AccessPointFeatureModels = v
	return s
}

func (s *DescribeAccessPointsResponseBodyAccessPointSetAccessPointType) SetAccessPointId(v string) *DescribeAccessPointsResponseBodyAccessPointSetAccessPointType {
	s.AccessPointId = &v
	return s
}

func (s *DescribeAccessPointsResponseBodyAccessPointSetAccessPointType) SetAttachedRegionNo(v string) *DescribeAccessPointsResponseBodyAccessPointSetAccessPointType {
	s.AttachedRegionNo = &v
	return s
}

func (s *DescribeAccessPointsResponseBodyAccessPointSetAccessPointType) SetDescription(v string) *DescribeAccessPointsResponseBodyAccessPointSetAccessPointType {
	s.Description = &v
	return s
}

func (s *DescribeAccessPointsResponseBodyAccessPointSetAccessPointType) SetHostOperator(v string) *DescribeAccessPointsResponseBodyAccessPointSetAccessPointType {
	s.HostOperator = &v
	return s
}

func (s *DescribeAccessPointsResponseBodyAccessPointSetAccessPointType) SetLocation(v string) *DescribeAccessPointsResponseBodyAccessPointSetAccessPointType {
	s.Location = &v
	return s
}

func (s *DescribeAccessPointsResponseBodyAccessPointSetAccessPointType) SetName(v string) *DescribeAccessPointsResponseBodyAccessPointSetAccessPointType {
	s.Name = &v
	return s
}

func (s *DescribeAccessPointsResponseBodyAccessPointSetAccessPointType) SetStatus(v string) *DescribeAccessPointsResponseBodyAccessPointSetAccessPointType {
	s.Status = &v
	return s
}

func (s *DescribeAccessPointsResponseBodyAccessPointSetAccessPointType) SetType(v string) *DescribeAccessPointsResponseBodyAccessPointSetAccessPointType {
	s.Type = &v
	return s
}

type DescribeAccessPointsResponseBodyAccessPointSetAccessPointTypeAccessPointFeatureModels struct {
	AccessPointFeatureModel []*DescribeAccessPointsResponseBodyAccessPointSetAccessPointTypeAccessPointFeatureModelsAccessPointFeatureModel `json:"AccessPointFeatureModel,omitempty" xml:"AccessPointFeatureModel,omitempty" type:"Repeated"`
}

func (s DescribeAccessPointsResponseBodyAccessPointSetAccessPointTypeAccessPointFeatureModels) String() string {
	return tea.Prettify(s)
}

func (s DescribeAccessPointsResponseBodyAccessPointSetAccessPointTypeAccessPointFeatureModels) GoString() string {
	return s.String()
}

func (s *DescribeAccessPointsResponseBodyAccessPointSetAccessPointTypeAccessPointFeatureModels) SetAccessPointFeatureModel(v []*DescribeAccessPointsResponseBodyAccessPointSetAccessPointTypeAccessPointFeatureModelsAccessPointFeatureModel) *DescribeAccessPointsResponseBodyAccessPointSetAccessPointTypeAccessPointFeatureModels {
	s.AccessPointFeatureModel = v
	return s
}

type DescribeAccessPointsResponseBodyAccessPointSetAccessPointTypeAccessPointFeatureModelsAccessPointFeatureModel struct {
	// The feature of the access point.
	FeatureKey *string `json:"FeatureKey,omitempty" xml:"FeatureKey,omitempty"`
	// The feature value of the access point.
	FeatureValue *string `json:"FeatureValue,omitempty" xml:"FeatureValue,omitempty"`
}

func (s DescribeAccessPointsResponseBodyAccessPointSetAccessPointTypeAccessPointFeatureModelsAccessPointFeatureModel) String() string {
	return tea.Prettify(s)
}

func (s DescribeAccessPointsResponseBodyAccessPointSetAccessPointTypeAccessPointFeatureModelsAccessPointFeatureModel) GoString() string {
	return s.String()
}

func (s *DescribeAccessPointsResponseBodyAccessPointSetAccessPointTypeAccessPointFeatureModelsAccessPointFeatureModel) SetFeatureKey(v string) *DescribeAccessPointsResponseBodyAccessPointSetAccessPointTypeAccessPointFeatureModelsAccessPointFeatureModel {
	s.FeatureKey = &v
	return s
}

func (s *DescribeAccessPointsResponseBodyAccessPointSetAccessPointTypeAccessPointFeatureModelsAccessPointFeatureModel) SetFeatureValue(v string) *DescribeAccessPointsResponseBodyAccessPointSetAccessPointTypeAccessPointFeatureModelsAccessPointFeatureModel {
	s.FeatureValue = &v
	return s
}

type DescribeAccessPointsResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeAccessPointsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeAccessPointsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeAccessPointsResponse) GoString() string {
	return s.String()
}

func (s *DescribeAccessPointsResponse) SetHeaders(v map[string]*string) *DescribeAccessPointsResponse {
	s.Headers = v
	return s
}

func (s *DescribeAccessPointsResponse) SetStatusCode(v int32) *DescribeAccessPointsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeAccessPointsResponse) SetBody(v *DescribeAccessPointsResponseBody) *DescribeAccessPointsResponse {
	s.Body = v
	return s
}

type DescribeBgpGroupsRequest struct {
	// The ID of the BGP group.
	BgpGroupId *string `json:"BgpGroupId,omitempty" xml:"BgpGroupId,omitempty"`
	// Specifies whether the BGP group is the default one. Valid values:
	//
	// *   **false**: yes
	// *   **true**: no
	IsDefault    *bool   `json:"IsDefault,omitempty" xml:"IsDefault,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of the page to return. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Maximum value: **50**. Default value: **10**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The region ID of the VBR.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the virtual border router (VBR) that is associated with the BGP group.
	RouterId *string `json:"RouterId,omitempty" xml:"RouterId,omitempty"`
}

func (s DescribeBgpGroupsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeBgpGroupsRequest) GoString() string {
	return s.String()
}

func (s *DescribeBgpGroupsRequest) SetBgpGroupId(v string) *DescribeBgpGroupsRequest {
	s.BgpGroupId = &v
	return s
}

func (s *DescribeBgpGroupsRequest) SetIsDefault(v bool) *DescribeBgpGroupsRequest {
	s.IsDefault = &v
	return s
}

func (s *DescribeBgpGroupsRequest) SetOwnerAccount(v string) *DescribeBgpGroupsRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeBgpGroupsRequest) SetOwnerId(v int64) *DescribeBgpGroupsRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeBgpGroupsRequest) SetPageNumber(v int32) *DescribeBgpGroupsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeBgpGroupsRequest) SetPageSize(v int32) *DescribeBgpGroupsRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeBgpGroupsRequest) SetRegionId(v string) *DescribeBgpGroupsRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeBgpGroupsRequest) SetResourceOwnerAccount(v string) *DescribeBgpGroupsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeBgpGroupsRequest) SetResourceOwnerId(v int64) *DescribeBgpGroupsRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeBgpGroupsRequest) SetRouterId(v string) *DescribeBgpGroupsRequest {
	s.RouterId = &v
	return s
}

type DescribeBgpGroupsResponseBody struct {
	// The detailed information about the BGP group.
	BgpGroups *DescribeBgpGroupsResponseBodyBgpGroups `json:"BgpGroups,omitempty" xml:"BgpGroups,omitempty" type:"Struct"`
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeBgpGroupsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeBgpGroupsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeBgpGroupsResponseBody) SetBgpGroups(v *DescribeBgpGroupsResponseBodyBgpGroups) *DescribeBgpGroupsResponseBody {
	s.BgpGroups = v
	return s
}

func (s *DescribeBgpGroupsResponseBody) SetPageNumber(v int32) *DescribeBgpGroupsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeBgpGroupsResponseBody) SetPageSize(v int32) *DescribeBgpGroupsResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeBgpGroupsResponseBody) SetRequestId(v string) *DescribeBgpGroupsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeBgpGroupsResponseBody) SetTotalCount(v int32) *DescribeBgpGroupsResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeBgpGroupsResponseBodyBgpGroups struct {
	BgpGroup []*DescribeBgpGroupsResponseBodyBgpGroupsBgpGroup `json:"BgpGroup,omitempty" xml:"BgpGroup,omitempty" type:"Repeated"`
}

func (s DescribeBgpGroupsResponseBodyBgpGroups) String() string {
	return tea.Prettify(s)
}

func (s DescribeBgpGroupsResponseBodyBgpGroups) GoString() string {
	return s.String()
}

func (s *DescribeBgpGroupsResponseBodyBgpGroups) SetBgpGroup(v []*DescribeBgpGroupsResponseBodyBgpGroupsBgpGroup) *DescribeBgpGroupsResponseBodyBgpGroups {
	s.BgpGroup = v
	return s
}

type DescribeBgpGroupsResponseBodyBgpGroupsBgpGroup struct {
	// The key used by the BGP group.
	AuthKey *string `json:"AuthKey,omitempty" xml:"AuthKey,omitempty"`
	// The ID of the BGP group.
	BgpGroupId *string `json:"BgpGroupId,omitempty" xml:"BgpGroupId,omitempty"`
	// The description of the BGP group.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The hold time to receive BGP messages. Unit: seconds.
	//
	// >  If no message is received within the hold time, the BGP peer is considered disconnected.
	Hold *string `json:"Hold,omitempty" xml:"Hold,omitempty"`
	// The IP version of the BGP group. Valid values:
	//
	// *   **ipv4**: IPv4
	// *   **ipv6**: IPv6. IPv6 is supported only if the VBR of the BGP group has IPv6 enabled.
	IpVersion *string `json:"IpVersion,omitempty" xml:"IpVersion,omitempty"`
	// Indicates whether the ASN is fake. Valid values:
	//
	// *   **false**: no
	// *   **true**: yes
	IsFake *string `json:"IsFake,omitempty" xml:"IsFake,omitempty"`
	// The keepalive time. Unit: seconds.
	Keepalive *string `json:"Keepalive,omitempty" xml:"Keepalive,omitempty"`
	// The ASN of the VBR.
	LocalAsn *string `json:"LocalAsn,omitempty" xml:"LocalAsn,omitempty"`
	// The name of the BGP group.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The autonomous system number (ASN) of the gateway device in the data center.
	PeerAsn *string `json:"PeerAsn,omitempty" xml:"PeerAsn,omitempty"`
	// The ID of the region to which the BGP group belongs.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The maximum number of route entries for BGP dynamic route learning.
	RouteLimit *string `json:"RouteLimit,omitempty" xml:"RouteLimit,omitempty"`
	// The ID of the VBR.
	RouterId *string `json:"RouterId,omitempty" xml:"RouterId,omitempty"`
	// The status of the BGP group.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeBgpGroupsResponseBodyBgpGroupsBgpGroup) String() string {
	return tea.Prettify(s)
}

func (s DescribeBgpGroupsResponseBodyBgpGroupsBgpGroup) GoString() string {
	return s.String()
}

func (s *DescribeBgpGroupsResponseBodyBgpGroupsBgpGroup) SetAuthKey(v string) *DescribeBgpGroupsResponseBodyBgpGroupsBgpGroup {
	s.AuthKey = &v
	return s
}

func (s *DescribeBgpGroupsResponseBodyBgpGroupsBgpGroup) SetBgpGroupId(v string) *DescribeBgpGroupsResponseBodyBgpGroupsBgpGroup {
	s.BgpGroupId = &v
	return s
}

func (s *DescribeBgpGroupsResponseBodyBgpGroupsBgpGroup) SetDescription(v string) *DescribeBgpGroupsResponseBodyBgpGroupsBgpGroup {
	s.Description = &v
	return s
}

func (s *DescribeBgpGroupsResponseBodyBgpGroupsBgpGroup) SetHold(v string) *DescribeBgpGroupsResponseBodyBgpGroupsBgpGroup {
	s.Hold = &v
	return s
}

func (s *DescribeBgpGroupsResponseBodyBgpGroupsBgpGroup) SetIpVersion(v string) *DescribeBgpGroupsResponseBodyBgpGroupsBgpGroup {
	s.IpVersion = &v
	return s
}

func (s *DescribeBgpGroupsResponseBodyBgpGroupsBgpGroup) SetIsFake(v string) *DescribeBgpGroupsResponseBodyBgpGroupsBgpGroup {
	s.IsFake = &v
	return s
}

func (s *DescribeBgpGroupsResponseBodyBgpGroupsBgpGroup) SetKeepalive(v string) *DescribeBgpGroupsResponseBodyBgpGroupsBgpGroup {
	s.Keepalive = &v
	return s
}

func (s *DescribeBgpGroupsResponseBodyBgpGroupsBgpGroup) SetLocalAsn(v string) *DescribeBgpGroupsResponseBodyBgpGroupsBgpGroup {
	s.LocalAsn = &v
	return s
}

func (s *DescribeBgpGroupsResponseBodyBgpGroupsBgpGroup) SetName(v string) *DescribeBgpGroupsResponseBodyBgpGroupsBgpGroup {
	s.Name = &v
	return s
}

func (s *DescribeBgpGroupsResponseBodyBgpGroupsBgpGroup) SetPeerAsn(v string) *DescribeBgpGroupsResponseBodyBgpGroupsBgpGroup {
	s.PeerAsn = &v
	return s
}

func (s *DescribeBgpGroupsResponseBodyBgpGroupsBgpGroup) SetRegionId(v string) *DescribeBgpGroupsResponseBodyBgpGroupsBgpGroup {
	s.RegionId = &v
	return s
}

func (s *DescribeBgpGroupsResponseBodyBgpGroupsBgpGroup) SetRouteLimit(v string) *DescribeBgpGroupsResponseBodyBgpGroupsBgpGroup {
	s.RouteLimit = &v
	return s
}

func (s *DescribeBgpGroupsResponseBodyBgpGroupsBgpGroup) SetRouterId(v string) *DescribeBgpGroupsResponseBodyBgpGroupsBgpGroup {
	s.RouterId = &v
	return s
}

func (s *DescribeBgpGroupsResponseBodyBgpGroupsBgpGroup) SetStatus(v string) *DescribeBgpGroupsResponseBodyBgpGroupsBgpGroup {
	s.Status = &v
	return s
}

type DescribeBgpGroupsResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeBgpGroupsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeBgpGroupsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeBgpGroupsResponse) GoString() string {
	return s.String()
}

func (s *DescribeBgpGroupsResponse) SetHeaders(v map[string]*string) *DescribeBgpGroupsResponse {
	s.Headers = v
	return s
}

func (s *DescribeBgpGroupsResponse) SetStatusCode(v int32) *DescribeBgpGroupsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeBgpGroupsResponse) SetBody(v *DescribeBgpGroupsResponseBody) *DescribeBgpGroupsResponse {
	s.Body = v
	return s
}

type DescribeBgpNetworksRequest struct {
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of the page to return. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Maximum value: **50**. Default value: **10**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the region where the BGP group is deployed.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the virtual border router (VBR).
	RouterId *string `json:"RouterId,omitempty" xml:"RouterId,omitempty"`
}

func (s DescribeBgpNetworksRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeBgpNetworksRequest) GoString() string {
	return s.String()
}

func (s *DescribeBgpNetworksRequest) SetOwnerAccount(v string) *DescribeBgpNetworksRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeBgpNetworksRequest) SetOwnerId(v int64) *DescribeBgpNetworksRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeBgpNetworksRequest) SetPageNumber(v int32) *DescribeBgpNetworksRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeBgpNetworksRequest) SetPageSize(v int32) *DescribeBgpNetworksRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeBgpNetworksRequest) SetRegionId(v string) *DescribeBgpNetworksRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeBgpNetworksRequest) SetResourceOwnerAccount(v string) *DescribeBgpNetworksRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeBgpNetworksRequest) SetResourceOwnerId(v int64) *DescribeBgpNetworksRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeBgpNetworksRequest) SetRouterId(v string) *DescribeBgpNetworksRequest {
	s.RouterId = &v
	return s
}

type DescribeBgpNetworksResponseBody struct {
	// BGP networks.
	BgpNetworks *DescribeBgpNetworksResponseBodyBgpNetworks `json:"BgpNetworks,omitempty" xml:"BgpNetworks,omitempty" type:"Struct"`
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of advertised BGP networks.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeBgpNetworksResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeBgpNetworksResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeBgpNetworksResponseBody) SetBgpNetworks(v *DescribeBgpNetworksResponseBodyBgpNetworks) *DescribeBgpNetworksResponseBody {
	s.BgpNetworks = v
	return s
}

func (s *DescribeBgpNetworksResponseBody) SetPageNumber(v int32) *DescribeBgpNetworksResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeBgpNetworksResponseBody) SetPageSize(v int32) *DescribeBgpNetworksResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeBgpNetworksResponseBody) SetRequestId(v string) *DescribeBgpNetworksResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeBgpNetworksResponseBody) SetTotalCount(v int32) *DescribeBgpNetworksResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeBgpNetworksResponseBodyBgpNetworks struct {
	BgpNetwork []*DescribeBgpNetworksResponseBodyBgpNetworksBgpNetwork `json:"BgpNetwork,omitempty" xml:"BgpNetwork,omitempty" type:"Repeated"`
}

func (s DescribeBgpNetworksResponseBodyBgpNetworks) String() string {
	return tea.Prettify(s)
}

func (s DescribeBgpNetworksResponseBodyBgpNetworks) GoString() string {
	return s.String()
}

func (s *DescribeBgpNetworksResponseBodyBgpNetworks) SetBgpNetwork(v []*DescribeBgpNetworksResponseBodyBgpNetworksBgpNetwork) *DescribeBgpNetworksResponseBodyBgpNetworks {
	s.BgpNetwork = v
	return s
}

type DescribeBgpNetworksResponseBodyBgpNetworksBgpNetwork struct {
	// The CIDR block of the advertised BGP network.
	DstCidrBlock *string `json:"DstCidrBlock,omitempty" xml:"DstCidrBlock,omitempty"`
	// The ID of the VBR.
	RouterId *string `json:"RouterId,omitempty" xml:"RouterId,omitempty"`
	// The status of the advertised BGP network.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The ID of the virtual private cloud (VPC).
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s DescribeBgpNetworksResponseBodyBgpNetworksBgpNetwork) String() string {
	return tea.Prettify(s)
}

func (s DescribeBgpNetworksResponseBodyBgpNetworksBgpNetwork) GoString() string {
	return s.String()
}

func (s *DescribeBgpNetworksResponseBodyBgpNetworksBgpNetwork) SetDstCidrBlock(v string) *DescribeBgpNetworksResponseBodyBgpNetworksBgpNetwork {
	s.DstCidrBlock = &v
	return s
}

func (s *DescribeBgpNetworksResponseBodyBgpNetworksBgpNetwork) SetRouterId(v string) *DescribeBgpNetworksResponseBodyBgpNetworksBgpNetwork {
	s.RouterId = &v
	return s
}

func (s *DescribeBgpNetworksResponseBodyBgpNetworksBgpNetwork) SetStatus(v string) *DescribeBgpNetworksResponseBodyBgpNetworksBgpNetwork {
	s.Status = &v
	return s
}

func (s *DescribeBgpNetworksResponseBodyBgpNetworksBgpNetwork) SetVpcId(v string) *DescribeBgpNetworksResponseBodyBgpNetworksBgpNetwork {
	s.VpcId = &v
	return s
}

type DescribeBgpNetworksResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeBgpNetworksResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeBgpNetworksResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeBgpNetworksResponse) GoString() string {
	return s.String()
}

func (s *DescribeBgpNetworksResponse) SetHeaders(v map[string]*string) *DescribeBgpNetworksResponse {
	s.Headers = v
	return s
}

func (s *DescribeBgpNetworksResponse) SetStatusCode(v int32) *DescribeBgpNetworksResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeBgpNetworksResponse) SetBody(v *DescribeBgpNetworksResponseBody) *DescribeBgpNetworksResponse {
	s.Body = v
	return s
}

type DescribeBgpPeersRequest struct {
	// The ID of the BGP group to which the BGP peer that you want to query belongs.
	BgpGroupId *string `json:"BgpGroupId,omitempty" xml:"BgpGroupId,omitempty"`
	// The ID of the BGP peer that you want to query.
	BgpPeerId *string `json:"BgpPeerId,omitempty" xml:"BgpPeerId,omitempty"`
	// Specifies whether the BGP group is the default BGP group. Valid values:
	//
	// *   **true**: The BGP group is the default BGP group.
	// *   **false**: The BGP group is not the default BGP group.
	IsDefault    *bool   `json:"IsDefault,omitempty" xml:"IsDefault,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of the page to return. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Maximum value: **50**. Default value: **10**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The region ID of the BGP group to which the BGP peer that you want to query belongs.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the virtual border router (VBR) that is associated with the BGP peer that you want to query.
	RouterId *string `json:"RouterId,omitempty" xml:"RouterId,omitempty"`
}

func (s DescribeBgpPeersRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeBgpPeersRequest) GoString() string {
	return s.String()
}

func (s *DescribeBgpPeersRequest) SetBgpGroupId(v string) *DescribeBgpPeersRequest {
	s.BgpGroupId = &v
	return s
}

func (s *DescribeBgpPeersRequest) SetBgpPeerId(v string) *DescribeBgpPeersRequest {
	s.BgpPeerId = &v
	return s
}

func (s *DescribeBgpPeersRequest) SetIsDefault(v bool) *DescribeBgpPeersRequest {
	s.IsDefault = &v
	return s
}

func (s *DescribeBgpPeersRequest) SetOwnerAccount(v string) *DescribeBgpPeersRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeBgpPeersRequest) SetOwnerId(v int64) *DescribeBgpPeersRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeBgpPeersRequest) SetPageNumber(v int32) *DescribeBgpPeersRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeBgpPeersRequest) SetPageSize(v int32) *DescribeBgpPeersRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeBgpPeersRequest) SetRegionId(v string) *DescribeBgpPeersRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeBgpPeersRequest) SetResourceOwnerAccount(v string) *DescribeBgpPeersRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeBgpPeersRequest) SetResourceOwnerId(v int64) *DescribeBgpPeersRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeBgpPeersRequest) SetRouterId(v string) *DescribeBgpPeersRequest {
	s.RouterId = &v
	return s
}

type DescribeBgpPeersResponseBody struct {
	// The detailed information about the BGP peers.
	BgpPeers *DescribeBgpPeersResponseBodyBgpPeers `json:"BgpPeers,omitempty" xml:"BgpPeers,omitempty" type:"Struct"`
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeBgpPeersResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeBgpPeersResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeBgpPeersResponseBody) SetBgpPeers(v *DescribeBgpPeersResponseBodyBgpPeers) *DescribeBgpPeersResponseBody {
	s.BgpPeers = v
	return s
}

func (s *DescribeBgpPeersResponseBody) SetPageNumber(v int32) *DescribeBgpPeersResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeBgpPeersResponseBody) SetPageSize(v int32) *DescribeBgpPeersResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeBgpPeersResponseBody) SetRequestId(v string) *DescribeBgpPeersResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeBgpPeersResponseBody) SetTotalCount(v int32) *DescribeBgpPeersResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeBgpPeersResponseBodyBgpPeers struct {
	BgpPeer []*DescribeBgpPeersResponseBodyBgpPeersBgpPeer `json:"BgpPeer,omitempty" xml:"BgpPeer,omitempty" type:"Repeated"`
}

func (s DescribeBgpPeersResponseBodyBgpPeers) String() string {
	return tea.Prettify(s)
}

func (s DescribeBgpPeersResponseBodyBgpPeers) GoString() string {
	return s.String()
}

func (s *DescribeBgpPeersResponseBodyBgpPeers) SetBgpPeer(v []*DescribeBgpPeersResponseBodyBgpPeersBgpPeer) *DescribeBgpPeersResponseBodyBgpPeers {
	s.BgpPeer = v
	return s
}

type DescribeBgpPeersResponseBodyBgpPeersBgpPeer struct {
	// The number of advertised routes.
	AdvertisedRouteCount *int32 `json:"AdvertisedRouteCount,omitempty" xml:"AdvertisedRouteCount,omitempty"`
	// The authentication key of the BGP group.
	AuthKey *string `json:"AuthKey,omitempty" xml:"AuthKey,omitempty"`
	// The Bidirectional Forwarding Detection (BFD) hop count.
	BfdMultiHop *int32 `json:"BfdMultiHop,omitempty" xml:"BfdMultiHop,omitempty"`
	// The ID of the BGP group.
	BgpGroupId *string `json:"BgpGroupId,omitempty" xml:"BgpGroupId,omitempty"`
	// The ID of the BGP peer.
	BgpPeerId *string `json:"BgpPeerId,omitempty" xml:"BgpPeerId,omitempty"`
	// The status of the BGP connection. Valid values:
	//
	// *   **Idle**: not connected
	// *   **Connect**: in use
	// *   **Active**: available
	// *   **Established**: established
	// *   **Down**: unavailable
	BgpStatus *string `json:"BgpStatus,omitempty" xml:"BgpStatus,omitempty"`
	// The description of the BGP group.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// Indicates whether BFD is enabled. Valid values:
	//
	// *   **true**: enabled
	// *   **false**: disabled
	EnableBfd *bool `json:"EnableBfd,omitempty" xml:"EnableBfd,omitempty"`
	// The time when the BGP peer is modified.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The hold time.
	Hold *string `json:"Hold,omitempty" xml:"Hold,omitempty"`
	// The version of the IP address.
	IpVersion *string `json:"IpVersion,omitempty" xml:"IpVersion,omitempty"`
	// Indicates whether a fake ASN is used. Valid values:
	//
	// *   **true**: yes
	// *   **false**: no
	IsFake *bool `json:"IsFake,omitempty" xml:"IsFake,omitempty"`
	// The Keepalive interval.
	Keepalive *string `json:"Keepalive,omitempty" xml:"Keepalive,omitempty"`
	// The AS number of the device on the Alibaba Cloud side.
	LocalAsn *string `json:"LocalAsn,omitempty" xml:"LocalAsn,omitempty"`
	// The name of the BGP peer.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The autonomous system (AS) number of the BGP peer.
	PeerAsn *string `json:"PeerAsn,omitempty" xml:"PeerAsn,omitempty"`
	// The IP address of the BGP peer.
	PeerIpAddress *string `json:"PeerIpAddress,omitempty" xml:"PeerIpAddress,omitempty"`
	// The number of received routes.
	ReceivedRouteCount *int32 `json:"ReceivedRouteCount,omitempty" xml:"ReceivedRouteCount,omitempty"`
	// The ID of the region to which the BGP group belongs.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The limit on routes.
	RouteLimit *string `json:"RouteLimit,omitempty" xml:"RouteLimit,omitempty"`
	// The ID of the router.
	RouterId *string `json:"RouterId,omitempty" xml:"RouterId,omitempty"`
	// The status of the BGP peer. Valid values:
	//
	// *   **Pending**
	// *   **Available**
	// *   **Modifying**
	// *   **Deleting**
	// *   **Deleted**
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeBgpPeersResponseBodyBgpPeersBgpPeer) String() string {
	return tea.Prettify(s)
}

func (s DescribeBgpPeersResponseBodyBgpPeersBgpPeer) GoString() string {
	return s.String()
}

func (s *DescribeBgpPeersResponseBodyBgpPeersBgpPeer) SetAdvertisedRouteCount(v int32) *DescribeBgpPeersResponseBodyBgpPeersBgpPeer {
	s.AdvertisedRouteCount = &v
	return s
}

func (s *DescribeBgpPeersResponseBodyBgpPeersBgpPeer) SetAuthKey(v string) *DescribeBgpPeersResponseBodyBgpPeersBgpPeer {
	s.AuthKey = &v
	return s
}

func (s *DescribeBgpPeersResponseBodyBgpPeersBgpPeer) SetBfdMultiHop(v int32) *DescribeBgpPeersResponseBodyBgpPeersBgpPeer {
	s.BfdMultiHop = &v
	return s
}

func (s *DescribeBgpPeersResponseBodyBgpPeersBgpPeer) SetBgpGroupId(v string) *DescribeBgpPeersResponseBodyBgpPeersBgpPeer {
	s.BgpGroupId = &v
	return s
}

func (s *DescribeBgpPeersResponseBodyBgpPeersBgpPeer) SetBgpPeerId(v string) *DescribeBgpPeersResponseBodyBgpPeersBgpPeer {
	s.BgpPeerId = &v
	return s
}

func (s *DescribeBgpPeersResponseBodyBgpPeersBgpPeer) SetBgpStatus(v string) *DescribeBgpPeersResponseBodyBgpPeersBgpPeer {
	s.BgpStatus = &v
	return s
}

func (s *DescribeBgpPeersResponseBodyBgpPeersBgpPeer) SetDescription(v string) *DescribeBgpPeersResponseBodyBgpPeersBgpPeer {
	s.Description = &v
	return s
}

func (s *DescribeBgpPeersResponseBodyBgpPeersBgpPeer) SetEnableBfd(v bool) *DescribeBgpPeersResponseBodyBgpPeersBgpPeer {
	s.EnableBfd = &v
	return s
}

func (s *DescribeBgpPeersResponseBodyBgpPeersBgpPeer) SetGmtModified(v string) *DescribeBgpPeersResponseBodyBgpPeersBgpPeer {
	s.GmtModified = &v
	return s
}

func (s *DescribeBgpPeersResponseBodyBgpPeersBgpPeer) SetHold(v string) *DescribeBgpPeersResponseBodyBgpPeersBgpPeer {
	s.Hold = &v
	return s
}

func (s *DescribeBgpPeersResponseBodyBgpPeersBgpPeer) SetIpVersion(v string) *DescribeBgpPeersResponseBodyBgpPeersBgpPeer {
	s.IpVersion = &v
	return s
}

func (s *DescribeBgpPeersResponseBodyBgpPeersBgpPeer) SetIsFake(v bool) *DescribeBgpPeersResponseBodyBgpPeersBgpPeer {
	s.IsFake = &v
	return s
}

func (s *DescribeBgpPeersResponseBodyBgpPeersBgpPeer) SetKeepalive(v string) *DescribeBgpPeersResponseBodyBgpPeersBgpPeer {
	s.Keepalive = &v
	return s
}

func (s *DescribeBgpPeersResponseBodyBgpPeersBgpPeer) SetLocalAsn(v string) *DescribeBgpPeersResponseBodyBgpPeersBgpPeer {
	s.LocalAsn = &v
	return s
}

func (s *DescribeBgpPeersResponseBodyBgpPeersBgpPeer) SetName(v string) *DescribeBgpPeersResponseBodyBgpPeersBgpPeer {
	s.Name = &v
	return s
}

func (s *DescribeBgpPeersResponseBodyBgpPeersBgpPeer) SetPeerAsn(v string) *DescribeBgpPeersResponseBodyBgpPeersBgpPeer {
	s.PeerAsn = &v
	return s
}

func (s *DescribeBgpPeersResponseBodyBgpPeersBgpPeer) SetPeerIpAddress(v string) *DescribeBgpPeersResponseBodyBgpPeersBgpPeer {
	s.PeerIpAddress = &v
	return s
}

func (s *DescribeBgpPeersResponseBodyBgpPeersBgpPeer) SetReceivedRouteCount(v int32) *DescribeBgpPeersResponseBodyBgpPeersBgpPeer {
	s.ReceivedRouteCount = &v
	return s
}

func (s *DescribeBgpPeersResponseBodyBgpPeersBgpPeer) SetRegionId(v string) *DescribeBgpPeersResponseBodyBgpPeersBgpPeer {
	s.RegionId = &v
	return s
}

func (s *DescribeBgpPeersResponseBodyBgpPeersBgpPeer) SetRouteLimit(v string) *DescribeBgpPeersResponseBodyBgpPeersBgpPeer {
	s.RouteLimit = &v
	return s
}

func (s *DescribeBgpPeersResponseBodyBgpPeersBgpPeer) SetRouterId(v string) *DescribeBgpPeersResponseBodyBgpPeersBgpPeer {
	s.RouterId = &v
	return s
}

func (s *DescribeBgpPeersResponseBodyBgpPeersBgpPeer) SetStatus(v string) *DescribeBgpPeersResponseBodyBgpPeersBgpPeer {
	s.Status = &v
	return s
}

type DescribeBgpPeersResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeBgpPeersResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeBgpPeersResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeBgpPeersResponse) GoString() string {
	return s.String()
}

func (s *DescribeBgpPeersResponse) SetHeaders(v map[string]*string) *DescribeBgpPeersResponse {
	s.Headers = v
	return s
}

func (s *DescribeBgpPeersResponse) SetStatusCode(v int32) *DescribeBgpPeersResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeBgpPeersResponse) SetBody(v *DescribeBgpPeersResponseBody) *DescribeBgpPeersResponse {
	s.Body = v
	return s
}

type DescribeCommonBandwidthPackagesRequest struct {
	// The ID of the EIP bandwidth plan.
	BandwidthPackageId *string `json:"BandwidthPackageId,omitempty" xml:"BandwidthPackageId,omitempty"`
	// Specifies whether to perform a dry run. Valid values:
	//
	// *   **true**: performs a dry run. The system checks the required parameters, request syntax, and instance status. If the request fails the dry run, an error message is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
	// *   **false**: performs a dry run and sends the request. If the request passes the dry run, an HTTP 2xx status code is returned and the operation is performed. This is the default value.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// Specifies whether to return the information about pending orders. Valid values:
	//
	// *   **false**: does not return the information about pending orders. This is the default value.
	// *   **true**: returns the information about pending orders.
	IncludeReservationData *bool `json:"IncludeReservationData,omitempty" xml:"IncludeReservationData,omitempty"`
	// The name of the EIP bandwidth plan.
	Name         *string `json:"Name,omitempty" xml:"Name,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of the page to return. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Maximum value: **50**. Default value: **10**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The region ID of the EIP bandwidth plan.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to obtain the region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// Specifies whether to enable Anti-DDoS Pro/Premium. Valid values:
	//
	// *   **false**: disables Anti-DDoS Pro/Premium. This is the default value.
	// *   **true**: enables Anti-DDoS Pro/Premium.
	SecurityProtectionEnabled *bool                                        `json:"SecurityProtectionEnabled,omitempty" xml:"SecurityProtectionEnabled,omitempty"`
	Tag                       []*DescribeCommonBandwidthPackagesRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s DescribeCommonBandwidthPackagesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeCommonBandwidthPackagesRequest) GoString() string {
	return s.String()
}

func (s *DescribeCommonBandwidthPackagesRequest) SetBandwidthPackageId(v string) *DescribeCommonBandwidthPackagesRequest {
	s.BandwidthPackageId = &v
	return s
}

func (s *DescribeCommonBandwidthPackagesRequest) SetDryRun(v bool) *DescribeCommonBandwidthPackagesRequest {
	s.DryRun = &v
	return s
}

func (s *DescribeCommonBandwidthPackagesRequest) SetIncludeReservationData(v bool) *DescribeCommonBandwidthPackagesRequest {
	s.IncludeReservationData = &v
	return s
}

func (s *DescribeCommonBandwidthPackagesRequest) SetName(v string) *DescribeCommonBandwidthPackagesRequest {
	s.Name = &v
	return s
}

func (s *DescribeCommonBandwidthPackagesRequest) SetOwnerAccount(v string) *DescribeCommonBandwidthPackagesRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeCommonBandwidthPackagesRequest) SetOwnerId(v int64) *DescribeCommonBandwidthPackagesRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeCommonBandwidthPackagesRequest) SetPageNumber(v int32) *DescribeCommonBandwidthPackagesRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeCommonBandwidthPackagesRequest) SetPageSize(v int32) *DescribeCommonBandwidthPackagesRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeCommonBandwidthPackagesRequest) SetRegionId(v string) *DescribeCommonBandwidthPackagesRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeCommonBandwidthPackagesRequest) SetResourceGroupId(v string) *DescribeCommonBandwidthPackagesRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeCommonBandwidthPackagesRequest) SetResourceOwnerAccount(v string) *DescribeCommonBandwidthPackagesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeCommonBandwidthPackagesRequest) SetResourceOwnerId(v int64) *DescribeCommonBandwidthPackagesRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeCommonBandwidthPackagesRequest) SetSecurityProtectionEnabled(v bool) *DescribeCommonBandwidthPackagesRequest {
	s.SecurityProtectionEnabled = &v
	return s
}

func (s *DescribeCommonBandwidthPackagesRequest) SetTag(v []*DescribeCommonBandwidthPackagesRequestTag) *DescribeCommonBandwidthPackagesRequest {
	s.Tag = v
	return s
}

type DescribeCommonBandwidthPackagesRequestTag struct {
	Key   *string `json:"Key,omitempty" xml:"Key,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeCommonBandwidthPackagesRequestTag) String() string {
	return tea.Prettify(s)
}

func (s DescribeCommonBandwidthPackagesRequestTag) GoString() string {
	return s.String()
}

func (s *DescribeCommonBandwidthPackagesRequestTag) SetKey(v string) *DescribeCommonBandwidthPackagesRequestTag {
	s.Key = &v
	return s
}

func (s *DescribeCommonBandwidthPackagesRequestTag) SetValue(v string) *DescribeCommonBandwidthPackagesRequestTag {
	s.Value = &v
	return s
}

type DescribeCommonBandwidthPackagesResponseBody struct {
	// The details of the EIP bandwidth plan.
	CommonBandwidthPackages *DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackages `json:"CommonBandwidthPackages,omitempty" xml:"CommonBandwidthPackages,omitempty" type:"Struct"`
	// The number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeCommonBandwidthPackagesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeCommonBandwidthPackagesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeCommonBandwidthPackagesResponseBody) SetCommonBandwidthPackages(v *DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackages) *DescribeCommonBandwidthPackagesResponseBody {
	s.CommonBandwidthPackages = v
	return s
}

func (s *DescribeCommonBandwidthPackagesResponseBody) SetPageNumber(v int32) *DescribeCommonBandwidthPackagesResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeCommonBandwidthPackagesResponseBody) SetPageSize(v int32) *DescribeCommonBandwidthPackagesResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeCommonBandwidthPackagesResponseBody) SetRequestId(v string) *DescribeCommonBandwidthPackagesResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeCommonBandwidthPackagesResponseBody) SetTotalCount(v int32) *DescribeCommonBandwidthPackagesResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackages struct {
	CommonBandwidthPackage []*DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackage `json:"CommonBandwidthPackage,omitempty" xml:"CommonBandwidthPackage,omitempty" type:"Repeated"`
}

func (s DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackages) String() string {
	return tea.Prettify(s)
}

func (s DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackages) GoString() string {
	return s.String()
}

func (s *DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackages) SetCommonBandwidthPackage(v []*DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackage) *DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackages {
	s.CommonBandwidthPackage = v
	return s
}

type DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackage struct {
	// The maximum bandwidth of the EIP bandwidth plan. Unit: Mbit/s.
	Bandwidth *string `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	// The ID of the EIP bandwidth plan.
	BandwidthPackageId *string `json:"BandwidthPackageId,omitempty" xml:"BandwidthPackageId,omitempty"`
	// The service state of the EIP bandwidth plan.
	//
	// *   **Normal**: The EIP bandwidth plan works as expected.
	// *   **FinancialLocked**: The EIP bandwidth plan has an overdue payment.
	// *   **Unactivated**: The EIP bandwidth plan is not activated.
	BusinessStatus *string `json:"BusinessStatus,omitempty" xml:"BusinessStatus,omitempty"`
	// The time when the EIP bandwidth plan was created. The time is displayed in the `YYYY-MM-DDThh:mm:ssZ` format.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// Indicates whether deletion protection was enabled.
	//
	// *   **true**: Deletion protection was enabled.
	// *   **false**: Deletion protection was disabled.
	DeletionProtection *bool `json:"DeletionProtection,omitempty" xml:"DeletionProtection,omitempty"`
	// The description of the EIP bandwidth plan.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The time when the EIP bandwidth plan expired. The time is displayed in the `YYYY-MM-DDThh:mm:ssZ` format.
	ExpiredTime *string `json:"ExpiredTime,omitempty" xml:"ExpiredTime,omitempty"`
	// Indicates whether the information about pending orders was returned.
	//
	// *   **false**: The information about pending orders was not returned.
	// *   **true**: The information about pending orders was returned.
	HasReservationData *string `json:"HasReservationData,omitempty" xml:"HasReservationData,omitempty"`
	// The line type.
	//
	// *   **BGP**: BGP (Multi-ISP) lines. BGP (Multi-ISP) lines are available in all regions.
	// *   **BGP_PRO**: BGP (Multi-ISP) Pro lines. BGP (Multi-ISP) Pro lines are available only in the China (Hong Kong), Singapore, Philippines (Manila), Malaysia (Kuala Lumpur), Indonesia (Jakarta), and Thailand (Bangkok) regions.
	//
	// If you are allowed to use single-ISP bandwidth, one of the following values is returned:
	//
	// *   **ChinaTelecom**: China Telecom
	// *   **ChinaUnicom**: China Unicom
	// *   **ChinaMobile**: China Mobile
	// *   **ChinaTelecom_L2**: China Telecom L2
	// *   **ChinaUnicom_L2**: China Unicom L2
	// *   **ChinaMobile_L2**: China Mobile L2
	//
	// If your services are deployed in China East 1 Finance, **BGP_FinanceCloud** is returned.
	ISP *string `json:"ISP,omitempty" xml:"ISP,omitempty"`
	// The billing method of the EIP bandwidth plan.
	//
	// **PostPaid**: the pay-as-you-go billing method
	InstanceChargeType *string `json:"InstanceChargeType,omitempty" xml:"InstanceChargeType,omitempty"`
	// The metering method of the EIP bandwidth plan.
	//
	// **PayByTraffic**: the pay-by-data-transfer metering method.
	InternetChargeType *string `json:"InternetChargeType,omitempty" xml:"InternetChargeType,omitempty"`
	// The name of the EIP bandwidth plan.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The elastic IP addresses (EIPs) associated with the EIP bandwidth plan.
	PublicIpAddresses *DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackagePublicIpAddresses `json:"PublicIpAddresses,omitempty" xml:"PublicIpAddresses,omitempty" type:"Struct"`
	// The percentage of the minimum bandwidth commitment. **20** is returned.
	//
	// >  This parameter is available only on the Alibaba Cloud China site.
	Ratio *int32 `json:"Ratio,omitempty" xml:"Ratio,omitempty"`
	// The region ID of the EIP bandwidth plan.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The time when the renewal took effect. The time is displayed in the `YYYY-MM-DDThh:mm:ssZ` format.
	ReservationActiveTime *string `json:"ReservationActiveTime,omitempty" xml:"ReservationActiveTime,omitempty"`
	// The new maximum bandwidth. Unit: Mbit/s.
	ReservationBandwidth *string `json:"ReservationBandwidth,omitempty" xml:"ReservationBandwidth,omitempty"`
	// The new metering method.
	//
	// **PayByTraffic**: the pay-by-data-transfer metering method
	ReservationInternetChargeType *string `json:"ReservationInternetChargeType,omitempty" xml:"ReservationInternetChargeType,omitempty"`
	// The renewal method.
	//
	// *   **RENEWCHANGE**: renewal with an upgrade or a downgrade
	// *   **TEMP_UPGRADE**: temporary upgrade
	// *   **UPGRADE**: upgrade
	ReservationOrderType *string `json:"ReservationOrderType,omitempty" xml:"ReservationOrderType,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The edition of Anti-DDoS.
	//
	// - If this parameter is empty, it indicates that Anti-DDoS Origin Basic was enabled.
	// - If **AntiDDoS_Enhanced** is returned, it indicates that Anti-DDoS Pro/Premium was enabled.
	SecurityProtectionTypes *DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackageSecurityProtectionTypes `json:"SecurityProtectionTypes,omitempty" xml:"SecurityProtectionTypes,omitempty" type:"Struct"`
	// Indicates whether the EIP bandwidth plan was created by the service account.
	//
	// *   **0**: The EIP bandwidth plan was not created by the service account.
	// *   **1**: The EIP bandwidth plan was created by the service account.
	ServiceManaged *int32 `json:"ServiceManaged,omitempty" xml:"ServiceManaged,omitempty"`
	// The status of the EIP bandwidth plan. Valid values:
	//
	// *   **Available**: The EIP bandwidth plan is available.
	// *   **Modifying**: The EIP bandwidth plan is being modified.
	Status *string                                                                                       `json:"Status,omitempty" xml:"Status,omitempty"`
	Tags   *DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackageTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Struct"`
}

func (s DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackage) String() string {
	return tea.Prettify(s)
}

func (s DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackage) GoString() string {
	return s.String()
}

func (s *DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackage) SetBandwidth(v string) *DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackage {
	s.Bandwidth = &v
	return s
}

func (s *DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackage) SetBandwidthPackageId(v string) *DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackage {
	s.BandwidthPackageId = &v
	return s
}

func (s *DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackage) SetBusinessStatus(v string) *DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackage {
	s.BusinessStatus = &v
	return s
}

func (s *DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackage) SetCreationTime(v string) *DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackage {
	s.CreationTime = &v
	return s
}

func (s *DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackage) SetDeletionProtection(v bool) *DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackage {
	s.DeletionProtection = &v
	return s
}

func (s *DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackage) SetDescription(v string) *DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackage {
	s.Description = &v
	return s
}

func (s *DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackage) SetExpiredTime(v string) *DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackage {
	s.ExpiredTime = &v
	return s
}

func (s *DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackage) SetHasReservationData(v string) *DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackage {
	s.HasReservationData = &v
	return s
}

func (s *DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackage) SetISP(v string) *DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackage {
	s.ISP = &v
	return s
}

func (s *DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackage) SetInstanceChargeType(v string) *DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackage {
	s.InstanceChargeType = &v
	return s
}

func (s *DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackage) SetInternetChargeType(v string) *DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackage {
	s.InternetChargeType = &v
	return s
}

func (s *DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackage) SetName(v string) *DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackage {
	s.Name = &v
	return s
}

func (s *DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackage) SetPublicIpAddresses(v *DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackagePublicIpAddresses) *DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackage {
	s.PublicIpAddresses = v
	return s
}

func (s *DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackage) SetRatio(v int32) *DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackage {
	s.Ratio = &v
	return s
}

func (s *DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackage) SetRegionId(v string) *DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackage {
	s.RegionId = &v
	return s
}

func (s *DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackage) SetReservationActiveTime(v string) *DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackage {
	s.ReservationActiveTime = &v
	return s
}

func (s *DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackage) SetReservationBandwidth(v string) *DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackage {
	s.ReservationBandwidth = &v
	return s
}

func (s *DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackage) SetReservationInternetChargeType(v string) *DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackage {
	s.ReservationInternetChargeType = &v
	return s
}

func (s *DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackage) SetReservationOrderType(v string) *DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackage {
	s.ReservationOrderType = &v
	return s
}

func (s *DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackage) SetResourceGroupId(v string) *DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackage {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackage) SetSecurityProtectionTypes(v *DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackageSecurityProtectionTypes) *DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackage {
	s.SecurityProtectionTypes = v
	return s
}

func (s *DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackage) SetServiceManaged(v int32) *DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackage {
	s.ServiceManaged = &v
	return s
}

func (s *DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackage) SetStatus(v string) *DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackage {
	s.Status = &v
	return s
}

func (s *DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackage) SetTags(v *DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackageTags) *DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackage {
	s.Tags = v
	return s
}

type DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackagePublicIpAddresses struct {
	PublicIpAddresse []*DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackagePublicIpAddressesPublicIpAddresse `json:"PublicIpAddresse,omitempty" xml:"PublicIpAddresse,omitempty" type:"Repeated"`
}

func (s DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackagePublicIpAddresses) String() string {
	return tea.Prettify(s)
}

func (s DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackagePublicIpAddresses) GoString() string {
	return s.String()
}

func (s *DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackagePublicIpAddresses) SetPublicIpAddresse(v []*DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackagePublicIpAddressesPublicIpAddresse) *DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackagePublicIpAddresses {
	s.PublicIpAddresse = v
	return s
}

type DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackagePublicIpAddressesPublicIpAddresse struct {
	// The ID of the EIP.
	AllocationId *string `json:"AllocationId,omitempty" xml:"AllocationId,omitempty"`
	// Indicates whether the EIP is associated with the EIP bandwidth plan.
	//
	// *   **BINDED**: The EIP is associated with the EIP bandwidth plan.
	// *   **BINDING**: The EIP is being associated with the EIP bandwidth plan.
	BandwidthPackageIpRelationStatus *string `json:"BandwidthPackageIpRelationStatus,omitempty" xml:"BandwidthPackageIpRelationStatus,omitempty"`
	// The public IP address.
	IpAddress *string `json:"IpAddress,omitempty" xml:"IpAddress,omitempty"`
}

func (s DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackagePublicIpAddressesPublicIpAddresse) String() string {
	return tea.Prettify(s)
}

func (s DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackagePublicIpAddressesPublicIpAddresse) GoString() string {
	return s.String()
}

func (s *DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackagePublicIpAddressesPublicIpAddresse) SetAllocationId(v string) *DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackagePublicIpAddressesPublicIpAddresse {
	s.AllocationId = &v
	return s
}

func (s *DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackagePublicIpAddressesPublicIpAddresse) SetBandwidthPackageIpRelationStatus(v string) *DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackagePublicIpAddressesPublicIpAddresse {
	s.BandwidthPackageIpRelationStatus = &v
	return s
}

func (s *DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackagePublicIpAddressesPublicIpAddresse) SetIpAddress(v string) *DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackagePublicIpAddressesPublicIpAddresse {
	s.IpAddress = &v
	return s
}

type DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackageSecurityProtectionTypes struct {
	SecurityProtectionType []*string `json:"SecurityProtectionType,omitempty" xml:"SecurityProtectionType,omitempty" type:"Repeated"`
}

func (s DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackageSecurityProtectionTypes) String() string {
	return tea.Prettify(s)
}

func (s DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackageSecurityProtectionTypes) GoString() string {
	return s.String()
}

func (s *DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackageSecurityProtectionTypes) SetSecurityProtectionType(v []*string) *DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackageSecurityProtectionTypes {
	s.SecurityProtectionType = v
	return s
}

type DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackageTags struct {
	Tag []*DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackageTagsTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackageTags) String() string {
	return tea.Prettify(s)
}

func (s DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackageTags) GoString() string {
	return s.String()
}

func (s *DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackageTags) SetTag(v []*DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackageTagsTag) *DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackageTags {
	s.Tag = v
	return s
}

type DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackageTagsTag struct {
	Key   *string `json:"Key,omitempty" xml:"Key,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackageTagsTag) String() string {
	return tea.Prettify(s)
}

func (s DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackageTagsTag) GoString() string {
	return s.String()
}

func (s *DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackageTagsTag) SetKey(v string) *DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackageTagsTag {
	s.Key = &v
	return s
}

func (s *DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackageTagsTag) SetValue(v string) *DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackageTagsTag {
	s.Value = &v
	return s
}

type DescribeCommonBandwidthPackagesResponse struct {
	Headers    map[string]*string                           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeCommonBandwidthPackagesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeCommonBandwidthPackagesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeCommonBandwidthPackagesResponse) GoString() string {
	return s.String()
}

func (s *DescribeCommonBandwidthPackagesResponse) SetHeaders(v map[string]*string) *DescribeCommonBandwidthPackagesResponse {
	s.Headers = v
	return s
}

func (s *DescribeCommonBandwidthPackagesResponse) SetStatusCode(v int32) *DescribeCommonBandwidthPackagesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeCommonBandwidthPackagesResponse) SetBody(v *DescribeCommonBandwidthPackagesResponseBody) *DescribeCommonBandwidthPackagesResponse {
	s.Body = v
	return s
}

type DescribeCustomerGatewayRequest struct {
	// The ID of the customer gateway.
	CustomerGatewayId *string `json:"CustomerGatewayId,omitempty" xml:"CustomerGatewayId,omitempty"`
	OwnerAccount      *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId           *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region where the customer gateway is deployed.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeCustomerGatewayRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeCustomerGatewayRequest) GoString() string {
	return s.String()
}

func (s *DescribeCustomerGatewayRequest) SetCustomerGatewayId(v string) *DescribeCustomerGatewayRequest {
	s.CustomerGatewayId = &v
	return s
}

func (s *DescribeCustomerGatewayRequest) SetOwnerAccount(v string) *DescribeCustomerGatewayRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeCustomerGatewayRequest) SetOwnerId(v int64) *DescribeCustomerGatewayRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeCustomerGatewayRequest) SetRegionId(v string) *DescribeCustomerGatewayRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeCustomerGatewayRequest) SetResourceOwnerAccount(v string) *DescribeCustomerGatewayRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeCustomerGatewayRequest) SetResourceOwnerId(v int64) *DescribeCustomerGatewayRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeCustomerGatewayResponseBody struct {
	// The autonomous system number (ASN) of the gateway device in the data center.
	Asn *int64 `json:"Asn,omitempty" xml:"Asn,omitempty"`
	// The authentication key of the BGP routing protocol for the gateway device in the data center.
	AuthKey *string `json:"AuthKey,omitempty" xml:"AuthKey,omitempty"`
	// The timestamp generated when the customer gateway was created. Unit: milliseconds.
	//
	// This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The ID of the customer gateway.
	CustomerGatewayId *string `json:"CustomerGatewayId,omitempty" xml:"CustomerGatewayId,omitempty"`
	// The description of the customer gateway.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The public IP address of the gateway device in the data center.
	IpAddress *string `json:"IpAddress,omitempty" xml:"IpAddress,omitempty"`
	// The name of the customer gateway.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The list of tags added to the customer gateway.
	Tags *DescribeCustomerGatewayResponseBodyTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Struct"`
}

func (s DescribeCustomerGatewayResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeCustomerGatewayResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeCustomerGatewayResponseBody) SetAsn(v int64) *DescribeCustomerGatewayResponseBody {
	s.Asn = &v
	return s
}

func (s *DescribeCustomerGatewayResponseBody) SetAuthKey(v string) *DescribeCustomerGatewayResponseBody {
	s.AuthKey = &v
	return s
}

func (s *DescribeCustomerGatewayResponseBody) SetCreateTime(v int64) *DescribeCustomerGatewayResponseBody {
	s.CreateTime = &v
	return s
}

func (s *DescribeCustomerGatewayResponseBody) SetCustomerGatewayId(v string) *DescribeCustomerGatewayResponseBody {
	s.CustomerGatewayId = &v
	return s
}

func (s *DescribeCustomerGatewayResponseBody) SetDescription(v string) *DescribeCustomerGatewayResponseBody {
	s.Description = &v
	return s
}

func (s *DescribeCustomerGatewayResponseBody) SetIpAddress(v string) *DescribeCustomerGatewayResponseBody {
	s.IpAddress = &v
	return s
}

func (s *DescribeCustomerGatewayResponseBody) SetName(v string) *DescribeCustomerGatewayResponseBody {
	s.Name = &v
	return s
}

func (s *DescribeCustomerGatewayResponseBody) SetRequestId(v string) *DescribeCustomerGatewayResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeCustomerGatewayResponseBody) SetTags(v *DescribeCustomerGatewayResponseBodyTags) *DescribeCustomerGatewayResponseBody {
	s.Tags = v
	return s
}

type DescribeCustomerGatewayResponseBodyTags struct {
	Tag []*DescribeCustomerGatewayResponseBodyTagsTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s DescribeCustomerGatewayResponseBodyTags) String() string {
	return tea.Prettify(s)
}

func (s DescribeCustomerGatewayResponseBodyTags) GoString() string {
	return s.String()
}

func (s *DescribeCustomerGatewayResponseBodyTags) SetTag(v []*DescribeCustomerGatewayResponseBodyTagsTag) *DescribeCustomerGatewayResponseBodyTags {
	s.Tag = v
	return s
}

type DescribeCustomerGatewayResponseBodyTagsTag struct {
	// The tag key.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeCustomerGatewayResponseBodyTagsTag) String() string {
	return tea.Prettify(s)
}

func (s DescribeCustomerGatewayResponseBodyTagsTag) GoString() string {
	return s.String()
}

func (s *DescribeCustomerGatewayResponseBodyTagsTag) SetKey(v string) *DescribeCustomerGatewayResponseBodyTagsTag {
	s.Key = &v
	return s
}

func (s *DescribeCustomerGatewayResponseBodyTagsTag) SetValue(v string) *DescribeCustomerGatewayResponseBodyTagsTag {
	s.Value = &v
	return s
}

type DescribeCustomerGatewayResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeCustomerGatewayResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeCustomerGatewayResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeCustomerGatewayResponse) GoString() string {
	return s.String()
}

func (s *DescribeCustomerGatewayResponse) SetHeaders(v map[string]*string) *DescribeCustomerGatewayResponse {
	s.Headers = v
	return s
}

func (s *DescribeCustomerGatewayResponse) SetStatusCode(v int32) *DescribeCustomerGatewayResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeCustomerGatewayResponse) SetBody(v *DescribeCustomerGatewayResponseBody) *DescribeCustomerGatewayResponse {
	s.Body = v
	return s
}

type DescribeCustomerGatewaysRequest struct {
	// The ID of the customer gateway.
	//
	// > If you do not specify a customer gateway ID, the system queries all customer gateways in the current region by default.
	CustomerGatewayId *string `json:"CustomerGatewayId,omitempty" xml:"CustomerGatewayId,omitempty"`
	OwnerAccount      *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId           *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of the page to return. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Maximum value: **50**. Default value: **10**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the region where the customer gateway is deployed.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The tag value.
	//
	// The tag value can be an empty string and cannot exceed 128 characters in length. It cannot start with `aliyun` or `acs:`, and cannot contain `http://` or `https://`.
	//
	// Each tag key corresponds to one tag value. You can specify up to 20 tag values in each call.
	Tag []*DescribeCustomerGatewaysRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s DescribeCustomerGatewaysRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeCustomerGatewaysRequest) GoString() string {
	return s.String()
}

func (s *DescribeCustomerGatewaysRequest) SetCustomerGatewayId(v string) *DescribeCustomerGatewaysRequest {
	s.CustomerGatewayId = &v
	return s
}

func (s *DescribeCustomerGatewaysRequest) SetOwnerAccount(v string) *DescribeCustomerGatewaysRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeCustomerGatewaysRequest) SetOwnerId(v int64) *DescribeCustomerGatewaysRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeCustomerGatewaysRequest) SetPageNumber(v int32) *DescribeCustomerGatewaysRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeCustomerGatewaysRequest) SetPageSize(v int32) *DescribeCustomerGatewaysRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeCustomerGatewaysRequest) SetRegionId(v string) *DescribeCustomerGatewaysRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeCustomerGatewaysRequest) SetResourceOwnerAccount(v string) *DescribeCustomerGatewaysRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeCustomerGatewaysRequest) SetResourceOwnerId(v int64) *DescribeCustomerGatewaysRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeCustomerGatewaysRequest) SetTag(v []*DescribeCustomerGatewaysRequestTag) *DescribeCustomerGatewaysRequest {
	s.Tag = v
	return s
}

type DescribeCustomerGatewaysRequestTag struct {
	// The tag key. The tag key cannot be an empty string.
	//
	// It can be at most 64 characters in length, and cannot contain `http://` or `https://`. It cannot start with `aliyun` or `acs:`.
	//
	// You can specify at most 20 tag keys in each call.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value.
	//
	// The tag value can be an empty string and cannot exceed 128 characters in length. It cannot start with `aliyun` or `acs:`, and cannot contain `http://` or `https://`.
	//
	// Each tag key corresponds to one tag value. You can specify at most 20 tag values in each call.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeCustomerGatewaysRequestTag) String() string {
	return tea.Prettify(s)
}

func (s DescribeCustomerGatewaysRequestTag) GoString() string {
	return s.String()
}

func (s *DescribeCustomerGatewaysRequestTag) SetKey(v string) *DescribeCustomerGatewaysRequestTag {
	s.Key = &v
	return s
}

func (s *DescribeCustomerGatewaysRequestTag) SetValue(v string) *DescribeCustomerGatewaysRequestTag {
	s.Value = &v
	return s
}

type DescribeCustomerGatewaysResponseBody struct {
	// The tag value.
	CustomerGateways *DescribeCustomerGatewaysResponseBodyCustomerGateways `json:"CustomerGateways,omitempty" xml:"CustomerGateways,omitempty" type:"Struct"`
	// The page number.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The number of returned entries.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeCustomerGatewaysResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeCustomerGatewaysResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeCustomerGatewaysResponseBody) SetCustomerGateways(v *DescribeCustomerGatewaysResponseBodyCustomerGateways) *DescribeCustomerGatewaysResponseBody {
	s.CustomerGateways = v
	return s
}

func (s *DescribeCustomerGatewaysResponseBody) SetPageNumber(v int32) *DescribeCustomerGatewaysResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeCustomerGatewaysResponseBody) SetPageSize(v int32) *DescribeCustomerGatewaysResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeCustomerGatewaysResponseBody) SetRequestId(v string) *DescribeCustomerGatewaysResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeCustomerGatewaysResponseBody) SetTotalCount(v int32) *DescribeCustomerGatewaysResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeCustomerGatewaysResponseBodyCustomerGateways struct {
	CustomerGateway []*DescribeCustomerGatewaysResponseBodyCustomerGatewaysCustomerGateway `json:"CustomerGateway,omitempty" xml:"CustomerGateway,omitempty" type:"Repeated"`
}

func (s DescribeCustomerGatewaysResponseBodyCustomerGateways) String() string {
	return tea.Prettify(s)
}

func (s DescribeCustomerGatewaysResponseBodyCustomerGateways) GoString() string {
	return s.String()
}

func (s *DescribeCustomerGatewaysResponseBodyCustomerGateways) SetCustomerGateway(v []*DescribeCustomerGatewaysResponseBodyCustomerGatewaysCustomerGateway) *DescribeCustomerGatewaysResponseBodyCustomerGateways {
	s.CustomerGateway = v
	return s
}

type DescribeCustomerGatewaysResponseBodyCustomerGatewaysCustomerGateway struct {
	// The autonomous system number (ASN) of the gateway device in the data center.
	Asn *int64 `json:"Asn,omitempty" xml:"Asn,omitempty"`
	// The authentication key of the BGP routing protocol for the gateway device in the data center.
	AuthKey *string `json:"AuthKey,omitempty" xml:"AuthKey,omitempty"`
	// The timestamp generated when the customer gateway was created. Unit: milliseconds.
	//
	// This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The ID of the customer gateway.
	CustomerGatewayId *string `json:"CustomerGatewayId,omitempty" xml:"CustomerGatewayId,omitempty"`
	// The description of the customer gateway.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The public IP address of the gateway device in the data center.
	IpAddress *string `json:"IpAddress,omitempty" xml:"IpAddress,omitempty"`
	// The name of the customer gateway.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The list of tags added to the customer gateway.
	Tags *DescribeCustomerGatewaysResponseBodyCustomerGatewaysCustomerGatewayTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Struct"`
}

func (s DescribeCustomerGatewaysResponseBodyCustomerGatewaysCustomerGateway) String() string {
	return tea.Prettify(s)
}

func (s DescribeCustomerGatewaysResponseBodyCustomerGatewaysCustomerGateway) GoString() string {
	return s.String()
}

func (s *DescribeCustomerGatewaysResponseBodyCustomerGatewaysCustomerGateway) SetAsn(v int64) *DescribeCustomerGatewaysResponseBodyCustomerGatewaysCustomerGateway {
	s.Asn = &v
	return s
}

func (s *DescribeCustomerGatewaysResponseBodyCustomerGatewaysCustomerGateway) SetAuthKey(v string) *DescribeCustomerGatewaysResponseBodyCustomerGatewaysCustomerGateway {
	s.AuthKey = &v
	return s
}

func (s *DescribeCustomerGatewaysResponseBodyCustomerGatewaysCustomerGateway) SetCreateTime(v int64) *DescribeCustomerGatewaysResponseBodyCustomerGatewaysCustomerGateway {
	s.CreateTime = &v
	return s
}

func (s *DescribeCustomerGatewaysResponseBodyCustomerGatewaysCustomerGateway) SetCustomerGatewayId(v string) *DescribeCustomerGatewaysResponseBodyCustomerGatewaysCustomerGateway {
	s.CustomerGatewayId = &v
	return s
}

func (s *DescribeCustomerGatewaysResponseBodyCustomerGatewaysCustomerGateway) SetDescription(v string) *DescribeCustomerGatewaysResponseBodyCustomerGatewaysCustomerGateway {
	s.Description = &v
	return s
}

func (s *DescribeCustomerGatewaysResponseBodyCustomerGatewaysCustomerGateway) SetIpAddress(v string) *DescribeCustomerGatewaysResponseBodyCustomerGatewaysCustomerGateway {
	s.IpAddress = &v
	return s
}

func (s *DescribeCustomerGatewaysResponseBodyCustomerGatewaysCustomerGateway) SetName(v string) *DescribeCustomerGatewaysResponseBodyCustomerGatewaysCustomerGateway {
	s.Name = &v
	return s
}

func (s *DescribeCustomerGatewaysResponseBodyCustomerGatewaysCustomerGateway) SetTags(v *DescribeCustomerGatewaysResponseBodyCustomerGatewaysCustomerGatewayTags) *DescribeCustomerGatewaysResponseBodyCustomerGatewaysCustomerGateway {
	s.Tags = v
	return s
}

type DescribeCustomerGatewaysResponseBodyCustomerGatewaysCustomerGatewayTags struct {
	Tag []*DescribeCustomerGatewaysResponseBodyCustomerGatewaysCustomerGatewayTagsTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s DescribeCustomerGatewaysResponseBodyCustomerGatewaysCustomerGatewayTags) String() string {
	return tea.Prettify(s)
}

func (s DescribeCustomerGatewaysResponseBodyCustomerGatewaysCustomerGatewayTags) GoString() string {
	return s.String()
}

func (s *DescribeCustomerGatewaysResponseBodyCustomerGatewaysCustomerGatewayTags) SetTag(v []*DescribeCustomerGatewaysResponseBodyCustomerGatewaysCustomerGatewayTagsTag) *DescribeCustomerGatewaysResponseBodyCustomerGatewaysCustomerGatewayTags {
	s.Tag = v
	return s
}

type DescribeCustomerGatewaysResponseBodyCustomerGatewaysCustomerGatewayTagsTag struct {
	// The tag key.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeCustomerGatewaysResponseBodyCustomerGatewaysCustomerGatewayTagsTag) String() string {
	return tea.Prettify(s)
}

func (s DescribeCustomerGatewaysResponseBodyCustomerGatewaysCustomerGatewayTagsTag) GoString() string {
	return s.String()
}

func (s *DescribeCustomerGatewaysResponseBodyCustomerGatewaysCustomerGatewayTagsTag) SetKey(v string) *DescribeCustomerGatewaysResponseBodyCustomerGatewaysCustomerGatewayTagsTag {
	s.Key = &v
	return s
}

func (s *DescribeCustomerGatewaysResponseBodyCustomerGatewaysCustomerGatewayTagsTag) SetValue(v string) *DescribeCustomerGatewaysResponseBodyCustomerGatewaysCustomerGatewayTagsTag {
	s.Value = &v
	return s
}

type DescribeCustomerGatewaysResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeCustomerGatewaysResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeCustomerGatewaysResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeCustomerGatewaysResponse) GoString() string {
	return s.String()
}

func (s *DescribeCustomerGatewaysResponse) SetHeaders(v map[string]*string) *DescribeCustomerGatewaysResponse {
	s.Headers = v
	return s
}

func (s *DescribeCustomerGatewaysResponse) SetStatusCode(v int32) *DescribeCustomerGatewaysResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeCustomerGatewaysResponse) SetBody(v *DescribeCustomerGatewaysResponseBody) *DescribeCustomerGatewaysResponse {
	s.Body = v
	return s
}

type DescribeEcGrantRelationRequest struct {
	// The ID of the instance.
	//
	// *   If you set **InstanceType** to **VBR**, specify a VBR ID.
	// *   If you set **InstanceType** to **VPC**, specify a VPC ID.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The type of instance. Valid values:
	//
	// *   **VBR**: queries the permissions that are granted to a VBR.
	// *   **VPC**: queries the permissions that are granted from a VPC.
	InstanceType *string `json:"InstanceType,omitempty" xml:"InstanceType,omitempty"`
	// The number of the page to return. Default value: **1**.
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Maximum value: **50**. Default value: **10**.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the region where the instance is deployed.
	//
	// *   If **InstanceType** is set to **VBR**, this parameter is required.
	// *   If **InstanceType** is set to **VPC**, you can ignore this parameter.
	VbrRegionNo *string `json:"VbrRegionNo,omitempty" xml:"VbrRegionNo,omitempty"`
}

func (s DescribeEcGrantRelationRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeEcGrantRelationRequest) GoString() string {
	return s.String()
}

func (s *DescribeEcGrantRelationRequest) SetInstanceId(v string) *DescribeEcGrantRelationRequest {
	s.InstanceId = &v
	return s
}

func (s *DescribeEcGrantRelationRequest) SetInstanceType(v string) *DescribeEcGrantRelationRequest {
	s.InstanceType = &v
	return s
}

func (s *DescribeEcGrantRelationRequest) SetPageNumber(v int64) *DescribeEcGrantRelationRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeEcGrantRelationRequest) SetPageSize(v int64) *DescribeEcGrantRelationRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeEcGrantRelationRequest) SetVbrRegionNo(v string) *DescribeEcGrantRelationRequest {
	s.VbrRegionNo = &v
	return s
}

type DescribeEcGrantRelationResponseBody struct {
	// The total number of entries returned.
	Count *int32 `json:"Count,omitempty" xml:"Count,omitempty"`
	// The query results.
	EcGrantRelations []*DescribeEcGrantRelationResponseBodyEcGrantRelations `json:"EcGrantRelations,omitempty" xml:"EcGrantRelations,omitempty" type:"Repeated"`
	// The number of the returned page.
	Page *int32 `json:"Page,omitempty" xml:"Page,omitempty"`
	// The number of entries returned on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeEcGrantRelationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeEcGrantRelationResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeEcGrantRelationResponseBody) SetCount(v int32) *DescribeEcGrantRelationResponseBody {
	s.Count = &v
	return s
}

func (s *DescribeEcGrantRelationResponseBody) SetEcGrantRelations(v []*DescribeEcGrantRelationResponseBodyEcGrantRelations) *DescribeEcGrantRelationResponseBody {
	s.EcGrantRelations = v
	return s
}

func (s *DescribeEcGrantRelationResponseBody) SetPage(v int32) *DescribeEcGrantRelationResponseBody {
	s.Page = &v
	return s
}

func (s *DescribeEcGrantRelationResponseBody) SetPageSize(v int32) *DescribeEcGrantRelationResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeEcGrantRelationResponseBody) SetRequestId(v string) *DescribeEcGrantRelationResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeEcGrantRelationResponseBody) SetTotalCount(v int32) *DescribeEcGrantRelationResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeEcGrantRelationResponseBodyEcGrantRelations struct {
	// The ID of the Alibaba Cloud account to which the VPC belongs.
	AliUid *int64 `json:"AliUid,omitempty" xml:"AliUid,omitempty"`
	// The time when permissions on the VPC were granted to the VBR.
	GmtCreate *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The VBRs that have permissions on the VPC. Valid values:
	//
	// *   **All**: VBRs that reside in the specified region and belong to the specified Alibaba Cloud account all have permissions on the VPC.
	// *   **Specify**: Only the specified VBR has permissions on the VPC.
	GrantType *string `json:"GrantType,omitempty" xml:"GrantType,omitempty"`
	// The ID of the VPC.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The name of the VPC.
	InstanceName *string `json:"InstanceName,omitempty" xml:"InstanceName,omitempty"`
	// The ID of the vRouter.
	InstanceRouterId *string `json:"InstanceRouterId,omitempty" xml:"InstanceRouterId,omitempty"`
	// The ID of the region where the VPC is deployed.
	RegionNo *string `json:"RegionNo,omitempty" xml:"RegionNo,omitempty"`
	// The query result. Valid values:
	//
	// *   **Created**: The VBR has permissions on the VPC.
	// *   **Deleted**: The VBR does not have permissions on the VPC.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The ID of the VBR.
	VbrInstanceId *string `json:"VbrInstanceId,omitempty" xml:"VbrInstanceId,omitempty"`
	// The ID of the Alibaba Cloud account to which the VBR belongs.
	VbrOwnerUid *int64 `json:"VbrOwnerUid,omitempty" xml:"VbrOwnerUid,omitempty"`
	// The ID of the region where the VBR is deployed.
	VbrRegionNo *string `json:"VbrRegionNo,omitempty" xml:"VbrRegionNo,omitempty"`
}

func (s DescribeEcGrantRelationResponseBodyEcGrantRelations) String() string {
	return tea.Prettify(s)
}

func (s DescribeEcGrantRelationResponseBodyEcGrantRelations) GoString() string {
	return s.String()
}

func (s *DescribeEcGrantRelationResponseBodyEcGrantRelations) SetAliUid(v int64) *DescribeEcGrantRelationResponseBodyEcGrantRelations {
	s.AliUid = &v
	return s
}

func (s *DescribeEcGrantRelationResponseBodyEcGrantRelations) SetGmtCreate(v string) *DescribeEcGrantRelationResponseBodyEcGrantRelations {
	s.GmtCreate = &v
	return s
}

func (s *DescribeEcGrantRelationResponseBodyEcGrantRelations) SetGrantType(v string) *DescribeEcGrantRelationResponseBodyEcGrantRelations {
	s.GrantType = &v
	return s
}

func (s *DescribeEcGrantRelationResponseBodyEcGrantRelations) SetInstanceId(v string) *DescribeEcGrantRelationResponseBodyEcGrantRelations {
	s.InstanceId = &v
	return s
}

func (s *DescribeEcGrantRelationResponseBodyEcGrantRelations) SetInstanceName(v string) *DescribeEcGrantRelationResponseBodyEcGrantRelations {
	s.InstanceName = &v
	return s
}

func (s *DescribeEcGrantRelationResponseBodyEcGrantRelations) SetInstanceRouterId(v string) *DescribeEcGrantRelationResponseBodyEcGrantRelations {
	s.InstanceRouterId = &v
	return s
}

func (s *DescribeEcGrantRelationResponseBodyEcGrantRelations) SetRegionNo(v string) *DescribeEcGrantRelationResponseBodyEcGrantRelations {
	s.RegionNo = &v
	return s
}

func (s *DescribeEcGrantRelationResponseBodyEcGrantRelations) SetStatus(v string) *DescribeEcGrantRelationResponseBodyEcGrantRelations {
	s.Status = &v
	return s
}

func (s *DescribeEcGrantRelationResponseBodyEcGrantRelations) SetVbrInstanceId(v string) *DescribeEcGrantRelationResponseBodyEcGrantRelations {
	s.VbrInstanceId = &v
	return s
}

func (s *DescribeEcGrantRelationResponseBodyEcGrantRelations) SetVbrOwnerUid(v int64) *DescribeEcGrantRelationResponseBodyEcGrantRelations {
	s.VbrOwnerUid = &v
	return s
}

func (s *DescribeEcGrantRelationResponseBodyEcGrantRelations) SetVbrRegionNo(v string) *DescribeEcGrantRelationResponseBodyEcGrantRelations {
	s.VbrRegionNo = &v
	return s
}

type DescribeEcGrantRelationResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeEcGrantRelationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeEcGrantRelationResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeEcGrantRelationResponse) GoString() string {
	return s.String()
}

func (s *DescribeEcGrantRelationResponse) SetHeaders(v map[string]*string) *DescribeEcGrantRelationResponse {
	s.Headers = v
	return s
}

func (s *DescribeEcGrantRelationResponse) SetStatusCode(v int32) *DescribeEcGrantRelationResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeEcGrantRelationResponse) SetBody(v *DescribeEcGrantRelationResponseBody) *DescribeEcGrantRelationResponse {
	s.Body = v
	return s
}

type DescribeEipAddressesRequest struct {
	Filter []*DescribeEipAddressesRequestFilter `json:"Filter,omitempty" xml:"Filter,omitempty" type:"Repeated"`
	// The ID of the EIP that you want to query.
	//
	// You can enter up to 50 IDs of EIPs. Separate multiple IDs with commas (,).
	//
	// >  If both the **EipAddress** and **AllocationId** parameters are set, you can enter up to 50 IDs of EIPs in **AllocationId**, and enter up to 50 IP addresses of EIPs in **EipAddress**.
	AllocationId *string `json:"AllocationId,omitempty" xml:"AllocationId,omitempty"`
	// The ID of the cloud resource.
	AssociatedInstanceId *string `json:"AssociatedInstanceId,omitempty" xml:"AssociatedInstanceId,omitempty"`
	// The type of the cloud resource with which you want to associate the EIP. Valid values:
	//
	// *   **EcsInstance** (default): an Elastic Compute Service (ECS) instance in a virtual private cloud (VPC)
	// *   **SlbInstance**: a Server Load Balancer (SLB) instance in a VPC
	// *   **Nat**: a NAT gateway
	// *   **HaVip**: a high-availability virtual IP address (HAVIP)
	// *   **NetworkInterface**: a secondary ENI
	// *   **IpAddress**: an IP address
	//
	// >  You can associate only one EIP with each ECS instance, SLB instance, HAVIP, or IP address. You can associate multiple EIPs with each NAT gateway. The number of EIPs that you can associate with a secondary ENI depends on the association mode. For more information, see [EIP overview](~~72125~~).
	AssociatedInstanceType *string `json:"AssociatedInstanceType,omitempty" xml:"AssociatedInstanceType,omitempty"`
	// The billing method of the EIP. Valid values:
	//
	// *   **PostPaid**: pay-as-you-go
	// *   **PrePaid**: subscription
	ChargeType *string `json:"ChargeType,omitempty" xml:"ChargeType,omitempty"`
	// Specifies whether to perform a dry run. Valid values:
	//
	// *   **true**: performs a dry run. The system checks the required parameters, request syntax, and limits. If the request fails the dry run, an error message is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
	// *   **false** (default): performs a dry run and sends the request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The IP address of the EIP that you want to query.
	//
	// You can enter up to 50 IP addresses of EIPs. Separate multiple IP addresses with commas (,).
	//
	// >  If both the **EipAddress** and **AllocationId** parameters are set, you can enter up to 50 IP addresses of EIPs in **EipAddress**, and enter up to 50 IDs of EIPs in **AllocationId**.
	EipAddress *string `json:"EipAddress,omitempty" xml:"EipAddress,omitempty"`
	// The name of the EIP.
	//
	// The name must be 1 to 128 characters in length, and can contain letters, digits, underscores (\_), and hyphens (-). The name must start with a letter.
	EipName *string `json:"EipName,omitempty" xml:"EipName,omitempty"`
	// The line type. Valid values:
	//
	// *   **BGP** (default): BGP (Multi-ISP) lines. All regions support BGP (Multi-ISP) EIPs.
	// *   **BGP_PRO**: BGP (Multi-ISP) Pro lines. Only the following regions support BGP (Multi-ISP) Pro lines: China (Hong Kong), Singapore, Malaysia (Kuala Lumpur), Philippines (Manila), Indonesia (Jakarta), and Thailand (Bangkok).
	//
	// For more information about BGP (Multi-ISP) and BGP (Multi-ISP) Pro, see [EIP line types](~~32321~~).
	//
	// If you are allowed to use single-ISP bandwidth, you can also choose one of the following values:
	//
	// *   **ChinaTelecom**: China Telecom
	// *   **ChinaUnicom**: China Unicom
	// *   **ChinaMobile**: China Mobile
	// *   **ChinaTelecom_L2**: China Telecom L2
	// *   **ChinaUnicom_L2**: China Unicom L2
	// *   **ChinaMobile_L2**: China Mobile L2
	//
	// If your services are deployed in China East 1 Finance, you must set this parameter to **BGP_FinanceCloud**.
	ISP *string `json:"ISP,omitempty" xml:"ISP,omitempty"`
	// Specifies whether to return information about pending orders. Valid values:
	//
	// *   **false** (default): does not return information about pending orders.
	// *   **true**: returns information about pending orders.
	IncludeReservationData *bool `json:"IncludeReservationData,omitempty" xml:"IncludeReservationData,omitempty"`
	// The reason why the EIP is locked. Valid values:
	//
	// *   **financial**: The EIP is locked due to overdue payments.
	// *   **security**: The EIP is locked for security reasons.
	LockReason   *string `json:"LockReason,omitempty" xml:"LockReason,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of the page to return. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Maximum value: **100**. Default value: **10**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The IP address pool to which the EIP that you want to query belongs.
	PublicIpAddressPoolId *string `json:"PublicIpAddressPoolId,omitempty" xml:"PublicIpAddressPoolId,omitempty"`
	// The region ID of the EIP.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group to which the EIPs belong.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// Specifies whether to enable Anti-DDoS Pro/Premium. Valid values:
	//
	// *   **false** (default): no
	// *   **true**: yes
	SecurityProtectionEnabled *bool `json:"SecurityProtectionEnabled,omitempty" xml:"SecurityProtectionEnabled,omitempty"`
	// The IDs of the contiguous EIPs.
	SegmentInstanceId *string `json:"SegmentInstanceId,omitempty" xml:"SegmentInstanceId,omitempty"`
	// The status of the EIP. Valid values:
	//
	// *   **Associating**: being associated
	// *   **Unassociating**: being disassociated
	// *   **InUse**: allocated
	// *   **Available**: available
	// *   **Releasing**: being released
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeEipAddressesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeEipAddressesRequest) GoString() string {
	return s.String()
}

func (s *DescribeEipAddressesRequest) SetFilter(v []*DescribeEipAddressesRequestFilter) *DescribeEipAddressesRequest {
	s.Filter = v
	return s
}

func (s *DescribeEipAddressesRequest) SetAllocationId(v string) *DescribeEipAddressesRequest {
	s.AllocationId = &v
	return s
}

func (s *DescribeEipAddressesRequest) SetAssociatedInstanceId(v string) *DescribeEipAddressesRequest {
	s.AssociatedInstanceId = &v
	return s
}

func (s *DescribeEipAddressesRequest) SetAssociatedInstanceType(v string) *DescribeEipAddressesRequest {
	s.AssociatedInstanceType = &v
	return s
}

func (s *DescribeEipAddressesRequest) SetChargeType(v string) *DescribeEipAddressesRequest {
	s.ChargeType = &v
	return s
}

func (s *DescribeEipAddressesRequest) SetDryRun(v bool) *DescribeEipAddressesRequest {
	s.DryRun = &v
	return s
}

func (s *DescribeEipAddressesRequest) SetEipAddress(v string) *DescribeEipAddressesRequest {
	s.EipAddress = &v
	return s
}

func (s *DescribeEipAddressesRequest) SetEipName(v string) *DescribeEipAddressesRequest {
	s.EipName = &v
	return s
}

func (s *DescribeEipAddressesRequest) SetISP(v string) *DescribeEipAddressesRequest {
	s.ISP = &v
	return s
}

func (s *DescribeEipAddressesRequest) SetIncludeReservationData(v bool) *DescribeEipAddressesRequest {
	s.IncludeReservationData = &v
	return s
}

func (s *DescribeEipAddressesRequest) SetLockReason(v string) *DescribeEipAddressesRequest {
	s.LockReason = &v
	return s
}

func (s *DescribeEipAddressesRequest) SetOwnerAccount(v string) *DescribeEipAddressesRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeEipAddressesRequest) SetOwnerId(v int64) *DescribeEipAddressesRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeEipAddressesRequest) SetPageNumber(v int32) *DescribeEipAddressesRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeEipAddressesRequest) SetPageSize(v int32) *DescribeEipAddressesRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeEipAddressesRequest) SetPublicIpAddressPoolId(v string) *DescribeEipAddressesRequest {
	s.PublicIpAddressPoolId = &v
	return s
}

func (s *DescribeEipAddressesRequest) SetRegionId(v string) *DescribeEipAddressesRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeEipAddressesRequest) SetResourceGroupId(v string) *DescribeEipAddressesRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeEipAddressesRequest) SetResourceOwnerAccount(v string) *DescribeEipAddressesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeEipAddressesRequest) SetResourceOwnerId(v int64) *DescribeEipAddressesRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeEipAddressesRequest) SetSecurityProtectionEnabled(v bool) *DescribeEipAddressesRequest {
	s.SecurityProtectionEnabled = &v
	return s
}

func (s *DescribeEipAddressesRequest) SetSegmentInstanceId(v string) *DescribeEipAddressesRequest {
	s.SegmentInstanceId = &v
	return s
}

func (s *DescribeEipAddressesRequest) SetStatus(v string) *DescribeEipAddressesRequest {
	s.Status = &v
	return s
}

type DescribeEipAddressesRequestFilter struct {
	// The filter key used to query resources. Set the value to **CreationStartTime**, which indicates the time when the system started to create the resource.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The filter value used to query resources. Specify the time in the ISO 8601 standard in `YYYY-MM-DDThh:mmZ` format. The time must be in UTC.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeEipAddressesRequestFilter) String() string {
	return tea.Prettify(s)
}

func (s DescribeEipAddressesRequestFilter) GoString() string {
	return s.String()
}

func (s *DescribeEipAddressesRequestFilter) SetKey(v string) *DescribeEipAddressesRequestFilter {
	s.Key = &v
	return s
}

func (s *DescribeEipAddressesRequestFilter) SetValue(v string) *DescribeEipAddressesRequestFilter {
	s.Value = &v
	return s
}

type DescribeEipAddressesResponseBody struct {
	// The details about the EIP.
	EipAddresses *DescribeEipAddressesResponseBodyEipAddresses `json:"EipAddresses,omitempty" xml:"EipAddresses,omitempty" type:"Struct"`
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeEipAddressesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeEipAddressesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeEipAddressesResponseBody) SetEipAddresses(v *DescribeEipAddressesResponseBodyEipAddresses) *DescribeEipAddressesResponseBody {
	s.EipAddresses = v
	return s
}

func (s *DescribeEipAddressesResponseBody) SetPageNumber(v int32) *DescribeEipAddressesResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeEipAddressesResponseBody) SetPageSize(v int32) *DescribeEipAddressesResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeEipAddressesResponseBody) SetRequestId(v string) *DescribeEipAddressesResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeEipAddressesResponseBody) SetTotalCount(v int32) *DescribeEipAddressesResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeEipAddressesResponseBodyEipAddresses struct {
	EipAddress []*DescribeEipAddressesResponseBodyEipAddressesEipAddress `json:"EipAddress,omitempty" xml:"EipAddress,omitempty" type:"Repeated"`
}

func (s DescribeEipAddressesResponseBodyEipAddresses) String() string {
	return tea.Prettify(s)
}

func (s DescribeEipAddressesResponseBodyEipAddresses) GoString() string {
	return s.String()
}

func (s *DescribeEipAddressesResponseBodyEipAddresses) SetEipAddress(v []*DescribeEipAddressesResponseBodyEipAddressesEipAddress) *DescribeEipAddressesResponseBodyEipAddresses {
	s.EipAddress = v
	return s
}

type DescribeEipAddressesResponseBodyEipAddressesEipAddress struct {
	// The ID of the EIP.
	AllocationId *string `json:"AllocationId,omitempty" xml:"AllocationId,omitempty"`
	// The time when the EIP was created. The time is displayed in `YYYY-MM-DDThh:mm:ssZ` format.
	AllocationTime *string `json:"AllocationTime,omitempty" xml:"AllocationTime,omitempty"`
	// The maximum bandwidth of the EIP. Unit: Mbit/s.
	Bandwidth *string `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	// The maximum bandwidth of the EIP bandwidth plan with which the EIP is associated. Unit: Mbit/s.
	BandwidthPackageBandwidth *string `json:"BandwidthPackageBandwidth,omitempty" xml:"BandwidthPackageBandwidth,omitempty"`
	// The ID of the EIP bandwidth plan.
	BandwidthPackageId *string `json:"BandwidthPackageId,omitempty" xml:"BandwidthPackageId,omitempty"`
	// The type of the bandwidth. Only **CommonBandwidthPackage** (EIP Bandwidth Plan) is returned.
	BandwidthPackageType *string `json:"BandwidthPackageType,omitempty" xml:"BandwidthPackageType,omitempty"`
	// The service status of the EIP. Valid values:
	//
	// *   **Normal**: active
	// *   **FinancialLocked**: locked
	BusinessStatus *string `json:"BusinessStatus,omitempty" xml:"BusinessStatus,omitempty"`
	// The billing method of the EIP. Valid values:
	//
	// *   **PostPaid**: pay-as-you-go
	// *   **PrePaid**: subscription
	ChargeType *string `json:"ChargeType,omitempty" xml:"ChargeType,omitempty"`
	// Indicates whether deletion protection is enabled. Valid values:
	//
	// *   **true**: enabled
	// *   **false**: disabled
	DeletionProtection *bool `json:"DeletionProtection,omitempty" xml:"DeletionProtection,omitempty"`
	// The description of the EIP.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The maximum bandwidth of the EIP when it is not associated with an EIP bandwidth plan. Unit: Mbit/s.
	EipBandwidth *string `json:"EipBandwidth,omitempty" xml:"EipBandwidth,omitempty"`
	// The time when the EIP expires. The time is displayed in `YYYY-MM-DDThh:mm:ssZ` format.
	ExpiredTime *string `json:"ExpiredTime,omitempty" xml:"ExpiredTime,omitempty"`
	// Indicates whether fine-grained monitoring is enabled for the EIP. Valid values:
	//
	// *   **false**: no
	// *   **true**: yes
	HDMonitorStatus *string `json:"HDMonitorStatus,omitempty" xml:"HDMonitorStatus,omitempty"`
	// Indicates whether renewal data is included.
	//
	// *   **false**: no
	// *   **true**: yes This parameter returns **true** only when the **IncludeReservationData** parameter is set to **true** and some orders have not taken effect.
	HasReservationData *string `json:"HasReservationData,omitempty" xml:"HasReservationData,omitempty"`
	// The line type.
	//
	// *   **BGP**: BGP (Multi-ISP). All regions support BGP (Multi-ISP) EIPs.
	// *   **BGP_PRO**: BGP (Multi-ISP) Pro lines. Only the following regions support BGP (Multi-ISP) Pro lines: China (Hong Kong), Singapore, Malaysia (Kuala Lumpur), Philippines (Manila), Indonesia (Jakarta), and Thailand (Bangkok).
	//
	// For more information about BGP (Multi-ISP) and BGP (Multi-ISP) Pro, see [EIP line types](~~32321~~).
	//
	// If you are allowed to use single-ISP bandwidth, one of the following values is returned:
	//
	// *   **ChinaTelecom**: China Telecom
	// *   **ChinaUnicom**: China Unicom
	// *   **ChinaMobile**: China Mobile
	// *   **ChinaTelecom_L2**: China Telecom L2
	// *   **ChinaUnicom_L2**: China Unicom L2
	// *   **ChinaMobile_L2**: China Mobile L2
	//
	// If your services are deployed in China East 1 Finance, **BGP_FinanceCloud** is returned.
	ISP *string `json:"ISP,omitempty" xml:"ISP,omitempty"`
	// The ID of the associated instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The region ID of the associated instance.
	InstanceRegionId *string `json:"InstanceRegionId,omitempty" xml:"InstanceRegionId,omitempty"`
	// The type of the associated instance. Valid values:
	//
	// *   **EcsInstance**: an ECS instance in a VPC
	// *   **SlbInstance**: an SLB instance in a VPC
	// *   **Nat**: a NAT gateway
	// *   **HaVip**: an HAVIP
	// *   **NetworkInterface**: a secondary ENI
	// *   **IpAddress**: an IP address
	InstanceType *string `json:"InstanceType,omitempty" xml:"InstanceType,omitempty"`
	// The metering method of the EIP. Valid values:
	//
	// *   **PayByBandwidth**: pay-by-bandwidth
	// *   **PayByTraffic**: pay-by-data-transfer
	InternetChargeType *string `json:"InternetChargeType,omitempty" xml:"InternetChargeType,omitempty"`
	// The IP address of the EIP.
	IpAddress *string `json:"IpAddress,omitempty" xml:"IpAddress,omitempty"`
	// The name of the EIP.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The network type. The value is set to **public**, which indicates the Internet.
	Netmode *string `json:"Netmode,omitempty" xml:"Netmode,omitempty"`
	// The details about the locked EIPs.
	OperationLocks *DescribeEipAddressesResponseBodyEipAddressesEipAddressOperationLocks `json:"OperationLocks,omitempty" xml:"OperationLocks,omitempty" type:"Struct"`
	// The ID of the IP address pool to which the EIP belongs.
	PublicIpAddressPoolId *string `json:"PublicIpAddressPoolId,omitempty" xml:"PublicIpAddressPoolId,omitempty"`
	// The region ID of the EIP.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The time when the renewal takes effect. The time is displayed in `YYYY-MM-DDThh:mm:ssZ` format.
	ReservationActiveTime *string `json:"ReservationActiveTime,omitempty" xml:"ReservationActiveTime,omitempty"`
	// The bandwidth after the renewal takes effect. Unit: Mbit/s.
	ReservationBandwidth *string `json:"ReservationBandwidth,omitempty" xml:"ReservationBandwidth,omitempty"`
	// The metering method that is used after the renewal takes effect. Valid values:
	//
	// *   **PayByBandwidth**: pay-by-bandwidth
	// *   **PayByTraffic**: pay-by-data-transfer
	ReservationInternetChargeType *string `json:"ReservationInternetChargeType,omitempty" xml:"ReservationInternetChargeType,omitempty"`
	// The type of the renewal order. Valid values:
	//
	// *   **RENEWCHANGE**: renewal with an upgrade or a downgrade
	// *   **TEMP_UPGRADE**: temporary upgrade
	// *   **UPGRADE**: upgrade
	ReservationOrderType *string `json:"ReservationOrderType,omitempty" xml:"ReservationOrderType,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// Indicates whether level-2 throttling is configured. Valid values:
	//
	// *   **true**: yes
	// *   **false**: no
	SecondLimited *bool `json:"SecondLimited,omitempty" xml:"SecondLimited,omitempty"`
	// The edition of Anti-DDoS.
	//
	// - If an empty value is returned, it indicates that Anti-DDoS Origin Basic is used.
	// - If **AntiDDoS_Enhanced** is returned, it indicates that Anti-DDoS Pro/Premium is used.
	SecurityProtectionTypes *DescribeEipAddressesResponseBodyEipAddressesEipAddressSecurityProtectionTypes `json:"SecurityProtectionTypes,omitempty" xml:"SecurityProtectionTypes,omitempty" type:"Struct"`
	// The IDs of contiguous EIPs.
	//
	// This value is returned only when you query contiguous EIP groups.
	SegmentInstanceId *string `json:"SegmentInstanceId,omitempty" xml:"SegmentInstanceId,omitempty"`
	// Indicates whether the resource is created by the service account.
	//
	// *   **0**: no
	// *   **1**: yes
	ServiceManaged *int32 `json:"ServiceManaged,omitempty" xml:"ServiceManaged,omitempty"`
	// The status of the EIP. Valid values:
	//
	// *   **Associating**: being associated
	// *   **Unassociating**: being disassociated
	// *   **InUse**: allocated
	// *   **Available**: available
	// *   **Releasing**: being released
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The tag list of the EIP.
	Tags *DescribeEipAddressesResponseBodyEipAddressesEipAddressTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Struct"`
	// The ID of the VPC that has IPv4 gateways enabled and that is deployed in the same region as the EIP.
	//
	// When you associate an EIP with an IP address, the system can enable the IP address to access the Internet based on VPC route configurations.
	//
	// >  This parameter is returned if **InstanceType** is set to **IpAddress**. In this case, the EIP is associated with an IP address.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
	// The zone of the EIP.
	//
	// This parameter is returned only if your account is included in the whitelist.
	Zone *string `json:"Zone,omitempty" xml:"Zone,omitempty"`
}

func (s DescribeEipAddressesResponseBodyEipAddressesEipAddress) String() string {
	return tea.Prettify(s)
}

func (s DescribeEipAddressesResponseBodyEipAddressesEipAddress) GoString() string {
	return s.String()
}

func (s *DescribeEipAddressesResponseBodyEipAddressesEipAddress) SetAllocationId(v string) *DescribeEipAddressesResponseBodyEipAddressesEipAddress {
	s.AllocationId = &v
	return s
}

func (s *DescribeEipAddressesResponseBodyEipAddressesEipAddress) SetAllocationTime(v string) *DescribeEipAddressesResponseBodyEipAddressesEipAddress {
	s.AllocationTime = &v
	return s
}

func (s *DescribeEipAddressesResponseBodyEipAddressesEipAddress) SetBandwidth(v string) *DescribeEipAddressesResponseBodyEipAddressesEipAddress {
	s.Bandwidth = &v
	return s
}

func (s *DescribeEipAddressesResponseBodyEipAddressesEipAddress) SetBandwidthPackageBandwidth(v string) *DescribeEipAddressesResponseBodyEipAddressesEipAddress {
	s.BandwidthPackageBandwidth = &v
	return s
}

func (s *DescribeEipAddressesResponseBodyEipAddressesEipAddress) SetBandwidthPackageId(v string) *DescribeEipAddressesResponseBodyEipAddressesEipAddress {
	s.BandwidthPackageId = &v
	return s
}

func (s *DescribeEipAddressesResponseBodyEipAddressesEipAddress) SetBandwidthPackageType(v string) *DescribeEipAddressesResponseBodyEipAddressesEipAddress {
	s.BandwidthPackageType = &v
	return s
}

func (s *DescribeEipAddressesResponseBodyEipAddressesEipAddress) SetBusinessStatus(v string) *DescribeEipAddressesResponseBodyEipAddressesEipAddress {
	s.BusinessStatus = &v
	return s
}

func (s *DescribeEipAddressesResponseBodyEipAddressesEipAddress) SetChargeType(v string) *DescribeEipAddressesResponseBodyEipAddressesEipAddress {
	s.ChargeType = &v
	return s
}

func (s *DescribeEipAddressesResponseBodyEipAddressesEipAddress) SetDeletionProtection(v bool) *DescribeEipAddressesResponseBodyEipAddressesEipAddress {
	s.DeletionProtection = &v
	return s
}

func (s *DescribeEipAddressesResponseBodyEipAddressesEipAddress) SetDescription(v string) *DescribeEipAddressesResponseBodyEipAddressesEipAddress {
	s.Description = &v
	return s
}

func (s *DescribeEipAddressesResponseBodyEipAddressesEipAddress) SetEipBandwidth(v string) *DescribeEipAddressesResponseBodyEipAddressesEipAddress {
	s.EipBandwidth = &v
	return s
}

func (s *DescribeEipAddressesResponseBodyEipAddressesEipAddress) SetExpiredTime(v string) *DescribeEipAddressesResponseBodyEipAddressesEipAddress {
	s.ExpiredTime = &v
	return s
}

func (s *DescribeEipAddressesResponseBodyEipAddressesEipAddress) SetHDMonitorStatus(v string) *DescribeEipAddressesResponseBodyEipAddressesEipAddress {
	s.HDMonitorStatus = &v
	return s
}

func (s *DescribeEipAddressesResponseBodyEipAddressesEipAddress) SetHasReservationData(v string) *DescribeEipAddressesResponseBodyEipAddressesEipAddress {
	s.HasReservationData = &v
	return s
}

func (s *DescribeEipAddressesResponseBodyEipAddressesEipAddress) SetISP(v string) *DescribeEipAddressesResponseBodyEipAddressesEipAddress {
	s.ISP = &v
	return s
}

func (s *DescribeEipAddressesResponseBodyEipAddressesEipAddress) SetInstanceId(v string) *DescribeEipAddressesResponseBodyEipAddressesEipAddress {
	s.InstanceId = &v
	return s
}

func (s *DescribeEipAddressesResponseBodyEipAddressesEipAddress) SetInstanceRegionId(v string) *DescribeEipAddressesResponseBodyEipAddressesEipAddress {
	s.InstanceRegionId = &v
	return s
}

func (s *DescribeEipAddressesResponseBodyEipAddressesEipAddress) SetInstanceType(v string) *DescribeEipAddressesResponseBodyEipAddressesEipAddress {
	s.InstanceType = &v
	return s
}

func (s *DescribeEipAddressesResponseBodyEipAddressesEipAddress) SetInternetChargeType(v string) *DescribeEipAddressesResponseBodyEipAddressesEipAddress {
	s.InternetChargeType = &v
	return s
}

func (s *DescribeEipAddressesResponseBodyEipAddressesEipAddress) SetIpAddress(v string) *DescribeEipAddressesResponseBodyEipAddressesEipAddress {
	s.IpAddress = &v
	return s
}

func (s *DescribeEipAddressesResponseBodyEipAddressesEipAddress) SetName(v string) *DescribeEipAddressesResponseBodyEipAddressesEipAddress {
	s.Name = &v
	return s
}

func (s *DescribeEipAddressesResponseBodyEipAddressesEipAddress) SetNetmode(v string) *DescribeEipAddressesResponseBodyEipAddressesEipAddress {
	s.Netmode = &v
	return s
}

func (s *DescribeEipAddressesResponseBodyEipAddressesEipAddress) SetOperationLocks(v *DescribeEipAddressesResponseBodyEipAddressesEipAddressOperationLocks) *DescribeEipAddressesResponseBodyEipAddressesEipAddress {
	s.OperationLocks = v
	return s
}

func (s *DescribeEipAddressesResponseBodyEipAddressesEipAddress) SetPublicIpAddressPoolId(v string) *DescribeEipAddressesResponseBodyEipAddressesEipAddress {
	s.PublicIpAddressPoolId = &v
	return s
}

func (s *DescribeEipAddressesResponseBodyEipAddressesEipAddress) SetRegionId(v string) *DescribeEipAddressesResponseBodyEipAddressesEipAddress {
	s.RegionId = &v
	return s
}

func (s *DescribeEipAddressesResponseBodyEipAddressesEipAddress) SetReservationActiveTime(v string) *DescribeEipAddressesResponseBodyEipAddressesEipAddress {
	s.ReservationActiveTime = &v
	return s
}

func (s *DescribeEipAddressesResponseBodyEipAddressesEipAddress) SetReservationBandwidth(v string) *DescribeEipAddressesResponseBodyEipAddressesEipAddress {
	s.ReservationBandwidth = &v
	return s
}

func (s *DescribeEipAddressesResponseBodyEipAddressesEipAddress) SetReservationInternetChargeType(v string) *DescribeEipAddressesResponseBodyEipAddressesEipAddress {
	s.ReservationInternetChargeType = &v
	return s
}

func (s *DescribeEipAddressesResponseBodyEipAddressesEipAddress) SetReservationOrderType(v string) *DescribeEipAddressesResponseBodyEipAddressesEipAddress {
	s.ReservationOrderType = &v
	return s
}

func (s *DescribeEipAddressesResponseBodyEipAddressesEipAddress) SetResourceGroupId(v string) *DescribeEipAddressesResponseBodyEipAddressesEipAddress {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeEipAddressesResponseBodyEipAddressesEipAddress) SetSecondLimited(v bool) *DescribeEipAddressesResponseBodyEipAddressesEipAddress {
	s.SecondLimited = &v
	return s
}

func (s *DescribeEipAddressesResponseBodyEipAddressesEipAddress) SetSecurityProtectionTypes(v *DescribeEipAddressesResponseBodyEipAddressesEipAddressSecurityProtectionTypes) *DescribeEipAddressesResponseBodyEipAddressesEipAddress {
	s.SecurityProtectionTypes = v
	return s
}

func (s *DescribeEipAddressesResponseBodyEipAddressesEipAddress) SetSegmentInstanceId(v string) *DescribeEipAddressesResponseBodyEipAddressesEipAddress {
	s.SegmentInstanceId = &v
	return s
}

func (s *DescribeEipAddressesResponseBodyEipAddressesEipAddress) SetServiceManaged(v int32) *DescribeEipAddressesResponseBodyEipAddressesEipAddress {
	s.ServiceManaged = &v
	return s
}

func (s *DescribeEipAddressesResponseBodyEipAddressesEipAddress) SetStatus(v string) *DescribeEipAddressesResponseBodyEipAddressesEipAddress {
	s.Status = &v
	return s
}

func (s *DescribeEipAddressesResponseBodyEipAddressesEipAddress) SetTags(v *DescribeEipAddressesResponseBodyEipAddressesEipAddressTags) *DescribeEipAddressesResponseBodyEipAddressesEipAddress {
	s.Tags = v
	return s
}

func (s *DescribeEipAddressesResponseBodyEipAddressesEipAddress) SetVpcId(v string) *DescribeEipAddressesResponseBodyEipAddressesEipAddress {
	s.VpcId = &v
	return s
}

func (s *DescribeEipAddressesResponseBodyEipAddressesEipAddress) SetZone(v string) *DescribeEipAddressesResponseBodyEipAddressesEipAddress {
	s.Zone = &v
	return s
}

type DescribeEipAddressesResponseBodyEipAddressesEipAddressOperationLocks struct {
	LockReason []*DescribeEipAddressesResponseBodyEipAddressesEipAddressOperationLocksLockReason `json:"LockReason,omitempty" xml:"LockReason,omitempty" type:"Repeated"`
}

func (s DescribeEipAddressesResponseBodyEipAddressesEipAddressOperationLocks) String() string {
	return tea.Prettify(s)
}

func (s DescribeEipAddressesResponseBodyEipAddressesEipAddressOperationLocks) GoString() string {
	return s.String()
}

func (s *DescribeEipAddressesResponseBodyEipAddressesEipAddressOperationLocks) SetLockReason(v []*DescribeEipAddressesResponseBodyEipAddressesEipAddressOperationLocksLockReason) *DescribeEipAddressesResponseBodyEipAddressesEipAddressOperationLocks {
	s.LockReason = v
	return s
}

type DescribeEipAddressesResponseBodyEipAddressesEipAddressOperationLocksLockReason struct {
	// The reason why the EIP is locked. Valid values:
	//
	// *   **financial**: The EIP is locked due to overdue payments.
	// *   **security**: The EIP is locked for security reasons.
	LockReason *string `json:"LockReason,omitempty" xml:"LockReason,omitempty"`
}

func (s DescribeEipAddressesResponseBodyEipAddressesEipAddressOperationLocksLockReason) String() string {
	return tea.Prettify(s)
}

func (s DescribeEipAddressesResponseBodyEipAddressesEipAddressOperationLocksLockReason) GoString() string {
	return s.String()
}

func (s *DescribeEipAddressesResponseBodyEipAddressesEipAddressOperationLocksLockReason) SetLockReason(v string) *DescribeEipAddressesResponseBodyEipAddressesEipAddressOperationLocksLockReason {
	s.LockReason = &v
	return s
}

type DescribeEipAddressesResponseBodyEipAddressesEipAddressSecurityProtectionTypes struct {
	SecurityProtectionType []*string `json:"SecurityProtectionType,omitempty" xml:"SecurityProtectionType,omitempty" type:"Repeated"`
}

func (s DescribeEipAddressesResponseBodyEipAddressesEipAddressSecurityProtectionTypes) String() string {
	return tea.Prettify(s)
}

func (s DescribeEipAddressesResponseBodyEipAddressesEipAddressSecurityProtectionTypes) GoString() string {
	return s.String()
}

func (s *DescribeEipAddressesResponseBodyEipAddressesEipAddressSecurityProtectionTypes) SetSecurityProtectionType(v []*string) *DescribeEipAddressesResponseBodyEipAddressesEipAddressSecurityProtectionTypes {
	s.SecurityProtectionType = v
	return s
}

type DescribeEipAddressesResponseBodyEipAddressesEipAddressTags struct {
	Tag []*DescribeEipAddressesResponseBodyEipAddressesEipAddressTagsTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s DescribeEipAddressesResponseBodyEipAddressesEipAddressTags) String() string {
	return tea.Prettify(s)
}

func (s DescribeEipAddressesResponseBodyEipAddressesEipAddressTags) GoString() string {
	return s.String()
}

func (s *DescribeEipAddressesResponseBodyEipAddressesEipAddressTags) SetTag(v []*DescribeEipAddressesResponseBodyEipAddressesEipAddressTagsTag) *DescribeEipAddressesResponseBodyEipAddressesEipAddressTags {
	s.Tag = v
	return s
}

type DescribeEipAddressesResponseBodyEipAddressesEipAddressTagsTag struct {
	// The tag key of the EIP.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value of the EIP.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeEipAddressesResponseBodyEipAddressesEipAddressTagsTag) String() string {
	return tea.Prettify(s)
}

func (s DescribeEipAddressesResponseBodyEipAddressesEipAddressTagsTag) GoString() string {
	return s.String()
}

func (s *DescribeEipAddressesResponseBodyEipAddressesEipAddressTagsTag) SetKey(v string) *DescribeEipAddressesResponseBodyEipAddressesEipAddressTagsTag {
	s.Key = &v
	return s
}

func (s *DescribeEipAddressesResponseBodyEipAddressesEipAddressTagsTag) SetValue(v string) *DescribeEipAddressesResponseBodyEipAddressesEipAddressTagsTag {
	s.Value = &v
	return s
}

type DescribeEipAddressesResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeEipAddressesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeEipAddressesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeEipAddressesResponse) GoString() string {
	return s.String()
}

func (s *DescribeEipAddressesResponse) SetHeaders(v map[string]*string) *DescribeEipAddressesResponse {
	s.Headers = v
	return s
}

func (s *DescribeEipAddressesResponse) SetStatusCode(v int32) *DescribeEipAddressesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeEipAddressesResponse) SetBody(v *DescribeEipAddressesResponseBody) *DescribeEipAddressesResponse {
	s.Body = v
	return s
}

type DescribeEipGatewayInfoRequest struct {
	// The ID of the secondary ENI that is associated with the EIP.
	InstanceId   *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region to which the EIP that you want to query belongs. You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeEipGatewayInfoRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeEipGatewayInfoRequest) GoString() string {
	return s.String()
}

func (s *DescribeEipGatewayInfoRequest) SetInstanceId(v string) *DescribeEipGatewayInfoRequest {
	s.InstanceId = &v
	return s
}

func (s *DescribeEipGatewayInfoRequest) SetOwnerAccount(v string) *DescribeEipGatewayInfoRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeEipGatewayInfoRequest) SetOwnerId(v int64) *DescribeEipGatewayInfoRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeEipGatewayInfoRequest) SetRegionId(v string) *DescribeEipGatewayInfoRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeEipGatewayInfoRequest) SetResourceOwnerAccount(v string) *DescribeEipGatewayInfoRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeEipGatewayInfoRequest) SetResourceOwnerId(v int64) *DescribeEipGatewayInfoRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeEipGatewayInfoResponseBody struct {
	// The status code of the operation.
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The detailed information about the EIP.
	EipInfos *DescribeEipGatewayInfoResponseBodyEipInfos `json:"EipInfos,omitempty" xml:"EipInfos,omitempty" type:"Struct"`
	// The result of the operation.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeEipGatewayInfoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeEipGatewayInfoResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeEipGatewayInfoResponseBody) SetCode(v string) *DescribeEipGatewayInfoResponseBody {
	s.Code = &v
	return s
}

func (s *DescribeEipGatewayInfoResponseBody) SetEipInfos(v *DescribeEipGatewayInfoResponseBodyEipInfos) *DescribeEipGatewayInfoResponseBody {
	s.EipInfos = v
	return s
}

func (s *DescribeEipGatewayInfoResponseBody) SetMessage(v string) *DescribeEipGatewayInfoResponseBody {
	s.Message = &v
	return s
}

func (s *DescribeEipGatewayInfoResponseBody) SetRequestId(v string) *DescribeEipGatewayInfoResponseBody {
	s.RequestId = &v
	return s
}

type DescribeEipGatewayInfoResponseBodyEipInfos struct {
	EipInfo []*DescribeEipGatewayInfoResponseBodyEipInfosEipInfo `json:"EipInfo,omitempty" xml:"EipInfo,omitempty" type:"Repeated"`
}

func (s DescribeEipGatewayInfoResponseBodyEipInfos) String() string {
	return tea.Prettify(s)
}

func (s DescribeEipGatewayInfoResponseBodyEipInfos) GoString() string {
	return s.String()
}

func (s *DescribeEipGatewayInfoResponseBodyEipInfos) SetEipInfo(v []*DescribeEipGatewayInfoResponseBodyEipInfosEipInfo) *DescribeEipGatewayInfoResponseBodyEipInfos {
	s.EipInfo = v
	return s
}

type DescribeEipGatewayInfoResponseBodyEipInfosEipInfo struct {
	// The IP address of the EIP.
	Ip *string `json:"Ip,omitempty" xml:"Ip,omitempty"`
	// The IP address of the gateway that is associated with the EIP.
	IpGw *string `json:"IpGw,omitempty" xml:"IpGw,omitempty"`
	// The subnet mask of the EIP.
	IpMask *string `json:"IpMask,omitempty" xml:"IpMask,omitempty"`
}

func (s DescribeEipGatewayInfoResponseBodyEipInfosEipInfo) String() string {
	return tea.Prettify(s)
}

func (s DescribeEipGatewayInfoResponseBodyEipInfosEipInfo) GoString() string {
	return s.String()
}

func (s *DescribeEipGatewayInfoResponseBodyEipInfosEipInfo) SetIp(v string) *DescribeEipGatewayInfoResponseBodyEipInfosEipInfo {
	s.Ip = &v
	return s
}

func (s *DescribeEipGatewayInfoResponseBodyEipInfosEipInfo) SetIpGw(v string) *DescribeEipGatewayInfoResponseBodyEipInfosEipInfo {
	s.IpGw = &v
	return s
}

func (s *DescribeEipGatewayInfoResponseBodyEipInfosEipInfo) SetIpMask(v string) *DescribeEipGatewayInfoResponseBodyEipInfosEipInfo {
	s.IpMask = &v
	return s
}

type DescribeEipGatewayInfoResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeEipGatewayInfoResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeEipGatewayInfoResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeEipGatewayInfoResponse) GoString() string {
	return s.String()
}

func (s *DescribeEipGatewayInfoResponse) SetHeaders(v map[string]*string) *DescribeEipGatewayInfoResponse {
	s.Headers = v
	return s
}

func (s *DescribeEipGatewayInfoResponse) SetStatusCode(v int32) *DescribeEipGatewayInfoResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeEipGatewayInfoResponse) SetBody(v *DescribeEipGatewayInfoResponseBody) *DescribeEipGatewayInfoResponse {
	s.Body = v
	return s
}

type DescribeEipMonitorDataRequest struct {
	// The ID of the EIP.
	AllocationId *string `json:"AllocationId,omitempty" xml:"AllocationId,omitempty"`
	// The end of the time range to query. The time must be in UTC. Specify the time in the ISO 8601 standard in `YYYY-MM-DDThh:mm:ssZ` format. For example, `2013-01-10T12:00:00Z` specifies 20:00:00 (UTC+8) on January 10, 2013.
	//
	// If the value of seconds (ss) is not 00, the end time is automatically rounded up to the next minute.
	EndTime      *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The duration of each monitoring data entry. Unit: seconds. Valid values: **60** (default), **300**, **900**, and **3600**.
	//
	// *   If the value of **(EndTime** - **StartTime**)/**Period** is greater than 200, a maximum of 200 monitoring data entries are returned at a time.
	// *   If the value of (**EndTime** - **StartTime**)/**Period** is less than or equal to 200, only the monitoring data collected between the start time and end time is returned.
	Period *int32 `json:"Period,omitempty" xml:"Period,omitempty"`
	// The ID of the region to which the EIP belongs.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query available regions.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The beginning of the time range to query. The time must be in UTC. Specify the time in the ISO 8601 standard in `YYYY-MM-DDThh:mm:ssZ` format. For example, `2013-01-10T12:00:00Z` specifies 20:00:00 (UTC+8) on January 10, 2013.
	//
	// If the value of seconds (ss) is not 00, the start time is automatically rounded up to the next minute.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeEipMonitorDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeEipMonitorDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeEipMonitorDataRequest) SetAllocationId(v string) *DescribeEipMonitorDataRequest {
	s.AllocationId = &v
	return s
}

func (s *DescribeEipMonitorDataRequest) SetEndTime(v string) *DescribeEipMonitorDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeEipMonitorDataRequest) SetOwnerAccount(v string) *DescribeEipMonitorDataRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeEipMonitorDataRequest) SetOwnerId(v int64) *DescribeEipMonitorDataRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeEipMonitorDataRequest) SetPeriod(v int32) *DescribeEipMonitorDataRequest {
	s.Period = &v
	return s
}

func (s *DescribeEipMonitorDataRequest) SetRegionId(v string) *DescribeEipMonitorDataRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeEipMonitorDataRequest) SetResourceOwnerAccount(v string) *DescribeEipMonitorDataRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeEipMonitorDataRequest) SetResourceOwnerId(v int64) *DescribeEipMonitorDataRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeEipMonitorDataRequest) SetStartTime(v string) *DescribeEipMonitorDataRequest {
	s.StartTime = &v
	return s
}

type DescribeEipMonitorDataResponseBody struct {
	// The detailed information about the monitoring data of the EIP.
	EipMonitorDatas *DescribeEipMonitorDataResponseBodyEipMonitorDatas `json:"EipMonitorDatas,omitempty" xml:"EipMonitorDatas,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeEipMonitorDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeEipMonitorDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeEipMonitorDataResponseBody) SetEipMonitorDatas(v *DescribeEipMonitorDataResponseBodyEipMonitorDatas) *DescribeEipMonitorDataResponseBody {
	s.EipMonitorDatas = v
	return s
}

func (s *DescribeEipMonitorDataResponseBody) SetRequestId(v string) *DescribeEipMonitorDataResponseBody {
	s.RequestId = &v
	return s
}

type DescribeEipMonitorDataResponseBodyEipMonitorDatas struct {
	EipMonitorData []*DescribeEipMonitorDataResponseBodyEipMonitorDatasEipMonitorData `json:"EipMonitorData,omitempty" xml:"EipMonitorData,omitempty" type:"Repeated"`
}

func (s DescribeEipMonitorDataResponseBodyEipMonitorDatas) String() string {
	return tea.Prettify(s)
}

func (s DescribeEipMonitorDataResponseBodyEipMonitorDatas) GoString() string {
	return s.String()
}

func (s *DescribeEipMonitorDataResponseBodyEipMonitorDatas) SetEipMonitorData(v []*DescribeEipMonitorDataResponseBodyEipMonitorDatasEipMonitorData) *DescribeEipMonitorDataResponseBodyEipMonitorDatas {
	s.EipMonitorData = v
	return s
}

type DescribeEipMonitorDataResponseBodyEipMonitorDatasEipMonitorData struct {
	EipBandwidth *int32 `json:"EipBandwidth,omitempty" xml:"EipBandwidth,omitempty"`
	// The sum of inbound and outbound traffic.
	EipFlow *int64 `json:"EipFlow,omitempty" xml:"EipFlow,omitempty"`
	// The number of packets.
	EipPackets *int32 `json:"EipPackets,omitempty" xml:"EipPackets,omitempty"`
	// The inbound traffic. Unit: bytes.
	EipRX *int64 `json:"EipRX,omitempty" xml:"EipRX,omitempty"`
	// The outbound traffic. Unit: bytes.
	EipTX *int64 `json:"EipTX,omitempty" xml:"EipTX,omitempty"`
	// The timestamp of the monitoring data. Specify the time in the ISO8601 standard. Example: `2020-01-21T09:50:23Z`.
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
}

func (s DescribeEipMonitorDataResponseBodyEipMonitorDatasEipMonitorData) String() string {
	return tea.Prettify(s)
}

func (s DescribeEipMonitorDataResponseBodyEipMonitorDatasEipMonitorData) GoString() string {
	return s.String()
}

func (s *DescribeEipMonitorDataResponseBodyEipMonitorDatasEipMonitorData) SetEipBandwidth(v int32) *DescribeEipMonitorDataResponseBodyEipMonitorDatasEipMonitorData {
	s.EipBandwidth = &v
	return s
}

func (s *DescribeEipMonitorDataResponseBodyEipMonitorDatasEipMonitorData) SetEipFlow(v int64) *DescribeEipMonitorDataResponseBodyEipMonitorDatasEipMonitorData {
	s.EipFlow = &v
	return s
}

func (s *DescribeEipMonitorDataResponseBodyEipMonitorDatasEipMonitorData) SetEipPackets(v int32) *DescribeEipMonitorDataResponseBodyEipMonitorDatasEipMonitorData {
	s.EipPackets = &v
	return s
}

func (s *DescribeEipMonitorDataResponseBodyEipMonitorDatasEipMonitorData) SetEipRX(v int64) *DescribeEipMonitorDataResponseBodyEipMonitorDatasEipMonitorData {
	s.EipRX = &v
	return s
}

func (s *DescribeEipMonitorDataResponseBodyEipMonitorDatasEipMonitorData) SetEipTX(v int64) *DescribeEipMonitorDataResponseBodyEipMonitorDatasEipMonitorData {
	s.EipTX = &v
	return s
}

func (s *DescribeEipMonitorDataResponseBodyEipMonitorDatasEipMonitorData) SetTimeStamp(v string) *DescribeEipMonitorDataResponseBodyEipMonitorDatasEipMonitorData {
	s.TimeStamp = &v
	return s
}

type DescribeEipMonitorDataResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeEipMonitorDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeEipMonitorDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeEipMonitorDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeEipMonitorDataResponse) SetHeaders(v map[string]*string) *DescribeEipMonitorDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeEipMonitorDataResponse) SetStatusCode(v int32) *DescribeEipMonitorDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeEipMonitorDataResponse) SetBody(v *DescribeEipMonitorDataResponseBody) *DescribeEipMonitorDataResponse {
	s.Body = v
	return s
}

type DescribeEipSegmentRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, the system uses **RequestId** as **ClientToken**. **RequestId** may be different for each API request.
	ClientToken  *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of the page to return. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Maximum value: **50**. Default value: **10**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the region to which the contiguous EIP group belongs. You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the contiguous EIP group that you want to query.
	SegmentInstanceId *string `json:"SegmentInstanceId,omitempty" xml:"SegmentInstanceId,omitempty"`
}

func (s DescribeEipSegmentRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeEipSegmentRequest) GoString() string {
	return s.String()
}

func (s *DescribeEipSegmentRequest) SetClientToken(v string) *DescribeEipSegmentRequest {
	s.ClientToken = &v
	return s
}

func (s *DescribeEipSegmentRequest) SetOwnerAccount(v string) *DescribeEipSegmentRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeEipSegmentRequest) SetOwnerId(v int64) *DescribeEipSegmentRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeEipSegmentRequest) SetPageNumber(v int32) *DescribeEipSegmentRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeEipSegmentRequest) SetPageSize(v int32) *DescribeEipSegmentRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeEipSegmentRequest) SetRegionId(v string) *DescribeEipSegmentRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeEipSegmentRequest) SetResourceOwnerAccount(v string) *DescribeEipSegmentRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeEipSegmentRequest) SetResourceOwnerId(v int64) *DescribeEipSegmentRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeEipSegmentRequest) SetSegmentInstanceId(v string) *DescribeEipSegmentRequest {
	s.SegmentInstanceId = &v
	return s
}

type DescribeEipSegmentResponseBody struct {
	// The details of the contiguous EIP group.
	EipSegments *DescribeEipSegmentResponseBodyEipSegments `json:"EipSegments,omitempty" xml:"EipSegments,omitempty" type:"Struct"`
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeEipSegmentResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeEipSegmentResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeEipSegmentResponseBody) SetEipSegments(v *DescribeEipSegmentResponseBodyEipSegments) *DescribeEipSegmentResponseBody {
	s.EipSegments = v
	return s
}

func (s *DescribeEipSegmentResponseBody) SetPageNumber(v int32) *DescribeEipSegmentResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeEipSegmentResponseBody) SetPageSize(v int32) *DescribeEipSegmentResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeEipSegmentResponseBody) SetRequestId(v string) *DescribeEipSegmentResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeEipSegmentResponseBody) SetTotalCount(v int32) *DescribeEipSegmentResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeEipSegmentResponseBodyEipSegments struct {
	EipSegment []*DescribeEipSegmentResponseBodyEipSegmentsEipSegment `json:"EipSegment,omitempty" xml:"EipSegment,omitempty" type:"Repeated"`
}

func (s DescribeEipSegmentResponseBodyEipSegments) String() string {
	return tea.Prettify(s)
}

func (s DescribeEipSegmentResponseBodyEipSegments) GoString() string {
	return s.String()
}

func (s *DescribeEipSegmentResponseBodyEipSegments) SetEipSegment(v []*DescribeEipSegmentResponseBodyEipSegmentsEipSegment) *DescribeEipSegmentResponseBodyEipSegments {
	s.EipSegment = v
	return s
}

type DescribeEipSegmentResponseBodyEipSegmentsEipSegment struct {
	// The time when the contiguous EIP group was created. The time is displayed in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is in UTC.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The description of the contiguous EIP group.
	Descritpion *string `json:"Descritpion,omitempty" xml:"Descritpion,omitempty"`
	// The ID of the contiguous EIP group.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The number of EIPs in the contiguous EIP group.
	IpCount *string `json:"IpCount,omitempty" xml:"IpCount,omitempty"`
	// The name of the contiguous EIP group.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the region to which the contiguous EIP group belongs.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The CIDR block and mask of the contiguous EIP group.
	Segment *string `json:"Segment,omitempty" xml:"Segment,omitempty"`
	// The status of the contiguous EIP group.
	//
	// *   **Allocating**: being allocated
	// *   **Allocated**: allocated
	// *   **Releasing**: being released
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	Zone   *string `json:"Zone,omitempty" xml:"Zone,omitempty"`
}

func (s DescribeEipSegmentResponseBodyEipSegmentsEipSegment) String() string {
	return tea.Prettify(s)
}

func (s DescribeEipSegmentResponseBodyEipSegmentsEipSegment) GoString() string {
	return s.String()
}

func (s *DescribeEipSegmentResponseBodyEipSegmentsEipSegment) SetCreationTime(v string) *DescribeEipSegmentResponseBodyEipSegmentsEipSegment {
	s.CreationTime = &v
	return s
}

func (s *DescribeEipSegmentResponseBodyEipSegmentsEipSegment) SetDescritpion(v string) *DescribeEipSegmentResponseBodyEipSegmentsEipSegment {
	s.Descritpion = &v
	return s
}

func (s *DescribeEipSegmentResponseBodyEipSegmentsEipSegment) SetInstanceId(v string) *DescribeEipSegmentResponseBodyEipSegmentsEipSegment {
	s.InstanceId = &v
	return s
}

func (s *DescribeEipSegmentResponseBodyEipSegmentsEipSegment) SetIpCount(v string) *DescribeEipSegmentResponseBodyEipSegmentsEipSegment {
	s.IpCount = &v
	return s
}

func (s *DescribeEipSegmentResponseBodyEipSegmentsEipSegment) SetName(v string) *DescribeEipSegmentResponseBodyEipSegmentsEipSegment {
	s.Name = &v
	return s
}

func (s *DescribeEipSegmentResponseBodyEipSegmentsEipSegment) SetRegionId(v string) *DescribeEipSegmentResponseBodyEipSegmentsEipSegment {
	s.RegionId = &v
	return s
}

func (s *DescribeEipSegmentResponseBodyEipSegmentsEipSegment) SetSegment(v string) *DescribeEipSegmentResponseBodyEipSegmentsEipSegment {
	s.Segment = &v
	return s
}

func (s *DescribeEipSegmentResponseBodyEipSegmentsEipSegment) SetStatus(v string) *DescribeEipSegmentResponseBodyEipSegmentsEipSegment {
	s.Status = &v
	return s
}

func (s *DescribeEipSegmentResponseBodyEipSegmentsEipSegment) SetZone(v string) *DescribeEipSegmentResponseBodyEipSegmentsEipSegment {
	s.Zone = &v
	return s
}

type DescribeEipSegmentResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeEipSegmentResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeEipSegmentResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeEipSegmentResponse) GoString() string {
	return s.String()
}

func (s *DescribeEipSegmentResponse) SetHeaders(v map[string]*string) *DescribeEipSegmentResponse {
	s.Headers = v
	return s
}

func (s *DescribeEipSegmentResponse) SetStatusCode(v int32) *DescribeEipSegmentResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeEipSegmentResponse) SetBody(v *DescribeEipSegmentResponseBody) *DescribeEipSegmentResponse {
	s.Body = v
	return s
}

type DescribeFlowLogsRequest struct {
	// The description of the flow log.
	//
	// The description must be 1 to 256 characters in length and cannot start with `http://` or `https://`.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the flow log.
	FlowLogId *string `json:"FlowLogId,omitempty" xml:"FlowLogId,omitempty"`
	// The name of the flow log.
	//
	// The name must be 1 to 128 characters in length and cannot start with `http://` or `https://`.
	FlowLogName *string `json:"FlowLogName,omitempty" xml:"FlowLogName,omitempty"`
	// The Logstore that stores the captured traffic data.
	LogStoreName *string `json:"LogStoreName,omitempty" xml:"LogStoreName,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of the page to return. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Maximum value: **50**. Default value: **20**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The project that manages the captured traffic data.
	ProjectName *string `json:"ProjectName,omitempty" xml:"ProjectName,omitempty"`
	// The region ID of the flow log.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group to which the flow log belongs.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The ID of the resource from which traffic is captured.
	ResourceId           *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The type of the resource from which traffic is captured. Valid values:
	//
	// *   **NetworkInterface**: elastic network interface (ENI)
	// *   **VSwitch**: all ENIs in a vSwitch
	// *   **VPC**: all ENIs in a virtual private cloud (VPC)
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The status of the flow log. Valid values:
	//
	// *   **Active**: enabled
	// *   **Activating**: being enabled
	// *   **Inactive**: disabled
	Status *string                        `json:"Status,omitempty" xml:"Status,omitempty"`
	Tags   []*DescribeFlowLogsRequestTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
	// The type of traffic that is captured. Valid values:
	//
	// *   **All**: all traffic
	// *   **Allow**: traffic that is allowed by access control
	// *   **Drop**: traffic that is denied by access control
	TrafficType *string `json:"TrafficType,omitempty" xml:"TrafficType,omitempty"`
	// The ID of the VPC to which the flow log belongs.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s DescribeFlowLogsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeFlowLogsRequest) GoString() string {
	return s.String()
}

func (s *DescribeFlowLogsRequest) SetDescription(v string) *DescribeFlowLogsRequest {
	s.Description = &v
	return s
}

func (s *DescribeFlowLogsRequest) SetFlowLogId(v string) *DescribeFlowLogsRequest {
	s.FlowLogId = &v
	return s
}

func (s *DescribeFlowLogsRequest) SetFlowLogName(v string) *DescribeFlowLogsRequest {
	s.FlowLogName = &v
	return s
}

func (s *DescribeFlowLogsRequest) SetLogStoreName(v string) *DescribeFlowLogsRequest {
	s.LogStoreName = &v
	return s
}

func (s *DescribeFlowLogsRequest) SetOwnerAccount(v string) *DescribeFlowLogsRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeFlowLogsRequest) SetOwnerId(v int64) *DescribeFlowLogsRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeFlowLogsRequest) SetPageNumber(v int32) *DescribeFlowLogsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeFlowLogsRequest) SetPageSize(v int32) *DescribeFlowLogsRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeFlowLogsRequest) SetProjectName(v string) *DescribeFlowLogsRequest {
	s.ProjectName = &v
	return s
}

func (s *DescribeFlowLogsRequest) SetRegionId(v string) *DescribeFlowLogsRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeFlowLogsRequest) SetResourceGroupId(v string) *DescribeFlowLogsRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeFlowLogsRequest) SetResourceId(v string) *DescribeFlowLogsRequest {
	s.ResourceId = &v
	return s
}

func (s *DescribeFlowLogsRequest) SetResourceOwnerAccount(v string) *DescribeFlowLogsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeFlowLogsRequest) SetResourceOwnerId(v int64) *DescribeFlowLogsRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeFlowLogsRequest) SetResourceType(v string) *DescribeFlowLogsRequest {
	s.ResourceType = &v
	return s
}

func (s *DescribeFlowLogsRequest) SetStatus(v string) *DescribeFlowLogsRequest {
	s.Status = &v
	return s
}

func (s *DescribeFlowLogsRequest) SetTags(v []*DescribeFlowLogsRequestTags) *DescribeFlowLogsRequest {
	s.Tags = v
	return s
}

func (s *DescribeFlowLogsRequest) SetTrafficType(v string) *DescribeFlowLogsRequest {
	s.TrafficType = &v
	return s
}

func (s *DescribeFlowLogsRequest) SetVpcId(v string) *DescribeFlowLogsRequest {
	s.VpcId = &v
	return s
}

type DescribeFlowLogsRequestTags struct {
	// The tag key. You can specify at most 20 tag keys. The tag key cannot be an empty string.
	//
	// The key cannot exceed 64 characters in length, and can contain digits, periods (.), underscores (\_), and hyphens (-). The key must start with a letter but cannot start with `aliyun` or `acs:`. The key cannot contain `http://` or `https://`.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value. You can specify at most 20 tag values. The tag value can be an empty string.
	//
	// The tag value cannot exceed 128 characters in length, and can contain digits, periods (.), underscores (\_), and hyphens (-). It must start with a letter but cannot start with `aliyun` or `acs:`. It cannot contain `http://` or `https://`.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeFlowLogsRequestTags) String() string {
	return tea.Prettify(s)
}

func (s DescribeFlowLogsRequestTags) GoString() string {
	return s.String()
}

func (s *DescribeFlowLogsRequestTags) SetKey(v string) *DescribeFlowLogsRequestTags {
	s.Key = &v
	return s
}

func (s *DescribeFlowLogsRequestTags) SetValue(v string) *DescribeFlowLogsRequestTags {
	s.Value = &v
	return s
}

type DescribeFlowLogsResponseBody struct {
	// The information about the flow logs.
	FlowLogs *DescribeFlowLogsResponseBodyFlowLogs `json:"FlowLogs,omitempty" xml:"FlowLogs,omitempty" type:"Struct"`
	// The number of the returned page.
	PageNumber *string `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *string `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the operation is successful. Valid values:
	//
	// *   **true**: yes
	// *   **false**: no
	Success *string `json:"Success,omitempty" xml:"Success,omitempty"`
	// The number of flow logs that are queried.
	TotalCount *string `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeFlowLogsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeFlowLogsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeFlowLogsResponseBody) SetFlowLogs(v *DescribeFlowLogsResponseBodyFlowLogs) *DescribeFlowLogsResponseBody {
	s.FlowLogs = v
	return s
}

func (s *DescribeFlowLogsResponseBody) SetPageNumber(v string) *DescribeFlowLogsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeFlowLogsResponseBody) SetPageSize(v string) *DescribeFlowLogsResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeFlowLogsResponseBody) SetRequestId(v string) *DescribeFlowLogsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeFlowLogsResponseBody) SetSuccess(v string) *DescribeFlowLogsResponseBody {
	s.Success = &v
	return s
}

func (s *DescribeFlowLogsResponseBody) SetTotalCount(v string) *DescribeFlowLogsResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeFlowLogsResponseBodyFlowLogs struct {
	FlowLog []*DescribeFlowLogsResponseBodyFlowLogsFlowLog `json:"FlowLog,omitempty" xml:"FlowLog,omitempty" type:"Repeated"`
}

func (s DescribeFlowLogsResponseBodyFlowLogs) String() string {
	return tea.Prettify(s)
}

func (s DescribeFlowLogsResponseBodyFlowLogs) GoString() string {
	return s.String()
}

func (s *DescribeFlowLogsResponseBodyFlowLogs) SetFlowLog(v []*DescribeFlowLogsResponseBodyFlowLogsFlowLog) *DescribeFlowLogsResponseBodyFlowLogs {
	s.FlowLog = v
	return s
}

type DescribeFlowLogsResponseBodyFlowLogsFlowLog struct {
	// The sampling interval of the flow log. Unit: seconds.
	AggregationInterval *int32 `json:"AggregationInterval,omitempty" xml:"AggregationInterval,omitempty"`
	// The business status of the flow log. Valid values:
	//
	// *   **Normal**: active
	// *   **FinancialLocked**: locked due to overdue payments
	BusinessStatus *string `json:"BusinessStatus,omitempty" xml:"BusinessStatus,omitempty"`
	// The time when the flow log was created.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The description of the flow log.
	Description                *string `json:"Description,omitempty" xml:"Description,omitempty"`
	FlowLogDeliverErrorMessage *string `json:"FlowLogDeliverErrorMessage,omitempty" xml:"FlowLogDeliverErrorMessage,omitempty"`
	FlowLogDeliverStatus       *string `json:"FlowLogDeliverStatus,omitempty" xml:"FlowLogDeliverStatus,omitempty"`
	// The ID of the flow log.
	FlowLogId *string `json:"FlowLogId,omitempty" xml:"FlowLogId,omitempty"`
	// The name of the flow log.
	FlowLogName *string `json:"FlowLogName,omitempty" xml:"FlowLogName,omitempty"`
	// The Logstore that stores the captured traffic data.
	LogStoreName *string `json:"LogStoreName,omitempty" xml:"LogStoreName,omitempty"`
	// The project that manages the captured traffic data.
	ProjectName *string `json:"ProjectName,omitempty" xml:"ProjectName,omitempty"`
	// The region ID of the flow log.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group to which the flow log belongs.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The ID of the resource from which traffic is captured.
	ResourceId *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	// The type of the resource from which traffic is captured. Valid values:
	//
	// *   **NetworkInterface**: an ENI
	// *   **VSwitch**: all ENIs in a vSwitch
	// *   **VPC**: all ENIs in a VPC
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The hosting type of the cloud service.
	//
	// *   This parameter can be empty, which indicates that the flow log is created by the user.
	// *   If this parameter is not empty, the value is fixed as **sls**. The value sls indicates that the flow log is created in the Log Service console.
	//
	// >  A flow log that is created in the Log Service console can be displayed in the VPC list. However, you cannot modify, start, stop, or delete the flow log in the VPC console. If you want to manage the flow log, you can log on to the [Log Service console](https://sls.console.aliyun.com) and perform required operations.
	ServiceType *string `json:"ServiceType,omitempty" xml:"ServiceType,omitempty"`
	// The status of the flow log. Valid values:
	//
	// *   **Active**: enabled
	// *   **Activating**: being enabled
	// *   **Inactive**: disabled
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// An array that consists of the details of the returned tags.
	Tags *DescribeFlowLogsResponseBodyFlowLogsFlowLogTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Struct"`
	// The scope of the traffic that you want to capture. Valid values:
	//
	// *   **all** (default value): all traffic
	// *   **internetGateway**: Internet traffic
	//
	// >  By default, the traffic path feature is unavailable. To use this feature, [submit a ticket](https://workorder-intl.console.aliyun.com/?spm=5176.11182188.console-base-top.dworkorder.18ae4882n3v6ZW#/ticket/createIndex).
	TrafficPath *DescribeFlowLogsResponseBodyFlowLogsFlowLogTrafficPath `json:"TrafficPath,omitempty" xml:"TrafficPath,omitempty" type:"Struct"`
	// The type of traffic that is captured by the flow log. Valid values:
	//
	// *   **All**: all traffic
	// *   **Allow**: traffic that is allowed by access control
	// *   **Drop**: traffic that is denied by access control
	TrafficType *string `json:"TrafficType,omitempty" xml:"TrafficType,omitempty"`
}

func (s DescribeFlowLogsResponseBodyFlowLogsFlowLog) String() string {
	return tea.Prettify(s)
}

func (s DescribeFlowLogsResponseBodyFlowLogsFlowLog) GoString() string {
	return s.String()
}

func (s *DescribeFlowLogsResponseBodyFlowLogsFlowLog) SetAggregationInterval(v int32) *DescribeFlowLogsResponseBodyFlowLogsFlowLog {
	s.AggregationInterval = &v
	return s
}

func (s *DescribeFlowLogsResponseBodyFlowLogsFlowLog) SetBusinessStatus(v string) *DescribeFlowLogsResponseBodyFlowLogsFlowLog {
	s.BusinessStatus = &v
	return s
}

func (s *DescribeFlowLogsResponseBodyFlowLogsFlowLog) SetCreationTime(v string) *DescribeFlowLogsResponseBodyFlowLogsFlowLog {
	s.CreationTime = &v
	return s
}

func (s *DescribeFlowLogsResponseBodyFlowLogsFlowLog) SetDescription(v string) *DescribeFlowLogsResponseBodyFlowLogsFlowLog {
	s.Description = &v
	return s
}

func (s *DescribeFlowLogsResponseBodyFlowLogsFlowLog) SetFlowLogDeliverErrorMessage(v string) *DescribeFlowLogsResponseBodyFlowLogsFlowLog {
	s.FlowLogDeliverErrorMessage = &v
	return s
}

func (s *DescribeFlowLogsResponseBodyFlowLogsFlowLog) SetFlowLogDeliverStatus(v string) *DescribeFlowLogsResponseBodyFlowLogsFlowLog {
	s.FlowLogDeliverStatus = &v
	return s
}

func (s *DescribeFlowLogsResponseBodyFlowLogsFlowLog) SetFlowLogId(v string) *DescribeFlowLogsResponseBodyFlowLogsFlowLog {
	s.FlowLogId = &v
	return s
}

func (s *DescribeFlowLogsResponseBodyFlowLogsFlowLog) SetFlowLogName(v string) *DescribeFlowLogsResponseBodyFlowLogsFlowLog {
	s.FlowLogName = &v
	return s
}

func (s *DescribeFlowLogsResponseBodyFlowLogsFlowLog) SetLogStoreName(v string) *DescribeFlowLogsResponseBodyFlowLogsFlowLog {
	s.LogStoreName = &v
	return s
}

func (s *DescribeFlowLogsResponseBodyFlowLogsFlowLog) SetProjectName(v string) *DescribeFlowLogsResponseBodyFlowLogsFlowLog {
	s.ProjectName = &v
	return s
}

func (s *DescribeFlowLogsResponseBodyFlowLogsFlowLog) SetRegionId(v string) *DescribeFlowLogsResponseBodyFlowLogsFlowLog {
	s.RegionId = &v
	return s
}

func (s *DescribeFlowLogsResponseBodyFlowLogsFlowLog) SetResourceGroupId(v string) *DescribeFlowLogsResponseBodyFlowLogsFlowLog {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeFlowLogsResponseBodyFlowLogsFlowLog) SetResourceId(v string) *DescribeFlowLogsResponseBodyFlowLogsFlowLog {
	s.ResourceId = &v
	return s
}

func (s *DescribeFlowLogsResponseBodyFlowLogsFlowLog) SetResourceType(v string) *DescribeFlowLogsResponseBodyFlowLogsFlowLog {
	s.ResourceType = &v
	return s
}

func (s *DescribeFlowLogsResponseBodyFlowLogsFlowLog) SetServiceType(v string) *DescribeFlowLogsResponseBodyFlowLogsFlowLog {
	s.ServiceType = &v
	return s
}

func (s *DescribeFlowLogsResponseBodyFlowLogsFlowLog) SetStatus(v string) *DescribeFlowLogsResponseBodyFlowLogsFlowLog {
	s.Status = &v
	return s
}

func (s *DescribeFlowLogsResponseBodyFlowLogsFlowLog) SetTags(v *DescribeFlowLogsResponseBodyFlowLogsFlowLogTags) *DescribeFlowLogsResponseBodyFlowLogsFlowLog {
	s.Tags = v
	return s
}

func (s *DescribeFlowLogsResponseBodyFlowLogsFlowLog) SetTrafficPath(v *DescribeFlowLogsResponseBodyFlowLogsFlowLogTrafficPath) *DescribeFlowLogsResponseBodyFlowLogsFlowLog {
	s.TrafficPath = v
	return s
}

func (s *DescribeFlowLogsResponseBodyFlowLogsFlowLog) SetTrafficType(v string) *DescribeFlowLogsResponseBodyFlowLogsFlowLog {
	s.TrafficType = &v
	return s
}

type DescribeFlowLogsResponseBodyFlowLogsFlowLogTags struct {
	Tag []*DescribeFlowLogsResponseBodyFlowLogsFlowLogTagsTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s DescribeFlowLogsResponseBodyFlowLogsFlowLogTags) String() string {
	return tea.Prettify(s)
}

func (s DescribeFlowLogsResponseBodyFlowLogsFlowLogTags) GoString() string {
	return s.String()
}

func (s *DescribeFlowLogsResponseBodyFlowLogsFlowLogTags) SetTag(v []*DescribeFlowLogsResponseBodyFlowLogsFlowLogTagsTag) *DescribeFlowLogsResponseBodyFlowLogsFlowLogTags {
	s.Tag = v
	return s
}

type DescribeFlowLogsResponseBodyFlowLogsFlowLogTagsTag struct {
	// The tag key.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeFlowLogsResponseBodyFlowLogsFlowLogTagsTag) String() string {
	return tea.Prettify(s)
}

func (s DescribeFlowLogsResponseBodyFlowLogsFlowLogTagsTag) GoString() string {
	return s.String()
}

func (s *DescribeFlowLogsResponseBodyFlowLogsFlowLogTagsTag) SetKey(v string) *DescribeFlowLogsResponseBodyFlowLogsFlowLogTagsTag {
	s.Key = &v
	return s
}

func (s *DescribeFlowLogsResponseBodyFlowLogsFlowLogTagsTag) SetValue(v string) *DescribeFlowLogsResponseBodyFlowLogsFlowLogTagsTag {
	s.Value = &v
	return s
}

type DescribeFlowLogsResponseBodyFlowLogsFlowLogTrafficPath struct {
	TrafficPathList []*string `json:"TrafficPathList,omitempty" xml:"TrafficPathList,omitempty" type:"Repeated"`
}

func (s DescribeFlowLogsResponseBodyFlowLogsFlowLogTrafficPath) String() string {
	return tea.Prettify(s)
}

func (s DescribeFlowLogsResponseBodyFlowLogsFlowLogTrafficPath) GoString() string {
	return s.String()
}

func (s *DescribeFlowLogsResponseBodyFlowLogsFlowLogTrafficPath) SetTrafficPathList(v []*string) *DescribeFlowLogsResponseBodyFlowLogsFlowLogTrafficPath {
	s.TrafficPathList = v
	return s
}

type DescribeFlowLogsResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeFlowLogsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeFlowLogsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeFlowLogsResponse) GoString() string {
	return s.String()
}

func (s *DescribeFlowLogsResponse) SetHeaders(v map[string]*string) *DescribeFlowLogsResponse {
	s.Headers = v
	return s
}

func (s *DescribeFlowLogsResponse) SetStatusCode(v int32) *DescribeFlowLogsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeFlowLogsResponse) SetBody(v *DescribeFlowLogsResponseBody) *DescribeFlowLogsResponse {
	s.Body = v
	return s
}

type DescribeForwardTableEntriesRequest struct {
	// *   The elastic IP addresses (EIPs) that can be accessed over the Internet when you query DNAT entries of Internet NAT gateways.
	// *   The NAT IP addresses that can be accessed by external networks when you query DNAT entries of Virtual Private Cloud (VPC) NAT gateways.
	ExternalIp *string `json:"ExternalIp,omitempty" xml:"ExternalIp,omitempty"`
	// *   The external port or port range that is used for port forwarding when you query DNAT entries of Internet NAT gateways.
	//
	//     *   Valid values: **1** to **65535**.
	//     *   If you want to query a port range, separate the first port and last port with a forward slash (/), such as `10/20`.
	//     *   If you set **ExternalPort** to a port range, you must also set **InternalPort** to a port range, and the number of ports specified by these parameters must be the same. For example, if you set **ExternalPort** to `10/20`, you can set **InternalPort** to `80/90`.
	//
	// *   The port that is used when the NAT IP address can be accessed by external networks when you query DNAT entries of VPC NAT gateways. Valid values: **1** to **65535**.
	ExternalPort *string `json:"ExternalPort,omitempty" xml:"ExternalPort,omitempty"`
	// The ID of the DNAT entry.
	ForwardEntryId *string `json:"ForwardEntryId,omitempty" xml:"ForwardEntryId,omitempty"`
	// The name of the DNAT entry.
	//
	// The name must be 2 to 128 characters in length, and can contain digits, periods (.), underscores (\_), and hyphens (-). It must start with a letter.
	ForwardEntryName *string `json:"ForwardEntryName,omitempty" xml:"ForwardEntryName,omitempty"`
	// The ID of the DNAT table.
	//
	// >  You must set at least one of the **ForwardTableId** and **NatGatewayId** parameters.
	ForwardTableId *string `json:"ForwardTableId,omitempty" xml:"ForwardTableId,omitempty"`
	// The private IP address.
	//
	// *   The private IP address of the ECS instance that uses DNAT entries to communicate with the Internet when you query DNAT entries of Internet NAT gateways.
	// *   The private IP address that uses DNAT entries for communication when you query DNAT entries of VPC NAT gateways.
	InternalIp *string `json:"InternalIp,omitempty" xml:"InternalIp,omitempty"`
	// *   The internal port or port range that is used for port forwarding when you query DNAT entries of Internet NAT gateways. Valid values: **1** to **65535**.
	// *   The port of the destination ECS instance to be mapped when you query DNAT entries of VPC NAT gateways. Valid values: **1** to **65535**.
	InternalPort *string `json:"InternalPort,omitempty" xml:"InternalPort,omitempty"`
	// The protocol. Valid values:
	//
	// *   **TCP**: The NAT gateway forwards TCP packets.
	// *   **UDP**: The NAT gateway forwards UDP packets.
	// *   **Any**: The NAT gateway forwards packets of all protocols.
	IpProtocol *string `json:"IpProtocol,omitempty" xml:"IpProtocol,omitempty"`
	// The ID of the NAT gateway.
	//
	// >  You must set at least one of the **ForwardTableId** and **NatGatewayId** parameters.
	NatGatewayId *string `json:"NatGatewayId,omitempty" xml:"NatGatewayId,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The page number of the page to return. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Maximum value: **50**. Default value: **10**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The region ID of the NAT gateway.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeForwardTableEntriesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeForwardTableEntriesRequest) GoString() string {
	return s.String()
}

func (s *DescribeForwardTableEntriesRequest) SetExternalIp(v string) *DescribeForwardTableEntriesRequest {
	s.ExternalIp = &v
	return s
}

func (s *DescribeForwardTableEntriesRequest) SetExternalPort(v string) *DescribeForwardTableEntriesRequest {
	s.ExternalPort = &v
	return s
}

func (s *DescribeForwardTableEntriesRequest) SetForwardEntryId(v string) *DescribeForwardTableEntriesRequest {
	s.ForwardEntryId = &v
	return s
}

func (s *DescribeForwardTableEntriesRequest) SetForwardEntryName(v string) *DescribeForwardTableEntriesRequest {
	s.ForwardEntryName = &v
	return s
}

func (s *DescribeForwardTableEntriesRequest) SetForwardTableId(v string) *DescribeForwardTableEntriesRequest {
	s.ForwardTableId = &v
	return s
}

func (s *DescribeForwardTableEntriesRequest) SetInternalIp(v string) *DescribeForwardTableEntriesRequest {
	s.InternalIp = &v
	return s
}

func (s *DescribeForwardTableEntriesRequest) SetInternalPort(v string) *DescribeForwardTableEntriesRequest {
	s.InternalPort = &v
	return s
}

func (s *DescribeForwardTableEntriesRequest) SetIpProtocol(v string) *DescribeForwardTableEntriesRequest {
	s.IpProtocol = &v
	return s
}

func (s *DescribeForwardTableEntriesRequest) SetNatGatewayId(v string) *DescribeForwardTableEntriesRequest {
	s.NatGatewayId = &v
	return s
}

func (s *DescribeForwardTableEntriesRequest) SetOwnerAccount(v string) *DescribeForwardTableEntriesRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeForwardTableEntriesRequest) SetOwnerId(v int64) *DescribeForwardTableEntriesRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeForwardTableEntriesRequest) SetPageNumber(v int32) *DescribeForwardTableEntriesRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeForwardTableEntriesRequest) SetPageSize(v int32) *DescribeForwardTableEntriesRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeForwardTableEntriesRequest) SetRegionId(v string) *DescribeForwardTableEntriesRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeForwardTableEntriesRequest) SetResourceOwnerAccount(v string) *DescribeForwardTableEntriesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeForwardTableEntriesRequest) SetResourceOwnerId(v int64) *DescribeForwardTableEntriesRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeForwardTableEntriesResponseBody struct {
	// The details of DNAT entries.
	ForwardTableEntries *DescribeForwardTableEntriesResponseBodyForwardTableEntries `json:"ForwardTableEntries,omitempty" xml:"ForwardTableEntries,omitempty" type:"Struct"`
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeForwardTableEntriesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeForwardTableEntriesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeForwardTableEntriesResponseBody) SetForwardTableEntries(v *DescribeForwardTableEntriesResponseBodyForwardTableEntries) *DescribeForwardTableEntriesResponseBody {
	s.ForwardTableEntries = v
	return s
}

func (s *DescribeForwardTableEntriesResponseBody) SetPageNumber(v int32) *DescribeForwardTableEntriesResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeForwardTableEntriesResponseBody) SetPageSize(v int32) *DescribeForwardTableEntriesResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeForwardTableEntriesResponseBody) SetRequestId(v string) *DescribeForwardTableEntriesResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeForwardTableEntriesResponseBody) SetTotalCount(v int32) *DescribeForwardTableEntriesResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeForwardTableEntriesResponseBodyForwardTableEntries struct {
	ForwardTableEntry []*DescribeForwardTableEntriesResponseBodyForwardTableEntriesForwardTableEntry `json:"ForwardTableEntry,omitempty" xml:"ForwardTableEntry,omitempty" type:"Repeated"`
}

func (s DescribeForwardTableEntriesResponseBodyForwardTableEntries) String() string {
	return tea.Prettify(s)
}

func (s DescribeForwardTableEntriesResponseBodyForwardTableEntries) GoString() string {
	return s.String()
}

func (s *DescribeForwardTableEntriesResponseBodyForwardTableEntries) SetForwardTableEntry(v []*DescribeForwardTableEntriesResponseBodyForwardTableEntriesForwardTableEntry) *DescribeForwardTableEntriesResponseBodyForwardTableEntries {
	s.ForwardTableEntry = v
	return s
}

type DescribeForwardTableEntriesResponseBodyForwardTableEntriesForwardTableEntry struct {
	// *   The EIPs that can be accessed over the Internet when you query DNAT entries of Internet NAT gateways.
	// *   The NAT IP addresses that can be accessed by external networks when you query DNAT entries of VPC NAT gateways.
	ExternalIp *string `json:"ExternalIp,omitempty" xml:"ExternalIp,omitempty"`
	// *   The external port or port range that is used for port forwarding when you query DNAT entries of Internet NAT gateways.
	// *   The port that is used when the NAT IP address can be accessed by external networks when you query DNAT entries of VPC NAT gateways.
	ExternalPort *string `json:"ExternalPort,omitempty" xml:"ExternalPort,omitempty"`
	// The ID of the DNAT entry.
	ForwardEntryId *string `json:"ForwardEntryId,omitempty" xml:"ForwardEntryId,omitempty"`
	// The name of the DNAT entry.
	ForwardEntryName *string `json:"ForwardEntryName,omitempty" xml:"ForwardEntryName,omitempty"`
	// The ID of the DNAT table to which the DNAT entry belongs.
	ForwardTableId *string `json:"ForwardTableId,omitempty" xml:"ForwardTableId,omitempty"`
	// The private IP address.
	//
	// *   The private IP address of the ECS instance that uses DNAT entries to communicate with the Internet when you query DNAT entries of Internet NAT gateways.
	// *   The private IP address that uses DNAT entries when you query DNAT entries of VPC NAT gateways.
	InternalIp *string `json:"InternalIp,omitempty" xml:"InternalIp,omitempty"`
	// *   The internal port or port range that is used for port forwarding when you query DNAT entries of Internet NAT gateways.
	// *   The destination ECS instance port to be mapped when you query DNAT entries of VPC NAT gateways.
	InternalPort *string `json:"InternalPort,omitempty" xml:"InternalPort,omitempty"`
	// The protocol. Valid values:
	//
	// *   **TCP**: The NAT gateway forwards TCP packets.
	// *   **UDP**: The NAT gateway forwards UDP packets.
	// *   **Any**: The NAT gateway forwards packets of all protocols.
	IpProtocol *string `json:"IpProtocol,omitempty" xml:"IpProtocol,omitempty"`
	// The status of the DNAT entry. Valid values:
	//
	// *   **Pending**: being created or modified
	// *   **Available**: available
	// *   **Deleting**: being deleted
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeForwardTableEntriesResponseBodyForwardTableEntriesForwardTableEntry) String() string {
	return tea.Prettify(s)
}

func (s DescribeForwardTableEntriesResponseBodyForwardTableEntriesForwardTableEntry) GoString() string {
	return s.String()
}

func (s *DescribeForwardTableEntriesResponseBodyForwardTableEntriesForwardTableEntry) SetExternalIp(v string) *DescribeForwardTableEntriesResponseBodyForwardTableEntriesForwardTableEntry {
	s.ExternalIp = &v
	return s
}

func (s *DescribeForwardTableEntriesResponseBodyForwardTableEntriesForwardTableEntry) SetExternalPort(v string) *DescribeForwardTableEntriesResponseBodyForwardTableEntriesForwardTableEntry {
	s.ExternalPort = &v
	return s
}

func (s *DescribeForwardTableEntriesResponseBodyForwardTableEntriesForwardTableEntry) SetForwardEntryId(v string) *DescribeForwardTableEntriesResponseBodyForwardTableEntriesForwardTableEntry {
	s.ForwardEntryId = &v
	return s
}

func (s *DescribeForwardTableEntriesResponseBodyForwardTableEntriesForwardTableEntry) SetForwardEntryName(v string) *DescribeForwardTableEntriesResponseBodyForwardTableEntriesForwardTableEntry {
	s.ForwardEntryName = &v
	return s
}

func (s *DescribeForwardTableEntriesResponseBodyForwardTableEntriesForwardTableEntry) SetForwardTableId(v string) *DescribeForwardTableEntriesResponseBodyForwardTableEntriesForwardTableEntry {
	s.ForwardTableId = &v
	return s
}

func (s *DescribeForwardTableEntriesResponseBodyForwardTableEntriesForwardTableEntry) SetInternalIp(v string) *DescribeForwardTableEntriesResponseBodyForwardTableEntriesForwardTableEntry {
	s.InternalIp = &v
	return s
}

func (s *DescribeForwardTableEntriesResponseBodyForwardTableEntriesForwardTableEntry) SetInternalPort(v string) *DescribeForwardTableEntriesResponseBodyForwardTableEntriesForwardTableEntry {
	s.InternalPort = &v
	return s
}

func (s *DescribeForwardTableEntriesResponseBodyForwardTableEntriesForwardTableEntry) SetIpProtocol(v string) *DescribeForwardTableEntriesResponseBodyForwardTableEntriesForwardTableEntry {
	s.IpProtocol = &v
	return s
}

func (s *DescribeForwardTableEntriesResponseBodyForwardTableEntriesForwardTableEntry) SetStatus(v string) *DescribeForwardTableEntriesResponseBodyForwardTableEntriesForwardTableEntry {
	s.Status = &v
	return s
}

type DescribeForwardTableEntriesResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeForwardTableEntriesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeForwardTableEntriesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeForwardTableEntriesResponse) GoString() string {
	return s.String()
}

func (s *DescribeForwardTableEntriesResponse) SetHeaders(v map[string]*string) *DescribeForwardTableEntriesResponse {
	s.Headers = v
	return s
}

func (s *DescribeForwardTableEntriesResponse) SetStatusCode(v int32) *DescribeForwardTableEntriesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeForwardTableEntriesResponse) SetBody(v *DescribeForwardTableEntriesResponseBody) *DescribeForwardTableEntriesResponse {
	s.Body = v
	return s
}

type DescribeGlobalAccelerationInstancesRequest struct {
	// The bandwidth type of the GA instance. Valid values:
	//
	// *   **Sharing**
	// *   **Exclusive** (default)
	BandwidthType *string `json:"BandwidthType,omitempty" xml:"BandwidthType,omitempty"`
	// The ID of the GA instance.
	GlobalAccelerationInstanceId *string `json:"GlobalAccelerationInstanceId,omitempty" xml:"GlobalAccelerationInstanceId,omitempty"`
	// Specifies whether to return information about pending orders. Valid values:
	//
	// *   **false** (default)
	// *   **true**
	IncludeReservationData *bool `json:"IncludeReservationData,omitempty" xml:"IncludeReservationData,omitempty"`
	// The public IP address of the GA instance.
	IpAddress *string `json:"IpAddress,omitempty" xml:"IpAddress,omitempty"`
	// The name of the GA instance.
	Name         *string `json:"Name,omitempty" xml:"Name,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of the page to return. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Maximum value: **100**. Default value: **10**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The region ID of the GA instance. You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the backend service instance.
	ServerId *string `json:"ServerId,omitempty" xml:"ServerId,omitempty"`
	// The region of the backend service. Valid values:
	//
	// *   **china-mainland**
	// *   **north-america**
	// *   **asia-pacific**
	// *   **europe**
	ServiceLocation *string `json:"ServiceLocation,omitempty" xml:"ServiceLocation,omitempty"`
	// The status of the GA instance. Valid values:
	//
	// *   **Available**
	// *   **Inuse**
	// *   **Associating**
	// *   **Unassociating**
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeGlobalAccelerationInstancesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeGlobalAccelerationInstancesRequest) GoString() string {
	return s.String()
}

func (s *DescribeGlobalAccelerationInstancesRequest) SetBandwidthType(v string) *DescribeGlobalAccelerationInstancesRequest {
	s.BandwidthType = &v
	return s
}

func (s *DescribeGlobalAccelerationInstancesRequest) SetGlobalAccelerationInstanceId(v string) *DescribeGlobalAccelerationInstancesRequest {
	s.GlobalAccelerationInstanceId = &v
	return s
}

func (s *DescribeGlobalAccelerationInstancesRequest) SetIncludeReservationData(v bool) *DescribeGlobalAccelerationInstancesRequest {
	s.IncludeReservationData = &v
	return s
}

func (s *DescribeGlobalAccelerationInstancesRequest) SetIpAddress(v string) *DescribeGlobalAccelerationInstancesRequest {
	s.IpAddress = &v
	return s
}

func (s *DescribeGlobalAccelerationInstancesRequest) SetName(v string) *DescribeGlobalAccelerationInstancesRequest {
	s.Name = &v
	return s
}

func (s *DescribeGlobalAccelerationInstancesRequest) SetOwnerAccount(v string) *DescribeGlobalAccelerationInstancesRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeGlobalAccelerationInstancesRequest) SetOwnerId(v int64) *DescribeGlobalAccelerationInstancesRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeGlobalAccelerationInstancesRequest) SetPageNumber(v int32) *DescribeGlobalAccelerationInstancesRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeGlobalAccelerationInstancesRequest) SetPageSize(v int32) *DescribeGlobalAccelerationInstancesRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeGlobalAccelerationInstancesRequest) SetRegionId(v string) *DescribeGlobalAccelerationInstancesRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeGlobalAccelerationInstancesRequest) SetResourceOwnerAccount(v string) *DescribeGlobalAccelerationInstancesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeGlobalAccelerationInstancesRequest) SetResourceOwnerId(v int64) *DescribeGlobalAccelerationInstancesRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeGlobalAccelerationInstancesRequest) SetServerId(v string) *DescribeGlobalAccelerationInstancesRequest {
	s.ServerId = &v
	return s
}

func (s *DescribeGlobalAccelerationInstancesRequest) SetServiceLocation(v string) *DescribeGlobalAccelerationInstancesRequest {
	s.ServiceLocation = &v
	return s
}

func (s *DescribeGlobalAccelerationInstancesRequest) SetStatus(v string) *DescribeGlobalAccelerationInstancesRequest {
	s.Status = &v
	return s
}

type DescribeGlobalAccelerationInstancesResponseBody struct {
	// The details of the GA instances.
	GlobalAccelerationInstances *DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstances `json:"GlobalAccelerationInstances,omitempty" xml:"GlobalAccelerationInstances,omitempty" type:"Struct"`
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeGlobalAccelerationInstancesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeGlobalAccelerationInstancesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeGlobalAccelerationInstancesResponseBody) SetGlobalAccelerationInstances(v *DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstances) *DescribeGlobalAccelerationInstancesResponseBody {
	s.GlobalAccelerationInstances = v
	return s
}

func (s *DescribeGlobalAccelerationInstancesResponseBody) SetPageNumber(v int32) *DescribeGlobalAccelerationInstancesResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeGlobalAccelerationInstancesResponseBody) SetPageSize(v int32) *DescribeGlobalAccelerationInstancesResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeGlobalAccelerationInstancesResponseBody) SetRequestId(v string) *DescribeGlobalAccelerationInstancesResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeGlobalAccelerationInstancesResponseBody) SetTotalCount(v int32) *DescribeGlobalAccelerationInstancesResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstances struct {
	GlobalAccelerationInstance []*DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstance `json:"GlobalAccelerationInstance,omitempty" xml:"GlobalAccelerationInstance,omitempty" type:"Repeated"`
}

func (s DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstances) String() string {
	return tea.Prettify(s)
}

func (s DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstances) GoString() string {
	return s.String()
}

func (s *DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstances) SetGlobalAccelerationInstance(v []*DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstance) *DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstances {
	s.GlobalAccelerationInstance = v
	return s
}

type DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstance struct {
	// The acceleration area of the GA instance.
	AccelerationLocation *string `json:"AccelerationLocation,omitempty" xml:"AccelerationLocation,omitempty"`
	// The details about the backend servers of the GA instance.
	BackendServers *DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstanceBackendServers `json:"BackendServers,omitempty" xml:"BackendServers,omitempty" type:"Struct"`
	// The maximum bandwidth of the GA instance.
	Bandwidth *string `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	// The bandwidth type of the GA instance.
	//
	// *   **Sharing**
	// *   **Exclusive** (default)
	BandwidthType *string `json:"BandwidthType,omitempty" xml:"BandwidthType,omitempty"`
	// The billing method of the GA instance.
	ChargeType *string `json:"ChargeType,omitempty" xml:"ChargeType,omitempty"`
	// The time when the GA instance was created. The time is displayed in UTC.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The description of the GA instance.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The time when the instance expires.
	ExpiredTime *string `json:"ExpiredTime,omitempty" xml:"ExpiredTime,omitempty"`
	// The ID of the GA instance.
	GlobalAccelerationInstanceId *string `json:"GlobalAccelerationInstanceId,omitempty" xml:"GlobalAccelerationInstanceId,omitempty"`
	// The billing method of the GA instance.
	InternetChargeType *string `json:"InternetChargeType,omitempty" xml:"InternetChargeType,omitempty"`
	// The public IP address of the dedicated GA instance.
	IpAddress *string `json:"IpAddress,omitempty" xml:"IpAddress,omitempty"`
	// The name of the GA instance.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The public IP address.
	PublicIpAddresses *DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstancePublicIpAddresses `json:"PublicIpAddresses,omitempty" xml:"PublicIpAddresses,omitempty" type:"Struct"`
	// The region ID of the GA instance.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The service area of the GA instance.
	ServiceLocation *string `json:"ServiceLocation,omitempty" xml:"ServiceLocation,omitempty"`
	// The status of the GA instance.
	//
	// *   **Available**
	// *   **Inuse**
	// *   **Associating**
	// *   **Unassociating**
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstance) String() string {
	return tea.Prettify(s)
}

func (s DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstance) GoString() string {
	return s.String()
}

func (s *DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstance) SetAccelerationLocation(v string) *DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstance {
	s.AccelerationLocation = &v
	return s
}

func (s *DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstance) SetBackendServers(v *DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstanceBackendServers) *DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstance {
	s.BackendServers = v
	return s
}

func (s *DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstance) SetBandwidth(v string) *DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstance {
	s.Bandwidth = &v
	return s
}

func (s *DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstance) SetBandwidthType(v string) *DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstance {
	s.BandwidthType = &v
	return s
}

func (s *DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstance) SetChargeType(v string) *DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstance {
	s.ChargeType = &v
	return s
}

func (s *DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstance) SetCreationTime(v string) *DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstance {
	s.CreationTime = &v
	return s
}

func (s *DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstance) SetDescription(v string) *DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstance {
	s.Description = &v
	return s
}

func (s *DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstance) SetExpiredTime(v string) *DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstance {
	s.ExpiredTime = &v
	return s
}

func (s *DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstance) SetGlobalAccelerationInstanceId(v string) *DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstance {
	s.GlobalAccelerationInstanceId = &v
	return s
}

func (s *DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstance) SetInternetChargeType(v string) *DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstance {
	s.InternetChargeType = &v
	return s
}

func (s *DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstance) SetIpAddress(v string) *DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstance {
	s.IpAddress = &v
	return s
}

func (s *DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstance) SetName(v string) *DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstance {
	s.Name = &v
	return s
}

func (s *DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstance) SetPublicIpAddresses(v *DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstancePublicIpAddresses) *DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstance {
	s.PublicIpAddresses = v
	return s
}

func (s *DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstance) SetRegionId(v string) *DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstance {
	s.RegionId = &v
	return s
}

func (s *DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstance) SetServiceLocation(v string) *DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstance {
	s.ServiceLocation = &v
	return s
}

func (s *DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstance) SetStatus(v string) *DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstance {
	s.Status = &v
	return s
}

type DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstanceBackendServers struct {
	BackendServer []*DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstanceBackendServersBackendServer `json:"BackendServer,omitempty" xml:"BackendServer,omitempty" type:"Repeated"`
}

func (s DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstanceBackendServers) String() string {
	return tea.Prettify(s)
}

func (s DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstanceBackendServers) GoString() string {
	return s.String()
}

func (s *DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstanceBackendServers) SetBackendServer(v []*DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstanceBackendServersBackendServer) *DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstanceBackendServers {
	s.BackendServer = v
	return s
}

type DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstanceBackendServersBackendServer struct {
	// The region where the backend servers are deployed.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the backend server.
	ServerId *string `json:"ServerId,omitempty" xml:"ServerId,omitempty"`
	// The IP address of the backend server.
	ServerIpAddress *string `json:"ServerIpAddress,omitempty" xml:"ServerIpAddress,omitempty"`
	// The type of the backend server.
	//
	// *   **EcsInstance**: Elastic Compute Service (ECS) instance
	// *   **SlbInstance**: Server Load Balancer (SLB) instance
	ServerType *string `json:"ServerType,omitempty" xml:"ServerType,omitempty"`
}

func (s DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstanceBackendServersBackendServer) String() string {
	return tea.Prettify(s)
}

func (s DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstanceBackendServersBackendServer) GoString() string {
	return s.String()
}

func (s *DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstanceBackendServersBackendServer) SetRegionId(v string) *DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstanceBackendServersBackendServer {
	s.RegionId = &v
	return s
}

func (s *DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstanceBackendServersBackendServer) SetServerId(v string) *DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstanceBackendServersBackendServer {
	s.ServerId = &v
	return s
}

func (s *DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstanceBackendServersBackendServer) SetServerIpAddress(v string) *DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstanceBackendServersBackendServer {
	s.ServerIpAddress = &v
	return s
}

func (s *DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstanceBackendServersBackendServer) SetServerType(v string) *DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstanceBackendServersBackendServer {
	s.ServerType = &v
	return s
}

type DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstancePublicIpAddresses struct {
	PublicIpAddress []*DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstancePublicIpAddressesPublicIpAddress `json:"PublicIpAddress,omitempty" xml:"PublicIpAddress,omitempty" type:"Repeated"`
}

func (s DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstancePublicIpAddresses) String() string {
	return tea.Prettify(s)
}

func (s DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstancePublicIpAddresses) GoString() string {
	return s.String()
}

func (s *DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstancePublicIpAddresses) SetPublicIpAddress(v []*DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstancePublicIpAddressesPublicIpAddress) *DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstancePublicIpAddresses {
	s.PublicIpAddress = v
	return s
}

type DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstancePublicIpAddressesPublicIpAddress struct {
	// The ID of the public IP address of the GA instance.
	AllocationId *string `json:"AllocationId,omitempty" xml:"AllocationId,omitempty"`
	// The public IP address of the GA instance.
	IpAddress *string `json:"IpAddress,omitempty" xml:"IpAddress,omitempty"`
}

func (s DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstancePublicIpAddressesPublicIpAddress) String() string {
	return tea.Prettify(s)
}

func (s DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstancePublicIpAddressesPublicIpAddress) GoString() string {
	return s.String()
}

func (s *DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstancePublicIpAddressesPublicIpAddress) SetAllocationId(v string) *DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstancePublicIpAddressesPublicIpAddress {
	s.AllocationId = &v
	return s
}

func (s *DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstancePublicIpAddressesPublicIpAddress) SetIpAddress(v string) *DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstancePublicIpAddressesPublicIpAddress {
	s.IpAddress = &v
	return s
}

type DescribeGlobalAccelerationInstancesResponse struct {
	Headers    map[string]*string                               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeGlobalAccelerationInstancesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeGlobalAccelerationInstancesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeGlobalAccelerationInstancesResponse) GoString() string {
	return s.String()
}

func (s *DescribeGlobalAccelerationInstancesResponse) SetHeaders(v map[string]*string) *DescribeGlobalAccelerationInstancesResponse {
	s.Headers = v
	return s
}

func (s *DescribeGlobalAccelerationInstancesResponse) SetStatusCode(v int32) *DescribeGlobalAccelerationInstancesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeGlobalAccelerationInstancesResponse) SetBody(v *DescribeGlobalAccelerationInstancesResponseBody) *DescribeGlobalAccelerationInstancesResponse {
	s.Body = v
	return s
}

type DescribeGrantRulesToCenRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among all requests. ClientToken can contain only ASCII characters.
	//
	// >  If you do not specify this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the network instance that you want to query.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The type of the network instance. Valid values:
	//
	// *   **VPC**
	// *   **VBR**
	// *   **CCN**
	InstanceType *string `json:"InstanceType,omitempty" xml:"InstanceType,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of the page to return. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Maximum value: **50**. Default value: **10**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The region ID of the network instance that you want to query.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group to which the network instance belongs.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeGrantRulesToCenRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeGrantRulesToCenRequest) GoString() string {
	return s.String()
}

func (s *DescribeGrantRulesToCenRequest) SetClientToken(v string) *DescribeGrantRulesToCenRequest {
	s.ClientToken = &v
	return s
}

func (s *DescribeGrantRulesToCenRequest) SetInstanceId(v string) *DescribeGrantRulesToCenRequest {
	s.InstanceId = &v
	return s
}

func (s *DescribeGrantRulesToCenRequest) SetInstanceType(v string) *DescribeGrantRulesToCenRequest {
	s.InstanceType = &v
	return s
}

func (s *DescribeGrantRulesToCenRequest) SetOwnerAccount(v string) *DescribeGrantRulesToCenRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeGrantRulesToCenRequest) SetOwnerId(v int64) *DescribeGrantRulesToCenRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeGrantRulesToCenRequest) SetPageNumber(v int32) *DescribeGrantRulesToCenRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeGrantRulesToCenRequest) SetPageSize(v int32) *DescribeGrantRulesToCenRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeGrantRulesToCenRequest) SetRegionId(v string) *DescribeGrantRulesToCenRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeGrantRulesToCenRequest) SetResourceGroupId(v string) *DescribeGrantRulesToCenRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeGrantRulesToCenRequest) SetResourceOwnerAccount(v string) *DescribeGrantRulesToCenRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeGrantRulesToCenRequest) SetResourceOwnerId(v int64) *DescribeGrantRulesToCenRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeGrantRulesToCenResponseBody struct {
	// The information about the authorization.
	CenGrantRules *DescribeGrantRulesToCenResponseBodyCenGrantRules `json:"CenGrantRules,omitempty" xml:"CenGrantRules,omitempty" type:"Struct"`
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeGrantRulesToCenResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeGrantRulesToCenResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeGrantRulesToCenResponseBody) SetCenGrantRules(v *DescribeGrantRulesToCenResponseBodyCenGrantRules) *DescribeGrantRulesToCenResponseBody {
	s.CenGrantRules = v
	return s
}

func (s *DescribeGrantRulesToCenResponseBody) SetPageNumber(v int32) *DescribeGrantRulesToCenResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeGrantRulesToCenResponseBody) SetPageSize(v int32) *DescribeGrantRulesToCenResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeGrantRulesToCenResponseBody) SetRequestId(v string) *DescribeGrantRulesToCenResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeGrantRulesToCenResponseBody) SetTotalCount(v int32) *DescribeGrantRulesToCenResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeGrantRulesToCenResponseBodyCenGrantRules struct {
	CbnGrantRule []*DescribeGrantRulesToCenResponseBodyCenGrantRulesCbnGrantRule `json:"CbnGrantRule,omitempty" xml:"CbnGrantRule,omitempty" type:"Repeated"`
}

func (s DescribeGrantRulesToCenResponseBodyCenGrantRules) String() string {
	return tea.Prettify(s)
}

func (s DescribeGrantRulesToCenResponseBodyCenGrantRules) GoString() string {
	return s.String()
}

func (s *DescribeGrantRulesToCenResponseBodyCenGrantRules) SetCbnGrantRule(v []*DescribeGrantRulesToCenResponseBodyCenGrantRulesCbnGrantRule) *DescribeGrantRulesToCenResponseBodyCenGrantRules {
	s.CbnGrantRule = v
	return s
}

type DescribeGrantRulesToCenResponseBodyCenGrantRulesCbnGrantRule struct {
	// The ID of the authorized CEN instance.
	CenInstanceId *string `json:"CenInstanceId,omitempty" xml:"CenInstanceId,omitempty"`
	// The UID of the Alibaba Cloud account to which the authorized CEN instance belongs.
	CenOwnerId *int64 `json:"CenOwnerId,omitempty" xml:"CenOwnerId,omitempty"`
	// The time when the instance was created.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
}

func (s DescribeGrantRulesToCenResponseBodyCenGrantRulesCbnGrantRule) String() string {
	return tea.Prettify(s)
}

func (s DescribeGrantRulesToCenResponseBodyCenGrantRulesCbnGrantRule) GoString() string {
	return s.String()
}

func (s *DescribeGrantRulesToCenResponseBodyCenGrantRulesCbnGrantRule) SetCenInstanceId(v string) *DescribeGrantRulesToCenResponseBodyCenGrantRulesCbnGrantRule {
	s.CenInstanceId = &v
	return s
}

func (s *DescribeGrantRulesToCenResponseBodyCenGrantRulesCbnGrantRule) SetCenOwnerId(v int64) *DescribeGrantRulesToCenResponseBodyCenGrantRulesCbnGrantRule {
	s.CenOwnerId = &v
	return s
}

func (s *DescribeGrantRulesToCenResponseBodyCenGrantRulesCbnGrantRule) SetCreationTime(v string) *DescribeGrantRulesToCenResponseBodyCenGrantRulesCbnGrantRule {
	s.CreationTime = &v
	return s
}

type DescribeGrantRulesToCenResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeGrantRulesToCenResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeGrantRulesToCenResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeGrantRulesToCenResponse) GoString() string {
	return s.String()
}

func (s *DescribeGrantRulesToCenResponse) SetHeaders(v map[string]*string) *DescribeGrantRulesToCenResponse {
	s.Headers = v
	return s
}

func (s *DescribeGrantRulesToCenResponse) SetStatusCode(v int32) *DescribeGrantRulesToCenResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeGrantRulesToCenResponse) SetBody(v *DescribeGrantRulesToCenResponseBody) *DescribeGrantRulesToCenResponse {
	s.Body = v
	return s
}

type DescribeHaVipsRequest struct {
	Filter       []*DescribeHaVipsRequestFilter `json:"Filter,omitempty" xml:"Filter,omitempty" type:"Repeated"`
	OwnerAccount *string                        `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64                         `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of the page to return. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Maximum value: **50**. Default value: **10**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the region to which the HAVIP belongs.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group to which the HAVIP belongs.
	ResourceGroupId      *string                      `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string                      `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64                       `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	Tags                 []*DescribeHaVipsRequestTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
}

func (s DescribeHaVipsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeHaVipsRequest) GoString() string {
	return s.String()
}

func (s *DescribeHaVipsRequest) SetFilter(v []*DescribeHaVipsRequestFilter) *DescribeHaVipsRequest {
	s.Filter = v
	return s
}

func (s *DescribeHaVipsRequest) SetOwnerAccount(v string) *DescribeHaVipsRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeHaVipsRequest) SetOwnerId(v int64) *DescribeHaVipsRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeHaVipsRequest) SetPageNumber(v int32) *DescribeHaVipsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeHaVipsRequest) SetPageSize(v int32) *DescribeHaVipsRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeHaVipsRequest) SetRegionId(v string) *DescribeHaVipsRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeHaVipsRequest) SetResourceGroupId(v string) *DescribeHaVipsRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeHaVipsRequest) SetResourceOwnerAccount(v string) *DescribeHaVipsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeHaVipsRequest) SetResourceOwnerId(v int64) *DescribeHaVipsRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeHaVipsRequest) SetTags(v []*DescribeHaVipsRequestTags) *DescribeHaVipsRequest {
	s.Tags = v
	return s
}

type DescribeHaVipsRequestFilter struct {
	// The filter keys. You can specify at most five filter keys. Valid values of **N**: **1 to 5**.
	//
	// The following filter keys are supported:
	//
	// *   **VpcId**: virtual private cloud (VPC) ID
	// *   **VSwitchId**: vSwitch ID
	// *   **Status**: HAVIP status
	// *   **HaVipId**: HAVIP ID
	// *   **HaVipAddress**: HAVIP IP address
	//
	// You can specify multiple values for each filter key. The logical operator among multiple values is OR. If one value is matched, the filter key is matched.
	//
	// The logical operator among multiple filter keys is AND. HAVIPs can be queried only if all filter keys are matched.
	Key   *string   `json:"Key,omitempty" xml:"Key,omitempty"`
	Value []*string `json:"Value,omitempty" xml:"Value,omitempty" type:"Repeated"`
}

func (s DescribeHaVipsRequestFilter) String() string {
	return tea.Prettify(s)
}

func (s DescribeHaVipsRequestFilter) GoString() string {
	return s.String()
}

func (s *DescribeHaVipsRequestFilter) SetKey(v string) *DescribeHaVipsRequestFilter {
	s.Key = &v
	return s
}

func (s *DescribeHaVipsRequestFilter) SetValue(v []*string) *DescribeHaVipsRequestFilter {
	s.Value = v
	return s
}

type DescribeHaVipsRequestTags struct {
	// The tag key. You can specify at most 20 tag keys. It cannot be an empty string.
	//
	// The key cannot exceed 64 characters in length, and can contain digits, periods (.), underscores (\_), and hyphens (-). The key must start with a letter but cannot start with `aliyun` or `acs:`. The key cannot contain `http://` or `https://`.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value. You can specify at most 20 tag values. It can be an empty string.
	//
	// The tag value cannot exceed 128 characters in length, and can contain digits, periods (.), underscores (\_), and hyphens (-). It must start with a letter but cannot start with `aliyun` or `acs:`. It cannot contain `http://` or `https://`.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeHaVipsRequestTags) String() string {
	return tea.Prettify(s)
}

func (s DescribeHaVipsRequestTags) GoString() string {
	return s.String()
}

func (s *DescribeHaVipsRequestTags) SetKey(v string) *DescribeHaVipsRequestTags {
	s.Key = &v
	return s
}

func (s *DescribeHaVipsRequestTags) SetValue(v string) *DescribeHaVipsRequestTags {
	s.Value = &v
	return s
}

type DescribeHaVipsResponseBody struct {
	// The details about the HAVIP.
	HaVips *DescribeHaVipsResponseBodyHaVips `json:"HaVips,omitempty" xml:"HaVips,omitempty" type:"Struct"`
	// The number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeHaVipsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeHaVipsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeHaVipsResponseBody) SetHaVips(v *DescribeHaVipsResponseBodyHaVips) *DescribeHaVipsResponseBody {
	s.HaVips = v
	return s
}

func (s *DescribeHaVipsResponseBody) SetPageNumber(v int32) *DescribeHaVipsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeHaVipsResponseBody) SetPageSize(v int32) *DescribeHaVipsResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeHaVipsResponseBody) SetRequestId(v string) *DescribeHaVipsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeHaVipsResponseBody) SetTotalCount(v int32) *DescribeHaVipsResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeHaVipsResponseBodyHaVips struct {
	HaVip []*DescribeHaVipsResponseBodyHaVipsHaVip `json:"HaVip,omitempty" xml:"HaVip,omitempty" type:"Repeated"`
}

func (s DescribeHaVipsResponseBodyHaVips) String() string {
	return tea.Prettify(s)
}

func (s DescribeHaVipsResponseBodyHaVips) GoString() string {
	return s.String()
}

func (s *DescribeHaVipsResponseBodyHaVips) SetHaVip(v []*DescribeHaVipsResponseBodyHaVipsHaVip) *DescribeHaVipsResponseBodyHaVips {
	s.HaVip = v
	return s
}

type DescribeHaVipsResponseBodyHaVipsHaVip struct {
	// The elastic IP address (EIP) associated with the HAVIP.
	AssociatedEipAddresses *DescribeHaVipsResponseBodyHaVipsHaVipAssociatedEipAddresses `json:"AssociatedEipAddresses,omitempty" xml:"AssociatedEipAddresses,omitempty" type:"Struct"`
	// The type of the instance with which the HAVIP is associated. Valid values:
	//
	// *   **EcsInstance**: an ECS instance
	// *   **NetworkInterface**: an ENI
	AssociatedInstanceType *string `json:"AssociatedInstanceType,omitempty" xml:"AssociatedInstanceType,omitempty"`
	// The ID of the instance with which the HAVIP is associated.
	AssociatedInstances *DescribeHaVipsResponseBodyHaVipsHaVipAssociatedInstances `json:"AssociatedInstances,omitempty" xml:"AssociatedInstances,omitempty" type:"Struct"`
	// The parameter is invalid. No value is returned.
	ChargeType *string `json:"ChargeType,omitempty" xml:"ChargeType,omitempty"`
	// The time when the HAVIP was created.
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The description of the HAVIP.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the HAVIP.
	HaVipId *string `json:"HaVipId,omitempty" xml:"HaVipId,omitempty"`
	// The private IP address of the HAVIP.
	IpAddress *string `json:"IpAddress,omitempty" xml:"IpAddress,omitempty"`
	// The ID of the active instance that is associated with the HAVIP.
	MasterInstanceId *string `json:"MasterInstanceId,omitempty" xml:"MasterInstanceId,omitempty"`
	// The name of the HAVIP.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the region to which the HAVIP belongs.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group to which the HAVIP belongs.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The status of the HAVIP. Valid values:
	//
	// *   **Creating**
	// *   **Available**
	// *   **Deleting**
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The list of tags.
	Tags *DescribeHaVipsResponseBodyHaVipsHaVipTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Struct"`
	// The ID of the vSwitch to which the HAVIP belongs.
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
	// The ID of the VPC to which the HAVIP belongs.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s DescribeHaVipsResponseBodyHaVipsHaVip) String() string {
	return tea.Prettify(s)
}

func (s DescribeHaVipsResponseBodyHaVipsHaVip) GoString() string {
	return s.String()
}

func (s *DescribeHaVipsResponseBodyHaVipsHaVip) SetAssociatedEipAddresses(v *DescribeHaVipsResponseBodyHaVipsHaVipAssociatedEipAddresses) *DescribeHaVipsResponseBodyHaVipsHaVip {
	s.AssociatedEipAddresses = v
	return s
}

func (s *DescribeHaVipsResponseBodyHaVipsHaVip) SetAssociatedInstanceType(v string) *DescribeHaVipsResponseBodyHaVipsHaVip {
	s.AssociatedInstanceType = &v
	return s
}

func (s *DescribeHaVipsResponseBodyHaVipsHaVip) SetAssociatedInstances(v *DescribeHaVipsResponseBodyHaVipsHaVipAssociatedInstances) *DescribeHaVipsResponseBodyHaVipsHaVip {
	s.AssociatedInstances = v
	return s
}

func (s *DescribeHaVipsResponseBodyHaVipsHaVip) SetChargeType(v string) *DescribeHaVipsResponseBodyHaVipsHaVip {
	s.ChargeType = &v
	return s
}

func (s *DescribeHaVipsResponseBodyHaVipsHaVip) SetCreateTime(v string) *DescribeHaVipsResponseBodyHaVipsHaVip {
	s.CreateTime = &v
	return s
}

func (s *DescribeHaVipsResponseBodyHaVipsHaVip) SetDescription(v string) *DescribeHaVipsResponseBodyHaVipsHaVip {
	s.Description = &v
	return s
}

func (s *DescribeHaVipsResponseBodyHaVipsHaVip) SetHaVipId(v string) *DescribeHaVipsResponseBodyHaVipsHaVip {
	s.HaVipId = &v
	return s
}

func (s *DescribeHaVipsResponseBodyHaVipsHaVip) SetIpAddress(v string) *DescribeHaVipsResponseBodyHaVipsHaVip {
	s.IpAddress = &v
	return s
}

func (s *DescribeHaVipsResponseBodyHaVipsHaVip) SetMasterInstanceId(v string) *DescribeHaVipsResponseBodyHaVipsHaVip {
	s.MasterInstanceId = &v
	return s
}

func (s *DescribeHaVipsResponseBodyHaVipsHaVip) SetName(v string) *DescribeHaVipsResponseBodyHaVipsHaVip {
	s.Name = &v
	return s
}

func (s *DescribeHaVipsResponseBodyHaVipsHaVip) SetRegionId(v string) *DescribeHaVipsResponseBodyHaVipsHaVip {
	s.RegionId = &v
	return s
}

func (s *DescribeHaVipsResponseBodyHaVipsHaVip) SetResourceGroupId(v string) *DescribeHaVipsResponseBodyHaVipsHaVip {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeHaVipsResponseBodyHaVipsHaVip) SetStatus(v string) *DescribeHaVipsResponseBodyHaVipsHaVip {
	s.Status = &v
	return s
}

func (s *DescribeHaVipsResponseBodyHaVipsHaVip) SetTags(v *DescribeHaVipsResponseBodyHaVipsHaVipTags) *DescribeHaVipsResponseBodyHaVipsHaVip {
	s.Tags = v
	return s
}

func (s *DescribeHaVipsResponseBodyHaVipsHaVip) SetVSwitchId(v string) *DescribeHaVipsResponseBodyHaVipsHaVip {
	s.VSwitchId = &v
	return s
}

func (s *DescribeHaVipsResponseBodyHaVipsHaVip) SetVpcId(v string) *DescribeHaVipsResponseBodyHaVipsHaVip {
	s.VpcId = &v
	return s
}

type DescribeHaVipsResponseBodyHaVipsHaVipAssociatedEipAddresses struct {
	AssociatedEipAddresse []*string `json:"associatedEipAddresse,omitempty" xml:"associatedEipAddresse,omitempty" type:"Repeated"`
}

func (s DescribeHaVipsResponseBodyHaVipsHaVipAssociatedEipAddresses) String() string {
	return tea.Prettify(s)
}

func (s DescribeHaVipsResponseBodyHaVipsHaVipAssociatedEipAddresses) GoString() string {
	return s.String()
}

func (s *DescribeHaVipsResponseBodyHaVipsHaVipAssociatedEipAddresses) SetAssociatedEipAddresse(v []*string) *DescribeHaVipsResponseBodyHaVipsHaVipAssociatedEipAddresses {
	s.AssociatedEipAddresse = v
	return s
}

type DescribeHaVipsResponseBodyHaVipsHaVipAssociatedInstances struct {
	AssociatedInstance []*string `json:"associatedInstance,omitempty" xml:"associatedInstance,omitempty" type:"Repeated"`
}

func (s DescribeHaVipsResponseBodyHaVipsHaVipAssociatedInstances) String() string {
	return tea.Prettify(s)
}

func (s DescribeHaVipsResponseBodyHaVipsHaVipAssociatedInstances) GoString() string {
	return s.String()
}

func (s *DescribeHaVipsResponseBodyHaVipsHaVipAssociatedInstances) SetAssociatedInstance(v []*string) *DescribeHaVipsResponseBodyHaVipsHaVipAssociatedInstances {
	s.AssociatedInstance = v
	return s
}

type DescribeHaVipsResponseBodyHaVipsHaVipTags struct {
	Tag []*DescribeHaVipsResponseBodyHaVipsHaVipTagsTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s DescribeHaVipsResponseBodyHaVipsHaVipTags) String() string {
	return tea.Prettify(s)
}

func (s DescribeHaVipsResponseBodyHaVipsHaVipTags) GoString() string {
	return s.String()
}

func (s *DescribeHaVipsResponseBodyHaVipsHaVipTags) SetTag(v []*DescribeHaVipsResponseBodyHaVipsHaVipTagsTag) *DescribeHaVipsResponseBodyHaVipsHaVipTags {
	s.Tag = v
	return s
}

type DescribeHaVipsResponseBodyHaVipsHaVipTagsTag struct {
	// The tag key.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeHaVipsResponseBodyHaVipsHaVipTagsTag) String() string {
	return tea.Prettify(s)
}

func (s DescribeHaVipsResponseBodyHaVipsHaVipTagsTag) GoString() string {
	return s.String()
}

func (s *DescribeHaVipsResponseBodyHaVipsHaVipTagsTag) SetKey(v string) *DescribeHaVipsResponseBodyHaVipsHaVipTagsTag {
	s.Key = &v
	return s
}

func (s *DescribeHaVipsResponseBodyHaVipsHaVipTagsTag) SetValue(v string) *DescribeHaVipsResponseBodyHaVipsHaVipTagsTag {
	s.Value = &v
	return s
}

type DescribeHaVipsResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeHaVipsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeHaVipsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeHaVipsResponse) GoString() string {
	return s.String()
}

func (s *DescribeHaVipsResponse) SetHeaders(v map[string]*string) *DescribeHaVipsResponse {
	s.Headers = v
	return s
}

func (s *DescribeHaVipsResponse) SetStatusCode(v int32) *DescribeHaVipsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeHaVipsResponse) SetBody(v *DescribeHaVipsResponseBody) *DescribeHaVipsResponse {
	s.Body = v
	return s
}

type DescribeHighDefinitionMonitorLogAttributeRequest struct {
	// The ID of the fine-grained monitoring instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the instance. Set the value to **EIP**.
	InstanceType *string `json:"InstanceType,omitempty" xml:"InstanceType,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region where the instance is deployed.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeHighDefinitionMonitorLogAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeHighDefinitionMonitorLogAttributeRequest) GoString() string {
	return s.String()
}

func (s *DescribeHighDefinitionMonitorLogAttributeRequest) SetInstanceId(v string) *DescribeHighDefinitionMonitorLogAttributeRequest {
	s.InstanceId = &v
	return s
}

func (s *DescribeHighDefinitionMonitorLogAttributeRequest) SetInstanceType(v string) *DescribeHighDefinitionMonitorLogAttributeRequest {
	s.InstanceType = &v
	return s
}

func (s *DescribeHighDefinitionMonitorLogAttributeRequest) SetOwnerAccount(v string) *DescribeHighDefinitionMonitorLogAttributeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeHighDefinitionMonitorLogAttributeRequest) SetOwnerId(v int64) *DescribeHighDefinitionMonitorLogAttributeRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeHighDefinitionMonitorLogAttributeRequest) SetRegionId(v string) *DescribeHighDefinitionMonitorLogAttributeRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeHighDefinitionMonitorLogAttributeRequest) SetResourceOwnerAccount(v string) *DescribeHighDefinitionMonitorLogAttributeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeHighDefinitionMonitorLogAttributeRequest) SetResourceOwnerId(v int64) *DescribeHighDefinitionMonitorLogAttributeRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeHighDefinitionMonitorLogAttributeResponseBody struct {
	// The ID of the fine-grained monitoring instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The type of the monitoring instance that is queried. The value is set to **EIP**.
	InstanceType *string `json:"InstanceType,omitempty" xml:"InstanceType,omitempty"`
	// The name of the log project of Log Service.
	LogProject *string `json:"LogProject,omitempty" xml:"LogProject,omitempty"`
	// The name of the Logstore of Log Service.
	LogStore *string `json:"LogStore,omitempty" xml:"LogStore,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the operation is performed. Valid values:
	//
	// *   **true**: The operation is performed.
	// *   **false**: The operation is not performed.
	Success *string `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DescribeHighDefinitionMonitorLogAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeHighDefinitionMonitorLogAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeHighDefinitionMonitorLogAttributeResponseBody) SetInstanceId(v string) *DescribeHighDefinitionMonitorLogAttributeResponseBody {
	s.InstanceId = &v
	return s
}

func (s *DescribeHighDefinitionMonitorLogAttributeResponseBody) SetInstanceType(v string) *DescribeHighDefinitionMonitorLogAttributeResponseBody {
	s.InstanceType = &v
	return s
}

func (s *DescribeHighDefinitionMonitorLogAttributeResponseBody) SetLogProject(v string) *DescribeHighDefinitionMonitorLogAttributeResponseBody {
	s.LogProject = &v
	return s
}

func (s *DescribeHighDefinitionMonitorLogAttributeResponseBody) SetLogStore(v string) *DescribeHighDefinitionMonitorLogAttributeResponseBody {
	s.LogStore = &v
	return s
}

func (s *DescribeHighDefinitionMonitorLogAttributeResponseBody) SetRequestId(v string) *DescribeHighDefinitionMonitorLogAttributeResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeHighDefinitionMonitorLogAttributeResponseBody) SetSuccess(v string) *DescribeHighDefinitionMonitorLogAttributeResponseBody {
	s.Success = &v
	return s
}

type DescribeHighDefinitionMonitorLogAttributeResponse struct {
	Headers    map[string]*string                                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeHighDefinitionMonitorLogAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeHighDefinitionMonitorLogAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeHighDefinitionMonitorLogAttributeResponse) GoString() string {
	return s.String()
}

func (s *DescribeHighDefinitionMonitorLogAttributeResponse) SetHeaders(v map[string]*string) *DescribeHighDefinitionMonitorLogAttributeResponse {
	s.Headers = v
	return s
}

func (s *DescribeHighDefinitionMonitorLogAttributeResponse) SetStatusCode(v int32) *DescribeHighDefinitionMonitorLogAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeHighDefinitionMonitorLogAttributeResponse) SetBody(v *DescribeHighDefinitionMonitorLogAttributeResponseBody) *DescribeHighDefinitionMonitorLogAttributeResponse {
	s.Body = v
	return s
}

type DescribeIPv6TranslatorAclListAttributesRequest struct {
	// The ACL ID.
	AclId        *string `json:"AclId,omitempty" xml:"AclId,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of the page to return. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Maximum value: **50**. Default value: **10**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The region of the ACL.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeIPv6TranslatorAclListAttributesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeIPv6TranslatorAclListAttributesRequest) GoString() string {
	return s.String()
}

func (s *DescribeIPv6TranslatorAclListAttributesRequest) SetAclId(v string) *DescribeIPv6TranslatorAclListAttributesRequest {
	s.AclId = &v
	return s
}

func (s *DescribeIPv6TranslatorAclListAttributesRequest) SetOwnerAccount(v string) *DescribeIPv6TranslatorAclListAttributesRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeIPv6TranslatorAclListAttributesRequest) SetOwnerId(v int64) *DescribeIPv6TranslatorAclListAttributesRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeIPv6TranslatorAclListAttributesRequest) SetPageNumber(v int32) *DescribeIPv6TranslatorAclListAttributesRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeIPv6TranslatorAclListAttributesRequest) SetPageSize(v int32) *DescribeIPv6TranslatorAclListAttributesRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeIPv6TranslatorAclListAttributesRequest) SetRegionId(v string) *DescribeIPv6TranslatorAclListAttributesRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeIPv6TranslatorAclListAttributesRequest) SetResourceOwnerAccount(v string) *DescribeIPv6TranslatorAclListAttributesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeIPv6TranslatorAclListAttributesRequest) SetResourceOwnerId(v int64) *DescribeIPv6TranslatorAclListAttributesRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeIPv6TranslatorAclListAttributesResponseBody struct {
	// The ACLs.
	AclEntries *DescribeIPv6TranslatorAclListAttributesResponseBodyAclEntries `json:"AclEntries,omitempty" xml:"AclEntries,omitempty" type:"Struct"`
	// The ACL ID.
	AclId *string `json:"AclId,omitempty" xml:"AclId,omitempty"`
	// The name of the ACL.
	AclName *string `json:"AclName,omitempty" xml:"AclName,omitempty"`
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeIPv6TranslatorAclListAttributesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeIPv6TranslatorAclListAttributesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeIPv6TranslatorAclListAttributesResponseBody) SetAclEntries(v *DescribeIPv6TranslatorAclListAttributesResponseBodyAclEntries) *DescribeIPv6TranslatorAclListAttributesResponseBody {
	s.AclEntries = v
	return s
}

func (s *DescribeIPv6TranslatorAclListAttributesResponseBody) SetAclId(v string) *DescribeIPv6TranslatorAclListAttributesResponseBody {
	s.AclId = &v
	return s
}

func (s *DescribeIPv6TranslatorAclListAttributesResponseBody) SetAclName(v string) *DescribeIPv6TranslatorAclListAttributesResponseBody {
	s.AclName = &v
	return s
}

func (s *DescribeIPv6TranslatorAclListAttributesResponseBody) SetPageNumber(v int32) *DescribeIPv6TranslatorAclListAttributesResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeIPv6TranslatorAclListAttributesResponseBody) SetPageSize(v int32) *DescribeIPv6TranslatorAclListAttributesResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeIPv6TranslatorAclListAttributesResponseBody) SetRequestId(v string) *DescribeIPv6TranslatorAclListAttributesResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeIPv6TranslatorAclListAttributesResponseBody) SetTotalCount(v int32) *DescribeIPv6TranslatorAclListAttributesResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeIPv6TranslatorAclListAttributesResponseBodyAclEntries struct {
	AclEntry []*DescribeIPv6TranslatorAclListAttributesResponseBodyAclEntriesAclEntry `json:"AclEntry,omitempty" xml:"AclEntry,omitempty" type:"Repeated"`
}

func (s DescribeIPv6TranslatorAclListAttributesResponseBodyAclEntries) String() string {
	return tea.Prettify(s)
}

func (s DescribeIPv6TranslatorAclListAttributesResponseBodyAclEntries) GoString() string {
	return s.String()
}

func (s *DescribeIPv6TranslatorAclListAttributesResponseBodyAclEntries) SetAclEntry(v []*DescribeIPv6TranslatorAclListAttributesResponseBodyAclEntriesAclEntry) *DescribeIPv6TranslatorAclListAttributesResponseBodyAclEntries {
	s.AclEntry = v
	return s
}

type DescribeIPv6TranslatorAclListAttributesResponseBodyAclEntriesAclEntry struct {
	// The remarks of the ACL entry.
	AclEntryComment *string `json:"AclEntryComment,omitempty" xml:"AclEntryComment,omitempty"`
	// The ID of the ACL entry.
	AclEntryId *string `json:"AclEntryId,omitempty" xml:"AclEntryId,omitempty"`
	// The IP address specified in the ACL entry.
	AclEntryIp *string `json:"AclEntryIp,omitempty" xml:"AclEntryIp,omitempty"`
}

func (s DescribeIPv6TranslatorAclListAttributesResponseBodyAclEntriesAclEntry) String() string {
	return tea.Prettify(s)
}

func (s DescribeIPv6TranslatorAclListAttributesResponseBodyAclEntriesAclEntry) GoString() string {
	return s.String()
}

func (s *DescribeIPv6TranslatorAclListAttributesResponseBodyAclEntriesAclEntry) SetAclEntryComment(v string) *DescribeIPv6TranslatorAclListAttributesResponseBodyAclEntriesAclEntry {
	s.AclEntryComment = &v
	return s
}

func (s *DescribeIPv6TranslatorAclListAttributesResponseBodyAclEntriesAclEntry) SetAclEntryId(v string) *DescribeIPv6TranslatorAclListAttributesResponseBodyAclEntriesAclEntry {
	s.AclEntryId = &v
	return s
}

func (s *DescribeIPv6TranslatorAclListAttributesResponseBodyAclEntriesAclEntry) SetAclEntryIp(v string) *DescribeIPv6TranslatorAclListAttributesResponseBodyAclEntriesAclEntry {
	s.AclEntryIp = &v
	return s
}

type DescribeIPv6TranslatorAclListAttributesResponse struct {
	Headers    map[string]*string                                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeIPv6TranslatorAclListAttributesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeIPv6TranslatorAclListAttributesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeIPv6TranslatorAclListAttributesResponse) GoString() string {
	return s.String()
}

func (s *DescribeIPv6TranslatorAclListAttributesResponse) SetHeaders(v map[string]*string) *DescribeIPv6TranslatorAclListAttributesResponse {
	s.Headers = v
	return s
}

func (s *DescribeIPv6TranslatorAclListAttributesResponse) SetStatusCode(v int32) *DescribeIPv6TranslatorAclListAttributesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeIPv6TranslatorAclListAttributesResponse) SetBody(v *DescribeIPv6TranslatorAclListAttributesResponseBody) *DescribeIPv6TranslatorAclListAttributesResponse {
	s.Body = v
	return s
}

type DescribeIPv6TranslatorAclListsRequest struct {
	// The ID of the ACL.
	AclId *string `json:"AclId,omitempty" xml:"AclId,omitempty"`
	// The name of the ACL.
	AclName      *string `json:"AclName,omitempty" xml:"AclName,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of the page to return. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Maximum value: **50**. Default value: **10**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The region of the ACL.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeIPv6TranslatorAclListsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeIPv6TranslatorAclListsRequest) GoString() string {
	return s.String()
}

func (s *DescribeIPv6TranslatorAclListsRequest) SetAclId(v string) *DescribeIPv6TranslatorAclListsRequest {
	s.AclId = &v
	return s
}

func (s *DescribeIPv6TranslatorAclListsRequest) SetAclName(v string) *DescribeIPv6TranslatorAclListsRequest {
	s.AclName = &v
	return s
}

func (s *DescribeIPv6TranslatorAclListsRequest) SetOwnerAccount(v string) *DescribeIPv6TranslatorAclListsRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeIPv6TranslatorAclListsRequest) SetOwnerId(v int64) *DescribeIPv6TranslatorAclListsRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeIPv6TranslatorAclListsRequest) SetPageNumber(v int32) *DescribeIPv6TranslatorAclListsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeIPv6TranslatorAclListsRequest) SetPageSize(v int32) *DescribeIPv6TranslatorAclListsRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeIPv6TranslatorAclListsRequest) SetRegionId(v string) *DescribeIPv6TranslatorAclListsRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeIPv6TranslatorAclListsRequest) SetResourceOwnerAccount(v string) *DescribeIPv6TranslatorAclListsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeIPv6TranslatorAclListsRequest) SetResourceOwnerId(v int64) *DescribeIPv6TranslatorAclListsRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeIPv6TranslatorAclListsResponseBody struct {
	// The list of network ACLs.
	Ipv6TranslatorAcls *DescribeIPv6TranslatorAclListsResponseBodyIpv6TranslatorAcls `json:"Ipv6TranslatorAcls,omitempty" xml:"Ipv6TranslatorAcls,omitempty" type:"Struct"`
	// The page number.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeIPv6TranslatorAclListsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeIPv6TranslatorAclListsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeIPv6TranslatorAclListsResponseBody) SetIpv6TranslatorAcls(v *DescribeIPv6TranslatorAclListsResponseBodyIpv6TranslatorAcls) *DescribeIPv6TranslatorAclListsResponseBody {
	s.Ipv6TranslatorAcls = v
	return s
}

func (s *DescribeIPv6TranslatorAclListsResponseBody) SetPageNumber(v int32) *DescribeIPv6TranslatorAclListsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeIPv6TranslatorAclListsResponseBody) SetPageSize(v int32) *DescribeIPv6TranslatorAclListsResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeIPv6TranslatorAclListsResponseBody) SetRequestId(v string) *DescribeIPv6TranslatorAclListsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeIPv6TranslatorAclListsResponseBody) SetTotalCount(v int32) *DescribeIPv6TranslatorAclListsResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeIPv6TranslatorAclListsResponseBodyIpv6TranslatorAcls struct {
	IPv6TranslatorAcl []*DescribeIPv6TranslatorAclListsResponseBodyIpv6TranslatorAclsIPv6TranslatorAcl `json:"IPv6TranslatorAcl,omitempty" xml:"IPv6TranslatorAcl,omitempty" type:"Repeated"`
}

func (s DescribeIPv6TranslatorAclListsResponseBodyIpv6TranslatorAcls) String() string {
	return tea.Prettify(s)
}

func (s DescribeIPv6TranslatorAclListsResponseBodyIpv6TranslatorAcls) GoString() string {
	return s.String()
}

func (s *DescribeIPv6TranslatorAclListsResponseBodyIpv6TranslatorAcls) SetIPv6TranslatorAcl(v []*DescribeIPv6TranslatorAclListsResponseBodyIpv6TranslatorAclsIPv6TranslatorAcl) *DescribeIPv6TranslatorAclListsResponseBodyIpv6TranslatorAcls {
	s.IPv6TranslatorAcl = v
	return s
}

type DescribeIPv6TranslatorAclListsResponseBodyIpv6TranslatorAclsIPv6TranslatorAcl struct {
	// The ACL ID.
	AclId *string `json:"AclId,omitempty" xml:"AclId,omitempty"`
	// The ACL name.
	AclName *string `json:"AclName,omitempty" xml:"AclName,omitempty"`
}

func (s DescribeIPv6TranslatorAclListsResponseBodyIpv6TranslatorAclsIPv6TranslatorAcl) String() string {
	return tea.Prettify(s)
}

func (s DescribeIPv6TranslatorAclListsResponseBodyIpv6TranslatorAclsIPv6TranslatorAcl) GoString() string {
	return s.String()
}

func (s *DescribeIPv6TranslatorAclListsResponseBodyIpv6TranslatorAclsIPv6TranslatorAcl) SetAclId(v string) *DescribeIPv6TranslatorAclListsResponseBodyIpv6TranslatorAclsIPv6TranslatorAcl {
	s.AclId = &v
	return s
}

func (s *DescribeIPv6TranslatorAclListsResponseBodyIpv6TranslatorAclsIPv6TranslatorAcl) SetAclName(v string) *DescribeIPv6TranslatorAclListsResponseBodyIpv6TranslatorAclsIPv6TranslatorAcl {
	s.AclName = &v
	return s
}

type DescribeIPv6TranslatorAclListsResponse struct {
	Headers    map[string]*string                          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeIPv6TranslatorAclListsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeIPv6TranslatorAclListsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeIPv6TranslatorAclListsResponse) GoString() string {
	return s.String()
}

func (s *DescribeIPv6TranslatorAclListsResponse) SetHeaders(v map[string]*string) *DescribeIPv6TranslatorAclListsResponse {
	s.Headers = v
	return s
}

func (s *DescribeIPv6TranslatorAclListsResponse) SetStatusCode(v int32) *DescribeIPv6TranslatorAclListsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeIPv6TranslatorAclListsResponse) SetBody(v *DescribeIPv6TranslatorAclListsResponseBody) *DescribeIPv6TranslatorAclListsResponse {
	s.Body = v
	return s
}

type DescribeIPv6TranslatorEntriesRequest struct {
	// The ID of the network ACL.
	AclId *string `json:"AclId,omitempty" xml:"AclId,omitempty"`
	// Specifies whether to enable access control lists (ACLs). Valid values:
	//
	// *   **on**
	// *   **off**
	AclStatus *string `json:"AclStatus,omitempty" xml:"AclStatus,omitempty"`
	// The ACL type. Valid values:
	//
	// *   **white**: a whitelist. IPv6 addresses in the ACL are allowed to access backend services.
	// *   **black**: a blacklist. IPv6 addresses in the ACL are not allowed to access backend services.
	AclType *string `json:"AclType,omitempty" xml:"AclType,omitempty"`
	// The IPv6 address allocated to the IPv6 Translation Service instance.
	AllocateIpv6Addr *string `json:"AllocateIpv6Addr,omitempty" xml:"AllocateIpv6Addr,omitempty"`
	// The port used by the IPv6 address allocated to the IPv6 Translation Service instance.
	AllocateIpv6Port *int32 `json:"AllocateIpv6Port,omitempty" xml:"AllocateIpv6Port,omitempty"`
	// The public IPv4 address that needs to provide IPv6 services.
	BackendIpv4Addr *string `json:"BackendIpv4Addr,omitempty" xml:"BackendIpv4Addr,omitempty"`
	// The port used by the public IPv4 address that needs to provide IPv6 services.
	BackendIpv4Port *int32 `json:"BackendIpv4Port,omitempty" xml:"BackendIpv4Port,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The name of the IPv6 mapping entry.
	EntryName *string `json:"EntryName,omitempty" xml:"EntryName,omitempty"`
	// The ID of the IPv6 mapping entry.
	//
	// > If **Ipv6TranslatorId** and **Ipv6TranslatorEntryId** are empty, information about all IPv6 mapping entries is returned. If only **Ipv6TranslatorEntryId** is empty, information about the IPv6 mapping entries of the current IPv6 Translation Service instance is returned.
	Ipv6TranslatorEntryId *string `json:"Ipv6TranslatorEntryId,omitempty" xml:"Ipv6TranslatorEntryId,omitempty"`
	// The ID of the IPv6 Translation Service instance.
	Ipv6TranslatorId *string `json:"Ipv6TranslatorId,omitempty" xml:"Ipv6TranslatorId,omitempty"`
	OwnerAccount     *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId          *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of the page to return. Default value: 1.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Maximum value: **50**. Default value: **10**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The region of the IPv6 Translation Service instance. You can call the **DescribeRegions** operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The protocol used by the data to be forwarded.
	TransProtocol *string `json:"TransProtocol,omitempty" xml:"TransProtocol,omitempty"`
}

func (s DescribeIPv6TranslatorEntriesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeIPv6TranslatorEntriesRequest) GoString() string {
	return s.String()
}

func (s *DescribeIPv6TranslatorEntriesRequest) SetAclId(v string) *DescribeIPv6TranslatorEntriesRequest {
	s.AclId = &v
	return s
}

func (s *DescribeIPv6TranslatorEntriesRequest) SetAclStatus(v string) *DescribeIPv6TranslatorEntriesRequest {
	s.AclStatus = &v
	return s
}

func (s *DescribeIPv6TranslatorEntriesRequest) SetAclType(v string) *DescribeIPv6TranslatorEntriesRequest {
	s.AclType = &v
	return s
}

func (s *DescribeIPv6TranslatorEntriesRequest) SetAllocateIpv6Addr(v string) *DescribeIPv6TranslatorEntriesRequest {
	s.AllocateIpv6Addr = &v
	return s
}

func (s *DescribeIPv6TranslatorEntriesRequest) SetAllocateIpv6Port(v int32) *DescribeIPv6TranslatorEntriesRequest {
	s.AllocateIpv6Port = &v
	return s
}

func (s *DescribeIPv6TranslatorEntriesRequest) SetBackendIpv4Addr(v string) *DescribeIPv6TranslatorEntriesRequest {
	s.BackendIpv4Addr = &v
	return s
}

func (s *DescribeIPv6TranslatorEntriesRequest) SetBackendIpv4Port(v int32) *DescribeIPv6TranslatorEntriesRequest {
	s.BackendIpv4Port = &v
	return s
}

func (s *DescribeIPv6TranslatorEntriesRequest) SetClientToken(v string) *DescribeIPv6TranslatorEntriesRequest {
	s.ClientToken = &v
	return s
}

func (s *DescribeIPv6TranslatorEntriesRequest) SetEntryName(v string) *DescribeIPv6TranslatorEntriesRequest {
	s.EntryName = &v
	return s
}

func (s *DescribeIPv6TranslatorEntriesRequest) SetIpv6TranslatorEntryId(v string) *DescribeIPv6TranslatorEntriesRequest {
	s.Ipv6TranslatorEntryId = &v
	return s
}

func (s *DescribeIPv6TranslatorEntriesRequest) SetIpv6TranslatorId(v string) *DescribeIPv6TranslatorEntriesRequest {
	s.Ipv6TranslatorId = &v
	return s
}

func (s *DescribeIPv6TranslatorEntriesRequest) SetOwnerAccount(v string) *DescribeIPv6TranslatorEntriesRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeIPv6TranslatorEntriesRequest) SetOwnerId(v int64) *DescribeIPv6TranslatorEntriesRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeIPv6TranslatorEntriesRequest) SetPageNumber(v int32) *DescribeIPv6TranslatorEntriesRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeIPv6TranslatorEntriesRequest) SetPageSize(v int32) *DescribeIPv6TranslatorEntriesRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeIPv6TranslatorEntriesRequest) SetRegionId(v string) *DescribeIPv6TranslatorEntriesRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeIPv6TranslatorEntriesRequest) SetResourceOwnerAccount(v string) *DescribeIPv6TranslatorEntriesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeIPv6TranslatorEntriesRequest) SetResourceOwnerId(v int64) *DescribeIPv6TranslatorEntriesRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeIPv6TranslatorEntriesRequest) SetTransProtocol(v string) *DescribeIPv6TranslatorEntriesRequest {
	s.TransProtocol = &v
	return s
}

type DescribeIPv6TranslatorEntriesResponseBody struct {
	// The IPv6 mapping entries that are queried.
	Ipv6TranslatorEntries *DescribeIPv6TranslatorEntriesResponseBodyIpv6TranslatorEntries `json:"Ipv6TranslatorEntries,omitempty" xml:"Ipv6TranslatorEntries,omitempty" type:"Struct"`
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeIPv6TranslatorEntriesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeIPv6TranslatorEntriesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeIPv6TranslatorEntriesResponseBody) SetIpv6TranslatorEntries(v *DescribeIPv6TranslatorEntriesResponseBodyIpv6TranslatorEntries) *DescribeIPv6TranslatorEntriesResponseBody {
	s.Ipv6TranslatorEntries = v
	return s
}

func (s *DescribeIPv6TranslatorEntriesResponseBody) SetPageNumber(v int32) *DescribeIPv6TranslatorEntriesResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeIPv6TranslatorEntriesResponseBody) SetPageSize(v int32) *DescribeIPv6TranslatorEntriesResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeIPv6TranslatorEntriesResponseBody) SetRequestId(v string) *DescribeIPv6TranslatorEntriesResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeIPv6TranslatorEntriesResponseBody) SetTotalCount(v int32) *DescribeIPv6TranslatorEntriesResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeIPv6TranslatorEntriesResponseBodyIpv6TranslatorEntries struct {
	Ipv6TranslatorEntry []*DescribeIPv6TranslatorEntriesResponseBodyIpv6TranslatorEntriesIpv6TranslatorEntry `json:"Ipv6TranslatorEntry,omitempty" xml:"Ipv6TranslatorEntry,omitempty" type:"Repeated"`
}

func (s DescribeIPv6TranslatorEntriesResponseBodyIpv6TranslatorEntries) String() string {
	return tea.Prettify(s)
}

func (s DescribeIPv6TranslatorEntriesResponseBodyIpv6TranslatorEntries) GoString() string {
	return s.String()
}

func (s *DescribeIPv6TranslatorEntriesResponseBodyIpv6TranslatorEntries) SetIpv6TranslatorEntry(v []*DescribeIPv6TranslatorEntriesResponseBodyIpv6TranslatorEntriesIpv6TranslatorEntry) *DescribeIPv6TranslatorEntriesResponseBodyIpv6TranslatorEntries {
	s.Ipv6TranslatorEntry = v
	return s
}

type DescribeIPv6TranslatorEntriesResponseBodyIpv6TranslatorEntriesIpv6TranslatorEntry struct {
	// The ID of the associated ACL.
	AclId *string `json:"AclId,omitempty" xml:"AclId,omitempty"`
	// Indicates whether ACLs are enabled.
	AclStatus *string `json:"AclStatus,omitempty" xml:"AclStatus,omitempty"`
	// The ACL type.
	//
	// *   **white**: a whitelist. IPv6 addresses in the ACL are allowed to access backend services.
	// *   **black**: a blacklist. IPv6 addresses in the ACL are not allowed to access backend services.
	AclType *string `json:"AclType,omitempty" xml:"AclType,omitempty"`
	// The IPv6 address allocated to the IPv6 Translation Service instance.
	AllocateIpv6Addr *string `json:"AllocateIpv6Addr,omitempty" xml:"AllocateIpv6Addr,omitempty"`
	// The port used by the IPv6 address allocated to the IPv6 Translation Service instance.
	AllocateIpv6Port *int32 `json:"AllocateIpv6Port,omitempty" xml:"AllocateIpv6Port,omitempty"`
	// The public IP address of the backend IPv4 server.
	BackendIpv4Addr *string `json:"BackendIpv4Addr,omitempty" xml:"BackendIpv4Addr,omitempty"`
	// The public IPv4 port used by the IPv4 server that needs to provide IPv6 access.
	BackendIpv4Port *string `json:"BackendIpv4Port,omitempty" xml:"BackendIpv4Port,omitempty"`
	// The bandwidth specified in the IPv6 mapping entry.
	EntryBandwidth *string `json:"EntryBandwidth,omitempty" xml:"EntryBandwidth,omitempty"`
	// The description of the IPv6 mapping entry.
	EntryDescription *string `json:"EntryDescription,omitempty" xml:"EntryDescription,omitempty"`
	// The name of the IPv6 mapping entry.
	EntryName *string `json:"EntryName,omitempty" xml:"EntryName,omitempty"`
	// The status of the IPv6 mapping entry.
	EntryStatus *string `json:"EntryStatus,omitempty" xml:"EntryStatus,omitempty"`
	// The ID of the IPv6 mapping entry.
	Ipv6TranslatorEntryId *string `json:"Ipv6TranslatorEntryId,omitempty" xml:"Ipv6TranslatorEntryId,omitempty"`
	// The ID of the IPv6 Translation Service instance to which the IPv6 mapping entry belongs.
	Ipv6TranslatorId *string `json:"Ipv6TranslatorId,omitempty" xml:"Ipv6TranslatorId,omitempty"`
	// The region of the IPv6 Translation Service instance.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The protocol.
	TransProtocol *string `json:"TransProtocol,omitempty" xml:"TransProtocol,omitempty"`
}

func (s DescribeIPv6TranslatorEntriesResponseBodyIpv6TranslatorEntriesIpv6TranslatorEntry) String() string {
	return tea.Prettify(s)
}

func (s DescribeIPv6TranslatorEntriesResponseBodyIpv6TranslatorEntriesIpv6TranslatorEntry) GoString() string {
	return s.String()
}

func (s *DescribeIPv6TranslatorEntriesResponseBodyIpv6TranslatorEntriesIpv6TranslatorEntry) SetAclId(v string) *DescribeIPv6TranslatorEntriesResponseBodyIpv6TranslatorEntriesIpv6TranslatorEntry {
	s.AclId = &v
	return s
}

func (s *DescribeIPv6TranslatorEntriesResponseBodyIpv6TranslatorEntriesIpv6TranslatorEntry) SetAclStatus(v string) *DescribeIPv6TranslatorEntriesResponseBodyIpv6TranslatorEntriesIpv6TranslatorEntry {
	s.AclStatus = &v
	return s
}

func (s *DescribeIPv6TranslatorEntriesResponseBodyIpv6TranslatorEntriesIpv6TranslatorEntry) SetAclType(v string) *DescribeIPv6TranslatorEntriesResponseBodyIpv6TranslatorEntriesIpv6TranslatorEntry {
	s.AclType = &v
	return s
}

func (s *DescribeIPv6TranslatorEntriesResponseBodyIpv6TranslatorEntriesIpv6TranslatorEntry) SetAllocateIpv6Addr(v string) *DescribeIPv6TranslatorEntriesResponseBodyIpv6TranslatorEntriesIpv6TranslatorEntry {
	s.AllocateIpv6Addr = &v
	return s
}

func (s *DescribeIPv6TranslatorEntriesResponseBodyIpv6TranslatorEntriesIpv6TranslatorEntry) SetAllocateIpv6Port(v int32) *DescribeIPv6TranslatorEntriesResponseBodyIpv6TranslatorEntriesIpv6TranslatorEntry {
	s.AllocateIpv6Port = &v
	return s
}

func (s *DescribeIPv6TranslatorEntriesResponseBodyIpv6TranslatorEntriesIpv6TranslatorEntry) SetBackendIpv4Addr(v string) *DescribeIPv6TranslatorEntriesResponseBodyIpv6TranslatorEntriesIpv6TranslatorEntry {
	s.BackendIpv4Addr = &v
	return s
}

func (s *DescribeIPv6TranslatorEntriesResponseBodyIpv6TranslatorEntriesIpv6TranslatorEntry) SetBackendIpv4Port(v string) *DescribeIPv6TranslatorEntriesResponseBodyIpv6TranslatorEntriesIpv6TranslatorEntry {
	s.BackendIpv4Port = &v
	return s
}

func (s *DescribeIPv6TranslatorEntriesResponseBodyIpv6TranslatorEntriesIpv6TranslatorEntry) SetEntryBandwidth(v string) *DescribeIPv6TranslatorEntriesResponseBodyIpv6TranslatorEntriesIpv6TranslatorEntry {
	s.EntryBandwidth = &v
	return s
}

func (s *DescribeIPv6TranslatorEntriesResponseBodyIpv6TranslatorEntriesIpv6TranslatorEntry) SetEntryDescription(v string) *DescribeIPv6TranslatorEntriesResponseBodyIpv6TranslatorEntriesIpv6TranslatorEntry {
	s.EntryDescription = &v
	return s
}

func (s *DescribeIPv6TranslatorEntriesResponseBodyIpv6TranslatorEntriesIpv6TranslatorEntry) SetEntryName(v string) *DescribeIPv6TranslatorEntriesResponseBodyIpv6TranslatorEntriesIpv6TranslatorEntry {
	s.EntryName = &v
	return s
}

func (s *DescribeIPv6TranslatorEntriesResponseBodyIpv6TranslatorEntriesIpv6TranslatorEntry) SetEntryStatus(v string) *DescribeIPv6TranslatorEntriesResponseBodyIpv6TranslatorEntriesIpv6TranslatorEntry {
	s.EntryStatus = &v
	return s
}

func (s *DescribeIPv6TranslatorEntriesResponseBodyIpv6TranslatorEntriesIpv6TranslatorEntry) SetIpv6TranslatorEntryId(v string) *DescribeIPv6TranslatorEntriesResponseBodyIpv6TranslatorEntriesIpv6TranslatorEntry {
	s.Ipv6TranslatorEntryId = &v
	return s
}

func (s *DescribeIPv6TranslatorEntriesResponseBodyIpv6TranslatorEntriesIpv6TranslatorEntry) SetIpv6TranslatorId(v string) *DescribeIPv6TranslatorEntriesResponseBodyIpv6TranslatorEntriesIpv6TranslatorEntry {
	s.Ipv6TranslatorId = &v
	return s
}

func (s *DescribeIPv6TranslatorEntriesResponseBodyIpv6TranslatorEntriesIpv6TranslatorEntry) SetRegionId(v string) *DescribeIPv6TranslatorEntriesResponseBodyIpv6TranslatorEntriesIpv6TranslatorEntry {
	s.RegionId = &v
	return s
}

func (s *DescribeIPv6TranslatorEntriesResponseBodyIpv6TranslatorEntriesIpv6TranslatorEntry) SetTransProtocol(v string) *DescribeIPv6TranslatorEntriesResponseBodyIpv6TranslatorEntriesIpv6TranslatorEntry {
	s.TransProtocol = &v
	return s
}

type DescribeIPv6TranslatorEntriesResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeIPv6TranslatorEntriesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeIPv6TranslatorEntriesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeIPv6TranslatorEntriesResponse) GoString() string {
	return s.String()
}

func (s *DescribeIPv6TranslatorEntriesResponse) SetHeaders(v map[string]*string) *DescribeIPv6TranslatorEntriesResponse {
	s.Headers = v
	return s
}

func (s *DescribeIPv6TranslatorEntriesResponse) SetStatusCode(v int32) *DescribeIPv6TranslatorEntriesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeIPv6TranslatorEntriesResponse) SetBody(v *DescribeIPv6TranslatorEntriesResponseBody) *DescribeIPv6TranslatorEntriesResponse {
	s.Body = v
	return s
}

type DescribeIPv6TranslatorsRequest struct {
	// The IPv4 address allocated to the IPv6 Translation Service instance.
	AllocateIpv4Addr *string `json:"AllocateIpv4Addr,omitempty" xml:"AllocateIpv4Addr,omitempty"`
	// The IPv6 address allocated to the IPv6 Translation Service instance.
	AllocateIpv6Addr *string `json:"AllocateIpv6Addr,omitempty" xml:"AllocateIpv6Addr,omitempty"`
	// The business status of the IPv6 Translation Service instance. Valid values:
	//
	// *   **Normal**
	// *   **FinancialLocked**
	BusinessStatus *string `json:"BusinessStatus,omitempty" xml:"BusinessStatus,omitempty"`
	// The ID of the IPv6 Translation Service instance.
	Ipv6TranslatorId *string `json:"Ipv6TranslatorId,omitempty" xml:"Ipv6TranslatorId,omitempty"`
	// The name of the IPv6 Translation Service instance.
	Name         *string `json:"Name,omitempty" xml:"Name,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of the page to return. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Maximum value: **50**. Default value: **10**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The billing method of the IPv6 Translation Service instance. Valid values:
	//
	// *   **Prepay**: subscription
	// *   **Postpay**: pay-as-you-go
	PayType *string `json:"PayType,omitempty" xml:"PayType,omitempty"`
	// The region of the IPv6 Translation Service instance. You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The specification of the IPv6 Translation Service instance. Set the value to **small**.
	Spec *string `json:"Spec,omitempty" xml:"Spec,omitempty"`
	// The status of the IPv6 Translation Service instance. Valid values:
	//
	// *   **init**
	// *   **provisioning**
	// *   **active**
	// *   **updating**
	// *   **upgrading**
	// *   **deleting**
	// *   **deleted**
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeIPv6TranslatorsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeIPv6TranslatorsRequest) GoString() string {
	return s.String()
}

func (s *DescribeIPv6TranslatorsRequest) SetAllocateIpv4Addr(v string) *DescribeIPv6TranslatorsRequest {
	s.AllocateIpv4Addr = &v
	return s
}

func (s *DescribeIPv6TranslatorsRequest) SetAllocateIpv6Addr(v string) *DescribeIPv6TranslatorsRequest {
	s.AllocateIpv6Addr = &v
	return s
}

func (s *DescribeIPv6TranslatorsRequest) SetBusinessStatus(v string) *DescribeIPv6TranslatorsRequest {
	s.BusinessStatus = &v
	return s
}

func (s *DescribeIPv6TranslatorsRequest) SetIpv6TranslatorId(v string) *DescribeIPv6TranslatorsRequest {
	s.Ipv6TranslatorId = &v
	return s
}

func (s *DescribeIPv6TranslatorsRequest) SetName(v string) *DescribeIPv6TranslatorsRequest {
	s.Name = &v
	return s
}

func (s *DescribeIPv6TranslatorsRequest) SetOwnerAccount(v string) *DescribeIPv6TranslatorsRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeIPv6TranslatorsRequest) SetOwnerId(v int64) *DescribeIPv6TranslatorsRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeIPv6TranslatorsRequest) SetPageNumber(v int32) *DescribeIPv6TranslatorsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeIPv6TranslatorsRequest) SetPageSize(v int32) *DescribeIPv6TranslatorsRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeIPv6TranslatorsRequest) SetPayType(v string) *DescribeIPv6TranslatorsRequest {
	s.PayType = &v
	return s
}

func (s *DescribeIPv6TranslatorsRequest) SetRegionId(v string) *DescribeIPv6TranslatorsRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeIPv6TranslatorsRequest) SetResourceOwnerAccount(v string) *DescribeIPv6TranslatorsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeIPv6TranslatorsRequest) SetResourceOwnerId(v int64) *DescribeIPv6TranslatorsRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeIPv6TranslatorsRequest) SetSpec(v string) *DescribeIPv6TranslatorsRequest {
	s.Spec = &v
	return s
}

func (s *DescribeIPv6TranslatorsRequest) SetStatus(v string) *DescribeIPv6TranslatorsRequest {
	s.Status = &v
	return s
}

type DescribeIPv6TranslatorsResponseBody struct {
	// The list of IPv6 Translation Service instances.
	Ipv6Translators *DescribeIPv6TranslatorsResponseBodyIpv6Translators `json:"Ipv6Translators,omitempty" xml:"Ipv6Translators,omitempty" type:"Struct"`
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The number of returned entries.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeIPv6TranslatorsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeIPv6TranslatorsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeIPv6TranslatorsResponseBody) SetIpv6Translators(v *DescribeIPv6TranslatorsResponseBodyIpv6Translators) *DescribeIPv6TranslatorsResponseBody {
	s.Ipv6Translators = v
	return s
}

func (s *DescribeIPv6TranslatorsResponseBody) SetPageNumber(v int32) *DescribeIPv6TranslatorsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeIPv6TranslatorsResponseBody) SetPageSize(v int32) *DescribeIPv6TranslatorsResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeIPv6TranslatorsResponseBody) SetRequestId(v string) *DescribeIPv6TranslatorsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeIPv6TranslatorsResponseBody) SetTotalCount(v int32) *DescribeIPv6TranslatorsResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeIPv6TranslatorsResponseBodyIpv6Translators struct {
	Ipv6Translator []*DescribeIPv6TranslatorsResponseBodyIpv6TranslatorsIpv6Translator `json:"Ipv6Translator,omitempty" xml:"Ipv6Translator,omitempty" type:"Repeated"`
}

func (s DescribeIPv6TranslatorsResponseBodyIpv6Translators) String() string {
	return tea.Prettify(s)
}

func (s DescribeIPv6TranslatorsResponseBodyIpv6Translators) GoString() string {
	return s.String()
}

func (s *DescribeIPv6TranslatorsResponseBodyIpv6Translators) SetIpv6Translator(v []*DescribeIPv6TranslatorsResponseBodyIpv6TranslatorsIpv6Translator) *DescribeIPv6TranslatorsResponseBodyIpv6Translators {
	s.Ipv6Translator = v
	return s
}

type DescribeIPv6TranslatorsResponseBodyIpv6TranslatorsIpv6Translator struct {
	// The IPv4 address allocated to the IPv6 Translation Service instance.
	AllocateIpv4Addr *string `json:"AllocateIpv4Addr,omitempty" xml:"AllocateIpv4Addr,omitempty"`
	// The IPv6 address allocated to the IPv6 Translation Service instance.
	AllocateIpv6Addr *string `json:"AllocateIpv6Addr,omitempty" xml:"AllocateIpv6Addr,omitempty"`
	// The bandwidth of the IPv6 Translation Service instance.
	AvailableBandwidth *string `json:"AvailableBandwidth,omitempty" xml:"AvailableBandwidth,omitempty"`
	// The bandwidth of the IPv6 Translation Service instance. Unit: Mbit/s.
	Bandwidth *int32 `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	// The business status of the IPv6 Translation Service instance. Valid values:
	//
	// *   **Normal**
	// *   **FinancialLocked**
	BusinessStatus *string `json:"BusinessStatus,omitempty" xml:"BusinessStatus,omitempty"`
	// The timestamp when the IPv6 Translation Service instance was created.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The description of the IPv6 Translation Service instance.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The timestamp when IPv6 Translation Service instance expires.
	EndTime *int64 `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The IDs of IPv6 mapping entries of the IPv6 Translation Service instance.
	Ipv6TranslatorEntryIds *DescribeIPv6TranslatorsResponseBodyIpv6TranslatorsIpv6TranslatorIpv6TranslatorEntryIds `json:"Ipv6TranslatorEntryIds,omitempty" xml:"Ipv6TranslatorEntryIds,omitempty" type:"Struct"`
	// The ID of the IPv6 Translation Service instance.
	Ipv6TranslatorId *string `json:"Ipv6TranslatorId,omitempty" xml:"Ipv6TranslatorId,omitempty"`
	// The name of the IPv6 Translation Service instance.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The billing method of the IPv6 Translation Service instance.
	//
	// *   **Prepay**: subscription
	// *   **Postpay**: pay-as-you-go
	PayType *string `json:"PayType,omitempty" xml:"PayType,omitempty"`
	// The region of the IPv6 Translation Service instance.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The specification of the IPv6 Translation Service instance.
	Spec *string `json:"Spec,omitempty" xml:"Spec,omitempty"`
	// The status of the IPv6 Translation Service instance.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeIPv6TranslatorsResponseBodyIpv6TranslatorsIpv6Translator) String() string {
	return tea.Prettify(s)
}

func (s DescribeIPv6TranslatorsResponseBodyIpv6TranslatorsIpv6Translator) GoString() string {
	return s.String()
}

func (s *DescribeIPv6TranslatorsResponseBodyIpv6TranslatorsIpv6Translator) SetAllocateIpv4Addr(v string) *DescribeIPv6TranslatorsResponseBodyIpv6TranslatorsIpv6Translator {
	s.AllocateIpv4Addr = &v
	return s
}

func (s *DescribeIPv6TranslatorsResponseBodyIpv6TranslatorsIpv6Translator) SetAllocateIpv6Addr(v string) *DescribeIPv6TranslatorsResponseBodyIpv6TranslatorsIpv6Translator {
	s.AllocateIpv6Addr = &v
	return s
}

func (s *DescribeIPv6TranslatorsResponseBodyIpv6TranslatorsIpv6Translator) SetAvailableBandwidth(v string) *DescribeIPv6TranslatorsResponseBodyIpv6TranslatorsIpv6Translator {
	s.AvailableBandwidth = &v
	return s
}

func (s *DescribeIPv6TranslatorsResponseBodyIpv6TranslatorsIpv6Translator) SetBandwidth(v int32) *DescribeIPv6TranslatorsResponseBodyIpv6TranslatorsIpv6Translator {
	s.Bandwidth = &v
	return s
}

func (s *DescribeIPv6TranslatorsResponseBodyIpv6TranslatorsIpv6Translator) SetBusinessStatus(v string) *DescribeIPv6TranslatorsResponseBodyIpv6TranslatorsIpv6Translator {
	s.BusinessStatus = &v
	return s
}

func (s *DescribeIPv6TranslatorsResponseBodyIpv6TranslatorsIpv6Translator) SetCreateTime(v int64) *DescribeIPv6TranslatorsResponseBodyIpv6TranslatorsIpv6Translator {
	s.CreateTime = &v
	return s
}

func (s *DescribeIPv6TranslatorsResponseBodyIpv6TranslatorsIpv6Translator) SetDescription(v string) *DescribeIPv6TranslatorsResponseBodyIpv6TranslatorsIpv6Translator {
	s.Description = &v
	return s
}

func (s *DescribeIPv6TranslatorsResponseBodyIpv6TranslatorsIpv6Translator) SetEndTime(v int64) *DescribeIPv6TranslatorsResponseBodyIpv6TranslatorsIpv6Translator {
	s.EndTime = &v
	return s
}

func (s *DescribeIPv6TranslatorsResponseBodyIpv6TranslatorsIpv6Translator) SetIpv6TranslatorEntryIds(v *DescribeIPv6TranslatorsResponseBodyIpv6TranslatorsIpv6TranslatorIpv6TranslatorEntryIds) *DescribeIPv6TranslatorsResponseBodyIpv6TranslatorsIpv6Translator {
	s.Ipv6TranslatorEntryIds = v
	return s
}

func (s *DescribeIPv6TranslatorsResponseBodyIpv6TranslatorsIpv6Translator) SetIpv6TranslatorId(v string) *DescribeIPv6TranslatorsResponseBodyIpv6TranslatorsIpv6Translator {
	s.Ipv6TranslatorId = &v
	return s
}

func (s *DescribeIPv6TranslatorsResponseBodyIpv6TranslatorsIpv6Translator) SetName(v string) *DescribeIPv6TranslatorsResponseBodyIpv6TranslatorsIpv6Translator {
	s.Name = &v
	return s
}

func (s *DescribeIPv6TranslatorsResponseBodyIpv6TranslatorsIpv6Translator) SetPayType(v string) *DescribeIPv6TranslatorsResponseBodyIpv6TranslatorsIpv6Translator {
	s.PayType = &v
	return s
}

func (s *DescribeIPv6TranslatorsResponseBodyIpv6TranslatorsIpv6Translator) SetRegionId(v string) *DescribeIPv6TranslatorsResponseBodyIpv6TranslatorsIpv6Translator {
	s.RegionId = &v
	return s
}

func (s *DescribeIPv6TranslatorsResponseBodyIpv6TranslatorsIpv6Translator) SetSpec(v string) *DescribeIPv6TranslatorsResponseBodyIpv6TranslatorsIpv6Translator {
	s.Spec = &v
	return s
}

func (s *DescribeIPv6TranslatorsResponseBodyIpv6TranslatorsIpv6Translator) SetStatus(v string) *DescribeIPv6TranslatorsResponseBodyIpv6TranslatorsIpv6Translator {
	s.Status = &v
	return s
}

type DescribeIPv6TranslatorsResponseBodyIpv6TranslatorsIpv6TranslatorIpv6TranslatorEntryIds struct {
	Ipv6TranslatorEntryId []*string `json:"Ipv6TranslatorEntryId,omitempty" xml:"Ipv6TranslatorEntryId,omitempty" type:"Repeated"`
}

func (s DescribeIPv6TranslatorsResponseBodyIpv6TranslatorsIpv6TranslatorIpv6TranslatorEntryIds) String() string {
	return tea.Prettify(s)
}

func (s DescribeIPv6TranslatorsResponseBodyIpv6TranslatorsIpv6TranslatorIpv6TranslatorEntryIds) GoString() string {
	return s.String()
}

func (s *DescribeIPv6TranslatorsResponseBodyIpv6TranslatorsIpv6TranslatorIpv6TranslatorEntryIds) SetIpv6TranslatorEntryId(v []*string) *DescribeIPv6TranslatorsResponseBodyIpv6TranslatorsIpv6TranslatorIpv6TranslatorEntryIds {
	s.Ipv6TranslatorEntryId = v
	return s
}

type DescribeIPv6TranslatorsResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeIPv6TranslatorsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeIPv6TranslatorsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeIPv6TranslatorsResponse) GoString() string {
	return s.String()
}

func (s *DescribeIPv6TranslatorsResponse) SetHeaders(v map[string]*string) *DescribeIPv6TranslatorsResponse {
	s.Headers = v
	return s
}

func (s *DescribeIPv6TranslatorsResponse) SetStatusCode(v int32) *DescribeIPv6TranslatorsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeIPv6TranslatorsResponse) SetBody(v *DescribeIPv6TranslatorsResponseBody) *DescribeIPv6TranslatorsResponse {
	s.Body = v
	return s
}

type DescribeIpv6AddressesRequest struct {
	// The ID of the instance that is assigned the IPv6 address.
	AssociatedInstanceId *string `json:"AssociatedInstanceId,omitempty" xml:"AssociatedInstanceId,omitempty"`
	// The type of the instance that is assigned the IPv6 address.
	//
	// Set the value to **EcsInstance**, which specifies an Elastic Compute Service (ECS) instance in a virtual private cloud (VPC). This is the default value.
	AssociatedInstanceType *string `json:"AssociatedInstanceType,omitempty" xml:"AssociatedInstanceType,omitempty"`
	IncludeReservationData *bool   `json:"IncludeReservationData,omitempty" xml:"IncludeReservationData,omitempty"`
	// The IPv6 address that you want to query.
	Ipv6Address *string `json:"Ipv6Address,omitempty" xml:"Ipv6Address,omitempty"`
	// The ID of the IPv6 address that you want to query. You can enter at most 20 IPv6 IDs in each API request. Separate IPv6 IDs with commas (,).
	Ipv6AddressId *string `json:"Ipv6AddressId,omitempty" xml:"Ipv6AddressId,omitempty"`
	// The ID of the Internet bandwidth that you purchased for the IPv6 address.
	Ipv6InternetBandwidthId *string `json:"Ipv6InternetBandwidthId,omitempty" xml:"Ipv6InternetBandwidthId,omitempty"`
	// The name of the IPv6 address that you want to query.
	//
	// The name must be 2 to 128 characters in length, and can contain letters, digits, periods (.), underscores (\_), and hyphens (-). The name must start with a letter but cannot start with `http://` or `https://`.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The type of communication supported by the IPv6 address. Valid values:
	//
	// *   **Private**: communication within private networks
	// *   **Public**: communication over the Internet
	NetworkType  *string `json:"NetworkType,omitempty" xml:"NetworkType,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of the page to return. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return per page. Maximum value: **50**. Default value: **10**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the region in which you want to query IPv6 addresses. You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the vSwitch to which the IPv6 address belongs.
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
	// The ID of the VPC to which the IPv6 address belongs.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s DescribeIpv6AddressesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeIpv6AddressesRequest) GoString() string {
	return s.String()
}

func (s *DescribeIpv6AddressesRequest) SetAssociatedInstanceId(v string) *DescribeIpv6AddressesRequest {
	s.AssociatedInstanceId = &v
	return s
}

func (s *DescribeIpv6AddressesRequest) SetAssociatedInstanceType(v string) *DescribeIpv6AddressesRequest {
	s.AssociatedInstanceType = &v
	return s
}

func (s *DescribeIpv6AddressesRequest) SetIncludeReservationData(v bool) *DescribeIpv6AddressesRequest {
	s.IncludeReservationData = &v
	return s
}

func (s *DescribeIpv6AddressesRequest) SetIpv6Address(v string) *DescribeIpv6AddressesRequest {
	s.Ipv6Address = &v
	return s
}

func (s *DescribeIpv6AddressesRequest) SetIpv6AddressId(v string) *DescribeIpv6AddressesRequest {
	s.Ipv6AddressId = &v
	return s
}

func (s *DescribeIpv6AddressesRequest) SetIpv6InternetBandwidthId(v string) *DescribeIpv6AddressesRequest {
	s.Ipv6InternetBandwidthId = &v
	return s
}

func (s *DescribeIpv6AddressesRequest) SetName(v string) *DescribeIpv6AddressesRequest {
	s.Name = &v
	return s
}

func (s *DescribeIpv6AddressesRequest) SetNetworkType(v string) *DescribeIpv6AddressesRequest {
	s.NetworkType = &v
	return s
}

func (s *DescribeIpv6AddressesRequest) SetOwnerAccount(v string) *DescribeIpv6AddressesRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeIpv6AddressesRequest) SetOwnerId(v int64) *DescribeIpv6AddressesRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeIpv6AddressesRequest) SetPageNumber(v int32) *DescribeIpv6AddressesRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeIpv6AddressesRequest) SetPageSize(v int32) *DescribeIpv6AddressesRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeIpv6AddressesRequest) SetRegionId(v string) *DescribeIpv6AddressesRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeIpv6AddressesRequest) SetResourceOwnerAccount(v string) *DescribeIpv6AddressesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeIpv6AddressesRequest) SetResourceOwnerId(v int64) *DescribeIpv6AddressesRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeIpv6AddressesRequest) SetVSwitchId(v string) *DescribeIpv6AddressesRequest {
	s.VSwitchId = &v
	return s
}

func (s *DescribeIpv6AddressesRequest) SetVpcId(v string) *DescribeIpv6AddressesRequest {
	s.VpcId = &v
	return s
}

type DescribeIpv6AddressesResponseBody struct {
	// The details about the IPv6 addresses.
	Ipv6Addresses *DescribeIpv6AddressesResponseBodyIpv6Addresses `json:"Ipv6Addresses,omitempty" xml:"Ipv6Addresses,omitempty" type:"Struct"`
	// The number of the returned page. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned on each page. Maximum value: **50**. Default value: **10**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeIpv6AddressesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeIpv6AddressesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeIpv6AddressesResponseBody) SetIpv6Addresses(v *DescribeIpv6AddressesResponseBodyIpv6Addresses) *DescribeIpv6AddressesResponseBody {
	s.Ipv6Addresses = v
	return s
}

func (s *DescribeIpv6AddressesResponseBody) SetPageNumber(v int32) *DescribeIpv6AddressesResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeIpv6AddressesResponseBody) SetPageSize(v int32) *DescribeIpv6AddressesResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeIpv6AddressesResponseBody) SetRequestId(v string) *DescribeIpv6AddressesResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeIpv6AddressesResponseBody) SetTotalCount(v int32) *DescribeIpv6AddressesResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeIpv6AddressesResponseBodyIpv6Addresses struct {
	Ipv6Address []*DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6Address `json:"Ipv6Address,omitempty" xml:"Ipv6Address,omitempty" type:"Repeated"`
}

func (s DescribeIpv6AddressesResponseBodyIpv6Addresses) String() string {
	return tea.Prettify(s)
}

func (s DescribeIpv6AddressesResponseBodyIpv6Addresses) GoString() string {
	return s.String()
}

func (s *DescribeIpv6AddressesResponseBodyIpv6Addresses) SetIpv6Address(v []*DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6Address) *DescribeIpv6AddressesResponseBodyIpv6Addresses {
	s.Ipv6Address = v
	return s
}

type DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6Address struct {
	// The time when the IPv6 address was created.
	AllocationTime *string `json:"AllocationTime,omitempty" xml:"AllocationTime,omitempty"`
	// The ID of the instance that is assigned the IPv6 address.
	AssociatedInstanceId *string `json:"AssociatedInstanceId,omitempty" xml:"AssociatedInstanceId,omitempty"`
	// The type of the instance that is assigned the IPv6 address.
	AssociatedInstanceType *string `json:"AssociatedInstanceType,omitempty" xml:"AssociatedInstanceType,omitempty"`
	// The IPv6 address.
	Ipv6Address *string `json:"Ipv6Address,omitempty" xml:"Ipv6Address,omitempty"`
	// The ID of the IPv6 address.
	Ipv6AddressId *string `json:"Ipv6AddressId,omitempty" xml:"Ipv6AddressId,omitempty"`
	// The name of the IPv6 address.
	Ipv6AddressName *string `json:"Ipv6AddressName,omitempty" xml:"Ipv6AddressName,omitempty"`
	// The ID of the IPv6 gateway to which the IPv6 address belongs.
	Ipv6GatewayId *string `json:"Ipv6GatewayId,omitempty" xml:"Ipv6GatewayId,omitempty"`
	// The information about the Internet bandwidth of the IPv6 address.
	Ipv6InternetBandwidth *DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6AddressIpv6InternetBandwidth `json:"Ipv6InternetBandwidth,omitempty" xml:"Ipv6InternetBandwidth,omitempty" type:"Struct"`
	// The service provider of the IPv6 address. Valid values:
	//
	// *   **BGP**: Alibaba Cloud Border Gateway Protocol (BGP) IPv6. This is the default value.
	// *   **ChinaMobile**: China Mobile (single ISP).
	// *   **ChinaUnicom**: China Unicom (single ISP).
	// *   **ChinaTelecom**: China Telecom (single ISP).
	Ipv6Isp *string `json:"Ipv6Isp,omitempty" xml:"Ipv6Isp,omitempty"`
	// The type of communication supported by the IPv6 address. Valid values:
	//
	// *   **Private**: communication within private networks
	// *   **Public**: communication over the Internet
	NetworkType *string `json:"NetworkType,omitempty" xml:"NetworkType,omitempty"`
	// The maximum bandwidth value of the IPv6 address.
	//
	// *   If the IPv6 address is associated with an EIP bandwidth plan, the value of **RealBandwidth** is the maximum bandwidth value of the EIP bandwidth plan.
	// *   If the IPv6 address is not associated with an EIP bandwidth plan, the value of **RealBandwidth** is the maximum bandwidth value of the Internet bandwidth of the IPv6 address.
	// *   If the IPv6 address is not associated with an EIP bandwidth plan or an Internet bandwidth plan, the values of **RealBandwidth** and **Bandwidth** are both 0.
	RealBandwidth *int32 `json:"RealBandwidth,omitempty" xml:"RealBandwidth,omitempty"`
	// The status of the IPv6 address. Valid values:
	//
	// *   **Pending**: being configured
	// *   **Available**: available
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The ID of the vSwitch to which the IPv6 address belongs.
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
	// The ID of the VPC to which the IPv6 address belongs.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6Address) String() string {
	return tea.Prettify(s)
}

func (s DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6Address) GoString() string {
	return s.String()
}

func (s *DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6Address) SetAllocationTime(v string) *DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6Address {
	s.AllocationTime = &v
	return s
}

func (s *DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6Address) SetAssociatedInstanceId(v string) *DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6Address {
	s.AssociatedInstanceId = &v
	return s
}

func (s *DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6Address) SetAssociatedInstanceType(v string) *DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6Address {
	s.AssociatedInstanceType = &v
	return s
}

func (s *DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6Address) SetIpv6Address(v string) *DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6Address {
	s.Ipv6Address = &v
	return s
}

func (s *DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6Address) SetIpv6AddressId(v string) *DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6Address {
	s.Ipv6AddressId = &v
	return s
}

func (s *DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6Address) SetIpv6AddressName(v string) *DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6Address {
	s.Ipv6AddressName = &v
	return s
}

func (s *DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6Address) SetIpv6GatewayId(v string) *DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6Address {
	s.Ipv6GatewayId = &v
	return s
}

func (s *DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6Address) SetIpv6InternetBandwidth(v *DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6AddressIpv6InternetBandwidth) *DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6Address {
	s.Ipv6InternetBandwidth = v
	return s
}

func (s *DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6Address) SetIpv6Isp(v string) *DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6Address {
	s.Ipv6Isp = &v
	return s
}

func (s *DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6Address) SetNetworkType(v string) *DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6Address {
	s.NetworkType = &v
	return s
}

func (s *DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6Address) SetRealBandwidth(v int32) *DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6Address {
	s.RealBandwidth = &v
	return s
}

func (s *DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6Address) SetStatus(v string) *DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6Address {
	s.Status = &v
	return s
}

func (s *DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6Address) SetVSwitchId(v string) *DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6Address {
	s.VSwitchId = &v
	return s
}

func (s *DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6Address) SetVpcId(v string) *DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6Address {
	s.VpcId = &v
	return s
}

type DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6AddressIpv6InternetBandwidth struct {
	// The exclusive Internet bandwidth of the IPv6 address. Unit: Mbit/s.
	Bandwidth *int32 `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	// The status of the Internet bandwidth of the IPv6 address. Valid values:
	//
	// *   **Normal**: normal
	// *   **FinancialLocked**: locked due to overdue payments
	// *   **SecurityLocked**: locked due to security reasons
	BusinessStatus     *string `json:"BusinessStatus,omitempty" xml:"BusinessStatus,omitempty"`
	HasReservationData *bool   `json:"HasReservationData,omitempty" xml:"HasReservationData,omitempty"`
	// The billing method of the Internet bandwidth of the IPv6 address. Valid values:
	//
	// **PostPaid**: pay-as-you-go
	InstanceChargeType *string `json:"InstanceChargeType,omitempty" xml:"InstanceChargeType,omitempty"`
	// The billing method of the Internet bandwidth of the IPv6 address. Valid values:
	//
	// *   **PayByTraffic**: pay-by-data-transfer
	// *   **PayByBandwidth**: pay-by-bandwidth
	InternetChargeType *string `json:"InternetChargeType,omitempty" xml:"InternetChargeType,omitempty"`
	// The instance ID of the Internet bandwidth of the IPv6 address.
	Ipv6InternetBandwidthId       *string `json:"Ipv6InternetBandwidthId,omitempty" xml:"Ipv6InternetBandwidthId,omitempty"`
	ReservationActiveTime         *string `json:"ReservationActiveTime,omitempty" xml:"ReservationActiveTime,omitempty"`
	ReservationBandwidth          *int64  `json:"ReservationBandwidth,omitempty" xml:"ReservationBandwidth,omitempty"`
	ReservationInternetChargeType *string `json:"ReservationInternetChargeType,omitempty" xml:"ReservationInternetChargeType,omitempty"`
	ReservationOrderType          *string `json:"ReservationOrderType,omitempty" xml:"ReservationOrderType,omitempty"`
}

func (s DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6AddressIpv6InternetBandwidth) String() string {
	return tea.Prettify(s)
}

func (s DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6AddressIpv6InternetBandwidth) GoString() string {
	return s.String()
}

func (s *DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6AddressIpv6InternetBandwidth) SetBandwidth(v int32) *DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6AddressIpv6InternetBandwidth {
	s.Bandwidth = &v
	return s
}

func (s *DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6AddressIpv6InternetBandwidth) SetBusinessStatus(v string) *DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6AddressIpv6InternetBandwidth {
	s.BusinessStatus = &v
	return s
}

func (s *DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6AddressIpv6InternetBandwidth) SetHasReservationData(v bool) *DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6AddressIpv6InternetBandwidth {
	s.HasReservationData = &v
	return s
}

func (s *DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6AddressIpv6InternetBandwidth) SetInstanceChargeType(v string) *DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6AddressIpv6InternetBandwidth {
	s.InstanceChargeType = &v
	return s
}

func (s *DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6AddressIpv6InternetBandwidth) SetInternetChargeType(v string) *DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6AddressIpv6InternetBandwidth {
	s.InternetChargeType = &v
	return s
}

func (s *DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6AddressIpv6InternetBandwidth) SetIpv6InternetBandwidthId(v string) *DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6AddressIpv6InternetBandwidth {
	s.Ipv6InternetBandwidthId = &v
	return s
}

func (s *DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6AddressIpv6InternetBandwidth) SetReservationActiveTime(v string) *DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6AddressIpv6InternetBandwidth {
	s.ReservationActiveTime = &v
	return s
}

func (s *DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6AddressIpv6InternetBandwidth) SetReservationBandwidth(v int64) *DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6AddressIpv6InternetBandwidth {
	s.ReservationBandwidth = &v
	return s
}

func (s *DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6AddressIpv6InternetBandwidth) SetReservationInternetChargeType(v string) *DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6AddressIpv6InternetBandwidth {
	s.ReservationInternetChargeType = &v
	return s
}

func (s *DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6AddressIpv6InternetBandwidth) SetReservationOrderType(v string) *DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6AddressIpv6InternetBandwidth {
	s.ReservationOrderType = &v
	return s
}

type DescribeIpv6AddressesResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeIpv6AddressesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeIpv6AddressesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeIpv6AddressesResponse) GoString() string {
	return s.String()
}

func (s *DescribeIpv6AddressesResponse) SetHeaders(v map[string]*string) *DescribeIpv6AddressesResponse {
	s.Headers = v
	return s
}

func (s *DescribeIpv6AddressesResponse) SetStatusCode(v int32) *DescribeIpv6AddressesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeIpv6AddressesResponse) SetBody(v *DescribeIpv6AddressesResponseBody) *DescribeIpv6AddressesResponse {
	s.Body = v
	return s
}

type DescribeIpv6EgressOnlyRulesRequest struct {
	// The ID of the instance that is associated with the IPv6 address to which the egress-only rule is applied.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The type of the instance to which you want to apply the egress-only rule. Set the value to
	//
	// **Ipv6Address**, which specifies that the egress-only rule applies to an IPv6 address.
	InstanceType *string `json:"InstanceType,omitempty" xml:"InstanceType,omitempty"`
	// The ID of the egress-only rule that you want to query.
	Ipv6EgressOnlyRuleId *string `json:"Ipv6EgressOnlyRuleId,omitempty" xml:"Ipv6EgressOnlyRuleId,omitempty"`
	// The ID of the IPv6 gateway.
	Ipv6GatewayId *string `json:"Ipv6GatewayId,omitempty" xml:"Ipv6GatewayId,omitempty"`
	// The name of the rule.
	Name         *string `json:"Name,omitempty" xml:"Name,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of the page to return. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Maximum value: **50**. Default value: **10**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the region where the IPv6 gateway is deployed. You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeIpv6EgressOnlyRulesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeIpv6EgressOnlyRulesRequest) GoString() string {
	return s.String()
}

func (s *DescribeIpv6EgressOnlyRulesRequest) SetInstanceId(v string) *DescribeIpv6EgressOnlyRulesRequest {
	s.InstanceId = &v
	return s
}

func (s *DescribeIpv6EgressOnlyRulesRequest) SetInstanceType(v string) *DescribeIpv6EgressOnlyRulesRequest {
	s.InstanceType = &v
	return s
}

func (s *DescribeIpv6EgressOnlyRulesRequest) SetIpv6EgressOnlyRuleId(v string) *DescribeIpv6EgressOnlyRulesRequest {
	s.Ipv6EgressOnlyRuleId = &v
	return s
}

func (s *DescribeIpv6EgressOnlyRulesRequest) SetIpv6GatewayId(v string) *DescribeIpv6EgressOnlyRulesRequest {
	s.Ipv6GatewayId = &v
	return s
}

func (s *DescribeIpv6EgressOnlyRulesRequest) SetName(v string) *DescribeIpv6EgressOnlyRulesRequest {
	s.Name = &v
	return s
}

func (s *DescribeIpv6EgressOnlyRulesRequest) SetOwnerAccount(v string) *DescribeIpv6EgressOnlyRulesRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeIpv6EgressOnlyRulesRequest) SetOwnerId(v int64) *DescribeIpv6EgressOnlyRulesRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeIpv6EgressOnlyRulesRequest) SetPageNumber(v int32) *DescribeIpv6EgressOnlyRulesRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeIpv6EgressOnlyRulesRequest) SetPageSize(v int32) *DescribeIpv6EgressOnlyRulesRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeIpv6EgressOnlyRulesRequest) SetRegionId(v string) *DescribeIpv6EgressOnlyRulesRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeIpv6EgressOnlyRulesRequest) SetResourceOwnerAccount(v string) *DescribeIpv6EgressOnlyRulesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeIpv6EgressOnlyRulesRequest) SetResourceOwnerId(v int64) *DescribeIpv6EgressOnlyRulesRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeIpv6EgressOnlyRulesResponseBody struct {
	// The details about the egress-only rules.
	Ipv6EgressOnlyRules *DescribeIpv6EgressOnlyRulesResponseBodyIpv6EgressOnlyRules `json:"Ipv6EgressOnlyRules,omitempty" xml:"Ipv6EgressOnlyRules,omitempty" type:"Struct"`
	// The number of the returned page. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page. Maximum value: **50**. Default value: **10**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeIpv6EgressOnlyRulesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeIpv6EgressOnlyRulesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeIpv6EgressOnlyRulesResponseBody) SetIpv6EgressOnlyRules(v *DescribeIpv6EgressOnlyRulesResponseBodyIpv6EgressOnlyRules) *DescribeIpv6EgressOnlyRulesResponseBody {
	s.Ipv6EgressOnlyRules = v
	return s
}

func (s *DescribeIpv6EgressOnlyRulesResponseBody) SetPageNumber(v int32) *DescribeIpv6EgressOnlyRulesResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeIpv6EgressOnlyRulesResponseBody) SetPageSize(v int32) *DescribeIpv6EgressOnlyRulesResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeIpv6EgressOnlyRulesResponseBody) SetRequestId(v string) *DescribeIpv6EgressOnlyRulesResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeIpv6EgressOnlyRulesResponseBody) SetTotalCount(v int32) *DescribeIpv6EgressOnlyRulesResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeIpv6EgressOnlyRulesResponseBodyIpv6EgressOnlyRules struct {
	Ipv6EgressOnlyRule []*DescribeIpv6EgressOnlyRulesResponseBodyIpv6EgressOnlyRulesIpv6EgressOnlyRule `json:"Ipv6EgressOnlyRule,omitempty" xml:"Ipv6EgressOnlyRule,omitempty" type:"Repeated"`
}

func (s DescribeIpv6EgressOnlyRulesResponseBodyIpv6EgressOnlyRules) String() string {
	return tea.Prettify(s)
}

func (s DescribeIpv6EgressOnlyRulesResponseBodyIpv6EgressOnlyRules) GoString() string {
	return s.String()
}

func (s *DescribeIpv6EgressOnlyRulesResponseBodyIpv6EgressOnlyRules) SetIpv6EgressOnlyRule(v []*DescribeIpv6EgressOnlyRulesResponseBodyIpv6EgressOnlyRulesIpv6EgressOnlyRule) *DescribeIpv6EgressOnlyRulesResponseBodyIpv6EgressOnlyRules {
	s.Ipv6EgressOnlyRule = v
	return s
}

type DescribeIpv6EgressOnlyRulesResponseBodyIpv6EgressOnlyRulesIpv6EgressOnlyRule struct {
	// The description of the egress-only rule.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the instance to which the egress-only rule applies.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The type of the instance to which the egress-only rule applies.
	InstanceType *string `json:"InstanceType,omitempty" xml:"InstanceType,omitempty"`
	// The ID of the egress-only rule.
	Ipv6EgressOnlyRuleId *string `json:"Ipv6EgressOnlyRuleId,omitempty" xml:"Ipv6EgressOnlyRuleId,omitempty"`
	// The name of the egress-only rule.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The status of the egress-only rule.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeIpv6EgressOnlyRulesResponseBodyIpv6EgressOnlyRulesIpv6EgressOnlyRule) String() string {
	return tea.Prettify(s)
}

func (s DescribeIpv6EgressOnlyRulesResponseBodyIpv6EgressOnlyRulesIpv6EgressOnlyRule) GoString() string {
	return s.String()
}

func (s *DescribeIpv6EgressOnlyRulesResponseBodyIpv6EgressOnlyRulesIpv6EgressOnlyRule) SetDescription(v string) *DescribeIpv6EgressOnlyRulesResponseBodyIpv6EgressOnlyRulesIpv6EgressOnlyRule {
	s.Description = &v
	return s
}

func (s *DescribeIpv6EgressOnlyRulesResponseBodyIpv6EgressOnlyRulesIpv6EgressOnlyRule) SetInstanceId(v string) *DescribeIpv6EgressOnlyRulesResponseBodyIpv6EgressOnlyRulesIpv6EgressOnlyRule {
	s.InstanceId = &v
	return s
}

func (s *DescribeIpv6EgressOnlyRulesResponseBodyIpv6EgressOnlyRulesIpv6EgressOnlyRule) SetInstanceType(v string) *DescribeIpv6EgressOnlyRulesResponseBodyIpv6EgressOnlyRulesIpv6EgressOnlyRule {
	s.InstanceType = &v
	return s
}

func (s *DescribeIpv6EgressOnlyRulesResponseBodyIpv6EgressOnlyRulesIpv6EgressOnlyRule) SetIpv6EgressOnlyRuleId(v string) *DescribeIpv6EgressOnlyRulesResponseBodyIpv6EgressOnlyRulesIpv6EgressOnlyRule {
	s.Ipv6EgressOnlyRuleId = &v
	return s
}

func (s *DescribeIpv6EgressOnlyRulesResponseBodyIpv6EgressOnlyRulesIpv6EgressOnlyRule) SetName(v string) *DescribeIpv6EgressOnlyRulesResponseBodyIpv6EgressOnlyRulesIpv6EgressOnlyRule {
	s.Name = &v
	return s
}

func (s *DescribeIpv6EgressOnlyRulesResponseBodyIpv6EgressOnlyRulesIpv6EgressOnlyRule) SetStatus(v string) *DescribeIpv6EgressOnlyRulesResponseBodyIpv6EgressOnlyRulesIpv6EgressOnlyRule {
	s.Status = &v
	return s
}

type DescribeIpv6EgressOnlyRulesResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeIpv6EgressOnlyRulesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeIpv6EgressOnlyRulesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeIpv6EgressOnlyRulesResponse) GoString() string {
	return s.String()
}

func (s *DescribeIpv6EgressOnlyRulesResponse) SetHeaders(v map[string]*string) *DescribeIpv6EgressOnlyRulesResponse {
	s.Headers = v
	return s
}

func (s *DescribeIpv6EgressOnlyRulesResponse) SetStatusCode(v int32) *DescribeIpv6EgressOnlyRulesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeIpv6EgressOnlyRulesResponse) SetBody(v *DescribeIpv6EgressOnlyRulesResponseBody) *DescribeIpv6EgressOnlyRulesResponse {
	s.Body = v
	return s
}

type DescribeIpv6GatewayAttributeRequest struct {
	// The ID of the IPv6 gateway that you want to query.
	Ipv6GatewayId *string `json:"Ipv6GatewayId,omitempty" xml:"Ipv6GatewayId,omitempty"`
	OwnerAccount  *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region where the IPv6 gateway is deployed. You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeIpv6GatewayAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeIpv6GatewayAttributeRequest) GoString() string {
	return s.String()
}

func (s *DescribeIpv6GatewayAttributeRequest) SetIpv6GatewayId(v string) *DescribeIpv6GatewayAttributeRequest {
	s.Ipv6GatewayId = &v
	return s
}

func (s *DescribeIpv6GatewayAttributeRequest) SetOwnerAccount(v string) *DescribeIpv6GatewayAttributeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeIpv6GatewayAttributeRequest) SetOwnerId(v int64) *DescribeIpv6GatewayAttributeRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeIpv6GatewayAttributeRequest) SetRegionId(v string) *DescribeIpv6GatewayAttributeRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeIpv6GatewayAttributeRequest) SetResourceOwnerAccount(v string) *DescribeIpv6GatewayAttributeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeIpv6GatewayAttributeRequest) SetResourceOwnerId(v int64) *DescribeIpv6GatewayAttributeRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeIpv6GatewayAttributeResponseBody struct {
	// The service status of the IPv6 gateway. Valid values:
	//
	// *   **Normal**: The IPv6 gateway runs as expected.
	// *   **FinacialLocked**: The IPv6 gateway is locked due to overdue payments.
	// *   **SecurityLocked**: The IPv6 gateway is locked due to security reasons.
	BusinessStatus *string `json:"BusinessStatus,omitempty" xml:"BusinessStatus,omitempty"`
	// The time when the IPv6 gateway was created.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The description of the IPv6 gateway.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The time when the IPv6 gateway expires.
	ExpiredTime *string `json:"ExpiredTime,omitempty" xml:"ExpiredTime,omitempty"`
	// The metering method of the IPv6 gateway.
	InstanceChargeType *string `json:"InstanceChargeType,omitempty" xml:"InstanceChargeType,omitempty"`
	// The ID of the IPv6 gateway.
	Ipv6GatewayId *string `json:"Ipv6GatewayId,omitempty" xml:"Ipv6GatewayId,omitempty"`
	// The name of the IPv6 gateway.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the region where the IPv6 gateway is deployed.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The status of the IPv6 gateway. Valid values:
	//
	// *   **Pending**
	// *   **Available**
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The list of tags.
	Tags *DescribeIpv6GatewayAttributeResponseBodyTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Struct"`
	// The ID of the virtual private cloud (VPC) to which the IPv6 gateway belongs.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s DescribeIpv6GatewayAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeIpv6GatewayAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeIpv6GatewayAttributeResponseBody) SetBusinessStatus(v string) *DescribeIpv6GatewayAttributeResponseBody {
	s.BusinessStatus = &v
	return s
}

func (s *DescribeIpv6GatewayAttributeResponseBody) SetCreationTime(v string) *DescribeIpv6GatewayAttributeResponseBody {
	s.CreationTime = &v
	return s
}

func (s *DescribeIpv6GatewayAttributeResponseBody) SetDescription(v string) *DescribeIpv6GatewayAttributeResponseBody {
	s.Description = &v
	return s
}

func (s *DescribeIpv6GatewayAttributeResponseBody) SetExpiredTime(v string) *DescribeIpv6GatewayAttributeResponseBody {
	s.ExpiredTime = &v
	return s
}

func (s *DescribeIpv6GatewayAttributeResponseBody) SetInstanceChargeType(v string) *DescribeIpv6GatewayAttributeResponseBody {
	s.InstanceChargeType = &v
	return s
}

func (s *DescribeIpv6GatewayAttributeResponseBody) SetIpv6GatewayId(v string) *DescribeIpv6GatewayAttributeResponseBody {
	s.Ipv6GatewayId = &v
	return s
}

func (s *DescribeIpv6GatewayAttributeResponseBody) SetName(v string) *DescribeIpv6GatewayAttributeResponseBody {
	s.Name = &v
	return s
}

func (s *DescribeIpv6GatewayAttributeResponseBody) SetRegionId(v string) *DescribeIpv6GatewayAttributeResponseBody {
	s.RegionId = &v
	return s
}

func (s *DescribeIpv6GatewayAttributeResponseBody) SetRequestId(v string) *DescribeIpv6GatewayAttributeResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeIpv6GatewayAttributeResponseBody) SetResourceGroupId(v string) *DescribeIpv6GatewayAttributeResponseBody {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeIpv6GatewayAttributeResponseBody) SetStatus(v string) *DescribeIpv6GatewayAttributeResponseBody {
	s.Status = &v
	return s
}

func (s *DescribeIpv6GatewayAttributeResponseBody) SetTags(v *DescribeIpv6GatewayAttributeResponseBodyTags) *DescribeIpv6GatewayAttributeResponseBody {
	s.Tags = v
	return s
}

func (s *DescribeIpv6GatewayAttributeResponseBody) SetVpcId(v string) *DescribeIpv6GatewayAttributeResponseBody {
	s.VpcId = &v
	return s
}

type DescribeIpv6GatewayAttributeResponseBodyTags struct {
	Tag []*DescribeIpv6GatewayAttributeResponseBodyTagsTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s DescribeIpv6GatewayAttributeResponseBodyTags) String() string {
	return tea.Prettify(s)
}

func (s DescribeIpv6GatewayAttributeResponseBodyTags) GoString() string {
	return s.String()
}

func (s *DescribeIpv6GatewayAttributeResponseBodyTags) SetTag(v []*DescribeIpv6GatewayAttributeResponseBodyTagsTag) *DescribeIpv6GatewayAttributeResponseBodyTags {
	s.Tag = v
	return s
}

type DescribeIpv6GatewayAttributeResponseBodyTagsTag struct {
	// The tag key.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeIpv6GatewayAttributeResponseBodyTagsTag) String() string {
	return tea.Prettify(s)
}

func (s DescribeIpv6GatewayAttributeResponseBodyTagsTag) GoString() string {
	return s.String()
}

func (s *DescribeIpv6GatewayAttributeResponseBodyTagsTag) SetKey(v string) *DescribeIpv6GatewayAttributeResponseBodyTagsTag {
	s.Key = &v
	return s
}

func (s *DescribeIpv6GatewayAttributeResponseBodyTagsTag) SetValue(v string) *DescribeIpv6GatewayAttributeResponseBodyTagsTag {
	s.Value = &v
	return s
}

type DescribeIpv6GatewayAttributeResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeIpv6GatewayAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeIpv6GatewayAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeIpv6GatewayAttributeResponse) GoString() string {
	return s.String()
}

func (s *DescribeIpv6GatewayAttributeResponse) SetHeaders(v map[string]*string) *DescribeIpv6GatewayAttributeResponse {
	s.Headers = v
	return s
}

func (s *DescribeIpv6GatewayAttributeResponse) SetStatusCode(v int32) *DescribeIpv6GatewayAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeIpv6GatewayAttributeResponse) SetBody(v *DescribeIpv6GatewayAttributeResponseBody) *DescribeIpv6GatewayAttributeResponse {
	s.Body = v
	return s
}

type DescribeIpv6GatewaysRequest struct {
	// The ID of the IPv6 gateway.
	Ipv6GatewayId *string `json:"Ipv6GatewayId,omitempty" xml:"Ipv6GatewayId,omitempty"`
	// The name of the IPv6 gateway.
	//
	// The name must be 2 to 256 characters in length, and can contain letters, digits, periods (.), underscores (\_), and hyphens (-). The name must start with a letter. It cannot start with `http://` or `https://`.
	Name         *string `json:"Name,omitempty" xml:"Name,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of the page to return.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the region where the IPv6 gateway is deployed.
	//
	// >  IPv6 gateways are available in the following regions: China (Qingdao), China (Beijing), China (Zhangjiakou), China (Hohhot), China (Ulanqab), China (Hangzhou), China (Shanghai), China (Shenzhen), China (Heyuan), China (Guangzhou), China (Chengdu), China (Hong Kong), Philippines (Manila), Singapore, US (Virginia), and Germany (Frankfurt).
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId      *string                            `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string                            `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64                             `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	Tags                 []*DescribeIpv6GatewaysRequestTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
	// The ID of the virtual private cloud (VPC) to which the IPv6 gateway belongs.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s DescribeIpv6GatewaysRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeIpv6GatewaysRequest) GoString() string {
	return s.String()
}

func (s *DescribeIpv6GatewaysRequest) SetIpv6GatewayId(v string) *DescribeIpv6GatewaysRequest {
	s.Ipv6GatewayId = &v
	return s
}

func (s *DescribeIpv6GatewaysRequest) SetName(v string) *DescribeIpv6GatewaysRequest {
	s.Name = &v
	return s
}

func (s *DescribeIpv6GatewaysRequest) SetOwnerAccount(v string) *DescribeIpv6GatewaysRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeIpv6GatewaysRequest) SetOwnerId(v int64) *DescribeIpv6GatewaysRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeIpv6GatewaysRequest) SetPageNumber(v int32) *DescribeIpv6GatewaysRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeIpv6GatewaysRequest) SetPageSize(v int32) *DescribeIpv6GatewaysRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeIpv6GatewaysRequest) SetRegionId(v string) *DescribeIpv6GatewaysRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeIpv6GatewaysRequest) SetResourceGroupId(v string) *DescribeIpv6GatewaysRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeIpv6GatewaysRequest) SetResourceOwnerAccount(v string) *DescribeIpv6GatewaysRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeIpv6GatewaysRequest) SetResourceOwnerId(v int64) *DescribeIpv6GatewaysRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeIpv6GatewaysRequest) SetTags(v []*DescribeIpv6GatewaysRequestTags) *DescribeIpv6GatewaysRequest {
	s.Tags = v
	return s
}

func (s *DescribeIpv6GatewaysRequest) SetVpcId(v string) *DescribeIpv6GatewaysRequest {
	s.VpcId = &v
	return s
}

type DescribeIpv6GatewaysRequestTags struct {
	// The key of the tag. The tag key cannot be an empty string.
	//
	// It must be 1 to 64 characters in length, and cannot contain `http://` or `https://`. It cannot start with `aliyun` or `acs:`.
	//
	// You can specify at most 20 tag keys in each call.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The value of the tag.
	//
	// The tag value can be an empty string and must be 1 to 128 characters in length. It cannot start with `aliyun` or `acs:`, and cannot contain `http://` or `https://`.
	//
	// Each tag key corresponds to one tag value. You can specify at most 20 tag values in each call.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeIpv6GatewaysRequestTags) String() string {
	return tea.Prettify(s)
}

func (s DescribeIpv6GatewaysRequestTags) GoString() string {
	return s.String()
}

func (s *DescribeIpv6GatewaysRequestTags) SetKey(v string) *DescribeIpv6GatewaysRequestTags {
	s.Key = &v
	return s
}

func (s *DescribeIpv6GatewaysRequestTags) SetValue(v string) *DescribeIpv6GatewaysRequestTags {
	s.Value = &v
	return s
}

type DescribeIpv6GatewaysResponseBody struct {
	// The details about the IPv6 gateways.
	Ipv6Gateways *DescribeIpv6GatewaysResponseBodyIpv6Gateways `json:"Ipv6Gateways,omitempty" xml:"Ipv6Gateways,omitempty" type:"Struct"`
	// The number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeIpv6GatewaysResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeIpv6GatewaysResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeIpv6GatewaysResponseBody) SetIpv6Gateways(v *DescribeIpv6GatewaysResponseBodyIpv6Gateways) *DescribeIpv6GatewaysResponseBody {
	s.Ipv6Gateways = v
	return s
}

func (s *DescribeIpv6GatewaysResponseBody) SetPageNumber(v int32) *DescribeIpv6GatewaysResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeIpv6GatewaysResponseBody) SetPageSize(v int32) *DescribeIpv6GatewaysResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeIpv6GatewaysResponseBody) SetRequestId(v string) *DescribeIpv6GatewaysResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeIpv6GatewaysResponseBody) SetTotalCount(v int32) *DescribeIpv6GatewaysResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeIpv6GatewaysResponseBodyIpv6Gateways struct {
	Ipv6Gateway []*DescribeIpv6GatewaysResponseBodyIpv6GatewaysIpv6Gateway `json:"Ipv6Gateway,omitempty" xml:"Ipv6Gateway,omitempty" type:"Repeated"`
}

func (s DescribeIpv6GatewaysResponseBodyIpv6Gateways) String() string {
	return tea.Prettify(s)
}

func (s DescribeIpv6GatewaysResponseBodyIpv6Gateways) GoString() string {
	return s.String()
}

func (s *DescribeIpv6GatewaysResponseBodyIpv6Gateways) SetIpv6Gateway(v []*DescribeIpv6GatewaysResponseBodyIpv6GatewaysIpv6Gateway) *DescribeIpv6GatewaysResponseBodyIpv6Gateways {
	s.Ipv6Gateway = v
	return s
}

type DescribeIpv6GatewaysResponseBodyIpv6GatewaysIpv6Gateway struct {
	// The state of the IPv6 gateway. Valid values:
	//
	// *   **Normal**: The IPv6 gateway runs as expected.
	// *   **FinancialLocked**: The IPv6 gateway is locked due to overdue payments.
	BusinessStatus *string `json:"BusinessStatus,omitempty" xml:"BusinessStatus,omitempty"`
	// The time when the IPv6 gateway was created.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The description of the IPv6 gateway.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The time when the IPv6 gateway expires.
	ExpiredTime *string `json:"ExpiredTime,omitempty" xml:"ExpiredTime,omitempty"`
	// The billing method of the IPv6 gateway.
	//
	// The value is set to **PostPaid**. This value indicates the pay-as-you-go billing method.
	InstanceChargeType *string `json:"InstanceChargeType,omitempty" xml:"InstanceChargeType,omitempty"`
	// The ID of the IPv6 gateway.
	Ipv6GatewayId *string `json:"Ipv6GatewayId,omitempty" xml:"Ipv6GatewayId,omitempty"`
	// The name of the IPv6 gateway.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The region ID of the IPv6 gateway.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The state of the IPv6 gateway. Valid values:
	//
	// *   **Pending**: The IPv6 gateway is being configured.
	// *   **Available**: The IPv6 gateway is available.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The list of tags.
	Tags *DescribeIpv6GatewaysResponseBodyIpv6GatewaysIpv6GatewayTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Struct"`
	// The ID of the VPC to which the IPv6 gateway belongs.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s DescribeIpv6GatewaysResponseBodyIpv6GatewaysIpv6Gateway) String() string {
	return tea.Prettify(s)
}

func (s DescribeIpv6GatewaysResponseBodyIpv6GatewaysIpv6Gateway) GoString() string {
	return s.String()
}

func (s *DescribeIpv6GatewaysResponseBodyIpv6GatewaysIpv6Gateway) SetBusinessStatus(v string) *DescribeIpv6GatewaysResponseBodyIpv6GatewaysIpv6Gateway {
	s.BusinessStatus = &v
	return s
}

func (s *DescribeIpv6GatewaysResponseBodyIpv6GatewaysIpv6Gateway) SetCreationTime(v string) *DescribeIpv6GatewaysResponseBodyIpv6GatewaysIpv6Gateway {
	s.CreationTime = &v
	return s
}

func (s *DescribeIpv6GatewaysResponseBodyIpv6GatewaysIpv6Gateway) SetDescription(v string) *DescribeIpv6GatewaysResponseBodyIpv6GatewaysIpv6Gateway {
	s.Description = &v
	return s
}

func (s *DescribeIpv6GatewaysResponseBodyIpv6GatewaysIpv6Gateway) SetExpiredTime(v string) *DescribeIpv6GatewaysResponseBodyIpv6GatewaysIpv6Gateway {
	s.ExpiredTime = &v
	return s
}

func (s *DescribeIpv6GatewaysResponseBodyIpv6GatewaysIpv6Gateway) SetInstanceChargeType(v string) *DescribeIpv6GatewaysResponseBodyIpv6GatewaysIpv6Gateway {
	s.InstanceChargeType = &v
	return s
}

func (s *DescribeIpv6GatewaysResponseBodyIpv6GatewaysIpv6Gateway) SetIpv6GatewayId(v string) *DescribeIpv6GatewaysResponseBodyIpv6GatewaysIpv6Gateway {
	s.Ipv6GatewayId = &v
	return s
}

func (s *DescribeIpv6GatewaysResponseBodyIpv6GatewaysIpv6Gateway) SetName(v string) *DescribeIpv6GatewaysResponseBodyIpv6GatewaysIpv6Gateway {
	s.Name = &v
	return s
}

func (s *DescribeIpv6GatewaysResponseBodyIpv6GatewaysIpv6Gateway) SetRegionId(v string) *DescribeIpv6GatewaysResponseBodyIpv6GatewaysIpv6Gateway {
	s.RegionId = &v
	return s
}

func (s *DescribeIpv6GatewaysResponseBodyIpv6GatewaysIpv6Gateway) SetResourceGroupId(v string) *DescribeIpv6GatewaysResponseBodyIpv6GatewaysIpv6Gateway {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeIpv6GatewaysResponseBodyIpv6GatewaysIpv6Gateway) SetStatus(v string) *DescribeIpv6GatewaysResponseBodyIpv6GatewaysIpv6Gateway {
	s.Status = &v
	return s
}

func (s *DescribeIpv6GatewaysResponseBodyIpv6GatewaysIpv6Gateway) SetTags(v *DescribeIpv6GatewaysResponseBodyIpv6GatewaysIpv6GatewayTags) *DescribeIpv6GatewaysResponseBodyIpv6GatewaysIpv6Gateway {
	s.Tags = v
	return s
}

func (s *DescribeIpv6GatewaysResponseBodyIpv6GatewaysIpv6Gateway) SetVpcId(v string) *DescribeIpv6GatewaysResponseBodyIpv6GatewaysIpv6Gateway {
	s.VpcId = &v
	return s
}

type DescribeIpv6GatewaysResponseBodyIpv6GatewaysIpv6GatewayTags struct {
	Tag []*DescribeIpv6GatewaysResponseBodyIpv6GatewaysIpv6GatewayTagsTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s DescribeIpv6GatewaysResponseBodyIpv6GatewaysIpv6GatewayTags) String() string {
	return tea.Prettify(s)
}

func (s DescribeIpv6GatewaysResponseBodyIpv6GatewaysIpv6GatewayTags) GoString() string {
	return s.String()
}

func (s *DescribeIpv6GatewaysResponseBodyIpv6GatewaysIpv6GatewayTags) SetTag(v []*DescribeIpv6GatewaysResponseBodyIpv6GatewaysIpv6GatewayTagsTag) *DescribeIpv6GatewaysResponseBodyIpv6GatewaysIpv6GatewayTags {
	s.Tag = v
	return s
}

type DescribeIpv6GatewaysResponseBodyIpv6GatewaysIpv6GatewayTagsTag struct {
	// The key of the tag.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The value of the tag.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeIpv6GatewaysResponseBodyIpv6GatewaysIpv6GatewayTagsTag) String() string {
	return tea.Prettify(s)
}

func (s DescribeIpv6GatewaysResponseBodyIpv6GatewaysIpv6GatewayTagsTag) GoString() string {
	return s.String()
}

func (s *DescribeIpv6GatewaysResponseBodyIpv6GatewaysIpv6GatewayTagsTag) SetKey(v string) *DescribeIpv6GatewaysResponseBodyIpv6GatewaysIpv6GatewayTagsTag {
	s.Key = &v
	return s
}

func (s *DescribeIpv6GatewaysResponseBodyIpv6GatewaysIpv6GatewayTagsTag) SetValue(v string) *DescribeIpv6GatewaysResponseBodyIpv6GatewaysIpv6GatewayTagsTag {
	s.Value = &v
	return s
}

type DescribeIpv6GatewaysResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeIpv6GatewaysResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeIpv6GatewaysResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeIpv6GatewaysResponse) GoString() string {
	return s.String()
}

func (s *DescribeIpv6GatewaysResponse) SetHeaders(v map[string]*string) *DescribeIpv6GatewaysResponse {
	s.Headers = v
	return s
}

func (s *DescribeIpv6GatewaysResponse) SetStatusCode(v int32) *DescribeIpv6GatewaysResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeIpv6GatewaysResponse) SetBody(v *DescribeIpv6GatewaysResponseBody) *DescribeIpv6GatewaysResponse {
	s.Body = v
	return s
}

type DescribeNatGatewaysRequest struct {
	// Specifies whether to perform a dry run. Valid values:
	//
	// - **true**: performs a dry run. The system prechecks whether your AccessKey pair is valid, whether the RAM user is authorized, and whether the required parameters are specified. If the request fails the dry run, an error message is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
	// - **false** (default): performs a dry run and sends the request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The billing method of the NAT gateway. Set the value to **PostPaid**, which specifies the pay-as-you-go billing method.
	InstanceChargeType *string `json:"InstanceChargeType,omitempty" xml:"InstanceChargeType,omitempty"`
	// The name of the NAT gateway.
	//
	// The name must be 1 to 128 characters in length, and cannot start with `http://` or `https://`.
	//
	// If this parameter is not set, the system automatically assigns a name to the NAT gateway.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the NAT gateway.
	NatGatewayId *string `json:"NatGatewayId,omitempty" xml:"NatGatewayId,omitempty"`
	// The type of NAT gateway. Set the value to **Enhanced** (enhanced NAT gateway).
	NatType *string `json:"NatType,omitempty" xml:"NatType,omitempty"`
	// The type of the NAT gateway. Valid values:
	//
	// *   **internet**: an Internet NAT gateway
	// *   **intranet**: a VPC NAT gateway
	NetworkType  *string `json:"NetworkType,omitempty" xml:"NetworkType,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of the page to return. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Maximum value: **50**. Default value: **10**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The region ID of the NAT gateways that you want to query.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group to which the NAT gateway belongs.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The size of the NAT gateway. Ignore this parameter.
	Spec *string `json:"Spec,omitempty" xml:"Spec,omitempty"`
	// The status of the NAT gateway. Valid values:
	//
	// *   **Creating**: After you send a request to create a NAT gateway, the system creates the NAT gateway in the background. The NAT gateway remains in the **Creating** state until the operation is completed.
	// *   **Available**: The NAT gateway remains in a stable state after the NAT gateway is created.
	// *   **Modifying**: After you send a request to modify a NAT gateway, the system modifies the NAT gateway in the background. The NAT gateway remains in the **Modifying** state until the operation is completed.
	// *   **Deleting**: After you send a request to delete a NAT gateway, the system deletes the NAT gateway in the background. The NAT gateway remains in the **Deleting** state until the operation is completed.
	// *   **Converting**: After you send a request to upgrade a standard NAT gateway to an enhanced NAT gateway, the system upgrades the NAT gateway in the background. The NAT gateway remains in the **Converting** state until the operation is completed.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The tags.
	Tag []*DescribeNatGatewaysRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
	// The ID of the VPC to which the NAT gateway belongs.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
	// The ID of the zone to which the NAT gateway belongs.
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
}

func (s DescribeNatGatewaysRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeNatGatewaysRequest) GoString() string {
	return s.String()
}

func (s *DescribeNatGatewaysRequest) SetDryRun(v bool) *DescribeNatGatewaysRequest {
	s.DryRun = &v
	return s
}

func (s *DescribeNatGatewaysRequest) SetInstanceChargeType(v string) *DescribeNatGatewaysRequest {
	s.InstanceChargeType = &v
	return s
}

func (s *DescribeNatGatewaysRequest) SetName(v string) *DescribeNatGatewaysRequest {
	s.Name = &v
	return s
}

func (s *DescribeNatGatewaysRequest) SetNatGatewayId(v string) *DescribeNatGatewaysRequest {
	s.NatGatewayId = &v
	return s
}

func (s *DescribeNatGatewaysRequest) SetNatType(v string) *DescribeNatGatewaysRequest {
	s.NatType = &v
	return s
}

func (s *DescribeNatGatewaysRequest) SetNetworkType(v string) *DescribeNatGatewaysRequest {
	s.NetworkType = &v
	return s
}

func (s *DescribeNatGatewaysRequest) SetOwnerAccount(v string) *DescribeNatGatewaysRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeNatGatewaysRequest) SetOwnerId(v int64) *DescribeNatGatewaysRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeNatGatewaysRequest) SetPageNumber(v int32) *DescribeNatGatewaysRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeNatGatewaysRequest) SetPageSize(v int32) *DescribeNatGatewaysRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeNatGatewaysRequest) SetRegionId(v string) *DescribeNatGatewaysRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeNatGatewaysRequest) SetResourceGroupId(v string) *DescribeNatGatewaysRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeNatGatewaysRequest) SetResourceOwnerAccount(v string) *DescribeNatGatewaysRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeNatGatewaysRequest) SetResourceOwnerId(v int64) *DescribeNatGatewaysRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeNatGatewaysRequest) SetSpec(v string) *DescribeNatGatewaysRequest {
	s.Spec = &v
	return s
}

func (s *DescribeNatGatewaysRequest) SetStatus(v string) *DescribeNatGatewaysRequest {
	s.Status = &v
	return s
}

func (s *DescribeNatGatewaysRequest) SetTag(v []*DescribeNatGatewaysRequestTag) *DescribeNatGatewaysRequest {
	s.Tag = v
	return s
}

func (s *DescribeNatGatewaysRequest) SetVpcId(v string) *DescribeNatGatewaysRequest {
	s.VpcId = &v
	return s
}

func (s *DescribeNatGatewaysRequest) SetZoneId(v string) *DescribeNatGatewaysRequest {
	s.ZoneId = &v
	return s
}

type DescribeNatGatewaysRequestTag struct {
	// The tag keys of the NAT gateway. You can specify up to 20 tag keys.
	//
	// Each tag key cannot exceed 64 characters in length, and cannot start with `aliyun` or `acs:`. It cannot contain `http://` or `https://`.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag values of the NAT gateway. You can specify up to 20 tag values.
	//
	// The tag value cannot exceed 128 characters in length, and cannot start with `aliyun` or `acs:`. The value cannot contain `http://` or `https://`.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeNatGatewaysRequestTag) String() string {
	return tea.Prettify(s)
}

func (s DescribeNatGatewaysRequestTag) GoString() string {
	return s.String()
}

func (s *DescribeNatGatewaysRequestTag) SetKey(v string) *DescribeNatGatewaysRequestTag {
	s.Key = &v
	return s
}

func (s *DescribeNatGatewaysRequestTag) SetValue(v string) *DescribeNatGatewaysRequestTag {
	s.Value = &v
	return s
}

type DescribeNatGatewaysResponseBody struct {
	// The details about the NAT gateway.
	NatGateways *DescribeNatGatewaysResponseBodyNatGateways `json:"NatGateways,omitempty" xml:"NatGateways,omitempty" type:"Struct"`
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The number of NAT gateway entries that are returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeNatGatewaysResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeNatGatewaysResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeNatGatewaysResponseBody) SetNatGateways(v *DescribeNatGatewaysResponseBodyNatGateways) *DescribeNatGatewaysResponseBody {
	s.NatGateways = v
	return s
}

func (s *DescribeNatGatewaysResponseBody) SetPageNumber(v int32) *DescribeNatGatewaysResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeNatGatewaysResponseBody) SetPageSize(v int32) *DescribeNatGatewaysResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeNatGatewaysResponseBody) SetRequestId(v string) *DescribeNatGatewaysResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeNatGatewaysResponseBody) SetTotalCount(v int32) *DescribeNatGatewaysResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeNatGatewaysResponseBodyNatGateways struct {
	NatGateway []*DescribeNatGatewaysResponseBodyNatGatewaysNatGateway `json:"NatGateway,omitempty" xml:"NatGateway,omitempty" type:"Repeated"`
}

func (s DescribeNatGatewaysResponseBodyNatGateways) String() string {
	return tea.Prettify(s)
}

func (s DescribeNatGatewaysResponseBodyNatGateways) GoString() string {
	return s.String()
}

func (s *DescribeNatGatewaysResponseBodyNatGateways) SetNatGateway(v []*DescribeNatGatewaysResponseBodyNatGatewaysNatGateway) *DescribeNatGatewaysResponseBodyNatGateways {
	s.NatGateway = v
	return s
}

type DescribeNatGatewaysResponseBodyNatGatewaysNatGateway struct {
	// Indicates whether automatic payment is enabled. Valid values:
	//
	// *   **false**: no
	// *   **true**: yes
	AutoPay *bool `json:"AutoPay,omitempty" xml:"AutoPay,omitempty"`
	// The status of the NAT gateway. Valid values:
	//
	// *   **Normal**: normal
	// *   **FinancialLocked**: locked due to overdue payments
	BusinessStatus *string `json:"BusinessStatus,omitempty" xml:"BusinessStatus,omitempty"`
	// The time when the NAT gateway was created.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// Indicates whether the deletion protection feature is enabled. Valid values:
	//
	// *   **true**: yes
	// *   **false**: no
	DeletionProtection *bool `json:"DeletionProtection,omitempty" xml:"DeletionProtection,omitempty"`
	// The description of the NAT gateway.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// Indicates whether the traffic monitoring feature is enabled. Valid values:
	//
	// *   **true**: yes
	// *   **false**: no
	EcsMetricEnabled *bool `json:"EcsMetricEnabled,omitempty" xml:"EcsMetricEnabled,omitempty"`
	// The mode in which the NAT gateway is associated with an elastic IP address (EIP). Valid values:
	//
	// *   **MULTI_BINDED**: multi-EIP-to-ENI mode
	// *   **NAT**: NAT mode, which is compatible with IPv4 addresses.
	//
	// >  Note: If you use the NAT mode, the EIP occupies one private IP address on the vSwitch of the NAT gateway. Make sure that the vSwitch has sufficient private IP addresses. Otherwise, the NAT gateway fails to be associated with the EIP. In NAT mode, you can associate a NAT gateway with up to 50 EIPs.
	EipBindMode *string `json:"EipBindMode,omitempty" xml:"EipBindMode,omitempty"`
	// The time when the NAT gateway expires.
	ExpiredTime *string `json:"ExpiredTime,omitempty" xml:"ExpiredTime,omitempty"`
	// The ID of the DNAT table.
	ForwardTableIds *DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayForwardTableIds `json:"ForwardTableIds,omitempty" xml:"ForwardTableIds,omitempty" type:"Struct"`
	// The ID of the FULLNAT table.
	FullNatTableIds *DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayFullNatTableIds `json:"FullNatTableIds,omitempty" xml:"FullNatTableIds,omitempty" type:"Struct"`
	// Indicates whether the ICMP non-retrieval feature is enabled. Valid values:
	//
	// *   **true**: yes
	// *   **false**: no
	IcmpReplyEnabled *bool `json:"IcmpReplyEnabled,omitempty" xml:"IcmpReplyEnabled,omitempty"`
	// The billing method of the NAT gateway. The value is set to **PostPaid**, which indicates the pay-as-you-go billing method.
	InstanceChargeType *string `json:"InstanceChargeType,omitempty" xml:"InstanceChargeType,omitempty"`
	// The metering method of the NAT gateway. Valid values:
	//
	// *   **PayBySpec**: pay-by-specification
	// *   **PayByLcu**: pay-by-CU
	InternetChargeType *string `json:"InternetChargeType,omitempty" xml:"InternetChargeType,omitempty"`
	// The list of elastic IP addresses (EIPs) that are associated with the Internet NAT gateway.
	IpLists *DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayIpLists `json:"IpLists,omitempty" xml:"IpLists,omitempty" type:"Struct"`
	// The name of the NAT gateway.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the NAT gateway.
	NatGatewayId *string `json:"NatGatewayId,omitempty" xml:"NatGatewayId,omitempty"`
	// The private network information about the enhanced Internet NAT gateway.
	//
	// >  If **NatType** is set to **Normal**, all parameters returned in this list are empty.
	NatGatewayPrivateInfo *DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayNatGatewayPrivateInfo `json:"NatGatewayPrivateInfo,omitempty" xml:"NatGatewayPrivateInfo,omitempty" type:"Struct"`
	// The type of the NAT gateway. The value is set to **Enhanced** (enhanced NAT gateway).
	NatType *string `json:"NatType,omitempty" xml:"NatType,omitempty"`
	// The type of NAT gateway. Valid values:
	//
	// *   **internet**: an Internet NAT gateway
	// *   **intranet**: a VPC NAT gateway
	NetworkType *string `json:"NetworkType,omitempty" xml:"NetworkType,omitempty"`
	// Indicates whether the NAT gateway supports PrivateLink. Valid values:
	//
	// *   **true**: yes
	// *   **false**: no
	PrivateLinkEnabled *bool `json:"PrivateLinkEnabled,omitempty" xml:"PrivateLinkEnabled,omitempty"`
	// The mode that is used by PrivateLink. Valid values:
	//
	// *   **FullNat**: the FULLNAT mode
	// *   **Geneve**: the GENEVE mode
	PrivateLinkMode *string `json:"PrivateLinkMode,omitempty" xml:"PrivateLinkMode,omitempty"`
	// The ID of the region where the NAT gateway is deployed.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group to which the contiguous EIP group belongs.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// Indicates whether the firewall feature is enabled. Valid values:
	//
	// *   **false**: no
	// *   **true**: yes
	SecurityProtectionEnabled *bool `json:"SecurityProtectionEnabled,omitempty" xml:"SecurityProtectionEnabled,omitempty"`
	// The ID of the SNAT table of the NAT gateway.
	SnatTableIds *DescribeNatGatewaysResponseBodyNatGatewaysNatGatewaySnatTableIds `json:"SnatTableIds,omitempty" xml:"SnatTableIds,omitempty" type:"Struct"`
	// The size of the NAT gateway. An empty value is returned for the parameter.
	//
	// If **InternetChargeType** is set to **PayByLcu**, an empty value is returned.
	Spec *string `json:"Spec,omitempty" xml:"Spec,omitempty"`
	// The status of the NAT gateway. Valid values:
	//
	// *   **Creating**: After you send a request to create a NAT gateway, the system creates the NAT gateway in the background. The NAT gateway remains in the Creating state until the operation is completed.
	// *   **Available**: The NAT gateway remains in a stable state after the NAT gateway is created.
	// *   **Modifying**: After you send a request to modify a NAT gateway, the system modifies the NAT gateway in the background. The NAT gateway remains in the Modifying state until the operation is completed.
	// *   **Deleting**: After you send a request to delete a NAT gateway, the system deletes the NAT gateway in the background. The NAT gateway remains in the Deleting state until the operation is completed.
	// *   **Converting**: After you send a request to upgrade a standard NAT gateway to an enhanced NAT gateway, the system upgrades the NAT gateway in the background. The NAT gateway remains in the Converting state until the operation is completed.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The tags that are added to the resource group.
	Tags *DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Struct"`
	// The ID of the VPC where the NAT gateway is deployed.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s DescribeNatGatewaysResponseBodyNatGatewaysNatGateway) String() string {
	return tea.Prettify(s)
}

func (s DescribeNatGatewaysResponseBodyNatGatewaysNatGateway) GoString() string {
	return s.String()
}

func (s *DescribeNatGatewaysResponseBodyNatGatewaysNatGateway) SetAutoPay(v bool) *DescribeNatGatewaysResponseBodyNatGatewaysNatGateway {
	s.AutoPay = &v
	return s
}

func (s *DescribeNatGatewaysResponseBodyNatGatewaysNatGateway) SetBusinessStatus(v string) *DescribeNatGatewaysResponseBodyNatGatewaysNatGateway {
	s.BusinessStatus = &v
	return s
}

func (s *DescribeNatGatewaysResponseBodyNatGatewaysNatGateway) SetCreationTime(v string) *DescribeNatGatewaysResponseBodyNatGatewaysNatGateway {
	s.CreationTime = &v
	return s
}

func (s *DescribeNatGatewaysResponseBodyNatGatewaysNatGateway) SetDeletionProtection(v bool) *DescribeNatGatewaysResponseBodyNatGatewaysNatGateway {
	s.DeletionProtection = &v
	return s
}

func (s *DescribeNatGatewaysResponseBodyNatGatewaysNatGateway) SetDescription(v string) *DescribeNatGatewaysResponseBodyNatGatewaysNatGateway {
	s.Description = &v
	return s
}

func (s *DescribeNatGatewaysResponseBodyNatGatewaysNatGateway) SetEcsMetricEnabled(v bool) *DescribeNatGatewaysResponseBodyNatGatewaysNatGateway {
	s.EcsMetricEnabled = &v
	return s
}

func (s *DescribeNatGatewaysResponseBodyNatGatewaysNatGateway) SetEipBindMode(v string) *DescribeNatGatewaysResponseBodyNatGatewaysNatGateway {
	s.EipBindMode = &v
	return s
}

func (s *DescribeNatGatewaysResponseBodyNatGatewaysNatGateway) SetExpiredTime(v string) *DescribeNatGatewaysResponseBodyNatGatewaysNatGateway {
	s.ExpiredTime = &v
	return s
}

func (s *DescribeNatGatewaysResponseBodyNatGatewaysNatGateway) SetForwardTableIds(v *DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayForwardTableIds) *DescribeNatGatewaysResponseBodyNatGatewaysNatGateway {
	s.ForwardTableIds = v
	return s
}

func (s *DescribeNatGatewaysResponseBodyNatGatewaysNatGateway) SetFullNatTableIds(v *DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayFullNatTableIds) *DescribeNatGatewaysResponseBodyNatGatewaysNatGateway {
	s.FullNatTableIds = v
	return s
}

func (s *DescribeNatGatewaysResponseBodyNatGatewaysNatGateway) SetIcmpReplyEnabled(v bool) *DescribeNatGatewaysResponseBodyNatGatewaysNatGateway {
	s.IcmpReplyEnabled = &v
	return s
}

func (s *DescribeNatGatewaysResponseBodyNatGatewaysNatGateway) SetInstanceChargeType(v string) *DescribeNatGatewaysResponseBodyNatGatewaysNatGateway {
	s.InstanceChargeType = &v
	return s
}

func (s *DescribeNatGatewaysResponseBodyNatGatewaysNatGateway) SetInternetChargeType(v string) *DescribeNatGatewaysResponseBodyNatGatewaysNatGateway {
	s.InternetChargeType = &v
	return s
}

func (s *DescribeNatGatewaysResponseBodyNatGatewaysNatGateway) SetIpLists(v *DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayIpLists) *DescribeNatGatewaysResponseBodyNatGatewaysNatGateway {
	s.IpLists = v
	return s
}

func (s *DescribeNatGatewaysResponseBodyNatGatewaysNatGateway) SetName(v string) *DescribeNatGatewaysResponseBodyNatGatewaysNatGateway {
	s.Name = &v
	return s
}

func (s *DescribeNatGatewaysResponseBodyNatGatewaysNatGateway) SetNatGatewayId(v string) *DescribeNatGatewaysResponseBodyNatGatewaysNatGateway {
	s.NatGatewayId = &v
	return s
}

func (s *DescribeNatGatewaysResponseBodyNatGatewaysNatGateway) SetNatGatewayPrivateInfo(v *DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayNatGatewayPrivateInfo) *DescribeNatGatewaysResponseBodyNatGatewaysNatGateway {
	s.NatGatewayPrivateInfo = v
	return s
}

func (s *DescribeNatGatewaysResponseBodyNatGatewaysNatGateway) SetNatType(v string) *DescribeNatGatewaysResponseBodyNatGatewaysNatGateway {
	s.NatType = &v
	return s
}

func (s *DescribeNatGatewaysResponseBodyNatGatewaysNatGateway) SetNetworkType(v string) *DescribeNatGatewaysResponseBodyNatGatewaysNatGateway {
	s.NetworkType = &v
	return s
}

func (s *DescribeNatGatewaysResponseBodyNatGatewaysNatGateway) SetPrivateLinkEnabled(v bool) *DescribeNatGatewaysResponseBodyNatGatewaysNatGateway {
	s.PrivateLinkEnabled = &v
	return s
}

func (s *DescribeNatGatewaysResponseBodyNatGatewaysNatGateway) SetPrivateLinkMode(v string) *DescribeNatGatewaysResponseBodyNatGatewaysNatGateway {
	s.PrivateLinkMode = &v
	return s
}

func (s *DescribeNatGatewaysResponseBodyNatGatewaysNatGateway) SetRegionId(v string) *DescribeNatGatewaysResponseBodyNatGatewaysNatGateway {
	s.RegionId = &v
	return s
}

func (s *DescribeNatGatewaysResponseBodyNatGatewaysNatGateway) SetResourceGroupId(v string) *DescribeNatGatewaysResponseBodyNatGatewaysNatGateway {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeNatGatewaysResponseBodyNatGatewaysNatGateway) SetSecurityProtectionEnabled(v bool) *DescribeNatGatewaysResponseBodyNatGatewaysNatGateway {
	s.SecurityProtectionEnabled = &v
	return s
}

func (s *DescribeNatGatewaysResponseBodyNatGatewaysNatGateway) SetSnatTableIds(v *DescribeNatGatewaysResponseBodyNatGatewaysNatGatewaySnatTableIds) *DescribeNatGatewaysResponseBodyNatGatewaysNatGateway {
	s.SnatTableIds = v
	return s
}

func (s *DescribeNatGatewaysResponseBodyNatGatewaysNatGateway) SetSpec(v string) *DescribeNatGatewaysResponseBodyNatGatewaysNatGateway {
	s.Spec = &v
	return s
}

func (s *DescribeNatGatewaysResponseBodyNatGatewaysNatGateway) SetStatus(v string) *DescribeNatGatewaysResponseBodyNatGatewaysNatGateway {
	s.Status = &v
	return s
}

func (s *DescribeNatGatewaysResponseBodyNatGatewaysNatGateway) SetTags(v *DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayTags) *DescribeNatGatewaysResponseBodyNatGatewaysNatGateway {
	s.Tags = v
	return s
}

func (s *DescribeNatGatewaysResponseBodyNatGatewaysNatGateway) SetVpcId(v string) *DescribeNatGatewaysResponseBodyNatGatewaysNatGateway {
	s.VpcId = &v
	return s
}

type DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayForwardTableIds struct {
	ForwardTableId []*string `json:"ForwardTableId,omitempty" xml:"ForwardTableId,omitempty" type:"Repeated"`
}

func (s DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayForwardTableIds) String() string {
	return tea.Prettify(s)
}

func (s DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayForwardTableIds) GoString() string {
	return s.String()
}

func (s *DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayForwardTableIds) SetForwardTableId(v []*string) *DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayForwardTableIds {
	s.ForwardTableId = v
	return s
}

type DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayFullNatTableIds struct {
	FullNatTableId []*string `json:"FullNatTableId,omitempty" xml:"FullNatTableId,omitempty" type:"Repeated"`
}

func (s DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayFullNatTableIds) String() string {
	return tea.Prettify(s)
}

func (s DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayFullNatTableIds) GoString() string {
	return s.String()
}

func (s *DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayFullNatTableIds) SetFullNatTableId(v []*string) *DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayFullNatTableIds {
	s.FullNatTableId = v
	return s
}

type DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayIpLists struct {
	IpList []*DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayIpListsIpList `json:"IpList,omitempty" xml:"IpList,omitempty" type:"Repeated"`
}

func (s DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayIpLists) String() string {
	return tea.Prettify(s)
}

func (s DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayIpLists) GoString() string {
	return s.String()
}

func (s *DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayIpLists) SetIpList(v []*DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayIpListsIpList) *DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayIpLists {
	s.IpList = v
	return s
}

type DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayIpListsIpList struct {
	// The ID of the EIP associated with the NAT gateway.
	AllocationId *string `json:"AllocationId,omitempty" xml:"AllocationId,omitempty"`
	// The IP address of the EIP associated with the NAT gateway.
	IpAddress *string `json:"IpAddress,omitempty" xml:"IpAddress,omitempty"`
	// The private IP address of the NAT gateway.
	PrivateIpAddress *string `json:"PrivateIpAddress,omitempty" xml:"PrivateIpAddress,omitempty"`
	// Indicates whether IP addresses that are used in DNAT entries can be specified in SNAT entries. Valid values:
	//
	// *   **true**: yes
	// *   **false**: no
	SnatEntryEnabled *bool `json:"SnatEntryEnabled,omitempty" xml:"SnatEntryEnabled,omitempty"`
	// The association between the EIP and the Internet NAT gateway. Valid values:
	//
	// *   **UsedByForwardTable**: The EIP is specified in a DNAT entry.
	// *   **UsedBySnatTable**: The EIP is specified in an SNAT entry.
	// *   **UsedByForwardSnatTable**: The EIP is specified in both an SNAT entry and a DNAT entry.
	// *   **Idle**: The EIP is not specified in a DNAT or SNAT entry.
	UsingStatus *string `json:"UsingStatus,omitempty" xml:"UsingStatus,omitempty"`
}

func (s DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayIpListsIpList) String() string {
	return tea.Prettify(s)
}

func (s DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayIpListsIpList) GoString() string {
	return s.String()
}

func (s *DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayIpListsIpList) SetAllocationId(v string) *DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayIpListsIpList {
	s.AllocationId = &v
	return s
}

func (s *DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayIpListsIpList) SetIpAddress(v string) *DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayIpListsIpList {
	s.IpAddress = &v
	return s
}

func (s *DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayIpListsIpList) SetPrivateIpAddress(v string) *DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayIpListsIpList {
	s.PrivateIpAddress = &v
	return s
}

func (s *DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayIpListsIpList) SetSnatEntryEnabled(v bool) *DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayIpListsIpList {
	s.SnatEntryEnabled = &v
	return s
}

func (s *DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayIpListsIpList) SetUsingStatus(v string) *DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayIpListsIpList {
	s.UsingStatus = &v
	return s
}

type DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayNatGatewayPrivateInfo struct {
	// The ID of the elastic network interface (ENI).
	EniInstanceId *string `json:"EniInstanceId,omitempty" xml:"EniInstanceId,omitempty"`
	// The mode in which the ENI is associated with the NAT gateway.
	//
	// *   **indirect**: non-cut-through mode
	// *   If an empty value is returned, it indicates that the cut-through mode is used.
	EniType *string `json:"EniType,omitempty" xml:"EniType,omitempty"`
	// The zone to which the NAT gateway belongs.
	IzNo *string `json:"IzNo,omitempty" xml:"IzNo,omitempty"`
	// The maximum bandwidth. Unit: Mbit/s.
	MaxBandwidth *int32 `json:"MaxBandwidth,omitempty" xml:"MaxBandwidth,omitempty"`
	// The number of new connections to the NAT gateway. Unit: connections per second.
	MaxSessionEstablishRate *int32 `json:"MaxSessionEstablishRate,omitempty" xml:"MaxSessionEstablishRate,omitempty"`
	// The number of concurrent connections to the NAT gateway. Unit: connections.
	MaxSessionQuota *int32 `json:"MaxSessionQuota,omitempty" xml:"MaxSessionQuota,omitempty"`
	// The private IP address.
	PrivateIpAddress *string `json:"PrivateIpAddress,omitempty" xml:"PrivateIpAddress,omitempty"`
	// The ID of the vSwitch to which the NAT gateway belongs.
	VswitchId *string `json:"VswitchId,omitempty" xml:"VswitchId,omitempty"`
}

func (s DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayNatGatewayPrivateInfo) String() string {
	return tea.Prettify(s)
}

func (s DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayNatGatewayPrivateInfo) GoString() string {
	return s.String()
}

func (s *DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayNatGatewayPrivateInfo) SetEniInstanceId(v string) *DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayNatGatewayPrivateInfo {
	s.EniInstanceId = &v
	return s
}

func (s *DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayNatGatewayPrivateInfo) SetEniType(v string) *DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayNatGatewayPrivateInfo {
	s.EniType = &v
	return s
}

func (s *DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayNatGatewayPrivateInfo) SetIzNo(v string) *DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayNatGatewayPrivateInfo {
	s.IzNo = &v
	return s
}

func (s *DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayNatGatewayPrivateInfo) SetMaxBandwidth(v int32) *DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayNatGatewayPrivateInfo {
	s.MaxBandwidth = &v
	return s
}

func (s *DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayNatGatewayPrivateInfo) SetMaxSessionEstablishRate(v int32) *DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayNatGatewayPrivateInfo {
	s.MaxSessionEstablishRate = &v
	return s
}

func (s *DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayNatGatewayPrivateInfo) SetMaxSessionQuota(v int32) *DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayNatGatewayPrivateInfo {
	s.MaxSessionQuota = &v
	return s
}

func (s *DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayNatGatewayPrivateInfo) SetPrivateIpAddress(v string) *DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayNatGatewayPrivateInfo {
	s.PrivateIpAddress = &v
	return s
}

func (s *DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayNatGatewayPrivateInfo) SetVswitchId(v string) *DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayNatGatewayPrivateInfo {
	s.VswitchId = &v
	return s
}

type DescribeNatGatewaysResponseBodyNatGatewaysNatGatewaySnatTableIds struct {
	SnatTableId []*string `json:"SnatTableId,omitempty" xml:"SnatTableId,omitempty" type:"Repeated"`
}

func (s DescribeNatGatewaysResponseBodyNatGatewaysNatGatewaySnatTableIds) String() string {
	return tea.Prettify(s)
}

func (s DescribeNatGatewaysResponseBodyNatGatewaysNatGatewaySnatTableIds) GoString() string {
	return s.String()
}

func (s *DescribeNatGatewaysResponseBodyNatGatewaysNatGatewaySnatTableIds) SetSnatTableId(v []*string) *DescribeNatGatewaysResponseBodyNatGatewaysNatGatewaySnatTableIds {
	s.SnatTableId = v
	return s
}

type DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayTags struct {
	Tag []*DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayTagsTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayTags) String() string {
	return tea.Prettify(s)
}

func (s DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayTags) GoString() string {
	return s.String()
}

func (s *DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayTags) SetTag(v []*DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayTagsTag) *DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayTags {
	s.Tag = v
	return s
}

type DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayTagsTag struct {
	// The tag key of the instance.
	TagKey *string `json:"TagKey,omitempty" xml:"TagKey,omitempty"`
	// The tag value of the instance.
	TagValue *string `json:"TagValue,omitempty" xml:"TagValue,omitempty"`
}

func (s DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayTagsTag) String() string {
	return tea.Prettify(s)
}

func (s DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayTagsTag) GoString() string {
	return s.String()
}

func (s *DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayTagsTag) SetTagKey(v string) *DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayTagsTag {
	s.TagKey = &v
	return s
}

func (s *DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayTagsTag) SetTagValue(v string) *DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayTagsTag {
	s.TagValue = &v
	return s
}

type DescribeNatGatewaysResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeNatGatewaysResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeNatGatewaysResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeNatGatewaysResponse) GoString() string {
	return s.String()
}

func (s *DescribeNatGatewaysResponse) SetHeaders(v map[string]*string) *DescribeNatGatewaysResponse {
	s.Headers = v
	return s
}

func (s *DescribeNatGatewaysResponse) SetStatusCode(v int32) *DescribeNatGatewaysResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeNatGatewaysResponse) SetBody(v *DescribeNatGatewaysResponseBody) *DescribeNatGatewaysResponse {
	s.Body = v
	return s
}

type DescribeNetworkAclAttributesRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. ClientToken can contain only ASCII characters.
	//
	// >  If you do not set this parameter, the system sets **ClientToken** to the value of **RequestId**. The value of **RequestId** for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the network ACL.
	NetworkAclId *string `json:"NetworkAclId,omitempty" xml:"NetworkAclId,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the network ACL.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeNetworkAclAttributesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeNetworkAclAttributesRequest) GoString() string {
	return s.String()
}

func (s *DescribeNetworkAclAttributesRequest) SetClientToken(v string) *DescribeNetworkAclAttributesRequest {
	s.ClientToken = &v
	return s
}

func (s *DescribeNetworkAclAttributesRequest) SetNetworkAclId(v string) *DescribeNetworkAclAttributesRequest {
	s.NetworkAclId = &v
	return s
}

func (s *DescribeNetworkAclAttributesRequest) SetOwnerId(v int64) *DescribeNetworkAclAttributesRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeNetworkAclAttributesRequest) SetRegionId(v string) *DescribeNetworkAclAttributesRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeNetworkAclAttributesRequest) SetResourceOwnerAccount(v string) *DescribeNetworkAclAttributesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeNetworkAclAttributesRequest) SetResourceOwnerId(v int64) *DescribeNetworkAclAttributesRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeNetworkAclAttributesResponseBody struct {
	// The details about the network ACL.
	NetworkAclAttribute *DescribeNetworkAclAttributesResponseBodyNetworkAclAttribute `json:"NetworkAclAttribute,omitempty" xml:"NetworkAclAttribute,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeNetworkAclAttributesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeNetworkAclAttributesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeNetworkAclAttributesResponseBody) SetNetworkAclAttribute(v *DescribeNetworkAclAttributesResponseBodyNetworkAclAttribute) *DescribeNetworkAclAttributesResponseBody {
	s.NetworkAclAttribute = v
	return s
}

func (s *DescribeNetworkAclAttributesResponseBody) SetRequestId(v string) *DescribeNetworkAclAttributesResponseBody {
	s.RequestId = &v
	return s
}

type DescribeNetworkAclAttributesResponseBodyNetworkAclAttribute struct {
	// The time when the network ACL was created.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The description of the network ACL.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The information about the outbound rules of the network ACL.
	EgressAclEntries *DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeEgressAclEntries `json:"EgressAclEntries,omitempty" xml:"EgressAclEntries,omitempty" type:"Struct"`
	// The information about the inbound rules of the network ACL.
	IngressAclEntries *DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeIngressAclEntries `json:"IngressAclEntries,omitempty" xml:"IngressAclEntries,omitempty" type:"Struct"`
	// The ID of the network ACL.
	NetworkAclId *string `json:"NetworkAclId,omitempty" xml:"NetworkAclId,omitempty"`
	// The name of the network ACL.
	NetworkAclName *string `json:"NetworkAclName,omitempty" xml:"NetworkAclName,omitempty"`
	// The ID of the Alibaba Cloud account to which the network ACL belongs.
	OwnerId *int64 `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the network ACL.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The details about the resource that is associated with the network ACL.
	Resources *DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeResources `json:"Resources,omitempty" xml:"Resources,omitempty" type:"Struct"`
	// The status of the associated resource. Valid values:
	//
	// *   **Available**
	// *   **Modifying**
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The tag list.
	Tags *DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Struct"`
	// The ID of the virtual private cloud (VPC) with which the network ACL is associated.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s DescribeNetworkAclAttributesResponseBodyNetworkAclAttribute) String() string {
	return tea.Prettify(s)
}

func (s DescribeNetworkAclAttributesResponseBodyNetworkAclAttribute) GoString() string {
	return s.String()
}

func (s *DescribeNetworkAclAttributesResponseBodyNetworkAclAttribute) SetCreationTime(v string) *DescribeNetworkAclAttributesResponseBodyNetworkAclAttribute {
	s.CreationTime = &v
	return s
}

func (s *DescribeNetworkAclAttributesResponseBodyNetworkAclAttribute) SetDescription(v string) *DescribeNetworkAclAttributesResponseBodyNetworkAclAttribute {
	s.Description = &v
	return s
}

func (s *DescribeNetworkAclAttributesResponseBodyNetworkAclAttribute) SetEgressAclEntries(v *DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeEgressAclEntries) *DescribeNetworkAclAttributesResponseBodyNetworkAclAttribute {
	s.EgressAclEntries = v
	return s
}

func (s *DescribeNetworkAclAttributesResponseBodyNetworkAclAttribute) SetIngressAclEntries(v *DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeIngressAclEntries) *DescribeNetworkAclAttributesResponseBodyNetworkAclAttribute {
	s.IngressAclEntries = v
	return s
}

func (s *DescribeNetworkAclAttributesResponseBodyNetworkAclAttribute) SetNetworkAclId(v string) *DescribeNetworkAclAttributesResponseBodyNetworkAclAttribute {
	s.NetworkAclId = &v
	return s
}

func (s *DescribeNetworkAclAttributesResponseBodyNetworkAclAttribute) SetNetworkAclName(v string) *DescribeNetworkAclAttributesResponseBodyNetworkAclAttribute {
	s.NetworkAclName = &v
	return s
}

func (s *DescribeNetworkAclAttributesResponseBodyNetworkAclAttribute) SetOwnerId(v int64) *DescribeNetworkAclAttributesResponseBodyNetworkAclAttribute {
	s.OwnerId = &v
	return s
}

func (s *DescribeNetworkAclAttributesResponseBodyNetworkAclAttribute) SetRegionId(v string) *DescribeNetworkAclAttributesResponseBodyNetworkAclAttribute {
	s.RegionId = &v
	return s
}

func (s *DescribeNetworkAclAttributesResponseBodyNetworkAclAttribute) SetResources(v *DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeResources) *DescribeNetworkAclAttributesResponseBodyNetworkAclAttribute {
	s.Resources = v
	return s
}

func (s *DescribeNetworkAclAttributesResponseBodyNetworkAclAttribute) SetStatus(v string) *DescribeNetworkAclAttributesResponseBodyNetworkAclAttribute {
	s.Status = &v
	return s
}

func (s *DescribeNetworkAclAttributesResponseBodyNetworkAclAttribute) SetTags(v *DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeTags) *DescribeNetworkAclAttributesResponseBodyNetworkAclAttribute {
	s.Tags = v
	return s
}

func (s *DescribeNetworkAclAttributesResponseBodyNetworkAclAttribute) SetVpcId(v string) *DescribeNetworkAclAttributesResponseBodyNetworkAclAttribute {
	s.VpcId = &v
	return s
}

type DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeEgressAclEntries struct {
	EgressAclEntry []*DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeEgressAclEntriesEgressAclEntry `json:"EgressAclEntry,omitempty" xml:"EgressAclEntry,omitempty" type:"Repeated"`
}

func (s DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeEgressAclEntries) String() string {
	return tea.Prettify(s)
}

func (s DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeEgressAclEntries) GoString() string {
	return s.String()
}

func (s *DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeEgressAclEntries) SetEgressAclEntry(v []*DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeEgressAclEntriesEgressAclEntry) *DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeEgressAclEntries {
	s.EgressAclEntry = v
	return s
}

type DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeEgressAclEntriesEgressAclEntry struct {
	// The description of the outbound rule.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The destination CIDR block.
	DestinationCidrIp *string `json:"DestinationCidrIp,omitempty" xml:"DestinationCidrIp,omitempty"`
	// The ID of the outbound rule.
	NetworkAclEntryId *string `json:"NetworkAclEntryId,omitempty" xml:"NetworkAclEntryId,omitempty"`
	// The name of the outbound rule.
	NetworkAclEntryName *string `json:"NetworkAclEntryName,omitempty" xml:"NetworkAclEntryName,omitempty"`
	// The action to be performed on network traffic that matches the rule. Valid values:
	//
	// - **accept**: allows network traffic.
	// - **drop**: blocks network traffic.
	Policy *string `json:"Policy,omitempty" xml:"Policy,omitempty"`
	// The destination port range of the outbound traffic.
	//
	// - If **Protocol** of the outbound rule is set to **all**, **icmp**, or **gre**, the port range is **-1/-1**, which indicates all ports.
	// - If **Protocol** of the outbound rule is set to **tcp** or **udp**, the port range is in the following format: **1/200** or **80/80**, which indicates port 1 to port 200, or port 80. Valid values for a port: **1** to **65535**.
	Port *string `json:"Port,omitempty" xml:"Port,omitempty"`
	// The protocol. Valid values:
	//
	// - **icmp**: ICMP
	// - **gre**: GRE
	// - **tcp**: TCP
	// - **udp**: UDP
	// - **all**: all protocols
	Protocol *string `json:"Protocol,omitempty" xml:"Protocol,omitempty"`
}

func (s DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeEgressAclEntriesEgressAclEntry) String() string {
	return tea.Prettify(s)
}

func (s DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeEgressAclEntriesEgressAclEntry) GoString() string {
	return s.String()
}

func (s *DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeEgressAclEntriesEgressAclEntry) SetDescription(v string) *DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeEgressAclEntriesEgressAclEntry {
	s.Description = &v
	return s
}

func (s *DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeEgressAclEntriesEgressAclEntry) SetDestinationCidrIp(v string) *DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeEgressAclEntriesEgressAclEntry {
	s.DestinationCidrIp = &v
	return s
}

func (s *DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeEgressAclEntriesEgressAclEntry) SetNetworkAclEntryId(v string) *DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeEgressAclEntriesEgressAclEntry {
	s.NetworkAclEntryId = &v
	return s
}

func (s *DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeEgressAclEntriesEgressAclEntry) SetNetworkAclEntryName(v string) *DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeEgressAclEntriesEgressAclEntry {
	s.NetworkAclEntryName = &v
	return s
}

func (s *DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeEgressAclEntriesEgressAclEntry) SetPolicy(v string) *DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeEgressAclEntriesEgressAclEntry {
	s.Policy = &v
	return s
}

func (s *DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeEgressAclEntriesEgressAclEntry) SetPort(v string) *DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeEgressAclEntriesEgressAclEntry {
	s.Port = &v
	return s
}

func (s *DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeEgressAclEntriesEgressAclEntry) SetProtocol(v string) *DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeEgressAclEntriesEgressAclEntry {
	s.Protocol = &v
	return s
}

type DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeIngressAclEntries struct {
	IngressAclEntry []*DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeIngressAclEntriesIngressAclEntry `json:"IngressAclEntry,omitempty" xml:"IngressAclEntry,omitempty" type:"Repeated"`
}

func (s DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeIngressAclEntries) String() string {
	return tea.Prettify(s)
}

func (s DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeIngressAclEntries) GoString() string {
	return s.String()
}

func (s *DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeIngressAclEntries) SetIngressAclEntry(v []*DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeIngressAclEntriesIngressAclEntry) *DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeIngressAclEntries {
	s.IngressAclEntry = v
	return s
}

type DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeIngressAclEntriesIngressAclEntry struct {
	// The description of the inbound rule.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the inbound rule.
	NetworkAclEntryId *string `json:"NetworkAclEntryId,omitempty" xml:"NetworkAclEntryId,omitempty"`
	// The name of the inbound rule.
	NetworkAclEntryName *string `json:"NetworkAclEntryName,omitempty" xml:"NetworkAclEntryName,omitempty"`
	// The action to be performed on network traffic that matches the rule. Valid values:
	//
	// *   **accept**: allows network traffic.
	// *   **drop**: blocks network traffic.
	Policy *string `json:"Policy,omitempty" xml:"Policy,omitempty"`
	// The destination port range of the inbound traffic.
	//
	// *   If **Protocol** of the inbound rule is set to **all**, **icmp**, or **gre**, the port range is **-1/-1**, which indicates all ports.
	// *   If **Protocol** of the inbound rule is set to **tcp** or **udp**, the port range is in the following format: **1/200** or **80/80**, which indicates port 1 to port 200, or port 80. Valid values for a port: **1** to **65535**.
	Port *string `json:"Port,omitempty" xml:"Port,omitempty"`
	// The protocol. Valid values:
	//
	// *   **icmp**: ICMP
	// *   **gre**: GRE
	// *   **tcp**: TCP
	// *   **udp**: UDP
	// *   **all**: all protocols
	Protocol *string `json:"Protocol,omitempty" xml:"Protocol,omitempty"`
	// The source CIDR block.
	SourceCidrIp *string `json:"SourceCidrIp,omitempty" xml:"SourceCidrIp,omitempty"`
}

func (s DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeIngressAclEntriesIngressAclEntry) String() string {
	return tea.Prettify(s)
}

func (s DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeIngressAclEntriesIngressAclEntry) GoString() string {
	return s.String()
}

func (s *DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeIngressAclEntriesIngressAclEntry) SetDescription(v string) *DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeIngressAclEntriesIngressAclEntry {
	s.Description = &v
	return s
}

func (s *DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeIngressAclEntriesIngressAclEntry) SetNetworkAclEntryId(v string) *DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeIngressAclEntriesIngressAclEntry {
	s.NetworkAclEntryId = &v
	return s
}

func (s *DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeIngressAclEntriesIngressAclEntry) SetNetworkAclEntryName(v string) *DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeIngressAclEntriesIngressAclEntry {
	s.NetworkAclEntryName = &v
	return s
}

func (s *DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeIngressAclEntriesIngressAclEntry) SetPolicy(v string) *DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeIngressAclEntriesIngressAclEntry {
	s.Policy = &v
	return s
}

func (s *DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeIngressAclEntriesIngressAclEntry) SetPort(v string) *DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeIngressAclEntriesIngressAclEntry {
	s.Port = &v
	return s
}

func (s *DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeIngressAclEntriesIngressAclEntry) SetProtocol(v string) *DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeIngressAclEntriesIngressAclEntry {
	s.Protocol = &v
	return s
}

func (s *DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeIngressAclEntriesIngressAclEntry) SetSourceCidrIp(v string) *DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeIngressAclEntriesIngressAclEntry {
	s.SourceCidrIp = &v
	return s
}

type DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeResources struct {
	Resource []*DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeResourcesResource `json:"Resource,omitempty" xml:"Resource,omitempty" type:"Repeated"`
}

func (s DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeResources) String() string {
	return tea.Prettify(s)
}

func (s DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeResources) GoString() string {
	return s.String()
}

func (s *DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeResources) SetResource(v []*DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeResourcesResource) *DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeResources {
	s.Resource = v
	return s
}

type DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeResourcesResource struct {
	// The ID of the associated resource.
	ResourceId *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	// The type of resource with which you want to associate the network ACL. The value is set to **VSwitch**.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The status of the associated resource. Valid values:
	//
	// - **BINDED**: The resource is associated with the network ACL.
	// - **BINDING**: The resource is being associated with the network ACL.
	// - **UNBINDING**: The resource is disassociated from the network ACL.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeResourcesResource) String() string {
	return tea.Prettify(s)
}

func (s DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeResourcesResource) GoString() string {
	return s.String()
}

func (s *DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeResourcesResource) SetResourceId(v string) *DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeResourcesResource {
	s.ResourceId = &v
	return s
}

func (s *DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeResourcesResource) SetResourceType(v string) *DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeResourcesResource {
	s.ResourceType = &v
	return s
}

func (s *DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeResourcesResource) SetStatus(v string) *DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeResourcesResource {
	s.Status = &v
	return s
}

type DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeTags struct {
	Tag []*DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeTagsTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeTags) String() string {
	return tea.Prettify(s)
}

func (s DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeTags) GoString() string {
	return s.String()
}

func (s *DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeTags) SetTag(v []*DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeTagsTag) *DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeTags {
	s.Tag = v
	return s
}

type DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeTagsTag struct {
	// The tag key.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeTagsTag) String() string {
	return tea.Prettify(s)
}

func (s DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeTagsTag) GoString() string {
	return s.String()
}

func (s *DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeTagsTag) SetKey(v string) *DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeTagsTag {
	s.Key = &v
	return s
}

func (s *DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeTagsTag) SetValue(v string) *DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeTagsTag {
	s.Value = &v
	return s
}

type DescribeNetworkAclAttributesResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeNetworkAclAttributesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeNetworkAclAttributesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeNetworkAclAttributesResponse) GoString() string {
	return s.String()
}

func (s *DescribeNetworkAclAttributesResponse) SetHeaders(v map[string]*string) *DescribeNetworkAclAttributesResponse {
	s.Headers = v
	return s
}

func (s *DescribeNetworkAclAttributesResponse) SetStatusCode(v int32) *DescribeNetworkAclAttributesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeNetworkAclAttributesResponse) SetBody(v *DescribeNetworkAclAttributesResponseBody) *DescribeNetworkAclAttributesResponse {
	s.Body = v
	return s
}

type DescribeNetworkAclsRequest struct {
	// The client token that you want to use to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that the value is unique among different requests. ClientToken can contain only ASCII characters.
	//
	// >  If you do not set this parameter, the system sets **ClientToken** to the value of **RequestId**. The value of **RequestId** for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the network ACL.
	NetworkAclId *string `json:"NetworkAclId,omitempty" xml:"NetworkAclId,omitempty"`
	// The name of the network ACL.
	//
	// The name must be 1 to 128 characters in length, and cannot start with `http://` or `https://`.
	NetworkAclName *string `json:"NetworkAclName,omitempty" xml:"NetworkAclName,omitempty"`
	OwnerId        *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of the page to return. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Maximum value: **50**. Default value: **10**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The region ID of the network ACL.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the associated instance.
	ResourceId           *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The type of the associated instance. Set the value to **VSwitch**.
	//
	// This parameter is valid only if **ResourceType** and **ResourceId** are both set.
	ResourceType *string                           `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	Tags         []*DescribeNetworkAclsRequestTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
	// The ID of the virtual private cloud (VPC) to which the network ACL belongs.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s DescribeNetworkAclsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeNetworkAclsRequest) GoString() string {
	return s.String()
}

func (s *DescribeNetworkAclsRequest) SetClientToken(v string) *DescribeNetworkAclsRequest {
	s.ClientToken = &v
	return s
}

func (s *DescribeNetworkAclsRequest) SetNetworkAclId(v string) *DescribeNetworkAclsRequest {
	s.NetworkAclId = &v
	return s
}

func (s *DescribeNetworkAclsRequest) SetNetworkAclName(v string) *DescribeNetworkAclsRequest {
	s.NetworkAclName = &v
	return s
}

func (s *DescribeNetworkAclsRequest) SetOwnerId(v int64) *DescribeNetworkAclsRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeNetworkAclsRequest) SetPageNumber(v int32) *DescribeNetworkAclsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeNetworkAclsRequest) SetPageSize(v int32) *DescribeNetworkAclsRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeNetworkAclsRequest) SetRegionId(v string) *DescribeNetworkAclsRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeNetworkAclsRequest) SetResourceId(v string) *DescribeNetworkAclsRequest {
	s.ResourceId = &v
	return s
}

func (s *DescribeNetworkAclsRequest) SetResourceOwnerAccount(v string) *DescribeNetworkAclsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeNetworkAclsRequest) SetResourceOwnerId(v int64) *DescribeNetworkAclsRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeNetworkAclsRequest) SetResourceType(v string) *DescribeNetworkAclsRequest {
	s.ResourceType = &v
	return s
}

func (s *DescribeNetworkAclsRequest) SetTags(v []*DescribeNetworkAclsRequestTags) *DescribeNetworkAclsRequest {
	s.Tags = v
	return s
}

func (s *DescribeNetworkAclsRequest) SetVpcId(v string) *DescribeNetworkAclsRequest {
	s.VpcId = &v
	return s
}

type DescribeNetworkAclsRequestTags struct {
	// The tag key. You can specify at most 20 tag keys. It cannot be an empty string.
	//
	// The key cannot exceed 64 characters in length, and can contain digits, periods (.), underscores (\_), and hyphens (-). The key must start with a letter but cannot start with `aliyun` or `acs:`. The key cannot contain `http://` or `https://`.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value. You can specify at most 20 tag values. It can be an empty string.
	//
	// The tag value cannot exceed 128 characters in length, and can contain digits, periods (.), underscores (\_), and hyphens (-). It must start with a letter but cannot start with `aliyun` or `acs:`. It cannot contain `http://` or `https://`.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeNetworkAclsRequestTags) String() string {
	return tea.Prettify(s)
}

func (s DescribeNetworkAclsRequestTags) GoString() string {
	return s.String()
}

func (s *DescribeNetworkAclsRequestTags) SetKey(v string) *DescribeNetworkAclsRequestTags {
	s.Key = &v
	return s
}

func (s *DescribeNetworkAclsRequestTags) SetValue(v string) *DescribeNetworkAclsRequestTags {
	s.Value = &v
	return s
}

type DescribeNetworkAclsResponseBody struct {
	// The details about the network ACL.
	NetworkAcls *DescribeNetworkAclsResponseBodyNetworkAcls `json:"NetworkAcls,omitempty" xml:"NetworkAcls,omitempty" type:"Struct"`
	// The page number of the returned page.
	PageNumber *string `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned on each page.
	PageSize *string `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalCount *string `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeNetworkAclsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeNetworkAclsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeNetworkAclsResponseBody) SetNetworkAcls(v *DescribeNetworkAclsResponseBodyNetworkAcls) *DescribeNetworkAclsResponseBody {
	s.NetworkAcls = v
	return s
}

func (s *DescribeNetworkAclsResponseBody) SetPageNumber(v string) *DescribeNetworkAclsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeNetworkAclsResponseBody) SetPageSize(v string) *DescribeNetworkAclsResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeNetworkAclsResponseBody) SetRequestId(v string) *DescribeNetworkAclsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeNetworkAclsResponseBody) SetTotalCount(v string) *DescribeNetworkAclsResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeNetworkAclsResponseBodyNetworkAcls struct {
	NetworkAcl []*DescribeNetworkAclsResponseBodyNetworkAclsNetworkAcl `json:"NetworkAcl,omitempty" xml:"NetworkAcl,omitempty" type:"Repeated"`
}

func (s DescribeNetworkAclsResponseBodyNetworkAcls) String() string {
	return tea.Prettify(s)
}

func (s DescribeNetworkAclsResponseBodyNetworkAcls) GoString() string {
	return s.String()
}

func (s *DescribeNetworkAclsResponseBodyNetworkAcls) SetNetworkAcl(v []*DescribeNetworkAclsResponseBodyNetworkAclsNetworkAcl) *DescribeNetworkAclsResponseBodyNetworkAcls {
	s.NetworkAcl = v
	return s
}

type DescribeNetworkAclsResponseBodyNetworkAclsNetworkAcl struct {
	// The time when the network ACL was created.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The description of the network ACL.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The outbound rules.
	EgressAclEntries *DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclEgressAclEntries `json:"EgressAclEntries,omitempty" xml:"EgressAclEntries,omitempty" type:"Struct"`
	// The inbound rules.
	IngressAclEntries *DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclIngressAclEntries `json:"IngressAclEntries,omitempty" xml:"IngressAclEntries,omitempty" type:"Struct"`
	// The ID of the network ACL.
	NetworkAclId *string `json:"NetworkAclId,omitempty" xml:"NetworkAclId,omitempty"`
	// The name of the network ACL.
	NetworkAclName *string `json:"NetworkAclName,omitempty" xml:"NetworkAclName,omitempty"`
	// The ID of the Alibaba Cloud account to which the network ACL belongs.
	OwnerId *int64 `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the network ACL.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The resources that are associated with the network ACL.
	Resources *DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclResources `json:"Resources,omitempty" xml:"Resources,omitempty" type:"Struct"`
	// The status of the network ACL. Valid values:
	//
	// *   **Available**
	// *   **Modifying**
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The tag list.
	Tags *DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Struct"`
	// The ID of the associated VPC.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s DescribeNetworkAclsResponseBodyNetworkAclsNetworkAcl) String() string {
	return tea.Prettify(s)
}

func (s DescribeNetworkAclsResponseBodyNetworkAclsNetworkAcl) GoString() string {
	return s.String()
}

func (s *DescribeNetworkAclsResponseBodyNetworkAclsNetworkAcl) SetCreationTime(v string) *DescribeNetworkAclsResponseBodyNetworkAclsNetworkAcl {
	s.CreationTime = &v
	return s
}

func (s *DescribeNetworkAclsResponseBodyNetworkAclsNetworkAcl) SetDescription(v string) *DescribeNetworkAclsResponseBodyNetworkAclsNetworkAcl {
	s.Description = &v
	return s
}

func (s *DescribeNetworkAclsResponseBodyNetworkAclsNetworkAcl) SetEgressAclEntries(v *DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclEgressAclEntries) *DescribeNetworkAclsResponseBodyNetworkAclsNetworkAcl {
	s.EgressAclEntries = v
	return s
}

func (s *DescribeNetworkAclsResponseBodyNetworkAclsNetworkAcl) SetIngressAclEntries(v *DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclIngressAclEntries) *DescribeNetworkAclsResponseBodyNetworkAclsNetworkAcl {
	s.IngressAclEntries = v
	return s
}

func (s *DescribeNetworkAclsResponseBodyNetworkAclsNetworkAcl) SetNetworkAclId(v string) *DescribeNetworkAclsResponseBodyNetworkAclsNetworkAcl {
	s.NetworkAclId = &v
	return s
}

func (s *DescribeNetworkAclsResponseBodyNetworkAclsNetworkAcl) SetNetworkAclName(v string) *DescribeNetworkAclsResponseBodyNetworkAclsNetworkAcl {
	s.NetworkAclName = &v
	return s
}

func (s *DescribeNetworkAclsResponseBodyNetworkAclsNetworkAcl) SetOwnerId(v int64) *DescribeNetworkAclsResponseBodyNetworkAclsNetworkAcl {
	s.OwnerId = &v
	return s
}

func (s *DescribeNetworkAclsResponseBodyNetworkAclsNetworkAcl) SetRegionId(v string) *DescribeNetworkAclsResponseBodyNetworkAclsNetworkAcl {
	s.RegionId = &v
	return s
}

func (s *DescribeNetworkAclsResponseBodyNetworkAclsNetworkAcl) SetResources(v *DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclResources) *DescribeNetworkAclsResponseBodyNetworkAclsNetworkAcl {
	s.Resources = v
	return s
}

func (s *DescribeNetworkAclsResponseBodyNetworkAclsNetworkAcl) SetStatus(v string) *DescribeNetworkAclsResponseBodyNetworkAclsNetworkAcl {
	s.Status = &v
	return s
}

func (s *DescribeNetworkAclsResponseBodyNetworkAclsNetworkAcl) SetTags(v *DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclTags) *DescribeNetworkAclsResponseBodyNetworkAclsNetworkAcl {
	s.Tags = v
	return s
}

func (s *DescribeNetworkAclsResponseBodyNetworkAclsNetworkAcl) SetVpcId(v string) *DescribeNetworkAclsResponseBodyNetworkAclsNetworkAcl {
	s.VpcId = &v
	return s
}

type DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclEgressAclEntries struct {
	EgressAclEntry []*DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclEgressAclEntriesEgressAclEntry `json:"EgressAclEntry,omitempty" xml:"EgressAclEntry,omitempty" type:"Repeated"`
}

func (s DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclEgressAclEntries) String() string {
	return tea.Prettify(s)
}

func (s DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclEgressAclEntries) GoString() string {
	return s.String()
}

func (s *DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclEgressAclEntries) SetEgressAclEntry(v []*DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclEgressAclEntriesEgressAclEntry) *DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclEgressAclEntries {
	s.EgressAclEntry = v
	return s
}

type DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclEgressAclEntriesEgressAclEntry struct {
	// The description of the outbound rule.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The destination CIDR block.
	DestinationCidrIp *string `json:"DestinationCidrIp,omitempty" xml:"DestinationCidrIp,omitempty"`
	// The ID of the outbound rule.
	NetworkAclEntryId *string `json:"NetworkAclEntryId,omitempty" xml:"NetworkAclEntryId,omitempty"`
	// The name of the outbound rule.
	NetworkAclEntryName *string `json:"NetworkAclEntryName,omitempty" xml:"NetworkAclEntryName,omitempty"`
	// The action to be performed on network traffic that matches the rule. Valid values:
	//
	// - **accept**: allows network traffic.
	// - **drop**: blocks network traffic.
	Policy *string `json:"Policy,omitempty" xml:"Policy,omitempty"`
	// The destination port range of the outbound traffic.
	//
	// - If **Protocol** of the outbound rule is set to **all**, **icmp**, or **gre**, the port range is **-1/-1**, which specifies all ports.
	// - If **Protocol** of the outbound rule is set to **tcp** or **udp**, the port range is in the following format: **1/200** or **80/80**. 1/200 indicates port 1 to port 200. 80/80 indicates port 80. Valid values for a port: **1** to **65535**.
	Port *string `json:"Port,omitempty" xml:"Port,omitempty"`
	// The protocol. Valid values:
	//
	// - **icmp**: ICMP
	// - **gre**: GRE
	// - **tcp**: TCP
	// - **udp**: UDP
	// - **all**: all protocols
	Protocol *string `json:"Protocol,omitempty" xml:"Protocol,omitempty"`
}

func (s DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclEgressAclEntriesEgressAclEntry) String() string {
	return tea.Prettify(s)
}

func (s DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclEgressAclEntriesEgressAclEntry) GoString() string {
	return s.String()
}

func (s *DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclEgressAclEntriesEgressAclEntry) SetDescription(v string) *DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclEgressAclEntriesEgressAclEntry {
	s.Description = &v
	return s
}

func (s *DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclEgressAclEntriesEgressAclEntry) SetDestinationCidrIp(v string) *DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclEgressAclEntriesEgressAclEntry {
	s.DestinationCidrIp = &v
	return s
}

func (s *DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclEgressAclEntriesEgressAclEntry) SetNetworkAclEntryId(v string) *DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclEgressAclEntriesEgressAclEntry {
	s.NetworkAclEntryId = &v
	return s
}

func (s *DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclEgressAclEntriesEgressAclEntry) SetNetworkAclEntryName(v string) *DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclEgressAclEntriesEgressAclEntry {
	s.NetworkAclEntryName = &v
	return s
}

func (s *DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclEgressAclEntriesEgressAclEntry) SetPolicy(v string) *DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclEgressAclEntriesEgressAclEntry {
	s.Policy = &v
	return s
}

func (s *DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclEgressAclEntriesEgressAclEntry) SetPort(v string) *DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclEgressAclEntriesEgressAclEntry {
	s.Port = &v
	return s
}

func (s *DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclEgressAclEntriesEgressAclEntry) SetProtocol(v string) *DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclEgressAclEntriesEgressAclEntry {
	s.Protocol = &v
	return s
}

type DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclIngressAclEntries struct {
	IngressAclEntry []*DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclIngressAclEntriesIngressAclEntry `json:"IngressAclEntry,omitempty" xml:"IngressAclEntry,omitempty" type:"Repeated"`
}

func (s DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclIngressAclEntries) String() string {
	return tea.Prettify(s)
}

func (s DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclIngressAclEntries) GoString() string {
	return s.String()
}

func (s *DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclIngressAclEntries) SetIngressAclEntry(v []*DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclIngressAclEntriesIngressAclEntry) *DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclIngressAclEntries {
	s.IngressAclEntry = v
	return s
}

type DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclIngressAclEntriesIngressAclEntry struct {
	// The description of the inbound rule.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the inbound rule.
	NetworkAclEntryId *string `json:"NetworkAclEntryId,omitempty" xml:"NetworkAclEntryId,omitempty"`
	// The name of the inbound rule.
	NetworkAclEntryName *string `json:"NetworkAclEntryName,omitempty" xml:"NetworkAclEntryName,omitempty"`
	// The action to be performed on network traffic that matches the rule. Valid values:
	//
	// *   **accept**: allows network traffic.
	// *   **drop**: blocks network traffic.
	Policy *string `json:"Policy,omitempty" xml:"Policy,omitempty"`
	// The destination port range of the inbound traffic.
	//
	// *   If **Protocol** of the inbound rule is set to **all**, **icmp**, or **gre**, the port range is **-1/-1**, which indicates all ports.
	// *   If **Protocol** of the inbound rule is set to **tcp** or **udp**, the port range is in the following format: **1/200** or **80/80**. 1/200 indicates port 1 to port 200. 80/80 indicates port 80. Valid values for a port: **1** to **65535**.
	Port *string `json:"Port,omitempty" xml:"Port,omitempty"`
	// The protocol. Valid values:
	//
	// *   **icmp**: ICMP
	// *   **gre**: GRE
	// *   **tcp**: TCP
	// *   **udp**: UDP
	// *   **all**: all protocols
	Protocol *string `json:"Protocol,omitempty" xml:"Protocol,omitempty"`
	// The source CIDR block.
	SourceCidrIp *string `json:"SourceCidrIp,omitempty" xml:"SourceCidrIp,omitempty"`
}

func (s DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclIngressAclEntriesIngressAclEntry) String() string {
	return tea.Prettify(s)
}

func (s DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclIngressAclEntriesIngressAclEntry) GoString() string {
	return s.String()
}

func (s *DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclIngressAclEntriesIngressAclEntry) SetDescription(v string) *DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclIngressAclEntriesIngressAclEntry {
	s.Description = &v
	return s
}

func (s *DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclIngressAclEntriesIngressAclEntry) SetNetworkAclEntryId(v string) *DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclIngressAclEntriesIngressAclEntry {
	s.NetworkAclEntryId = &v
	return s
}

func (s *DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclIngressAclEntriesIngressAclEntry) SetNetworkAclEntryName(v string) *DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclIngressAclEntriesIngressAclEntry {
	s.NetworkAclEntryName = &v
	return s
}

func (s *DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclIngressAclEntriesIngressAclEntry) SetPolicy(v string) *DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclIngressAclEntriesIngressAclEntry {
	s.Policy = &v
	return s
}

func (s *DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclIngressAclEntriesIngressAclEntry) SetPort(v string) *DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclIngressAclEntriesIngressAclEntry {
	s.Port = &v
	return s
}

func (s *DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclIngressAclEntriesIngressAclEntry) SetProtocol(v string) *DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclIngressAclEntriesIngressAclEntry {
	s.Protocol = &v
	return s
}

func (s *DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclIngressAclEntriesIngressAclEntry) SetSourceCidrIp(v string) *DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclIngressAclEntriesIngressAclEntry {
	s.SourceCidrIp = &v
	return s
}

type DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclResources struct {
	Resource []*DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclResourcesResource `json:"Resource,omitempty" xml:"Resource,omitempty" type:"Repeated"`
}

func (s DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclResources) String() string {
	return tea.Prettify(s)
}

func (s DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclResources) GoString() string {
	return s.String()
}

func (s *DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclResources) SetResource(v []*DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclResourcesResource) *DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclResources {
	s.Resource = v
	return s
}

type DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclResourcesResource struct {
	// The ID of the associated resource.
	ResourceId *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	// The type of the associated resource.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The association status of the resource. Valid values:
	//
	// - **BINDED**: associated
	// - **BINDING**: being associated
	// - **UNBINDING**: disassociated
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclResourcesResource) String() string {
	return tea.Prettify(s)
}

func (s DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclResourcesResource) GoString() string {
	return s.String()
}

func (s *DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclResourcesResource) SetResourceId(v string) *DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclResourcesResource {
	s.ResourceId = &v
	return s
}

func (s *DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclResourcesResource) SetResourceType(v string) *DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclResourcesResource {
	s.ResourceType = &v
	return s
}

func (s *DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclResourcesResource) SetStatus(v string) *DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclResourcesResource {
	s.Status = &v
	return s
}

type DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclTags struct {
	Tag []*DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclTagsTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclTags) String() string {
	return tea.Prettify(s)
}

func (s DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclTags) GoString() string {
	return s.String()
}

func (s *DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclTags) SetTag(v []*DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclTagsTag) *DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclTags {
	s.Tag = v
	return s
}

type DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclTagsTag struct {
	// The tag key.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclTagsTag) String() string {
	return tea.Prettify(s)
}

func (s DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclTagsTag) GoString() string {
	return s.String()
}

func (s *DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclTagsTag) SetKey(v string) *DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclTagsTag {
	s.Key = &v
	return s
}

func (s *DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclTagsTag) SetValue(v string) *DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclTagsTag {
	s.Value = &v
	return s
}

type DescribeNetworkAclsResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeNetworkAclsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeNetworkAclsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeNetworkAclsResponse) GoString() string {
	return s.String()
}

func (s *DescribeNetworkAclsResponse) SetHeaders(v map[string]*string) *DescribeNetworkAclsResponse {
	s.Headers = v
	return s
}

func (s *DescribeNetworkAclsResponse) SetStatusCode(v int32) *DescribeNetworkAclsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeNetworkAclsResponse) SetBody(v *DescribeNetworkAclsResponseBody) *DescribeNetworkAclsResponse {
	s.Body = v
	return s
}

type DescribePhysicalConnectionLOARequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	//
	// >  If you do not set this parameter, the system automatically uses **RequestId** as **ClientToken**. **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the Express Connect circuit.
	InstanceId   *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the Express Connect circuit.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribePhysicalConnectionLOARequest) String() string {
	return tea.Prettify(s)
}

func (s DescribePhysicalConnectionLOARequest) GoString() string {
	return s.String()
}

func (s *DescribePhysicalConnectionLOARequest) SetClientToken(v string) *DescribePhysicalConnectionLOARequest {
	s.ClientToken = &v
	return s
}

func (s *DescribePhysicalConnectionLOARequest) SetInstanceId(v string) *DescribePhysicalConnectionLOARequest {
	s.InstanceId = &v
	return s
}

func (s *DescribePhysicalConnectionLOARequest) SetOwnerAccount(v string) *DescribePhysicalConnectionLOARequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribePhysicalConnectionLOARequest) SetOwnerId(v int64) *DescribePhysicalConnectionLOARequest {
	s.OwnerId = &v
	return s
}

func (s *DescribePhysicalConnectionLOARequest) SetRegionId(v string) *DescribePhysicalConnectionLOARequest {
	s.RegionId = &v
	return s
}

func (s *DescribePhysicalConnectionLOARequest) SetResourceOwnerAccount(v string) *DescribePhysicalConnectionLOARequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribePhysicalConnectionLOARequest) SetResourceOwnerId(v int64) *DescribePhysicalConnectionLOARequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribePhysicalConnectionLOAResponseBody struct {
	// The LOA information about the Express Connect circuit.
	PhysicalConnectionLOAType *DescribePhysicalConnectionLOAResponseBodyPhysicalConnectionLOAType `json:"PhysicalConnectionLOAType,omitempty" xml:"PhysicalConnectionLOAType,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribePhysicalConnectionLOAResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribePhysicalConnectionLOAResponseBody) GoString() string {
	return s.String()
}

func (s *DescribePhysicalConnectionLOAResponseBody) SetPhysicalConnectionLOAType(v *DescribePhysicalConnectionLOAResponseBodyPhysicalConnectionLOAType) *DescribePhysicalConnectionLOAResponseBody {
	s.PhysicalConnectionLOAType = v
	return s
}

func (s *DescribePhysicalConnectionLOAResponseBody) SetRequestId(v string) *DescribePhysicalConnectionLOAResponseBody {
	s.RequestId = &v
	return s
}

type DescribePhysicalConnectionLOAResponseBodyPhysicalConnectionLOAType struct {
	// The name of the construction company.
	CompanyLocalizedName *string `json:"CompanyLocalizedName,omitempty" xml:"CompanyLocalizedName,omitempty"`
	// The name of the organization that requires the Express Connect circuit.
	CompanyName *string `json:"CompanyName,omitempty" xml:"CompanyName,omitempty"`
	// The time when construction starts.
	ConstructionTime *string `json:"ConstructionTime,omitempty" xml:"ConstructionTime,omitempty"`
	// The ID of the Express Connect circuit.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The circuit code provided by the connectivity provider.
	LineCode *string `json:"LineCode,omitempty" xml:"LineCode,omitempty"`
	// The label of the cable in the data center.
	LineLabel *string `json:"LineLabel,omitempty" xml:"LineLabel,omitempty"`
	// The type of the Express Connect circuit. Valid values:
	//
	// *   **MSTP**
	// *   **MPLSVPN**
	// *   **FIBRE**
	// *   **Other**
	LineType *string `json:"LineType,omitempty" xml:"LineType,omitempty"`
	// The download URL of the LOA file.
	LoaUrl *string `json:"LoaUrl,omitempty" xml:"LoaUrl,omitempty"`
	// The information about the construction workers.
	PMInfo *DescribePhysicalConnectionLOAResponseBodyPhysicalConnectionLOATypePMInfo `json:"PMInfo,omitempty" xml:"PMInfo,omitempty" type:"Struct"`
	// The on-site construction company.
	SI *string `json:"SI,omitempty" xml:"SI,omitempty"`
	// The status of the LOA. Valid values:
	//
	// *   **Applying**: The LOA is pending for approval.
	// *   **Accept**: The LOA is approved.
	// *   **Available**: The LOA is available.
	// *   **Rejected**: The LOA is rejected.
	// *   **Completing**: The Express Connect circuit is under construction.
	// *   **Complete**: The Express Connect circuit is installed.
	// *   **Deleted**: The LOA is deleted.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribePhysicalConnectionLOAResponseBodyPhysicalConnectionLOAType) String() string {
	return tea.Prettify(s)
}

func (s DescribePhysicalConnectionLOAResponseBodyPhysicalConnectionLOAType) GoString() string {
	return s.String()
}

func (s *DescribePhysicalConnectionLOAResponseBodyPhysicalConnectionLOAType) SetCompanyLocalizedName(v string) *DescribePhysicalConnectionLOAResponseBodyPhysicalConnectionLOAType {
	s.CompanyLocalizedName = &v
	return s
}

func (s *DescribePhysicalConnectionLOAResponseBodyPhysicalConnectionLOAType) SetCompanyName(v string) *DescribePhysicalConnectionLOAResponseBodyPhysicalConnectionLOAType {
	s.CompanyName = &v
	return s
}

func (s *DescribePhysicalConnectionLOAResponseBodyPhysicalConnectionLOAType) SetConstructionTime(v string) *DescribePhysicalConnectionLOAResponseBodyPhysicalConnectionLOAType {
	s.ConstructionTime = &v
	return s
}

func (s *DescribePhysicalConnectionLOAResponseBodyPhysicalConnectionLOAType) SetInstanceId(v string) *DescribePhysicalConnectionLOAResponseBodyPhysicalConnectionLOAType {
	s.InstanceId = &v
	return s
}

func (s *DescribePhysicalConnectionLOAResponseBodyPhysicalConnectionLOAType) SetLineCode(v string) *DescribePhysicalConnectionLOAResponseBodyPhysicalConnectionLOAType {
	s.LineCode = &v
	return s
}

func (s *DescribePhysicalConnectionLOAResponseBodyPhysicalConnectionLOAType) SetLineLabel(v string) *DescribePhysicalConnectionLOAResponseBodyPhysicalConnectionLOAType {
	s.LineLabel = &v
	return s
}

func (s *DescribePhysicalConnectionLOAResponseBodyPhysicalConnectionLOAType) SetLineType(v string) *DescribePhysicalConnectionLOAResponseBodyPhysicalConnectionLOAType {
	s.LineType = &v
	return s
}

func (s *DescribePhysicalConnectionLOAResponseBodyPhysicalConnectionLOAType) SetLoaUrl(v string) *DescribePhysicalConnectionLOAResponseBodyPhysicalConnectionLOAType {
	s.LoaUrl = &v
	return s
}

func (s *DescribePhysicalConnectionLOAResponseBodyPhysicalConnectionLOAType) SetPMInfo(v *DescribePhysicalConnectionLOAResponseBodyPhysicalConnectionLOATypePMInfo) *DescribePhysicalConnectionLOAResponseBodyPhysicalConnectionLOAType {
	s.PMInfo = v
	return s
}

func (s *DescribePhysicalConnectionLOAResponseBodyPhysicalConnectionLOAType) SetSI(v string) *DescribePhysicalConnectionLOAResponseBodyPhysicalConnectionLOAType {
	s.SI = &v
	return s
}

func (s *DescribePhysicalConnectionLOAResponseBodyPhysicalConnectionLOAType) SetStatus(v string) *DescribePhysicalConnectionLOAResponseBodyPhysicalConnectionLOAType {
	s.Status = &v
	return s
}

type DescribePhysicalConnectionLOAResponseBodyPhysicalConnectionLOATypePMInfo struct {
	PMInfo []*DescribePhysicalConnectionLOAResponseBodyPhysicalConnectionLOATypePMInfoPMInfo `json:"PMInfo,omitempty" xml:"PMInfo,omitempty" type:"Repeated"`
}

func (s DescribePhysicalConnectionLOAResponseBodyPhysicalConnectionLOATypePMInfo) String() string {
	return tea.Prettify(s)
}

func (s DescribePhysicalConnectionLOAResponseBodyPhysicalConnectionLOATypePMInfo) GoString() string {
	return s.String()
}

func (s *DescribePhysicalConnectionLOAResponseBodyPhysicalConnectionLOATypePMInfo) SetPMInfo(v []*DescribePhysicalConnectionLOAResponseBodyPhysicalConnectionLOATypePMInfoPMInfo) *DescribePhysicalConnectionLOAResponseBodyPhysicalConnectionLOATypePMInfo {
	s.PMInfo = v
	return s
}

type DescribePhysicalConnectionLOAResponseBodyPhysicalConnectionLOATypePMInfoPMInfo struct {
	// The identity document number of the construction worker.
	PMCertificateNo *string `json:"PMCertificateNo,omitempty" xml:"PMCertificateNo,omitempty"`
	// The identity document type of the construction worker. Valid values:
	//
	// *   **IDCard**: identity card
	// *   **Passport**: passport
	// *   **Other**: other identity documents
	PMCertificateType *string `json:"PMCertificateType,omitempty" xml:"PMCertificateType,omitempty"`
	// The phone number of the construction worker.
	PMContactInfo *string `json:"PMContactInfo,omitempty" xml:"PMContactInfo,omitempty"`
	// The gender of the construction worker. Valid values:
	//
	// *   **Male**: male
	// *   **Female**: female
	PMGender *string `json:"PMGender,omitempty" xml:"PMGender,omitempty"`
	// The name of the construction worker.
	PMName *string `json:"PMName,omitempty" xml:"PMName,omitempty"`
}

func (s DescribePhysicalConnectionLOAResponseBodyPhysicalConnectionLOATypePMInfoPMInfo) String() string {
	return tea.Prettify(s)
}

func (s DescribePhysicalConnectionLOAResponseBodyPhysicalConnectionLOATypePMInfoPMInfo) GoString() string {
	return s.String()
}

func (s *DescribePhysicalConnectionLOAResponseBodyPhysicalConnectionLOATypePMInfoPMInfo) SetPMCertificateNo(v string) *DescribePhysicalConnectionLOAResponseBodyPhysicalConnectionLOATypePMInfoPMInfo {
	s.PMCertificateNo = &v
	return s
}

func (s *DescribePhysicalConnectionLOAResponseBodyPhysicalConnectionLOATypePMInfoPMInfo) SetPMCertificateType(v string) *DescribePhysicalConnectionLOAResponseBodyPhysicalConnectionLOATypePMInfoPMInfo {
	s.PMCertificateType = &v
	return s
}

func (s *DescribePhysicalConnectionLOAResponseBodyPhysicalConnectionLOATypePMInfoPMInfo) SetPMContactInfo(v string) *DescribePhysicalConnectionLOAResponseBodyPhysicalConnectionLOATypePMInfoPMInfo {
	s.PMContactInfo = &v
	return s
}

func (s *DescribePhysicalConnectionLOAResponseBodyPhysicalConnectionLOATypePMInfoPMInfo) SetPMGender(v string) *DescribePhysicalConnectionLOAResponseBodyPhysicalConnectionLOATypePMInfoPMInfo {
	s.PMGender = &v
	return s
}

func (s *DescribePhysicalConnectionLOAResponseBodyPhysicalConnectionLOATypePMInfoPMInfo) SetPMName(v string) *DescribePhysicalConnectionLOAResponseBodyPhysicalConnectionLOATypePMInfoPMInfo {
	s.PMName = &v
	return s
}

type DescribePhysicalConnectionLOAResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribePhysicalConnectionLOAResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribePhysicalConnectionLOAResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribePhysicalConnectionLOAResponse) GoString() string {
	return s.String()
}

func (s *DescribePhysicalConnectionLOAResponse) SetHeaders(v map[string]*string) *DescribePhysicalConnectionLOAResponse {
	s.Headers = v
	return s
}

func (s *DescribePhysicalConnectionLOAResponse) SetStatusCode(v int32) *DescribePhysicalConnectionLOAResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribePhysicalConnectionLOAResponse) SetBody(v *DescribePhysicalConnectionLOAResponseBody) *DescribePhysicalConnectionLOAResponse {
	s.Body = v
	return s
}

type DescribePhysicalConnectionsRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. ClientToken can contain only ASCII characters.
	ClientToken *string                                     `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	Filter      []*DescribePhysicalConnectionsRequestFilter `json:"Filter,omitempty" xml:"Filter,omitempty" type:"Repeated"`
	// Specifies whether to return the data about pending orders. Valid values:
	//
	// *   **true**: yes
	// *   **false** (default): no
	IncludeReservationData *bool   `json:"IncludeReservationData,omitempty" xml:"IncludeReservationData,omitempty"`
	OwnerAccount           *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId                *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of the page to return. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Default value: **10**. Valid values: **1** to **50**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The region ID of the Express Connect circuit.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string                                   `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceGroupId      *string                                   `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string                                   `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64                                    `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	Tags                 []*DescribePhysicalConnectionsRequestTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
}

func (s DescribePhysicalConnectionsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribePhysicalConnectionsRequest) GoString() string {
	return s.String()
}

func (s *DescribePhysicalConnectionsRequest) SetClientToken(v string) *DescribePhysicalConnectionsRequest {
	s.ClientToken = &v
	return s
}

func (s *DescribePhysicalConnectionsRequest) SetFilter(v []*DescribePhysicalConnectionsRequestFilter) *DescribePhysicalConnectionsRequest {
	s.Filter = v
	return s
}

func (s *DescribePhysicalConnectionsRequest) SetIncludeReservationData(v bool) *DescribePhysicalConnectionsRequest {
	s.IncludeReservationData = &v
	return s
}

func (s *DescribePhysicalConnectionsRequest) SetOwnerAccount(v string) *DescribePhysicalConnectionsRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribePhysicalConnectionsRequest) SetOwnerId(v int64) *DescribePhysicalConnectionsRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribePhysicalConnectionsRequest) SetPageNumber(v int32) *DescribePhysicalConnectionsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribePhysicalConnectionsRequest) SetPageSize(v int32) *DescribePhysicalConnectionsRequest {
	s.PageSize = &v
	return s
}

func (s *DescribePhysicalConnectionsRequest) SetRegionId(v string) *DescribePhysicalConnectionsRequest {
	s.RegionId = &v
	return s
}

func (s *DescribePhysicalConnectionsRequest) SetResourceGroupId(v string) *DescribePhysicalConnectionsRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribePhysicalConnectionsRequest) SetResourceOwnerAccount(v string) *DescribePhysicalConnectionsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribePhysicalConnectionsRequest) SetResourceOwnerId(v int64) *DescribePhysicalConnectionsRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribePhysicalConnectionsRequest) SetTags(v []*DescribePhysicalConnectionsRequestTags) *DescribePhysicalConnectionsRequest {
	s.Tags = v
	return s
}

type DescribePhysicalConnectionsRequestFilter struct {
	// The key of the filter. Valid values:
	//
	// *   **PhysicalConnectionId**: the ID of the Express Connect circuit.
	//
	// *   **AccessPointId**: the ID of the access point.
	//
	// *   **Type**: the type of the Express Connect circuit. You can set Type only to **VPC**.
	//
	// *   **LineOperator**: the connectivity provider of the Express Connect circuit. Valid values:
	//
	//     *   **CT**: China Telecom.
	//     *   **CU**: China Unicom.
	//     *   **CM**: China Mobile.
	//     *   **CO**: other connectivity providers in the Chinese mainland.
	//     *   **Equinix**: Equinix.
	//     *   **Other**: other connectivity providers outside the Chinese mainland.
	//
	// *   **Spec**: the specification of the Express Connect circuit. Valid values:
	//
	//     *   **1G and below**
	//
	//     *   **10G**
	//
	//     *   **40G**
	//
	//     *   **100G**
	//
	// > By default, you cannot set Spec to **40G** or **100G**. To query 40 Gbit/s or 100 Gbit/s Express Connect circuits, you must first submit an application to acquire the permissions.
	//
	// *   **Status**: the status of the Express Connect circuit. Valid values:
	//
	//     *   **Initial**: The application is under review.
	//     *   **Approved**: The application is approved.
	//     *   **Allocating**: The system is allocating resources.
	//     *   **Allocated**: The Express Connect circuit is under construction.
	//     *   **Confirmed**: The Express Connect circuit is pending user confirmation.
	//     *   **Enabled**: The Express Connect circuit is enabled.
	//     *   **Rejected**: The application is rejected.
	//     *   **Canceled**: The application is canceled.
	//     *   **Allocation Failed**: The system failed to allocate resources.
	//     *   **Terminating**: The Express Connect circuit is being disabled.
	//     *   **Terminated**: The Express Connect circuit is disabled.
	//
	// *   **Name**: the name of the Express Connect circuit.
	//
	// You can specify at most five filter conditions in each call. The logical relation among the filter conditions is **AND**. Therefore, an Express Connect circuit is returned only when all specified filter conditions are matched.
	Key   *string   `json:"Key,omitempty" xml:"Key,omitempty"`
	Value []*string `json:"Value,omitempty" xml:"Value,omitempty" type:"Repeated"`
}

func (s DescribePhysicalConnectionsRequestFilter) String() string {
	return tea.Prettify(s)
}

func (s DescribePhysicalConnectionsRequestFilter) GoString() string {
	return s.String()
}

func (s *DescribePhysicalConnectionsRequestFilter) SetKey(v string) *DescribePhysicalConnectionsRequestFilter {
	s.Key = &v
	return s
}

func (s *DescribePhysicalConnectionsRequestFilter) SetValue(v []*string) *DescribePhysicalConnectionsRequestFilter {
	s.Value = v
	return s
}

type DescribePhysicalConnectionsRequestTags struct {
	// The key of the tag that is added to the resource. You can specify at most 20 tag keys. The tag value cannot be an empty string.
	//
	// The key cannot exceed 64 characters in length, and can contain digits, periods (.), underscores (\_), and hyphens (-). The key must start with a letter but cannot start with `aliyun` or `acs:`. The key cannot contain `http://` or `https://`.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The value of the tag that is added to the resource. You can specify at most 20 tag values. The tag value can be an empty string.
	//
	// The value cannot exceed 128 characters in length and can contain digits, periods (.), underscores (\_), and hyphens (-). The value must start with a letter but cannot start with `aliyun` or `acs:`. The value cannot contain `http://` or `https://`.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribePhysicalConnectionsRequestTags) String() string {
	return tea.Prettify(s)
}

func (s DescribePhysicalConnectionsRequestTags) GoString() string {
	return s.String()
}

func (s *DescribePhysicalConnectionsRequestTags) SetKey(v string) *DescribePhysicalConnectionsRequestTags {
	s.Key = &v
	return s
}

func (s *DescribePhysicalConnectionsRequestTags) SetValue(v string) *DescribePhysicalConnectionsRequestTags {
	s.Value = &v
	return s
}

type DescribePhysicalConnectionsResponseBody struct {
	// The number of the returned page. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page. Default value: **10**. Valid values: **1** to **50**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The list of Express Connect circuits.
	PhysicalConnectionSet *DescribePhysicalConnectionsResponseBodyPhysicalConnectionSet `json:"PhysicalConnectionSet,omitempty" xml:"PhysicalConnectionSet,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribePhysicalConnectionsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribePhysicalConnectionsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribePhysicalConnectionsResponseBody) SetPageNumber(v int32) *DescribePhysicalConnectionsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribePhysicalConnectionsResponseBody) SetPageSize(v int32) *DescribePhysicalConnectionsResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribePhysicalConnectionsResponseBody) SetPhysicalConnectionSet(v *DescribePhysicalConnectionsResponseBodyPhysicalConnectionSet) *DescribePhysicalConnectionsResponseBody {
	s.PhysicalConnectionSet = v
	return s
}

func (s *DescribePhysicalConnectionsResponseBody) SetRequestId(v string) *DescribePhysicalConnectionsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribePhysicalConnectionsResponseBody) SetTotalCount(v int32) *DescribePhysicalConnectionsResponseBody {
	s.TotalCount = &v
	return s
}

type DescribePhysicalConnectionsResponseBodyPhysicalConnectionSet struct {
	PhysicalConnectionType []*DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType `json:"PhysicalConnectionType,omitempty" xml:"PhysicalConnectionType,omitempty" type:"Repeated"`
}

func (s DescribePhysicalConnectionsResponseBodyPhysicalConnectionSet) String() string {
	return tea.Prettify(s)
}

func (s DescribePhysicalConnectionsResponseBodyPhysicalConnectionSet) GoString() string {
	return s.String()
}

func (s *DescribePhysicalConnectionsResponseBodyPhysicalConnectionSet) SetPhysicalConnectionType(v []*DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType) *DescribePhysicalConnectionsResponseBodyPhysicalConnectionSet {
	s.PhysicalConnectionType = v
	return s
}

type DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType struct {
	// The ID of the access point.
	AccessPointId *string `json:"AccessPointId,omitempty" xml:"AccessPointId,omitempty"`
	// The type of the access point.
	AccessPointType  *string `json:"AccessPointType,omitempty" xml:"AccessPointType,omitempty"`
	AdDetailLocation *string `json:"AdDetailLocation,omitempty" xml:"AdDetailLocation,omitempty"`
	// The geographical location of the access device.
	AdLocation *string `json:"AdLocation,omitempty" xml:"AdLocation,omitempty"`
	// The maximum bandwidth of the Express Connect circuit.
	//
	// Unit: Gbit/s.
	Bandwidth *int64 `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	// The status of the Express Connect circuit. Valid values:
	//
	// *   **Normal**: enabled
	// *   **FinancialLocked**: locked due to overdue payments
	// *   **SecurityLocked**: locked for security reasons
	BusinessStatus *string `json:"BusinessStatus,omitempty" xml:"BusinessStatus,omitempty"`
	// The billing method of the Express Connect circuit.
	//
	// If the value is set to **Prepaid**, it indicates that the Express Connect circuit is billed on a subscription basis.
	ChargeType *string `json:"ChargeType,omitempty" xml:"ChargeType,omitempty"`
	// The circuit code of the Express Connect circuit. The circuit code is provided by the connectivity provider.
	CircuitCode *string `json:"CircuitCode,omitempty" xml:"CircuitCode,omitempty"`
	// The time when the Express Connect circuit was created.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The description of the Express Connect circuit.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The time when the Express Connect circuit was enabled.
	EnabledTime *string `json:"EnabledTime,omitempty" xml:"EnabledTime,omitempty"`
	// The time when the Express Connect circuit expires.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The estimated bandwidth value of the hosted connection. The estimated bandwidth takes effect after you complete the payment.
	//
	// **M** indicates Mbit/s and **G** indicates Gbit/s.
	ExpectSpec *string `json:"ExpectSpec,omitempty" xml:"ExpectSpec,omitempty"`
	// Indicates whether the data about pending orders is returned. Valid values:
	//
	// *   **true**: yes
	// *   **false**: no
	HasReservationData *string `json:"HasReservationData,omitempty" xml:"HasReservationData,omitempty"`
	// The connectivity provider of the Express Connect circuit. Valid values:
	//
	// *   **CT**: China Telecom.
	// *   **CU**: China Unicom.
	// *   **CM**: China Mobile.
	// *   **CO**: other connectivity providers in the Chinese mainland.
	// *   **Equinix**: Equinix.
	// *   **Other**: other connectivity providers outside the Chinese mainland.
	LineOperator *string `json:"LineOperator,omitempty" xml:"LineOperator,omitempty"`
	// The status of the letter of authorization (LOA). Valid values:
	//
	// *   **Applying**: The LOA is pending approval.
	// *   **Accept**: The LOA is approved.
	// *   **Available**: The LOA is available.
	// *   **Rejected**: The LOA is rejected.
	// *   **Completing**: The Express Connect circuit is under construction.
	// *   **Complete**: The Express Connect circuit is installed.
	// *   **Deleted**: The LOA is deleted.
	LoaStatus *string `json:"LoaStatus,omitempty" xml:"LoaStatus,omitempty"`
	// The name of the Express Connect circuit.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The payer for the hosted connection. Valid values:
	//
	// *   **PayByPhysicalConnectionOwner**: The partner pays for the hosted connection.
	// *   **PayByVirtualPhysicalConnectionOwner**: The tenant pays for the hosted connection.
	OrderMode *string `json:"OrderMode,omitempty" xml:"OrderMode,omitempty"`
	// The Alibaba Cloud account ID of the Express Connect circuit that is used to create the hosted connection.
	ParentPhysicalConnectionAliUid *int64 `json:"ParentPhysicalConnectionAliUid,omitempty" xml:"ParentPhysicalConnectionAliUid,omitempty"`
	// The ID of the Express Connect circuit that is used to create the hosted connection.
	ParentPhysicalConnectionId *string `json:"ParentPhysicalConnectionId,omitempty" xml:"ParentPhysicalConnectionId,omitempty"`
	// The geographical location of the data center.
	PeerLocation *string `json:"PeerLocation,omitempty" xml:"PeerLocation,omitempty"`
	// The ID of the Express Connect circuit.
	PhysicalConnectionId *string `json:"PhysicalConnectionId,omitempty" xml:"PhysicalConnectionId,omitempty"`
	// The ID of the port on the access device.
	PortNumber *string `json:"PortNumber,omitempty" xml:"PortNumber,omitempty"`
	// The port type. Valid values:
	//
	// *   **100Base-T**: 100 Mbit/s copper Ethernet port
	// *   **1000Base-T**: 1,000 Mbit/s copper Ethernet port
	// *   **1000Base-LX**: 1,000 Mbit/s single-mode optical port (10 km)
	// *   **10GBase-T**: 10,000 Mbit/s copper Ethernet port
	// *   **10GBase-LR**: 10,000 Mbit/s single-mode optical port (10 km)
	// *   **40GBase-LR**: 40,000 Mbit/s single-mode optical port
	// *   **100GBase-LR**: 100,000 Mbit/s single-mode optical port
	//
	// >  Whether 40GBase-LR and 100GBase-LR ports can be created is based on resource supplies. For more information, contact your business manager.
	PortType *string `json:"PortType,omitempty" xml:"PortType,omitempty"`
	// The type of the Express Connect circuit. Valid values:
	//
	// *   **VirtualPhysicalConnection**: a shared Express Connect circuit
	// *   **PhysicalConnection**: a dedicated Express Connect circuit
	ProductType *string `json:"ProductType,omitempty" xml:"ProductType,omitempty"`
	// The ID of the redundant Express Connect circuit.
	RedundantPhysicalConnectionId *string `json:"RedundantPhysicalConnectionId,omitempty" xml:"RedundantPhysicalConnectionId,omitempty"`
	// The time when the pending order takes effect.
	ReservationActiveTime *string `json:"ReservationActiveTime,omitempty" xml:"ReservationActiveTime,omitempty"`
	// The billing method of the pending order.
	//
	// The value is set to **PayByBandwidth**, which indicates the pay-by-bandwidth metering method.
	ReservationInternetChargeType *string `json:"ReservationInternetChargeType,omitempty" xml:"ReservationInternetChargeType,omitempty"`
	// The type of the pending order.
	//
	// If the value is set to **RENEW**, it indicates that the order is placed for service renewal.
	ReservationOrderType *string `json:"ReservationOrderType,omitempty" xml:"ReservationOrderType,omitempty"`
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The specification of the Express Connect circuit.
	//
	// Unit: **G** (Gbit/s).
	Spec *string `json:"Spec,omitempty" xml:"Spec,omitempty"`
	// The status of the Express Connect circuit. Valid values:
	//
	// *   **Initial**: The application is under review.
	// *   **Approved**: The application is approved.
	// *   **Allocating**: The system is allocating resources.
	// *   **Allocated**: The Express Connect circuit is under construction.
	// *   **Confirmed**: The Express Connect circuit is pending user confirmation.
	// *   **Enabled**: The Express Connect circuit is enabled.
	// *   **Rejected**: The application is rejected.
	// *   **Canceled**: The application is canceled.
	// *   **Allocation Failed**: The system failed to allocate resources.
	// *   **Terminating**: The Express Connect circuit is being disabled.
	// *   **Terminated**: The Express Connect circuit is disabled.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The type of the Express Connect circuit. The value is set to **VPC**.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The number of hosted connections that are established over the Express Connect circuit.
	VirtualPhysicalConnectionCount *int32 `json:"VirtualPhysicalConnectionCount,omitempty" xml:"VirtualPhysicalConnectionCount,omitempty"`
	// The VLAN ID of the hosted connection.
	VlanId *string `json:"VlanId,omitempty" xml:"VlanId,omitempty"`
	// The status of the hosted connection. Valid values:
	//
	// *   **Confirmed**: accepted
	// *   **UnConfirmed**: pending acceptance
	// *   **Deleted**: deleted
	VpconnStatus *string `json:"VpconnStatus,omitempty" xml:"VpconnStatus,omitempty"`
}

func (s DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType) String() string {
	return tea.Prettify(s)
}

func (s DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType) GoString() string {
	return s.String()
}

func (s *DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType) SetAccessPointId(v string) *DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType {
	s.AccessPointId = &v
	return s
}

func (s *DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType) SetAccessPointType(v string) *DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType {
	s.AccessPointType = &v
	return s
}

func (s *DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType) SetAdDetailLocation(v string) *DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType {
	s.AdDetailLocation = &v
	return s
}

func (s *DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType) SetAdLocation(v string) *DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType {
	s.AdLocation = &v
	return s
}

func (s *DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType) SetBandwidth(v int64) *DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType {
	s.Bandwidth = &v
	return s
}

func (s *DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType) SetBusinessStatus(v string) *DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType {
	s.BusinessStatus = &v
	return s
}

func (s *DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType) SetChargeType(v string) *DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType {
	s.ChargeType = &v
	return s
}

func (s *DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType) SetCircuitCode(v string) *DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType {
	s.CircuitCode = &v
	return s
}

func (s *DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType) SetCreationTime(v string) *DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType {
	s.CreationTime = &v
	return s
}

func (s *DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType) SetDescription(v string) *DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType {
	s.Description = &v
	return s
}

func (s *DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType) SetEnabledTime(v string) *DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType {
	s.EnabledTime = &v
	return s
}

func (s *DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType) SetEndTime(v string) *DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType {
	s.EndTime = &v
	return s
}

func (s *DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType) SetExpectSpec(v string) *DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType {
	s.ExpectSpec = &v
	return s
}

func (s *DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType) SetHasReservationData(v string) *DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType {
	s.HasReservationData = &v
	return s
}

func (s *DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType) SetLineOperator(v string) *DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType {
	s.LineOperator = &v
	return s
}

func (s *DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType) SetLoaStatus(v string) *DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType {
	s.LoaStatus = &v
	return s
}

func (s *DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType) SetName(v string) *DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType {
	s.Name = &v
	return s
}

func (s *DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType) SetOrderMode(v string) *DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType {
	s.OrderMode = &v
	return s
}

func (s *DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType) SetParentPhysicalConnectionAliUid(v int64) *DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType {
	s.ParentPhysicalConnectionAliUid = &v
	return s
}

func (s *DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType) SetParentPhysicalConnectionId(v string) *DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType {
	s.ParentPhysicalConnectionId = &v
	return s
}

func (s *DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType) SetPeerLocation(v string) *DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType {
	s.PeerLocation = &v
	return s
}

func (s *DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType) SetPhysicalConnectionId(v string) *DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType {
	s.PhysicalConnectionId = &v
	return s
}

func (s *DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType) SetPortNumber(v string) *DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType {
	s.PortNumber = &v
	return s
}

func (s *DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType) SetPortType(v string) *DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType {
	s.PortType = &v
	return s
}

func (s *DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType) SetProductType(v string) *DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType {
	s.ProductType = &v
	return s
}

func (s *DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType) SetRedundantPhysicalConnectionId(v string) *DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType {
	s.RedundantPhysicalConnectionId = &v
	return s
}

func (s *DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType) SetReservationActiveTime(v string) *DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType {
	s.ReservationActiveTime = &v
	return s
}

func (s *DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType) SetReservationInternetChargeType(v string) *DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType {
	s.ReservationInternetChargeType = &v
	return s
}

func (s *DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType) SetReservationOrderType(v string) *DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType {
	s.ReservationOrderType = &v
	return s
}

func (s *DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType) SetResourceGroupId(v string) *DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType) SetSpec(v string) *DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType {
	s.Spec = &v
	return s
}

func (s *DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType) SetStatus(v string) *DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType {
	s.Status = &v
	return s
}

func (s *DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType) SetType(v string) *DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType {
	s.Type = &v
	return s
}

func (s *DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType) SetVirtualPhysicalConnectionCount(v int32) *DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType {
	s.VirtualPhysicalConnectionCount = &v
	return s
}

func (s *DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType) SetVlanId(v string) *DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType {
	s.VlanId = &v
	return s
}

func (s *DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType) SetVpconnStatus(v string) *DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType {
	s.VpconnStatus = &v
	return s
}

type DescribePhysicalConnectionsResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribePhysicalConnectionsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribePhysicalConnectionsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribePhysicalConnectionsResponse) GoString() string {
	return s.String()
}

func (s *DescribePhysicalConnectionsResponse) SetHeaders(v map[string]*string) *DescribePhysicalConnectionsResponse {
	s.Headers = v
	return s
}

func (s *DescribePhysicalConnectionsResponse) SetStatusCode(v int32) *DescribePhysicalConnectionsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribePhysicalConnectionsResponse) SetBody(v *DescribePhysicalConnectionsResponseBody) *DescribePhysicalConnectionsResponse {
	s.Body = v
	return s
}

type DescribePublicIpAddressRequest struct {
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of the page to return. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page.
	//
	// Valid values: **1** to **100**. Default value: **100**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The region that you want to query.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribePublicIpAddressRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribePublicIpAddressRequest) GoString() string {
	return s.String()
}

func (s *DescribePublicIpAddressRequest) SetOwnerAccount(v string) *DescribePublicIpAddressRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribePublicIpAddressRequest) SetOwnerId(v int64) *DescribePublicIpAddressRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribePublicIpAddressRequest) SetPageNumber(v int32) *DescribePublicIpAddressRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribePublicIpAddressRequest) SetPageSize(v int32) *DescribePublicIpAddressRequest {
	s.PageSize = &v
	return s
}

func (s *DescribePublicIpAddressRequest) SetRegionId(v string) *DescribePublicIpAddressRequest {
	s.RegionId = &v
	return s
}

func (s *DescribePublicIpAddressRequest) SetResourceOwnerAccount(v string) *DescribePublicIpAddressRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribePublicIpAddressRequest) SetResourceOwnerId(v int64) *DescribePublicIpAddressRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribePublicIpAddressResponseBody struct {
	// The HTTP status code.
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The response message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The range of the public IP addresses of the VPC in the region.
	PublicIpAddress []*string `json:"PublicIpAddress,omitempty" xml:"PublicIpAddress,omitempty" type:"Repeated"`
	// The ID of the region to which the public IP addresses belong.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call is successful. Valid values:
	//
	// *   **true**: yes
	// *   **false**: no
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribePublicIpAddressResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribePublicIpAddressResponseBody) GoString() string {
	return s.String()
}

func (s *DescribePublicIpAddressResponseBody) SetCode(v string) *DescribePublicIpAddressResponseBody {
	s.Code = &v
	return s
}

func (s *DescribePublicIpAddressResponseBody) SetMessage(v string) *DescribePublicIpAddressResponseBody {
	s.Message = &v
	return s
}

func (s *DescribePublicIpAddressResponseBody) SetPageNumber(v int32) *DescribePublicIpAddressResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribePublicIpAddressResponseBody) SetPageSize(v int32) *DescribePublicIpAddressResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribePublicIpAddressResponseBody) SetPublicIpAddress(v []*string) *DescribePublicIpAddressResponseBody {
	s.PublicIpAddress = v
	return s
}

func (s *DescribePublicIpAddressResponseBody) SetRegionId(v string) *DescribePublicIpAddressResponseBody {
	s.RegionId = &v
	return s
}

func (s *DescribePublicIpAddressResponseBody) SetRequestId(v string) *DescribePublicIpAddressResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribePublicIpAddressResponseBody) SetSuccess(v bool) *DescribePublicIpAddressResponseBody {
	s.Success = &v
	return s
}

func (s *DescribePublicIpAddressResponseBody) SetTotalCount(v int32) *DescribePublicIpAddressResponseBody {
	s.TotalCount = &v
	return s
}

type DescribePublicIpAddressResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribePublicIpAddressResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribePublicIpAddressResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribePublicIpAddressResponse) GoString() string {
	return s.String()
}

func (s *DescribePublicIpAddressResponse) SetHeaders(v map[string]*string) *DescribePublicIpAddressResponse {
	s.Headers = v
	return s
}

func (s *DescribePublicIpAddressResponse) SetStatusCode(v int32) *DescribePublicIpAddressResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribePublicIpAddressResponse) SetBody(v *DescribePublicIpAddressResponseBody) *DescribePublicIpAddressResponse {
	s.Body = v
	return s
}

type DescribeRegionsRequest struct {
	// The language of the response. Valid values:
	//
	// *   **zh-CN** (default): Chinese
	// *   **en-US**: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	OwnerAccount   *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId        *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The service type. Default value: **VPC**.
	ProductType          *string `json:"ProductType,omitempty" xml:"ProductType,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeRegionsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeRegionsRequest) GoString() string {
	return s.String()
}

func (s *DescribeRegionsRequest) SetAcceptLanguage(v string) *DescribeRegionsRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *DescribeRegionsRequest) SetOwnerAccount(v string) *DescribeRegionsRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeRegionsRequest) SetOwnerId(v int64) *DescribeRegionsRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeRegionsRequest) SetProductType(v string) *DescribeRegionsRequest {
	s.ProductType = &v
	return s
}

func (s *DescribeRegionsRequest) SetResourceOwnerAccount(v string) *DescribeRegionsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeRegionsRequest) SetResourceOwnerId(v int64) *DescribeRegionsRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeRegionsResponseBody struct {
	// The list of regions.
	Regions *DescribeRegionsResponseBodyRegions `json:"Regions,omitempty" xml:"Regions,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeRegionsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeRegionsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeRegionsResponseBody) SetRegions(v *DescribeRegionsResponseBodyRegions) *DescribeRegionsResponseBody {
	s.Regions = v
	return s
}

func (s *DescribeRegionsResponseBody) SetRequestId(v string) *DescribeRegionsResponseBody {
	s.RequestId = &v
	return s
}

type DescribeRegionsResponseBodyRegions struct {
	Region []*DescribeRegionsResponseBodyRegionsRegion `json:"Region,omitempty" xml:"Region,omitempty" type:"Repeated"`
}

func (s DescribeRegionsResponseBodyRegions) String() string {
	return tea.Prettify(s)
}

func (s DescribeRegionsResponseBodyRegions) GoString() string {
	return s.String()
}

func (s *DescribeRegionsResponseBodyRegions) SetRegion(v []*DescribeRegionsResponseBodyRegionsRegion) *DescribeRegionsResponseBodyRegions {
	s.Region = v
	return s
}

type DescribeRegionsResponseBodyRegionsRegion struct {
	// The name of the region.
	LocalName *string `json:"LocalName,omitempty" xml:"LocalName,omitempty"`
	// The endpoint of the region.
	RegionEndpoint *string `json:"RegionEndpoint,omitempty" xml:"RegionEndpoint,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DescribeRegionsResponseBodyRegionsRegion) String() string {
	return tea.Prettify(s)
}

func (s DescribeRegionsResponseBodyRegionsRegion) GoString() string {
	return s.String()
}

func (s *DescribeRegionsResponseBodyRegionsRegion) SetLocalName(v string) *DescribeRegionsResponseBodyRegionsRegion {
	s.LocalName = &v
	return s
}

func (s *DescribeRegionsResponseBodyRegionsRegion) SetRegionEndpoint(v string) *DescribeRegionsResponseBodyRegionsRegion {
	s.RegionEndpoint = &v
	return s
}

func (s *DescribeRegionsResponseBodyRegionsRegion) SetRegionId(v string) *DescribeRegionsResponseBodyRegionsRegion {
	s.RegionId = &v
	return s
}

type DescribeRegionsResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeRegionsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeRegionsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeRegionsResponse) GoString() string {
	return s.String()
}

func (s *DescribeRegionsResponse) SetHeaders(v map[string]*string) *DescribeRegionsResponse {
	s.Headers = v
	return s
}

func (s *DescribeRegionsResponse) SetStatusCode(v int32) *DescribeRegionsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeRegionsResponse) SetBody(v *DescribeRegionsResponseBody) *DescribeRegionsResponse {
	s.Body = v
	return s
}

type DescribeRouteEntryListRequest struct {
	DestCidrBlockList []*string `json:"DestCidrBlockList,omitempty" xml:"DestCidrBlockList,omitempty" type:"Repeated"`
	// The destination CIDR block of the route. IPv4 and IPv6 CIDR blocks are supported.
	DestinationCidrBlock *string `json:"DestinationCidrBlock,omitempty" xml:"DestinationCidrBlock,omitempty"`
	// The IP version. Valid values:
	//
	// *   **IPv4**
	// *   **IPv6**
	IpVersion *string `json:"IpVersion,omitempty" xml:"IpVersion,omitempty"`
	// The number of entries to return on each page. Valid values: **1** to **100**. Default value: **10**.
	MaxResult *int32 `json:"MaxResult,omitempty" xml:"MaxResult,omitempty"`
	// The ID of the next hop.
	NextHopId *string `json:"NextHopId,omitempty" xml:"NextHopId,omitempty"`
	// The type of the next hop. Valid values:
	//
	// *   **Instance** (default): an Elastic Compute Service (ECS) instance
	// *   **HaVip**: a high-availability virtual IP address (HAVIP)
	// *   **VpnGateway**: a VPN gateway
	// *   **NatGateway**: a NAT gateway
	// *   **NetworkInterface**: a secondary elastic network interface (ENI)
	// *   **RouterInterface**: a router interface
	// *   **IPv6Gateway**: an IPv6 gateway
	// *   **Attachment**: a transit router
	NextHopType *string `json:"NextHopType,omitempty" xml:"NextHopType,omitempty"`
	// The token that is used for the next query. Valid values:
	//
	// *   If this is your first query and no next queries are to be sent, ignore this parameter.
	// *   If a next query is to be sent, set the parameter to the value of NextToken that is returned from the last call.
	NextToken    *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the route table.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the route that you want to query.
	RouteEntryId *string `json:"RouteEntryId,omitempty" xml:"RouteEntryId,omitempty"`
	// The name of the route.
	//
	// The name must be 1 to 128 characters in length, and cannot start with `http://` or `https://`.
	RouteEntryName *string `json:"RouteEntryName,omitempty" xml:"RouteEntryName,omitempty"`
	// The type of the route. Valid values:
	//
	// *   **Custom**: a custom route
	// *   **System**: a system route
	// *   **BGP**: a BGP route
	// *   **CEN**: a Cloud Enterprise Network (CEN) route
	RouteEntryType *string `json:"RouteEntryType,omitempty" xml:"RouteEntryType,omitempty"`
	// The ID of the route table.
	RouteTableId *string `json:"RouteTableId,omitempty" xml:"RouteTableId,omitempty"`
	// Specifies whether to host the route. If the parameter is empty, the route is not hosted.
	//
	// If you set the value to **TR**, the route is hosted by a transit router.
	ServiceType *string `json:"ServiceType,omitempty" xml:"ServiceType,omitempty"`
}

func (s DescribeRouteEntryListRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeRouteEntryListRequest) GoString() string {
	return s.String()
}

func (s *DescribeRouteEntryListRequest) SetDestCidrBlockList(v []*string) *DescribeRouteEntryListRequest {
	s.DestCidrBlockList = v
	return s
}

func (s *DescribeRouteEntryListRequest) SetDestinationCidrBlock(v string) *DescribeRouteEntryListRequest {
	s.DestinationCidrBlock = &v
	return s
}

func (s *DescribeRouteEntryListRequest) SetIpVersion(v string) *DescribeRouteEntryListRequest {
	s.IpVersion = &v
	return s
}

func (s *DescribeRouteEntryListRequest) SetMaxResult(v int32) *DescribeRouteEntryListRequest {
	s.MaxResult = &v
	return s
}

func (s *DescribeRouteEntryListRequest) SetNextHopId(v string) *DescribeRouteEntryListRequest {
	s.NextHopId = &v
	return s
}

func (s *DescribeRouteEntryListRequest) SetNextHopType(v string) *DescribeRouteEntryListRequest {
	s.NextHopType = &v
	return s
}

func (s *DescribeRouteEntryListRequest) SetNextToken(v string) *DescribeRouteEntryListRequest {
	s.NextToken = &v
	return s
}

func (s *DescribeRouteEntryListRequest) SetOwnerAccount(v string) *DescribeRouteEntryListRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeRouteEntryListRequest) SetOwnerId(v int64) *DescribeRouteEntryListRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeRouteEntryListRequest) SetRegionId(v string) *DescribeRouteEntryListRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeRouteEntryListRequest) SetResourceOwnerAccount(v string) *DescribeRouteEntryListRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeRouteEntryListRequest) SetResourceOwnerId(v int64) *DescribeRouteEntryListRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeRouteEntryListRequest) SetRouteEntryId(v string) *DescribeRouteEntryListRequest {
	s.RouteEntryId = &v
	return s
}

func (s *DescribeRouteEntryListRequest) SetRouteEntryName(v string) *DescribeRouteEntryListRequest {
	s.RouteEntryName = &v
	return s
}

func (s *DescribeRouteEntryListRequest) SetRouteEntryType(v string) *DescribeRouteEntryListRequest {
	s.RouteEntryType = &v
	return s
}

func (s *DescribeRouteEntryListRequest) SetRouteTableId(v string) *DescribeRouteEntryListRequest {
	s.RouteTableId = &v
	return s
}

func (s *DescribeRouteEntryListRequest) SetServiceType(v string) *DescribeRouteEntryListRequest {
	s.ServiceType = &v
	return s
}

type DescribeRouteEntryListResponseBody struct {
	// The token that is used for the next query. Valid values:
	//
	// *   If **NextToken** is empty, it indicates that no next query is to be sent.
	// *   If a value of **NextToken** is returned, the value is the token that is used for the subsequent query.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The information about the routes.
	RouteEntrys *DescribeRouteEntryListResponseBodyRouteEntrys `json:"RouteEntrys,omitempty" xml:"RouteEntrys,omitempty" type:"Struct"`
}

func (s DescribeRouteEntryListResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeRouteEntryListResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeRouteEntryListResponseBody) SetNextToken(v string) *DescribeRouteEntryListResponseBody {
	s.NextToken = &v
	return s
}

func (s *DescribeRouteEntryListResponseBody) SetRequestId(v string) *DescribeRouteEntryListResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeRouteEntryListResponseBody) SetRouteEntrys(v *DescribeRouteEntryListResponseBodyRouteEntrys) *DescribeRouteEntryListResponseBody {
	s.RouteEntrys = v
	return s
}

type DescribeRouteEntryListResponseBodyRouteEntrys struct {
	RouteEntry []*DescribeRouteEntryListResponseBodyRouteEntrysRouteEntry `json:"RouteEntry,omitempty" xml:"RouteEntry,omitempty" type:"Repeated"`
}

func (s DescribeRouteEntryListResponseBodyRouteEntrys) String() string {
	return tea.Prettify(s)
}

func (s DescribeRouteEntryListResponseBodyRouteEntrys) GoString() string {
	return s.String()
}

func (s *DescribeRouteEntryListResponseBodyRouteEntrys) SetRouteEntry(v []*DescribeRouteEntryListResponseBodyRouteEntrysRouteEntry) *DescribeRouteEntryListResponseBodyRouteEntrys {
	s.RouteEntry = v
	return s
}

type DescribeRouteEntryListResponseBodyRouteEntrysRouteEntry struct {
	// The description of the route.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The destination CIDR blocks of the route.
	DestinationCidrBlock *string `json:"DestinationCidrBlock,omitempty" xml:"DestinationCidrBlock,omitempty"`
	// The time when the route was modified. The time is displayed in `YYYY-MM-DDThh:mm:ssZ` format in UTC.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The IP version. Valid values:
	//
	// *   **IPv4**
	// *   **IPv6**
	IpVersion *string `json:"IpVersion,omitempty" xml:"IpVersion,omitempty"`
	// The information about the next hops.
	NextHops *DescribeRouteEntryListResponseBodyRouteEntrysRouteEntryNextHops `json:"NextHops,omitempty" xml:"NextHops,omitempty" type:"Struct"`
	// The ID of the route.
	RouteEntryId *string `json:"RouteEntryId,omitempty" xml:"RouteEntryId,omitempty"`
	// The name of the route.
	RouteEntryName *string `json:"RouteEntryName,omitempty" xml:"RouteEntryName,omitempty"`
	// The ID of the route table.
	RouteTableId *string `json:"RouteTableId,omitempty" xml:"RouteTableId,omitempty"`
	// Indicates whether the route is hosted. If the parameter is empty, the route is not hosted.
	//
	// If the value is set to **TR**, the route is hosted by a transit router.
	ServiceType *string `json:"ServiceType,omitempty" xml:"ServiceType,omitempty"`
	// The status of the route. Valid values:
	//
	// *   **Pending**: The route is being configured.
	// *   **Available**: The route is available.
	// *   **Modifying**: The route is being modified.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The type of the route. Valid values:
	//
	// *   **Custom**: a custom route
	// *   **System**: a system route
	// *   **BGP**: a BGP route
	// *   **CEN**: a CEN route
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s DescribeRouteEntryListResponseBodyRouteEntrysRouteEntry) String() string {
	return tea.Prettify(s)
}

func (s DescribeRouteEntryListResponseBodyRouteEntrysRouteEntry) GoString() string {
	return s.String()
}

func (s *DescribeRouteEntryListResponseBodyRouteEntrysRouteEntry) SetDescription(v string) *DescribeRouteEntryListResponseBodyRouteEntrysRouteEntry {
	s.Description = &v
	return s
}

func (s *DescribeRouteEntryListResponseBodyRouteEntrysRouteEntry) SetDestinationCidrBlock(v string) *DescribeRouteEntryListResponseBodyRouteEntrysRouteEntry {
	s.DestinationCidrBlock = &v
	return s
}

func (s *DescribeRouteEntryListResponseBodyRouteEntrysRouteEntry) SetGmtModified(v string) *DescribeRouteEntryListResponseBodyRouteEntrysRouteEntry {
	s.GmtModified = &v
	return s
}

func (s *DescribeRouteEntryListResponseBodyRouteEntrysRouteEntry) SetIpVersion(v string) *DescribeRouteEntryListResponseBodyRouteEntrysRouteEntry {
	s.IpVersion = &v
	return s
}

func (s *DescribeRouteEntryListResponseBodyRouteEntrysRouteEntry) SetNextHops(v *DescribeRouteEntryListResponseBodyRouteEntrysRouteEntryNextHops) *DescribeRouteEntryListResponseBodyRouteEntrysRouteEntry {
	s.NextHops = v
	return s
}

func (s *DescribeRouteEntryListResponseBodyRouteEntrysRouteEntry) SetRouteEntryId(v string) *DescribeRouteEntryListResponseBodyRouteEntrysRouteEntry {
	s.RouteEntryId = &v
	return s
}

func (s *DescribeRouteEntryListResponseBodyRouteEntrysRouteEntry) SetRouteEntryName(v string) *DescribeRouteEntryListResponseBodyRouteEntrysRouteEntry {
	s.RouteEntryName = &v
	return s
}

func (s *DescribeRouteEntryListResponseBodyRouteEntrysRouteEntry) SetRouteTableId(v string) *DescribeRouteEntryListResponseBodyRouteEntrysRouteEntry {
	s.RouteTableId = &v
	return s
}

func (s *DescribeRouteEntryListResponseBodyRouteEntrysRouteEntry) SetServiceType(v string) *DescribeRouteEntryListResponseBodyRouteEntrysRouteEntry {
	s.ServiceType = &v
	return s
}

func (s *DescribeRouteEntryListResponseBodyRouteEntrysRouteEntry) SetStatus(v string) *DescribeRouteEntryListResponseBodyRouteEntrysRouteEntry {
	s.Status = &v
	return s
}

func (s *DescribeRouteEntryListResponseBodyRouteEntrysRouteEntry) SetType(v string) *DescribeRouteEntryListResponseBodyRouteEntrysRouteEntry {
	s.Type = &v
	return s
}

type DescribeRouteEntryListResponseBodyRouteEntrysRouteEntryNextHops struct {
	NextHop []*DescribeRouteEntryListResponseBodyRouteEntrysRouteEntryNextHopsNextHop `json:"NextHop,omitempty" xml:"NextHop,omitempty" type:"Repeated"`
}

func (s DescribeRouteEntryListResponseBodyRouteEntrysRouteEntryNextHops) String() string {
	return tea.Prettify(s)
}

func (s DescribeRouteEntryListResponseBodyRouteEntrysRouteEntryNextHops) GoString() string {
	return s.String()
}

func (s *DescribeRouteEntryListResponseBodyRouteEntrysRouteEntryNextHops) SetNextHop(v []*DescribeRouteEntryListResponseBodyRouteEntrysRouteEntryNextHopsNextHop) *DescribeRouteEntryListResponseBodyRouteEntrysRouteEntryNextHops {
	s.NextHop = v
	return s
}

type DescribeRouteEntryListResponseBodyRouteEntrysRouteEntryNextHopsNextHop struct {
	// Indicates whether the route is available. Valid values:
	//
	// *   **0**: unavailable
	// *   **1**: available
	//
	// >  This parameter is returned if the next hop type is set to **RouterInterface**.
	Enabled *int32 `json:"Enabled,omitempty" xml:"Enabled,omitempty"`
	// The ID of the next hop.
	NextHopId *string `json:"NextHopId,omitempty" xml:"NextHopId,omitempty"`
	// The region ID of the next hop.
	//
	// >  This parameter is returned if the next hop type is set to **RouterInterface**.
	NextHopRegionId *string `json:"NextHopRegionId,omitempty" xml:"NextHopRegionId,omitempty"`
	// The information about the next hop.
	NextHopRelatedInfo *DescribeRouteEntryListResponseBodyRouteEntrysRouteEntryNextHopsNextHopNextHopRelatedInfo `json:"NextHopRelatedInfo,omitempty" xml:"NextHopRelatedInfo,omitempty" type:"Struct"`
	// The type of the next hop. Valid values:
	//
	// *   **Instance**: an ECS instance
	// *   **HaVip**: an HAVIP
	// *   **VpnGateway**: a VPN gateway
	// *   **NatGateway**: a NAT gateway
	// *   **NetworkInterface**: a secondary ENI
	// *   **RouterInterface**: a router interface
	// *   **IPv6Gateway**: an IPv6 gateway
	// *   **Attachment**: a transit router
	NextHopType *string `json:"NextHopType,omitempty" xml:"NextHopType,omitempty"`
	// The weight of the route.
	//
	// >  This parameter is returned if the next hop type is set to **RouterInterface**.
	Weight *int32 `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s DescribeRouteEntryListResponseBodyRouteEntrysRouteEntryNextHopsNextHop) String() string {
	return tea.Prettify(s)
}

func (s DescribeRouteEntryListResponseBodyRouteEntrysRouteEntryNextHopsNextHop) GoString() string {
	return s.String()
}

func (s *DescribeRouteEntryListResponseBodyRouteEntrysRouteEntryNextHopsNextHop) SetEnabled(v int32) *DescribeRouteEntryListResponseBodyRouteEntrysRouteEntryNextHopsNextHop {
	s.Enabled = &v
	return s
}

func (s *DescribeRouteEntryListResponseBodyRouteEntrysRouteEntryNextHopsNextHop) SetNextHopId(v string) *DescribeRouteEntryListResponseBodyRouteEntrysRouteEntryNextHopsNextHop {
	s.NextHopId = &v
	return s
}

func (s *DescribeRouteEntryListResponseBodyRouteEntrysRouteEntryNextHopsNextHop) SetNextHopRegionId(v string) *DescribeRouteEntryListResponseBodyRouteEntrysRouteEntryNextHopsNextHop {
	s.NextHopRegionId = &v
	return s
}

func (s *DescribeRouteEntryListResponseBodyRouteEntrysRouteEntryNextHopsNextHop) SetNextHopRelatedInfo(v *DescribeRouteEntryListResponseBodyRouteEntrysRouteEntryNextHopsNextHopNextHopRelatedInfo) *DescribeRouteEntryListResponseBodyRouteEntrysRouteEntryNextHopsNextHop {
	s.NextHopRelatedInfo = v
	return s
}

func (s *DescribeRouteEntryListResponseBodyRouteEntrysRouteEntryNextHopsNextHop) SetNextHopType(v string) *DescribeRouteEntryListResponseBodyRouteEntrysRouteEntryNextHopsNextHop {
	s.NextHopType = &v
	return s
}

func (s *DescribeRouteEntryListResponseBodyRouteEntrysRouteEntryNextHopsNextHop) SetWeight(v int32) *DescribeRouteEntryListResponseBodyRouteEntrysRouteEntryNextHopsNextHop {
	s.Weight = &v
	return s
}

type DescribeRouteEntryListResponseBodyRouteEntrysRouteEntryNextHopsNextHopNextHopRelatedInfo struct {
	// The ID of the instance associated with the next hop.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The type of the instance associated with the next hop. Valid values:
	//
	// *   **VPC**: a virtual private cloud (VPC)
	// *   **VBR**: a VBR
	// *   **PCONN**: an Express Connect circuit
	InstanceType *string `json:"InstanceType,omitempty" xml:"InstanceType,omitempty"`
	// The region ID of the instance associated with the next hop.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DescribeRouteEntryListResponseBodyRouteEntrysRouteEntryNextHopsNextHopNextHopRelatedInfo) String() string {
	return tea.Prettify(s)
}

func (s DescribeRouteEntryListResponseBodyRouteEntrysRouteEntryNextHopsNextHopNextHopRelatedInfo) GoString() string {
	return s.String()
}

func (s *DescribeRouteEntryListResponseBodyRouteEntrysRouteEntryNextHopsNextHopNextHopRelatedInfo) SetInstanceId(v string) *DescribeRouteEntryListResponseBodyRouteEntrysRouteEntryNextHopsNextHopNextHopRelatedInfo {
	s.InstanceId = &v
	return s
}

func (s *DescribeRouteEntryListResponseBodyRouteEntrysRouteEntryNextHopsNextHopNextHopRelatedInfo) SetInstanceType(v string) *DescribeRouteEntryListResponseBodyRouteEntrysRouteEntryNextHopsNextHopNextHopRelatedInfo {
	s.InstanceType = &v
	return s
}

func (s *DescribeRouteEntryListResponseBodyRouteEntrysRouteEntryNextHopsNextHopNextHopRelatedInfo) SetRegionId(v string) *DescribeRouteEntryListResponseBodyRouteEntrysRouteEntryNextHopsNextHopNextHopRelatedInfo {
	s.RegionId = &v
	return s
}

type DescribeRouteEntryListResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeRouteEntryListResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeRouteEntryListResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeRouteEntryListResponse) GoString() string {
	return s.String()
}

func (s *DescribeRouteEntryListResponse) SetHeaders(v map[string]*string) *DescribeRouteEntryListResponse {
	s.Headers = v
	return s
}

func (s *DescribeRouteEntryListResponse) SetStatusCode(v int32) *DescribeRouteEntryListResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeRouteEntryListResponse) SetBody(v *DescribeRouteEntryListResponseBody) *DescribeRouteEntryListResponse {
	s.Body = v
	return s
}

type DescribeRouteTableListRequest struct {
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of the page to return. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Maximum value: **50**. Default value: **10**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The region ID of the VPC to which the route table belongs.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group to which the route table to be queried belongs.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the route table that you want to query.
	RouteTableId *string `json:"RouteTableId,omitempty" xml:"RouteTableId,omitempty"`
	// The name of the route table that you want to query.
	RouteTableName *string `json:"RouteTableName,omitempty" xml:"RouteTableName,omitempty"`
	// The ID of the router to which the route table belongs.
	RouterId *string `json:"RouterId,omitempty" xml:"RouterId,omitempty"`
	// The type of the router to which the route table belongs. Valid values:
	//
	// *   **VRouter** (default): a vRouter
	// *   **VBR**: a virtual border router (VBR)
	RouterType *string                             `json:"RouterType,omitempty" xml:"RouterType,omitempty"`
	Tag        []*DescribeRouteTableListRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
	// The ID of the virtual private cloud (VPC) to which the route table belongs.
	//
	// After this parameter is set, the value of the **RouterType** parameter is automatically set to **VRouter**.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s DescribeRouteTableListRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeRouteTableListRequest) GoString() string {
	return s.String()
}

func (s *DescribeRouteTableListRequest) SetOwnerAccount(v string) *DescribeRouteTableListRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeRouteTableListRequest) SetOwnerId(v int64) *DescribeRouteTableListRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeRouteTableListRequest) SetPageNumber(v int32) *DescribeRouteTableListRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeRouteTableListRequest) SetPageSize(v int32) *DescribeRouteTableListRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeRouteTableListRequest) SetRegionId(v string) *DescribeRouteTableListRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeRouteTableListRequest) SetResourceGroupId(v string) *DescribeRouteTableListRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeRouteTableListRequest) SetResourceOwnerAccount(v string) *DescribeRouteTableListRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeRouteTableListRequest) SetResourceOwnerId(v int64) *DescribeRouteTableListRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeRouteTableListRequest) SetRouteTableId(v string) *DescribeRouteTableListRequest {
	s.RouteTableId = &v
	return s
}

func (s *DescribeRouteTableListRequest) SetRouteTableName(v string) *DescribeRouteTableListRequest {
	s.RouteTableName = &v
	return s
}

func (s *DescribeRouteTableListRequest) SetRouterId(v string) *DescribeRouteTableListRequest {
	s.RouterId = &v
	return s
}

func (s *DescribeRouteTableListRequest) SetRouterType(v string) *DescribeRouteTableListRequest {
	s.RouterType = &v
	return s
}

func (s *DescribeRouteTableListRequest) SetTag(v []*DescribeRouteTableListRequestTag) *DescribeRouteTableListRequest {
	s.Tag = v
	return s
}

func (s *DescribeRouteTableListRequest) SetVpcId(v string) *DescribeRouteTableListRequest {
	s.VpcId = &v
	return s
}

type DescribeRouteTableListRequestTag struct {
}

func (s DescribeRouteTableListRequestTag) String() string {
	return tea.Prettify(s)
}

func (s DescribeRouteTableListRequestTag) GoString() string {
	return s.String()
}

type DescribeRouteTableListResponseBody struct {
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The detailed information about the route tables.
	RouterTableList *DescribeRouteTableListResponseBodyRouterTableList `json:"RouterTableList,omitempty" xml:"RouterTableList,omitempty" type:"Struct"`
	// The number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeRouteTableListResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeRouteTableListResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeRouteTableListResponseBody) SetPageNumber(v int32) *DescribeRouteTableListResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeRouteTableListResponseBody) SetPageSize(v int32) *DescribeRouteTableListResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeRouteTableListResponseBody) SetRequestId(v string) *DescribeRouteTableListResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeRouteTableListResponseBody) SetRouterTableList(v *DescribeRouteTableListResponseBodyRouterTableList) *DescribeRouteTableListResponseBody {
	s.RouterTableList = v
	return s
}

func (s *DescribeRouteTableListResponseBody) SetTotalCount(v int32) *DescribeRouteTableListResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeRouteTableListResponseBodyRouterTableList struct {
	RouterTableListType []*DescribeRouteTableListResponseBodyRouterTableListRouterTableListType `json:"RouterTableListType,omitempty" xml:"RouterTableListType,omitempty" type:"Repeated"`
}

func (s DescribeRouteTableListResponseBodyRouterTableList) String() string {
	return tea.Prettify(s)
}

func (s DescribeRouteTableListResponseBodyRouterTableList) GoString() string {
	return s.String()
}

func (s *DescribeRouteTableListResponseBodyRouterTableList) SetRouterTableListType(v []*DescribeRouteTableListResponseBodyRouterTableListRouterTableListType) *DescribeRouteTableListResponseBodyRouterTableList {
	s.RouterTableListType = v
	return s
}

type DescribeRouteTableListResponseBodyRouterTableListRouterTableListType struct {
	// The type of the cloud resource with which the route table is associated. Valid values:
	//
	// *   **VSwitch**: a vSwitch
	// *   **Gateway**: an IPv4 gateway
	AssociateType *string `json:"AssociateType,omitempty" xml:"AssociateType,omitempty"`
	// The time when the route table was created.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The description of the route table.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The detailed information about the IPv4 gateway.
	GatewayIds *DescribeRouteTableListResponseBodyRouterTableListRouterTableListTypeGatewayIds `json:"GatewayIds,omitempty" xml:"GatewayIds,omitempty" type:"Struct"`
	// The ID of the Alibaba Cloud account to which the route table belongs.
	OwnerId *int64 `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the resource group to which the route table belongs.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The ID of the route table.
	RouteTableId *string `json:"RouteTableId,omitempty" xml:"RouteTableId,omitempty"`
	// The name of the route table.
	RouteTableName *string `json:"RouteTableName,omitempty" xml:"RouteTableName,omitempty"`
	// The type of the route table. Valid values:
	//
	// *   **Custom**: a custom route table
	// *   **System**: a system route table
	RouteTableType *string `json:"RouteTableType,omitempty" xml:"RouteTableType,omitempty"`
	// The ID of the router to which the route table belongs.
	RouterId *string `json:"RouterId,omitempty" xml:"RouterId,omitempty"`
	// The type of the router to which the route table belongs. Valid values:
	//
	// *   **VRouter**: a vRouter
	// *   **VBR**: a VBR
	RouterType *string `json:"RouterType,omitempty" xml:"RouterType,omitempty"`
	// The status of the route table. Valid values:
	//
	// *   **Pending**: being created
	// *   **Available**: available
	// *   **Deleting**: being deleted
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The tag added to the route table.
	Tags *DescribeRouteTableListResponseBodyRouterTableListRouterTableListTypeTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Struct"`
	// The ID of the vSwitch.
	VSwitchIds *DescribeRouteTableListResponseBodyRouterTableListRouterTableListTypeVSwitchIds `json:"VSwitchIds,omitempty" xml:"VSwitchIds,omitempty" type:"Struct"`
	// The ID of the VPC to which the route table belongs.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s DescribeRouteTableListResponseBodyRouterTableListRouterTableListType) String() string {
	return tea.Prettify(s)
}

func (s DescribeRouteTableListResponseBodyRouterTableListRouterTableListType) GoString() string {
	return s.String()
}

func (s *DescribeRouteTableListResponseBodyRouterTableListRouterTableListType) SetAssociateType(v string) *DescribeRouteTableListResponseBodyRouterTableListRouterTableListType {
	s.AssociateType = &v
	return s
}

func (s *DescribeRouteTableListResponseBodyRouterTableListRouterTableListType) SetCreationTime(v string) *DescribeRouteTableListResponseBodyRouterTableListRouterTableListType {
	s.CreationTime = &v
	return s
}

func (s *DescribeRouteTableListResponseBodyRouterTableListRouterTableListType) SetDescription(v string) *DescribeRouteTableListResponseBodyRouterTableListRouterTableListType {
	s.Description = &v
	return s
}

func (s *DescribeRouteTableListResponseBodyRouterTableListRouterTableListType) SetGatewayIds(v *DescribeRouteTableListResponseBodyRouterTableListRouterTableListTypeGatewayIds) *DescribeRouteTableListResponseBodyRouterTableListRouterTableListType {
	s.GatewayIds = v
	return s
}

func (s *DescribeRouteTableListResponseBodyRouterTableListRouterTableListType) SetOwnerId(v int64) *DescribeRouteTableListResponseBodyRouterTableListRouterTableListType {
	s.OwnerId = &v
	return s
}

func (s *DescribeRouteTableListResponseBodyRouterTableListRouterTableListType) SetResourceGroupId(v string) *DescribeRouteTableListResponseBodyRouterTableListRouterTableListType {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeRouteTableListResponseBodyRouterTableListRouterTableListType) SetRouteTableId(v string) *DescribeRouteTableListResponseBodyRouterTableListRouterTableListType {
	s.RouteTableId = &v
	return s
}

func (s *DescribeRouteTableListResponseBodyRouterTableListRouterTableListType) SetRouteTableName(v string) *DescribeRouteTableListResponseBodyRouterTableListRouterTableListType {
	s.RouteTableName = &v
	return s
}

func (s *DescribeRouteTableListResponseBodyRouterTableListRouterTableListType) SetRouteTableType(v string) *DescribeRouteTableListResponseBodyRouterTableListRouterTableListType {
	s.RouteTableType = &v
	return s
}

func (s *DescribeRouteTableListResponseBodyRouterTableListRouterTableListType) SetRouterId(v string) *DescribeRouteTableListResponseBodyRouterTableListRouterTableListType {
	s.RouterId = &v
	return s
}

func (s *DescribeRouteTableListResponseBodyRouterTableListRouterTableListType) SetRouterType(v string) *DescribeRouteTableListResponseBodyRouterTableListRouterTableListType {
	s.RouterType = &v
	return s
}

func (s *DescribeRouteTableListResponseBodyRouterTableListRouterTableListType) SetStatus(v string) *DescribeRouteTableListResponseBodyRouterTableListRouterTableListType {
	s.Status = &v
	return s
}

func (s *DescribeRouteTableListResponseBodyRouterTableListRouterTableListType) SetTags(v *DescribeRouteTableListResponseBodyRouterTableListRouterTableListTypeTags) *DescribeRouteTableListResponseBodyRouterTableListRouterTableListType {
	s.Tags = v
	return s
}

func (s *DescribeRouteTableListResponseBodyRouterTableListRouterTableListType) SetVSwitchIds(v *DescribeRouteTableListResponseBodyRouterTableListRouterTableListTypeVSwitchIds) *DescribeRouteTableListResponseBodyRouterTableListRouterTableListType {
	s.VSwitchIds = v
	return s
}

func (s *DescribeRouteTableListResponseBodyRouterTableListRouterTableListType) SetVpcId(v string) *DescribeRouteTableListResponseBodyRouterTableListRouterTableListType {
	s.VpcId = &v
	return s
}

type DescribeRouteTableListResponseBodyRouterTableListRouterTableListTypeGatewayIds struct {
	GatewayIds []*string `json:"GatewayIds,omitempty" xml:"GatewayIds,omitempty" type:"Repeated"`
}

func (s DescribeRouteTableListResponseBodyRouterTableListRouterTableListTypeGatewayIds) String() string {
	return tea.Prettify(s)
}

func (s DescribeRouteTableListResponseBodyRouterTableListRouterTableListTypeGatewayIds) GoString() string {
	return s.String()
}

func (s *DescribeRouteTableListResponseBodyRouterTableListRouterTableListTypeGatewayIds) SetGatewayIds(v []*string) *DescribeRouteTableListResponseBodyRouterTableListRouterTableListTypeGatewayIds {
	s.GatewayIds = v
	return s
}

type DescribeRouteTableListResponseBodyRouterTableListRouterTableListTypeTags struct {
	Tag []*DescribeRouteTableListResponseBodyRouterTableListRouterTableListTypeTagsTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s DescribeRouteTableListResponseBodyRouterTableListRouterTableListTypeTags) String() string {
	return tea.Prettify(s)
}

func (s DescribeRouteTableListResponseBodyRouterTableListRouterTableListTypeTags) GoString() string {
	return s.String()
}

func (s *DescribeRouteTableListResponseBodyRouterTableListRouterTableListTypeTags) SetTag(v []*DescribeRouteTableListResponseBodyRouterTableListRouterTableListTypeTagsTag) *DescribeRouteTableListResponseBodyRouterTableListRouterTableListTypeTags {
	s.Tag = v
	return s
}

type DescribeRouteTableListResponseBodyRouterTableListRouterTableListTypeTagsTag struct {
	// The key of the tag that is added to the route table.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The value of the tag that is added to the route table.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeRouteTableListResponseBodyRouterTableListRouterTableListTypeTagsTag) String() string {
	return tea.Prettify(s)
}

func (s DescribeRouteTableListResponseBodyRouterTableListRouterTableListTypeTagsTag) GoString() string {
	return s.String()
}

func (s *DescribeRouteTableListResponseBodyRouterTableListRouterTableListTypeTagsTag) SetKey(v string) *DescribeRouteTableListResponseBodyRouterTableListRouterTableListTypeTagsTag {
	s.Key = &v
	return s
}

func (s *DescribeRouteTableListResponseBodyRouterTableListRouterTableListTypeTagsTag) SetValue(v string) *DescribeRouteTableListResponseBodyRouterTableListRouterTableListTypeTagsTag {
	s.Value = &v
	return s
}

type DescribeRouteTableListResponseBodyRouterTableListRouterTableListTypeVSwitchIds struct {
	VSwitchId []*string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty" type:"Repeated"`
}

func (s DescribeRouteTableListResponseBodyRouterTableListRouterTableListTypeVSwitchIds) String() string {
	return tea.Prettify(s)
}

func (s DescribeRouteTableListResponseBodyRouterTableListRouterTableListTypeVSwitchIds) GoString() string {
	return s.String()
}

func (s *DescribeRouteTableListResponseBodyRouterTableListRouterTableListTypeVSwitchIds) SetVSwitchId(v []*string) *DescribeRouteTableListResponseBodyRouterTableListRouterTableListTypeVSwitchIds {
	s.VSwitchId = v
	return s
}

type DescribeRouteTableListResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeRouteTableListResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeRouteTableListResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeRouteTableListResponse) GoString() string {
	return s.String()
}

func (s *DescribeRouteTableListResponse) SetHeaders(v map[string]*string) *DescribeRouteTableListResponse {
	s.Headers = v
	return s
}

func (s *DescribeRouteTableListResponse) SetStatusCode(v int32) *DescribeRouteTableListResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeRouteTableListResponse) SetBody(v *DescribeRouteTableListResponseBody) *DescribeRouteTableListResponse {
	s.Body = v
	return s
}

type DescribeRouteTablesRequest struct {
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of the page to return. Default value: **1**
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Maximum value: **50**. Default value: **10**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The region ID of the virtual private cloud (VPC) to which the route table belongs.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group to which the route table belongs.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the route table that you want to query.
	RouteTableId *string `json:"RouteTableId,omitempty" xml:"RouteTableId,omitempty"`
	// The name of the route table that you want to query.
	RouteTableName *string `json:"RouteTableName,omitempty" xml:"RouteTableName,omitempty"`
	// The ID of the vRouter or VBR to which the route table belongs.
	RouterId *string `json:"RouterId,omitempty" xml:"RouterId,omitempty"`
	// The type of the router to which the route table belongs. Valid values:
	//
	// *   **VRouter**: a vRouter
	// *   **VBR**: a virtual border router (VBR)
	RouterType *string `json:"RouterType,omitempty" xml:"RouterType,omitempty"`
	// The type of route table that you want to query. Valid values:
	//
	// *   **System** : a system route table
	// *   **Custom**: a custom route table
	// *   **BGP**: a Border Gateway Protocol (BGP) route table
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The ID of the vRouter to which the route table belongs.
	//
	// After you set this parameter, **RouterType** is automatically set to **VRouter**.
	VRouterId *string `json:"VRouterId,omitempty" xml:"VRouterId,omitempty"`
}

func (s DescribeRouteTablesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeRouteTablesRequest) GoString() string {
	return s.String()
}

func (s *DescribeRouteTablesRequest) SetOwnerAccount(v string) *DescribeRouteTablesRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeRouteTablesRequest) SetOwnerId(v int64) *DescribeRouteTablesRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeRouteTablesRequest) SetPageNumber(v int32) *DescribeRouteTablesRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeRouteTablesRequest) SetPageSize(v int32) *DescribeRouteTablesRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeRouteTablesRequest) SetRegionId(v string) *DescribeRouteTablesRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeRouteTablesRequest) SetResourceGroupId(v string) *DescribeRouteTablesRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeRouteTablesRequest) SetResourceOwnerAccount(v string) *DescribeRouteTablesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeRouteTablesRequest) SetResourceOwnerId(v int64) *DescribeRouteTablesRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeRouteTablesRequest) SetRouteTableId(v string) *DescribeRouteTablesRequest {
	s.RouteTableId = &v
	return s
}

func (s *DescribeRouteTablesRequest) SetRouteTableName(v string) *DescribeRouteTablesRequest {
	s.RouteTableName = &v
	return s
}

func (s *DescribeRouteTablesRequest) SetRouterId(v string) *DescribeRouteTablesRequest {
	s.RouterId = &v
	return s
}

func (s *DescribeRouteTablesRequest) SetRouterType(v string) *DescribeRouteTablesRequest {
	s.RouterType = &v
	return s
}

func (s *DescribeRouteTablesRequest) SetType(v string) *DescribeRouteTablesRequest {
	s.Type = &v
	return s
}

func (s *DescribeRouteTablesRequest) SetVRouterId(v string) *DescribeRouteTablesRequest {
	s.VRouterId = &v
	return s
}

type DescribeRouteTablesResponseBody struct {
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Details about the route table.
	RouteTables *DescribeRouteTablesResponseBodyRouteTables `json:"RouteTables,omitempty" xml:"RouteTables,omitempty" type:"Struct"`
	TotalCount  *int32                                      `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeRouteTablesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeRouteTablesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeRouteTablesResponseBody) SetPageNumber(v int32) *DescribeRouteTablesResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeRouteTablesResponseBody) SetPageSize(v int32) *DescribeRouteTablesResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeRouteTablesResponseBody) SetRequestId(v string) *DescribeRouteTablesResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeRouteTablesResponseBody) SetRouteTables(v *DescribeRouteTablesResponseBodyRouteTables) *DescribeRouteTablesResponseBody {
	s.RouteTables = v
	return s
}

func (s *DescribeRouteTablesResponseBody) SetTotalCount(v int32) *DescribeRouteTablesResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeRouteTablesResponseBodyRouteTables struct {
	RouteTable []*DescribeRouteTablesResponseBodyRouteTablesRouteTable `json:"RouteTable,omitempty" xml:"RouteTable,omitempty" type:"Repeated"`
}

func (s DescribeRouteTablesResponseBodyRouteTables) String() string {
	return tea.Prettify(s)
}

func (s DescribeRouteTablesResponseBodyRouteTables) GoString() string {
	return s.String()
}

func (s *DescribeRouteTablesResponseBodyRouteTables) SetRouteTable(v []*DescribeRouteTablesResponseBodyRouteTablesRouteTable) *DescribeRouteTablesResponseBodyRouteTables {
	s.RouteTable = v
	return s
}

type DescribeRouteTablesResponseBodyRouteTablesRouteTable struct {
	// The time when the route table was created.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The ID of the resource group to which the elastic IP address (EIP) belongs.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// Detailed information about the route entry.
	RouteEntrys *DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrys `json:"RouteEntrys,omitempty" xml:"RouteEntrys,omitempty" type:"Struct"`
	// The ID of the route table to which the route entry belongs.
	RouteTableId   *string `json:"RouteTableId,omitempty" xml:"RouteTableId,omitempty"`
	RouteTableType *string `json:"RouteTableType,omitempty" xml:"RouteTableType,omitempty"`
	// The state of the route table.
	//
	// *   **Pending**: The route table is being configured.
	// *   **Available**: The route table is available.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The ID of the vRouter.
	VRouterId *string `json:"VRouterId,omitempty" xml:"VRouterId,omitempty"`
	// The list of vSwitches that belong to the VPC.
	VSwitchIds *DescribeRouteTablesResponseBodyRouteTablesRouteTableVSwitchIds `json:"VSwitchIds,omitempty" xml:"VSwitchIds,omitempty" type:"Struct"`
}

func (s DescribeRouteTablesResponseBodyRouteTablesRouteTable) String() string {
	return tea.Prettify(s)
}

func (s DescribeRouteTablesResponseBodyRouteTablesRouteTable) GoString() string {
	return s.String()
}

func (s *DescribeRouteTablesResponseBodyRouteTablesRouteTable) SetCreationTime(v string) *DescribeRouteTablesResponseBodyRouteTablesRouteTable {
	s.CreationTime = &v
	return s
}

func (s *DescribeRouteTablesResponseBodyRouteTablesRouteTable) SetResourceGroupId(v string) *DescribeRouteTablesResponseBodyRouteTablesRouteTable {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeRouteTablesResponseBodyRouteTablesRouteTable) SetRouteEntrys(v *DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrys) *DescribeRouteTablesResponseBodyRouteTablesRouteTable {
	s.RouteEntrys = v
	return s
}

func (s *DescribeRouteTablesResponseBodyRouteTablesRouteTable) SetRouteTableId(v string) *DescribeRouteTablesResponseBodyRouteTablesRouteTable {
	s.RouteTableId = &v
	return s
}

func (s *DescribeRouteTablesResponseBodyRouteTablesRouteTable) SetRouteTableType(v string) *DescribeRouteTablesResponseBodyRouteTablesRouteTable {
	s.RouteTableType = &v
	return s
}

func (s *DescribeRouteTablesResponseBodyRouteTablesRouteTable) SetStatus(v string) *DescribeRouteTablesResponseBodyRouteTablesRouteTable {
	s.Status = &v
	return s
}

func (s *DescribeRouteTablesResponseBodyRouteTablesRouteTable) SetVRouterId(v string) *DescribeRouteTablesResponseBodyRouteTablesRouteTable {
	s.VRouterId = &v
	return s
}

func (s *DescribeRouteTablesResponseBodyRouteTablesRouteTable) SetVSwitchIds(v *DescribeRouteTablesResponseBodyRouteTablesRouteTableVSwitchIds) *DescribeRouteTablesResponseBodyRouteTablesRouteTable {
	s.VSwitchIds = v
	return s
}

type DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrys struct {
	RouteEntry []*DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntry `json:"RouteEntry,omitempty" xml:"RouteEntry,omitempty" type:"Repeated"`
}

func (s DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrys) String() string {
	return tea.Prettify(s)
}

func (s DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrys) GoString() string {
	return s.String()
}

func (s *DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrys) SetRouteEntry(v []*DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntry) *DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrys {
	s.RouteEntry = v
	return s
}

type DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntry struct {
	// The description of the router entry.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The destination CIDR block of the route entry.
	DestinationCidrBlock *string `json:"DestinationCidrBlock,omitempty" xml:"DestinationCidrBlock,omitempty"`
	// The ID of the next hop.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The type of the route.
	//
	// *   **local**: a vSwitch route
	// *   **service**: a cloud service route
	// *   **classicLink**: a route added by the system after ClassicLink is enabled
	NextHopType *string `json:"NextHopType,omitempty" xml:"NextHopType,omitempty"`
	// The list of next hops of equal-cost multi-path routing (ECMP) routes.
	NextHops     *DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntryNextHops `json:"NextHops,omitempty" xml:"NextHops,omitempty" type:"Struct"`
	RouteEntryId *string                                                                            `json:"RouteEntryId,omitempty" xml:"RouteEntryId,omitempty"`
	// The name of the route entry.
	RouteEntryName *string `json:"RouteEntryName,omitempty" xml:"RouteEntryName,omitempty"`
	// The ID of the route table to which the route entry belongs.
	RouteTableId *string `json:"RouteTableId,omitempty" xml:"RouteTableId,omitempty"`
	// The state of the route entry.
	//
	// *   **Pending**: The route entry is being configured.
	// *   **Available**: The route entry is available.
	// *   **Modifying**: The route entry is being modified.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The type of the route entry.
	//
	// *   **System** : a system route entry
	// *   **Custom**: a custom route entry
	// *   **BGP**: a BGP route entry
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntry) String() string {
	return tea.Prettify(s)
}

func (s DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntry) GoString() string {
	return s.String()
}

func (s *DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntry) SetDescription(v string) *DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntry {
	s.Description = &v
	return s
}

func (s *DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntry) SetDestinationCidrBlock(v string) *DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntry {
	s.DestinationCidrBlock = &v
	return s
}

func (s *DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntry) SetInstanceId(v string) *DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntry {
	s.InstanceId = &v
	return s
}

func (s *DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntry) SetNextHopType(v string) *DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntry {
	s.NextHopType = &v
	return s
}

func (s *DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntry) SetNextHops(v *DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntryNextHops) *DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntry {
	s.NextHops = v
	return s
}

func (s *DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntry) SetRouteEntryId(v string) *DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntry {
	s.RouteEntryId = &v
	return s
}

func (s *DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntry) SetRouteEntryName(v string) *DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntry {
	s.RouteEntryName = &v
	return s
}

func (s *DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntry) SetRouteTableId(v string) *DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntry {
	s.RouteTableId = &v
	return s
}

func (s *DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntry) SetStatus(v string) *DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntry {
	s.Status = &v
	return s
}

func (s *DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntry) SetType(v string) *DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntry {
	s.Type = &v
	return s
}

type DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntryNextHops struct {
	NextHop []*DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntryNextHopsNextHop `json:"NextHop,omitempty" xml:"NextHop,omitempty" type:"Repeated"`
}

func (s DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntryNextHops) String() string {
	return tea.Prettify(s)
}

func (s DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntryNextHops) GoString() string {
	return s.String()
}

func (s *DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntryNextHops) SetNextHop(v []*DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntryNextHopsNextHop) *DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntryNextHops {
	s.NextHop = v
	return s
}

type DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntryNextHopsNextHop struct {
	// Indicates whether the next hop feature is enabled.
	//
	// *   **0**: The next hop feature is disabled.
	// *   **1**: The next hop feature is enabled.
	Enabled *int32 `json:"Enabled,omitempty" xml:"Enabled,omitempty"`
	// The ID of the next hop.
	NextHopId *string `json:"NextHopId,omitempty" xml:"NextHopId,omitempty"`
	// The type of the next hop.
	//
	// *   **Instance**: The next hop is an Elastic Compute Service (ECS) instance.
	// *   **HaVip**: The next hop is a high-availability virtual IP address (HAVIP).
	// *   **VpnGateway**: The next hop is a VPN gateway.
	// *   **NatGateway**: The next hop is a NAT gateway.
	// *   **NetworkInterface**: The next hop is a secondary elastic network interface (ENI).
	// *   **RouterInterface**: The next hop is a router interface.
	// *   **IPv6Gateway**: The next hop is an IPv6 gateway.
	NextHopType *string `json:"NextHopType,omitempty" xml:"NextHopType,omitempty"`
	// The route weight of the next hop.
	Weight *int32 `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntryNextHopsNextHop) String() string {
	return tea.Prettify(s)
}

func (s DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntryNextHopsNextHop) GoString() string {
	return s.String()
}

func (s *DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntryNextHopsNextHop) SetEnabled(v int32) *DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntryNextHopsNextHop {
	s.Enabled = &v
	return s
}

func (s *DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntryNextHopsNextHop) SetNextHopId(v string) *DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntryNextHopsNextHop {
	s.NextHopId = &v
	return s
}

func (s *DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntryNextHopsNextHop) SetNextHopType(v string) *DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntryNextHopsNextHop {
	s.NextHopType = &v
	return s
}

func (s *DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntryNextHopsNextHop) SetWeight(v int32) *DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntryNextHopsNextHop {
	s.Weight = &v
	return s
}

type DescribeRouteTablesResponseBodyRouteTablesRouteTableVSwitchIds struct {
	VSwitchId []*string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty" type:"Repeated"`
}

func (s DescribeRouteTablesResponseBodyRouteTablesRouteTableVSwitchIds) String() string {
	return tea.Prettify(s)
}

func (s DescribeRouteTablesResponseBodyRouteTablesRouteTableVSwitchIds) GoString() string {
	return s.String()
}

func (s *DescribeRouteTablesResponseBodyRouteTablesRouteTableVSwitchIds) SetVSwitchId(v []*string) *DescribeRouteTablesResponseBodyRouteTablesRouteTableVSwitchIds {
	s.VSwitchId = v
	return s
}

type DescribeRouteTablesResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeRouteTablesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeRouteTablesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeRouteTablesResponse) GoString() string {
	return s.String()
}

func (s *DescribeRouteTablesResponse) SetHeaders(v map[string]*string) *DescribeRouteTablesResponse {
	s.Headers = v
	return s
}

func (s *DescribeRouteTablesResponse) SetStatusCode(v int32) *DescribeRouteTablesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeRouteTablesResponse) SetBody(v *DescribeRouteTablesResponseBody) *DescribeRouteTablesResponse {
	s.Body = v
	return s
}

type DescribeRouterInterfaceAttributeRequest struct {
	// The ID of the router interface.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	OwnerId    *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region to which the router interface belongs.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeRouterInterfaceAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeRouterInterfaceAttributeRequest) GoString() string {
	return s.String()
}

func (s *DescribeRouterInterfaceAttributeRequest) SetInstanceId(v string) *DescribeRouterInterfaceAttributeRequest {
	s.InstanceId = &v
	return s
}

func (s *DescribeRouterInterfaceAttributeRequest) SetOwnerId(v int64) *DescribeRouterInterfaceAttributeRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeRouterInterfaceAttributeRequest) SetRegionId(v string) *DescribeRouterInterfaceAttributeRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeRouterInterfaceAttributeRequest) SetResourceOwnerAccount(v string) *DescribeRouterInterfaceAttributeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeRouterInterfaceAttributeRequest) SetResourceOwnerId(v int64) *DescribeRouterInterfaceAttributeRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeRouterInterfaceAttributeResponseBody struct {
	// The ID of the access point.
	AccessPointId *string `json:"AccessPointId,omitempty" xml:"AccessPointId,omitempty"`
	// The bandwidth of the router interface. Unit: Mbit/s.
	Bandwidth *int32 `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	// The status of the router interface. Valid values:
	//
	// *   **Normal**: normal
	// *   **FinancialLocked**: locked due to overdue payments
	// *   **SecurityLocked**: locked due to security reasons
	BusinessStatus *string `json:"BusinessStatus,omitempty" xml:"BusinessStatus,omitempty"`
	// The billing method. Valid values:
	//
	// *   **AfterPay**: pay-as-you-go
	// *   **PrePaid**: subscription
	ChargeType *string `json:"ChargeType,omitempty" xml:"ChargeType,omitempty"`
	// The HTTP status code returned.
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The time when the connection is established.
	ConnectedTime *string `json:"ConnectedTime,omitempty" xml:"ConnectedTime,omitempty"`
	// The time when the router interface was created.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// Indicates whether the connection is a cross-border connection. Valid values:
	//
	// *   **false**: no
	// *   **true**: yes
	CrossBorder *bool `json:"CrossBorder,omitempty" xml:"CrossBorder,omitempty"`
	// The description of the router interface.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The end of the time range queried.
	EndTime      *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	FastLinkMode *string `json:"FastLinkMode,omitempty" xml:"FastLinkMode,omitempty"`
	// The time when the router interface was modified.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// Indicates whether renewal data is included. Valid values:
	//
	// *   **false**: no
	// *   **true**: yes
	HasReservationData *string `json:"HasReservationData,omitempty" xml:"HasReservationData,omitempty"`
	// The rate of health checks. Unit: seconds. The value indicates the interval at which probe packets are sent during a health check.
	HcRate *int32 `json:"HcRate,omitempty" xml:"HcRate,omitempty"`
	// The health check threshold, which is the number of probe packets that are sent during a health check. Unit: packets.
	HcThreshold *int32 `json:"HcThreshold,omitempty" xml:"HcThreshold,omitempty"`
	// The source IP address that is used for health checks.
	HealthCheckSourceIp *string `json:"HealthCheckSourceIp,omitempty" xml:"HealthCheckSourceIp,omitempty"`
	// The health check status. Valid values:
	//
	// *   **Abnormal**: abnormal.
	// *   **Normal**: normal.
	// *   **NoRedundantRoute**: No redundant route is configured.
	// *   **NoHealthCheckConfig**: No health check is configured.
	HealthCheckStatus *string `json:"HealthCheckStatus,omitempty" xml:"HealthCheckStatus,omitempty"`
	// The destination IP address that is used for health checks.
	HealthCheckTargetIp *string `json:"HealthCheckTargetIp,omitempty" xml:"HealthCheckTargetIp,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The name of the router interface.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the peer access point.
	OppositeAccessPointId *string `json:"OppositeAccessPointId,omitempty" xml:"OppositeAccessPointId,omitempty"`
	// The bandwidth of the peer router interface. Unit: Mbit/s.
	OppositeBandwidth *int32 `json:"OppositeBandwidth,omitempty" xml:"OppositeBandwidth,omitempty"`
	// The service status of the peer router interface. Valid values:
	//
	// *   **Normal**: normal
	// *   **FinancialLocked**: locked due to overdue payments
	// *   **SecurityLocked**: locked due to security reasons
	OppositeInterfaceBusinessStatus *string `json:"OppositeInterfaceBusinessStatus,omitempty" xml:"OppositeInterfaceBusinessStatus,omitempty"`
	// The ID of the peer router interface.
	OppositeInterfaceId *string `json:"OppositeInterfaceId,omitempty" xml:"OppositeInterfaceId,omitempty"`
	// The ID of the Alibaba Cloud account to which the peer router interface belongs.
	OppositeInterfaceOwnerId *string `json:"OppositeInterfaceOwnerId,omitempty" xml:"OppositeInterfaceOwnerId,omitempty"`
	// The specification of the peer router interface. Valid values:
	//
	// *   **Mini.2**: 2 Mbit/s
	// *   **Mini.5**: 5 Mbit/s
	// *   **Small.1**: 10 Mbit/s
	// *   **Small.2**: 20 Mbit/s
	// *   **Small.5**: 50 Mbit/s
	// *   **Middle.1**: 100 Mbit/s
	// *   **Middle.2**: 200 Mbit/s
	// *   **Middle.5**: 500 Mbit/s
	// *   **Large.1**: 1,000 Mbit/s
	// *   **Large.2**: 2,000 Mbit/s
	// *   **Large.5**: 5,000 Mbit/s
	// *   **Xlarge.1**: 10,000 Mbit/s
	// *   **Negative**: not applicable
	OppositeInterfaceSpec *string `json:"OppositeInterfaceSpec,omitempty" xml:"OppositeInterfaceSpec,omitempty"`
	// The status of the peer router interface. Valid values:
	//
	// *   **Idle**: not connected
	// *   **AcceptingConnecting**: accepting a connection
	// *   **Connecting**: connecting
	// *   **Activating**: being activated
	// *   **Active**: activated
	// *   **Modifying**: being modified
	// *   **Deactivating**: being disabled
	// *   **Inactive**: disabled
	// *   **Deleting**: being deleted
	// *   **Deleted**: deleted
	OppositeInterfaceStatus *string `json:"OppositeInterfaceStatus,omitempty" xml:"OppositeInterfaceStatus,omitempty"`
	// The region ID of the peer router interface.
	OppositeRegionId *string `json:"OppositeRegionId,omitempty" xml:"OppositeRegionId,omitempty"`
	// The ID of the router to which the peer router interface belongs.
	OppositeRouterId *string `json:"OppositeRouterId,omitempty" xml:"OppositeRouterId,omitempty"`
	// The type of the router to which the peer router interface belongs. Valid values:
	//
	// *   **VRouter**: a vRouter
	// *   **VBR**: a virtual border router (VBR)
	OppositeRouterType *string `json:"OppositeRouterType,omitempty" xml:"OppositeRouterType,omitempty"`
	// The ID of the peer VPC.
	OppositeVpcInstanceId *string `json:"OppositeVpcInstanceId,omitempty" xml:"OppositeVpcInstanceId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The time when the renewal takes effect.
	ReservationActiveTime *string `json:"ReservationActiveTime,omitempty" xml:"ReservationActiveTime,omitempty"`
	// The bandwidth after the renewal takes effect. Unit: Mbit/s.
	ReservationBandwidth *string `json:"ReservationBandwidth,omitempty" xml:"ReservationBandwidth,omitempty"`
	// The metering method that is used after the renewal takes effect. The value is set to **PayByBandwidth**, which indicates the pay-by-bandwidth metering method.
	ReservationInternetChargeType *string `json:"ReservationInternetChargeType,omitempty" xml:"ReservationInternetChargeType,omitempty"`
	// The type of the renewal order. The value is set to **RENEW**, which indicates that the order is placed for service renewal.
	ReservationOrderType *string `json:"ReservationOrderType,omitempty" xml:"ReservationOrderType,omitempty"`
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// Indicates whether the router interface is the requester or the acceptor of the peering connection.
	Role *string `json:"Role,omitempty" xml:"Role,omitempty"`
	// The ID of the router to which the router interface belongs.
	RouterId *string `json:"RouterId,omitempty" xml:"RouterId,omitempty"`
	// The ID of the router interface.
	RouterInterfaceId *string `json:"RouterInterfaceId,omitempty" xml:"RouterInterfaceId,omitempty"`
	// The type of the router to which the route table belongs. Valid values:
	//
	// *   **VRouter**: a vRouter
	// *   **VBR**: a VBR
	RouterType *string `json:"RouterType,omitempty" xml:"RouterType,omitempty"`
	// The specification of the router interface. Valid values:
	//
	// *   **Mini.2**: 2 Mbit/s
	// *   **Mini.5**: 5 Mbit/s
	// *   **Small.1**: 10 Mbit/s
	// *   **Small.2**: 20 Mbit/s
	// *   **Small.5**: 50 Mbit/s
	// *   **Middle.1**: 100 Mbit/s
	// *   **Middle.2**: 200 Mbit/s
	// *   **Middle.5**: 500 Mbit/s
	// *   **Large.1**: 1,000 Mbit/s
	// *   **Large.2**: 2,000 Mbit/s
	// *   **Large.5**: 5,000 Mbit/s
	// *   **Xlarge.1**: 10,000 Mbit/s
	Spec *string `json:"Spec,omitempty" xml:"Spec,omitempty"`
	// The status of the router interface. Valid values:
	//
	// *   **Idle**: not connected
	// *   **AcceptingConnecting**: accepting a connection
	// *   **Connecting**: connecting
	// *   **Activating**: being activated
	// *   **Active**: activated
	// *   **Modifying**: being modified
	// *   **Deactivating**: being disabled
	// *   **Inactive**: disabled
	// *   **Deleting**: being deleted
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// Indicates whether the operation is successful.
	Success *bool                                             `json:"Success,omitempty" xml:"Success,omitempty"`
	Tags    *DescribeRouterInterfaceAttributeResponseBodyTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Struct"`
	// The ID of the virtual private cloud (VPC) to which the router interface belongs.
	VpcInstanceId *string `json:"VpcInstanceId,omitempty" xml:"VpcInstanceId,omitempty"`
}

func (s DescribeRouterInterfaceAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeRouterInterfaceAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeRouterInterfaceAttributeResponseBody) SetAccessPointId(v string) *DescribeRouterInterfaceAttributeResponseBody {
	s.AccessPointId = &v
	return s
}

func (s *DescribeRouterInterfaceAttributeResponseBody) SetBandwidth(v int32) *DescribeRouterInterfaceAttributeResponseBody {
	s.Bandwidth = &v
	return s
}

func (s *DescribeRouterInterfaceAttributeResponseBody) SetBusinessStatus(v string) *DescribeRouterInterfaceAttributeResponseBody {
	s.BusinessStatus = &v
	return s
}

func (s *DescribeRouterInterfaceAttributeResponseBody) SetChargeType(v string) *DescribeRouterInterfaceAttributeResponseBody {
	s.ChargeType = &v
	return s
}

func (s *DescribeRouterInterfaceAttributeResponseBody) SetCode(v string) *DescribeRouterInterfaceAttributeResponseBody {
	s.Code = &v
	return s
}

func (s *DescribeRouterInterfaceAttributeResponseBody) SetConnectedTime(v string) *DescribeRouterInterfaceAttributeResponseBody {
	s.ConnectedTime = &v
	return s
}

func (s *DescribeRouterInterfaceAttributeResponseBody) SetCreationTime(v string) *DescribeRouterInterfaceAttributeResponseBody {
	s.CreationTime = &v
	return s
}

func (s *DescribeRouterInterfaceAttributeResponseBody) SetCrossBorder(v bool) *DescribeRouterInterfaceAttributeResponseBody {
	s.CrossBorder = &v
	return s
}

func (s *DescribeRouterInterfaceAttributeResponseBody) SetDescription(v string) *DescribeRouterInterfaceAttributeResponseBody {
	s.Description = &v
	return s
}

func (s *DescribeRouterInterfaceAttributeResponseBody) SetEndTime(v string) *DescribeRouterInterfaceAttributeResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeRouterInterfaceAttributeResponseBody) SetFastLinkMode(v string) *DescribeRouterInterfaceAttributeResponseBody {
	s.FastLinkMode = &v
	return s
}

func (s *DescribeRouterInterfaceAttributeResponseBody) SetGmtModified(v string) *DescribeRouterInterfaceAttributeResponseBody {
	s.GmtModified = &v
	return s
}

func (s *DescribeRouterInterfaceAttributeResponseBody) SetHasReservationData(v string) *DescribeRouterInterfaceAttributeResponseBody {
	s.HasReservationData = &v
	return s
}

func (s *DescribeRouterInterfaceAttributeResponseBody) SetHcRate(v int32) *DescribeRouterInterfaceAttributeResponseBody {
	s.HcRate = &v
	return s
}

func (s *DescribeRouterInterfaceAttributeResponseBody) SetHcThreshold(v int32) *DescribeRouterInterfaceAttributeResponseBody {
	s.HcThreshold = &v
	return s
}

func (s *DescribeRouterInterfaceAttributeResponseBody) SetHealthCheckSourceIp(v string) *DescribeRouterInterfaceAttributeResponseBody {
	s.HealthCheckSourceIp = &v
	return s
}

func (s *DescribeRouterInterfaceAttributeResponseBody) SetHealthCheckStatus(v string) *DescribeRouterInterfaceAttributeResponseBody {
	s.HealthCheckStatus = &v
	return s
}

func (s *DescribeRouterInterfaceAttributeResponseBody) SetHealthCheckTargetIp(v string) *DescribeRouterInterfaceAttributeResponseBody {
	s.HealthCheckTargetIp = &v
	return s
}

func (s *DescribeRouterInterfaceAttributeResponseBody) SetMessage(v string) *DescribeRouterInterfaceAttributeResponseBody {
	s.Message = &v
	return s
}

func (s *DescribeRouterInterfaceAttributeResponseBody) SetName(v string) *DescribeRouterInterfaceAttributeResponseBody {
	s.Name = &v
	return s
}

func (s *DescribeRouterInterfaceAttributeResponseBody) SetOppositeAccessPointId(v string) *DescribeRouterInterfaceAttributeResponseBody {
	s.OppositeAccessPointId = &v
	return s
}

func (s *DescribeRouterInterfaceAttributeResponseBody) SetOppositeBandwidth(v int32) *DescribeRouterInterfaceAttributeResponseBody {
	s.OppositeBandwidth = &v
	return s
}

func (s *DescribeRouterInterfaceAttributeResponseBody) SetOppositeInterfaceBusinessStatus(v string) *DescribeRouterInterfaceAttributeResponseBody {
	s.OppositeInterfaceBusinessStatus = &v
	return s
}

func (s *DescribeRouterInterfaceAttributeResponseBody) SetOppositeInterfaceId(v string) *DescribeRouterInterfaceAttributeResponseBody {
	s.OppositeInterfaceId = &v
	return s
}

func (s *DescribeRouterInterfaceAttributeResponseBody) SetOppositeInterfaceOwnerId(v string) *DescribeRouterInterfaceAttributeResponseBody {
	s.OppositeInterfaceOwnerId = &v
	return s
}

func (s *DescribeRouterInterfaceAttributeResponseBody) SetOppositeInterfaceSpec(v string) *DescribeRouterInterfaceAttributeResponseBody {
	s.OppositeInterfaceSpec = &v
	return s
}

func (s *DescribeRouterInterfaceAttributeResponseBody) SetOppositeInterfaceStatus(v string) *DescribeRouterInterfaceAttributeResponseBody {
	s.OppositeInterfaceStatus = &v
	return s
}

func (s *DescribeRouterInterfaceAttributeResponseBody) SetOppositeRegionId(v string) *DescribeRouterInterfaceAttributeResponseBody {
	s.OppositeRegionId = &v
	return s
}

func (s *DescribeRouterInterfaceAttributeResponseBody) SetOppositeRouterId(v string) *DescribeRouterInterfaceAttributeResponseBody {
	s.OppositeRouterId = &v
	return s
}

func (s *DescribeRouterInterfaceAttributeResponseBody) SetOppositeRouterType(v string) *DescribeRouterInterfaceAttributeResponseBody {
	s.OppositeRouterType = &v
	return s
}

func (s *DescribeRouterInterfaceAttributeResponseBody) SetOppositeVpcInstanceId(v string) *DescribeRouterInterfaceAttributeResponseBody {
	s.OppositeVpcInstanceId = &v
	return s
}

func (s *DescribeRouterInterfaceAttributeResponseBody) SetRequestId(v string) *DescribeRouterInterfaceAttributeResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeRouterInterfaceAttributeResponseBody) SetReservationActiveTime(v string) *DescribeRouterInterfaceAttributeResponseBody {
	s.ReservationActiveTime = &v
	return s
}

func (s *DescribeRouterInterfaceAttributeResponseBody) SetReservationBandwidth(v string) *DescribeRouterInterfaceAttributeResponseBody {
	s.ReservationBandwidth = &v
	return s
}

func (s *DescribeRouterInterfaceAttributeResponseBody) SetReservationInternetChargeType(v string) *DescribeRouterInterfaceAttributeResponseBody {
	s.ReservationInternetChargeType = &v
	return s
}

func (s *DescribeRouterInterfaceAttributeResponseBody) SetReservationOrderType(v string) *DescribeRouterInterfaceAttributeResponseBody {
	s.ReservationOrderType = &v
	return s
}

func (s *DescribeRouterInterfaceAttributeResponseBody) SetResourceGroupId(v string) *DescribeRouterInterfaceAttributeResponseBody {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeRouterInterfaceAttributeResponseBody) SetRole(v string) *DescribeRouterInterfaceAttributeResponseBody {
	s.Role = &v
	return s
}

func (s *DescribeRouterInterfaceAttributeResponseBody) SetRouterId(v string) *DescribeRouterInterfaceAttributeResponseBody {
	s.RouterId = &v
	return s
}

func (s *DescribeRouterInterfaceAttributeResponseBody) SetRouterInterfaceId(v string) *DescribeRouterInterfaceAttributeResponseBody {
	s.RouterInterfaceId = &v
	return s
}

func (s *DescribeRouterInterfaceAttributeResponseBody) SetRouterType(v string) *DescribeRouterInterfaceAttributeResponseBody {
	s.RouterType = &v
	return s
}

func (s *DescribeRouterInterfaceAttributeResponseBody) SetSpec(v string) *DescribeRouterInterfaceAttributeResponseBody {
	s.Spec = &v
	return s
}

func (s *DescribeRouterInterfaceAttributeResponseBody) SetStatus(v string) *DescribeRouterInterfaceAttributeResponseBody {
	s.Status = &v
	return s
}

func (s *DescribeRouterInterfaceAttributeResponseBody) SetSuccess(v bool) *DescribeRouterInterfaceAttributeResponseBody {
	s.Success = &v
	return s
}

func (s *DescribeRouterInterfaceAttributeResponseBody) SetTags(v *DescribeRouterInterfaceAttributeResponseBodyTags) *DescribeRouterInterfaceAttributeResponseBody {
	s.Tags = v
	return s
}

func (s *DescribeRouterInterfaceAttributeResponseBody) SetVpcInstanceId(v string) *DescribeRouterInterfaceAttributeResponseBody {
	s.VpcInstanceId = &v
	return s
}

type DescribeRouterInterfaceAttributeResponseBodyTags struct {
	Tags []*DescribeRouterInterfaceAttributeResponseBodyTagsTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
}

func (s DescribeRouterInterfaceAttributeResponseBodyTags) String() string {
	return tea.Prettify(s)
}

func (s DescribeRouterInterfaceAttributeResponseBodyTags) GoString() string {
	return s.String()
}

func (s *DescribeRouterInterfaceAttributeResponseBodyTags) SetTags(v []*DescribeRouterInterfaceAttributeResponseBodyTagsTags) *DescribeRouterInterfaceAttributeResponseBodyTags {
	s.Tags = v
	return s
}

type DescribeRouterInterfaceAttributeResponseBodyTagsTags struct {
	Key   *string `json:"Key,omitempty" xml:"Key,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeRouterInterfaceAttributeResponseBodyTagsTags) String() string {
	return tea.Prettify(s)
}

func (s DescribeRouterInterfaceAttributeResponseBodyTagsTags) GoString() string {
	return s.String()
}

func (s *DescribeRouterInterfaceAttributeResponseBodyTagsTags) SetKey(v string) *DescribeRouterInterfaceAttributeResponseBodyTagsTags {
	s.Key = &v
	return s
}

func (s *DescribeRouterInterfaceAttributeResponseBodyTagsTags) SetValue(v string) *DescribeRouterInterfaceAttributeResponseBodyTagsTags {
	s.Value = &v
	return s
}

type DescribeRouterInterfaceAttributeResponse struct {
	Headers    map[string]*string                            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeRouterInterfaceAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeRouterInterfaceAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeRouterInterfaceAttributeResponse) GoString() string {
	return s.String()
}

func (s *DescribeRouterInterfaceAttributeResponse) SetHeaders(v map[string]*string) *DescribeRouterInterfaceAttributeResponse {
	s.Headers = v
	return s
}

func (s *DescribeRouterInterfaceAttributeResponse) SetStatusCode(v int32) *DescribeRouterInterfaceAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeRouterInterfaceAttributeResponse) SetBody(v *DescribeRouterInterfaceAttributeResponseBody) *DescribeRouterInterfaceAttributeResponse {
	s.Body = v
	return s
}

type DescribeRouterInterfacesRequest struct {
	Filter []*DescribeRouterInterfacesRequestFilter `json:"Filter,omitempty" xml:"Filter,omitempty" type:"Repeated"`
	// Specifies whether renewal data is included. Default value: false. Valid values:
	//
	// *   **true**
	// *   **false**
	IncludeReservationData *bool  `json:"IncludeReservationData,omitempty" xml:"IncludeReservationData,omitempty"`
	OwnerId                *int64 `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of the page to return. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Maximum value: **50**. Default value: **10**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The region ID of the router interface.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string                                `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceGroupId      *string                                `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string                                `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64                                 `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	Tags                 []*DescribeRouterInterfacesRequestTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
}

func (s DescribeRouterInterfacesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeRouterInterfacesRequest) GoString() string {
	return s.String()
}

func (s *DescribeRouterInterfacesRequest) SetFilter(v []*DescribeRouterInterfacesRequestFilter) *DescribeRouterInterfacesRequest {
	s.Filter = v
	return s
}

func (s *DescribeRouterInterfacesRequest) SetIncludeReservationData(v bool) *DescribeRouterInterfacesRequest {
	s.IncludeReservationData = &v
	return s
}

func (s *DescribeRouterInterfacesRequest) SetOwnerId(v int64) *DescribeRouterInterfacesRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeRouterInterfacesRequest) SetPageNumber(v int32) *DescribeRouterInterfacesRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeRouterInterfacesRequest) SetPageSize(v int32) *DescribeRouterInterfacesRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeRouterInterfacesRequest) SetRegionId(v string) *DescribeRouterInterfacesRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeRouterInterfacesRequest) SetResourceGroupId(v string) *DescribeRouterInterfacesRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeRouterInterfacesRequest) SetResourceOwnerAccount(v string) *DescribeRouterInterfacesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeRouterInterfacesRequest) SetResourceOwnerId(v int64) *DescribeRouterInterfacesRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeRouterInterfacesRequest) SetTags(v []*DescribeRouterInterfacesRequestTags) *DescribeRouterInterfacesRequest {
	s.Tags = v
	return s
}

type DescribeRouterInterfacesRequestFilter struct {
	// The filter conditions. You can specify up to five filter conditions. The following filter conditions are supported:
	//
	// *   **RouterInterfaceId**: the ID of the router interface.
	// *   **RouterId**: the ID of the router.
	// *   **RouterType**: the router type. Valid values: **VRouter** and **VBR**.
	// *   **RouterInterfaceOwnerId**: the ID of the Alibaba Cloud account to which the router interface belongs.
	// *   **OppositeInterfaceId**: the ID of the peer router interface.
	// *   **OppositeRouterType**: the type of the peer router interface. Valid values: **VRouter** and **VBR**.
	// *   **OppositeRouterId**: the ID of the peer router.
	// *   **OppositeInterfaceOwnerId**: the ID of the Alibaba Cloud account to which the peer router interface belongs.
	// *   **Status**: the status of the router interface.
	// *   **Name**: the name of the router interface.
	//
	// >  The logical operator between multiple values in the filter condition is OR. In this case, the filter condition is met if one of the values is matched. The logical operator between filter conditions is AND, which means that a result is returned only when all conditions are met.
	Key   *string   `json:"Key,omitempty" xml:"Key,omitempty"`
	Value []*string `json:"Value,omitempty" xml:"Value,omitempty" type:"Repeated"`
}

func (s DescribeRouterInterfacesRequestFilter) String() string {
	return tea.Prettify(s)
}

func (s DescribeRouterInterfacesRequestFilter) GoString() string {
	return s.String()
}

func (s *DescribeRouterInterfacesRequestFilter) SetKey(v string) *DescribeRouterInterfacesRequestFilter {
	s.Key = &v
	return s
}

func (s *DescribeRouterInterfacesRequestFilter) SetValue(v []*string) *DescribeRouterInterfacesRequestFilter {
	s.Value = v
	return s
}

type DescribeRouterInterfacesRequestTags struct {
	Key   *string `json:"Key,omitempty" xml:"Key,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeRouterInterfacesRequestTags) String() string {
	return tea.Prettify(s)
}

func (s DescribeRouterInterfacesRequestTags) GoString() string {
	return s.String()
}

func (s *DescribeRouterInterfacesRequestTags) SetKey(v string) *DescribeRouterInterfacesRequestTags {
	s.Key = &v
	return s
}

func (s *DescribeRouterInterfacesRequestTags) SetValue(v string) *DescribeRouterInterfacesRequestTags {
	s.Value = &v
	return s
}

type DescribeRouterInterfacesResponseBody struct {
	// The number of the returned page. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page. Maximum value: **50**. Default value: **10**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The details of the router interface.
	RouterInterfaceSet *DescribeRouterInterfacesResponseBodyRouterInterfaceSet `json:"RouterInterfaceSet,omitempty" xml:"RouterInterfaceSet,omitempty" type:"Struct"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeRouterInterfacesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeRouterInterfacesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeRouterInterfacesResponseBody) SetPageNumber(v int32) *DescribeRouterInterfacesResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeRouterInterfacesResponseBody) SetPageSize(v int32) *DescribeRouterInterfacesResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeRouterInterfacesResponseBody) SetRequestId(v string) *DescribeRouterInterfacesResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeRouterInterfacesResponseBody) SetRouterInterfaceSet(v *DescribeRouterInterfacesResponseBodyRouterInterfaceSet) *DescribeRouterInterfacesResponseBody {
	s.RouterInterfaceSet = v
	return s
}

func (s *DescribeRouterInterfacesResponseBody) SetTotalCount(v int32) *DescribeRouterInterfacesResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeRouterInterfacesResponseBodyRouterInterfaceSet struct {
	RouterInterfaceType []*DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType `json:"RouterInterfaceType,omitempty" xml:"RouterInterfaceType,omitempty" type:"Repeated"`
}

func (s DescribeRouterInterfacesResponseBodyRouterInterfaceSet) String() string {
	return tea.Prettify(s)
}

func (s DescribeRouterInterfacesResponseBodyRouterInterfaceSet) GoString() string {
	return s.String()
}

func (s *DescribeRouterInterfacesResponseBodyRouterInterfaceSet) SetRouterInterfaceType(v []*DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType) *DescribeRouterInterfacesResponseBodyRouterInterfaceSet {
	s.RouterInterfaceType = v
	return s
}

type DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType struct {
	// The ID of the access point.
	AccessPointId *string `json:"AccessPointId,omitempty" xml:"AccessPointId,omitempty"`
	// The bandwidth of the router interface. Unit: Mbit/s.
	Bandwidth *int32 `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	// The service status of the router interface. Valid values:
	//
	// *   **Normal**: normal
	// *   **FinancialLocked**: locked due to overdue payments
	// *   **SecurityLocked**: locked due to security reasons
	BusinessStatus *string `json:"BusinessStatus,omitempty" xml:"BusinessStatus,omitempty"`
	// The metering method.
	ChargeType *string `json:"ChargeType,omitempty" xml:"ChargeType,omitempty"`
	// The time when the connection was established.
	//
	// The time follows the ISO8601 standard in the `YYYY-MM-DDThh:mmZ` format. The time is displayed in UTC.
	ConnectedTime *string `json:"ConnectedTime,omitempty" xml:"ConnectedTime,omitempty"`
	// The time when the route table was created.
	//
	// The time follows the ISO8601 standard in the `YYYY-MM-DDThh:mmZ` format. The time is displayed in UTC.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// Indicates whether the connection is a cross-border connection.
	CrossBorder *bool `json:"CrossBorder,omitempty" xml:"CrossBorder,omitempty"`
	// The description of the router interface.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The end of the time range queried.
	//
	// The time follows the ISO8601 standard in the `YYYY-MM-DDThh:mmZ` format. The time is displayed in UTC.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// Indicates whether the VBR that is created in the Fast Link mode is uplinked to the router interface. The Fast Link mode helps automatically connect router interfaces that are created for the VBR and its peer VPC. Default value: false. Valid values:
	//
	// *   **true**
	// *   **false**
	FastLinkMode *bool `json:"FastLinkMode,omitempty" xml:"FastLinkMode,omitempty"`
	// Indicates whether renewal data is included.
	HasReservationData *string `json:"HasReservationData,omitempty" xml:"HasReservationData,omitempty"`
	// The rate of the heath check.
	HcRate *int32 `json:"HcRate,omitempty" xml:"HcRate,omitempty"`
	// The health check threshold.
	HcThreshold *int32 `json:"HcThreshold,omitempty" xml:"HcThreshold,omitempty"`
	// The source IP address that is used for the health check.
	HealthCheckSourceIp *string `json:"HealthCheckSourceIp,omitempty" xml:"HealthCheckSourceIp,omitempty"`
	// The destination IP address that is used for the health check.
	HealthCheckTargetIp *string `json:"HealthCheckTargetIp,omitempty" xml:"HealthCheckTargetIp,omitempty"`
	// Indicates whether protection against malicious IPv6 traffic is enabled. Valid values:
	//
	// *   **on**
	// *   **off**
	// *   **unsupport**
	Ipv6Status *string `json:"Ipv6Status,omitempty" xml:"Ipv6Status,omitempty"`
	// The custom name.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the peer access point.
	OppositeAccessPointId *string `json:"OppositeAccessPointId,omitempty" xml:"OppositeAccessPointId,omitempty"`
	// The maximum bandwidth of the peer router interface. Unit: Mbit/s.
	OppositeBandwidth *int32 `json:"OppositeBandwidth,omitempty" xml:"OppositeBandwidth,omitempty"`
	// The service status of the peer router interface.
	OppositeInterfaceBusinessStatus *string `json:"OppositeInterfaceBusinessStatus,omitempty" xml:"OppositeInterfaceBusinessStatus,omitempty"`
	// The ID of the peer router interface.
	OppositeInterfaceId *string `json:"OppositeInterfaceId,omitempty" xml:"OppositeInterfaceId,omitempty"`
	// The ID of the Alibaba Cloud account to which the peer router interface belongs.
	OppositeInterfaceOwnerId *string `json:"OppositeInterfaceOwnerId,omitempty" xml:"OppositeInterfaceOwnerId,omitempty"`
	// The specification of the peer router interface.
	OppositeInterfaceSpec *string `json:"OppositeInterfaceSpec,omitempty" xml:"OppositeInterfaceSpec,omitempty"`
	// The status of the peer router interface.
	OppositeInterfaceStatus *string `json:"OppositeInterfaceStatus,omitempty" xml:"OppositeInterfaceStatus,omitempty"`
	// The region ID of the peer router interface.
	OppositeRegionId *string `json:"OppositeRegionId,omitempty" xml:"OppositeRegionId,omitempty"`
	// The ID of the router to which the peer router interface belongs.
	OppositeRouterId *string `json:"OppositeRouterId,omitempty" xml:"OppositeRouterId,omitempty"`
	// The type of the router to which the peer router interface belongs.
	OppositeRouterType *string `json:"OppositeRouterType,omitempty" xml:"OppositeRouterType,omitempty"`
	// The ID of the peer VPC.
	OppositeVpcInstanceId *string `json:"OppositeVpcInstanceId,omitempty" xml:"OppositeVpcInstanceId,omitempty"`
	// The time when the renewal takes effect.
	//
	// The time follows the ISO8601 standard in the `YYYY-MM-DDThh:mmZ` format. The time is displayed in UTC.
	ReservationActiveTime *string `json:"ReservationActiveTime,omitempty" xml:"ReservationActiveTime,omitempty"`
	// The bandwidth after the renewal takes effect. Unit: Mbit/s.
	ReservationBandwidth *string `json:"ReservationBandwidth,omitempty" xml:"ReservationBandwidth,omitempty"`
	// The metering method that is used after the renewal takes effect.
	ReservationInternetChargeType *string `json:"ReservationInternetChargeType,omitempty" xml:"ReservationInternetChargeType,omitempty"`
	// The type of the renewal order.
	ReservationOrderType *string `json:"ReservationOrderType,omitempty" xml:"ReservationOrderType,omitempty"`
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// Indicates whether the router interface is the initiator or acceptor of the peering connection.
	Role *string `json:"Role,omitempty" xml:"Role,omitempty"`
	// The ID of the router to which the route entry belongs.
	RouterId *string `json:"RouterId,omitempty" xml:"RouterId,omitempty"`
	// The ID of the router interface.
	RouterInterfaceId *string `json:"RouterInterfaceId,omitempty" xml:"RouterInterfaceId,omitempty"`
	// The type of the router to which the route table belongs. Valid values:
	//
	// *   **VRouter**
	// *   **VBR**
	RouterType *string `json:"RouterType,omitempty" xml:"RouterType,omitempty"`
	// The specification of the router interface.
	Spec *string `json:"Spec,omitempty" xml:"Spec,omitempty"`
	// The status of the router interface.
	Status *string                                                                        `json:"Status,omitempty" xml:"Status,omitempty"`
	Tags   *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceTypeTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Struct"`
	// The ID of the local virtual private cloud (VPC) in the peering connection.
	VpcInstanceId *string `json:"VpcInstanceId,omitempty" xml:"VpcInstanceId,omitempty"`
}

func (s DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType) String() string {
	return tea.Prettify(s)
}

func (s DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType) GoString() string {
	return s.String()
}

func (s *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType) SetAccessPointId(v string) *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType {
	s.AccessPointId = &v
	return s
}

func (s *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType) SetBandwidth(v int32) *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType {
	s.Bandwidth = &v
	return s
}

func (s *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType) SetBusinessStatus(v string) *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType {
	s.BusinessStatus = &v
	return s
}

func (s *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType) SetChargeType(v string) *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType {
	s.ChargeType = &v
	return s
}

func (s *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType) SetConnectedTime(v string) *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType {
	s.ConnectedTime = &v
	return s
}

func (s *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType) SetCreationTime(v string) *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType {
	s.CreationTime = &v
	return s
}

func (s *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType) SetCrossBorder(v bool) *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType {
	s.CrossBorder = &v
	return s
}

func (s *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType) SetDescription(v string) *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType {
	s.Description = &v
	return s
}

func (s *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType) SetEndTime(v string) *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType {
	s.EndTime = &v
	return s
}

func (s *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType) SetFastLinkMode(v bool) *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType {
	s.FastLinkMode = &v
	return s
}

func (s *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType) SetHasReservationData(v string) *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType {
	s.HasReservationData = &v
	return s
}

func (s *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType) SetHcRate(v int32) *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType {
	s.HcRate = &v
	return s
}

func (s *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType) SetHcThreshold(v int32) *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType {
	s.HcThreshold = &v
	return s
}

func (s *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType) SetHealthCheckSourceIp(v string) *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType {
	s.HealthCheckSourceIp = &v
	return s
}

func (s *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType) SetHealthCheckTargetIp(v string) *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType {
	s.HealthCheckTargetIp = &v
	return s
}

func (s *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType) SetIpv6Status(v string) *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType {
	s.Ipv6Status = &v
	return s
}

func (s *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType) SetName(v string) *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType {
	s.Name = &v
	return s
}

func (s *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType) SetOppositeAccessPointId(v string) *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType {
	s.OppositeAccessPointId = &v
	return s
}

func (s *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType) SetOppositeBandwidth(v int32) *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType {
	s.OppositeBandwidth = &v
	return s
}

func (s *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType) SetOppositeInterfaceBusinessStatus(v string) *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType {
	s.OppositeInterfaceBusinessStatus = &v
	return s
}

func (s *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType) SetOppositeInterfaceId(v string) *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType {
	s.OppositeInterfaceId = &v
	return s
}

func (s *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType) SetOppositeInterfaceOwnerId(v string) *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType {
	s.OppositeInterfaceOwnerId = &v
	return s
}

func (s *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType) SetOppositeInterfaceSpec(v string) *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType {
	s.OppositeInterfaceSpec = &v
	return s
}

func (s *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType) SetOppositeInterfaceStatus(v string) *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType {
	s.OppositeInterfaceStatus = &v
	return s
}

func (s *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType) SetOppositeRegionId(v string) *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType {
	s.OppositeRegionId = &v
	return s
}

func (s *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType) SetOppositeRouterId(v string) *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType {
	s.OppositeRouterId = &v
	return s
}

func (s *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType) SetOppositeRouterType(v string) *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType {
	s.OppositeRouterType = &v
	return s
}

func (s *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType) SetOppositeVpcInstanceId(v string) *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType {
	s.OppositeVpcInstanceId = &v
	return s
}

func (s *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType) SetReservationActiveTime(v string) *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType {
	s.ReservationActiveTime = &v
	return s
}

func (s *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType) SetReservationBandwidth(v string) *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType {
	s.ReservationBandwidth = &v
	return s
}

func (s *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType) SetReservationInternetChargeType(v string) *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType {
	s.ReservationInternetChargeType = &v
	return s
}

func (s *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType) SetReservationOrderType(v string) *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType {
	s.ReservationOrderType = &v
	return s
}

func (s *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType) SetResourceGroupId(v string) *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType) SetRole(v string) *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType {
	s.Role = &v
	return s
}

func (s *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType) SetRouterId(v string) *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType {
	s.RouterId = &v
	return s
}

func (s *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType) SetRouterInterfaceId(v string) *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType {
	s.RouterInterfaceId = &v
	return s
}

func (s *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType) SetRouterType(v string) *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType {
	s.RouterType = &v
	return s
}

func (s *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType) SetSpec(v string) *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType {
	s.Spec = &v
	return s
}

func (s *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType) SetStatus(v string) *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType {
	s.Status = &v
	return s
}

func (s *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType) SetTags(v *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceTypeTags) *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType {
	s.Tags = v
	return s
}

func (s *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType) SetVpcInstanceId(v string) *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType {
	s.VpcInstanceId = &v
	return s
}

type DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceTypeTags struct {
	Tags []*DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceTypeTagsTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
}

func (s DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceTypeTags) String() string {
	return tea.Prettify(s)
}

func (s DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceTypeTags) GoString() string {
	return s.String()
}

func (s *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceTypeTags) SetTags(v []*DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceTypeTagsTags) *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceTypeTags {
	s.Tags = v
	return s
}

type DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceTypeTagsTags struct {
	Key   *string `json:"Key,omitempty" xml:"Key,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceTypeTagsTags) String() string {
	return tea.Prettify(s)
}

func (s DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceTypeTagsTags) GoString() string {
	return s.String()
}

func (s *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceTypeTagsTags) SetKey(v string) *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceTypeTagsTags {
	s.Key = &v
	return s
}

func (s *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceTypeTagsTags) SetValue(v string) *DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceTypeTagsTags {
	s.Value = &v
	return s
}

type DescribeRouterInterfacesResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeRouterInterfacesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeRouterInterfacesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeRouterInterfacesResponse) GoString() string {
	return s.String()
}

func (s *DescribeRouterInterfacesResponse) SetHeaders(v map[string]*string) *DescribeRouterInterfacesResponse {
	s.Headers = v
	return s
}

func (s *DescribeRouterInterfacesResponse) SetStatusCode(v int32) *DescribeRouterInterfacesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeRouterInterfacesResponse) SetBody(v *DescribeRouterInterfacesResponseBody) *DescribeRouterInterfacesResponse {
	s.Body = v
	return s
}

type DescribeServerRelatedGlobalAccelerationInstancesRequest struct {
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the GA instance.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the backend service instance.
	ServerId *string `json:"ServerId,omitempty" xml:"ServerId,omitempty"`
	// The type of the backend service instance. Valid values:
	//
	// *   **EcsInstance** (default): Elastic Compute Service (ECS)
	// *   **SlbInstance**: Server Load Balancer (SLB)
	ServerType *string `json:"ServerType,omitempty" xml:"ServerType,omitempty"`
}

func (s DescribeServerRelatedGlobalAccelerationInstancesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeServerRelatedGlobalAccelerationInstancesRequest) GoString() string {
	return s.String()
}

func (s *DescribeServerRelatedGlobalAccelerationInstancesRequest) SetOwnerAccount(v string) *DescribeServerRelatedGlobalAccelerationInstancesRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeServerRelatedGlobalAccelerationInstancesRequest) SetOwnerId(v int64) *DescribeServerRelatedGlobalAccelerationInstancesRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeServerRelatedGlobalAccelerationInstancesRequest) SetRegionId(v string) *DescribeServerRelatedGlobalAccelerationInstancesRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeServerRelatedGlobalAccelerationInstancesRequest) SetResourceOwnerAccount(v string) *DescribeServerRelatedGlobalAccelerationInstancesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeServerRelatedGlobalAccelerationInstancesRequest) SetResourceOwnerId(v int64) *DescribeServerRelatedGlobalAccelerationInstancesRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeServerRelatedGlobalAccelerationInstancesRequest) SetServerId(v string) *DescribeServerRelatedGlobalAccelerationInstancesRequest {
	s.ServerId = &v
	return s
}

func (s *DescribeServerRelatedGlobalAccelerationInstancesRequest) SetServerType(v string) *DescribeServerRelatedGlobalAccelerationInstancesRequest {
	s.ServerType = &v
	return s
}

type DescribeServerRelatedGlobalAccelerationInstancesResponseBody struct {
	// The list of GA instances.
	GlobalAccelerationInstances *DescribeServerRelatedGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstances `json:"GlobalAccelerationInstances,omitempty" xml:"GlobalAccelerationInstances,omitempty" type:"Struct"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeServerRelatedGlobalAccelerationInstancesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeServerRelatedGlobalAccelerationInstancesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeServerRelatedGlobalAccelerationInstancesResponseBody) SetGlobalAccelerationInstances(v *DescribeServerRelatedGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstances) *DescribeServerRelatedGlobalAccelerationInstancesResponseBody {
	s.GlobalAccelerationInstances = v
	return s
}

func (s *DescribeServerRelatedGlobalAccelerationInstancesResponseBody) SetRequestId(v string) *DescribeServerRelatedGlobalAccelerationInstancesResponseBody {
	s.RequestId = &v
	return s
}

type DescribeServerRelatedGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstances struct {
	GlobalAccelerationInstance []*DescribeServerRelatedGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstance `json:"GlobalAccelerationInstance,omitempty" xml:"GlobalAccelerationInstance,omitempty" type:"Repeated"`
}

func (s DescribeServerRelatedGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstances) String() string {
	return tea.Prettify(s)
}

func (s DescribeServerRelatedGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstances) GoString() string {
	return s.String()
}

func (s *DescribeServerRelatedGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstances) SetGlobalAccelerationInstance(v []*DescribeServerRelatedGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstance) *DescribeServerRelatedGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstances {
	s.GlobalAccelerationInstance = v
	return s
}

type DescribeServerRelatedGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstance struct {
	// The ID of the GA instance.
	GlobalAccelerationInstanceId *string `json:"GlobalAccelerationInstanceId,omitempty" xml:"GlobalAccelerationInstanceId,omitempty"`
	// The public IP address of the GA instance.
	IpAddress *string `json:"IpAddress,omitempty" xml:"IpAddress,omitempty"`
	// The region ID of the GA instance.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The IP address of the backend service.
	ServerIpAddress *string `json:"ServerIpAddress,omitempty" xml:"ServerIpAddress,omitempty"`
}

func (s DescribeServerRelatedGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstance) String() string {
	return tea.Prettify(s)
}

func (s DescribeServerRelatedGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstance) GoString() string {
	return s.String()
}

func (s *DescribeServerRelatedGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstance) SetGlobalAccelerationInstanceId(v string) *DescribeServerRelatedGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstance {
	s.GlobalAccelerationInstanceId = &v
	return s
}

func (s *DescribeServerRelatedGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstance) SetIpAddress(v string) *DescribeServerRelatedGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstance {
	s.IpAddress = &v
	return s
}

func (s *DescribeServerRelatedGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstance) SetRegionId(v string) *DescribeServerRelatedGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstance {
	s.RegionId = &v
	return s
}

func (s *DescribeServerRelatedGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstance) SetServerIpAddress(v string) *DescribeServerRelatedGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstance {
	s.ServerIpAddress = &v
	return s
}

type DescribeServerRelatedGlobalAccelerationInstancesResponse struct {
	Headers    map[string]*string                                            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeServerRelatedGlobalAccelerationInstancesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeServerRelatedGlobalAccelerationInstancesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeServerRelatedGlobalAccelerationInstancesResponse) GoString() string {
	return s.String()
}

func (s *DescribeServerRelatedGlobalAccelerationInstancesResponse) SetHeaders(v map[string]*string) *DescribeServerRelatedGlobalAccelerationInstancesResponse {
	s.Headers = v
	return s
}

func (s *DescribeServerRelatedGlobalAccelerationInstancesResponse) SetStatusCode(v int32) *DescribeServerRelatedGlobalAccelerationInstancesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeServerRelatedGlobalAccelerationInstancesResponse) SetBody(v *DescribeServerRelatedGlobalAccelerationInstancesResponseBody) *DescribeServerRelatedGlobalAccelerationInstancesResponse {
	s.Body = v
	return s
}

type DescribeSnatTableEntriesRequest struct {
	// The ID of the NAT gateway.
	//
	// >  You must set at least one of the **SnatTableId** and **NatGatewayId** parameters.
	NatGatewayId *string `json:"NatGatewayId,omitempty" xml:"NatGatewayId,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of the page to return. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Maximum value: **50**. Default value: **10**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The region ID of the NAT gateway.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the SNAT entry.
	SnatEntryId *string `json:"SnatEntryId,omitempty" xml:"SnatEntryId,omitempty"`
	// The name of the SNAT entry.
	//
	// The name must be 2 to 128 characters in length, and can contain digits, underscores (\_), and hyphens (-). The name must start with a letter.
	SnatEntryName *string `json:"SnatEntryName,omitempty" xml:"SnatEntryName,omitempty"`
	// *   When you query SNAT entries of Internet NAT gateways, this parameter specifies the EIP in an SNAT entry.
	// *   When you query SNAT entries of VPC NAT gateways, this parameter specifies the NAT IP address in an SNAT entry.
	SnatIp *string `json:"SnatIp,omitempty" xml:"SnatIp,omitempty"`
	// The ID of the SNAT table.
	//
	// >  You must set at least one of the **SnatTableId** and **NatGatewayId** parameters.
	SnatTableId *string `json:"SnatTableId,omitempty" xml:"SnatTableId,omitempty"`
	// The source CIDR block specified in the SNAT entry.
	SourceCIDR *string `json:"SourceCIDR,omitempty" xml:"SourceCIDR,omitempty"`
	// The ID of the vSwitch.
	//
	// *   When you query SNAT entries of Internet NAT gateways, this parameter specifies that Elastic Compute Service (ECS) instances in the vSwitch can use SNAT entries to access the Internet.
	// *   When you query SNAT entries of virtual private cloud (VPC) NAT gateways, this parameter specifies that ECS instances in the vSwitch can use SNAT entries to access external networks.
	SourceVSwitchId *string `json:"SourceVSwitchId,omitempty" xml:"SourceVSwitchId,omitempty"`
}

func (s DescribeSnatTableEntriesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeSnatTableEntriesRequest) GoString() string {
	return s.String()
}

func (s *DescribeSnatTableEntriesRequest) SetNatGatewayId(v string) *DescribeSnatTableEntriesRequest {
	s.NatGatewayId = &v
	return s
}

func (s *DescribeSnatTableEntriesRequest) SetOwnerAccount(v string) *DescribeSnatTableEntriesRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeSnatTableEntriesRequest) SetOwnerId(v int64) *DescribeSnatTableEntriesRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeSnatTableEntriesRequest) SetPageNumber(v int32) *DescribeSnatTableEntriesRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeSnatTableEntriesRequest) SetPageSize(v int32) *DescribeSnatTableEntriesRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeSnatTableEntriesRequest) SetRegionId(v string) *DescribeSnatTableEntriesRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeSnatTableEntriesRequest) SetResourceOwnerAccount(v string) *DescribeSnatTableEntriesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeSnatTableEntriesRequest) SetResourceOwnerId(v int64) *DescribeSnatTableEntriesRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeSnatTableEntriesRequest) SetSnatEntryId(v string) *DescribeSnatTableEntriesRequest {
	s.SnatEntryId = &v
	return s
}

func (s *DescribeSnatTableEntriesRequest) SetSnatEntryName(v string) *DescribeSnatTableEntriesRequest {
	s.SnatEntryName = &v
	return s
}

func (s *DescribeSnatTableEntriesRequest) SetSnatIp(v string) *DescribeSnatTableEntriesRequest {
	s.SnatIp = &v
	return s
}

func (s *DescribeSnatTableEntriesRequest) SetSnatTableId(v string) *DescribeSnatTableEntriesRequest {
	s.SnatTableId = &v
	return s
}

func (s *DescribeSnatTableEntriesRequest) SetSourceCIDR(v string) *DescribeSnatTableEntriesRequest {
	s.SourceCIDR = &v
	return s
}

func (s *DescribeSnatTableEntriesRequest) SetSourceVSwitchId(v string) *DescribeSnatTableEntriesRequest {
	s.SourceVSwitchId = &v
	return s
}

type DescribeSnatTableEntriesResponseBody struct {
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The details of the SNAT entries.
	SnatTableEntries *DescribeSnatTableEntriesResponseBodySnatTableEntries `json:"SnatTableEntries,omitempty" xml:"SnatTableEntries,omitempty" type:"Struct"`
	// The number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeSnatTableEntriesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeSnatTableEntriesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeSnatTableEntriesResponseBody) SetPageNumber(v int32) *DescribeSnatTableEntriesResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeSnatTableEntriesResponseBody) SetPageSize(v int32) *DescribeSnatTableEntriesResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeSnatTableEntriesResponseBody) SetRequestId(v string) *DescribeSnatTableEntriesResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeSnatTableEntriesResponseBody) SetSnatTableEntries(v *DescribeSnatTableEntriesResponseBodySnatTableEntries) *DescribeSnatTableEntriesResponseBody {
	s.SnatTableEntries = v
	return s
}

func (s *DescribeSnatTableEntriesResponseBody) SetTotalCount(v int32) *DescribeSnatTableEntriesResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeSnatTableEntriesResponseBodySnatTableEntries struct {
	SnatTableEntry []*DescribeSnatTableEntriesResponseBodySnatTableEntriesSnatTableEntry `json:"SnatTableEntry,omitempty" xml:"SnatTableEntry,omitempty" type:"Repeated"`
}

func (s DescribeSnatTableEntriesResponseBodySnatTableEntries) String() string {
	return tea.Prettify(s)
}

func (s DescribeSnatTableEntriesResponseBodySnatTableEntries) GoString() string {
	return s.String()
}

func (s *DescribeSnatTableEntriesResponseBodySnatTableEntries) SetSnatTableEntry(v []*DescribeSnatTableEntriesResponseBodySnatTableEntriesSnatTableEntry) *DescribeSnatTableEntriesResponseBodySnatTableEntries {
	s.SnatTableEntry = v
	return s
}

type DescribeSnatTableEntriesResponseBodySnatTableEntriesSnatTableEntry struct {
	// The ID of the SNAT entry.
	SnatEntryId *string `json:"SnatEntryId,omitempty" xml:"SnatEntryId,omitempty"`
	// The name of the SNAT entry.
	SnatEntryName *string `json:"SnatEntryName,omitempty" xml:"SnatEntryName,omitempty"`
	// *   When you query SNAT entries of Internet NAT gateways, this parameter indicates the EIP in an SNAT entry.
	// *   When you query SNAT entries of VPC NAT gateways, this parameter indicates the NAT IP address in an SNAT entry.
	SnatIp *string `json:"SnatIp,omitempty" xml:"SnatIp,omitempty"`
	// The ID of the SNAT table to which the SNAT entry belongs.
	SnatTableId *string `json:"SnatTableId,omitempty" xml:"SnatTableId,omitempty"`
	// The source CIDR block specified in the SNAT entry.
	SourceCIDR *string `json:"SourceCIDR,omitempty" xml:"SourceCIDR,omitempty"`
	// *   When you query SNAT entries of Internet NAT gateways, this parameter indicates the ID of the vSwitch that uses SNAT to access the Internet.
	// *   When you query SNAT entries of VPC NAT gateways, this parameter indicates the ID of the vSwitch that uses SNAT to access external networks.
	SourceVSwitchId *string `json:"SourceVSwitchId,omitempty" xml:"SourceVSwitchId,omitempty"`
	// The status of the SNAT entry. Valid values:
	//
	// *   **Pending**: being created or modified
	// *   **Available**: available
	// *   **Deleting**: being deleted
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeSnatTableEntriesResponseBodySnatTableEntriesSnatTableEntry) String() string {
	return tea.Prettify(s)
}

func (s DescribeSnatTableEntriesResponseBodySnatTableEntriesSnatTableEntry) GoString() string {
	return s.String()
}

func (s *DescribeSnatTableEntriesResponseBodySnatTableEntriesSnatTableEntry) SetSnatEntryId(v string) *DescribeSnatTableEntriesResponseBodySnatTableEntriesSnatTableEntry {
	s.SnatEntryId = &v
	return s
}

func (s *DescribeSnatTableEntriesResponseBodySnatTableEntriesSnatTableEntry) SetSnatEntryName(v string) *DescribeSnatTableEntriesResponseBodySnatTableEntriesSnatTableEntry {
	s.SnatEntryName = &v
	return s
}

func (s *DescribeSnatTableEntriesResponseBodySnatTableEntriesSnatTableEntry) SetSnatIp(v string) *DescribeSnatTableEntriesResponseBodySnatTableEntriesSnatTableEntry {
	s.SnatIp = &v
	return s
}

func (s *DescribeSnatTableEntriesResponseBodySnatTableEntriesSnatTableEntry) SetSnatTableId(v string) *DescribeSnatTableEntriesResponseBodySnatTableEntriesSnatTableEntry {
	s.SnatTableId = &v
	return s
}

func (s *DescribeSnatTableEntriesResponseBodySnatTableEntriesSnatTableEntry) SetSourceCIDR(v string) *DescribeSnatTableEntriesResponseBodySnatTableEntriesSnatTableEntry {
	s.SourceCIDR = &v
	return s
}

func (s *DescribeSnatTableEntriesResponseBodySnatTableEntriesSnatTableEntry) SetSourceVSwitchId(v string) *DescribeSnatTableEntriesResponseBodySnatTableEntriesSnatTableEntry {
	s.SourceVSwitchId = &v
	return s
}

func (s *DescribeSnatTableEntriesResponseBodySnatTableEntriesSnatTableEntry) SetStatus(v string) *DescribeSnatTableEntriesResponseBodySnatTableEntriesSnatTableEntry {
	s.Status = &v
	return s
}

type DescribeSnatTableEntriesResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeSnatTableEntriesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeSnatTableEntriesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeSnatTableEntriesResponse) GoString() string {
	return s.String()
}

func (s *DescribeSnatTableEntriesResponse) SetHeaders(v map[string]*string) *DescribeSnatTableEntriesResponse {
	s.Headers = v
	return s
}

func (s *DescribeSnatTableEntriesResponse) SetStatusCode(v int32) *DescribeSnatTableEntriesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeSnatTableEntriesResponse) SetBody(v *DescribeSnatTableEntriesResponseBody) *DescribeSnatTableEntriesResponse {
	s.Body = v
	return s
}

type DescribeSslVpnClientCertRequest struct {
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the SSL client certificate. You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the SSL client certificate that you want to query.
	SslVpnClientCertId *string `json:"SslVpnClientCertId,omitempty" xml:"SslVpnClientCertId,omitempty"`
}

func (s DescribeSslVpnClientCertRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeSslVpnClientCertRequest) GoString() string {
	return s.String()
}

func (s *DescribeSslVpnClientCertRequest) SetOwnerAccount(v string) *DescribeSslVpnClientCertRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeSslVpnClientCertRequest) SetOwnerId(v int64) *DescribeSslVpnClientCertRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeSslVpnClientCertRequest) SetRegionId(v string) *DescribeSslVpnClientCertRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeSslVpnClientCertRequest) SetResourceOwnerAccount(v string) *DescribeSslVpnClientCertRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeSslVpnClientCertRequest) SetResourceOwnerId(v int64) *DescribeSslVpnClientCertRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeSslVpnClientCertRequest) SetSslVpnClientCertId(v string) *DescribeSslVpnClientCertRequest {
	s.SslVpnClientCertId = &v
	return s
}

type DescribeSslVpnClientCertResponseBody struct {
	// The CA certificate.
	CaCert *string `json:"CaCert,omitempty" xml:"CaCert,omitempty"`
	// The client certificate.
	ClientCert *string `json:"ClientCert,omitempty" xml:"ClientCert,omitempty"`
	// The client configuration.
	ClientConfig *string `json:"ClientConfig,omitempty" xml:"ClientConfig,omitempty"`
	// The client key.
	ClientKey *string `json:"ClientKey,omitempty" xml:"ClientKey,omitempty"`
	// The timestamp that indicates when the SSL client certificate was created. Unit: milliseconds.
	//
	// This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The timestamp that indicates when the SSL client certificate expires. Unit: milliseconds.
	//
	// This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
	EndTime *int64 `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The name of the SSL client certificate.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the region where the SSL client certificate is created.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the SSL client certificate.
	SslVpnClientCertId *string `json:"SslVpnClientCertId,omitempty" xml:"SslVpnClientCertId,omitempty"`
	// The ID of the SSL server.
	SslVpnServerId *string `json:"SslVpnServerId,omitempty" xml:"SslVpnServerId,omitempty"`
	// The status of the SSL client certificate. Valid values:
	//
	// *   **expiring-soon**
	// *   **normal**
	// *   **expired**
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeSslVpnClientCertResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeSslVpnClientCertResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeSslVpnClientCertResponseBody) SetCaCert(v string) *DescribeSslVpnClientCertResponseBody {
	s.CaCert = &v
	return s
}

func (s *DescribeSslVpnClientCertResponseBody) SetClientCert(v string) *DescribeSslVpnClientCertResponseBody {
	s.ClientCert = &v
	return s
}

func (s *DescribeSslVpnClientCertResponseBody) SetClientConfig(v string) *DescribeSslVpnClientCertResponseBody {
	s.ClientConfig = &v
	return s
}

func (s *DescribeSslVpnClientCertResponseBody) SetClientKey(v string) *DescribeSslVpnClientCertResponseBody {
	s.ClientKey = &v
	return s
}

func (s *DescribeSslVpnClientCertResponseBody) SetCreateTime(v int64) *DescribeSslVpnClientCertResponseBody {
	s.CreateTime = &v
	return s
}

func (s *DescribeSslVpnClientCertResponseBody) SetEndTime(v int64) *DescribeSslVpnClientCertResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeSslVpnClientCertResponseBody) SetName(v string) *DescribeSslVpnClientCertResponseBody {
	s.Name = &v
	return s
}

func (s *DescribeSslVpnClientCertResponseBody) SetRegionId(v string) *DescribeSslVpnClientCertResponseBody {
	s.RegionId = &v
	return s
}

func (s *DescribeSslVpnClientCertResponseBody) SetRequestId(v string) *DescribeSslVpnClientCertResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeSslVpnClientCertResponseBody) SetSslVpnClientCertId(v string) *DescribeSslVpnClientCertResponseBody {
	s.SslVpnClientCertId = &v
	return s
}

func (s *DescribeSslVpnClientCertResponseBody) SetSslVpnServerId(v string) *DescribeSslVpnClientCertResponseBody {
	s.SslVpnServerId = &v
	return s
}

func (s *DescribeSslVpnClientCertResponseBody) SetStatus(v string) *DescribeSslVpnClientCertResponseBody {
	s.Status = &v
	return s
}

type DescribeSslVpnClientCertResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeSslVpnClientCertResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeSslVpnClientCertResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeSslVpnClientCertResponse) GoString() string {
	return s.String()
}

func (s *DescribeSslVpnClientCertResponse) SetHeaders(v map[string]*string) *DescribeSslVpnClientCertResponse {
	s.Headers = v
	return s
}

func (s *DescribeSslVpnClientCertResponse) SetStatusCode(v int32) *DescribeSslVpnClientCertResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeSslVpnClientCertResponse) SetBody(v *DescribeSslVpnClientCertResponseBody) *DescribeSslVpnClientCertResponse {
	s.Body = v
	return s
}

type DescribeSslVpnClientCertsRequest struct {
	// The name of the SSL client certificate.
	Name         *string `json:"Name,omitempty" xml:"Name,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of the page to return. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Default value: **10**. Valid values: **1** to **50**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The region ID of the SSL client certificates to be queried.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the SSL client certificate.
	SslVpnClientCertId *string `json:"SslVpnClientCertId,omitempty" xml:"SslVpnClientCertId,omitempty"`
	// The ID of the SSL server.
	SslVpnServerId *string `json:"SslVpnServerId,omitempty" xml:"SslVpnServerId,omitempty"`
}

func (s DescribeSslVpnClientCertsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeSslVpnClientCertsRequest) GoString() string {
	return s.String()
}

func (s *DescribeSslVpnClientCertsRequest) SetName(v string) *DescribeSslVpnClientCertsRequest {
	s.Name = &v
	return s
}

func (s *DescribeSslVpnClientCertsRequest) SetOwnerAccount(v string) *DescribeSslVpnClientCertsRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeSslVpnClientCertsRequest) SetOwnerId(v int64) *DescribeSslVpnClientCertsRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeSslVpnClientCertsRequest) SetPageNumber(v int32) *DescribeSslVpnClientCertsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeSslVpnClientCertsRequest) SetPageSize(v int32) *DescribeSslVpnClientCertsRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeSslVpnClientCertsRequest) SetRegionId(v string) *DescribeSslVpnClientCertsRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeSslVpnClientCertsRequest) SetResourceOwnerAccount(v string) *DescribeSslVpnClientCertsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeSslVpnClientCertsRequest) SetResourceOwnerId(v int64) *DescribeSslVpnClientCertsRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeSslVpnClientCertsRequest) SetSslVpnClientCertId(v string) *DescribeSslVpnClientCertsRequest {
	s.SslVpnClientCertId = &v
	return s
}

func (s *DescribeSslVpnClientCertsRequest) SetSslVpnServerId(v string) *DescribeSslVpnClientCertsRequest {
	s.SslVpnServerId = &v
	return s
}

type DescribeSslVpnClientCertsResponseBody struct {
	// The number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The information about the SSL client certificates.
	SslVpnClientCertKeys *DescribeSslVpnClientCertsResponseBodySslVpnClientCertKeys `json:"SslVpnClientCertKeys,omitempty" xml:"SslVpnClientCertKeys,omitempty" type:"Struct"`
	// The number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeSslVpnClientCertsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeSslVpnClientCertsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeSslVpnClientCertsResponseBody) SetPageNumber(v int32) *DescribeSslVpnClientCertsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeSslVpnClientCertsResponseBody) SetPageSize(v int32) *DescribeSslVpnClientCertsResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeSslVpnClientCertsResponseBody) SetRequestId(v string) *DescribeSslVpnClientCertsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeSslVpnClientCertsResponseBody) SetSslVpnClientCertKeys(v *DescribeSslVpnClientCertsResponseBodySslVpnClientCertKeys) *DescribeSslVpnClientCertsResponseBody {
	s.SslVpnClientCertKeys = v
	return s
}

func (s *DescribeSslVpnClientCertsResponseBody) SetTotalCount(v int32) *DescribeSslVpnClientCertsResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeSslVpnClientCertsResponseBodySslVpnClientCertKeys struct {
	SslVpnClientCertKey []*DescribeSslVpnClientCertsResponseBodySslVpnClientCertKeysSslVpnClientCertKey `json:"SslVpnClientCertKey,omitempty" xml:"SslVpnClientCertKey,omitempty" type:"Repeated"`
}

func (s DescribeSslVpnClientCertsResponseBodySslVpnClientCertKeys) String() string {
	return tea.Prettify(s)
}

func (s DescribeSslVpnClientCertsResponseBodySslVpnClientCertKeys) GoString() string {
	return s.String()
}

func (s *DescribeSslVpnClientCertsResponseBodySslVpnClientCertKeys) SetSslVpnClientCertKey(v []*DescribeSslVpnClientCertsResponseBodySslVpnClientCertKeysSslVpnClientCertKey) *DescribeSslVpnClientCertsResponseBodySslVpnClientCertKeys {
	s.SslVpnClientCertKey = v
	return s
}

type DescribeSslVpnClientCertsResponseBodySslVpnClientCertKeysSslVpnClientCertKey struct {
	// The timestamp that indicates when the SSL client certificate was created. Unit: milliseconds.
	//
	// This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The timestamp that indicates when the SSL client certificate expires. Unit: milliseconds.
	//
	// This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
	EndTime *int64 `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The name of the SSL client certificate.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The region where the SSL client certificate is created.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the SSL client certificate.
	SslVpnClientCertId *string `json:"SslVpnClientCertId,omitempty" xml:"SslVpnClientCertId,omitempty"`
	// The ID of the SSL server.
	SslVpnServerId *string `json:"SslVpnServerId,omitempty" xml:"SslVpnServerId,omitempty"`
	// The status of the SSL client certificate. Valid values:
	//
	// *   **expiring-soon**: The certificate expires in one week.
	// *   **normal**: The certificate is active.
	// *   **expired**: The certificate has expired.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeSslVpnClientCertsResponseBodySslVpnClientCertKeysSslVpnClientCertKey) String() string {
	return tea.Prettify(s)
}

func (s DescribeSslVpnClientCertsResponseBodySslVpnClientCertKeysSslVpnClientCertKey) GoString() string {
	return s.String()
}

func (s *DescribeSslVpnClientCertsResponseBodySslVpnClientCertKeysSslVpnClientCertKey) SetCreateTime(v int64) *DescribeSslVpnClientCertsResponseBodySslVpnClientCertKeysSslVpnClientCertKey {
	s.CreateTime = &v
	return s
}

func (s *DescribeSslVpnClientCertsResponseBodySslVpnClientCertKeysSslVpnClientCertKey) SetEndTime(v int64) *DescribeSslVpnClientCertsResponseBodySslVpnClientCertKeysSslVpnClientCertKey {
	s.EndTime = &v
	return s
}

func (s *DescribeSslVpnClientCertsResponseBodySslVpnClientCertKeysSslVpnClientCertKey) SetName(v string) *DescribeSslVpnClientCertsResponseBodySslVpnClientCertKeysSslVpnClientCertKey {
	s.Name = &v
	return s
}

func (s *DescribeSslVpnClientCertsResponseBodySslVpnClientCertKeysSslVpnClientCertKey) SetRegionId(v string) *DescribeSslVpnClientCertsResponseBodySslVpnClientCertKeysSslVpnClientCertKey {
	s.RegionId = &v
	return s
}

func (s *DescribeSslVpnClientCertsResponseBodySslVpnClientCertKeysSslVpnClientCertKey) SetSslVpnClientCertId(v string) *DescribeSslVpnClientCertsResponseBodySslVpnClientCertKeysSslVpnClientCertKey {
	s.SslVpnClientCertId = &v
	return s
}

func (s *DescribeSslVpnClientCertsResponseBodySslVpnClientCertKeysSslVpnClientCertKey) SetSslVpnServerId(v string) *DescribeSslVpnClientCertsResponseBodySslVpnClientCertKeysSslVpnClientCertKey {
	s.SslVpnServerId = &v
	return s
}

func (s *DescribeSslVpnClientCertsResponseBodySslVpnClientCertKeysSslVpnClientCertKey) SetStatus(v string) *DescribeSslVpnClientCertsResponseBodySslVpnClientCertKeysSslVpnClientCertKey {
	s.Status = &v
	return s
}

type DescribeSslVpnClientCertsResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeSslVpnClientCertsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeSslVpnClientCertsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeSslVpnClientCertsResponse) GoString() string {
	return s.String()
}

func (s *DescribeSslVpnClientCertsResponse) SetHeaders(v map[string]*string) *DescribeSslVpnClientCertsResponse {
	s.Headers = v
	return s
}

func (s *DescribeSslVpnClientCertsResponse) SetStatusCode(v int32) *DescribeSslVpnClientCertsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeSslVpnClientCertsResponse) SetBody(v *DescribeSslVpnClientCertsResponseBody) *DescribeSslVpnClientCertsResponse {
	s.Body = v
	return s
}

type DescribeSslVpnClientsRequest struct {
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	PageNumber           *int32  `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	PageSize             *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	VpnGatewayId         *string `json:"VpnGatewayId,omitempty" xml:"VpnGatewayId,omitempty"`
}

func (s DescribeSslVpnClientsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeSslVpnClientsRequest) GoString() string {
	return s.String()
}

func (s *DescribeSslVpnClientsRequest) SetOwnerAccount(v string) *DescribeSslVpnClientsRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeSslVpnClientsRequest) SetOwnerId(v int64) *DescribeSslVpnClientsRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeSslVpnClientsRequest) SetPageNumber(v int32) *DescribeSslVpnClientsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeSslVpnClientsRequest) SetPageSize(v int32) *DescribeSslVpnClientsRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeSslVpnClientsRequest) SetRegionId(v string) *DescribeSslVpnClientsRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeSslVpnClientsRequest) SetResourceOwnerAccount(v string) *DescribeSslVpnClientsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeSslVpnClientsRequest) SetResourceOwnerId(v int64) *DescribeSslVpnClientsRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeSslVpnClientsRequest) SetVpnGatewayId(v string) *DescribeSslVpnClientsRequest {
	s.VpnGatewayId = &v
	return s
}

type DescribeSslVpnClientsResponseBody struct {
	ClientInfoList []*DescribeSslVpnClientsResponseBodyClientInfoList `json:"ClientInfoList,omitempty" xml:"ClientInfoList,omitempty" type:"Repeated"`
	PageNumber     *int32                                             `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	PageSize       *int32                                             `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	RegionId       *string                                            `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	RequestId      *string                                            `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	TotalCount     *int32                                             `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
	VpnGatewayId   *string                                            `json:"VpnGatewayId,omitempty" xml:"VpnGatewayId,omitempty"`
}

func (s DescribeSslVpnClientsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeSslVpnClientsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeSslVpnClientsResponseBody) SetClientInfoList(v []*DescribeSslVpnClientsResponseBodyClientInfoList) *DescribeSslVpnClientsResponseBody {
	s.ClientInfoList = v
	return s
}

func (s *DescribeSslVpnClientsResponseBody) SetPageNumber(v int32) *DescribeSslVpnClientsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeSslVpnClientsResponseBody) SetPageSize(v int32) *DescribeSslVpnClientsResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeSslVpnClientsResponseBody) SetRegionId(v string) *DescribeSslVpnClientsResponseBody {
	s.RegionId = &v
	return s
}

func (s *DescribeSslVpnClientsResponseBody) SetRequestId(v string) *DescribeSslVpnClientsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeSslVpnClientsResponseBody) SetTotalCount(v int32) *DescribeSslVpnClientsResponseBody {
	s.TotalCount = &v
	return s
}

func (s *DescribeSslVpnClientsResponseBody) SetVpnGatewayId(v string) *DescribeSslVpnClientsResponseBody {
	s.VpnGatewayId = &v
	return s
}

type DescribeSslVpnClientsResponseBodyClientInfoList struct {
	CommonName    *string `json:"CommonName,omitempty" xml:"CommonName,omitempty"`
	ConnectedTime *int64  `json:"ConnectedTime,omitempty" xml:"ConnectedTime,omitempty"`
	Ip            *string `json:"Ip,omitempty" xml:"Ip,omitempty"`
	Port          *string `json:"Port,omitempty" xml:"Port,omitempty"`
	PrivateIp     *string `json:"PrivateIp,omitempty" xml:"PrivateIp,omitempty"`
	ReceiveBytes  *int64  `json:"ReceiveBytes,omitempty" xml:"ReceiveBytes,omitempty"`
	SendBytes     *int64  `json:"SendBytes,omitempty" xml:"SendBytes,omitempty"`
	Status        *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeSslVpnClientsResponseBodyClientInfoList) String() string {
	return tea.Prettify(s)
}

func (s DescribeSslVpnClientsResponseBodyClientInfoList) GoString() string {
	return s.String()
}

func (s *DescribeSslVpnClientsResponseBodyClientInfoList) SetCommonName(v string) *DescribeSslVpnClientsResponseBodyClientInfoList {
	s.CommonName = &v
	return s
}

func (s *DescribeSslVpnClientsResponseBodyClientInfoList) SetConnectedTime(v int64) *DescribeSslVpnClientsResponseBodyClientInfoList {
	s.ConnectedTime = &v
	return s
}

func (s *DescribeSslVpnClientsResponseBodyClientInfoList) SetIp(v string) *DescribeSslVpnClientsResponseBodyClientInfoList {
	s.Ip = &v
	return s
}

func (s *DescribeSslVpnClientsResponseBodyClientInfoList) SetPort(v string) *DescribeSslVpnClientsResponseBodyClientInfoList {
	s.Port = &v
	return s
}

func (s *DescribeSslVpnClientsResponseBodyClientInfoList) SetPrivateIp(v string) *DescribeSslVpnClientsResponseBodyClientInfoList {
	s.PrivateIp = &v
	return s
}

func (s *DescribeSslVpnClientsResponseBodyClientInfoList) SetReceiveBytes(v int64) *DescribeSslVpnClientsResponseBodyClientInfoList {
	s.ReceiveBytes = &v
	return s
}

func (s *DescribeSslVpnClientsResponseBodyClientInfoList) SetSendBytes(v int64) *DescribeSslVpnClientsResponseBodyClientInfoList {
	s.SendBytes = &v
	return s
}

func (s *DescribeSslVpnClientsResponseBodyClientInfoList) SetStatus(v string) *DescribeSslVpnClientsResponseBodyClientInfoList {
	s.Status = &v
	return s
}

type DescribeSslVpnClientsResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeSslVpnClientsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeSslVpnClientsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeSslVpnClientsResponse) GoString() string {
	return s.String()
}

func (s *DescribeSslVpnClientsResponse) SetHeaders(v map[string]*string) *DescribeSslVpnClientsResponse {
	s.Headers = v
	return s
}

func (s *DescribeSslVpnClientsResponse) SetStatusCode(v int32) *DescribeSslVpnClientsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeSslVpnClientsResponse) SetBody(v *DescribeSslVpnClientsResponseBody) *DescribeSslVpnClientsResponse {
	s.Body = v
	return s
}

type DescribeSslVpnServersRequest struct {
	// The name of the SSL-VPN server.
	//
	// The name must be 1 to 100 characters in length and cannot start with `http://` or `https://`.
	Name         *string `json:"Name,omitempty" xml:"Name,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of the returned page. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Maximum value: **50**. Default value: **10**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the region where the SSL servers are created.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the SSL-VPN server.
	SslVpnServerId *string `json:"SslVpnServerId,omitempty" xml:"SslVpnServerId,omitempty"`
	// The ID of the VPN gateway.
	VpnGatewayId *string `json:"VpnGatewayId,omitempty" xml:"VpnGatewayId,omitempty"`
}

func (s DescribeSslVpnServersRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeSslVpnServersRequest) GoString() string {
	return s.String()
}

func (s *DescribeSslVpnServersRequest) SetName(v string) *DescribeSslVpnServersRequest {
	s.Name = &v
	return s
}

func (s *DescribeSslVpnServersRequest) SetOwnerAccount(v string) *DescribeSslVpnServersRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeSslVpnServersRequest) SetOwnerId(v int64) *DescribeSslVpnServersRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeSslVpnServersRequest) SetPageNumber(v int32) *DescribeSslVpnServersRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeSslVpnServersRequest) SetPageSize(v int32) *DescribeSslVpnServersRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeSslVpnServersRequest) SetRegionId(v string) *DescribeSslVpnServersRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeSslVpnServersRequest) SetResourceOwnerAccount(v string) *DescribeSslVpnServersRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeSslVpnServersRequest) SetResourceOwnerId(v int64) *DescribeSslVpnServersRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeSslVpnServersRequest) SetSslVpnServerId(v string) *DescribeSslVpnServersRequest {
	s.SslVpnServerId = &v
	return s
}

func (s *DescribeSslVpnServersRequest) SetVpnGatewayId(v string) *DescribeSslVpnServersRequest {
	s.VpnGatewayId = &v
	return s
}

type DescribeSslVpnServersResponseBody struct {
	// The number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The detailed information about the SSL servers.
	SslVpnServers *DescribeSslVpnServersResponseBodySslVpnServers `json:"SslVpnServers,omitempty" xml:"SslVpnServers,omitempty" type:"Struct"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeSslVpnServersResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeSslVpnServersResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeSslVpnServersResponseBody) SetPageNumber(v int32) *DescribeSslVpnServersResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeSslVpnServersResponseBody) SetPageSize(v int32) *DescribeSslVpnServersResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeSslVpnServersResponseBody) SetRequestId(v string) *DescribeSslVpnServersResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeSslVpnServersResponseBody) SetSslVpnServers(v *DescribeSslVpnServersResponseBodySslVpnServers) *DescribeSslVpnServersResponseBody {
	s.SslVpnServers = v
	return s
}

func (s *DescribeSslVpnServersResponseBody) SetTotalCount(v int32) *DescribeSslVpnServersResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeSslVpnServersResponseBodySslVpnServers struct {
	SslVpnServer []*DescribeSslVpnServersResponseBodySslVpnServersSslVpnServer `json:"SslVpnServer,omitempty" xml:"SslVpnServer,omitempty" type:"Repeated"`
}

func (s DescribeSslVpnServersResponseBodySslVpnServers) String() string {
	return tea.Prettify(s)
}

func (s DescribeSslVpnServersResponseBodySslVpnServers) GoString() string {
	return s.String()
}

func (s *DescribeSslVpnServersResponseBodySslVpnServers) SetSslVpnServer(v []*DescribeSslVpnServersResponseBodySslVpnServersSslVpnServer) *DescribeSslVpnServersResponseBodySslVpnServers {
	s.SslVpnServer = v
	return s
}

type DescribeSslVpnServersResponseBodySslVpnServersSslVpnServer struct {
	// The encryption algorithm.
	Cipher *string `json:"Cipher,omitempty" xml:"Cipher,omitempty"`
	// The client CIDR block.
	ClientIpPool *string `json:"ClientIpPool,omitempty" xml:"ClientIpPool,omitempty"`
	// Indicates whether data compression is enabled. Valid values:
	//
	// *   **true**: yes
	// *   **false** (default): no
	Compress *bool `json:"Compress,omitempty" xml:"Compress,omitempty"`
	// The total number of current connections.
	Connections *int32 `json:"Connections,omitempty" xml:"Connections,omitempty"`
	// The timestamp generated when the SSL server was created.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// Indicates whether two-factor authentication is enabled. Valid values:
	//
	// *   **true**: yes
	// *   **false** (default): no
	EnableMultiFactorAuth *bool `json:"EnableMultiFactorAuth,omitempty" xml:"EnableMultiFactorAuth,omitempty"`
	// The ID of the Identity as a Service (IDaaS) instance.
	IDaaSInstanceId *string `json:"IDaaSInstanceId,omitempty" xml:"IDaaSInstanceId,omitempty"`
	// The ID of the region where the IDaaS instance is created.
	IDaaSRegionId *string `json:"IDaaSRegionId,omitempty" xml:"IDaaSRegionId,omitempty"`
	// The public IP address of the VPN gateway.
	InternetIp *string `json:"InternetIp,omitempty" xml:"InternetIp,omitempty"`
	// The local CIDR block.
	LocalSubnet *string `json:"LocalSubnet,omitempty" xml:"LocalSubnet,omitempty"`
	// The maximum number of connections.
	MaxConnections *int32 `json:"MaxConnections,omitempty" xml:"MaxConnections,omitempty"`
	// The name of the SSL server.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The port that is used by the SSL server.
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
	// The protocol that is used by the SSL server.
	Proto *string `json:"Proto,omitempty" xml:"Proto,omitempty"`
	// The ID of the region where the SSL server is created.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the SSL server.
	SslVpnServerId *string `json:"SslVpnServerId,omitempty" xml:"SslVpnServerId,omitempty"`
	// The ID of the VPN gateway.
	VpnGatewayId *string `json:"VpnGatewayId,omitempty" xml:"VpnGatewayId,omitempty"`
}

func (s DescribeSslVpnServersResponseBodySslVpnServersSslVpnServer) String() string {
	return tea.Prettify(s)
}

func (s DescribeSslVpnServersResponseBodySslVpnServersSslVpnServer) GoString() string {
	return s.String()
}

func (s *DescribeSslVpnServersResponseBodySslVpnServersSslVpnServer) SetCipher(v string) *DescribeSslVpnServersResponseBodySslVpnServersSslVpnServer {
	s.Cipher = &v
	return s
}

func (s *DescribeSslVpnServersResponseBodySslVpnServersSslVpnServer) SetClientIpPool(v string) *DescribeSslVpnServersResponseBodySslVpnServersSslVpnServer {
	s.ClientIpPool = &v
	return s
}

func (s *DescribeSslVpnServersResponseBodySslVpnServersSslVpnServer) SetCompress(v bool) *DescribeSslVpnServersResponseBodySslVpnServersSslVpnServer {
	s.Compress = &v
	return s
}

func (s *DescribeSslVpnServersResponseBodySslVpnServersSslVpnServer) SetConnections(v int32) *DescribeSslVpnServersResponseBodySslVpnServersSslVpnServer {
	s.Connections = &v
	return s
}

func (s *DescribeSslVpnServersResponseBodySslVpnServersSslVpnServer) SetCreateTime(v int64) *DescribeSslVpnServersResponseBodySslVpnServersSslVpnServer {
	s.CreateTime = &v
	return s
}

func (s *DescribeSslVpnServersResponseBodySslVpnServersSslVpnServer) SetEnableMultiFactorAuth(v bool) *DescribeSslVpnServersResponseBodySslVpnServersSslVpnServer {
	s.EnableMultiFactorAuth = &v
	return s
}

func (s *DescribeSslVpnServersResponseBodySslVpnServersSslVpnServer) SetIDaaSInstanceId(v string) *DescribeSslVpnServersResponseBodySslVpnServersSslVpnServer {
	s.IDaaSInstanceId = &v
	return s
}

func (s *DescribeSslVpnServersResponseBodySslVpnServersSslVpnServer) SetIDaaSRegionId(v string) *DescribeSslVpnServersResponseBodySslVpnServersSslVpnServer {
	s.IDaaSRegionId = &v
	return s
}

func (s *DescribeSslVpnServersResponseBodySslVpnServersSslVpnServer) SetInternetIp(v string) *DescribeSslVpnServersResponseBodySslVpnServersSslVpnServer {
	s.InternetIp = &v
	return s
}

func (s *DescribeSslVpnServersResponseBodySslVpnServersSslVpnServer) SetLocalSubnet(v string) *DescribeSslVpnServersResponseBodySslVpnServersSslVpnServer {
	s.LocalSubnet = &v
	return s
}

func (s *DescribeSslVpnServersResponseBodySslVpnServersSslVpnServer) SetMaxConnections(v int32) *DescribeSslVpnServersResponseBodySslVpnServersSslVpnServer {
	s.MaxConnections = &v
	return s
}

func (s *DescribeSslVpnServersResponseBodySslVpnServersSslVpnServer) SetName(v string) *DescribeSslVpnServersResponseBodySslVpnServersSslVpnServer {
	s.Name = &v
	return s
}

func (s *DescribeSslVpnServersResponseBodySslVpnServersSslVpnServer) SetPort(v int32) *DescribeSslVpnServersResponseBodySslVpnServersSslVpnServer {
	s.Port = &v
	return s
}

func (s *DescribeSslVpnServersResponseBodySslVpnServersSslVpnServer) SetProto(v string) *DescribeSslVpnServersResponseBodySslVpnServersSslVpnServer {
	s.Proto = &v
	return s
}

func (s *DescribeSslVpnServersResponseBodySslVpnServersSslVpnServer) SetRegionId(v string) *DescribeSslVpnServersResponseBodySslVpnServersSslVpnServer {
	s.RegionId = &v
	return s
}

func (s *DescribeSslVpnServersResponseBodySslVpnServersSslVpnServer) SetSslVpnServerId(v string) *DescribeSslVpnServersResponseBodySslVpnServersSslVpnServer {
	s.SslVpnServerId = &v
	return s
}

func (s *DescribeSslVpnServersResponseBodySslVpnServersSslVpnServer) SetVpnGatewayId(v string) *DescribeSslVpnServersResponseBodySslVpnServersSslVpnServer {
	s.VpnGatewayId = &v
	return s
}

type DescribeSslVpnServersResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeSslVpnServersResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeSslVpnServersResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeSslVpnServersResponse) GoString() string {
	return s.String()
}

func (s *DescribeSslVpnServersResponse) SetHeaders(v map[string]*string) *DescribeSslVpnServersResponse {
	s.Headers = v
	return s
}

func (s *DescribeSslVpnServersResponse) SetStatusCode(v int32) *DescribeSslVpnServersResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeSslVpnServersResponse) SetBody(v *DescribeSslVpnServersResponseBody) *DescribeSslVpnServersResponse {
	s.Body = v
	return s
}

type DescribeTagKeysRequest struct {
	// The tag keys.
	Keyword *string `json:"Keyword,omitempty" xml:"Keyword,omitempty"`
	// The number of entries to return on each page. Valid values: 1 to 50. Default value: 50.
	MaxResult *int32 `json:"MaxResult,omitempty" xml:"MaxResult,omitempty"`
	// The token that is used for the next query. Valid values:
	//
	// *   If this is your first query or no next query is to be sent, ignore this parameter.
	// *   If a subsequent query is to be sent, set the parameter to the value of NextToken that is returned from the last call.
	NextToken    *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the resource.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string   `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceId           []*string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty" type:"Repeated"`
	ResourceOwnerAccount *string   `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64    `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The resource type. Valid values:
	//
	// *   **VPC**: virtual private cloud (VPC)
	// *   **VSWITCH**: vSwitch
	// *   **ROUTETABLE**: route table
	// *   **EIP**: elastic IP address (EIP)
	// *   **VpnGateway**: VPN gateway
	// *   **NATGATEWAY**: NAT gateway
	// *   **COMMONBANDWIDTHPACKAGE**: EIP bandwidth plan
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
}

func (s DescribeTagKeysRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeTagKeysRequest) GoString() string {
	return s.String()
}

func (s *DescribeTagKeysRequest) SetKeyword(v string) *DescribeTagKeysRequest {
	s.Keyword = &v
	return s
}

func (s *DescribeTagKeysRequest) SetMaxResult(v int32) *DescribeTagKeysRequest {
	s.MaxResult = &v
	return s
}

func (s *DescribeTagKeysRequest) SetNextToken(v string) *DescribeTagKeysRequest {
	s.NextToken = &v
	return s
}

func (s *DescribeTagKeysRequest) SetOwnerAccount(v string) *DescribeTagKeysRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeTagKeysRequest) SetOwnerId(v int64) *DescribeTagKeysRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeTagKeysRequest) SetRegionId(v string) *DescribeTagKeysRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeTagKeysRequest) SetResourceId(v []*string) *DescribeTagKeysRequest {
	s.ResourceId = v
	return s
}

func (s *DescribeTagKeysRequest) SetResourceOwnerAccount(v string) *DescribeTagKeysRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeTagKeysRequest) SetResourceOwnerId(v int64) *DescribeTagKeysRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeTagKeysRequest) SetResourceType(v string) *DescribeTagKeysRequest {
	s.ResourceType = &v
	return s
}

type DescribeTagKeysResponseBody struct {
	// The token that is used for the next query. Valid values:
	//
	// *   If the value of **NextToken** is not returned, it indicates that no next query is to be sent.
	// *   If a value of **NextToken** is returned, the value is the token that is used for the subsequent query.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The list of tag keys.
	TagKeys *DescribeTagKeysResponseBodyTagKeys `json:"TagKeys,omitempty" xml:"TagKeys,omitempty" type:"Struct"`
}

func (s DescribeTagKeysResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeTagKeysResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeTagKeysResponseBody) SetNextToken(v string) *DescribeTagKeysResponseBody {
	s.NextToken = &v
	return s
}

func (s *DescribeTagKeysResponseBody) SetRequestId(v string) *DescribeTagKeysResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeTagKeysResponseBody) SetTagKeys(v *DescribeTagKeysResponseBodyTagKeys) *DescribeTagKeysResponseBody {
	s.TagKeys = v
	return s
}

type DescribeTagKeysResponseBodyTagKeys struct {
	TagKey []*DescribeTagKeysResponseBodyTagKeysTagKey `json:"TagKey,omitempty" xml:"TagKey,omitempty" type:"Repeated"`
}

func (s DescribeTagKeysResponseBodyTagKeys) String() string {
	return tea.Prettify(s)
}

func (s DescribeTagKeysResponseBodyTagKeys) GoString() string {
	return s.String()
}

func (s *DescribeTagKeysResponseBodyTagKeys) SetTagKey(v []*DescribeTagKeysResponseBodyTagKeysTagKey) *DescribeTagKeysResponseBodyTagKeys {
	s.TagKey = v
	return s
}

type DescribeTagKeysResponseBodyTagKeysTagKey struct {
	// The tag key.
	TagKey *string `json:"TagKey,omitempty" xml:"TagKey,omitempty"`
	// The type of the tag key. Valid values:
	//
	// *   **Custom**: custom
	// *   **System**: system
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s DescribeTagKeysResponseBodyTagKeysTagKey) String() string {
	return tea.Prettify(s)
}

func (s DescribeTagKeysResponseBodyTagKeysTagKey) GoString() string {
	return s.String()
}

func (s *DescribeTagKeysResponseBodyTagKeysTagKey) SetTagKey(v string) *DescribeTagKeysResponseBodyTagKeysTagKey {
	s.TagKey = &v
	return s
}

func (s *DescribeTagKeysResponseBodyTagKeysTagKey) SetType(v string) *DescribeTagKeysResponseBodyTagKeysTagKey {
	s.Type = &v
	return s
}

type DescribeTagKeysResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeTagKeysResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeTagKeysResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeTagKeysResponse) GoString() string {
	return s.String()
}

func (s *DescribeTagKeysResponse) SetHeaders(v map[string]*string) *DescribeTagKeysResponse {
	s.Headers = v
	return s
}

func (s *DescribeTagKeysResponse) SetStatusCode(v int32) *DescribeTagKeysResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeTagKeysResponse) SetBody(v *DescribeTagKeysResponseBody) *DescribeTagKeysResponse {
	s.Body = v
	return s
}

type DescribeTagKeysForExpressConnectRequest struct {
	// The keyword of the tag. The keyword is used to perform a fuzzy match. You can specify a keyword to query all tags that contain the keyword.
	Keyword *string `json:"Keyword,omitempty" xml:"Keyword,omitempty"`
	// The number of entries to return on each page. Valid values: **1** to **100**. Default value: **20**.
	MaxResult *int32 `json:"MaxResult,omitempty" xml:"MaxResult,omitempty"`
	// The token that is used for the next query. Valid values:
	//
	// *   If this is your first query and no next queries are to be sent, ignore this parameter.
	// *   If a next query is to be sent, set the parameter to the value of NextToken that is returned from the last call.
	NextToken    *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region to which the resource belongs.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string   `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceId           []*string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty" type:"Repeated"`
	ResourceOwnerAccount *string   `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64    `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The type of the resource. Set the value to **PHYSICALCONNECTION**, which specifies an Express Connect circuit.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
}

func (s DescribeTagKeysForExpressConnectRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeTagKeysForExpressConnectRequest) GoString() string {
	return s.String()
}

func (s *DescribeTagKeysForExpressConnectRequest) SetKeyword(v string) *DescribeTagKeysForExpressConnectRequest {
	s.Keyword = &v
	return s
}

func (s *DescribeTagKeysForExpressConnectRequest) SetMaxResult(v int32) *DescribeTagKeysForExpressConnectRequest {
	s.MaxResult = &v
	return s
}

func (s *DescribeTagKeysForExpressConnectRequest) SetNextToken(v string) *DescribeTagKeysForExpressConnectRequest {
	s.NextToken = &v
	return s
}

func (s *DescribeTagKeysForExpressConnectRequest) SetOwnerAccount(v string) *DescribeTagKeysForExpressConnectRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeTagKeysForExpressConnectRequest) SetOwnerId(v int64) *DescribeTagKeysForExpressConnectRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeTagKeysForExpressConnectRequest) SetRegionId(v string) *DescribeTagKeysForExpressConnectRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeTagKeysForExpressConnectRequest) SetResourceId(v []*string) *DescribeTagKeysForExpressConnectRequest {
	s.ResourceId = v
	return s
}

func (s *DescribeTagKeysForExpressConnectRequest) SetResourceOwnerAccount(v string) *DescribeTagKeysForExpressConnectRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeTagKeysForExpressConnectRequest) SetResourceOwnerId(v int64) *DescribeTagKeysForExpressConnectRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeTagKeysForExpressConnectRequest) SetResourceType(v string) *DescribeTagKeysForExpressConnectRequest {
	s.ResourceType = &v
	return s
}

type DescribeTagKeysForExpressConnectResponseBody struct {
	// The token that is used for the next query. Valid values:
	//
	// *   If no value is returned for **NextToken**, no next queries are sent.
	// *   If a value is returned for **NextToken**, the value is the token that is used for the next query.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The list of tag keys.
	TagKeys *DescribeTagKeysForExpressConnectResponseBodyTagKeys `json:"TagKeys,omitempty" xml:"TagKeys,omitempty" type:"Struct"`
}

func (s DescribeTagKeysForExpressConnectResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeTagKeysForExpressConnectResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeTagKeysForExpressConnectResponseBody) SetNextToken(v string) *DescribeTagKeysForExpressConnectResponseBody {
	s.NextToken = &v
	return s
}

func (s *DescribeTagKeysForExpressConnectResponseBody) SetRequestId(v string) *DescribeTagKeysForExpressConnectResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeTagKeysForExpressConnectResponseBody) SetTagKeys(v *DescribeTagKeysForExpressConnectResponseBodyTagKeys) *DescribeTagKeysForExpressConnectResponseBody {
	s.TagKeys = v
	return s
}

type DescribeTagKeysForExpressConnectResponseBodyTagKeys struct {
	TagKey []*DescribeTagKeysForExpressConnectResponseBodyTagKeysTagKey `json:"TagKey,omitempty" xml:"TagKey,omitempty" type:"Repeated"`
}

func (s DescribeTagKeysForExpressConnectResponseBodyTagKeys) String() string {
	return tea.Prettify(s)
}

func (s DescribeTagKeysForExpressConnectResponseBodyTagKeys) GoString() string {
	return s.String()
}

func (s *DescribeTagKeysForExpressConnectResponseBodyTagKeys) SetTagKey(v []*DescribeTagKeysForExpressConnectResponseBodyTagKeysTagKey) *DescribeTagKeysForExpressConnectResponseBodyTagKeys {
	s.TagKey = v
	return s
}

type DescribeTagKeysForExpressConnectResponseBodyTagKeysTagKey struct {
	// The tag key.
	TagKey *string `json:"TagKey,omitempty" xml:"TagKey,omitempty"`
	// The type of the resource. The value is set to **PHYSICALCONNECTION**, which indicates an Express Connect circuit.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s DescribeTagKeysForExpressConnectResponseBodyTagKeysTagKey) String() string {
	return tea.Prettify(s)
}

func (s DescribeTagKeysForExpressConnectResponseBodyTagKeysTagKey) GoString() string {
	return s.String()
}

func (s *DescribeTagKeysForExpressConnectResponseBodyTagKeysTagKey) SetTagKey(v string) *DescribeTagKeysForExpressConnectResponseBodyTagKeysTagKey {
	s.TagKey = &v
	return s
}

func (s *DescribeTagKeysForExpressConnectResponseBodyTagKeysTagKey) SetType(v string) *DescribeTagKeysForExpressConnectResponseBodyTagKeysTagKey {
	s.Type = &v
	return s
}

type DescribeTagKeysForExpressConnectResponse struct {
	Headers    map[string]*string                            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeTagKeysForExpressConnectResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeTagKeysForExpressConnectResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeTagKeysForExpressConnectResponse) GoString() string {
	return s.String()
}

func (s *DescribeTagKeysForExpressConnectResponse) SetHeaders(v map[string]*string) *DescribeTagKeysForExpressConnectResponse {
	s.Headers = v
	return s
}

func (s *DescribeTagKeysForExpressConnectResponse) SetStatusCode(v int32) *DescribeTagKeysForExpressConnectResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeTagKeysForExpressConnectResponse) SetBody(v *DescribeTagKeysForExpressConnectResponseBody) *DescribeTagKeysForExpressConnectResponse {
	s.Body = v
	return s
}

type DescribeTagsRequest struct {
	// The number of entries to return on each page. Valid values: 1 to 50. Default value: 50.
	MaxResult *int32 `json:"MaxResult,omitempty" xml:"MaxResult,omitempty"`
	// The token that is used for the next query. Valid values:
	//
	// *   If this is your first query or no next query is to be sent, ignore this parameter.
	// *   If a subsequent query is to be sent, set the parameter to the value of NextToken that is returned from the last call.
	NextToken    *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region to which the resource belongs.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string   `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceId           []*string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty" type:"Repeated"`
	ResourceOwnerAccount *string   `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64    `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The resource type. Valid values:
	//
	// *   **VPC**: virtual private cloud (VPC)
	// *   **VSWITCH**: vSwitch
	// *   **ROUTETABLE**: route table
	// *   **EIP**: elastic IP address (EIP)
	// *   **VpnGateway**: VPN gateway
	// *   **NATGATEWAY**: NAT gateway
	// *   **COMMONBANDWIDTHPACKAGE**: EIP bandwidth plan
	ResourceType *string                   `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	Tag          []*DescribeTagsRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s DescribeTagsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeTagsRequest) GoString() string {
	return s.String()
}

func (s *DescribeTagsRequest) SetMaxResult(v int32) *DescribeTagsRequest {
	s.MaxResult = &v
	return s
}

func (s *DescribeTagsRequest) SetNextToken(v string) *DescribeTagsRequest {
	s.NextToken = &v
	return s
}

func (s *DescribeTagsRequest) SetOwnerAccount(v string) *DescribeTagsRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeTagsRequest) SetOwnerId(v int64) *DescribeTagsRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeTagsRequest) SetRegionId(v string) *DescribeTagsRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeTagsRequest) SetResourceId(v []*string) *DescribeTagsRequest {
	s.ResourceId = v
	return s
}

func (s *DescribeTagsRequest) SetResourceOwnerAccount(v string) *DescribeTagsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeTagsRequest) SetResourceOwnerId(v int64) *DescribeTagsRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeTagsRequest) SetResourceType(v string) *DescribeTagsRequest {
	s.ResourceType = &v
	return s
}

func (s *DescribeTagsRequest) SetTag(v []*DescribeTagsRequestTag) *DescribeTagsRequest {
	s.Tag = v
	return s
}

type DescribeTagsRequestTag struct {
	// The key of the tag that is added to the resource. You can specify up to 20 tag keys. The tag key cannot be an empty string.
	//
	// The key cannot exceed 64 characters in length, and can contain digits, periods (.), underscores (\_), and hyphens (-). The key must start with a letter but cannot start with `aliyun` or `acs:`. The key cannot contain `http://` or `https://`.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The value of the tag that is added to the resource. You can specify up to 20 tag values. The tag value can be an empty string.
	//
	// The tag value cannot exceed 128 characters in length, and can contain digits, periods (.), underscores (\_), and hyphens (-). The key must start with a letter but cannot start with `aliyun` or `acs:`. The key cannot contain `http://` or `https://`.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeTagsRequestTag) String() string {
	return tea.Prettify(s)
}

func (s DescribeTagsRequestTag) GoString() string {
	return s.String()
}

func (s *DescribeTagsRequestTag) SetKey(v string) *DescribeTagsRequestTag {
	s.Key = &v
	return s
}

func (s *DescribeTagsRequestTag) SetValue(v string) *DescribeTagsRequestTag {
	s.Value = &v
	return s
}

type DescribeTagsResponseBody struct {
	// The token that is used for the next query. Valid values:
	//
	// *   If the value of **NextToken** is not returned, it indicates that no next query is to be sent.
	// *   If a value of **NextToken** is returned, the value is the token that is used for the subsequent query.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The list of tags that meet the filter conditions.
	TagResources *DescribeTagsResponseBodyTagResources `json:"TagResources,omitempty" xml:"TagResources,omitempty" type:"Struct"`
}

func (s DescribeTagsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeTagsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeTagsResponseBody) SetNextToken(v string) *DescribeTagsResponseBody {
	s.NextToken = &v
	return s
}

func (s *DescribeTagsResponseBody) SetRequestId(v string) *DescribeTagsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeTagsResponseBody) SetTagResources(v *DescribeTagsResponseBodyTagResources) *DescribeTagsResponseBody {
	s.TagResources = v
	return s
}

type DescribeTagsResponseBodyTagResources struct {
	TagResource []*DescribeTagsResponseBodyTagResourcesTagResource `json:"TagResource,omitempty" xml:"TagResource,omitempty" type:"Repeated"`
}

func (s DescribeTagsResponseBodyTagResources) String() string {
	return tea.Prettify(s)
}

func (s DescribeTagsResponseBodyTagResources) GoString() string {
	return s.String()
}

func (s *DescribeTagsResponseBodyTagResources) SetTagResource(v []*DescribeTagsResponseBodyTagResourcesTagResource) *DescribeTagsResponseBodyTagResources {
	s.TagResource = v
	return s
}

type DescribeTagsResponseBodyTagResourcesTagResource struct {
	// The tag key.
	TagKey *string `json:"TagKey,omitempty" xml:"TagKey,omitempty"`
	// The tag value.
	TagValue *string `json:"TagValue,omitempty" xml:"TagValue,omitempty"`
}

func (s DescribeTagsResponseBodyTagResourcesTagResource) String() string {
	return tea.Prettify(s)
}

func (s DescribeTagsResponseBodyTagResourcesTagResource) GoString() string {
	return s.String()
}

func (s *DescribeTagsResponseBodyTagResourcesTagResource) SetTagKey(v string) *DescribeTagsResponseBodyTagResourcesTagResource {
	s.TagKey = &v
	return s
}

func (s *DescribeTagsResponseBodyTagResourcesTagResource) SetTagValue(v string) *DescribeTagsResponseBodyTagResourcesTagResource {
	s.TagValue = &v
	return s
}

type DescribeTagsResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeTagsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeTagsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeTagsResponse) GoString() string {
	return s.String()
}

func (s *DescribeTagsResponse) SetHeaders(v map[string]*string) *DescribeTagsResponse {
	s.Headers = v
	return s
}

func (s *DescribeTagsResponse) SetStatusCode(v int32) *DescribeTagsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeTagsResponse) SetBody(v *DescribeTagsResponseBody) *DescribeTagsResponse {
	s.Body = v
	return s
}

type DescribeVRoutersRequest struct {
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of the page to return. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Maximum value: **50**. Default value: **10**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The region ID of the vRouter that you want to query.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the vRouter.
	VRouterId *string `json:"VRouterId,omitempty" xml:"VRouterId,omitempty"`
}

func (s DescribeVRoutersRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeVRoutersRequest) GoString() string {
	return s.String()
}

func (s *DescribeVRoutersRequest) SetOwnerAccount(v string) *DescribeVRoutersRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeVRoutersRequest) SetOwnerId(v int64) *DescribeVRoutersRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeVRoutersRequest) SetPageNumber(v int32) *DescribeVRoutersRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeVRoutersRequest) SetPageSize(v int32) *DescribeVRoutersRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeVRoutersRequest) SetRegionId(v string) *DescribeVRoutersRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeVRoutersRequest) SetResourceOwnerAccount(v string) *DescribeVRoutersRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeVRoutersRequest) SetResourceOwnerId(v int64) *DescribeVRoutersRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeVRoutersRequest) SetVRouterId(v string) *DescribeVRoutersRequest {
	s.VRouterId = &v
	return s
}

type DescribeVRoutersResponseBody struct {
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
	// The details about the vRouters.
	VRouters *DescribeVRoutersResponseBodyVRouters `json:"VRouters,omitempty" xml:"VRouters,omitempty" type:"Struct"`
}

func (s DescribeVRoutersResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeVRoutersResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeVRoutersResponseBody) SetPageNumber(v int32) *DescribeVRoutersResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeVRoutersResponseBody) SetPageSize(v int32) *DescribeVRoutersResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeVRoutersResponseBody) SetRequestId(v string) *DescribeVRoutersResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeVRoutersResponseBody) SetTotalCount(v int32) *DescribeVRoutersResponseBody {
	s.TotalCount = &v
	return s
}

func (s *DescribeVRoutersResponseBody) SetVRouters(v *DescribeVRoutersResponseBodyVRouters) *DescribeVRoutersResponseBody {
	s.VRouters = v
	return s
}

type DescribeVRoutersResponseBodyVRouters struct {
	VRouter []*DescribeVRoutersResponseBodyVRoutersVRouter `json:"VRouter,omitempty" xml:"VRouter,omitempty" type:"Repeated"`
}

func (s DescribeVRoutersResponseBodyVRouters) String() string {
	return tea.Prettify(s)
}

func (s DescribeVRoutersResponseBodyVRouters) GoString() string {
	return s.String()
}

func (s *DescribeVRoutersResponseBodyVRouters) SetVRouter(v []*DescribeVRoutersResponseBodyVRoutersVRouter) *DescribeVRoutersResponseBodyVRouters {
	s.VRouter = v
	return s
}

type DescribeVRoutersResponseBodyVRoutersVRouter struct {
	// The time when the vRouter was created.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The description of the vRouter.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The region to which the vRouter belongs.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the route table in the vRouter.
	RouteTableIds *DescribeVRoutersResponseBodyVRoutersVRouterRouteTableIds `json:"RouteTableIds,omitempty" xml:"RouteTableIds,omitempty" type:"Struct"`
	// The ID of the vRouter.
	VRouterId *string `json:"VRouterId,omitempty" xml:"VRouterId,omitempty"`
	// The name of the vRouter.
	VRouterName *string `json:"VRouterName,omitempty" xml:"VRouterName,omitempty"`
	// The ID of the virtual private cloud (VPC) to which the vRouter belongs.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s DescribeVRoutersResponseBodyVRoutersVRouter) String() string {
	return tea.Prettify(s)
}

func (s DescribeVRoutersResponseBodyVRoutersVRouter) GoString() string {
	return s.String()
}

func (s *DescribeVRoutersResponseBodyVRoutersVRouter) SetCreationTime(v string) *DescribeVRoutersResponseBodyVRoutersVRouter {
	s.CreationTime = &v
	return s
}

func (s *DescribeVRoutersResponseBodyVRoutersVRouter) SetDescription(v string) *DescribeVRoutersResponseBodyVRoutersVRouter {
	s.Description = &v
	return s
}

func (s *DescribeVRoutersResponseBodyVRoutersVRouter) SetRegionId(v string) *DescribeVRoutersResponseBodyVRoutersVRouter {
	s.RegionId = &v
	return s
}

func (s *DescribeVRoutersResponseBodyVRoutersVRouter) SetRouteTableIds(v *DescribeVRoutersResponseBodyVRoutersVRouterRouteTableIds) *DescribeVRoutersResponseBodyVRoutersVRouter {
	s.RouteTableIds = v
	return s
}

func (s *DescribeVRoutersResponseBodyVRoutersVRouter) SetVRouterId(v string) *DescribeVRoutersResponseBodyVRoutersVRouter {
	s.VRouterId = &v
	return s
}

func (s *DescribeVRoutersResponseBodyVRoutersVRouter) SetVRouterName(v string) *DescribeVRoutersResponseBodyVRoutersVRouter {
	s.VRouterName = &v
	return s
}

func (s *DescribeVRoutersResponseBodyVRoutersVRouter) SetVpcId(v string) *DescribeVRoutersResponseBodyVRoutersVRouter {
	s.VpcId = &v
	return s
}

type DescribeVRoutersResponseBodyVRoutersVRouterRouteTableIds struct {
	RouteTableId []*string `json:"RouteTableId,omitempty" xml:"RouteTableId,omitempty" type:"Repeated"`
}

func (s DescribeVRoutersResponseBodyVRoutersVRouterRouteTableIds) String() string {
	return tea.Prettify(s)
}

func (s DescribeVRoutersResponseBodyVRoutersVRouterRouteTableIds) GoString() string {
	return s.String()
}

func (s *DescribeVRoutersResponseBodyVRoutersVRouterRouteTableIds) SetRouteTableId(v []*string) *DescribeVRoutersResponseBodyVRoutersVRouterRouteTableIds {
	s.RouteTableId = v
	return s
}

type DescribeVRoutersResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeVRoutersResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeVRoutersResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeVRoutersResponse) GoString() string {
	return s.String()
}

func (s *DescribeVRoutersResponse) SetHeaders(v map[string]*string) *DescribeVRoutersResponse {
	s.Headers = v
	return s
}

func (s *DescribeVRoutersResponse) SetStatusCode(v int32) *DescribeVRoutersResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeVRoutersResponse) SetBody(v *DescribeVRoutersResponseBody) *DescribeVRoutersResponse {
	s.Body = v
	return s
}

type DescribeVSwitchAttributesRequest struct {
	// Specifies whether to perform a dry run. Valid values:
	//
	// *   **true**: performs a dry run. The system checks the required parameters, request syntax, and limits. If the request fails the dry run, an error message is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
	// *   **false** (default): sends a request and performs a dry run. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed.
	DryRun       *bool   `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the virtual private cloud (VPC) to which the route table belongs.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the vSwitch.
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
}

func (s DescribeVSwitchAttributesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeVSwitchAttributesRequest) GoString() string {
	return s.String()
}

func (s *DescribeVSwitchAttributesRequest) SetDryRun(v bool) *DescribeVSwitchAttributesRequest {
	s.DryRun = &v
	return s
}

func (s *DescribeVSwitchAttributesRequest) SetOwnerAccount(v string) *DescribeVSwitchAttributesRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeVSwitchAttributesRequest) SetOwnerId(v int64) *DescribeVSwitchAttributesRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeVSwitchAttributesRequest) SetRegionId(v string) *DescribeVSwitchAttributesRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeVSwitchAttributesRequest) SetResourceOwnerAccount(v string) *DescribeVSwitchAttributesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeVSwitchAttributesRequest) SetResourceOwnerId(v int64) *DescribeVSwitchAttributesRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeVSwitchAttributesRequest) SetVSwitchId(v string) *DescribeVSwitchAttributesRequest {
	s.VSwitchId = &v
	return s
}

type DescribeVSwitchAttributesResponseBody struct {
	// The number of available IP addresses.
	AvailableIpAddressCount *int64 `json:"AvailableIpAddressCount,omitempty" xml:"AvailableIpAddressCount,omitempty"`
	// The CIDR block of the vSwitch.
	CidrBlock *string `json:"CidrBlock,omitempty" xml:"CidrBlock,omitempty"`
	// The time when the vSwitch was created.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The description of the vSwitch.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	EnabledIpv6 *bool   `json:"EnabledIpv6,omitempty" xml:"EnabledIpv6,omitempty"`
	// The IPv6 CIDR block of the vSwitch.
	Ipv6CidrBlock *string `json:"Ipv6CidrBlock,omitempty" xml:"Ipv6CidrBlock,omitempty"`
	// Indicates whether the vSwitch is the default vSwitch. Valid values:
	//
	// *   **true**: yes
	// *   **false**: no
	IsDefault *bool `json:"IsDefault,omitempty" xml:"IsDefault,omitempty"`
	// The network access control list (ACL) rules.
	NetworkAclId *string `json:"NetworkAclId,omitempty" xml:"NetworkAclId,omitempty"`
	// The ID of the Alibaba Cloud account to which the vSwitch belongs.
	OwnerId *int64 `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The information about the route table that is associated with the vSwitch.
	RouteTable *DescribeVSwitchAttributesResponseBodyRouteTable `json:"RouteTable,omitempty" xml:"RouteTable,omitempty" type:"Struct"`
	ShareType  *string                                          `json:"ShareType,omitempty" xml:"ShareType,omitempty"`
	// The status of the vSwitch. Valid values:
	//
	// *   **Pending**
	// *   **Available**
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The tag list.
	Tags *DescribeVSwitchAttributesResponseBodyTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Struct"`
	// The ID of the vSwitch.
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
	// The name of the vSwitch.
	VSwitchName *string `json:"VSwitchName,omitempty" xml:"VSwitchName,omitempty"`
	// The ID of the VPC to which the vSwitch belongs.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
	// The ID of the zone to which the vSwitch belongs.
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
}

func (s DescribeVSwitchAttributesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeVSwitchAttributesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeVSwitchAttributesResponseBody) SetAvailableIpAddressCount(v int64) *DescribeVSwitchAttributesResponseBody {
	s.AvailableIpAddressCount = &v
	return s
}

func (s *DescribeVSwitchAttributesResponseBody) SetCidrBlock(v string) *DescribeVSwitchAttributesResponseBody {
	s.CidrBlock = &v
	return s
}

func (s *DescribeVSwitchAttributesResponseBody) SetCreationTime(v string) *DescribeVSwitchAttributesResponseBody {
	s.CreationTime = &v
	return s
}

func (s *DescribeVSwitchAttributesResponseBody) SetDescription(v string) *DescribeVSwitchAttributesResponseBody {
	s.Description = &v
	return s
}

func (s *DescribeVSwitchAttributesResponseBody) SetEnabledIpv6(v bool) *DescribeVSwitchAttributesResponseBody {
	s.EnabledIpv6 = &v
	return s
}

func (s *DescribeVSwitchAttributesResponseBody) SetIpv6CidrBlock(v string) *DescribeVSwitchAttributesResponseBody {
	s.Ipv6CidrBlock = &v
	return s
}

func (s *DescribeVSwitchAttributesResponseBody) SetIsDefault(v bool) *DescribeVSwitchAttributesResponseBody {
	s.IsDefault = &v
	return s
}

func (s *DescribeVSwitchAttributesResponseBody) SetNetworkAclId(v string) *DescribeVSwitchAttributesResponseBody {
	s.NetworkAclId = &v
	return s
}

func (s *DescribeVSwitchAttributesResponseBody) SetOwnerId(v int64) *DescribeVSwitchAttributesResponseBody {
	s.OwnerId = &v
	return s
}

func (s *DescribeVSwitchAttributesResponseBody) SetRequestId(v string) *DescribeVSwitchAttributesResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeVSwitchAttributesResponseBody) SetResourceGroupId(v string) *DescribeVSwitchAttributesResponseBody {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeVSwitchAttributesResponseBody) SetRouteTable(v *DescribeVSwitchAttributesResponseBodyRouteTable) *DescribeVSwitchAttributesResponseBody {
	s.RouteTable = v
	return s
}

func (s *DescribeVSwitchAttributesResponseBody) SetShareType(v string) *DescribeVSwitchAttributesResponseBody {
	s.ShareType = &v
	return s
}

func (s *DescribeVSwitchAttributesResponseBody) SetStatus(v string) *DescribeVSwitchAttributesResponseBody {
	s.Status = &v
	return s
}

func (s *DescribeVSwitchAttributesResponseBody) SetTags(v *DescribeVSwitchAttributesResponseBodyTags) *DescribeVSwitchAttributesResponseBody {
	s.Tags = v
	return s
}

func (s *DescribeVSwitchAttributesResponseBody) SetVSwitchId(v string) *DescribeVSwitchAttributesResponseBody {
	s.VSwitchId = &v
	return s
}

func (s *DescribeVSwitchAttributesResponseBody) SetVSwitchName(v string) *DescribeVSwitchAttributesResponseBody {
	s.VSwitchName = &v
	return s
}

func (s *DescribeVSwitchAttributesResponseBody) SetVpcId(v string) *DescribeVSwitchAttributesResponseBody {
	s.VpcId = &v
	return s
}

func (s *DescribeVSwitchAttributesResponseBody) SetZoneId(v string) *DescribeVSwitchAttributesResponseBody {
	s.ZoneId = &v
	return s
}

type DescribeVSwitchAttributesResponseBodyRouteTable struct {
	// The ID of the route table that is associated with the vSwitch.
	RouteTableId *string `json:"RouteTableId,omitempty" xml:"RouteTableId,omitempty"`
	// The type of the route table. Valid values:
	//
	// *   **System**: system route table
	// *   **Custom**: custom route table
	RouteTableType *string `json:"RouteTableType,omitempty" xml:"RouteTableType,omitempty"`
}

func (s DescribeVSwitchAttributesResponseBodyRouteTable) String() string {
	return tea.Prettify(s)
}

func (s DescribeVSwitchAttributesResponseBodyRouteTable) GoString() string {
	return s.String()
}

func (s *DescribeVSwitchAttributesResponseBodyRouteTable) SetRouteTableId(v string) *DescribeVSwitchAttributesResponseBodyRouteTable {
	s.RouteTableId = &v
	return s
}

func (s *DescribeVSwitchAttributesResponseBodyRouteTable) SetRouteTableType(v string) *DescribeVSwitchAttributesResponseBodyRouteTable {
	s.RouteTableType = &v
	return s
}

type DescribeVSwitchAttributesResponseBodyTags struct {
	Tag []*DescribeVSwitchAttributesResponseBodyTagsTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s DescribeVSwitchAttributesResponseBodyTags) String() string {
	return tea.Prettify(s)
}

func (s DescribeVSwitchAttributesResponseBodyTags) GoString() string {
	return s.String()
}

func (s *DescribeVSwitchAttributesResponseBodyTags) SetTag(v []*DescribeVSwitchAttributesResponseBodyTagsTag) *DescribeVSwitchAttributesResponseBodyTags {
	s.Tag = v
	return s
}

type DescribeVSwitchAttributesResponseBodyTagsTag struct {
	// The tag key.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeVSwitchAttributesResponseBodyTagsTag) String() string {
	return tea.Prettify(s)
}

func (s DescribeVSwitchAttributesResponseBodyTagsTag) GoString() string {
	return s.String()
}

func (s *DescribeVSwitchAttributesResponseBodyTagsTag) SetKey(v string) *DescribeVSwitchAttributesResponseBodyTagsTag {
	s.Key = &v
	return s
}

func (s *DescribeVSwitchAttributesResponseBodyTagsTag) SetValue(v string) *DescribeVSwitchAttributesResponseBodyTagsTag {
	s.Value = &v
	return s
}

type DescribeVSwitchAttributesResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeVSwitchAttributesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeVSwitchAttributesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeVSwitchAttributesResponse) GoString() string {
	return s.String()
}

func (s *DescribeVSwitchAttributesResponse) SetHeaders(v map[string]*string) *DescribeVSwitchAttributesResponse {
	s.Headers = v
	return s
}

func (s *DescribeVSwitchAttributesResponse) SetStatusCode(v int32) *DescribeVSwitchAttributesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeVSwitchAttributesResponse) SetBody(v *DescribeVSwitchAttributesResponseBody) *DescribeVSwitchAttributesResponse {
	s.Body = v
	return s
}

type DescribeVSwitchesRequest struct {
	// Specifies whether to check the request without performing the operation. Valid values:
	//
	// *   **true**: checks the request without performing the operation. The system checks the required parameters, request syntax, and limits. If the request fails check, an error message is returned. If the request passes the check, the `DryRunOperation` error code is returned.
	// *   **false**: sends the request. If the request passes the precheck, an HTTP 2xx status code is returned and the operation is performed. This is the default value.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// Specifies whether to query the default vSwitch in the specified region. Valid values:
	//
	// *   **true**: queries the default vSwitch in the specified region.
	// *   **false**: does not query the default vSwitch in the specified region.
	//
	// If you do not specify this parameter, the system queries all vSwitches in the specified region by default.
	IsDefault    *bool   `json:"IsDefault,omitempty" xml:"IsDefault,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of the page to return. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Maximum value: **50**. Default value: **10**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The region ID of the vSwitch. You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	//
	// >  You must set at least one of the **RegionId** and **VpcId** parameters.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group to which the vSwitch belongs.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the route table.
	RouteTableId *string                        `json:"RouteTableId,omitempty" xml:"RouteTableId,omitempty"`
	Tag          []*DescribeVSwitchesRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
	// The ID of the vSwitch that you want to query.
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
	// The name of the vSwitch.
	//
	// The name must be 1 to 128 characters in length, and cannot start with `http://` or `https://`.
	VSwitchName *string `json:"VSwitchName,omitempty" xml:"VSwitchName,omitempty"`
	// The ID of the Alibaba Cloud account to which the resource belongs.
	VSwitchOwnerId *int64 `json:"VSwitchOwnerId,omitempty" xml:"VSwitchOwnerId,omitempty"`
	// The ID of the VPC to which the vSwitches belong.
	//
	// >  You must set at least one of the **RegionId** and **VpcId** parameters.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
	// The ID of the zone to which the vSwitch belongs. You can call the [DescribeZones](~~36064~~) operation to query the most recent zone list.
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
}

func (s DescribeVSwitchesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeVSwitchesRequest) GoString() string {
	return s.String()
}

func (s *DescribeVSwitchesRequest) SetDryRun(v bool) *DescribeVSwitchesRequest {
	s.DryRun = &v
	return s
}

func (s *DescribeVSwitchesRequest) SetIsDefault(v bool) *DescribeVSwitchesRequest {
	s.IsDefault = &v
	return s
}

func (s *DescribeVSwitchesRequest) SetOwnerAccount(v string) *DescribeVSwitchesRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeVSwitchesRequest) SetOwnerId(v int64) *DescribeVSwitchesRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeVSwitchesRequest) SetPageNumber(v int32) *DescribeVSwitchesRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeVSwitchesRequest) SetPageSize(v int32) *DescribeVSwitchesRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeVSwitchesRequest) SetRegionId(v string) *DescribeVSwitchesRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeVSwitchesRequest) SetResourceGroupId(v string) *DescribeVSwitchesRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeVSwitchesRequest) SetResourceOwnerAccount(v string) *DescribeVSwitchesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeVSwitchesRequest) SetResourceOwnerId(v int64) *DescribeVSwitchesRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeVSwitchesRequest) SetRouteTableId(v string) *DescribeVSwitchesRequest {
	s.RouteTableId = &v
	return s
}

func (s *DescribeVSwitchesRequest) SetTag(v []*DescribeVSwitchesRequestTag) *DescribeVSwitchesRequest {
	s.Tag = v
	return s
}

func (s *DescribeVSwitchesRequest) SetVSwitchId(v string) *DescribeVSwitchesRequest {
	s.VSwitchId = &v
	return s
}

func (s *DescribeVSwitchesRequest) SetVSwitchName(v string) *DescribeVSwitchesRequest {
	s.VSwitchName = &v
	return s
}

func (s *DescribeVSwitchesRequest) SetVSwitchOwnerId(v int64) *DescribeVSwitchesRequest {
	s.VSwitchOwnerId = &v
	return s
}

func (s *DescribeVSwitchesRequest) SetVpcId(v string) *DescribeVSwitchesRequest {
	s.VpcId = &v
	return s
}

func (s *DescribeVSwitchesRequest) SetZoneId(v string) *DescribeVSwitchesRequest {
	s.ZoneId = &v
	return s
}

type DescribeVSwitchesRequestTag struct {
	Key   *string `json:"Key,omitempty" xml:"Key,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeVSwitchesRequestTag) String() string {
	return tea.Prettify(s)
}

func (s DescribeVSwitchesRequestTag) GoString() string {
	return s.String()
}

func (s *DescribeVSwitchesRequestTag) SetKey(v string) *DescribeVSwitchesRequestTag {
	s.Key = &v
	return s
}

func (s *DescribeVSwitchesRequestTag) SetValue(v string) *DescribeVSwitchesRequestTag {
	s.Value = &v
	return s
}

type DescribeVSwitchesResponseBody struct {
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
	// The details about the vSwitch.
	VSwitches *DescribeVSwitchesResponseBodyVSwitches `json:"VSwitches,omitempty" xml:"VSwitches,omitempty" type:"Struct"`
}

func (s DescribeVSwitchesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeVSwitchesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeVSwitchesResponseBody) SetPageNumber(v int32) *DescribeVSwitchesResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeVSwitchesResponseBody) SetPageSize(v int32) *DescribeVSwitchesResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeVSwitchesResponseBody) SetRequestId(v string) *DescribeVSwitchesResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeVSwitchesResponseBody) SetTotalCount(v int32) *DescribeVSwitchesResponseBody {
	s.TotalCount = &v
	return s
}

func (s *DescribeVSwitchesResponseBody) SetVSwitches(v *DescribeVSwitchesResponseBodyVSwitches) *DescribeVSwitchesResponseBody {
	s.VSwitches = v
	return s
}

type DescribeVSwitchesResponseBodyVSwitches struct {
	VSwitch []*DescribeVSwitchesResponseBodyVSwitchesVSwitch `json:"VSwitch,omitempty" xml:"VSwitch,omitempty" type:"Repeated"`
}

func (s DescribeVSwitchesResponseBodyVSwitches) String() string {
	return tea.Prettify(s)
}

func (s DescribeVSwitchesResponseBodyVSwitches) GoString() string {
	return s.String()
}

func (s *DescribeVSwitchesResponseBodyVSwitches) SetVSwitch(v []*DescribeVSwitchesResponseBodyVSwitchesVSwitch) *DescribeVSwitchesResponseBodyVSwitches {
	s.VSwitch = v
	return s
}

type DescribeVSwitchesResponseBodyVSwitchesVSwitch struct {
	// The number of available IP addresses in the vSwitch.
	AvailableIpAddressCount *int64 `json:"AvailableIpAddressCount,omitempty" xml:"AvailableIpAddressCount,omitempty"`
	// The IPv4 CIDR block of the vSwitch.
	CidrBlock *string `json:"CidrBlock,omitempty" xml:"CidrBlock,omitempty"`
	// The time when the vSwitch was created.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The description of the vSwitches.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	EnabledIpv6 *bool   `json:"EnabledIpv6,omitempty" xml:"EnabledIpv6,omitempty"`
	// The IPv6 CIDR block of the vSwitch.
	Ipv6CidrBlock *string `json:"Ipv6CidrBlock,omitempty" xml:"Ipv6CidrBlock,omitempty"`
	// Indicates whether the vSwitch is the default vSwitch. Valid values:
	//
	// *   **true**: The vSwitch is the default vSwitch.
	// *   **false**: The vSwitch is not the default vSwitch.
	IsDefault *bool `json:"IsDefault,omitempty" xml:"IsDefault,omitempty"`
	// The ID of the network access control list (ACL).
	NetworkAclId *string `json:"NetworkAclId,omitempty" xml:"NetworkAclId,omitempty"`
	// The ID of the Alibaba Cloud account to which the resource belongs.
	OwnerId *int64 `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the resource group to which the vSwitch belongs.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The information about the route table.
	RouteTable *DescribeVSwitchesResponseBodyVSwitchesVSwitchRouteTable `json:"RouteTable,omitempty" xml:"RouteTable,omitempty" type:"Struct"`
	ShareType  *string                                                  `json:"ShareType,omitempty" xml:"ShareType,omitempty"`
	// The status of the vSwitch. Valid values:
	//
	// *   **Pending**: The vSwitch is being configured.
	// *   **Available**: The vSwitch is available.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The tag information about the vSwitch.
	Tags *DescribeVSwitchesResponseBodyVSwitchesVSwitchTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Struct"`
	// The ID of the vSwitch.
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
	// The name of the vSwitch.
	VSwitchName *string `json:"VSwitchName,omitempty" xml:"VSwitchName,omitempty"`
	// The ID of the VPC to which the vSwitch belongs.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
	// The ID of the zone to which the vSwitch belongs.
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
}

func (s DescribeVSwitchesResponseBodyVSwitchesVSwitch) String() string {
	return tea.Prettify(s)
}

func (s DescribeVSwitchesResponseBodyVSwitchesVSwitch) GoString() string {
	return s.String()
}

func (s *DescribeVSwitchesResponseBodyVSwitchesVSwitch) SetAvailableIpAddressCount(v int64) *DescribeVSwitchesResponseBodyVSwitchesVSwitch {
	s.AvailableIpAddressCount = &v
	return s
}

func (s *DescribeVSwitchesResponseBodyVSwitchesVSwitch) SetCidrBlock(v string) *DescribeVSwitchesResponseBodyVSwitchesVSwitch {
	s.CidrBlock = &v
	return s
}

func (s *DescribeVSwitchesResponseBodyVSwitchesVSwitch) SetCreationTime(v string) *DescribeVSwitchesResponseBodyVSwitchesVSwitch {
	s.CreationTime = &v
	return s
}

func (s *DescribeVSwitchesResponseBodyVSwitchesVSwitch) SetDescription(v string) *DescribeVSwitchesResponseBodyVSwitchesVSwitch {
	s.Description = &v
	return s
}

func (s *DescribeVSwitchesResponseBodyVSwitchesVSwitch) SetEnabledIpv6(v bool) *DescribeVSwitchesResponseBodyVSwitchesVSwitch {
	s.EnabledIpv6 = &v
	return s
}

func (s *DescribeVSwitchesResponseBodyVSwitchesVSwitch) SetIpv6CidrBlock(v string) *DescribeVSwitchesResponseBodyVSwitchesVSwitch {
	s.Ipv6CidrBlock = &v
	return s
}

func (s *DescribeVSwitchesResponseBodyVSwitchesVSwitch) SetIsDefault(v bool) *DescribeVSwitchesResponseBodyVSwitchesVSwitch {
	s.IsDefault = &v
	return s
}

func (s *DescribeVSwitchesResponseBodyVSwitchesVSwitch) SetNetworkAclId(v string) *DescribeVSwitchesResponseBodyVSwitchesVSwitch {
	s.NetworkAclId = &v
	return s
}

func (s *DescribeVSwitchesResponseBodyVSwitchesVSwitch) SetOwnerId(v int64) *DescribeVSwitchesResponseBodyVSwitchesVSwitch {
	s.OwnerId = &v
	return s
}

func (s *DescribeVSwitchesResponseBodyVSwitchesVSwitch) SetResourceGroupId(v string) *DescribeVSwitchesResponseBodyVSwitchesVSwitch {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeVSwitchesResponseBodyVSwitchesVSwitch) SetRouteTable(v *DescribeVSwitchesResponseBodyVSwitchesVSwitchRouteTable) *DescribeVSwitchesResponseBodyVSwitchesVSwitch {
	s.RouteTable = v
	return s
}

func (s *DescribeVSwitchesResponseBodyVSwitchesVSwitch) SetShareType(v string) *DescribeVSwitchesResponseBodyVSwitchesVSwitch {
	s.ShareType = &v
	return s
}

func (s *DescribeVSwitchesResponseBodyVSwitchesVSwitch) SetStatus(v string) *DescribeVSwitchesResponseBodyVSwitchesVSwitch {
	s.Status = &v
	return s
}

func (s *DescribeVSwitchesResponseBodyVSwitchesVSwitch) SetTags(v *DescribeVSwitchesResponseBodyVSwitchesVSwitchTags) *DescribeVSwitchesResponseBodyVSwitchesVSwitch {
	s.Tags = v
	return s
}

func (s *DescribeVSwitchesResponseBodyVSwitchesVSwitch) SetVSwitchId(v string) *DescribeVSwitchesResponseBodyVSwitchesVSwitch {
	s.VSwitchId = &v
	return s
}

func (s *DescribeVSwitchesResponseBodyVSwitchesVSwitch) SetVSwitchName(v string) *DescribeVSwitchesResponseBodyVSwitchesVSwitch {
	s.VSwitchName = &v
	return s
}

func (s *DescribeVSwitchesResponseBodyVSwitchesVSwitch) SetVpcId(v string) *DescribeVSwitchesResponseBodyVSwitchesVSwitch {
	s.VpcId = &v
	return s
}

func (s *DescribeVSwitchesResponseBodyVSwitchesVSwitch) SetZoneId(v string) *DescribeVSwitchesResponseBodyVSwitchesVSwitch {
	s.ZoneId = &v
	return s
}

type DescribeVSwitchesResponseBodyVSwitchesVSwitchRouteTable struct {
	// The ID of the route table that is associated with the vSwitch.
	RouteTableId *string `json:"RouteTableId,omitempty" xml:"RouteTableId,omitempty"`
	// The type of the route table that is associated with the vSwitch. Valid values:
	//
	// - **System**: system route table
	// - **Custom**: custom route table
	RouteTableType *string `json:"RouteTableType,omitempty" xml:"RouteTableType,omitempty"`
}

func (s DescribeVSwitchesResponseBodyVSwitchesVSwitchRouteTable) String() string {
	return tea.Prettify(s)
}

func (s DescribeVSwitchesResponseBodyVSwitchesVSwitchRouteTable) GoString() string {
	return s.String()
}

func (s *DescribeVSwitchesResponseBodyVSwitchesVSwitchRouteTable) SetRouteTableId(v string) *DescribeVSwitchesResponseBodyVSwitchesVSwitchRouteTable {
	s.RouteTableId = &v
	return s
}

func (s *DescribeVSwitchesResponseBodyVSwitchesVSwitchRouteTable) SetRouteTableType(v string) *DescribeVSwitchesResponseBodyVSwitchesVSwitchRouteTable {
	s.RouteTableType = &v
	return s
}

type DescribeVSwitchesResponseBodyVSwitchesVSwitchTags struct {
	Tag []*DescribeVSwitchesResponseBodyVSwitchesVSwitchTagsTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s DescribeVSwitchesResponseBodyVSwitchesVSwitchTags) String() string {
	return tea.Prettify(s)
}

func (s DescribeVSwitchesResponseBodyVSwitchesVSwitchTags) GoString() string {
	return s.String()
}

func (s *DescribeVSwitchesResponseBodyVSwitchesVSwitchTags) SetTag(v []*DescribeVSwitchesResponseBodyVSwitchesVSwitchTagsTag) *DescribeVSwitchesResponseBodyVSwitchesVSwitchTags {
	s.Tag = v
	return s
}

type DescribeVSwitchesResponseBodyVSwitchesVSwitchTagsTag struct {
	// The key of the tag that is added to the vSwitch.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The value of the tag that is added to the vSwitch.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeVSwitchesResponseBodyVSwitchesVSwitchTagsTag) String() string {
	return tea.Prettify(s)
}

func (s DescribeVSwitchesResponseBodyVSwitchesVSwitchTagsTag) GoString() string {
	return s.String()
}

func (s *DescribeVSwitchesResponseBodyVSwitchesVSwitchTagsTag) SetKey(v string) *DescribeVSwitchesResponseBodyVSwitchesVSwitchTagsTag {
	s.Key = &v
	return s
}

func (s *DescribeVSwitchesResponseBodyVSwitchesVSwitchTagsTag) SetValue(v string) *DescribeVSwitchesResponseBodyVSwitchesVSwitchTagsTag {
	s.Value = &v
	return s
}

type DescribeVSwitchesResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeVSwitchesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeVSwitchesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeVSwitchesResponse) GoString() string {
	return s.String()
}

func (s *DescribeVSwitchesResponse) SetHeaders(v map[string]*string) *DescribeVSwitchesResponse {
	s.Headers = v
	return s
}

func (s *DescribeVSwitchesResponse) SetStatusCode(v int32) *DescribeVSwitchesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeVSwitchesResponse) SetBody(v *DescribeVSwitchesResponseBody) *DescribeVSwitchesResponse {
	s.Body = v
	return s
}

type DescribeVbrHaRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to precheck the request. Valid values:
	//
	// *   **true**: prechecks the request without performing the operation. The system checks the request format, instance status, and whether the required parameters are specified. An error message is returned if the request fails the precheck. If the request passes the precheck, `DRYRUN.SUCCESS` is returned.
	// *   **false**: prechecks the request. After the request passes the precheck, the operation is performed.
	DryRun       *bool   `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region where the VBR is deployed.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the VBR failover group.
	VbrHaId *string `json:"VbrHaId,omitempty" xml:"VbrHaId,omitempty"`
	// The ID of the VBR.
	VbrId *string `json:"VbrId,omitempty" xml:"VbrId,omitempty"`
}

func (s DescribeVbrHaRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeVbrHaRequest) GoString() string {
	return s.String()
}

func (s *DescribeVbrHaRequest) SetClientToken(v string) *DescribeVbrHaRequest {
	s.ClientToken = &v
	return s
}

func (s *DescribeVbrHaRequest) SetDryRun(v bool) *DescribeVbrHaRequest {
	s.DryRun = &v
	return s
}

func (s *DescribeVbrHaRequest) SetOwnerAccount(v string) *DescribeVbrHaRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeVbrHaRequest) SetOwnerId(v int64) *DescribeVbrHaRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeVbrHaRequest) SetRegionId(v string) *DescribeVbrHaRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeVbrHaRequest) SetResourceOwnerAccount(v string) *DescribeVbrHaRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeVbrHaRequest) SetResourceOwnerId(v int64) *DescribeVbrHaRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeVbrHaRequest) SetVbrHaId(v string) *DescribeVbrHaRequest {
	s.VbrHaId = &v
	return s
}

func (s *DescribeVbrHaRequest) SetVbrId(v string) *DescribeVbrHaRequest {
	s.VbrId = &v
	return s
}

type DescribeVbrHaResponseBody struct {
	// The time when the VBR was created.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The description of the VBR failover group.
	//
	// The description must be 2 to 256 characters in length. It must start with a letter and cannot start with `http://`or `https://`.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The name of the VBR failover group.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the other VBR in the VBR failover group.
	PeerVbrId *string `json:"PeerVbrId,omitempty" xml:"PeerVbrId,omitempty"`
	// The ID of the region where the VBR is deployed.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The state of the VBR failover group.
	//
	// *   **Creating**: The VBR failover group is being created.
	// *   **Active**: The VBR failover group is running as expected.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The ID of the VBR failover group.
	VbrHaId *string `json:"VbrHaId,omitempty" xml:"VbrHaId,omitempty"`
	// The ID of the VBR.
	VbrId *string `json:"VbrId,omitempty" xml:"VbrId,omitempty"`
}

func (s DescribeVbrHaResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeVbrHaResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeVbrHaResponseBody) SetCreationTime(v string) *DescribeVbrHaResponseBody {
	s.CreationTime = &v
	return s
}

func (s *DescribeVbrHaResponseBody) SetDescription(v string) *DescribeVbrHaResponseBody {
	s.Description = &v
	return s
}

func (s *DescribeVbrHaResponseBody) SetName(v string) *DescribeVbrHaResponseBody {
	s.Name = &v
	return s
}

func (s *DescribeVbrHaResponseBody) SetPeerVbrId(v string) *DescribeVbrHaResponseBody {
	s.PeerVbrId = &v
	return s
}

func (s *DescribeVbrHaResponseBody) SetRegionId(v string) *DescribeVbrHaResponseBody {
	s.RegionId = &v
	return s
}

func (s *DescribeVbrHaResponseBody) SetRequestId(v string) *DescribeVbrHaResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeVbrHaResponseBody) SetStatus(v string) *DescribeVbrHaResponseBody {
	s.Status = &v
	return s
}

func (s *DescribeVbrHaResponseBody) SetVbrHaId(v string) *DescribeVbrHaResponseBody {
	s.VbrHaId = &v
	return s
}

func (s *DescribeVbrHaResponseBody) SetVbrId(v string) *DescribeVbrHaResponseBody {
	s.VbrId = &v
	return s
}

type DescribeVbrHaResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeVbrHaResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeVbrHaResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeVbrHaResponse) GoString() string {
	return s.String()
}

func (s *DescribeVbrHaResponse) SetHeaders(v map[string]*string) *DescribeVbrHaResponse {
	s.Headers = v
	return s
}

func (s *DescribeVbrHaResponse) SetStatusCode(v int32) *DescribeVbrHaResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeVbrHaResponse) SetBody(v *DescribeVbrHaResponseBody) *DescribeVbrHaResponse {
	s.Body = v
	return s
}

type DescribeVcoRouteEntriesRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among all requests. ClientToken can contain only ASCII characters.
	//
	// >  If you do not set this parameter, the system uses **RequestId** as **ClientToken**. The value of **RequestId** for each API request may be different.
	ClientToken  *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	// The number of the page to return. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Default value: **10**. Valid values: **1** to **50**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The region ID of the IPsec-VPN connection.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent list of regions.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The route type. Valid values:
	//
	// *   **custom** (default): a destination-based route
	// *   **bgp**: a BGP route
	RouteEntryType *string `json:"RouteEntryType,omitempty" xml:"RouteEntryType,omitempty"`
	// The ID of the IPsec-VPN connection.
	VpnConnectionId *string `json:"VpnConnectionId,omitempty" xml:"VpnConnectionId,omitempty"`
}

func (s DescribeVcoRouteEntriesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeVcoRouteEntriesRequest) GoString() string {
	return s.String()
}

func (s *DescribeVcoRouteEntriesRequest) SetClientToken(v string) *DescribeVcoRouteEntriesRequest {
	s.ClientToken = &v
	return s
}

func (s *DescribeVcoRouteEntriesRequest) SetOwnerAccount(v string) *DescribeVcoRouteEntriesRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeVcoRouteEntriesRequest) SetPageNumber(v int32) *DescribeVcoRouteEntriesRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeVcoRouteEntriesRequest) SetPageSize(v int32) *DescribeVcoRouteEntriesRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeVcoRouteEntriesRequest) SetRegionId(v string) *DescribeVcoRouteEntriesRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeVcoRouteEntriesRequest) SetResourceOwnerAccount(v string) *DescribeVcoRouteEntriesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeVcoRouteEntriesRequest) SetResourceOwnerId(v int64) *DescribeVcoRouteEntriesRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeVcoRouteEntriesRequest) SetRouteEntryType(v string) *DescribeVcoRouteEntriesRequest {
	s.RouteEntryType = &v
	return s
}

func (s *DescribeVcoRouteEntriesRequest) SetVpnConnectionId(v string) *DescribeVcoRouteEntriesRequest {
	s.VpnConnectionId = &v
	return s
}

type DescribeVcoRouteEntriesResponseBody struct {
	// The number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
	// The list of routes.
	VcoRouteEntries []*DescribeVcoRouteEntriesResponseBodyVcoRouteEntries `json:"VcoRouteEntries,omitempty" xml:"VcoRouteEntries,omitempty" type:"Repeated"`
}

func (s DescribeVcoRouteEntriesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeVcoRouteEntriesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeVcoRouteEntriesResponseBody) SetPageNumber(v int32) *DescribeVcoRouteEntriesResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeVcoRouteEntriesResponseBody) SetPageSize(v int32) *DescribeVcoRouteEntriesResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeVcoRouteEntriesResponseBody) SetRequestId(v string) *DescribeVcoRouteEntriesResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeVcoRouteEntriesResponseBody) SetTotalCount(v int32) *DescribeVcoRouteEntriesResponseBody {
	s.TotalCount = &v
	return s
}

func (s *DescribeVcoRouteEntriesResponseBody) SetVcoRouteEntries(v []*DescribeVcoRouteEntriesResponseBodyVcoRouteEntries) *DescribeVcoRouteEntriesResponseBody {
	s.VcoRouteEntries = v
	return s
}

type DescribeVcoRouteEntriesResponseBodyVcoRouteEntries struct {
	// The list of autonomous system (AS) numbers that the BGP route goes through.
	AsPath *string `json:"AsPath,omitempty" xml:"AsPath,omitempty"`
	// The community value carried by the BGP route.
	Community *string `json:"Community,omitempty" xml:"Community,omitempty"`
	// The timestamp when the route was created.
	//
	// This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The next hop of the route.
	NextHop *string `json:"NextHop,omitempty" xml:"NextHop,omitempty"`
	// The destination CIDR block of the route.
	RouteDest *string `json:"RouteDest,omitempty" xml:"RouteDest,omitempty"`
	// The route type. Valid values:
	//
	// *   **custom**: a destination-based route
	// *   **bgp**: a BGP route
	RouteEntryType *string `json:"RouteEntryType,omitempty" xml:"RouteEntryType,omitempty"`
	// The source of the BGP route. Valid values:
	//
	// *   **CLOUD**: indicates that the current BGP route is learned by the IPsec-VPN connection from the transit router.
	// *   **VPN_BGP**: indicates that the current BGP route is learned by the IPsec-VPN connection from the data center.
	Source *string `json:"Source,omitempty" xml:"Source,omitempty"`
	// The status of the route.
	//
	// *   **published**: indicates that the current route is advertised to the transit router.
	// *   **Active**: indicates that the current BGP route is available.
	State *string `json:"State,omitempty" xml:"State,omitempty"`
	// The ID of the IPsec-VPN connection.
	VpnConnectionId *string `json:"VpnConnectionId,omitempty" xml:"VpnConnectionId,omitempty"`
	// The weight of the destination-based route. Valid values:
	//
	// *   **0**: a low priority
	// *   **100**: a high priority
	Weight *int32 `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s DescribeVcoRouteEntriesResponseBodyVcoRouteEntries) String() string {
	return tea.Prettify(s)
}

func (s DescribeVcoRouteEntriesResponseBodyVcoRouteEntries) GoString() string {
	return s.String()
}

func (s *DescribeVcoRouteEntriesResponseBodyVcoRouteEntries) SetAsPath(v string) *DescribeVcoRouteEntriesResponseBodyVcoRouteEntries {
	s.AsPath = &v
	return s
}

func (s *DescribeVcoRouteEntriesResponseBodyVcoRouteEntries) SetCommunity(v string) *DescribeVcoRouteEntriesResponseBodyVcoRouteEntries {
	s.Community = &v
	return s
}

func (s *DescribeVcoRouteEntriesResponseBodyVcoRouteEntries) SetCreateTime(v int64) *DescribeVcoRouteEntriesResponseBodyVcoRouteEntries {
	s.CreateTime = &v
	return s
}

func (s *DescribeVcoRouteEntriesResponseBodyVcoRouteEntries) SetNextHop(v string) *DescribeVcoRouteEntriesResponseBodyVcoRouteEntries {
	s.NextHop = &v
	return s
}

func (s *DescribeVcoRouteEntriesResponseBodyVcoRouteEntries) SetRouteDest(v string) *DescribeVcoRouteEntriesResponseBodyVcoRouteEntries {
	s.RouteDest = &v
	return s
}

func (s *DescribeVcoRouteEntriesResponseBodyVcoRouteEntries) SetRouteEntryType(v string) *DescribeVcoRouteEntriesResponseBodyVcoRouteEntries {
	s.RouteEntryType = &v
	return s
}

func (s *DescribeVcoRouteEntriesResponseBodyVcoRouteEntries) SetSource(v string) *DescribeVcoRouteEntriesResponseBodyVcoRouteEntries {
	s.Source = &v
	return s
}

func (s *DescribeVcoRouteEntriesResponseBodyVcoRouteEntries) SetState(v string) *DescribeVcoRouteEntriesResponseBodyVcoRouteEntries {
	s.State = &v
	return s
}

func (s *DescribeVcoRouteEntriesResponseBodyVcoRouteEntries) SetVpnConnectionId(v string) *DescribeVcoRouteEntriesResponseBodyVcoRouteEntries {
	s.VpnConnectionId = &v
	return s
}

func (s *DescribeVcoRouteEntriesResponseBodyVcoRouteEntries) SetWeight(v int32) *DescribeVcoRouteEntriesResponseBodyVcoRouteEntries {
	s.Weight = &v
	return s
}

type DescribeVcoRouteEntriesResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeVcoRouteEntriesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeVcoRouteEntriesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeVcoRouteEntriesResponse) GoString() string {
	return s.String()
}

func (s *DescribeVcoRouteEntriesResponse) SetHeaders(v map[string]*string) *DescribeVcoRouteEntriesResponse {
	s.Headers = v
	return s
}

func (s *DescribeVcoRouteEntriesResponse) SetStatusCode(v int32) *DescribeVcoRouteEntriesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeVcoRouteEntriesResponse) SetBody(v *DescribeVcoRouteEntriesResponseBody) *DescribeVcoRouteEntriesResponse {
	s.Body = v
	return s
}

type DescribeVirtualBorderRoutersRequest struct {
	Filter []*DescribeVirtualBorderRoutersRequestFilter `json:"Filter,omitempty" xml:"Filter,omitempty" type:"Repeated"`
	// Specifies whether cross-account VBRs are included.
	//
	// *   **true**: yes
	// *   **false**: no. This is the default value.
	IncludeCrossAccountVbr *bool  `json:"IncludeCrossAccountVbr,omitempty" xml:"IncludeCrossAccountVbr,omitempty"`
	OwnerId                *int64 `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of the page to return. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Maximum value: **50**. Default value: **10**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the region where the VBRs are deployed. You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string                                    `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceGroupId      *string                                    `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string                                    `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64                                     `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	Tags                 []*DescribeVirtualBorderRoutersRequestTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
}

func (s DescribeVirtualBorderRoutersRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeVirtualBorderRoutersRequest) GoString() string {
	return s.String()
}

func (s *DescribeVirtualBorderRoutersRequest) SetFilter(v []*DescribeVirtualBorderRoutersRequestFilter) *DescribeVirtualBorderRoutersRequest {
	s.Filter = v
	return s
}

func (s *DescribeVirtualBorderRoutersRequest) SetIncludeCrossAccountVbr(v bool) *DescribeVirtualBorderRoutersRequest {
	s.IncludeCrossAccountVbr = &v
	return s
}

func (s *DescribeVirtualBorderRoutersRequest) SetOwnerId(v int64) *DescribeVirtualBorderRoutersRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeVirtualBorderRoutersRequest) SetPageNumber(v int32) *DescribeVirtualBorderRoutersRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeVirtualBorderRoutersRequest) SetPageSize(v int32) *DescribeVirtualBorderRoutersRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeVirtualBorderRoutersRequest) SetRegionId(v string) *DescribeVirtualBorderRoutersRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeVirtualBorderRoutersRequest) SetResourceGroupId(v string) *DescribeVirtualBorderRoutersRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeVirtualBorderRoutersRequest) SetResourceOwnerAccount(v string) *DescribeVirtualBorderRoutersRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeVirtualBorderRoutersRequest) SetResourceOwnerId(v int64) *DescribeVirtualBorderRoutersRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeVirtualBorderRoutersRequest) SetTags(v []*DescribeVirtualBorderRoutersRequestTags) *DescribeVirtualBorderRoutersRequest {
	s.Tags = v
	return s
}

type DescribeVirtualBorderRoutersRequestFilter struct {
	// The filter conditions. You can specify at most five filter conditions. The following filter conditions are supported:
	//
	// *   **PhysicalConnectionId**: Filter by Express Connect circuit ID.
	// *   **VbrId**: Filter by VBR ID.
	// *   **Status**: Filter by VBR status.
	// *   **Name**: Filter by VBR name.
	// *   **AccessPointId**: Filter by access point ID.
	// *   **eccId**: Filter by Express Cloud Connect (ECC) instance ID.
	// *   **type**: Filter by Express Connect circuit type.
	Key   *string   `json:"Key,omitempty" xml:"Key,omitempty"`
	Value []*string `json:"Value,omitempty" xml:"Value,omitempty" type:"Repeated"`
}

func (s DescribeVirtualBorderRoutersRequestFilter) String() string {
	return tea.Prettify(s)
}

func (s DescribeVirtualBorderRoutersRequestFilter) GoString() string {
	return s.String()
}

func (s *DescribeVirtualBorderRoutersRequestFilter) SetKey(v string) *DescribeVirtualBorderRoutersRequestFilter {
	s.Key = &v
	return s
}

func (s *DescribeVirtualBorderRoutersRequestFilter) SetValue(v []*string) *DescribeVirtualBorderRoutersRequestFilter {
	s.Value = v
	return s
}

type DescribeVirtualBorderRoutersRequestTags struct {
	Key   *string `json:"Key,omitempty" xml:"Key,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeVirtualBorderRoutersRequestTags) String() string {
	return tea.Prettify(s)
}

func (s DescribeVirtualBorderRoutersRequestTags) GoString() string {
	return s.String()
}

func (s *DescribeVirtualBorderRoutersRequestTags) SetKey(v string) *DescribeVirtualBorderRoutersRequestTags {
	s.Key = &v
	return s
}

func (s *DescribeVirtualBorderRoutersRequestTags) SetValue(v string) *DescribeVirtualBorderRoutersRequestTags {
	s.Value = &v
	return s
}

type DescribeVirtualBorderRoutersResponseBody struct {
	// The number of the returned page. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page. Maximum value: **50**. Default value: **10**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
	// The information about the queried VBRs.
	VirtualBorderRouterSet *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSet `json:"VirtualBorderRouterSet,omitempty" xml:"VirtualBorderRouterSet,omitempty" type:"Struct"`
}

func (s DescribeVirtualBorderRoutersResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeVirtualBorderRoutersResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeVirtualBorderRoutersResponseBody) SetPageNumber(v int32) *DescribeVirtualBorderRoutersResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeVirtualBorderRoutersResponseBody) SetPageSize(v int32) *DescribeVirtualBorderRoutersResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeVirtualBorderRoutersResponseBody) SetRequestId(v string) *DescribeVirtualBorderRoutersResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeVirtualBorderRoutersResponseBody) SetTotalCount(v int32) *DescribeVirtualBorderRoutersResponseBody {
	s.TotalCount = &v
	return s
}

func (s *DescribeVirtualBorderRoutersResponseBody) SetVirtualBorderRouterSet(v *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSet) *DescribeVirtualBorderRoutersResponseBody {
	s.VirtualBorderRouterSet = v
	return s
}

type DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSet struct {
	VirtualBorderRouterType []*DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType `json:"VirtualBorderRouterType,omitempty" xml:"VirtualBorderRouterType,omitempty" type:"Repeated"`
}

func (s DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSet) String() string {
	return tea.Prettify(s)
}

func (s DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSet) GoString() string {
	return s.String()
}

func (s *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSet) SetVirtualBorderRouterType(v []*DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType) *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSet {
	s.VirtualBorderRouterType = v
	return s
}

type DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType struct {
	// The ID of the access point.
	AccessPointId *string `json:"AccessPointId,omitempty" xml:"AccessPointId,omitempty"`
	// The first time when the VBR was activated.
	ActivationTime *string `json:"ActivationTime,omitempty" xml:"ActivationTime,omitempty"`
	// The information about the Cloud Enterprise Network (CEN) instance to which the VBR is attached.
	AssociatedCens *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedCens `json:"AssociatedCens,omitempty" xml:"AssociatedCens,omitempty" type:"Struct"`
	// The information about the Express Connect circuit that is associated with the VBR.
	AssociatedPhysicalConnections *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedPhysicalConnections `json:"AssociatedPhysicalConnections,omitempty" xml:"AssociatedPhysicalConnections,omitempty" type:"Struct"`
	// The bandwidth of the VBR. Unit: Mbit/s.
	Bandwidth *int32 `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	// The circuit code of the Express Connect circuit. The circuit code is predefined by the connectivity provider.
	CircuitCode *string `json:"CircuitCode,omitempty" xml:"CircuitCode,omitempty"`
	// The ID of the cloud box.
	CloudBoxInstanceId *string `json:"CloudBoxInstanceId,omitempty" xml:"CloudBoxInstanceId,omitempty"`
	// The time when the VBR was created.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The description of the VBR.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The multiple of the detection time.
	//
	// This value indicates the maximum number of dropped packets that is allowed by the receiver when the initiator transmits packets. This value can be used to check whether the connection works as expected.
	//
	// Valid values: **3 to 10**.
	DetectMultiplier *int64 `json:"DetectMultiplier,omitempty" xml:"DetectMultiplier,omitempty"`
	// The ID of the ECC instance.
	EccId *string `json:"EccId,omitempty" xml:"EccId,omitempty"`
	// Indicates whether IPv6 is enabled. Valid values:
	//
	// *   **true**: enabled
	// *   **false**: disabled
	EnableIpv6 *bool `json:"EnableIpv6,omitempty" xml:"EnableIpv6,omitempty"`
	// The IPv4 address of the gateway device on the Alibaba Cloud side.
	LocalGatewayIp *string `json:"LocalGatewayIp,omitempty" xml:"LocalGatewayIp,omitempty"`
	// The IPv6 address of the gateway device on the Alibaba Cloud side.
	LocalIpv6GatewayIp *string `json:"LocalIpv6GatewayIp,omitempty" xml:"LocalIpv6GatewayIp,omitempty"`
	// The time interval to receive Bidirectional Forwarding Detection (BFD) packets. Valid values: **200 to 1000**. Unit: milliseconds.
	MinRxInterval *int64 `json:"MinRxInterval,omitempty" xml:"MinRxInterval,omitempty"`
	// The time interval to send Bidirectional Forwarding Detection (BFD) packets. Valid values: **200 to 1000**. Unit: milliseconds.
	MinTxInterval *int64 `json:"MinTxInterval,omitempty" xml:"MinTxInterval,omitempty"`
	// The name of the VBR.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The billing method of the VBR.
	//
	// *   **PrePaid**: subscription If you choose this billing method, make sure that your Alibaba Cloud account supports balance payments or credit payments.
	// *   **PostPaid**: pay-as-you-go
	PConnVbrChargeType *string `json:"PConnVbrChargeType,omitempty" xml:"PConnVbrChargeType,omitempty"`
	// The time when the VBR expires.
	PConnVbrExpireTime *string `json:"PConnVbrExpireTime,omitempty" xml:"PConnVbrExpireTime,omitempty"`
	// The IPv4 address of the VBR on the user side.
	PeerGatewayIp *string `json:"PeerGatewayIp,omitempty" xml:"PeerGatewayIp,omitempty"`
	// The IPv6 address of the gateway device on the user side.
	PeerIpv6GatewayIp *string `json:"PeerIpv6GatewayIp,omitempty" xml:"PeerIpv6GatewayIp,omitempty"`
	// The subnet mask of the IPv6 addresses configured on the user side and Alibaba Cloud side.
	PeeringIpv6SubnetMask *string `json:"PeeringIpv6SubnetMask,omitempty" xml:"PeeringIpv6SubnetMask,omitempty"`
	// The subnet mask of the IPv4 addresses configured on the user side and Alibaba Cloud side.
	PeeringSubnetMask *string `json:"PeeringSubnetMask,omitempty" xml:"PeeringSubnetMask,omitempty"`
	// The business status of the Express Connect circuit.
	//
	// *   **Normal**: normal
	// *   **FinancialLocked**: locked due to overdue payments
	PhysicalConnectionBusinessStatus *string `json:"PhysicalConnectionBusinessStatus,omitempty" xml:"PhysicalConnectionBusinessStatus,omitempty"`
	// The ID of the Express Connect circuit to which the VBR belongs.
	PhysicalConnectionId *string `json:"PhysicalConnectionId,omitempty" xml:"PhysicalConnectionId,omitempty"`
	// The UID of the Alibaba Cloud account to which the Express Connect circuit belongs.
	PhysicalConnectionOwnerUid *string `json:"PhysicalConnectionOwnerUid,omitempty" xml:"PhysicalConnectionOwnerUid,omitempty"`
	// The status of the Express Connect circuit.
	//
	// *   **Initial**: The application is under review.
	// *   **Approved**: The application is approved.
	// *   **Allocating**: The system is allocating resources.
	// *   **Allocated**: The Express Connect circuit is under construction.
	// *   **Confirmed**: The Express Connect circuit is pending for user confirmation.
	// *   **Enabled**: The Express Connect circuit is enabled.
	// *   **Rejected**: The application is rejected.
	// *   **Canceled**: The application is canceled.
	// *   **Allocation Failed**: The system failed to allocate resources.
	// *   **Terminated**: The Express Connect circuit is disabled.
	PhysicalConnectionStatus *string `json:"PhysicalConnectionStatus,omitempty" xml:"PhysicalConnectionStatus,omitempty"`
	// The last time when the status of the VBR changed from **terminated** to **active**.
	RecoveryTime    *string `json:"RecoveryTime,omitempty" xml:"RecoveryTime,omitempty"`
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The ID of the VBR route table.
	RouteTableId *string `json:"RouteTableId,omitempty" xml:"RouteTableId,omitempty"`
	// The status of the VBR. Valid values:
	//
	// *   **unconfirmed**: pending confirmation from other users
	// *   **active**: normal
	// *   **terminating**: being disabled
	// *   **terminated**: disabled
	// *   **recovering**: being enabled
	// *   **deleting:**: being deleted
	Status *string                                                                                    `json:"Status,omitempty" xml:"Status,omitempty"`
	Tags   *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Struct"`
	// The last time when the VBR was disabled.
	TerminationTime *string `json:"TerminationTime,omitempty" xml:"TerminationTime,omitempty"`
	// The type of the VBR.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The ID of the VBR.
	VbrId *string `json:"VbrId,omitempty" xml:"VbrId,omitempty"`
	// The VLAN ID of the VBR.
	VlanId *int32 `json:"VlanId,omitempty" xml:"VlanId,omitempty"`
	// The ID of the VBR interface.
	VlanInterfaceId *string `json:"VlanInterfaceId,omitempty" xml:"VlanInterfaceId,omitempty"`
}

func (s DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType) String() string {
	return tea.Prettify(s)
}

func (s DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType) GoString() string {
	return s.String()
}

func (s *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType) SetAccessPointId(v string) *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType {
	s.AccessPointId = &v
	return s
}

func (s *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType) SetActivationTime(v string) *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType {
	s.ActivationTime = &v
	return s
}

func (s *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType) SetAssociatedCens(v *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedCens) *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType {
	s.AssociatedCens = v
	return s
}

func (s *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType) SetAssociatedPhysicalConnections(v *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedPhysicalConnections) *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType {
	s.AssociatedPhysicalConnections = v
	return s
}

func (s *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType) SetBandwidth(v int32) *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType {
	s.Bandwidth = &v
	return s
}

func (s *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType) SetCircuitCode(v string) *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType {
	s.CircuitCode = &v
	return s
}

func (s *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType) SetCloudBoxInstanceId(v string) *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType {
	s.CloudBoxInstanceId = &v
	return s
}

func (s *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType) SetCreationTime(v string) *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType {
	s.CreationTime = &v
	return s
}

func (s *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType) SetDescription(v string) *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType {
	s.Description = &v
	return s
}

func (s *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType) SetDetectMultiplier(v int64) *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType {
	s.DetectMultiplier = &v
	return s
}

func (s *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType) SetEccId(v string) *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType {
	s.EccId = &v
	return s
}

func (s *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType) SetEnableIpv6(v bool) *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType {
	s.EnableIpv6 = &v
	return s
}

func (s *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType) SetLocalGatewayIp(v string) *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType {
	s.LocalGatewayIp = &v
	return s
}

func (s *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType) SetLocalIpv6GatewayIp(v string) *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType {
	s.LocalIpv6GatewayIp = &v
	return s
}

func (s *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType) SetMinRxInterval(v int64) *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType {
	s.MinRxInterval = &v
	return s
}

func (s *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType) SetMinTxInterval(v int64) *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType {
	s.MinTxInterval = &v
	return s
}

func (s *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType) SetName(v string) *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType {
	s.Name = &v
	return s
}

func (s *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType) SetPConnVbrChargeType(v string) *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType {
	s.PConnVbrChargeType = &v
	return s
}

func (s *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType) SetPConnVbrExpireTime(v string) *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType {
	s.PConnVbrExpireTime = &v
	return s
}

func (s *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType) SetPeerGatewayIp(v string) *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType {
	s.PeerGatewayIp = &v
	return s
}

func (s *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType) SetPeerIpv6GatewayIp(v string) *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType {
	s.PeerIpv6GatewayIp = &v
	return s
}

func (s *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType) SetPeeringIpv6SubnetMask(v string) *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType {
	s.PeeringIpv6SubnetMask = &v
	return s
}

func (s *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType) SetPeeringSubnetMask(v string) *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType {
	s.PeeringSubnetMask = &v
	return s
}

func (s *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType) SetPhysicalConnectionBusinessStatus(v string) *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType {
	s.PhysicalConnectionBusinessStatus = &v
	return s
}

func (s *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType) SetPhysicalConnectionId(v string) *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType {
	s.PhysicalConnectionId = &v
	return s
}

func (s *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType) SetPhysicalConnectionOwnerUid(v string) *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType {
	s.PhysicalConnectionOwnerUid = &v
	return s
}

func (s *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType) SetPhysicalConnectionStatus(v string) *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType {
	s.PhysicalConnectionStatus = &v
	return s
}

func (s *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType) SetRecoveryTime(v string) *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType {
	s.RecoveryTime = &v
	return s
}

func (s *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType) SetResourceGroupId(v string) *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType) SetRouteTableId(v string) *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType {
	s.RouteTableId = &v
	return s
}

func (s *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType) SetStatus(v string) *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType {
	s.Status = &v
	return s
}

func (s *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType) SetTags(v *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeTags) *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType {
	s.Tags = v
	return s
}

func (s *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType) SetTerminationTime(v string) *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType {
	s.TerminationTime = &v
	return s
}

func (s *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType) SetType(v string) *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType {
	s.Type = &v
	return s
}

func (s *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType) SetVbrId(v string) *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType {
	s.VbrId = &v
	return s
}

func (s *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType) SetVlanId(v int32) *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType {
	s.VlanId = &v
	return s
}

func (s *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType) SetVlanInterfaceId(v string) *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType {
	s.VlanInterfaceId = &v
	return s
}

type DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedCens struct {
	AssociatedCen []*DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedCensAssociatedCen `json:"AssociatedCen,omitempty" xml:"AssociatedCen,omitempty" type:"Repeated"`
}

func (s DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedCens) String() string {
	return tea.Prettify(s)
}

func (s DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedCens) GoString() string {
	return s.String()
}

func (s *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedCens) SetAssociatedCen(v []*DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedCensAssociatedCen) *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedCens {
	s.AssociatedCen = v
	return s
}

type DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedCensAssociatedCen struct {
	// The ID of the CEN instance.
	CenId *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	// The user ID (UID) of the Alibaba Cloud account to which the CEN instance belongs.
	CenOwnerId *int64 `json:"CenOwnerId,omitempty" xml:"CenOwnerId,omitempty"`
	// The status of the CEN instance. Valid values:
	//
	// - **Attached**: The VBR is attached to the CEN instance.
	// - **Attaching**: The VBR is being attached to the CEN instance.
	// - **Detached**: The VBR is detached from the CEN instance.
	// - **Detaching**: The VBR is being detached from the CEN instance.
	// - If no value is returned, the VBR is not attached to a CEN instance.
	CenStatus *string `json:"CenStatus,omitempty" xml:"CenStatus,omitempty"`
}

func (s DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedCensAssociatedCen) String() string {
	return tea.Prettify(s)
}

func (s DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedCensAssociatedCen) GoString() string {
	return s.String()
}

func (s *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedCensAssociatedCen) SetCenId(v string) *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedCensAssociatedCen {
	s.CenId = &v
	return s
}

func (s *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedCensAssociatedCen) SetCenOwnerId(v int64) *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedCensAssociatedCen {
	s.CenOwnerId = &v
	return s
}

func (s *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedCensAssociatedCen) SetCenStatus(v string) *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedCensAssociatedCen {
	s.CenStatus = &v
	return s
}

type DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedPhysicalConnections struct {
	AssociatedPhysicalConnection []*DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedPhysicalConnectionsAssociatedPhysicalConnection `json:"AssociatedPhysicalConnection,omitempty" xml:"AssociatedPhysicalConnection,omitempty" type:"Repeated"`
}

func (s DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedPhysicalConnections) String() string {
	return tea.Prettify(s)
}

func (s DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedPhysicalConnections) GoString() string {
	return s.String()
}

func (s *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedPhysicalConnections) SetAssociatedPhysicalConnection(v []*DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedPhysicalConnectionsAssociatedPhysicalConnection) *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedPhysicalConnections {
	s.AssociatedPhysicalConnection = v
	return s
}

type DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedPhysicalConnectionsAssociatedPhysicalConnection struct {
	// The circuit code of the Express Connect circuit. The circuit code is predefined by the connectivity provider.
	CircuitCode *string `json:"CircuitCode,omitempty" xml:"CircuitCode,omitempty"`
	// Indicates whether IPv6 is enabled. Valid values:
	//
	// *   **true**: enabled.
	// *   **false**: disabled.
	EnableIpv6 *bool `json:"EnableIpv6,omitempty" xml:"EnableIpv6,omitempty"`
	// The IPv4 address of the gateway device on the Alibaba Cloud side.
	LocalGatewayIp *string `json:"LocalGatewayIp,omitempty" xml:"LocalGatewayIp,omitempty"`
	// The IPv6 address of the gateway device on the Alibaba Cloud side.
	LocalIpv6GatewayIp *string `json:"LocalIpv6GatewayIp,omitempty" xml:"LocalIpv6GatewayIp,omitempty"`
	// The IPv4 address of the VBR on the user side.
	PeerGatewayIp *string `json:"PeerGatewayIp,omitempty" xml:"PeerGatewayIp,omitempty"`
	// The IPv6 address of the gateway device in the data center.
	PeerIpv6GatewayIp *string `json:"PeerIpv6GatewayIp,omitempty" xml:"PeerIpv6GatewayIp,omitempty"`
	// The subnet mask for the IPv6 addresses of the gateway devices on the Alibaba Cloud side and on the user side.
	//
	// The two IPv6 addresses must fall within the same subnet.
	PeeringIpv6SubnetMask *string `json:"PeeringIpv6SubnetMask,omitempty" xml:"PeeringIpv6SubnetMask,omitempty"`
	// The subnet mask for the IPv4 addresses of the gateway devices on the Alibaba Cloud side and on the user side.
	//
	// The two IPv4 addresses must fall within the same subnet.
	PeeringSubnetMask *string `json:"PeeringSubnetMask,omitempty" xml:"PeeringSubnetMask,omitempty"`
	// The business status of the Express Connect circuit.
	//
	// *   **Normal**: normal
	// *   **FinancialLocked**: locked due to overdue payments
	PhysicalConnectionBusinessStatus *string `json:"PhysicalConnectionBusinessStatus,omitempty" xml:"PhysicalConnectionBusinessStatus,omitempty"`
	// The ID of the Express Connect circuit.
	PhysicalConnectionId *string `json:"PhysicalConnectionId,omitempty" xml:"PhysicalConnectionId,omitempty"`
	// The UID of the Alibaba Cloud account to which the Express Connect circuit belongs.
	PhysicalConnectionOwnerUid *string `json:"PhysicalConnectionOwnerUid,omitempty" xml:"PhysicalConnectionOwnerUid,omitempty"`
	// The status of the Express Connect circuit.
	//
	// *   **Initial**: The application is under review.
	// *   **Approved**: The application is approved.
	// *   **Allocating**: The system is allocating resources.
	// *   **Allocated**: The Express Connect circuit is under construction.
	// *   **Confirmed**: The Express Connect circuit is pending for user confirmation.
	// *   **Enabled**: The Express Connect circuit is enabled.
	// *   **Rejected**: The application is rejected.
	// *   **Canceled**: The application is canceled.
	// *   **Allocation Failed**: The system failed to allocate resources.
	// *   **Terminated**: The Express Connect circuit is disabled.
	PhysicalConnectionStatus *string `json:"PhysicalConnectionStatus,omitempty" xml:"PhysicalConnectionStatus,omitempty"`
	// The status of the VBR. Valid values:
	//
	// *   **unconfirmed**: pending confirmation from other users
	// *   **active**: normal
	// *   **terminating**: being disabled
	// *   **terminated**: disabled
	// *   **recovering**: being enabled
	// *   **deleting:** The endpoint is being deleted.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The VLAN ID of the VBR.
	VlanId *string `json:"VlanId,omitempty" xml:"VlanId,omitempty"`
	// The ID of the VBR interface, which can be used as the next hop of a VBR route.
	VlanInterfaceId *string `json:"VlanInterfaceId,omitempty" xml:"VlanInterfaceId,omitempty"`
}

func (s DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedPhysicalConnectionsAssociatedPhysicalConnection) String() string {
	return tea.Prettify(s)
}

func (s DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedPhysicalConnectionsAssociatedPhysicalConnection) GoString() string {
	return s.String()
}

func (s *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedPhysicalConnectionsAssociatedPhysicalConnection) SetCircuitCode(v string) *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedPhysicalConnectionsAssociatedPhysicalConnection {
	s.CircuitCode = &v
	return s
}

func (s *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedPhysicalConnectionsAssociatedPhysicalConnection) SetEnableIpv6(v bool) *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedPhysicalConnectionsAssociatedPhysicalConnection {
	s.EnableIpv6 = &v
	return s
}

func (s *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedPhysicalConnectionsAssociatedPhysicalConnection) SetLocalGatewayIp(v string) *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedPhysicalConnectionsAssociatedPhysicalConnection {
	s.LocalGatewayIp = &v
	return s
}

func (s *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedPhysicalConnectionsAssociatedPhysicalConnection) SetLocalIpv6GatewayIp(v string) *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedPhysicalConnectionsAssociatedPhysicalConnection {
	s.LocalIpv6GatewayIp = &v
	return s
}

func (s *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedPhysicalConnectionsAssociatedPhysicalConnection) SetPeerGatewayIp(v string) *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedPhysicalConnectionsAssociatedPhysicalConnection {
	s.PeerGatewayIp = &v
	return s
}

func (s *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedPhysicalConnectionsAssociatedPhysicalConnection) SetPeerIpv6GatewayIp(v string) *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedPhysicalConnectionsAssociatedPhysicalConnection {
	s.PeerIpv6GatewayIp = &v
	return s
}

func (s *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedPhysicalConnectionsAssociatedPhysicalConnection) SetPeeringIpv6SubnetMask(v string) *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedPhysicalConnectionsAssociatedPhysicalConnection {
	s.PeeringIpv6SubnetMask = &v
	return s
}

func (s *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedPhysicalConnectionsAssociatedPhysicalConnection) SetPeeringSubnetMask(v string) *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedPhysicalConnectionsAssociatedPhysicalConnection {
	s.PeeringSubnetMask = &v
	return s
}

func (s *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedPhysicalConnectionsAssociatedPhysicalConnection) SetPhysicalConnectionBusinessStatus(v string) *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedPhysicalConnectionsAssociatedPhysicalConnection {
	s.PhysicalConnectionBusinessStatus = &v
	return s
}

func (s *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedPhysicalConnectionsAssociatedPhysicalConnection) SetPhysicalConnectionId(v string) *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedPhysicalConnectionsAssociatedPhysicalConnection {
	s.PhysicalConnectionId = &v
	return s
}

func (s *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedPhysicalConnectionsAssociatedPhysicalConnection) SetPhysicalConnectionOwnerUid(v string) *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedPhysicalConnectionsAssociatedPhysicalConnection {
	s.PhysicalConnectionOwnerUid = &v
	return s
}

func (s *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedPhysicalConnectionsAssociatedPhysicalConnection) SetPhysicalConnectionStatus(v string) *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedPhysicalConnectionsAssociatedPhysicalConnection {
	s.PhysicalConnectionStatus = &v
	return s
}

func (s *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedPhysicalConnectionsAssociatedPhysicalConnection) SetStatus(v string) *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedPhysicalConnectionsAssociatedPhysicalConnection {
	s.Status = &v
	return s
}

func (s *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedPhysicalConnectionsAssociatedPhysicalConnection) SetVlanId(v string) *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedPhysicalConnectionsAssociatedPhysicalConnection {
	s.VlanId = &v
	return s
}

func (s *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedPhysicalConnectionsAssociatedPhysicalConnection) SetVlanInterfaceId(v string) *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedPhysicalConnectionsAssociatedPhysicalConnection {
	s.VlanInterfaceId = &v
	return s
}

type DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeTags struct {
	Tags []*DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeTagsTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
}

func (s DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeTags) String() string {
	return tea.Prettify(s)
}

func (s DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeTags) GoString() string {
	return s.String()
}

func (s *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeTags) SetTags(v []*DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeTagsTags) *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeTags {
	s.Tags = v
	return s
}

type DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeTagsTags struct {
	Key   *string `json:"Key,omitempty" xml:"Key,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeTagsTags) String() string {
	return tea.Prettify(s)
}

func (s DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeTagsTags) GoString() string {
	return s.String()
}

func (s *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeTagsTags) SetKey(v string) *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeTagsTags {
	s.Key = &v
	return s
}

func (s *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeTagsTags) SetValue(v string) *DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeTagsTags {
	s.Value = &v
	return s
}

type DescribeVirtualBorderRoutersResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeVirtualBorderRoutersResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeVirtualBorderRoutersResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeVirtualBorderRoutersResponse) GoString() string {
	return s.String()
}

func (s *DescribeVirtualBorderRoutersResponse) SetHeaders(v map[string]*string) *DescribeVirtualBorderRoutersResponse {
	s.Headers = v
	return s
}

func (s *DescribeVirtualBorderRoutersResponse) SetStatusCode(v int32) *DescribeVirtualBorderRoutersResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeVirtualBorderRoutersResponse) SetBody(v *DescribeVirtualBorderRoutersResponseBody) *DescribeVirtualBorderRoutersResponse {
	s.Body = v
	return s
}

type DescribeVirtualBorderRoutersForPhysicalConnectionRequest struct {
	// 25425
	Filter  []*DescribeVirtualBorderRoutersForPhysicalConnectionRequestFilter `json:"Filter,omitempty" xml:"Filter,omitempty" type:"Repeated"`
	OwnerId *int64                                                            `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of the page to return. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Maximum value: **50**. Default value: **10**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the Express Connect circuit.
	PhysicalConnectionId *string `json:"PhysicalConnectionId,omitempty" xml:"PhysicalConnectionId,omitempty"`
	// The region where the Express Connect circuit is deployed. You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeVirtualBorderRoutersForPhysicalConnectionRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeVirtualBorderRoutersForPhysicalConnectionRequest) GoString() string {
	return s.String()
}

func (s *DescribeVirtualBorderRoutersForPhysicalConnectionRequest) SetFilter(v []*DescribeVirtualBorderRoutersForPhysicalConnectionRequestFilter) *DescribeVirtualBorderRoutersForPhysicalConnectionRequest {
	s.Filter = v
	return s
}

func (s *DescribeVirtualBorderRoutersForPhysicalConnectionRequest) SetOwnerId(v int64) *DescribeVirtualBorderRoutersForPhysicalConnectionRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeVirtualBorderRoutersForPhysicalConnectionRequest) SetPageNumber(v int32) *DescribeVirtualBorderRoutersForPhysicalConnectionRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeVirtualBorderRoutersForPhysicalConnectionRequest) SetPageSize(v int32) *DescribeVirtualBorderRoutersForPhysicalConnectionRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeVirtualBorderRoutersForPhysicalConnectionRequest) SetPhysicalConnectionId(v string) *DescribeVirtualBorderRoutersForPhysicalConnectionRequest {
	s.PhysicalConnectionId = &v
	return s
}

func (s *DescribeVirtualBorderRoutersForPhysicalConnectionRequest) SetRegionId(v string) *DescribeVirtualBorderRoutersForPhysicalConnectionRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeVirtualBorderRoutersForPhysicalConnectionRequest) SetResourceOwnerAccount(v string) *DescribeVirtualBorderRoutersForPhysicalConnectionRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeVirtualBorderRoutersForPhysicalConnectionRequest) SetResourceOwnerId(v int64) *DescribeVirtualBorderRoutersForPhysicalConnectionRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeVirtualBorderRoutersForPhysicalConnectionRequestFilter struct {
	// The filter conditions. You can specify at most five filter conditions. The following filter conditions are supported:
	//
	// *   **PhysicalConnectionId**: Filter by Express Connect circuit ID.
	// *   **VbrId**: Filter by VBR ID.
	// *   **Status**: Filter by VBR status.
	// *   **Name**: Filter by VBR name.
	// *   **AccessPointId**: Filter by access point ID.
	// *   **eccId**: Filter by Express Cloud Connect (ECC) instance ID.
	// *   **type**: Filter by VBR type.
	Key   *string   `json:"Key,omitempty" xml:"Key,omitempty"`
	Value []*string `json:"Value,omitempty" xml:"Value,omitempty" type:"Repeated"`
}

func (s DescribeVirtualBorderRoutersForPhysicalConnectionRequestFilter) String() string {
	return tea.Prettify(s)
}

func (s DescribeVirtualBorderRoutersForPhysicalConnectionRequestFilter) GoString() string {
	return s.String()
}

func (s *DescribeVirtualBorderRoutersForPhysicalConnectionRequestFilter) SetKey(v string) *DescribeVirtualBorderRoutersForPhysicalConnectionRequestFilter {
	s.Key = &v
	return s
}

func (s *DescribeVirtualBorderRoutersForPhysicalConnectionRequestFilter) SetValue(v []*string) *DescribeVirtualBorderRoutersForPhysicalConnectionRequestFilter {
	s.Value = v
	return s
}

type DescribeVirtualBorderRoutersForPhysicalConnectionResponseBody struct {
	// The page number of the returned page. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page. Maximum value: **50**. Default value: **10**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
	// The information about VBRs.
	VirtualBorderRouterForPhysicalConnectionSet *DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSet `json:"VirtualBorderRouterForPhysicalConnectionSet,omitempty" xml:"VirtualBorderRouterForPhysicalConnectionSet,omitempty" type:"Struct"`
}

func (s DescribeVirtualBorderRoutersForPhysicalConnectionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeVirtualBorderRoutersForPhysicalConnectionResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeVirtualBorderRoutersForPhysicalConnectionResponseBody) SetPageNumber(v int32) *DescribeVirtualBorderRoutersForPhysicalConnectionResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeVirtualBorderRoutersForPhysicalConnectionResponseBody) SetPageSize(v int32) *DescribeVirtualBorderRoutersForPhysicalConnectionResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeVirtualBorderRoutersForPhysicalConnectionResponseBody) SetRequestId(v string) *DescribeVirtualBorderRoutersForPhysicalConnectionResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeVirtualBorderRoutersForPhysicalConnectionResponseBody) SetTotalCount(v int32) *DescribeVirtualBorderRoutersForPhysicalConnectionResponseBody {
	s.TotalCount = &v
	return s
}

func (s *DescribeVirtualBorderRoutersForPhysicalConnectionResponseBody) SetVirtualBorderRouterForPhysicalConnectionSet(v *DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSet) *DescribeVirtualBorderRoutersForPhysicalConnectionResponseBody {
	s.VirtualBorderRouterForPhysicalConnectionSet = v
	return s
}

type DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSet struct {
	VirtualBorderRouterForPhysicalConnectionType []*DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSetVirtualBorderRouterForPhysicalConnectionType `json:"VirtualBorderRouterForPhysicalConnectionType,omitempty" xml:"VirtualBorderRouterForPhysicalConnectionType,omitempty" type:"Repeated"`
}

func (s DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSet) String() string {
	return tea.Prettify(s)
}

func (s DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSet) GoString() string {
	return s.String()
}

func (s *DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSet) SetVirtualBorderRouterForPhysicalConnectionType(v []*DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSetVirtualBorderRouterForPhysicalConnectionType) *DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSet {
	s.VirtualBorderRouterForPhysicalConnectionType = v
	return s
}

type DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSetVirtualBorderRouterForPhysicalConnectionType struct {
	// The first time when the VBR was activated.
	ActivationTime *string `json:"ActivationTime,omitempty" xml:"ActivationTime,omitempty"`
	// The bandwidth of the VBR associated with the Express Connect circuit. Unit: Mbit/s.
	Bandwidth *string `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	// The status of the bandwidth. Valid values:
	//
	// *   **Active**: normal
	// *   **Inactive**: abnormal
	BandwidthStatus *string `json:"BandwidthStatus,omitempty" xml:"BandwidthStatus,omitempty"`
	// The circuit code of the Express Connect circuit. The circuit code is predefined by the connectivity provider.
	CircuitCode *string `json:"CircuitCode,omitempty" xml:"CircuitCode,omitempty"`
	// The time when the VBR was created.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The ID of the ECC instance.
	EccId *string `json:"EccId,omitempty" xml:"EccId,omitempty"`
	// Indicates whether IPv6 is enabled. Valid values:
	//
	// *   **true**: yes
	// *   **false**: no
	EnableIpv6 *bool `json:"EnableIpv6,omitempty" xml:"EnableIpv6,omitempty"`
	// The IPv4 address of the VBR.
	LocalGatewayIp *string `json:"LocalGatewayIp,omitempty" xml:"LocalGatewayIp,omitempty"`
	// The IPv6 address of the VBR.
	LocalIpv6GatewayIp *string `json:"LocalIpv6GatewayIp,omitempty" xml:"LocalIpv6GatewayIp,omitempty"`
	// The status of the VBR associated with the Express Connect circuit. Valid values:
	//
	// *   **Normal**: normal
	// *   **FinancialLocked**: locked due to overdue payments
	PConnVbrBussinessStatus *string `json:"PConnVbrBussinessStatus,omitempty" xml:"PConnVbrBussinessStatus,omitempty"`
	// The billing method of the VBR that is associated with the Express Connect circuit. Valid values:
	//
	// *   **PrePaid**: subscription If you choose this billing method, make sure that your Alibaba Cloud account supports balance payments or credit payments.
	// *   **PostPaid**: pay-as-you-go
	PConnVbrChargeType *string `json:"PConnVbrChargeType,omitempty" xml:"PConnVbrChargeType,omitempty"`
	// The time when the VBR associated with the Express Connect circuit expires.
	PConnVbrExpireTime *string `json:"PConnVbrExpireTime,omitempty" xml:"PConnVbrExpireTime,omitempty"`
	// The IPv4 address of the gateway device in the data center.
	PeerGatewayIp *string `json:"PeerGatewayIp,omitempty" xml:"PeerGatewayIp,omitempty"`
	// The IPv6 address of the gateway device in the data center.
	//
	// This parameter is required when you create a VBR for the owner of the Express Connect circuit. You can ignore this parameter when you create a VBR for another Alibaba Cloud account.
	PeerIpv6GatewayIp *string `json:"PeerIpv6GatewayIp,omitempty" xml:"PeerIpv6GatewayIp,omitempty"`
	// The subnet mask for the IPv6 addresses of the gateway devices in the data center and the VBRs.
	//
	// The two IPv6 addresses must fall within the same subnet.
	PeeringIpv6SubnetMask *string `json:"PeeringIpv6SubnetMask,omitempty" xml:"PeeringIpv6SubnetMask,omitempty"`
	// The subnet mask for the IPv4 addresses of the gateway device in the data center and the VBR.
	//
	// The two IPv4 addresses must fall within the same subnet.
	PeeringSubnetMask *string `json:"PeeringSubnetMask,omitempty" xml:"PeeringSubnetMask,omitempty"`
	// The last time when the status of the VBR changed from Terminated to Active.
	RecoveryTime *string `json:"RecoveryTime,omitempty" xml:"RecoveryTime,omitempty"`
	// The status of the VBR. Valid values: Valid values:
	//
	// *   **Unconfirmed**: pending confirmation from other users
	// *   **Active**: normal
	// *   **Terminating**: being disabled
	// *   **Terminated**: disabled
	// *   **Recovering**: being enabled
	// *   **Deleting**: being deleted
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The last time when the VBR was disabled.
	TerminationTime *string `json:"TerminationTime,omitempty" xml:"TerminationTime,omitempty"`
	// The type of the VBR.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The ID of the VBR.
	VbrId *string `json:"VbrId,omitempty" xml:"VbrId,omitempty"`
	// The ID of the Alibaba Cloud account to which the VBR belongs.
	//
	// If the owner of the VBR is the same as that of the Express Connect circuit, this parameter is empty.
	VbrOwnerUid *int64 `json:"VbrOwnerUid,omitempty" xml:"VbrOwnerUid,omitempty"`
	// The VLAN ID of the VBR.
	VlanId *int32 `json:"VlanId,omitempty" xml:"VlanId,omitempty"`
}

func (s DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSetVirtualBorderRouterForPhysicalConnectionType) String() string {
	return tea.Prettify(s)
}

func (s DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSetVirtualBorderRouterForPhysicalConnectionType) GoString() string {
	return s.String()
}

func (s *DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSetVirtualBorderRouterForPhysicalConnectionType) SetActivationTime(v string) *DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSetVirtualBorderRouterForPhysicalConnectionType {
	s.ActivationTime = &v
	return s
}

func (s *DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSetVirtualBorderRouterForPhysicalConnectionType) SetBandwidth(v string) *DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSetVirtualBorderRouterForPhysicalConnectionType {
	s.Bandwidth = &v
	return s
}

func (s *DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSetVirtualBorderRouterForPhysicalConnectionType) SetBandwidthStatus(v string) *DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSetVirtualBorderRouterForPhysicalConnectionType {
	s.BandwidthStatus = &v
	return s
}

func (s *DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSetVirtualBorderRouterForPhysicalConnectionType) SetCircuitCode(v string) *DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSetVirtualBorderRouterForPhysicalConnectionType {
	s.CircuitCode = &v
	return s
}

func (s *DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSetVirtualBorderRouterForPhysicalConnectionType) SetCreationTime(v string) *DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSetVirtualBorderRouterForPhysicalConnectionType {
	s.CreationTime = &v
	return s
}

func (s *DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSetVirtualBorderRouterForPhysicalConnectionType) SetEccId(v string) *DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSetVirtualBorderRouterForPhysicalConnectionType {
	s.EccId = &v
	return s
}

func (s *DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSetVirtualBorderRouterForPhysicalConnectionType) SetEnableIpv6(v bool) *DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSetVirtualBorderRouterForPhysicalConnectionType {
	s.EnableIpv6 = &v
	return s
}

func (s *DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSetVirtualBorderRouterForPhysicalConnectionType) SetLocalGatewayIp(v string) *DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSetVirtualBorderRouterForPhysicalConnectionType {
	s.LocalGatewayIp = &v
	return s
}

func (s *DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSetVirtualBorderRouterForPhysicalConnectionType) SetLocalIpv6GatewayIp(v string) *DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSetVirtualBorderRouterForPhysicalConnectionType {
	s.LocalIpv6GatewayIp = &v
	return s
}

func (s *DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSetVirtualBorderRouterForPhysicalConnectionType) SetPConnVbrBussinessStatus(v string) *DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSetVirtualBorderRouterForPhysicalConnectionType {
	s.PConnVbrBussinessStatus = &v
	return s
}

func (s *DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSetVirtualBorderRouterForPhysicalConnectionType) SetPConnVbrChargeType(v string) *DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSetVirtualBorderRouterForPhysicalConnectionType {
	s.PConnVbrChargeType = &v
	return s
}

func (s *DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSetVirtualBorderRouterForPhysicalConnectionType) SetPConnVbrExpireTime(v string) *DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSetVirtualBorderRouterForPhysicalConnectionType {
	s.PConnVbrExpireTime = &v
	return s
}

func (s *DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSetVirtualBorderRouterForPhysicalConnectionType) SetPeerGatewayIp(v string) *DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSetVirtualBorderRouterForPhysicalConnectionType {
	s.PeerGatewayIp = &v
	return s
}

func (s *DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSetVirtualBorderRouterForPhysicalConnectionType) SetPeerIpv6GatewayIp(v string) *DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSetVirtualBorderRouterForPhysicalConnectionType {
	s.PeerIpv6GatewayIp = &v
	return s
}

func (s *DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSetVirtualBorderRouterForPhysicalConnectionType) SetPeeringIpv6SubnetMask(v string) *DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSetVirtualBorderRouterForPhysicalConnectionType {
	s.PeeringIpv6SubnetMask = &v
	return s
}

func (s *DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSetVirtualBorderRouterForPhysicalConnectionType) SetPeeringSubnetMask(v string) *DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSetVirtualBorderRouterForPhysicalConnectionType {
	s.PeeringSubnetMask = &v
	return s
}

func (s *DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSetVirtualBorderRouterForPhysicalConnectionType) SetRecoveryTime(v string) *DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSetVirtualBorderRouterForPhysicalConnectionType {
	s.RecoveryTime = &v
	return s
}

func (s *DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSetVirtualBorderRouterForPhysicalConnectionType) SetStatus(v string) *DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSetVirtualBorderRouterForPhysicalConnectionType {
	s.Status = &v
	return s
}

func (s *DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSetVirtualBorderRouterForPhysicalConnectionType) SetTerminationTime(v string) *DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSetVirtualBorderRouterForPhysicalConnectionType {
	s.TerminationTime = &v
	return s
}

func (s *DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSetVirtualBorderRouterForPhysicalConnectionType) SetType(v string) *DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSetVirtualBorderRouterForPhysicalConnectionType {
	s.Type = &v
	return s
}

func (s *DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSetVirtualBorderRouterForPhysicalConnectionType) SetVbrId(v string) *DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSetVirtualBorderRouterForPhysicalConnectionType {
	s.VbrId = &v
	return s
}

func (s *DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSetVirtualBorderRouterForPhysicalConnectionType) SetVbrOwnerUid(v int64) *DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSetVirtualBorderRouterForPhysicalConnectionType {
	s.VbrOwnerUid = &v
	return s
}

func (s *DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSetVirtualBorderRouterForPhysicalConnectionType) SetVlanId(v int32) *DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSetVirtualBorderRouterForPhysicalConnectionType {
	s.VlanId = &v
	return s
}

type DescribeVirtualBorderRoutersForPhysicalConnectionResponse struct {
	Headers    map[string]*string                                             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeVirtualBorderRoutersForPhysicalConnectionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeVirtualBorderRoutersForPhysicalConnectionResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeVirtualBorderRoutersForPhysicalConnectionResponse) GoString() string {
	return s.String()
}

func (s *DescribeVirtualBorderRoutersForPhysicalConnectionResponse) SetHeaders(v map[string]*string) *DescribeVirtualBorderRoutersForPhysicalConnectionResponse {
	s.Headers = v
	return s
}

func (s *DescribeVirtualBorderRoutersForPhysicalConnectionResponse) SetStatusCode(v int32) *DescribeVirtualBorderRoutersForPhysicalConnectionResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeVirtualBorderRoutersForPhysicalConnectionResponse) SetBody(v *DescribeVirtualBorderRoutersForPhysicalConnectionResponseBody) *DescribeVirtualBorderRoutersForPhysicalConnectionResponse {
	s.Body = v
	return s
}

type DescribeVpcAttributeRequest struct {
	// Specifies whether to check the request without performing the operation. Valid values:
	//
	// *   **true**: checks the request without performing the operation. The system checks whether your AccessKey pair is valid, whether the Resource Access Management (RAM) user is authorized, and whether the required parameters are set. If the request fails the check, an error message is returned. If the request passes the check, the `DryRunOperation` error code is returned.
	// *   **false**: sends the request. After the request passes the check, a 2xx HTTP status code is returned and the operation is performed. This is the default value.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// Specifies whether the VPC is the default VPC. Valid values:
	//
	// *   **false** (default): no
	// *   **true**: yes
	IsDefault    *bool   `json:"IsDefault,omitempty" xml:"IsDefault,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the VPC.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the VPC that you want to query.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s DescribeVpcAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpcAttributeRequest) GoString() string {
	return s.String()
}

func (s *DescribeVpcAttributeRequest) SetDryRun(v bool) *DescribeVpcAttributeRequest {
	s.DryRun = &v
	return s
}

func (s *DescribeVpcAttributeRequest) SetIsDefault(v bool) *DescribeVpcAttributeRequest {
	s.IsDefault = &v
	return s
}

func (s *DescribeVpcAttributeRequest) SetOwnerAccount(v string) *DescribeVpcAttributeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeVpcAttributeRequest) SetOwnerId(v int64) *DescribeVpcAttributeRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeVpcAttributeRequest) SetRegionId(v string) *DescribeVpcAttributeRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeVpcAttributeRequest) SetResourceOwnerAccount(v string) *DescribeVpcAttributeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeVpcAttributeRequest) SetResourceOwnerId(v int64) *DescribeVpcAttributeRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeVpcAttributeRequest) SetVpcId(v string) *DescribeVpcAttributeRequest {
	s.VpcId = &v
	return s
}

type DescribeVpcAttributeResponseBody struct {
	// The list of Cloud Enterprise Network (CEN) instances to which the VPC is attached.
	//
	// If the VPC is not attached to a CEN instance, the parameter is not returned.
	AssociatedCens *DescribeVpcAttributeResponseBodyAssociatedCens `json:"AssociatedCens,omitempty" xml:"AssociatedCens,omitempty" type:"Struct"`
	// The IPv4 CIDR block of the VPC.
	CidrBlock *string `json:"CidrBlock,omitempty" xml:"CidrBlock,omitempty"`
	// Indicates whether the ClassicLink feature is enabled. Valid values:
	//
	// *   **true**: yes
	// *   **false** (default): no
	ClassicLinkEnabled *bool `json:"ClassicLinkEnabled,omitempty" xml:"ClassicLinkEnabled,omitempty"`
	// The list of resources deployed in the VPC.
	CloudResources *DescribeVpcAttributeResponseBodyCloudResources `json:"CloudResources,omitempty" xml:"CloudResources,omitempty" type:"Struct"`
	// The time when the VPC was created.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The description of the VPC.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the DHCP options set.
	DhcpOptionsSetId *string `json:"DhcpOptionsSetId,omitempty" xml:"DhcpOptionsSetId,omitempty"`
	// The status of the DHCP options set. Valid values:
	//
	// *   **Available**: available
	// *   **InUse**: in use
	// *   **Deleted**: deleted
	// *   **Pending**: being configured
	DhcpOptionsSetStatus *string `json:"DhcpOptionsSetStatus,omitempty" xml:"DhcpOptionsSetStatus,omitempty"`
	// The ID of the IPv4 gateway.
	Ipv4GatewayId *string `json:"Ipv4GatewayId,omitempty" xml:"Ipv4GatewayId,omitempty"`
	// The IPv6 CIDR block of the VPC.
	Ipv6CidrBlock *string `json:"Ipv6CidrBlock,omitempty" xml:"Ipv6CidrBlock,omitempty"`
	// The information about the IPv6 CIDR blocks of the VPC.
	Ipv6CidrBlocks *DescribeVpcAttributeResponseBodyIpv6CidrBlocks `json:"Ipv6CidrBlocks,omitempty" xml:"Ipv6CidrBlocks,omitempty" type:"Struct"`
	// Indicates whether the VPC is the default VPC. Valid values:
	//
	// *   **true**: yes
	// *   **false** (default): no
	IsDefault *bool `json:"IsDefault,omitempty" xml:"IsDefault,omitempty"`
	// The ID of the Alibaba Cloud account to which the VPC belongs.
	OwnerId *int64 `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the VPC.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The secondary IPv4 CIDR block of the VPC.
	SecondaryCidrBlocks *DescribeVpcAttributeResponseBodySecondaryCidrBlocks `json:"SecondaryCidrBlocks,omitempty" xml:"SecondaryCidrBlocks,omitempty" type:"Struct"`
	// The status of the VPC. Valid values:
	//
	// *   **Available**: available
	// *   **Pending**: being configured
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// Indicates whether the VPC supports IPv4 gateways.
	//
	// - **true**: yes
	// - **false**: no
	SupportIpv4Gateway *bool                                 `json:"SupportIpv4Gateway,omitempty" xml:"SupportIpv4Gateway,omitempty"`
	Tags               *DescribeVpcAttributeResponseBodyTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Struct"`
	// The user CIDR block. Multiple CIDR blocks are separated by commas (,). At most three CIDR blocks are returned.
	UserCidrs *DescribeVpcAttributeResponseBodyUserCidrs `json:"UserCidrs,omitempty" xml:"UserCidrs,omitempty" type:"Struct"`
	// The ID of the vRouter that belongs to the VPC.
	VRouterId *string `json:"VRouterId,omitempty" xml:"VRouterId,omitempty"`
	// The list of vSwitches deployed in the VPC.
	VSwitchIds *DescribeVpcAttributeResponseBodyVSwitchIds `json:"VSwitchIds,omitempty" xml:"VSwitchIds,omitempty" type:"Struct"`
	// The ID of the VPC.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
	// The name of the VPC.
	VpcName *string `json:"VpcName,omitempty" xml:"VpcName,omitempty"`
}

func (s DescribeVpcAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpcAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeVpcAttributeResponseBody) SetAssociatedCens(v *DescribeVpcAttributeResponseBodyAssociatedCens) *DescribeVpcAttributeResponseBody {
	s.AssociatedCens = v
	return s
}

func (s *DescribeVpcAttributeResponseBody) SetCidrBlock(v string) *DescribeVpcAttributeResponseBody {
	s.CidrBlock = &v
	return s
}

func (s *DescribeVpcAttributeResponseBody) SetClassicLinkEnabled(v bool) *DescribeVpcAttributeResponseBody {
	s.ClassicLinkEnabled = &v
	return s
}

func (s *DescribeVpcAttributeResponseBody) SetCloudResources(v *DescribeVpcAttributeResponseBodyCloudResources) *DescribeVpcAttributeResponseBody {
	s.CloudResources = v
	return s
}

func (s *DescribeVpcAttributeResponseBody) SetCreationTime(v string) *DescribeVpcAttributeResponseBody {
	s.CreationTime = &v
	return s
}

func (s *DescribeVpcAttributeResponseBody) SetDescription(v string) *DescribeVpcAttributeResponseBody {
	s.Description = &v
	return s
}

func (s *DescribeVpcAttributeResponseBody) SetDhcpOptionsSetId(v string) *DescribeVpcAttributeResponseBody {
	s.DhcpOptionsSetId = &v
	return s
}

func (s *DescribeVpcAttributeResponseBody) SetDhcpOptionsSetStatus(v string) *DescribeVpcAttributeResponseBody {
	s.DhcpOptionsSetStatus = &v
	return s
}

func (s *DescribeVpcAttributeResponseBody) SetIpv4GatewayId(v string) *DescribeVpcAttributeResponseBody {
	s.Ipv4GatewayId = &v
	return s
}

func (s *DescribeVpcAttributeResponseBody) SetIpv6CidrBlock(v string) *DescribeVpcAttributeResponseBody {
	s.Ipv6CidrBlock = &v
	return s
}

func (s *DescribeVpcAttributeResponseBody) SetIpv6CidrBlocks(v *DescribeVpcAttributeResponseBodyIpv6CidrBlocks) *DescribeVpcAttributeResponseBody {
	s.Ipv6CidrBlocks = v
	return s
}

func (s *DescribeVpcAttributeResponseBody) SetIsDefault(v bool) *DescribeVpcAttributeResponseBody {
	s.IsDefault = &v
	return s
}

func (s *DescribeVpcAttributeResponseBody) SetOwnerId(v int64) *DescribeVpcAttributeResponseBody {
	s.OwnerId = &v
	return s
}

func (s *DescribeVpcAttributeResponseBody) SetRegionId(v string) *DescribeVpcAttributeResponseBody {
	s.RegionId = &v
	return s
}

func (s *DescribeVpcAttributeResponseBody) SetRequestId(v string) *DescribeVpcAttributeResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeVpcAttributeResponseBody) SetResourceGroupId(v string) *DescribeVpcAttributeResponseBody {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeVpcAttributeResponseBody) SetSecondaryCidrBlocks(v *DescribeVpcAttributeResponseBodySecondaryCidrBlocks) *DescribeVpcAttributeResponseBody {
	s.SecondaryCidrBlocks = v
	return s
}

func (s *DescribeVpcAttributeResponseBody) SetStatus(v string) *DescribeVpcAttributeResponseBody {
	s.Status = &v
	return s
}

func (s *DescribeVpcAttributeResponseBody) SetSupportIpv4Gateway(v bool) *DescribeVpcAttributeResponseBody {
	s.SupportIpv4Gateway = &v
	return s
}

func (s *DescribeVpcAttributeResponseBody) SetTags(v *DescribeVpcAttributeResponseBodyTags) *DescribeVpcAttributeResponseBody {
	s.Tags = v
	return s
}

func (s *DescribeVpcAttributeResponseBody) SetUserCidrs(v *DescribeVpcAttributeResponseBodyUserCidrs) *DescribeVpcAttributeResponseBody {
	s.UserCidrs = v
	return s
}

func (s *DescribeVpcAttributeResponseBody) SetVRouterId(v string) *DescribeVpcAttributeResponseBody {
	s.VRouterId = &v
	return s
}

func (s *DescribeVpcAttributeResponseBody) SetVSwitchIds(v *DescribeVpcAttributeResponseBodyVSwitchIds) *DescribeVpcAttributeResponseBody {
	s.VSwitchIds = v
	return s
}

func (s *DescribeVpcAttributeResponseBody) SetVpcId(v string) *DescribeVpcAttributeResponseBody {
	s.VpcId = &v
	return s
}

func (s *DescribeVpcAttributeResponseBody) SetVpcName(v string) *DescribeVpcAttributeResponseBody {
	s.VpcName = &v
	return s
}

type DescribeVpcAttributeResponseBodyAssociatedCens struct {
	AssociatedCen []*DescribeVpcAttributeResponseBodyAssociatedCensAssociatedCen `json:"AssociatedCen,omitempty" xml:"AssociatedCen,omitempty" type:"Repeated"`
}

func (s DescribeVpcAttributeResponseBodyAssociatedCens) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpcAttributeResponseBodyAssociatedCens) GoString() string {
	return s.String()
}

func (s *DescribeVpcAttributeResponseBodyAssociatedCens) SetAssociatedCen(v []*DescribeVpcAttributeResponseBodyAssociatedCensAssociatedCen) *DescribeVpcAttributeResponseBodyAssociatedCens {
	s.AssociatedCen = v
	return s
}

type DescribeVpcAttributeResponseBodyAssociatedCensAssociatedCen struct {
	// The ID of the CEN instance to which the VPC is attached.
	CenId *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	// The ID of the Alibaba Cloud account to which the CEN instance belongs.
	CenOwnerId *int64 `json:"CenOwnerId,omitempty" xml:"CenOwnerId,omitempty"`
	// The status of the CEN instance to which the VPC is attached.
	//
	// **Attached** is returned only if the VPC is attached to a CEN instance.
	CenStatus *string `json:"CenStatus,omitempty" xml:"CenStatus,omitempty"`
}

func (s DescribeVpcAttributeResponseBodyAssociatedCensAssociatedCen) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpcAttributeResponseBodyAssociatedCensAssociatedCen) GoString() string {
	return s.String()
}

func (s *DescribeVpcAttributeResponseBodyAssociatedCensAssociatedCen) SetCenId(v string) *DescribeVpcAttributeResponseBodyAssociatedCensAssociatedCen {
	s.CenId = &v
	return s
}

func (s *DescribeVpcAttributeResponseBodyAssociatedCensAssociatedCen) SetCenOwnerId(v int64) *DescribeVpcAttributeResponseBodyAssociatedCensAssociatedCen {
	s.CenOwnerId = &v
	return s
}

func (s *DescribeVpcAttributeResponseBodyAssociatedCensAssociatedCen) SetCenStatus(v string) *DescribeVpcAttributeResponseBodyAssociatedCensAssociatedCen {
	s.CenStatus = &v
	return s
}

type DescribeVpcAttributeResponseBodyCloudResources struct {
	CloudResourceSetType []*DescribeVpcAttributeResponseBodyCloudResourcesCloudResourceSetType `json:"CloudResourceSetType,omitempty" xml:"CloudResourceSetType,omitempty" type:"Repeated"`
}

func (s DescribeVpcAttributeResponseBodyCloudResources) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpcAttributeResponseBodyCloudResources) GoString() string {
	return s.String()
}

func (s *DescribeVpcAttributeResponseBodyCloudResources) SetCloudResourceSetType(v []*DescribeVpcAttributeResponseBodyCloudResourcesCloudResourceSetType) *DescribeVpcAttributeResponseBodyCloudResources {
	s.CloudResourceSetType = v
	return s
}

type DescribeVpcAttributeResponseBodyCloudResourcesCloudResourceSetType struct {
	// The number of resources deployed in the VPC.
	ResourceCount *int32 `json:"ResourceCount,omitempty" xml:"ResourceCount,omitempty"`
	// The type of resources deployed in the VPC. Valid values:
	//
	// - **VSwitch**: vSwitches
	// - **VRouter**: vRouters
	// - **RouteTable**: route tables
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
}

func (s DescribeVpcAttributeResponseBodyCloudResourcesCloudResourceSetType) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpcAttributeResponseBodyCloudResourcesCloudResourceSetType) GoString() string {
	return s.String()
}

func (s *DescribeVpcAttributeResponseBodyCloudResourcesCloudResourceSetType) SetResourceCount(v int32) *DescribeVpcAttributeResponseBodyCloudResourcesCloudResourceSetType {
	s.ResourceCount = &v
	return s
}

func (s *DescribeVpcAttributeResponseBodyCloudResourcesCloudResourceSetType) SetResourceType(v string) *DescribeVpcAttributeResponseBodyCloudResourcesCloudResourceSetType {
	s.ResourceType = &v
	return s
}

type DescribeVpcAttributeResponseBodyIpv6CidrBlocks struct {
	Ipv6CidrBlock []*DescribeVpcAttributeResponseBodyIpv6CidrBlocksIpv6CidrBlock `json:"Ipv6CidrBlock,omitempty" xml:"Ipv6CidrBlock,omitempty" type:"Repeated"`
}

func (s DescribeVpcAttributeResponseBodyIpv6CidrBlocks) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpcAttributeResponseBodyIpv6CidrBlocks) GoString() string {
	return s.String()
}

func (s *DescribeVpcAttributeResponseBodyIpv6CidrBlocks) SetIpv6CidrBlock(v []*DescribeVpcAttributeResponseBodyIpv6CidrBlocksIpv6CidrBlock) *DescribeVpcAttributeResponseBodyIpv6CidrBlocks {
	s.Ipv6CidrBlock = v
	return s
}

type DescribeVpcAttributeResponseBodyIpv6CidrBlocksIpv6CidrBlock struct {
	// The IPv6 CIDR block of the VPC.
	Ipv6CidrBlock *string `json:"Ipv6CidrBlock,omitempty" xml:"Ipv6CidrBlock,omitempty"`
	// The type of the IPv6 CIDR block. Valid values:
	//
	// - **BGP** (default): an IPv6 CIDR block provided by Alibaba Cloud over Border Gateway Protocol (BGP)
	// - **ChinaMobile**: an IPv6 CIDR block provided by China Mobile (single ISP)
	// - **ChinaUnicom**: an IPv6 CIDR block provided by China Unicom (single ISP)
	// - **ChinaTelecom**: an IPv6 CIDR block provided by China Telecom (single ISP)
	//
	// >  If your Alibaba Cloud account is allowed to activate single-ISP bandwidth, valid values are: **ChinaTelecom**, **ChinaUnicom**, and **ChinaMobile**.
	Ipv6Isp *string `json:"Ipv6Isp,omitempty" xml:"Ipv6Isp,omitempty"`
}

func (s DescribeVpcAttributeResponseBodyIpv6CidrBlocksIpv6CidrBlock) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpcAttributeResponseBodyIpv6CidrBlocksIpv6CidrBlock) GoString() string {
	return s.String()
}

func (s *DescribeVpcAttributeResponseBodyIpv6CidrBlocksIpv6CidrBlock) SetIpv6CidrBlock(v string) *DescribeVpcAttributeResponseBodyIpv6CidrBlocksIpv6CidrBlock {
	s.Ipv6CidrBlock = &v
	return s
}

func (s *DescribeVpcAttributeResponseBodyIpv6CidrBlocksIpv6CidrBlock) SetIpv6Isp(v string) *DescribeVpcAttributeResponseBodyIpv6CidrBlocksIpv6CidrBlock {
	s.Ipv6Isp = &v
	return s
}

type DescribeVpcAttributeResponseBodySecondaryCidrBlocks struct {
	SecondaryCidrBlock []*string `json:"SecondaryCidrBlock,omitempty" xml:"SecondaryCidrBlock,omitempty" type:"Repeated"`
}

func (s DescribeVpcAttributeResponseBodySecondaryCidrBlocks) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpcAttributeResponseBodySecondaryCidrBlocks) GoString() string {
	return s.String()
}

func (s *DescribeVpcAttributeResponseBodySecondaryCidrBlocks) SetSecondaryCidrBlock(v []*string) *DescribeVpcAttributeResponseBodySecondaryCidrBlocks {
	s.SecondaryCidrBlock = v
	return s
}

type DescribeVpcAttributeResponseBodyTags struct {
	Tag []*DescribeVpcAttributeResponseBodyTagsTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s DescribeVpcAttributeResponseBodyTags) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpcAttributeResponseBodyTags) GoString() string {
	return s.String()
}

func (s *DescribeVpcAttributeResponseBodyTags) SetTag(v []*DescribeVpcAttributeResponseBodyTagsTag) *DescribeVpcAttributeResponseBodyTags {
	s.Tag = v
	return s
}

type DescribeVpcAttributeResponseBodyTagsTag struct {
	Key   *string `json:"Key,omitempty" xml:"Key,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeVpcAttributeResponseBodyTagsTag) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpcAttributeResponseBodyTagsTag) GoString() string {
	return s.String()
}

func (s *DescribeVpcAttributeResponseBodyTagsTag) SetKey(v string) *DescribeVpcAttributeResponseBodyTagsTag {
	s.Key = &v
	return s
}

func (s *DescribeVpcAttributeResponseBodyTagsTag) SetValue(v string) *DescribeVpcAttributeResponseBodyTagsTag {
	s.Value = &v
	return s
}

type DescribeVpcAttributeResponseBodyUserCidrs struct {
	UserCidr []*string `json:"UserCidr,omitempty" xml:"UserCidr,omitempty" type:"Repeated"`
}

func (s DescribeVpcAttributeResponseBodyUserCidrs) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpcAttributeResponseBodyUserCidrs) GoString() string {
	return s.String()
}

func (s *DescribeVpcAttributeResponseBodyUserCidrs) SetUserCidr(v []*string) *DescribeVpcAttributeResponseBodyUserCidrs {
	s.UserCidr = v
	return s
}

type DescribeVpcAttributeResponseBodyVSwitchIds struct {
	VSwitchId []*string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty" type:"Repeated"`
}

func (s DescribeVpcAttributeResponseBodyVSwitchIds) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpcAttributeResponseBodyVSwitchIds) GoString() string {
	return s.String()
}

func (s *DescribeVpcAttributeResponseBodyVSwitchIds) SetVSwitchId(v []*string) *DescribeVpcAttributeResponseBodyVSwitchIds {
	s.VSwitchId = v
	return s
}

type DescribeVpcAttributeResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeVpcAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeVpcAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpcAttributeResponse) GoString() string {
	return s.String()
}

func (s *DescribeVpcAttributeResponse) SetHeaders(v map[string]*string) *DescribeVpcAttributeResponse {
	s.Headers = v
	return s
}

func (s *DescribeVpcAttributeResponse) SetStatusCode(v int32) *DescribeVpcAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeVpcAttributeResponse) SetBody(v *DescribeVpcAttributeResponseBody) *DescribeVpcAttributeResponse {
	s.Body = v
	return s
}

type DescribeVpcsRequest struct {
	// The ID of the DHCP options set.
	DhcpOptionsSetId *string `json:"DhcpOptionsSetId,omitempty" xml:"DhcpOptionsSetId,omitempty"`
	// Specifies whether to check the request without performing the operation. Valid values:
	//
	// *   **true**: checks the request but does not query VPCs. The system checks whether your AccessKey pair is valid, whether the Resource Access Management (RAM) user is authorized, and whether the required parameters are set. If the request fails to pass the check, an error message is returned. If the request passes the check, the `DryRunOperation` error code is returned.
	// *   **false** (default): sends the request. If the request passes the check, a 2xx HTTP status code is returned and VPCs are queried.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// Specifies whether to query the default VPC in the specified region. Valid values:
	//
	// *   **true** (default): yes
	// *   **false**: no
	IsDefault    *bool   `json:"IsDefault,omitempty" xml:"IsDefault,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of the page to return. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return per page. Maximum value: **50**. Default value: **10**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The region ID of the VPC.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group to which the VPC to be queried belongs.
	ResourceGroupId      *string                   `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string                   `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64                    `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	Tag                  []*DescribeVpcsRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
	// The ID of the VPC.
	//
	// You can specify up to 20 VPC IDs. Separate multiple IDs with commas (,).
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
	// The name of the VPC.
	VpcName *string `json:"VpcName,omitempty" xml:"VpcName,omitempty"`
	// The ID of the Alibaba Cloud account to which the VPC belongs.
	VpcOwnerId *int64 `json:"VpcOwnerId,omitempty" xml:"VpcOwnerId,omitempty"`
}

func (s DescribeVpcsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpcsRequest) GoString() string {
	return s.String()
}

func (s *DescribeVpcsRequest) SetDhcpOptionsSetId(v string) *DescribeVpcsRequest {
	s.DhcpOptionsSetId = &v
	return s
}

func (s *DescribeVpcsRequest) SetDryRun(v bool) *DescribeVpcsRequest {
	s.DryRun = &v
	return s
}

func (s *DescribeVpcsRequest) SetIsDefault(v bool) *DescribeVpcsRequest {
	s.IsDefault = &v
	return s
}

func (s *DescribeVpcsRequest) SetOwnerAccount(v string) *DescribeVpcsRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeVpcsRequest) SetOwnerId(v int64) *DescribeVpcsRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeVpcsRequest) SetPageNumber(v int32) *DescribeVpcsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeVpcsRequest) SetPageSize(v int32) *DescribeVpcsRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeVpcsRequest) SetRegionId(v string) *DescribeVpcsRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeVpcsRequest) SetResourceGroupId(v string) *DescribeVpcsRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeVpcsRequest) SetResourceOwnerAccount(v string) *DescribeVpcsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeVpcsRequest) SetResourceOwnerId(v int64) *DescribeVpcsRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeVpcsRequest) SetTag(v []*DescribeVpcsRequestTag) *DescribeVpcsRequest {
	s.Tag = v
	return s
}

func (s *DescribeVpcsRequest) SetVpcId(v string) *DescribeVpcsRequest {
	s.VpcId = &v
	return s
}

func (s *DescribeVpcsRequest) SetVpcName(v string) *DescribeVpcsRequest {
	s.VpcName = &v
	return s
}

func (s *DescribeVpcsRequest) SetVpcOwnerId(v int64) *DescribeVpcsRequest {
	s.VpcOwnerId = &v
	return s
}

type DescribeVpcsRequestTag struct {
	Key   *string `json:"Key,omitempty" xml:"Key,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeVpcsRequestTag) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpcsRequestTag) GoString() string {
	return s.String()
}

func (s *DescribeVpcsRequestTag) SetKey(v string) *DescribeVpcsRequestTag {
	s.Key = &v
	return s
}

func (s *DescribeVpcsRequestTag) SetValue(v string) *DescribeVpcsRequestTag {
	s.Value = &v
	return s
}

type DescribeVpcsResponseBody struct {
	// The number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
	// The details of the VPCs.
	Vpcs *DescribeVpcsResponseBodyVpcs `json:"Vpcs,omitempty" xml:"Vpcs,omitempty" type:"Struct"`
}

func (s DescribeVpcsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpcsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeVpcsResponseBody) SetPageNumber(v int32) *DescribeVpcsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeVpcsResponseBody) SetPageSize(v int32) *DescribeVpcsResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeVpcsResponseBody) SetRequestId(v string) *DescribeVpcsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeVpcsResponseBody) SetTotalCount(v int32) *DescribeVpcsResponseBody {
	s.TotalCount = &v
	return s
}

func (s *DescribeVpcsResponseBody) SetVpcs(v *DescribeVpcsResponseBodyVpcs) *DescribeVpcsResponseBody {
	s.Vpcs = v
	return s
}

type DescribeVpcsResponseBodyVpcs struct {
	Vpc []*DescribeVpcsResponseBodyVpcsVpc `json:"Vpc,omitempty" xml:"Vpc,omitempty" type:"Repeated"`
}

func (s DescribeVpcsResponseBodyVpcs) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpcsResponseBodyVpcs) GoString() string {
	return s.String()
}

func (s *DescribeVpcsResponseBodyVpcs) SetVpc(v []*DescribeVpcsResponseBodyVpcsVpc) *DescribeVpcsResponseBodyVpcs {
	s.Vpc = v
	return s
}

type DescribeVpcsResponseBodyVpcsVpc struct {
	// The status of the Cloud Enterprise Network (CEN) instance to which the VPC is attached.
	//
	// **Attached** is returned only if the VPC is attached to a CEN instance.
	CenStatus *string `json:"CenStatus,omitempty" xml:"CenStatus,omitempty"`
	// The IPv4 CIDR block of the VPC.
	CidrBlock *string `json:"CidrBlock,omitempty" xml:"CidrBlock,omitempty"`
	// The time when the VPC was created.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The description of the VPC.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the DHCP options set.
	DhcpOptionsSetId *string `json:"DhcpOptionsSetId,omitempty" xml:"DhcpOptionsSetId,omitempty"`
	// The status of the DHCP options set. Valid values:
	//
	// *   **Available**: available
	// *   **InUse**: in use
	// *   **Deleted**: deleted
	// *   **Pending**: being configured
	DhcpOptionsSetStatus *string `json:"DhcpOptionsSetStatus,omitempty" xml:"DhcpOptionsSetStatus,omitempty"`
	// The IPv6 CIDR block of the VPC.
	Ipv6CidrBlock *string `json:"Ipv6CidrBlock,omitempty" xml:"Ipv6CidrBlock,omitempty"`
	// The IPv6 CIDR blocks of the VPC.
	Ipv6CidrBlocks *DescribeVpcsResponseBodyVpcsVpcIpv6CidrBlocks `json:"Ipv6CidrBlocks,omitempty" xml:"Ipv6CidrBlocks,omitempty" type:"Struct"`
	// Indicates whether the VPC is the default VPC in the region. Valid values:
	//
	// *   **true**: yes
	// *   **false**: no
	IsDefault *bool `json:"IsDefault,omitempty" xml:"IsDefault,omitempty"`
	// The IDs of the NAT gateways.
	NatGatewayIds *DescribeVpcsResponseBodyVpcsVpcNatGatewayIds `json:"NatGatewayIds,omitempty" xml:"NatGatewayIds,omitempty" type:"Struct"`
	// The ID of the Alibaba Cloud account to which the VPC belongs.
	OwnerId *int64 `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region to which the VPC belongs.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group to which the VPC belongs.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The IDs of the route tables.
	RouterTableIds *DescribeVpcsResponseBodyVpcsVpcRouterTableIds `json:"RouterTableIds,omitempty" xml:"RouterTableIds,omitempty" type:"Struct"`
	// The secondary CIDR blocks of the VPC.
	SecondaryCidrBlocks *DescribeVpcsResponseBodyVpcsVpcSecondaryCidrBlocks `json:"SecondaryCidrBlocks,omitempty" xml:"SecondaryCidrBlocks,omitempty" type:"Struct"`
	// The status of the VPC. Valid values:
	//
	// *   **Pending**: being configured
	// *   **Available**: available
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The tag information about the VPC.
	Tags *DescribeVpcsResponseBodyVpcsVpcTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Struct"`
	// The list of user CIDR blocks.
	UserCidrs *DescribeVpcsResponseBodyVpcsVpcUserCidrs `json:"UserCidrs,omitempty" xml:"UserCidrs,omitempty" type:"Struct"`
	// The ID of the vRouter.
	VRouterId *string `json:"VRouterId,omitempty" xml:"VRouterId,omitempty"`
	// The vSwitches in the VPC.
	//
	// You can query up to 300 vSwitches in the VPC. The information about the latest vSwitches is returned. If you want to query the information about all vSwitches in a VPC, call the [DescribeVSwitches](/help/en/virtual-private-cloud/latest/describevswitches) operation.
	VSwitchIds *DescribeVpcsResponseBodyVpcsVpcVSwitchIds `json:"VSwitchIds,omitempty" xml:"VSwitchIds,omitempty" type:"Struct"`
	// The ID of the VPC.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
	// The name of the VPC.
	VpcName *string `json:"VpcName,omitempty" xml:"VpcName,omitempty"`
}

func (s DescribeVpcsResponseBodyVpcsVpc) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpcsResponseBodyVpcsVpc) GoString() string {
	return s.String()
}

func (s *DescribeVpcsResponseBodyVpcsVpc) SetCenStatus(v string) *DescribeVpcsResponseBodyVpcsVpc {
	s.CenStatus = &v
	return s
}

func (s *DescribeVpcsResponseBodyVpcsVpc) SetCidrBlock(v string) *DescribeVpcsResponseBodyVpcsVpc {
	s.CidrBlock = &v
	return s
}

func (s *DescribeVpcsResponseBodyVpcsVpc) SetCreationTime(v string) *DescribeVpcsResponseBodyVpcsVpc {
	s.CreationTime = &v
	return s
}

func (s *DescribeVpcsResponseBodyVpcsVpc) SetDescription(v string) *DescribeVpcsResponseBodyVpcsVpc {
	s.Description = &v
	return s
}

func (s *DescribeVpcsResponseBodyVpcsVpc) SetDhcpOptionsSetId(v string) *DescribeVpcsResponseBodyVpcsVpc {
	s.DhcpOptionsSetId = &v
	return s
}

func (s *DescribeVpcsResponseBodyVpcsVpc) SetDhcpOptionsSetStatus(v string) *DescribeVpcsResponseBodyVpcsVpc {
	s.DhcpOptionsSetStatus = &v
	return s
}

func (s *DescribeVpcsResponseBodyVpcsVpc) SetIpv6CidrBlock(v string) *DescribeVpcsResponseBodyVpcsVpc {
	s.Ipv6CidrBlock = &v
	return s
}

func (s *DescribeVpcsResponseBodyVpcsVpc) SetIpv6CidrBlocks(v *DescribeVpcsResponseBodyVpcsVpcIpv6CidrBlocks) *DescribeVpcsResponseBodyVpcsVpc {
	s.Ipv6CidrBlocks = v
	return s
}

func (s *DescribeVpcsResponseBodyVpcsVpc) SetIsDefault(v bool) *DescribeVpcsResponseBodyVpcsVpc {
	s.IsDefault = &v
	return s
}

func (s *DescribeVpcsResponseBodyVpcsVpc) SetNatGatewayIds(v *DescribeVpcsResponseBodyVpcsVpcNatGatewayIds) *DescribeVpcsResponseBodyVpcsVpc {
	s.NatGatewayIds = v
	return s
}

func (s *DescribeVpcsResponseBodyVpcsVpc) SetOwnerId(v int64) *DescribeVpcsResponseBodyVpcsVpc {
	s.OwnerId = &v
	return s
}

func (s *DescribeVpcsResponseBodyVpcsVpc) SetRegionId(v string) *DescribeVpcsResponseBodyVpcsVpc {
	s.RegionId = &v
	return s
}

func (s *DescribeVpcsResponseBodyVpcsVpc) SetResourceGroupId(v string) *DescribeVpcsResponseBodyVpcsVpc {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeVpcsResponseBodyVpcsVpc) SetRouterTableIds(v *DescribeVpcsResponseBodyVpcsVpcRouterTableIds) *DescribeVpcsResponseBodyVpcsVpc {
	s.RouterTableIds = v
	return s
}

func (s *DescribeVpcsResponseBodyVpcsVpc) SetSecondaryCidrBlocks(v *DescribeVpcsResponseBodyVpcsVpcSecondaryCidrBlocks) *DescribeVpcsResponseBodyVpcsVpc {
	s.SecondaryCidrBlocks = v
	return s
}

func (s *DescribeVpcsResponseBodyVpcsVpc) SetStatus(v string) *DescribeVpcsResponseBodyVpcsVpc {
	s.Status = &v
	return s
}

func (s *DescribeVpcsResponseBodyVpcsVpc) SetTags(v *DescribeVpcsResponseBodyVpcsVpcTags) *DescribeVpcsResponseBodyVpcsVpc {
	s.Tags = v
	return s
}

func (s *DescribeVpcsResponseBodyVpcsVpc) SetUserCidrs(v *DescribeVpcsResponseBodyVpcsVpcUserCidrs) *DescribeVpcsResponseBodyVpcsVpc {
	s.UserCidrs = v
	return s
}

func (s *DescribeVpcsResponseBodyVpcsVpc) SetVRouterId(v string) *DescribeVpcsResponseBodyVpcsVpc {
	s.VRouterId = &v
	return s
}

func (s *DescribeVpcsResponseBodyVpcsVpc) SetVSwitchIds(v *DescribeVpcsResponseBodyVpcsVpcVSwitchIds) *DescribeVpcsResponseBodyVpcsVpc {
	s.VSwitchIds = v
	return s
}

func (s *DescribeVpcsResponseBodyVpcsVpc) SetVpcId(v string) *DescribeVpcsResponseBodyVpcsVpc {
	s.VpcId = &v
	return s
}

func (s *DescribeVpcsResponseBodyVpcsVpc) SetVpcName(v string) *DescribeVpcsResponseBodyVpcsVpc {
	s.VpcName = &v
	return s
}

type DescribeVpcsResponseBodyVpcsVpcIpv6CidrBlocks struct {
	Ipv6CidrBlock []*DescribeVpcsResponseBodyVpcsVpcIpv6CidrBlocksIpv6CidrBlock `json:"Ipv6CidrBlock,omitempty" xml:"Ipv6CidrBlock,omitempty" type:"Repeated"`
}

func (s DescribeVpcsResponseBodyVpcsVpcIpv6CidrBlocks) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpcsResponseBodyVpcsVpcIpv6CidrBlocks) GoString() string {
	return s.String()
}

func (s *DescribeVpcsResponseBodyVpcsVpcIpv6CidrBlocks) SetIpv6CidrBlock(v []*DescribeVpcsResponseBodyVpcsVpcIpv6CidrBlocksIpv6CidrBlock) *DescribeVpcsResponseBodyVpcsVpcIpv6CidrBlocks {
	s.Ipv6CidrBlock = v
	return s
}

type DescribeVpcsResponseBodyVpcsVpcIpv6CidrBlocksIpv6CidrBlock struct {
	// The IPv6 CIDR block of the VPC.
	Ipv6CidrBlock *string `json:"Ipv6CidrBlock,omitempty" xml:"Ipv6CidrBlock,omitempty"`
	// The type of IPv6 CIDR block. Valid values:
	//
	// - **BGP**: an IPv6 CIDR block provided by Alibaba Cloud over Border Gateway Protocol (BGP)
	// - **ChinaMobile**: an IPv6 CIDR block provided by China Mobile (single ISP)
	// - **ChinaUnicom**: an IPv6 CIDR block provided by China Unicom (single ISP)
	// - **ChinaTelecom**: an IPv6 CIDR block provided by China Telecom (single ISP)
	//
	// >  If your Alibaba Cloud account is allowed to activate single-ISP bandwidth, valid values are: **ChinaTelecom**, **ChinaUnicom**, and **ChinaMobile**.
	Ipv6Isp *string `json:"Ipv6Isp,omitempty" xml:"Ipv6Isp,omitempty"`
}

func (s DescribeVpcsResponseBodyVpcsVpcIpv6CidrBlocksIpv6CidrBlock) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpcsResponseBodyVpcsVpcIpv6CidrBlocksIpv6CidrBlock) GoString() string {
	return s.String()
}

func (s *DescribeVpcsResponseBodyVpcsVpcIpv6CidrBlocksIpv6CidrBlock) SetIpv6CidrBlock(v string) *DescribeVpcsResponseBodyVpcsVpcIpv6CidrBlocksIpv6CidrBlock {
	s.Ipv6CidrBlock = &v
	return s
}

func (s *DescribeVpcsResponseBodyVpcsVpcIpv6CidrBlocksIpv6CidrBlock) SetIpv6Isp(v string) *DescribeVpcsResponseBodyVpcsVpcIpv6CidrBlocksIpv6CidrBlock {
	s.Ipv6Isp = &v
	return s
}

type DescribeVpcsResponseBodyVpcsVpcNatGatewayIds struct {
	NatGatewayIds []*string `json:"NatGatewayIds,omitempty" xml:"NatGatewayIds,omitempty" type:"Repeated"`
}

func (s DescribeVpcsResponseBodyVpcsVpcNatGatewayIds) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpcsResponseBodyVpcsVpcNatGatewayIds) GoString() string {
	return s.String()
}

func (s *DescribeVpcsResponseBodyVpcsVpcNatGatewayIds) SetNatGatewayIds(v []*string) *DescribeVpcsResponseBodyVpcsVpcNatGatewayIds {
	s.NatGatewayIds = v
	return s
}

type DescribeVpcsResponseBodyVpcsVpcRouterTableIds struct {
	RouterTableIds []*string `json:"RouterTableIds,omitempty" xml:"RouterTableIds,omitempty" type:"Repeated"`
}

func (s DescribeVpcsResponseBodyVpcsVpcRouterTableIds) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpcsResponseBodyVpcsVpcRouterTableIds) GoString() string {
	return s.String()
}

func (s *DescribeVpcsResponseBodyVpcsVpcRouterTableIds) SetRouterTableIds(v []*string) *DescribeVpcsResponseBodyVpcsVpcRouterTableIds {
	s.RouterTableIds = v
	return s
}

type DescribeVpcsResponseBodyVpcsVpcSecondaryCidrBlocks struct {
	SecondaryCidrBlock []*string `json:"SecondaryCidrBlock,omitempty" xml:"SecondaryCidrBlock,omitempty" type:"Repeated"`
}

func (s DescribeVpcsResponseBodyVpcsVpcSecondaryCidrBlocks) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpcsResponseBodyVpcsVpcSecondaryCidrBlocks) GoString() string {
	return s.String()
}

func (s *DescribeVpcsResponseBodyVpcsVpcSecondaryCidrBlocks) SetSecondaryCidrBlock(v []*string) *DescribeVpcsResponseBodyVpcsVpcSecondaryCidrBlocks {
	s.SecondaryCidrBlock = v
	return s
}

type DescribeVpcsResponseBodyVpcsVpcTags struct {
	Tag []*DescribeVpcsResponseBodyVpcsVpcTagsTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s DescribeVpcsResponseBodyVpcsVpcTags) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpcsResponseBodyVpcsVpcTags) GoString() string {
	return s.String()
}

func (s *DescribeVpcsResponseBodyVpcsVpcTags) SetTag(v []*DescribeVpcsResponseBodyVpcsVpcTagsTag) *DescribeVpcsResponseBodyVpcsVpcTags {
	s.Tag = v
	return s
}

type DescribeVpcsResponseBodyVpcsVpcTagsTag struct {
	// The key of the tag that is added to the VPC.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The value of the tag that is added to the VPC.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeVpcsResponseBodyVpcsVpcTagsTag) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpcsResponseBodyVpcsVpcTagsTag) GoString() string {
	return s.String()
}

func (s *DescribeVpcsResponseBodyVpcsVpcTagsTag) SetKey(v string) *DescribeVpcsResponseBodyVpcsVpcTagsTag {
	s.Key = &v
	return s
}

func (s *DescribeVpcsResponseBodyVpcsVpcTagsTag) SetValue(v string) *DescribeVpcsResponseBodyVpcsVpcTagsTag {
	s.Value = &v
	return s
}

type DescribeVpcsResponseBodyVpcsVpcUserCidrs struct {
	UserCidr []*string `json:"UserCidr,omitempty" xml:"UserCidr,omitempty" type:"Repeated"`
}

func (s DescribeVpcsResponseBodyVpcsVpcUserCidrs) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpcsResponseBodyVpcsVpcUserCidrs) GoString() string {
	return s.String()
}

func (s *DescribeVpcsResponseBodyVpcsVpcUserCidrs) SetUserCidr(v []*string) *DescribeVpcsResponseBodyVpcsVpcUserCidrs {
	s.UserCidr = v
	return s
}

type DescribeVpcsResponseBodyVpcsVpcVSwitchIds struct {
	VSwitchId []*string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty" type:"Repeated"`
}

func (s DescribeVpcsResponseBodyVpcsVpcVSwitchIds) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpcsResponseBodyVpcsVpcVSwitchIds) GoString() string {
	return s.String()
}

func (s *DescribeVpcsResponseBodyVpcsVpcVSwitchIds) SetVSwitchId(v []*string) *DescribeVpcsResponseBodyVpcsVpcVSwitchIds {
	s.VSwitchId = v
	return s
}

type DescribeVpcsResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeVpcsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeVpcsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpcsResponse) GoString() string {
	return s.String()
}

func (s *DescribeVpcsResponse) SetHeaders(v map[string]*string) *DescribeVpcsResponse {
	s.Headers = v
	return s
}

func (s *DescribeVpcsResponse) SetStatusCode(v int32) *DescribeVpcsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeVpcsResponse) SetBody(v *DescribeVpcsResponseBody) *DescribeVpcsResponse {
	s.Body = v
	return s
}

type DescribeVpnAttachmentsRequest struct {
	// The type of resource that is associated with the IPsec-VPN connection. Default value: **CEN**.
	//
	// Set the value to **CEN**, which specifies to query IPsec-VPN connections associated with the transit router.
	AttachType   *string `json:"AttachType,omitempty" xml:"AttachType,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of the page to return. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Default value: **10**. Valid values: **1** to **50**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the region to which the IPsec-VPN connection belongs.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the IPsec-VPN connection.
	//
	// >  If you do not specify an ID, the system queries all IPsec-VPN connections associated with the transit router in the region.
	VpnConnectionId *string `json:"VpnConnectionId,omitempty" xml:"VpnConnectionId,omitempty"`
}

func (s DescribeVpnAttachmentsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpnAttachmentsRequest) GoString() string {
	return s.String()
}

func (s *DescribeVpnAttachmentsRequest) SetAttachType(v string) *DescribeVpnAttachmentsRequest {
	s.AttachType = &v
	return s
}

func (s *DescribeVpnAttachmentsRequest) SetOwnerAccount(v string) *DescribeVpnAttachmentsRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeVpnAttachmentsRequest) SetOwnerId(v int64) *DescribeVpnAttachmentsRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeVpnAttachmentsRequest) SetPageNumber(v int32) *DescribeVpnAttachmentsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeVpnAttachmentsRequest) SetPageSize(v int32) *DescribeVpnAttachmentsRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeVpnAttachmentsRequest) SetRegionId(v string) *DescribeVpnAttachmentsRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeVpnAttachmentsRequest) SetResourceOwnerAccount(v string) *DescribeVpnAttachmentsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeVpnAttachmentsRequest) SetResourceOwnerId(v int64) *DescribeVpnAttachmentsRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeVpnAttachmentsRequest) SetVpnConnectionId(v string) *DescribeVpnAttachmentsRequest {
	s.VpnConnectionId = &v
	return s
}

type DescribeVpnAttachmentsResponseBody struct {
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
	// The list of IPsec-VPN connections associated with the transit router.
	VpnAttachments []*DescribeVpnAttachmentsResponseBodyVpnAttachments `json:"VpnAttachments,omitempty" xml:"VpnAttachments,omitempty" type:"Repeated"`
}

func (s DescribeVpnAttachmentsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpnAttachmentsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeVpnAttachmentsResponseBody) SetPageNumber(v int32) *DescribeVpnAttachmentsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeVpnAttachmentsResponseBody) SetPageSize(v int32) *DescribeVpnAttachmentsResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeVpnAttachmentsResponseBody) SetRequestId(v string) *DescribeVpnAttachmentsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeVpnAttachmentsResponseBody) SetTotalCount(v int32) *DescribeVpnAttachmentsResponseBody {
	s.TotalCount = &v
	return s
}

func (s *DescribeVpnAttachmentsResponseBody) SetVpnAttachments(v []*DescribeVpnAttachmentsResponseBodyVpnAttachments) *DescribeVpnAttachmentsResponseBody {
	s.VpnAttachments = v
	return s
}

type DescribeVpnAttachmentsResponseBodyVpnAttachments struct {
	// The type of resource that is associated with the IPsec-VPN connection. The value is set to **CEN**, which indicates that the IPsec-VPN connection is associated with a transit router.
	AttachType *string `json:"AttachType,omitempty" xml:"AttachType,omitempty"`
	// Indicates whether the IPsec-VPN connection is associated with a transit router that belongs to another Alibaba Cloud account. Valid values:
	//
	// *   **true**: yes
	// *   **false**: no
	CrossAccountAuthorized *bool `json:"CrossAccountAuthorized,omitempty" xml:"CrossAccountAuthorized,omitempty"`
	// The description of the IPsec-VPN connection.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the IPsec-VPN connection.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The name of the IPsec-VPN connection.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the transit router with which the IPsec-VPN connection is associated.
	TransitRouterId *string `json:"TransitRouterId,omitempty" xml:"TransitRouterId,omitempty"`
	// The name of the transit router.
	TransitRouterName *string `json:"TransitRouterName,omitempty" xml:"TransitRouterName,omitempty"`
}

func (s DescribeVpnAttachmentsResponseBodyVpnAttachments) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpnAttachmentsResponseBodyVpnAttachments) GoString() string {
	return s.String()
}

func (s *DescribeVpnAttachmentsResponseBodyVpnAttachments) SetAttachType(v string) *DescribeVpnAttachmentsResponseBodyVpnAttachments {
	s.AttachType = &v
	return s
}

func (s *DescribeVpnAttachmentsResponseBodyVpnAttachments) SetCrossAccountAuthorized(v bool) *DescribeVpnAttachmentsResponseBodyVpnAttachments {
	s.CrossAccountAuthorized = &v
	return s
}

func (s *DescribeVpnAttachmentsResponseBodyVpnAttachments) SetDescription(v string) *DescribeVpnAttachmentsResponseBodyVpnAttachments {
	s.Description = &v
	return s
}

func (s *DescribeVpnAttachmentsResponseBodyVpnAttachments) SetInstanceId(v string) *DescribeVpnAttachmentsResponseBodyVpnAttachments {
	s.InstanceId = &v
	return s
}

func (s *DescribeVpnAttachmentsResponseBodyVpnAttachments) SetName(v string) *DescribeVpnAttachmentsResponseBodyVpnAttachments {
	s.Name = &v
	return s
}

func (s *DescribeVpnAttachmentsResponseBodyVpnAttachments) SetTransitRouterId(v string) *DescribeVpnAttachmentsResponseBodyVpnAttachments {
	s.TransitRouterId = &v
	return s
}

func (s *DescribeVpnAttachmentsResponseBodyVpnAttachments) SetTransitRouterName(v string) *DescribeVpnAttachmentsResponseBodyVpnAttachments {
	s.TransitRouterName = &v
	return s
}

type DescribeVpnAttachmentsResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeVpnAttachmentsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeVpnAttachmentsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpnAttachmentsResponse) GoString() string {
	return s.String()
}

func (s *DescribeVpnAttachmentsResponse) SetHeaders(v map[string]*string) *DescribeVpnAttachmentsResponse {
	s.Headers = v
	return s
}

func (s *DescribeVpnAttachmentsResponse) SetStatusCode(v int32) *DescribeVpnAttachmentsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeVpnAttachmentsResponse) SetBody(v *DescribeVpnAttachmentsResponseBody) *DescribeVpnAttachmentsResponse {
	s.Body = v
	return s
}

type DescribeVpnConnectionRequest struct {
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region where the IPsec-VPN connection is established.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the IPsec-VPN connection.
	VpnConnectionId *string `json:"VpnConnectionId,omitempty" xml:"VpnConnectionId,omitempty"`
}

func (s DescribeVpnConnectionRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpnConnectionRequest) GoString() string {
	return s.String()
}

func (s *DescribeVpnConnectionRequest) SetOwnerAccount(v string) *DescribeVpnConnectionRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeVpnConnectionRequest) SetOwnerId(v int64) *DescribeVpnConnectionRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeVpnConnectionRequest) SetRegionId(v string) *DescribeVpnConnectionRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeVpnConnectionRequest) SetResourceOwnerAccount(v string) *DescribeVpnConnectionRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeVpnConnectionRequest) SetResourceOwnerId(v int64) *DescribeVpnConnectionRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeVpnConnectionRequest) SetVpnConnectionId(v string) *DescribeVpnConnectionRequest {
	s.VpnConnectionId = &v
	return s
}

type DescribeVpnConnectionResponseBody struct {
	// The ID of the CEN instance to which the transit router belongs.
	AttachInstanceId *string `json:"AttachInstanceId,omitempty" xml:"AttachInstanceId,omitempty"`
	// The type of resource that is associated with the IPsec-VPN connection. Valid values:
	//
	// *   **CEN**: indicates that the IPsec-VPN connection is associated with a transit router of a Cloud Enterprise Network (CEN) instance.
	// *   **NO_ASSOCIATED**: indicates that the IPsec-VPN connection is not associated with a resource.
	// *   **VPNGW**: indicates that the IPsec-VPN connection is associated with a VPN gateway.
	AttachType *string `json:"AttachType,omitempty" xml:"AttachType,omitempty"`
	// The timestamp that indicates when the IPsec-VPN connection was established. Unit: milliseconds.
	//
	// This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// Indicates whether the IPsec-VPN connection is associated with a transit router that belongs to another Alibaba Cloud account. Valid values:
	//
	// *   **true**: yes
	// *   **false**: no
	CrossAccountAuthorized *bool `json:"CrossAccountAuthorized,omitempty" xml:"CrossAccountAuthorized,omitempty"`
	// The ID of the customer gateway.
	CustomerGatewayId *string `json:"CustomerGatewayId,omitempty" xml:"CustomerGatewayId,omitempty"`
	// Indicates whether IPsec negotiations immediately start.
	//
	// *   **true**: Negotiations are reinitiated after the configuration is changed.
	// *   **false**: Negotiations are reinitiated when traffic is detected.
	EffectImmediately *bool `json:"EffectImmediately,omitempty" xml:"EffectImmediately,omitempty"`
	// Indicates whether dead peer detection (DPD) is enabled.
	//
	// *   **false**: disabled
	// *   **true**: enabled
	//
	// After you enable DPD, the initiator of the IPsec-VPN connection sends DPD packets to check the existence and availability of the peer. If no response is received from the peer within a specified period of time, the connection fails. Then, the ISAKMP SA, IPsec SA, and IPsec tunnel are deleted.
	EnableDpd *bool `json:"EnableDpd,omitempty" xml:"EnableDpd,omitempty"`
	// Indicates whether NAT traversal is enabled. Valid values:
	//
	// *   **true**: NAT traversal is enabled.
	// *   **false**: NAT traversal is disabled.
	//
	// After NAT traversal is enabled, the initiator does not check the UDP ports during IKE negotiations and can automatically discover NAT gateway devices along the VPN tunnel.
	EnableNatTraversal *bool `json:"EnableNatTraversal,omitempty" xml:"EnableNatTraversal,omitempty"`
	EnableTunnelsBgp   *bool `json:"EnableTunnelsBgp,omitempty" xml:"EnableTunnelsBgp,omitempty"`
	// The configurations of Phase 1 negotiations.
	IkeConfig *DescribeVpnConnectionResponseBodyIkeConfig `json:"IkeConfig,omitempty" xml:"IkeConfig,omitempty" type:"Struct"`
	// The gateway IP address of the IPsec-VPN connection.
	InternetIp *string `json:"InternetIp,omitempty" xml:"InternetIp,omitempty"`
	// The configuration of phase 2 negotiations.
	IpsecConfig *DescribeVpnConnectionResponseBodyIpsecConfig `json:"IpsecConfig,omitempty" xml:"IpsecConfig,omitempty" type:"Struct"`
	// The CIDR block on the Alibaba Cloud side.
	//
	// CIDR blocks are separated with commas (,).
	LocalSubnet *string `json:"LocalSubnet,omitempty" xml:"LocalSubnet,omitempty"`
	// The name of the IPsec-VPN connection.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The network type of the IPsec-VPN connection. Valid values:
	//
	// *   **public**: an encrypted connection over the Internet.
	// *   **private**: an encrypted connection over private networks.
	NetworkType *string `json:"NetworkType,omitempty" xml:"NetworkType,omitempty"`
	// The CA certificate of the peer.
	RemoteCaCertificate *string `json:"RemoteCaCertificate,omitempty" xml:"RemoteCaCertificate,omitempty"`
	// The CIDR block on the data center side.
	//
	// CIDR blocks are separated with commas (,).
	RemoteSubnet *string `json:"RemoteSubnet,omitempty" xml:"RemoteSubnet,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The bandwidth specification of the IPsec-VPN connection. Unit: **Mbit/s**.
	Spec *string `json:"Spec,omitempty" xml:"Spec,omitempty"`
	// The association status of the IPsec-VPN connection. Valid values:
	//
	// *   **active**: The IPsec-VPN connection is associated with a VPN gateway.
	// *   **init**: The IPsec-VPN connection is not associated with a resource and is being initialized.
	// *   **attaching**: The IPsec-VPN connection is being associated with a transit router.
	// *   **attached**: The IPsec-VPN connection is associated with a transit router.
	// *   **detaching**: The IPsec-VPN connection is being disassociated from a transit router.
	// *   **financialLocked**: The IPsec-VPN connection is locked due to overdue payments.
	// *   **provisioning**: The IPsec-VPN connection is being prepared.
	// *   **updating**: The IPsec-VPN connection is being updated.
	// *   **Upgrading**: The IPsec-VPN connection is being upgraded.
	// *   **deleted**: The IPsec-VPN connection is deleted.
	State *string `json:"State,omitempty" xml:"State,omitempty"`
	// The status of the IPsec-VPN connection. Valid values:
	//
	// *   **ike_sa_not_established**: Phase 1 negotiations failed.
	// *   **ike_sa_established**: Phase 1 negotiations were successful.
	// *   **ipsec_sa_not_established**: Phase 2 negotiations failed.
	// *   **ipsec_sa_established**: Phase 2 negotiations were successful.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The list of tags added to the IPsec-VPN connection.
	Tags *DescribeVpnConnectionResponseBodyTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Struct"`
	// The ID of the transit router with which the IPsec-VPN connection is associated.
	TransitRouterId *string `json:"TransitRouterId,omitempty" xml:"TransitRouterId,omitempty"`
	// The name of the transit router.
	TransitRouterName          *string                                                      `json:"TransitRouterName,omitempty" xml:"TransitRouterName,omitempty"`
	TunnelOptionsSpecification *DescribeVpnConnectionResponseBodyTunnelOptionsSpecification `json:"TunnelOptionsSpecification,omitempty" xml:"TunnelOptionsSpecification,omitempty" type:"Struct"`
	// The information about health checks.
	VcoHealthCheck *DescribeVpnConnectionResponseBodyVcoHealthCheck `json:"VcoHealthCheck,omitempty" xml:"VcoHealthCheck,omitempty" type:"Struct"`
	// The configurations of the BGP routing protocol.
	VpnBgpConfig *DescribeVpnConnectionResponseBodyVpnBgpConfig `json:"VpnBgpConfig,omitempty" xml:"VpnBgpConfig,omitempty" type:"Struct"`
	// The ID of the IPsec-VPN connection.
	VpnConnectionId *string `json:"VpnConnectionId,omitempty" xml:"VpnConnectionId,omitempty"`
	// The ID of the VPN gateway.
	VpnGatewayId *string `json:"VpnGatewayId,omitempty" xml:"VpnGatewayId,omitempty"`
	// The ID of the zone where the IPsec-VPN connection is deployed.
	//
	// You can call [DescribeZones](~~36064~~) to query zone IDs.
	ZoneNo *string `json:"ZoneNo,omitempty" xml:"ZoneNo,omitempty"`
}

func (s DescribeVpnConnectionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpnConnectionResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeVpnConnectionResponseBody) SetAttachInstanceId(v string) *DescribeVpnConnectionResponseBody {
	s.AttachInstanceId = &v
	return s
}

func (s *DescribeVpnConnectionResponseBody) SetAttachType(v string) *DescribeVpnConnectionResponseBody {
	s.AttachType = &v
	return s
}

func (s *DescribeVpnConnectionResponseBody) SetCreateTime(v int64) *DescribeVpnConnectionResponseBody {
	s.CreateTime = &v
	return s
}

func (s *DescribeVpnConnectionResponseBody) SetCrossAccountAuthorized(v bool) *DescribeVpnConnectionResponseBody {
	s.CrossAccountAuthorized = &v
	return s
}

func (s *DescribeVpnConnectionResponseBody) SetCustomerGatewayId(v string) *DescribeVpnConnectionResponseBody {
	s.CustomerGatewayId = &v
	return s
}

func (s *DescribeVpnConnectionResponseBody) SetEffectImmediately(v bool) *DescribeVpnConnectionResponseBody {
	s.EffectImmediately = &v
	return s
}

func (s *DescribeVpnConnectionResponseBody) SetEnableDpd(v bool) *DescribeVpnConnectionResponseBody {
	s.EnableDpd = &v
	return s
}

func (s *DescribeVpnConnectionResponseBody) SetEnableNatTraversal(v bool) *DescribeVpnConnectionResponseBody {
	s.EnableNatTraversal = &v
	return s
}

func (s *DescribeVpnConnectionResponseBody) SetEnableTunnelsBgp(v bool) *DescribeVpnConnectionResponseBody {
	s.EnableTunnelsBgp = &v
	return s
}

func (s *DescribeVpnConnectionResponseBody) SetIkeConfig(v *DescribeVpnConnectionResponseBodyIkeConfig) *DescribeVpnConnectionResponseBody {
	s.IkeConfig = v
	return s
}

func (s *DescribeVpnConnectionResponseBody) SetInternetIp(v string) *DescribeVpnConnectionResponseBody {
	s.InternetIp = &v
	return s
}

func (s *DescribeVpnConnectionResponseBody) SetIpsecConfig(v *DescribeVpnConnectionResponseBodyIpsecConfig) *DescribeVpnConnectionResponseBody {
	s.IpsecConfig = v
	return s
}

func (s *DescribeVpnConnectionResponseBody) SetLocalSubnet(v string) *DescribeVpnConnectionResponseBody {
	s.LocalSubnet = &v
	return s
}

func (s *DescribeVpnConnectionResponseBody) SetName(v string) *DescribeVpnConnectionResponseBody {
	s.Name = &v
	return s
}

func (s *DescribeVpnConnectionResponseBody) SetNetworkType(v string) *DescribeVpnConnectionResponseBody {
	s.NetworkType = &v
	return s
}

func (s *DescribeVpnConnectionResponseBody) SetRemoteCaCertificate(v string) *DescribeVpnConnectionResponseBody {
	s.RemoteCaCertificate = &v
	return s
}

func (s *DescribeVpnConnectionResponseBody) SetRemoteSubnet(v string) *DescribeVpnConnectionResponseBody {
	s.RemoteSubnet = &v
	return s
}

func (s *DescribeVpnConnectionResponseBody) SetRequestId(v string) *DescribeVpnConnectionResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeVpnConnectionResponseBody) SetSpec(v string) *DescribeVpnConnectionResponseBody {
	s.Spec = &v
	return s
}

func (s *DescribeVpnConnectionResponseBody) SetState(v string) *DescribeVpnConnectionResponseBody {
	s.State = &v
	return s
}

func (s *DescribeVpnConnectionResponseBody) SetStatus(v string) *DescribeVpnConnectionResponseBody {
	s.Status = &v
	return s
}

func (s *DescribeVpnConnectionResponseBody) SetTags(v *DescribeVpnConnectionResponseBodyTags) *DescribeVpnConnectionResponseBody {
	s.Tags = v
	return s
}

func (s *DescribeVpnConnectionResponseBody) SetTransitRouterId(v string) *DescribeVpnConnectionResponseBody {
	s.TransitRouterId = &v
	return s
}

func (s *DescribeVpnConnectionResponseBody) SetTransitRouterName(v string) *DescribeVpnConnectionResponseBody {
	s.TransitRouterName = &v
	return s
}

func (s *DescribeVpnConnectionResponseBody) SetTunnelOptionsSpecification(v *DescribeVpnConnectionResponseBodyTunnelOptionsSpecification) *DescribeVpnConnectionResponseBody {
	s.TunnelOptionsSpecification = v
	return s
}

func (s *DescribeVpnConnectionResponseBody) SetVcoHealthCheck(v *DescribeVpnConnectionResponseBodyVcoHealthCheck) *DescribeVpnConnectionResponseBody {
	s.VcoHealthCheck = v
	return s
}

func (s *DescribeVpnConnectionResponseBody) SetVpnBgpConfig(v *DescribeVpnConnectionResponseBodyVpnBgpConfig) *DescribeVpnConnectionResponseBody {
	s.VpnBgpConfig = v
	return s
}

func (s *DescribeVpnConnectionResponseBody) SetVpnConnectionId(v string) *DescribeVpnConnectionResponseBody {
	s.VpnConnectionId = &v
	return s
}

func (s *DescribeVpnConnectionResponseBody) SetVpnGatewayId(v string) *DescribeVpnConnectionResponseBody {
	s.VpnGatewayId = &v
	return s
}

func (s *DescribeVpnConnectionResponseBody) SetZoneNo(v string) *DescribeVpnConnectionResponseBody {
	s.ZoneNo = &v
	return s
}

type DescribeVpnConnectionResponseBodyIkeConfig struct {
	// The IKE authentication algorithm.
	IkeAuthAlg *string `json:"IkeAuthAlg,omitempty" xml:"IkeAuthAlg,omitempty"`
	// The IKE encryption algorithm.
	IkeEncAlg *string `json:"IkeEncAlg,omitempty" xml:"IkeEncAlg,omitempty"`
	// The IKE lifetime. Unit: seconds.
	IkeLifetime *int64 `json:"IkeLifetime,omitempty" xml:"IkeLifetime,omitempty"`
	// The IKE negotiation mode.
	//
	// *   **main**: This mode offers higher security during negotiations.
	// *   **aggressive**: This mode is faster and has a higher success rate.
	IkeMode *string `json:"IkeMode,omitempty" xml:"IkeMode,omitempty"`
	// The DH group.
	IkePfs *string `json:"IkePfs,omitempty" xml:"IkePfs,omitempty"`
	// The version of the IKE protocol.
	//
	// *   **ikev1**
	// *   **ikev2**
	//
	// Compared with IKEv1, IKEv2 simplifies the SA negotiation process and is more suitable for scenarios in which multiple CIDR blocks are used.
	IkeVersion *string `json:"IkeVersion,omitempty" xml:"IkeVersion,omitempty"`
	// The identifier on the data center side.
	LocalId *string `json:"LocalId,omitempty" xml:"LocalId,omitempty"`
	// The pre-shared key.
	Psk *string `json:"Psk,omitempty" xml:"Psk,omitempty"`
	// The identifier on the Alibaba Cloud side.
	RemoteId *string `json:"RemoteId,omitempty" xml:"RemoteId,omitempty"`
}

func (s DescribeVpnConnectionResponseBodyIkeConfig) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpnConnectionResponseBodyIkeConfig) GoString() string {
	return s.String()
}

func (s *DescribeVpnConnectionResponseBodyIkeConfig) SetIkeAuthAlg(v string) *DescribeVpnConnectionResponseBodyIkeConfig {
	s.IkeAuthAlg = &v
	return s
}

func (s *DescribeVpnConnectionResponseBodyIkeConfig) SetIkeEncAlg(v string) *DescribeVpnConnectionResponseBodyIkeConfig {
	s.IkeEncAlg = &v
	return s
}

func (s *DescribeVpnConnectionResponseBodyIkeConfig) SetIkeLifetime(v int64) *DescribeVpnConnectionResponseBodyIkeConfig {
	s.IkeLifetime = &v
	return s
}

func (s *DescribeVpnConnectionResponseBodyIkeConfig) SetIkeMode(v string) *DescribeVpnConnectionResponseBodyIkeConfig {
	s.IkeMode = &v
	return s
}

func (s *DescribeVpnConnectionResponseBodyIkeConfig) SetIkePfs(v string) *DescribeVpnConnectionResponseBodyIkeConfig {
	s.IkePfs = &v
	return s
}

func (s *DescribeVpnConnectionResponseBodyIkeConfig) SetIkeVersion(v string) *DescribeVpnConnectionResponseBodyIkeConfig {
	s.IkeVersion = &v
	return s
}

func (s *DescribeVpnConnectionResponseBodyIkeConfig) SetLocalId(v string) *DescribeVpnConnectionResponseBodyIkeConfig {
	s.LocalId = &v
	return s
}

func (s *DescribeVpnConnectionResponseBodyIkeConfig) SetPsk(v string) *DescribeVpnConnectionResponseBodyIkeConfig {
	s.Psk = &v
	return s
}

func (s *DescribeVpnConnectionResponseBodyIkeConfig) SetRemoteId(v string) *DescribeVpnConnectionResponseBodyIkeConfig {
	s.RemoteId = &v
	return s
}

type DescribeVpnConnectionResponseBodyIpsecConfig struct {
	// The IPsec authentication algorithm.
	IpsecAuthAlg *string `json:"IpsecAuthAlg,omitempty" xml:"IpsecAuthAlg,omitempty"`
	// The IPsec encryption algorithm.
	IpsecEncAlg *string `json:"IpsecEncAlg,omitempty" xml:"IpsecEncAlg,omitempty"`
	// The IPsec lifetime. Unit: seconds.
	IpsecLifetime *int64 `json:"IpsecLifetime,omitempty" xml:"IpsecLifetime,omitempty"`
	// The DH group.
	IpsecPfs *string `json:"IpsecPfs,omitempty" xml:"IpsecPfs,omitempty"`
}

func (s DescribeVpnConnectionResponseBodyIpsecConfig) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpnConnectionResponseBodyIpsecConfig) GoString() string {
	return s.String()
}

func (s *DescribeVpnConnectionResponseBodyIpsecConfig) SetIpsecAuthAlg(v string) *DescribeVpnConnectionResponseBodyIpsecConfig {
	s.IpsecAuthAlg = &v
	return s
}

func (s *DescribeVpnConnectionResponseBodyIpsecConfig) SetIpsecEncAlg(v string) *DescribeVpnConnectionResponseBodyIpsecConfig {
	s.IpsecEncAlg = &v
	return s
}

func (s *DescribeVpnConnectionResponseBodyIpsecConfig) SetIpsecLifetime(v int64) *DescribeVpnConnectionResponseBodyIpsecConfig {
	s.IpsecLifetime = &v
	return s
}

func (s *DescribeVpnConnectionResponseBodyIpsecConfig) SetIpsecPfs(v string) *DescribeVpnConnectionResponseBodyIpsecConfig {
	s.IpsecPfs = &v
	return s
}

type DescribeVpnConnectionResponseBodyTags struct {
	Tag []*DescribeVpnConnectionResponseBodyTagsTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s DescribeVpnConnectionResponseBodyTags) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpnConnectionResponseBodyTags) GoString() string {
	return s.String()
}

func (s *DescribeVpnConnectionResponseBodyTags) SetTag(v []*DescribeVpnConnectionResponseBodyTagsTag) *DescribeVpnConnectionResponseBodyTags {
	s.Tag = v
	return s
}

type DescribeVpnConnectionResponseBodyTagsTag struct {
	// The tag key.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeVpnConnectionResponseBodyTagsTag) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpnConnectionResponseBodyTagsTag) GoString() string {
	return s.String()
}

func (s *DescribeVpnConnectionResponseBodyTagsTag) SetKey(v string) *DescribeVpnConnectionResponseBodyTagsTag {
	s.Key = &v
	return s
}

func (s *DescribeVpnConnectionResponseBodyTagsTag) SetValue(v string) *DescribeVpnConnectionResponseBodyTagsTag {
	s.Value = &v
	return s
}

type DescribeVpnConnectionResponseBodyTunnelOptionsSpecification struct {
	TunnelOptions []*DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptions `json:"TunnelOptions,omitempty" xml:"TunnelOptions,omitempty" type:"Repeated"`
}

func (s DescribeVpnConnectionResponseBodyTunnelOptionsSpecification) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpnConnectionResponseBodyTunnelOptionsSpecification) GoString() string {
	return s.String()
}

func (s *DescribeVpnConnectionResponseBodyTunnelOptionsSpecification) SetTunnelOptions(v []*DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptions) *DescribeVpnConnectionResponseBodyTunnelOptionsSpecification {
	s.TunnelOptions = v
	return s
}

type DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptions struct {
	CustomerGatewayId   *string                                                                                    `json:"CustomerGatewayId,omitempty" xml:"CustomerGatewayId,omitempty"`
	EnableDpd           *string                                                                                    `json:"EnableDpd,omitempty" xml:"EnableDpd,omitempty"`
	EnableNatTraversal  *string                                                                                    `json:"EnableNatTraversal,omitempty" xml:"EnableNatTraversal,omitempty"`
	InternetIp          *string                                                                                    `json:"InternetIp,omitempty" xml:"InternetIp,omitempty"`
	RemoteCaCertificate *string                                                                                    `json:"RemoteCaCertificate,omitempty" xml:"RemoteCaCertificate,omitempty"`
	Role                *string                                                                                    `json:"Role,omitempty" xml:"Role,omitempty"`
	State               *string                                                                                    `json:"State,omitempty" xml:"State,omitempty"`
	Status              *string                                                                                    `json:"Status,omitempty" xml:"Status,omitempty"`
	TunnelBgpConfig     *DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelBgpConfig   `json:"TunnelBgpConfig,omitempty" xml:"TunnelBgpConfig,omitempty" type:"Struct"`
	TunnelId            *string                                                                                    `json:"TunnelId,omitempty" xml:"TunnelId,omitempty"`
	TunnelIkeConfig     *DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig   `json:"TunnelIkeConfig,omitempty" xml:"TunnelIkeConfig,omitempty" type:"Struct"`
	TunnelIpsecConfig   *DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIpsecConfig `json:"TunnelIpsecConfig,omitempty" xml:"TunnelIpsecConfig,omitempty" type:"Struct"`
	ZoneNo              *string                                                                                    `json:"ZoneNo,omitempty" xml:"ZoneNo,omitempty"`
}

func (s DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptions) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptions) GoString() string {
	return s.String()
}

func (s *DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptions) SetCustomerGatewayId(v string) *DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptions {
	s.CustomerGatewayId = &v
	return s
}

func (s *DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptions) SetEnableDpd(v string) *DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptions {
	s.EnableDpd = &v
	return s
}

func (s *DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptions) SetEnableNatTraversal(v string) *DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptions {
	s.EnableNatTraversal = &v
	return s
}

func (s *DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptions) SetInternetIp(v string) *DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptions {
	s.InternetIp = &v
	return s
}

func (s *DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptions) SetRemoteCaCertificate(v string) *DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptions {
	s.RemoteCaCertificate = &v
	return s
}

func (s *DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptions) SetRole(v string) *DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptions {
	s.Role = &v
	return s
}

func (s *DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptions) SetState(v string) *DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptions {
	s.State = &v
	return s
}

func (s *DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptions) SetStatus(v string) *DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptions {
	s.Status = &v
	return s
}

func (s *DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptions) SetTunnelBgpConfig(v *DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelBgpConfig) *DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptions {
	s.TunnelBgpConfig = v
	return s
}

func (s *DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptions) SetTunnelId(v string) *DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptions {
	s.TunnelId = &v
	return s
}

func (s *DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptions) SetTunnelIkeConfig(v *DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig) *DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptions {
	s.TunnelIkeConfig = v
	return s
}

func (s *DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptions) SetTunnelIpsecConfig(v *DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIpsecConfig) *DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptions {
	s.TunnelIpsecConfig = v
	return s
}

func (s *DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptions) SetZoneNo(v string) *DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptions {
	s.ZoneNo = &v
	return s
}

type DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelBgpConfig struct {
	BgpStatus  *string `json:"BgpStatus,omitempty" xml:"BgpStatus,omitempty"`
	LocalAsn   *string `json:"LocalAsn,omitempty" xml:"LocalAsn,omitempty"`
	LocalBgpIp *string `json:"LocalBgpIp,omitempty" xml:"LocalBgpIp,omitempty"`
	PeerAsn    *string `json:"PeerAsn,omitempty" xml:"PeerAsn,omitempty"`
	PeerBgpIp  *string `json:"PeerBgpIp,omitempty" xml:"PeerBgpIp,omitempty"`
	TunnelCidr *string `json:"TunnelCidr,omitempty" xml:"TunnelCidr,omitempty"`
}

func (s DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelBgpConfig) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelBgpConfig) GoString() string {
	return s.String()
}

func (s *DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelBgpConfig) SetBgpStatus(v string) *DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelBgpConfig {
	s.BgpStatus = &v
	return s
}

func (s *DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelBgpConfig) SetLocalAsn(v string) *DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelBgpConfig {
	s.LocalAsn = &v
	return s
}

func (s *DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelBgpConfig) SetLocalBgpIp(v string) *DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelBgpConfig {
	s.LocalBgpIp = &v
	return s
}

func (s *DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelBgpConfig) SetPeerAsn(v string) *DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelBgpConfig {
	s.PeerAsn = &v
	return s
}

func (s *DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelBgpConfig) SetPeerBgpIp(v string) *DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelBgpConfig {
	s.PeerBgpIp = &v
	return s
}

func (s *DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelBgpConfig) SetTunnelCidr(v string) *DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelBgpConfig {
	s.TunnelCidr = &v
	return s
}

type DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig struct {
	IkeAuthAlg  *string `json:"IkeAuthAlg,omitempty" xml:"IkeAuthAlg,omitempty"`
	IkeEncAlg   *string `json:"IkeEncAlg,omitempty" xml:"IkeEncAlg,omitempty"`
	IkeLifetime *string `json:"IkeLifetime,omitempty" xml:"IkeLifetime,omitempty"`
	IkeMode     *string `json:"IkeMode,omitempty" xml:"IkeMode,omitempty"`
	IkePfs      *string `json:"IkePfs,omitempty" xml:"IkePfs,omitempty"`
	IkeVersion  *string `json:"IkeVersion,omitempty" xml:"IkeVersion,omitempty"`
	LocalId     *string `json:"LocalId,omitempty" xml:"LocalId,omitempty"`
	Psk         *string `json:"Psk,omitempty" xml:"Psk,omitempty"`
	RemoteId    *string `json:"RemoteId,omitempty" xml:"RemoteId,omitempty"`
}

func (s DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig) GoString() string {
	return s.String()
}

func (s *DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig) SetIkeAuthAlg(v string) *DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig {
	s.IkeAuthAlg = &v
	return s
}

func (s *DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig) SetIkeEncAlg(v string) *DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig {
	s.IkeEncAlg = &v
	return s
}

func (s *DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig) SetIkeLifetime(v string) *DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig {
	s.IkeLifetime = &v
	return s
}

func (s *DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig) SetIkeMode(v string) *DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig {
	s.IkeMode = &v
	return s
}

func (s *DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig) SetIkePfs(v string) *DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig {
	s.IkePfs = &v
	return s
}

func (s *DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig) SetIkeVersion(v string) *DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig {
	s.IkeVersion = &v
	return s
}

func (s *DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig) SetLocalId(v string) *DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig {
	s.LocalId = &v
	return s
}

func (s *DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig) SetPsk(v string) *DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig {
	s.Psk = &v
	return s
}

func (s *DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig) SetRemoteId(v string) *DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig {
	s.RemoteId = &v
	return s
}

type DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIpsecConfig struct {
	IpsecAuthAlg  *string `json:"IpsecAuthAlg,omitempty" xml:"IpsecAuthAlg,omitempty"`
	IpsecEncAlg   *string `json:"IpsecEncAlg,omitempty" xml:"IpsecEncAlg,omitempty"`
	IpsecLifetime *string `json:"IpsecLifetime,omitempty" xml:"IpsecLifetime,omitempty"`
	IpsecPfs      *string `json:"IpsecPfs,omitempty" xml:"IpsecPfs,omitempty"`
}

func (s DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIpsecConfig) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIpsecConfig) GoString() string {
	return s.String()
}

func (s *DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIpsecConfig) SetIpsecAuthAlg(v string) *DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIpsecConfig {
	s.IpsecAuthAlg = &v
	return s
}

func (s *DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIpsecConfig) SetIpsecEncAlg(v string) *DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIpsecConfig {
	s.IpsecEncAlg = &v
	return s
}

func (s *DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIpsecConfig) SetIpsecLifetime(v string) *DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIpsecConfig {
	s.IpsecLifetime = &v
	return s
}

func (s *DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIpsecConfig) SetIpsecPfs(v string) *DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIpsecConfig {
	s.IpsecPfs = &v
	return s
}

type DescribeVpnConnectionResponseBodyVcoHealthCheck struct {
	// The destination IP address.
	Dip *string `json:"Dip,omitempty" xml:"Dip,omitempty"`
	// Indicates whether health checks are enabled.
	//
	// *   **false**: disabled
	// *   **true**: enabled
	Enable *string `json:"Enable,omitempty" xml:"Enable,omitempty"`
	// The interval of health check retries. Unit: seconds.
	Interval *int32 `json:"Interval,omitempty" xml:"Interval,omitempty"`
	// Indicates whether advertised routes are withdrawn when the health check fails.
	//
	// *   **revoke_route**: published routes are withdrawn.
	// *   **reserve_route**: published routes are not withdrawn.
	Policy *string `json:"Policy,omitempty" xml:"Policy,omitempty"`
	// The maximum number of health check retries.
	Retry *int32 `json:"Retry,omitempty" xml:"Retry,omitempty"`
	// The source IP address.
	Sip *string `json:"Sip,omitempty" xml:"Sip,omitempty"`
	// The status of the health check.
	//
	// *   **failed**: abnormal
	// *   **success**: normal
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeVpnConnectionResponseBodyVcoHealthCheck) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpnConnectionResponseBodyVcoHealthCheck) GoString() string {
	return s.String()
}

func (s *DescribeVpnConnectionResponseBodyVcoHealthCheck) SetDip(v string) *DescribeVpnConnectionResponseBodyVcoHealthCheck {
	s.Dip = &v
	return s
}

func (s *DescribeVpnConnectionResponseBodyVcoHealthCheck) SetEnable(v string) *DescribeVpnConnectionResponseBodyVcoHealthCheck {
	s.Enable = &v
	return s
}

func (s *DescribeVpnConnectionResponseBodyVcoHealthCheck) SetInterval(v int32) *DescribeVpnConnectionResponseBodyVcoHealthCheck {
	s.Interval = &v
	return s
}

func (s *DescribeVpnConnectionResponseBodyVcoHealthCheck) SetPolicy(v string) *DescribeVpnConnectionResponseBodyVcoHealthCheck {
	s.Policy = &v
	return s
}

func (s *DescribeVpnConnectionResponseBodyVcoHealthCheck) SetRetry(v int32) *DescribeVpnConnectionResponseBodyVcoHealthCheck {
	s.Retry = &v
	return s
}

func (s *DescribeVpnConnectionResponseBodyVcoHealthCheck) SetSip(v string) *DescribeVpnConnectionResponseBodyVcoHealthCheck {
	s.Sip = &v
	return s
}

func (s *DescribeVpnConnectionResponseBodyVcoHealthCheck) SetStatus(v string) *DescribeVpnConnectionResponseBodyVcoHealthCheck {
	s.Status = &v
	return s
}

type DescribeVpnConnectionResponseBodyVpnBgpConfig struct {
	// The authentication key of the BGP routing protocol.
	AuthKey *string `json:"AuthKey,omitempty" xml:"AuthKey,omitempty"`
	// The status of the BGP routing protocol. Valid values:
	//
	// *   **true**: enabled
	// *   **false**: disabled
	EnableBgp *string `json:"EnableBgp,omitempty" xml:"EnableBgp,omitempty"`
	// The ASN on the Alibaba Cloud side.
	LocalAsn *int64 `json:"LocalAsn,omitempty" xml:"LocalAsn,omitempty"`
	// The BGP IP address on the Alibaba Cloud side.
	LocalBgpIp *string `json:"LocalBgpIp,omitempty" xml:"LocalBgpIp,omitempty"`
	// The autonomous system number (ASN) of the peer.
	PeerAsn *int64 `json:"PeerAsn,omitempty" xml:"PeerAsn,omitempty"`
	// The BGP IP address of the peer.
	PeerBgpIp *string `json:"PeerBgpIp,omitempty" xml:"PeerBgpIp,omitempty"`
	// The negotiation status of the BGP routing protocol.
	//
	// *   **success**: normal
	// *   **failed**: abnormal
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The CIDR block of the IPsec tunnel. The CIDR block belongs to 169.254.0.0/16. The mask of the CIDR block is 30 bits in length.
	TunnelCidr *string `json:"TunnelCidr,omitempty" xml:"TunnelCidr,omitempty"`
}

func (s DescribeVpnConnectionResponseBodyVpnBgpConfig) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpnConnectionResponseBodyVpnBgpConfig) GoString() string {
	return s.String()
}

func (s *DescribeVpnConnectionResponseBodyVpnBgpConfig) SetAuthKey(v string) *DescribeVpnConnectionResponseBodyVpnBgpConfig {
	s.AuthKey = &v
	return s
}

func (s *DescribeVpnConnectionResponseBodyVpnBgpConfig) SetEnableBgp(v string) *DescribeVpnConnectionResponseBodyVpnBgpConfig {
	s.EnableBgp = &v
	return s
}

func (s *DescribeVpnConnectionResponseBodyVpnBgpConfig) SetLocalAsn(v int64) *DescribeVpnConnectionResponseBodyVpnBgpConfig {
	s.LocalAsn = &v
	return s
}

func (s *DescribeVpnConnectionResponseBodyVpnBgpConfig) SetLocalBgpIp(v string) *DescribeVpnConnectionResponseBodyVpnBgpConfig {
	s.LocalBgpIp = &v
	return s
}

func (s *DescribeVpnConnectionResponseBodyVpnBgpConfig) SetPeerAsn(v int64) *DescribeVpnConnectionResponseBodyVpnBgpConfig {
	s.PeerAsn = &v
	return s
}

func (s *DescribeVpnConnectionResponseBodyVpnBgpConfig) SetPeerBgpIp(v string) *DescribeVpnConnectionResponseBodyVpnBgpConfig {
	s.PeerBgpIp = &v
	return s
}

func (s *DescribeVpnConnectionResponseBodyVpnBgpConfig) SetStatus(v string) *DescribeVpnConnectionResponseBodyVpnBgpConfig {
	s.Status = &v
	return s
}

func (s *DescribeVpnConnectionResponseBodyVpnBgpConfig) SetTunnelCidr(v string) *DescribeVpnConnectionResponseBodyVpnBgpConfig {
	s.TunnelCidr = &v
	return s
}

type DescribeVpnConnectionResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeVpnConnectionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeVpnConnectionResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpnConnectionResponse) GoString() string {
	return s.String()
}

func (s *DescribeVpnConnectionResponse) SetHeaders(v map[string]*string) *DescribeVpnConnectionResponse {
	s.Headers = v
	return s
}

func (s *DescribeVpnConnectionResponse) SetStatusCode(v int32) *DescribeVpnConnectionResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeVpnConnectionResponse) SetBody(v *DescribeVpnConnectionResponseBody) *DescribeVpnConnectionResponse {
	s.Body = v
	return s
}

type DescribeVpnConnectionLogsRequest struct {
	// The beginning of the time range to query. The value must be a UNIX timestamp. For example, 1671003744 specifies 15:42:24 (UTC+8) on December 14, 2022.
	//
	// >  If you specify **From**, you must also specify **To** or **MinutePeriod**.
	From *int32 `json:"From,omitempty" xml:"From,omitempty"`
	// The interval at which log data is queried. Valid values: **1** to **10**. Unit: minutes.
	//
	// >  If both **From** and **To** are not specified, you must specify **MinutePeriod**.
	MinutePeriod *int32  `json:"MinutePeriod,omitempty" xml:"MinutePeriod,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of the page to return. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Valid values: **1** to **50**. Default value: **10**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the region to which the IPsec-VPN connection belongs.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The end of the time range to query. The value must be a UNIX timestamp. For example, 1671004344 specifies 15:52:24 (UTC+8) on December 14, 2022.
	//
	// >  If you specify **To**, you must also specify **From** or **MinutePeriod**.
	To       *int32  `json:"To,omitempty" xml:"To,omitempty"`
	TunnelId *string `json:"TunnelId,omitempty" xml:"TunnelId,omitempty"`
	// The ID of the IPsec-VPN connection.
	VpnConnectionId *string `json:"VpnConnectionId,omitempty" xml:"VpnConnectionId,omitempty"`
}

func (s DescribeVpnConnectionLogsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpnConnectionLogsRequest) GoString() string {
	return s.String()
}

func (s *DescribeVpnConnectionLogsRequest) SetFrom(v int32) *DescribeVpnConnectionLogsRequest {
	s.From = &v
	return s
}

func (s *DescribeVpnConnectionLogsRequest) SetMinutePeriod(v int32) *DescribeVpnConnectionLogsRequest {
	s.MinutePeriod = &v
	return s
}

func (s *DescribeVpnConnectionLogsRequest) SetOwnerAccount(v string) *DescribeVpnConnectionLogsRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeVpnConnectionLogsRequest) SetOwnerId(v int64) *DescribeVpnConnectionLogsRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeVpnConnectionLogsRequest) SetPageNumber(v int32) *DescribeVpnConnectionLogsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeVpnConnectionLogsRequest) SetPageSize(v int32) *DescribeVpnConnectionLogsRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeVpnConnectionLogsRequest) SetRegionId(v string) *DescribeVpnConnectionLogsRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeVpnConnectionLogsRequest) SetResourceOwnerAccount(v string) *DescribeVpnConnectionLogsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeVpnConnectionLogsRequest) SetResourceOwnerId(v int64) *DescribeVpnConnectionLogsRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeVpnConnectionLogsRequest) SetTo(v int32) *DescribeVpnConnectionLogsRequest {
	s.To = &v
	return s
}

func (s *DescribeVpnConnectionLogsRequest) SetTunnelId(v string) *DescribeVpnConnectionLogsRequest {
	s.TunnelId = &v
	return s
}

func (s *DescribeVpnConnectionLogsRequest) SetVpnConnectionId(v string) *DescribeVpnConnectionLogsRequest {
	s.VpnConnectionId = &v
	return s
}

type DescribeVpnConnectionLogsResponseBody struct {
	// The number of entries on the current page.
	Count *int32 `json:"Count,omitempty" xml:"Count,omitempty"`
	// An array of strings.
	//
	// Each item in the array is a log entry.
	Data *DescribeVpnConnectionLogsResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// Indicates whether the log is accurate. Valid values:
	//
	// *   **true**: accurate
	// *   **false**: inaccurate
	IsCompleted *bool `json:"IsCompleted,omitempty" xml:"IsCompleted,omitempty"`
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeVpnConnectionLogsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpnConnectionLogsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeVpnConnectionLogsResponseBody) SetCount(v int32) *DescribeVpnConnectionLogsResponseBody {
	s.Count = &v
	return s
}

func (s *DescribeVpnConnectionLogsResponseBody) SetData(v *DescribeVpnConnectionLogsResponseBodyData) *DescribeVpnConnectionLogsResponseBody {
	s.Data = v
	return s
}

func (s *DescribeVpnConnectionLogsResponseBody) SetIsCompleted(v bool) *DescribeVpnConnectionLogsResponseBody {
	s.IsCompleted = &v
	return s
}

func (s *DescribeVpnConnectionLogsResponseBody) SetPageNumber(v int32) *DescribeVpnConnectionLogsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeVpnConnectionLogsResponseBody) SetPageSize(v int32) *DescribeVpnConnectionLogsResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeVpnConnectionLogsResponseBody) SetRequestId(v string) *DescribeVpnConnectionLogsResponseBody {
	s.RequestId = &v
	return s
}

type DescribeVpnConnectionLogsResponseBodyData struct {
	Logs []*string `json:"Logs,omitempty" xml:"Logs,omitempty" type:"Repeated"`
}

func (s DescribeVpnConnectionLogsResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpnConnectionLogsResponseBodyData) GoString() string {
	return s.String()
}

func (s *DescribeVpnConnectionLogsResponseBodyData) SetLogs(v []*string) *DescribeVpnConnectionLogsResponseBodyData {
	s.Logs = v
	return s
}

type DescribeVpnConnectionLogsResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeVpnConnectionLogsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeVpnConnectionLogsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpnConnectionLogsResponse) GoString() string {
	return s.String()
}

func (s *DescribeVpnConnectionLogsResponse) SetHeaders(v map[string]*string) *DescribeVpnConnectionLogsResponse {
	s.Headers = v
	return s
}

func (s *DescribeVpnConnectionLogsResponse) SetStatusCode(v int32) *DescribeVpnConnectionLogsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeVpnConnectionLogsResponse) SetBody(v *DescribeVpnConnectionLogsResponseBody) *DescribeVpnConnectionLogsResponse {
	s.Body = v
	return s
}

type DescribeVpnConnectionsRequest struct {
	// The ID of the customer gateway.
	CustomerGatewayId *string `json:"CustomerGatewayId,omitempty" xml:"CustomerGatewayId,omitempty"`
	OwnerAccount      *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId           *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of the page to return. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Default value: **10**. Valid values: **1** to **50**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the region where the IPsec-VPN connection is created.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The tag value.
	//
	// The tag value can be an empty string and cannot exceed 128 characters in length. It cannot start with `aliyun` or `acs:`, and cannot contain `http://` or `https://`.
	//
	// Each tag key corresponds to one tag value. You can specify up to 20 tag values in each call.
	Tag []*DescribeVpnConnectionsRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
	// The ID of the IPsec-VPN connection.
	VpnConnectionId *string `json:"VpnConnectionId,omitempty" xml:"VpnConnectionId,omitempty"`
	// The ID of the VPN gateway.
	VpnGatewayId *string `json:"VpnGatewayId,omitempty" xml:"VpnGatewayId,omitempty"`
}

func (s DescribeVpnConnectionsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpnConnectionsRequest) GoString() string {
	return s.String()
}

func (s *DescribeVpnConnectionsRequest) SetCustomerGatewayId(v string) *DescribeVpnConnectionsRequest {
	s.CustomerGatewayId = &v
	return s
}

func (s *DescribeVpnConnectionsRequest) SetOwnerAccount(v string) *DescribeVpnConnectionsRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeVpnConnectionsRequest) SetOwnerId(v int64) *DescribeVpnConnectionsRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeVpnConnectionsRequest) SetPageNumber(v int32) *DescribeVpnConnectionsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeVpnConnectionsRequest) SetPageSize(v int32) *DescribeVpnConnectionsRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeVpnConnectionsRequest) SetRegionId(v string) *DescribeVpnConnectionsRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeVpnConnectionsRequest) SetResourceOwnerAccount(v string) *DescribeVpnConnectionsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeVpnConnectionsRequest) SetResourceOwnerId(v int64) *DescribeVpnConnectionsRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeVpnConnectionsRequest) SetTag(v []*DescribeVpnConnectionsRequestTag) *DescribeVpnConnectionsRequest {
	s.Tag = v
	return s
}

func (s *DescribeVpnConnectionsRequest) SetVpnConnectionId(v string) *DescribeVpnConnectionsRequest {
	s.VpnConnectionId = &v
	return s
}

func (s *DescribeVpnConnectionsRequest) SetVpnGatewayId(v string) *DescribeVpnConnectionsRequest {
	s.VpnGatewayId = &v
	return s
}

type DescribeVpnConnectionsRequestTag struct {
	// The tag key. The tag key cannot be an empty string.
	//
	// It can be at most 64 characters in length, and cannot contain `http://` or `https://`. It cannot start with `aliyun` or `acs:`.
	//
	// You can specify at most 20 tag keys in each call.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value.
	//
	// The tag value can be an empty string and cannot exceed 128 characters in length. It cannot start with `aliyun` or `acs:`, and cannot contain `http://` or `https://`.
	//
	// Each tag key corresponds to one tag value. You can specify at most 20 tag values in each call.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeVpnConnectionsRequestTag) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpnConnectionsRequestTag) GoString() string {
	return s.String()
}

func (s *DescribeVpnConnectionsRequestTag) SetKey(v string) *DescribeVpnConnectionsRequestTag {
	s.Key = &v
	return s
}

func (s *DescribeVpnConnectionsRequestTag) SetValue(v string) *DescribeVpnConnectionsRequestTag {
	s.Value = &v
	return s
}

type DescribeVpnConnectionsResponseBody struct {
	// The page number.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
	// The tag value.
	VpnConnections *DescribeVpnConnectionsResponseBodyVpnConnections `json:"VpnConnections,omitempty" xml:"VpnConnections,omitempty" type:"Struct"`
}

func (s DescribeVpnConnectionsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpnConnectionsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeVpnConnectionsResponseBody) SetPageNumber(v int32) *DescribeVpnConnectionsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeVpnConnectionsResponseBody) SetPageSize(v int32) *DescribeVpnConnectionsResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeVpnConnectionsResponseBody) SetRequestId(v string) *DescribeVpnConnectionsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeVpnConnectionsResponseBody) SetTotalCount(v int32) *DescribeVpnConnectionsResponseBody {
	s.TotalCount = &v
	return s
}

func (s *DescribeVpnConnectionsResponseBody) SetVpnConnections(v *DescribeVpnConnectionsResponseBodyVpnConnections) *DescribeVpnConnectionsResponseBody {
	s.VpnConnections = v
	return s
}

type DescribeVpnConnectionsResponseBodyVpnConnections struct {
	VpnConnection []*DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnection `json:"VpnConnection,omitempty" xml:"VpnConnection,omitempty" type:"Repeated"`
}

func (s DescribeVpnConnectionsResponseBodyVpnConnections) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpnConnectionsResponseBodyVpnConnections) GoString() string {
	return s.String()
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnections) SetVpnConnection(v []*DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnection) *DescribeVpnConnectionsResponseBodyVpnConnections {
	s.VpnConnection = v
	return s
}

type DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnection struct {
	// The ID of the CEN instance to which the transit router belongs.
	AttachInstanceId *string `json:"AttachInstanceId,omitempty" xml:"AttachInstanceId,omitempty"`
	// The type of resource that is associated with the IPsec-VPN connection. Valid values:
	//
	// *   **CEN**: indicates that the IPsec-VPN connection is associated with a transit router of a Cloud Enterprise Network (CEN) instance.
	// *   **NO_ASSOCIATED**: indicates that the IPsec-VPN connection is not associated with a resource.
	// *   **VPNGW**: indicates that the IPsec-VPN connection is associated with a VPN gateway.
	AttachType *string `json:"AttachType,omitempty" xml:"AttachType,omitempty"`
	// The timestamp that indicates the time when the IPsec-VPN connection was established. Unit: milliseconds.
	//
	// This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// Indicates whether the IPsec-VPN connection is associated with a transit router that belongs to another Alibaba Cloud account. Valid values:
	//
	// *   **true**: yes
	// *   **false**: no
	CrossAccountAuthorized *bool `json:"CrossAccountAuthorized,omitempty" xml:"CrossAccountAuthorized,omitempty"`
	// The ID of the customer gateway.
	CustomerGatewayId *string `json:"CustomerGatewayId,omitempty" xml:"CustomerGatewayId,omitempty"`
	// Indicates whether IPsec negotiations immediately start.
	//
	// *   **true**: Negotiations are re-initiated after the configuration is changed.
	// *   **false**: Negotiations are re-initiated when traffic is detected.
	EffectImmediately *bool `json:"EffectImmediately,omitempty" xml:"EffectImmediately,omitempty"`
	// Indicates whether dead peer detection (DPD) is enabled. Valid values:
	//
	// *   **true**: enabled.
	//
	//     The initiator of the IPsec-VPN connection sends DPD packets to verify the existence and availability of the peer. If no feedback is received from the peer within a specified period of time, the connection fails. ISAKMP SA and IPsec SA are deleted. The security tunnel is also deleted.
	//
	// *   **false**: disabled. The IPsec initiator does not send DPD packets.
	EnableDpd *bool `json:"EnableDpd,omitempty" xml:"EnableDpd,omitempty"`
	// Indicates whether NAT traversal is enabled. Valid values:
	//
	// *   **true**: enabled
	//
	//     After NAT traversal is enabled, the initiator does not check the UDP ports during IKE negotiations and can automatically discover NAT gateway devices along the IPsec tunnel.
	//
	// *   **false**: disabled
	EnableNatTraversal *bool `json:"EnableNatTraversal,omitempty" xml:"EnableNatTraversal,omitempty"`
	EnableTunnelsBgp   *bool `json:"EnableTunnelsBgp,omitempty" xml:"EnableTunnelsBgp,omitempty"`
	// The configurations of phase 1 negotiations.
	IkeConfig *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionIkeConfig `json:"IkeConfig,omitempty" xml:"IkeConfig,omitempty" type:"Struct"`
	// The gateway IP address of the IPsec-VPN connection.
	//
	// >  This parameter is returned only when the IPsec-VPN connection is associated with a transit router.
	InternetIp *string `json:"InternetIp,omitempty" xml:"InternetIp,omitempty"`
	// The configuration of phase 2 negotiations.
	IpsecConfig *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionIpsecConfig `json:"IpsecConfig,omitempty" xml:"IpsecConfig,omitempty" type:"Struct"`
	// The CIDR block on the Alibaba Cloud side.
	//
	// CIDR blocks are separated by commas (,).
	LocalSubnet *string `json:"LocalSubnet,omitempty" xml:"LocalSubnet,omitempty"`
	// The name of the IPsec-VPN connection.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The network type of the IPsec-VPN connection. Valid values:
	//
	// *   **public**: an encrypted connection over the Internet.
	// *   **private**: an encrypted connection over private networks.
	NetworkType *string `json:"NetworkType,omitempty" xml:"NetworkType,omitempty"`
	// The CA certificate of the peer.
	RemoteCaCertificate *string `json:"RemoteCaCertificate,omitempty" xml:"RemoteCaCertificate,omitempty"`
	// The CIDR block on the data center side.
	//
	// CIDR blocks are separated by commas (,).
	RemoteSubnet *string `json:"RemoteSubnet,omitempty" xml:"RemoteSubnet,omitempty"`
	// The bandwidth specification of the IPsec-VPN connection. Unit: **Mbit/s**.
	Spec *string `json:"Spec,omitempty" xml:"Spec,omitempty"`
	// The status of the IPsec-VPN connection. Valid values:
	//
	// *   **active**: The IPsec-VPN connection is associated with a VPN gateway.
	// *   **init**: The IPsec-VPN connection is not associated with a resource and is being initialized.
	// *   **attaching**: The IPsec-VPN connection is being associated with a transit router.
	// *   **attached**: The IPsec-VPN connection is associated with a transit router.
	// *   **detaching**: The IPsec-VPN connection is being disassociated from a transit router.
	// *   **financialLocked**: The IPsec-VPN connection is locked due to overdue payments.
	// *   **provisioning**: The IPsec-VPN connection is being prepared.
	// *   **updating**: The IPsec-VPN connection is being updated.
	// *   **Upgrading**: The IPsec-VPN connection is being upgraded.
	// *   **deleted**: The IPsec-VPN connection is deleted.
	State *string `json:"State,omitempty" xml:"State,omitempty"`
	// The status of the IPsec-VPN connection. Valid values:
	//
	// *   **ike_sa_not_established**: Phase 1 negotiations failed.
	// *   **ike_sa_established**: Phase 1 negotiations succeeded.
	// *   **ipsec_sa_not_established**: Phase 2 negotiations failed.
	// *   **ipsec_sa_established**: Phase 2 negotiations succeeded.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The list of tags added to the IPsec-VPN connection.
	Tag *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Struct"`
	// The ID of the transit router with which the IPsec-VPN connection is associated.
	TransitRouterId *string `json:"TransitRouterId,omitempty" xml:"TransitRouterId,omitempty"`
	// The name of the transit router.
	TransitRouterName *string `json:"TransitRouterName,omitempty" xml:"TransitRouterName,omitempty"`
	// IPsec连接的隧道配置信息。
	//
	// 仅查询双隧道模式的IPsec连接会返回**TunnelOptionsSpecification**数组下的参数。
	TunnelOptionsSpecification *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecification `json:"TunnelOptionsSpecification,omitempty" xml:"TunnelOptionsSpecification,omitempty" type:"Struct"`
	// The health check configurations.
	VcoHealthCheck *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionVcoHealthCheck `json:"VcoHealthCheck,omitempty" xml:"VcoHealthCheck,omitempty" type:"Struct"`
	// The configurations of the BGP routing protocol.
	VpnBgpConfig *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionVpnBgpConfig `json:"VpnBgpConfig,omitempty" xml:"VpnBgpConfig,omitempty" type:"Struct"`
	// The ID of the IPsec-VPN connection.
	VpnConnectionId *string `json:"VpnConnectionId,omitempty" xml:"VpnConnectionId,omitempty"`
	// The ID of the VPN gateway.
	VpnGatewayId *string `json:"VpnGatewayId,omitempty" xml:"VpnGatewayId,omitempty"`
}

func (s DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnection) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnection) GoString() string {
	return s.String()
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnection) SetAttachInstanceId(v string) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnection {
	s.AttachInstanceId = &v
	return s
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnection) SetAttachType(v string) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnection {
	s.AttachType = &v
	return s
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnection) SetCreateTime(v int64) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnection {
	s.CreateTime = &v
	return s
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnection) SetCrossAccountAuthorized(v bool) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnection {
	s.CrossAccountAuthorized = &v
	return s
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnection) SetCustomerGatewayId(v string) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnection {
	s.CustomerGatewayId = &v
	return s
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnection) SetEffectImmediately(v bool) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnection {
	s.EffectImmediately = &v
	return s
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnection) SetEnableDpd(v bool) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnection {
	s.EnableDpd = &v
	return s
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnection) SetEnableNatTraversal(v bool) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnection {
	s.EnableNatTraversal = &v
	return s
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnection) SetEnableTunnelsBgp(v bool) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnection {
	s.EnableTunnelsBgp = &v
	return s
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnection) SetIkeConfig(v *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionIkeConfig) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnection {
	s.IkeConfig = v
	return s
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnection) SetInternetIp(v string) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnection {
	s.InternetIp = &v
	return s
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnection) SetIpsecConfig(v *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionIpsecConfig) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnection {
	s.IpsecConfig = v
	return s
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnection) SetLocalSubnet(v string) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnection {
	s.LocalSubnet = &v
	return s
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnection) SetName(v string) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnection {
	s.Name = &v
	return s
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnection) SetNetworkType(v string) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnection {
	s.NetworkType = &v
	return s
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnection) SetRemoteCaCertificate(v string) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnection {
	s.RemoteCaCertificate = &v
	return s
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnection) SetRemoteSubnet(v string) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnection {
	s.RemoteSubnet = &v
	return s
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnection) SetSpec(v string) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnection {
	s.Spec = &v
	return s
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnection) SetState(v string) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnection {
	s.State = &v
	return s
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnection) SetStatus(v string) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnection {
	s.Status = &v
	return s
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnection) SetTag(v *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTag) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnection {
	s.Tag = v
	return s
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnection) SetTransitRouterId(v string) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnection {
	s.TransitRouterId = &v
	return s
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnection) SetTransitRouterName(v string) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnection {
	s.TransitRouterName = &v
	return s
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnection) SetTunnelOptionsSpecification(v *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecification) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnection {
	s.TunnelOptionsSpecification = v
	return s
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnection) SetVcoHealthCheck(v *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionVcoHealthCheck) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnection {
	s.VcoHealthCheck = v
	return s
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnection) SetVpnBgpConfig(v *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionVpnBgpConfig) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnection {
	s.VpnBgpConfig = v
	return s
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnection) SetVpnConnectionId(v string) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnection {
	s.VpnConnectionId = &v
	return s
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnection) SetVpnGatewayId(v string) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnection {
	s.VpnGatewayId = &v
	return s
}

type DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionIkeConfig struct {
	// The IKE authentication algorithm.
	IkeAuthAlg *string `json:"IkeAuthAlg,omitempty" xml:"IkeAuthAlg,omitempty"`
	// The IKE encryption algorithm.
	IkeEncAlg *string `json:"IkeEncAlg,omitempty" xml:"IkeEncAlg,omitempty"`
	// The IKE lifetime. Unit: seconds.
	IkeLifetime *int64 `json:"IkeLifetime,omitempty" xml:"IkeLifetime,omitempty"`
	// The IKE negotiation mode.
	//
	// *   **main**: This mode offers higher security during negotiations.
	// *   **aggressive**: This mode is faster and has a higher success rate.
	IkeMode *string `json:"IkeMode,omitempty" xml:"IkeMode,omitempty"`
	// The DH group.
	IkePfs *string `json:"IkePfs,omitempty" xml:"IkePfs,omitempty"`
	// The version of the IKE protocol.
	//
	// *   **ikev1**
	// *   **ikev2**
	//
	// Compared with IKEv1, IKEv2 simplifies the SA negotiation process and is more suitable for scenarios in which multiple CIDR blocks are used.
	IkeVersion *string `json:"IkeVersion,omitempty" xml:"IkeVersion,omitempty"`
	// The identifier on the data center side.
	LocalId *string `json:"LocalId,omitempty" xml:"LocalId,omitempty"`
	// The pre-shared key.
	Psk *string `json:"Psk,omitempty" xml:"Psk,omitempty"`
	// The identifier on the Alibaba Cloud side.
	RemoteId *string `json:"RemoteId,omitempty" xml:"RemoteId,omitempty"`
}

func (s DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionIkeConfig) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionIkeConfig) GoString() string {
	return s.String()
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionIkeConfig) SetIkeAuthAlg(v string) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionIkeConfig {
	s.IkeAuthAlg = &v
	return s
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionIkeConfig) SetIkeEncAlg(v string) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionIkeConfig {
	s.IkeEncAlg = &v
	return s
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionIkeConfig) SetIkeLifetime(v int64) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionIkeConfig {
	s.IkeLifetime = &v
	return s
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionIkeConfig) SetIkeMode(v string) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionIkeConfig {
	s.IkeMode = &v
	return s
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionIkeConfig) SetIkePfs(v string) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionIkeConfig {
	s.IkePfs = &v
	return s
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionIkeConfig) SetIkeVersion(v string) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionIkeConfig {
	s.IkeVersion = &v
	return s
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionIkeConfig) SetLocalId(v string) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionIkeConfig {
	s.LocalId = &v
	return s
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionIkeConfig) SetPsk(v string) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionIkeConfig {
	s.Psk = &v
	return s
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionIkeConfig) SetRemoteId(v string) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionIkeConfig {
	s.RemoteId = &v
	return s
}

type DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionIpsecConfig struct {
	// The IPsec authentication algorithm.
	IpsecAuthAlg *string `json:"IpsecAuthAlg,omitempty" xml:"IpsecAuthAlg,omitempty"`
	// The IPsec encryption algorithm.
	IpsecEncAlg *string `json:"IpsecEncAlg,omitempty" xml:"IpsecEncAlg,omitempty"`
	// The IPsec lifetime. Unit: seconds.
	IpsecLifetime *int64 `json:"IpsecLifetime,omitempty" xml:"IpsecLifetime,omitempty"`
	// The DH group.
	IpsecPfs *string `json:"IpsecPfs,omitempty" xml:"IpsecPfs,omitempty"`
}

func (s DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionIpsecConfig) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionIpsecConfig) GoString() string {
	return s.String()
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionIpsecConfig) SetIpsecAuthAlg(v string) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionIpsecConfig {
	s.IpsecAuthAlg = &v
	return s
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionIpsecConfig) SetIpsecEncAlg(v string) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionIpsecConfig {
	s.IpsecEncAlg = &v
	return s
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionIpsecConfig) SetIpsecLifetime(v int64) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionIpsecConfig {
	s.IpsecLifetime = &v
	return s
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionIpsecConfig) SetIpsecPfs(v string) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionIpsecConfig {
	s.IpsecPfs = &v
	return s
}

type DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTag struct {
	Tag []*DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTagTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTag) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTag) GoString() string {
	return s.String()
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTag) SetTag(v []*DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTagTag) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTag {
	s.Tag = v
	return s
}

type DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTagTag struct {
	// The tag key.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTagTag) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTagTag) GoString() string {
	return s.String()
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTagTag) SetKey(v string) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTagTag {
	s.Key = &v
	return s
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTagTag) SetValue(v string) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTagTag {
	s.Value = &v
	return s
}

type DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecification struct {
	TunnelOptions []*DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptions `json:"TunnelOptions,omitempty" xml:"TunnelOptions,omitempty" type:"Repeated"`
}

func (s DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecification) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecification) GoString() string {
	return s.String()
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecification) SetTunnelOptions(v []*DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptions) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecification {
	s.TunnelOptions = v
	return s
}

type DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptions struct {
	// 隧道关联的用户网关ID。
	CustomerGatewayId *string `json:"CustomerGatewayId,omitempty" xml:"CustomerGatewayId,omitempty"`
	// 隧道是否已开启DPD（对等体存活检测）功能。
	// - **false**：未开启。
	// - **true**：已开启。
	EnableDpd *string `json:"EnableDpd,omitempty" xml:"EnableDpd,omitempty"`
	// 隧道是否已开启NAT穿越功能。
	//
	// - **false**：未开启。
	// - **true**：已开启。
	EnableNatTraversal *string `json:"EnableNatTraversal,omitempty" xml:"EnableNatTraversal,omitempty"`
	// 隧道的IP地址。
	InternetIp *string `json:"InternetIp,omitempty" xml:"InternetIp,omitempty"`
	// 隧道对端的CA证书。
	//
	// 仅VPN网关实例的类型为国密型时才会返回当前参数。
	RemoteCaCertificate *string `json:"RemoteCaCertificate,omitempty" xml:"RemoteCaCertificate,omitempty"`
	// 隧道的角色。
	//
	// - **master**：表示当前隧道为主隧道。
	// - **slave**：表示当前隧道为备隧道。
	Role *string `json:"Role,omitempty" xml:"Role,omitempty"`
	// IPsec连接与转发路由器实例的绑定状态。
	//
	// - **active**：IPsec连接已与VPN网关实例绑定，状态正常。
	// - **init**：IPsec连接未绑定任何资源，IPsec连接初始化。
	// - **attaching**：IPsec连接与转发路由器实例绑定中。
	// - **attached**：IPsec连接已与转发路由器实例绑定。
	// - **detaching**：IPsec连接与转发路由器实例解绑中。
	// - **financialLocked**：欠费锁定。
	// - **provisioning**：资源准备中。
	// - **updating**：更新中。
	// - **upgrading**：升级中。
	// - **deleted**：已删除。
	State *string `json:"State,omitempty" xml:"State,omitempty"`
	// IPsec连接的状态。
	//
	// - **ike_sa_not_established**：第一阶段协商失败。
	//
	// - **ike_sa_established**：第一阶段协商成功。
	//
	// - **ipsec_sa_not_established**：第二阶段协商失败。
	//
	// - **ipsec_sa_established**：第二阶段协商成功。
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// 隧道的BGP配置信息。
	TunnelBgpConfig *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptionsTunnelBgpConfig `json:"TunnelBgpConfig,omitempty" xml:"TunnelBgpConfig,omitempty" type:"Struct"`
	// 隧道ID。
	TunnelId *string `json:"TunnelId,omitempty" xml:"TunnelId,omitempty"`
	// 第一阶段协商的配置。
	TunnelIkeConfig *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig `json:"TunnelIkeConfig,omitempty" xml:"TunnelIkeConfig,omitempty" type:"Struct"`
	// 第二阶段协商的配置。
	TunnelIpsecConfig *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptionsTunnelIpsecConfig `json:"TunnelIpsecConfig,omitempty" xml:"TunnelIpsecConfig,omitempty" type:"Struct"`
	// 隧道部署的可用区。
	ZoneNo *string `json:"ZoneNo,omitempty" xml:"ZoneNo,omitempty"`
}

func (s DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptions) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptions) GoString() string {
	return s.String()
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptions) SetCustomerGatewayId(v string) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptions {
	s.CustomerGatewayId = &v
	return s
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptions) SetEnableDpd(v string) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptions {
	s.EnableDpd = &v
	return s
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptions) SetEnableNatTraversal(v string) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptions {
	s.EnableNatTraversal = &v
	return s
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptions) SetInternetIp(v string) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptions {
	s.InternetIp = &v
	return s
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptions) SetRemoteCaCertificate(v string) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptions {
	s.RemoteCaCertificate = &v
	return s
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptions) SetRole(v string) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptions {
	s.Role = &v
	return s
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptions) SetState(v string) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptions {
	s.State = &v
	return s
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptions) SetStatus(v string) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptions {
	s.Status = &v
	return s
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptions) SetTunnelBgpConfig(v *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptionsTunnelBgpConfig) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptions {
	s.TunnelBgpConfig = v
	return s
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptions) SetTunnelId(v string) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptions {
	s.TunnelId = &v
	return s
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptions) SetTunnelIkeConfig(v *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptions {
	s.TunnelIkeConfig = v
	return s
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptions) SetTunnelIpsecConfig(v *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptionsTunnelIpsecConfig) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptions {
	s.TunnelIpsecConfig = v
	return s
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptions) SetZoneNo(v string) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptions {
	s.ZoneNo = &v
	return s
}

type DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptionsTunnelBgpConfig struct {
	// BGP的协商状态。
	//
	// - **success**：正常。
	// - **false**：异常。
	BgpStatus *string `json:"BgpStatus,omitempty" xml:"BgpStatus,omitempty"`
	// 隧道本端（阿里云侧）的自治系统号。
	LocalAsn *string `json:"LocalAsn,omitempty" xml:"LocalAsn,omitempty"`
	// 隧道本端（阿里云侧）的BGP地址。
	LocalBgpIp *string `json:"LocalBgpIp,omitempty" xml:"LocalBgpIp,omitempty"`
	// 隧道对端的自治系统号。
	PeerAsn *string `json:"PeerAsn,omitempty" xml:"PeerAsn,omitempty"`
	// 隧道对端的BGP地址。
	PeerBgpIp *string `json:"PeerBgpIp,omitempty" xml:"PeerBgpIp,omitempty"`
	// 隧道的BGP网段。
	TunnelCidr *string `json:"TunnelCidr,omitempty" xml:"TunnelCidr,omitempty"`
}

func (s DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptionsTunnelBgpConfig) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptionsTunnelBgpConfig) GoString() string {
	return s.String()
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptionsTunnelBgpConfig) SetBgpStatus(v string) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptionsTunnelBgpConfig {
	s.BgpStatus = &v
	return s
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptionsTunnelBgpConfig) SetLocalAsn(v string) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptionsTunnelBgpConfig {
	s.LocalAsn = &v
	return s
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptionsTunnelBgpConfig) SetLocalBgpIp(v string) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptionsTunnelBgpConfig {
	s.LocalBgpIp = &v
	return s
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptionsTunnelBgpConfig) SetPeerAsn(v string) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptionsTunnelBgpConfig {
	s.PeerAsn = &v
	return s
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptionsTunnelBgpConfig) SetPeerBgpIp(v string) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptionsTunnelBgpConfig {
	s.PeerBgpIp = &v
	return s
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptionsTunnelBgpConfig) SetTunnelCidr(v string) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptionsTunnelBgpConfig {
	s.TunnelCidr = &v
	return s
}

type DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig struct {
	// IKE阶段认证算法。
	IkeAuthAlg *string `json:"IkeAuthAlg,omitempty" xml:"IkeAuthAlg,omitempty"`
	// IKE阶段加密算法。
	IkeEncAlg *string `json:"IkeEncAlg,omitempty" xml:"IkeEncAlg,omitempty"`
	// IKE阶段生存时间。单位：秒。
	IkeLifetime *string `json:"IkeLifetime,omitempty" xml:"IkeLifetime,omitempty"`
	// IKE协商模式。
	//
	// - **main**：主模式，协商过程安全性高。
	// - **aggressive**：野蛮模式，协商快速且协商成功率高。
	IkeMode *string `json:"IkeMode,omitempty" xml:"IkeMode,omitempty"`
	// IKE阶段DH分组。
	IkePfs *string `json:"IkePfs,omitempty" xml:"IkePfs,omitempty"`
	// IKE协议版本。
	IkeVersion *string `json:"IkeVersion,omitempty" xml:"IkeVersion,omitempty"`
	// 隧道本端（阿里云侧）的标识。
	LocalId *string `json:"LocalId,omitempty" xml:"LocalId,omitempty"`
	// 预共享密钥。
	Psk *string `json:"Psk,omitempty" xml:"Psk,omitempty"`
	// 隧道对端的标识。
	RemoteId *string `json:"RemoteId,omitempty" xml:"RemoteId,omitempty"`
}

func (s DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig) GoString() string {
	return s.String()
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig) SetIkeAuthAlg(v string) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig {
	s.IkeAuthAlg = &v
	return s
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig) SetIkeEncAlg(v string) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig {
	s.IkeEncAlg = &v
	return s
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig) SetIkeLifetime(v string) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig {
	s.IkeLifetime = &v
	return s
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig) SetIkeMode(v string) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig {
	s.IkeMode = &v
	return s
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig) SetIkePfs(v string) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig {
	s.IkePfs = &v
	return s
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig) SetIkeVersion(v string) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig {
	s.IkeVersion = &v
	return s
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig) SetLocalId(v string) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig {
	s.LocalId = &v
	return s
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig) SetPsk(v string) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig {
	s.Psk = &v
	return s
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig) SetRemoteId(v string) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig {
	s.RemoteId = &v
	return s
}

type DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptionsTunnelIpsecConfig struct {
	// IPsec阶段认证算法。
	IpsecAuthAlg *string `json:"IpsecAuthAlg,omitempty" xml:"IpsecAuthAlg,omitempty"`
	// IPsec阶段加密算法。
	IpsecEncAlg *string `json:"IpsecEncAlg,omitempty" xml:"IpsecEncAlg,omitempty"`
	// IPsec阶段生存时间。单位：秒。
	IpsecLifetime *string `json:"IpsecLifetime,omitempty" xml:"IpsecLifetime,omitempty"`
	// IPsec阶段DH分组。
	IpsecPfs *string `json:"IpsecPfs,omitempty" xml:"IpsecPfs,omitempty"`
}

func (s DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptionsTunnelIpsecConfig) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptionsTunnelIpsecConfig) GoString() string {
	return s.String()
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptionsTunnelIpsecConfig) SetIpsecAuthAlg(v string) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptionsTunnelIpsecConfig {
	s.IpsecAuthAlg = &v
	return s
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptionsTunnelIpsecConfig) SetIpsecEncAlg(v string) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptionsTunnelIpsecConfig {
	s.IpsecEncAlg = &v
	return s
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptionsTunnelIpsecConfig) SetIpsecLifetime(v string) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptionsTunnelIpsecConfig {
	s.IpsecLifetime = &v
	return s
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptionsTunnelIpsecConfig) SetIpsecPfs(v string) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptionsTunnelIpsecConfig {
	s.IpsecPfs = &v
	return s
}

type DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionVcoHealthCheck struct {
	// The destination IP address.
	Dip *string `json:"Dip,omitempty" xml:"Dip,omitempty"`
	// Indicates whether health checks are enabled.
	//
	// *   **true**: yes
	// *   **false**: no
	Enable *string `json:"Enable,omitempty" xml:"Enable,omitempty"`
	// The interval between two consecutive health checks. Unit: seconds.
	Interval *int32 `json:"Interval,omitempty" xml:"Interval,omitempty"`
	// Indicates whether advertised routes are withdrawn when the health check fails.
	//
	// *   **revoke_route**: yes
	// *   **reserve_route**: no
	Policy *string `json:"Policy,omitempty" xml:"Policy,omitempty"`
	// The maximum number of health check retries.
	Retry *int32 `json:"Retry,omitempty" xml:"Retry,omitempty"`
	// The source IP address.
	Sip *string `json:"Sip,omitempty" xml:"Sip,omitempty"`
	// The status of the health check.
	//
	// *   **success**: normal
	// *   **failed**: abnormal
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionVcoHealthCheck) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionVcoHealthCheck) GoString() string {
	return s.String()
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionVcoHealthCheck) SetDip(v string) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionVcoHealthCheck {
	s.Dip = &v
	return s
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionVcoHealthCheck) SetEnable(v string) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionVcoHealthCheck {
	s.Enable = &v
	return s
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionVcoHealthCheck) SetInterval(v int32) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionVcoHealthCheck {
	s.Interval = &v
	return s
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionVcoHealthCheck) SetPolicy(v string) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionVcoHealthCheck {
	s.Policy = &v
	return s
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionVcoHealthCheck) SetRetry(v int32) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionVcoHealthCheck {
	s.Retry = &v
	return s
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionVcoHealthCheck) SetSip(v string) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionVcoHealthCheck {
	s.Sip = &v
	return s
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionVcoHealthCheck) SetStatus(v string) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionVcoHealthCheck {
	s.Status = &v
	return s
}

type DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionVpnBgpConfig struct {
	// The authentication key of the BGP routing protocol.
	AuthKey *string `json:"AuthKey,omitempty" xml:"AuthKey,omitempty"`
	// The ASN on the Alibaba Cloud side.
	LocalAsn *int64 `json:"LocalAsn,omitempty" xml:"LocalAsn,omitempty"`
	// The BGP IP address on the Alibaba Cloud side.
	LocalBgpIp *string `json:"LocalBgpIp,omitempty" xml:"LocalBgpIp,omitempty"`
	// The autonomous system number (ASN) of the peer.
	PeerAsn *int64 `json:"PeerAsn,omitempty" xml:"PeerAsn,omitempty"`
	// The BGP IP address of the peer.
	PeerBgpIp *string `json:"PeerBgpIp,omitempty" xml:"PeerBgpIp,omitempty"`
	// The negotiation status of the BGP routing protocol. Valid values:
	//
	// *   **success**: normal
	// *   **false**: abnormal
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The CIDR block of the IPsec tunnel. The CIDR block falls within 169.254.0.0/16. The mask of the CIDR block is 30 bits in length.
	TunnelCidr *string `json:"TunnelCidr,omitempty" xml:"TunnelCidr,omitempty"`
}

func (s DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionVpnBgpConfig) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionVpnBgpConfig) GoString() string {
	return s.String()
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionVpnBgpConfig) SetAuthKey(v string) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionVpnBgpConfig {
	s.AuthKey = &v
	return s
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionVpnBgpConfig) SetLocalAsn(v int64) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionVpnBgpConfig {
	s.LocalAsn = &v
	return s
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionVpnBgpConfig) SetLocalBgpIp(v string) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionVpnBgpConfig {
	s.LocalBgpIp = &v
	return s
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionVpnBgpConfig) SetPeerAsn(v int64) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionVpnBgpConfig {
	s.PeerAsn = &v
	return s
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionVpnBgpConfig) SetPeerBgpIp(v string) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionVpnBgpConfig {
	s.PeerBgpIp = &v
	return s
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionVpnBgpConfig) SetStatus(v string) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionVpnBgpConfig {
	s.Status = &v
	return s
}

func (s *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionVpnBgpConfig) SetTunnelCidr(v string) *DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionVpnBgpConfig {
	s.TunnelCidr = &v
	return s
}

type DescribeVpnConnectionsResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeVpnConnectionsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeVpnConnectionsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpnConnectionsResponse) GoString() string {
	return s.String()
}

func (s *DescribeVpnConnectionsResponse) SetHeaders(v map[string]*string) *DescribeVpnConnectionsResponse {
	s.Headers = v
	return s
}

func (s *DescribeVpnConnectionsResponse) SetStatusCode(v int32) *DescribeVpnConnectionsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeVpnConnectionsResponse) SetBody(v *DescribeVpnConnectionsResponseBody) *DescribeVpnConnectionsResponse {
	s.Body = v
	return s
}

type DescribeVpnCrossAccountAuthorizationsRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. ClientToken can contain only ASCII characters.
	//
	// >  If you do not set this parameter, the system automatically uses **RequestId** as **ClientToken**. **RequestId** of each API request may be different.
	ClientToken  *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	// The number of the page to return. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Default value: **10**. Valid values: **1** to **50**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the region to which the IPsec-VPN connection belongs.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the IPsec-VPN connection.
	VpnConnectionId *string `json:"VpnConnectionId,omitempty" xml:"VpnConnectionId,omitempty"`
}

func (s DescribeVpnCrossAccountAuthorizationsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpnCrossAccountAuthorizationsRequest) GoString() string {
	return s.String()
}

func (s *DescribeVpnCrossAccountAuthorizationsRequest) SetClientToken(v string) *DescribeVpnCrossAccountAuthorizationsRequest {
	s.ClientToken = &v
	return s
}

func (s *DescribeVpnCrossAccountAuthorizationsRequest) SetOwnerAccount(v string) *DescribeVpnCrossAccountAuthorizationsRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeVpnCrossAccountAuthorizationsRequest) SetPageNumber(v int32) *DescribeVpnCrossAccountAuthorizationsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeVpnCrossAccountAuthorizationsRequest) SetPageSize(v int32) *DescribeVpnCrossAccountAuthorizationsRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeVpnCrossAccountAuthorizationsRequest) SetRegionId(v string) *DescribeVpnCrossAccountAuthorizationsRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeVpnCrossAccountAuthorizationsRequest) SetResourceOwnerAccount(v string) *DescribeVpnCrossAccountAuthorizationsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeVpnCrossAccountAuthorizationsRequest) SetResourceOwnerId(v int64) *DescribeVpnCrossAccountAuthorizationsRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeVpnCrossAccountAuthorizationsRequest) SetVpnConnectionId(v string) *DescribeVpnCrossAccountAuthorizationsRequest {
	s.VpnConnectionId = &v
	return s
}

type DescribeVpnCrossAccountAuthorizationsResponseBody struct {
	// The cross-account authorization information about the IPsec-VPN connection.
	CrossAccountAuthorizations []*DescribeVpnCrossAccountAuthorizationsResponseBodyCrossAccountAuthorizations `json:"CrossAccountAuthorizations,omitempty" xml:"CrossAccountAuthorizations,omitempty" type:"Repeated"`
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeVpnCrossAccountAuthorizationsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpnCrossAccountAuthorizationsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeVpnCrossAccountAuthorizationsResponseBody) SetCrossAccountAuthorizations(v []*DescribeVpnCrossAccountAuthorizationsResponseBodyCrossAccountAuthorizations) *DescribeVpnCrossAccountAuthorizationsResponseBody {
	s.CrossAccountAuthorizations = v
	return s
}

func (s *DescribeVpnCrossAccountAuthorizationsResponseBody) SetPageNumber(v int32) *DescribeVpnCrossAccountAuthorizationsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeVpnCrossAccountAuthorizationsResponseBody) SetPageSize(v int32) *DescribeVpnCrossAccountAuthorizationsResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeVpnCrossAccountAuthorizationsResponseBody) SetRequestId(v string) *DescribeVpnCrossAccountAuthorizationsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeVpnCrossAccountAuthorizationsResponseBody) SetTotalCount(v int32) *DescribeVpnCrossAccountAuthorizationsResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeVpnCrossAccountAuthorizationsResponseBodyCrossAccountAuthorizations struct {
	// The ID of the Alibaba Cloud account to which the IPsec-VPN connection belongs.
	AliUid *int64 `json:"AliUid,omitempty" xml:"AliUid,omitempty"`
	// The ID of the CEN instance.
	BindInstance *string `json:"BindInstance,omitempty" xml:"BindInstance,omitempty"`
	// The resource type of the authorization.
	//
	// The value is set to **CEN**, which indicates that the IPsec-VPN connection can be associated with a transit router of a Cloud Enterprise Network (CEN) instance that belongs to another Alibaba Cloud account.
	BindProduct *string `json:"BindProduct,omitempty" xml:"BindProduct,omitempty"`
	// The ID of the Alibaba Cloud account whose resource the IPsec-VPN connection can be associated with.
	BindUid *int64 `json:"BindUid,omitempty" xml:"BindUid,omitempty"`
	// The timestamp when the authorization for the IPsec-VPN connection was created.
	//
	// This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
	CreationTime *int64 `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The ID of the IPsec-VPN connection.
	VpnConnectionId *string `json:"VpnConnectionId,omitempty" xml:"VpnConnectionId,omitempty"`
}

func (s DescribeVpnCrossAccountAuthorizationsResponseBodyCrossAccountAuthorizations) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpnCrossAccountAuthorizationsResponseBodyCrossAccountAuthorizations) GoString() string {
	return s.String()
}

func (s *DescribeVpnCrossAccountAuthorizationsResponseBodyCrossAccountAuthorizations) SetAliUid(v int64) *DescribeVpnCrossAccountAuthorizationsResponseBodyCrossAccountAuthorizations {
	s.AliUid = &v
	return s
}

func (s *DescribeVpnCrossAccountAuthorizationsResponseBodyCrossAccountAuthorizations) SetBindInstance(v string) *DescribeVpnCrossAccountAuthorizationsResponseBodyCrossAccountAuthorizations {
	s.BindInstance = &v
	return s
}

func (s *DescribeVpnCrossAccountAuthorizationsResponseBodyCrossAccountAuthorizations) SetBindProduct(v string) *DescribeVpnCrossAccountAuthorizationsResponseBodyCrossAccountAuthorizations {
	s.BindProduct = &v
	return s
}

func (s *DescribeVpnCrossAccountAuthorizationsResponseBodyCrossAccountAuthorizations) SetBindUid(v int64) *DescribeVpnCrossAccountAuthorizationsResponseBodyCrossAccountAuthorizations {
	s.BindUid = &v
	return s
}

func (s *DescribeVpnCrossAccountAuthorizationsResponseBodyCrossAccountAuthorizations) SetCreationTime(v int64) *DescribeVpnCrossAccountAuthorizationsResponseBodyCrossAccountAuthorizations {
	s.CreationTime = &v
	return s
}

func (s *DescribeVpnCrossAccountAuthorizationsResponseBodyCrossAccountAuthorizations) SetVpnConnectionId(v string) *DescribeVpnCrossAccountAuthorizationsResponseBodyCrossAccountAuthorizations {
	s.VpnConnectionId = &v
	return s
}

type DescribeVpnCrossAccountAuthorizationsResponse struct {
	Headers    map[string]*string                                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeVpnCrossAccountAuthorizationsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeVpnCrossAccountAuthorizationsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpnCrossAccountAuthorizationsResponse) GoString() string {
	return s.String()
}

func (s *DescribeVpnCrossAccountAuthorizationsResponse) SetHeaders(v map[string]*string) *DescribeVpnCrossAccountAuthorizationsResponse {
	s.Headers = v
	return s
}

func (s *DescribeVpnCrossAccountAuthorizationsResponse) SetStatusCode(v int32) *DescribeVpnCrossAccountAuthorizationsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeVpnCrossAccountAuthorizationsResponse) SetBody(v *DescribeVpnCrossAccountAuthorizationsResponseBody) *DescribeVpnCrossAccountAuthorizationsResponse {
	s.Body = v
	return s
}

type DescribeVpnGatewayRequest struct {
	// Specifies whether to return information about pending orders. Valid values:
	//
	// *   **false** (default)
	// *   **true**
	IncludeReservationData *bool   `json:"IncludeReservationData,omitempty" xml:"IncludeReservationData,omitempty"`
	OwnerAccount           *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId                *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the VPN gateway.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the VPN gateway.
	VpnGatewayId *string `json:"VpnGatewayId,omitempty" xml:"VpnGatewayId,omitempty"`
}

func (s DescribeVpnGatewayRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpnGatewayRequest) GoString() string {
	return s.String()
}

func (s *DescribeVpnGatewayRequest) SetIncludeReservationData(v bool) *DescribeVpnGatewayRequest {
	s.IncludeReservationData = &v
	return s
}

func (s *DescribeVpnGatewayRequest) SetOwnerAccount(v string) *DescribeVpnGatewayRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeVpnGatewayRequest) SetOwnerId(v int64) *DescribeVpnGatewayRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeVpnGatewayRequest) SetRegionId(v string) *DescribeVpnGatewayRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeVpnGatewayRequest) SetResourceOwnerAccount(v string) *DescribeVpnGatewayRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeVpnGatewayRequest) SetResourceOwnerId(v int64) *DescribeVpnGatewayRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeVpnGatewayRequest) SetVpnGatewayId(v string) *DescribeVpnGatewayRequest {
	s.VpnGatewayId = &v
	return s
}

type DescribeVpnGatewayResponseBody struct {
	// Indicates whether BGP routes are automatically advertised to the VPC. Valid values:
	//
	// *   **true**
	// *   **false**
	AutoPropagate *bool `json:"AutoPropagate,omitempty" xml:"AutoPropagate,omitempty"`
	// The payment status of the VPN gateway. Valid values:
	//
	// *   **Normal**
	// *   **FinancialLocked**
	BusinessStatus *string `json:"BusinessStatus,omitempty" xml:"BusinessStatus,omitempty"`
	// The billing method. Valid value:
	//
	// **POSTPAY**: pay-as-you-go
	ChargeType *string `json:"ChargeType,omitempty" xml:"ChargeType,omitempty"`
	// The timestamp when the VPN gateway was created. Unit: milliseconds.
	//
	// This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The description of the VPN gateway.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// 系统为VPN网关实例分配的用于创建IPsec-VPN连接的第二个IP地址。
	//
	// 仅支持创建双隧道模式IPsec-VPN连接的VPN网关实例会返回当前参数。
	DisasterRecoveryInternetIp *string `json:"DisasterRecoveryInternetIp,omitempty" xml:"DisasterRecoveryInternetIp,omitempty"`
	// VPN网关实例关联的第二个交换机ID。
	//
	// 仅支持创建双隧道模式IPsec-VPN连接的VPN网关实例会返回当前参数。
	DisasterRecoveryVSwitchId *string `json:"DisasterRecoveryVSwitchId,omitempty" xml:"DisasterRecoveryVSwitchId,omitempty"`
	// Indicates whether BGP is enabled for the VPN gateway. Valid values:
	//
	// *   **true**
	// *   **false**
	EnableBgp *bool `json:"EnableBgp,omitempty" xml:"EnableBgp,omitempty"`
	// The timestamp when the VPN gateway expires. Unit: milliseconds.
	//
	// This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
	EndTime *int64 `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The public IP address of the VPN gateway.
	InternetIp *string `json:"InternetIp,omitempty" xml:"InternetIp,omitempty"`
	// Indicates whether the IPsec-VPN feature is enabled. Valid values:
	//
	// *   **enable**
	// *   **disable**
	IpsecVpn *string `json:"IpsecVpn,omitempty" xml:"IpsecVpn,omitempty"`
	// The name of the VPN gateway.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The network type of the VPN gateway.
	//
	// *   **public**
	// *   **private**
	NetworkType *string `json:"NetworkType,omitempty" xml:"NetworkType,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The information about pending orders.
	//
	// > This set of parameters is returned only when **IncludeReservationData** is set to **true**.
	ReservationData *DescribeVpnGatewayResponseBodyReservationData `json:"ReservationData,omitempty" xml:"ReservationData,omitempty" type:"Struct"`
	// The maximum bandwidth of the VPN gateway. Unit: Mbit/s.
	Spec *string `json:"Spec,omitempty" xml:"Spec,omitempty"`
	// The maximum number of concurrent SSL-VPN connections.
	SslMaxConnections *int64 `json:"SslMaxConnections,omitempty" xml:"SslMaxConnections,omitempty"`
	// The status of the SSL-VPN feature. Valid values:
	//
	// *   **enable**
	// *   **disable**
	SslVpn *string `json:"SslVpn,omitempty" xml:"SslVpn,omitempty"`
	// SSL-VPN连接的IP地址。
	//
	// 仅支持创建双隧道模式IPsec-VPN连接的公网网络类型的VPN网关实例开启SSL-VPN功能后，才会返回当前参数。
	SslVpnInternetIp *string `json:"SslVpnInternetIp,omitempty" xml:"SslVpnInternetIp,omitempty"`
	// The status of the VPN gateway. Valid values:
	//
	// *   **init**
	// *   **provisioning**
	// *   **active**
	// *   **updating**
	// *   **deleting**
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The automatically generated tag of the VPN gateway.
	//
	// *   **VpnEnableBgp**: indicates whether the VPN gateway supports BGP. Valid values:
	//
	//     *   **true**
	//     *   **false**
	//
	// *   **VisuallySsl**: indicates whether the VPN gateway allows you to view information about connected SSL clients.
	//
	//     *   **true**
	//     *   **false**
	//
	// *   **PbrPriority**: indicates whether the VPN gateway allows you to configure priorities for policy-based routes.
	//
	//     *   **true**
	//     *   **false**
	//
	// *   **VpnNewImage**: indicates whether the VPN gateway is upgraded.
	//
	//     *   **true**
	//     *   **false**
	//
	// *   **description**
	//
	// *   **VpnVersion**
	Tag *string `json:"Tag,omitempty" xml:"Tag,omitempty"`
	// The tag value.
	Tags *DescribeVpnGatewayResponseBodyTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Struct"`
	// The ID of the vSwitch to which the VPN gateway belongs.
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
	// The ID of the VPC to which the VPN gateway belongs.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
	// The ID of the VPN gateway.
	VpnGatewayId *string `json:"VpnGatewayId,omitempty" xml:"VpnGatewayId,omitempty"`
	// The type of the VPN gateway.
	//
	// Only **Normal** may be returned, which indicates a standard NAT gateway.
	VpnType *string `json:"VpnType,omitempty" xml:"VpnType,omitempty"`
}

func (s DescribeVpnGatewayResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpnGatewayResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeVpnGatewayResponseBody) SetAutoPropagate(v bool) *DescribeVpnGatewayResponseBody {
	s.AutoPropagate = &v
	return s
}

func (s *DescribeVpnGatewayResponseBody) SetBusinessStatus(v string) *DescribeVpnGatewayResponseBody {
	s.BusinessStatus = &v
	return s
}

func (s *DescribeVpnGatewayResponseBody) SetChargeType(v string) *DescribeVpnGatewayResponseBody {
	s.ChargeType = &v
	return s
}

func (s *DescribeVpnGatewayResponseBody) SetCreateTime(v int64) *DescribeVpnGatewayResponseBody {
	s.CreateTime = &v
	return s
}

func (s *DescribeVpnGatewayResponseBody) SetDescription(v string) *DescribeVpnGatewayResponseBody {
	s.Description = &v
	return s
}

func (s *DescribeVpnGatewayResponseBody) SetDisasterRecoveryInternetIp(v string) *DescribeVpnGatewayResponseBody {
	s.DisasterRecoveryInternetIp = &v
	return s
}

func (s *DescribeVpnGatewayResponseBody) SetDisasterRecoveryVSwitchId(v string) *DescribeVpnGatewayResponseBody {
	s.DisasterRecoveryVSwitchId = &v
	return s
}

func (s *DescribeVpnGatewayResponseBody) SetEnableBgp(v bool) *DescribeVpnGatewayResponseBody {
	s.EnableBgp = &v
	return s
}

func (s *DescribeVpnGatewayResponseBody) SetEndTime(v int64) *DescribeVpnGatewayResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeVpnGatewayResponseBody) SetInternetIp(v string) *DescribeVpnGatewayResponseBody {
	s.InternetIp = &v
	return s
}

func (s *DescribeVpnGatewayResponseBody) SetIpsecVpn(v string) *DescribeVpnGatewayResponseBody {
	s.IpsecVpn = &v
	return s
}

func (s *DescribeVpnGatewayResponseBody) SetName(v string) *DescribeVpnGatewayResponseBody {
	s.Name = &v
	return s
}

func (s *DescribeVpnGatewayResponseBody) SetNetworkType(v string) *DescribeVpnGatewayResponseBody {
	s.NetworkType = &v
	return s
}

func (s *DescribeVpnGatewayResponseBody) SetRequestId(v string) *DescribeVpnGatewayResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeVpnGatewayResponseBody) SetReservationData(v *DescribeVpnGatewayResponseBodyReservationData) *DescribeVpnGatewayResponseBody {
	s.ReservationData = v
	return s
}

func (s *DescribeVpnGatewayResponseBody) SetSpec(v string) *DescribeVpnGatewayResponseBody {
	s.Spec = &v
	return s
}

func (s *DescribeVpnGatewayResponseBody) SetSslMaxConnections(v int64) *DescribeVpnGatewayResponseBody {
	s.SslMaxConnections = &v
	return s
}

func (s *DescribeVpnGatewayResponseBody) SetSslVpn(v string) *DescribeVpnGatewayResponseBody {
	s.SslVpn = &v
	return s
}

func (s *DescribeVpnGatewayResponseBody) SetSslVpnInternetIp(v string) *DescribeVpnGatewayResponseBody {
	s.SslVpnInternetIp = &v
	return s
}

func (s *DescribeVpnGatewayResponseBody) SetStatus(v string) *DescribeVpnGatewayResponseBody {
	s.Status = &v
	return s
}

func (s *DescribeVpnGatewayResponseBody) SetTag(v string) *DescribeVpnGatewayResponseBody {
	s.Tag = &v
	return s
}

func (s *DescribeVpnGatewayResponseBody) SetTags(v *DescribeVpnGatewayResponseBodyTags) *DescribeVpnGatewayResponseBody {
	s.Tags = v
	return s
}

func (s *DescribeVpnGatewayResponseBody) SetVSwitchId(v string) *DescribeVpnGatewayResponseBody {
	s.VSwitchId = &v
	return s
}

func (s *DescribeVpnGatewayResponseBody) SetVpcId(v string) *DescribeVpnGatewayResponseBody {
	s.VpcId = &v
	return s
}

func (s *DescribeVpnGatewayResponseBody) SetVpnGatewayId(v string) *DescribeVpnGatewayResponseBody {
	s.VpnGatewayId = &v
	return s
}

func (s *DescribeVpnGatewayResponseBody) SetVpnType(v string) *DescribeVpnGatewayResponseBody {
	s.VpnType = &v
	return s
}

type DescribeVpnGatewayResponseBodyReservationData struct {
	// If the order type is **TEMP_UPGRADE** (temporary upgrade), this parameter specifies the time when the temporary upgrade expires.
	//
	// If the order type is **RENEWCHANGE** (renewal with a specification change) or **RENEW** (renewal), this parameter indicates the time when the renewal or renewal with a specification change takes effect.
	ReservationEndTime *string `json:"ReservationEndTime,omitempty" xml:"ReservationEndTime,omitempty"`
	// The IPsec-VPN status of the pending order. Valid values:
	//
	// *   **enable**
	// *   **disable**
	ReservationIpsec *string `json:"ReservationIpsec,omitempty" xml:"ReservationIpsec,omitempty"`
	// The maximum number of concurrent SSL-VPN connections of the pending order.
	ReservationMaxConnections *int32 `json:"ReservationMaxConnections,omitempty" xml:"ReservationMaxConnections,omitempty"`
	// The type of the pending order. Valid values:
	//
	// *   **RENEWCHANGE**: renewal with upgrade or downgrade
	// *   **TEMP_UPGRADE**: temporary upgrade
	// *   **RENEW**: renewal
	ReservationOrderType *string `json:"ReservationOrderType,omitempty" xml:"ReservationOrderType,omitempty"`
	// The bandwidth of the pending order. Unit: Mbit/s.
	ReservationSpec *string `json:"ReservationSpec,omitempty" xml:"ReservationSpec,omitempty"`
	// The SSL-VPN status of the pending order. Valid values:
	//
	// *   **enable**
	// *   **disable**
	ReservationSsl *string `json:"ReservationSsl,omitempty" xml:"ReservationSsl,omitempty"`
	// The status of the pending order. Valid values:
	//
	// *   **1**: indicates that the order of the renewal or specification change has not taken effect.
	// *   **2**: indicates that the order is an order for temporary upgrade and the order has taken effect. After the temporary upgrade expires, the system restores the VPN gateway to its previous specifications. In this case, **ReservationIpsec**, **ReservationMaxConnections**, **ReservationSpec**, and **ReservationSsl** indicate the previous specification.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeVpnGatewayResponseBodyReservationData) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpnGatewayResponseBodyReservationData) GoString() string {
	return s.String()
}

func (s *DescribeVpnGatewayResponseBodyReservationData) SetReservationEndTime(v string) *DescribeVpnGatewayResponseBodyReservationData {
	s.ReservationEndTime = &v
	return s
}

func (s *DescribeVpnGatewayResponseBodyReservationData) SetReservationIpsec(v string) *DescribeVpnGatewayResponseBodyReservationData {
	s.ReservationIpsec = &v
	return s
}

func (s *DescribeVpnGatewayResponseBodyReservationData) SetReservationMaxConnections(v int32) *DescribeVpnGatewayResponseBodyReservationData {
	s.ReservationMaxConnections = &v
	return s
}

func (s *DescribeVpnGatewayResponseBodyReservationData) SetReservationOrderType(v string) *DescribeVpnGatewayResponseBodyReservationData {
	s.ReservationOrderType = &v
	return s
}

func (s *DescribeVpnGatewayResponseBodyReservationData) SetReservationSpec(v string) *DescribeVpnGatewayResponseBodyReservationData {
	s.ReservationSpec = &v
	return s
}

func (s *DescribeVpnGatewayResponseBodyReservationData) SetReservationSsl(v string) *DescribeVpnGatewayResponseBodyReservationData {
	s.ReservationSsl = &v
	return s
}

func (s *DescribeVpnGatewayResponseBodyReservationData) SetStatus(v string) *DescribeVpnGatewayResponseBodyReservationData {
	s.Status = &v
	return s
}

type DescribeVpnGatewayResponseBodyTags struct {
	Tag []*DescribeVpnGatewayResponseBodyTagsTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s DescribeVpnGatewayResponseBodyTags) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpnGatewayResponseBodyTags) GoString() string {
	return s.String()
}

func (s *DescribeVpnGatewayResponseBodyTags) SetTag(v []*DescribeVpnGatewayResponseBodyTagsTag) *DescribeVpnGatewayResponseBodyTags {
	s.Tag = v
	return s
}

type DescribeVpnGatewayResponseBodyTagsTag struct {
	// The tag key
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeVpnGatewayResponseBodyTagsTag) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpnGatewayResponseBodyTagsTag) GoString() string {
	return s.String()
}

func (s *DescribeVpnGatewayResponseBodyTagsTag) SetKey(v string) *DescribeVpnGatewayResponseBodyTagsTag {
	s.Key = &v
	return s
}

func (s *DescribeVpnGatewayResponseBodyTagsTag) SetValue(v string) *DescribeVpnGatewayResponseBodyTagsTag {
	s.Value = &v
	return s
}

type DescribeVpnGatewayResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeVpnGatewayResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeVpnGatewayResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpnGatewayResponse) GoString() string {
	return s.String()
}

func (s *DescribeVpnGatewayResponse) SetHeaders(v map[string]*string) *DescribeVpnGatewayResponse {
	s.Headers = v
	return s
}

func (s *DescribeVpnGatewayResponse) SetStatusCode(v int32) *DescribeVpnGatewayResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeVpnGatewayResponse) SetBody(v *DescribeVpnGatewayResponseBody) *DescribeVpnGatewayResponse {
	s.Body = v
	return s
}

type DescribeVpnGatewaysRequest struct {
	// The payment status of the VPN gateway. Valid values:
	//
	// *   **Normal**
	// *   **FinancialLocked**
	BusinessStatus *string `json:"BusinessStatus,omitempty" xml:"BusinessStatus,omitempty"`
	// Specifies whether to return information about pending orders. Valid values:
	//
	// *   **false** (default)
	// *   **true**
	IncludeReservationData *bool   `json:"IncludeReservationData,omitempty" xml:"IncludeReservationData,omitempty"`
	OwnerAccount           *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId                *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of the page to return. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Valid values: **1** to **50**. Default value: **10**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The region ID of the VPN gateway.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The status of the VPN gateway. Valid values:
	//
	// *   **init**
	// *   **provisioning**
	// *   **active**
	// *   **updating**
	// *   **deleting**
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The value of tag N to add to the resource.
	//
	// The value of this parameter can be an empty string and cannot exceed 128 characters in length. It cannot start with `aliyun` or `acs:`, and cannot contain `http://` or `https://`.
	//
	// Each tag key corresponds to one tag value. You can specify at most 20 tag values in each call.
	Tag []*DescribeVpnGatewaysRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
	// The ID of the virtual private cloud (VPC) to which the VPN gateway belongs.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
	// The ID of the VPN gateway.
	VpnGatewayId *string `json:"VpnGatewayId,omitempty" xml:"VpnGatewayId,omitempty"`
}

func (s DescribeVpnGatewaysRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpnGatewaysRequest) GoString() string {
	return s.String()
}

func (s *DescribeVpnGatewaysRequest) SetBusinessStatus(v string) *DescribeVpnGatewaysRequest {
	s.BusinessStatus = &v
	return s
}

func (s *DescribeVpnGatewaysRequest) SetIncludeReservationData(v bool) *DescribeVpnGatewaysRequest {
	s.IncludeReservationData = &v
	return s
}

func (s *DescribeVpnGatewaysRequest) SetOwnerAccount(v string) *DescribeVpnGatewaysRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeVpnGatewaysRequest) SetOwnerId(v int64) *DescribeVpnGatewaysRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeVpnGatewaysRequest) SetPageNumber(v int32) *DescribeVpnGatewaysRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeVpnGatewaysRequest) SetPageSize(v int32) *DescribeVpnGatewaysRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeVpnGatewaysRequest) SetRegionId(v string) *DescribeVpnGatewaysRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeVpnGatewaysRequest) SetResourceOwnerAccount(v string) *DescribeVpnGatewaysRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeVpnGatewaysRequest) SetResourceOwnerId(v int64) *DescribeVpnGatewaysRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeVpnGatewaysRequest) SetStatus(v string) *DescribeVpnGatewaysRequest {
	s.Status = &v
	return s
}

func (s *DescribeVpnGatewaysRequest) SetTag(v []*DescribeVpnGatewaysRequestTag) *DescribeVpnGatewaysRequest {
	s.Tag = v
	return s
}

func (s *DescribeVpnGatewaysRequest) SetVpcId(v string) *DescribeVpnGatewaysRequest {
	s.VpcId = &v
	return s
}

func (s *DescribeVpnGatewaysRequest) SetVpnGatewayId(v string) *DescribeVpnGatewaysRequest {
	s.VpnGatewayId = &v
	return s
}

type DescribeVpnGatewaysRequestTag struct {
	// The tag key. The tag key cannot be an empty string.
	//
	// It can be at most 64 characters in length, and cannot contain `http://` or `https://`. It cannot start with `aliyun` or `acs:`.
	//
	// You can specify at most 20 tag keys in each call.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value.
	//
	// The tag value can be an empty string and cannot exceed 128 characters in length. It cannot start with `aliyun` or `acs:`, and cannot contain `http://` or `https://`.
	//
	// Each tag key corresponds to one tag value. You can specify at most 20 tag values in each call.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeVpnGatewaysRequestTag) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpnGatewaysRequestTag) GoString() string {
	return s.String()
}

func (s *DescribeVpnGatewaysRequestTag) SetKey(v string) *DescribeVpnGatewaysRequestTag {
	s.Key = &v
	return s
}

func (s *DescribeVpnGatewaysRequestTag) SetValue(v string) *DescribeVpnGatewaysRequestTag {
	s.Value = &v
	return s
}

type DescribeVpnGatewaysResponseBody struct {
	// The number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
	// If the order type is **TEMP_UPGRADE** (temporary upgrade), this parameter specifies the time when the temporary upgrade expires.
	//
	// If the order type is **RENEWCHANGE** (renewal with a specification change) or **RENEW** (renewal), this parameter indicates the time when the renewal or renewal with a specification change takes effect.
	VpnGateways *DescribeVpnGatewaysResponseBodyVpnGateways `json:"VpnGateways,omitempty" xml:"VpnGateways,omitempty" type:"Struct"`
}

func (s DescribeVpnGatewaysResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpnGatewaysResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeVpnGatewaysResponseBody) SetPageNumber(v int32) *DescribeVpnGatewaysResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeVpnGatewaysResponseBody) SetPageSize(v int32) *DescribeVpnGatewaysResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeVpnGatewaysResponseBody) SetRequestId(v string) *DescribeVpnGatewaysResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeVpnGatewaysResponseBody) SetTotalCount(v int32) *DescribeVpnGatewaysResponseBody {
	s.TotalCount = &v
	return s
}

func (s *DescribeVpnGatewaysResponseBody) SetVpnGateways(v *DescribeVpnGatewaysResponseBodyVpnGateways) *DescribeVpnGatewaysResponseBody {
	s.VpnGateways = v
	return s
}

type DescribeVpnGatewaysResponseBodyVpnGateways struct {
	VpnGateway []*DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGateway `json:"VpnGateway,omitempty" xml:"VpnGateway,omitempty" type:"Repeated"`
}

func (s DescribeVpnGatewaysResponseBodyVpnGateways) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpnGatewaysResponseBodyVpnGateways) GoString() string {
	return s.String()
}

func (s *DescribeVpnGatewaysResponseBodyVpnGateways) SetVpnGateway(v []*DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGateway) *DescribeVpnGatewaysResponseBodyVpnGateways {
	s.VpnGateway = v
	return s
}

type DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGateway struct {
	// Indicates whether BGP routes are automatically advertised to the VPC. Valid values:
	//
	// *   **true**: yes
	// *   **false**: no
	AutoPropagate *bool `json:"AutoPropagate,omitempty" xml:"AutoPropagate,omitempty"`
	// The payment status of the VPN gateway.
	//
	// *   **Normal:** The VPN gateway is running as expected.
	// *   **FinancialLocked**: The VPN gateway is locked due to overdue payments.
	BusinessStatus *string `json:"BusinessStatus,omitempty" xml:"BusinessStatus,omitempty"`
	// The billing method of the VPN gateway.
	//
	// The value is set to **POSTPAY**, which indicates the pay-as-you-go billing method.
	ChargeType *string `json:"ChargeType,omitempty" xml:"ChargeType,omitempty"`
	// The timestamp when the VPN gateway was created. Unit: milliseconds.
	//
	// This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The description of the VPN gateway.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// 系统为VPN网关实例分配的用于创建IPsec-VPN连接的第二个IP地址。
	//
	// 仅支持创建双隧道模式IPsec-VPN连接的VPN网关实例会返回当前参数。
	DisasterRecoveryInternetIp *string `json:"DisasterRecoveryInternetIp,omitempty" xml:"DisasterRecoveryInternetIp,omitempty"`
	// VPN网关实例关联的第二个交换机ID。
	//
	// 仅支持创建双隧道模式IPsec-VPN连接的VPN网关实例会返回当前参数。
	DisasterRecoveryVSwitchId *string `json:"DisasterRecoveryVSwitchId,omitempty" xml:"DisasterRecoveryVSwitchId,omitempty"`
	// The BGP status of the VPN gateway.
	//
	// *   **true**: enabled
	// *   **false**: disabled
	EnableBgp *bool `json:"EnableBgp,omitempty" xml:"EnableBgp,omitempty"`
	// The timestamp when the VPN gateway expires. Unit: milliseconds.
	//
	// This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
	EndTime *int64 `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The public IP address of the VPN gateway.
	InternetIp *string `json:"InternetIp,omitempty" xml:"InternetIp,omitempty"`
	// Indicates whether IPsec-VPN is enabled for the VPN gateway.
	//
	// *   **enable**: enabled
	// *   **disable**: disabled
	IpsecVpn *string `json:"IpsecVpn,omitempty" xml:"IpsecVpn,omitempty"`
	// The name of the VPN gateway.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The network type of the VPN gateway.
	//
	// *   **public**: public VPN gateway
	// *   **private**: private VPN gateway
	NetworkType *string `json:"NetworkType,omitempty" xml:"NetworkType,omitempty"`
	// The information about the pending orders.
	//
	// >  This parameter is returned only when **IncludeReservationData** is set to **true**.
	ReservationData *DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGatewayReservationData `json:"ReservationData,omitempty" xml:"ReservationData,omitempty" type:"Struct"`
	// The maximum bandwidth of the VPN gateway. **M** indicates Mbit/s.
	Spec *string `json:"Spec,omitempty" xml:"Spec,omitempty"`
	// The number of SSL-VPN connections supported by the VPN gateway.
	SslMaxConnections *int64 `json:"SslMaxConnections,omitempty" xml:"SslMaxConnections,omitempty"`
	// Indicates whether SSL-VPN is enabled for the VPN gateway.
	//
	// *   **enable**: enabled
	// *   **disable**: disabled
	SslVpn *string `json:"SslVpn,omitempty" xml:"SslVpn,omitempty"`
	// SSL-VPN连接的IP地址。
	//
	// 仅支持创建双隧道模式IPsec-VPN连接的公网网络类型的VPN网关实例开启SSL-VPN功能后，才会返回当前参数。
	SslVpnInternetIp *string `json:"SslVpnInternetIp,omitempty" xml:"SslVpnInternetIp,omitempty"`
	// The status of the pending order.
	//
	// *   **1**: indicates that the order for renewal or the order for renewal with a specification change has not taken effect.
	// *   **2**: indicates that the order for a temporary upgrade has taken effect. After the temporary upgrade expires, the system restores the VPN gateway to its previous specifications. In this case, **ReservationIpsec**, **ReservationMaxConnections**, **ReservationSpec**, and **ReservationSsl** indicate the previous specification.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The automatically generated tag of the VPN gateway.
	//
	// *   **VpnEnableBgp**: indicates whether the VPN gateway supports BGP. Valid values:
	//
	//     *   **true**: yes
	//     *   **false**: no
	//
	// *   **VisuallySsl**: indicates whether the VPN gateway allows you to view information about connected SSL clients.
	//
	//     *   **true**: yes
	//     *   **false**: no
	//
	// *   **PbrPriority**: indicates whether the VPN gateway allows you to configure priorities for policy-based routes.
	//
	//     *   **true**: yes
	//     *   **false**: no
	//
	// *   **VpnNewImage**: indicates whether the VPN gateway is upgraded.
	//
	//     *   **true**: yes
	//     *   **false**: no
	//
	// *   **description**: the description of the VPN gateway. This parameter is for internal system use only.
	//
	// *   **VpnVersion**: the version of the VPN gateway.
	Tag *string `json:"Tag,omitempty" xml:"Tag,omitempty"`
	// The list of tags added to the VPN gateway.
	Tags *DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGatewayTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Struct"`
	// The ID of the vSwitch to which the VPN gateway belongs.
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
	// The ID of the VPC to which the VPN gateway belongs.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
	// The ID of the VPN gateway.
	VpnGatewayId *string `json:"VpnGatewayId,omitempty" xml:"VpnGatewayId,omitempty"`
	// The type of the VPN gateway.
	//
	// The value is set to **Normal**, which indicates a standard NAT gateway.
	VpnType *string `json:"VpnType,omitempty" xml:"VpnType,omitempty"`
}

func (s DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGateway) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGateway) GoString() string {
	return s.String()
}

func (s *DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGateway) SetAutoPropagate(v bool) *DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGateway {
	s.AutoPropagate = &v
	return s
}

func (s *DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGateway) SetBusinessStatus(v string) *DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGateway {
	s.BusinessStatus = &v
	return s
}

func (s *DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGateway) SetChargeType(v string) *DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGateway {
	s.ChargeType = &v
	return s
}

func (s *DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGateway) SetCreateTime(v int64) *DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGateway {
	s.CreateTime = &v
	return s
}

func (s *DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGateway) SetDescription(v string) *DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGateway {
	s.Description = &v
	return s
}

func (s *DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGateway) SetDisasterRecoveryInternetIp(v string) *DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGateway {
	s.DisasterRecoveryInternetIp = &v
	return s
}

func (s *DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGateway) SetDisasterRecoveryVSwitchId(v string) *DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGateway {
	s.DisasterRecoveryVSwitchId = &v
	return s
}

func (s *DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGateway) SetEnableBgp(v bool) *DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGateway {
	s.EnableBgp = &v
	return s
}

func (s *DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGateway) SetEndTime(v int64) *DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGateway {
	s.EndTime = &v
	return s
}

func (s *DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGateway) SetInternetIp(v string) *DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGateway {
	s.InternetIp = &v
	return s
}

func (s *DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGateway) SetIpsecVpn(v string) *DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGateway {
	s.IpsecVpn = &v
	return s
}

func (s *DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGateway) SetName(v string) *DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGateway {
	s.Name = &v
	return s
}

func (s *DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGateway) SetNetworkType(v string) *DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGateway {
	s.NetworkType = &v
	return s
}

func (s *DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGateway) SetReservationData(v *DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGatewayReservationData) *DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGateway {
	s.ReservationData = v
	return s
}

func (s *DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGateway) SetSpec(v string) *DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGateway {
	s.Spec = &v
	return s
}

func (s *DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGateway) SetSslMaxConnections(v int64) *DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGateway {
	s.SslMaxConnections = &v
	return s
}

func (s *DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGateway) SetSslVpn(v string) *DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGateway {
	s.SslVpn = &v
	return s
}

func (s *DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGateway) SetSslVpnInternetIp(v string) *DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGateway {
	s.SslVpnInternetIp = &v
	return s
}

func (s *DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGateway) SetStatus(v string) *DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGateway {
	s.Status = &v
	return s
}

func (s *DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGateway) SetTag(v string) *DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGateway {
	s.Tag = &v
	return s
}

func (s *DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGateway) SetTags(v *DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGatewayTags) *DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGateway {
	s.Tags = v
	return s
}

func (s *DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGateway) SetVSwitchId(v string) *DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGateway {
	s.VSwitchId = &v
	return s
}

func (s *DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGateway) SetVpcId(v string) *DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGateway {
	s.VpcId = &v
	return s
}

func (s *DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGateway) SetVpnGatewayId(v string) *DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGateway {
	s.VpnGatewayId = &v
	return s
}

func (s *DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGateway) SetVpnType(v string) *DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGateway {
	s.VpnType = &v
	return s
}

type DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGatewayReservationData struct {
	// If the order type is **TEMP_UPGRADE** (temporary upgrade), this parameter specifies the time when the temporary upgrade expires.
	//
	// If the order type is **RENEWCHANGE** (renewal with an upgrade or a downgrade) or **RENEW** (renewal), this parameter indicates the time when the renewal or renewal with an upgrade or a downgrade takes effect.
	ReservationEndTime *string `json:"ReservationEndTime,omitempty" xml:"ReservationEndTime,omitempty"`
	// The IPsec-VPN status of the order that has not taken effect. Valid values:
	//
	// - **enable**: enabled
	// - **disable**: disabled
	ReservationIpsec *string `json:"ReservationIpsec,omitempty" xml:"ReservationIpsec,omitempty"`
	// The maximum number of concurrent SSL-VPN connections of the pending order.
	ReservationMaxConnections *int32 `json:"ReservationMaxConnections,omitempty" xml:"ReservationMaxConnections,omitempty"`
	// The type of the order that has not taken effect. Valid values:
	//
	// - **RENEWCHANGE**: renewal with a specification change
	// - **TEMP_UPGRADE**: temporary upgrade
	// - **RENEW**: renewal
	ReservationOrderType *string `json:"ReservationOrderType,omitempty" xml:"ReservationOrderType,omitempty"`
	// The bandwidth specification of the order that has not taken effect. Unit: Mbit/s.
	ReservationSpec *string `json:"ReservationSpec,omitempty" xml:"ReservationSpec,omitempty"`
	// The SSL-VPN status of the order that has not taken effect. Valid values:
	//
	// - **enable**: enabled
	// - **disable**: disabled
	ReservationSsl *string `json:"ReservationSsl,omitempty" xml:"ReservationSsl,omitempty"`
	// The status of the pending order.
	//
	// - **1**: indicates that the order for renewal or the order for renewal with a specification change has not taken effect.
	// - **2**: indicates that the order for a temporary upgrade has taken effect. After the temporary upgrade expires, the system restores the VPN gateway to its previous specifications. In this case, **ReservationIpsec**, **ReservationMaxConnections**, **ReservationSpec**, and **ReservationSsl** indicate the previous specification.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGatewayReservationData) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGatewayReservationData) GoString() string {
	return s.String()
}

func (s *DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGatewayReservationData) SetReservationEndTime(v string) *DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGatewayReservationData {
	s.ReservationEndTime = &v
	return s
}

func (s *DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGatewayReservationData) SetReservationIpsec(v string) *DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGatewayReservationData {
	s.ReservationIpsec = &v
	return s
}

func (s *DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGatewayReservationData) SetReservationMaxConnections(v int32) *DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGatewayReservationData {
	s.ReservationMaxConnections = &v
	return s
}

func (s *DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGatewayReservationData) SetReservationOrderType(v string) *DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGatewayReservationData {
	s.ReservationOrderType = &v
	return s
}

func (s *DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGatewayReservationData) SetReservationSpec(v string) *DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGatewayReservationData {
	s.ReservationSpec = &v
	return s
}

func (s *DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGatewayReservationData) SetReservationSsl(v string) *DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGatewayReservationData {
	s.ReservationSsl = &v
	return s
}

func (s *DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGatewayReservationData) SetStatus(v string) *DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGatewayReservationData {
	s.Status = &v
	return s
}

type DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGatewayTags struct {
	Tag []*DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGatewayTagsTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGatewayTags) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGatewayTags) GoString() string {
	return s.String()
}

func (s *DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGatewayTags) SetTag(v []*DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGatewayTagsTag) *DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGatewayTags {
	s.Tag = v
	return s
}

type DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGatewayTagsTag struct {
	// The tag key.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGatewayTagsTag) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGatewayTagsTag) GoString() string {
	return s.String()
}

func (s *DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGatewayTagsTag) SetKey(v string) *DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGatewayTagsTag {
	s.Key = &v
	return s
}

func (s *DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGatewayTagsTag) SetValue(v string) *DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGatewayTagsTag {
	s.Value = &v
	return s
}

type DescribeVpnGatewaysResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeVpnGatewaysResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeVpnGatewaysResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpnGatewaysResponse) GoString() string {
	return s.String()
}

func (s *DescribeVpnGatewaysResponse) SetHeaders(v map[string]*string) *DescribeVpnGatewaysResponse {
	s.Headers = v
	return s
}

func (s *DescribeVpnGatewaysResponse) SetStatusCode(v int32) *DescribeVpnGatewaysResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeVpnGatewaysResponse) SetBody(v *DescribeVpnGatewaysResponseBody) *DescribeVpnGatewaysResponse {
	s.Body = v
	return s
}

type DescribeVpnPbrRouteEntriesRequest struct {
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of the page to return. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Maximum value: **50**. Default value: **10**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the region where the VPN gateway is created.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the VPN gateway.
	VpnGatewayId *string `json:"VpnGatewayId,omitempty" xml:"VpnGatewayId,omitempty"`
}

func (s DescribeVpnPbrRouteEntriesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpnPbrRouteEntriesRequest) GoString() string {
	return s.String()
}

func (s *DescribeVpnPbrRouteEntriesRequest) SetOwnerAccount(v string) *DescribeVpnPbrRouteEntriesRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeVpnPbrRouteEntriesRequest) SetOwnerId(v int64) *DescribeVpnPbrRouteEntriesRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeVpnPbrRouteEntriesRequest) SetPageNumber(v int32) *DescribeVpnPbrRouteEntriesRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeVpnPbrRouteEntriesRequest) SetPageSize(v int32) *DescribeVpnPbrRouteEntriesRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeVpnPbrRouteEntriesRequest) SetRegionId(v string) *DescribeVpnPbrRouteEntriesRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeVpnPbrRouteEntriesRequest) SetResourceOwnerAccount(v string) *DescribeVpnPbrRouteEntriesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeVpnPbrRouteEntriesRequest) SetResourceOwnerId(v int64) *DescribeVpnPbrRouteEntriesRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeVpnPbrRouteEntriesRequest) SetVpnGatewayId(v string) *DescribeVpnPbrRouteEntriesRequest {
	s.VpnGatewayId = &v
	return s
}

type DescribeVpnPbrRouteEntriesResponseBody struct {
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
	// The list of policy-based routes.
	VpnPbrRouteEntries *DescribeVpnPbrRouteEntriesResponseBodyVpnPbrRouteEntries `json:"VpnPbrRouteEntries,omitempty" xml:"VpnPbrRouteEntries,omitempty" type:"Struct"`
}

func (s DescribeVpnPbrRouteEntriesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpnPbrRouteEntriesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeVpnPbrRouteEntriesResponseBody) SetPageNumber(v int32) *DescribeVpnPbrRouteEntriesResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeVpnPbrRouteEntriesResponseBody) SetPageSize(v int32) *DescribeVpnPbrRouteEntriesResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeVpnPbrRouteEntriesResponseBody) SetRequestId(v string) *DescribeVpnPbrRouteEntriesResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeVpnPbrRouteEntriesResponseBody) SetTotalCount(v int32) *DescribeVpnPbrRouteEntriesResponseBody {
	s.TotalCount = &v
	return s
}

func (s *DescribeVpnPbrRouteEntriesResponseBody) SetVpnPbrRouteEntries(v *DescribeVpnPbrRouteEntriesResponseBodyVpnPbrRouteEntries) *DescribeVpnPbrRouteEntriesResponseBody {
	s.VpnPbrRouteEntries = v
	return s
}

type DescribeVpnPbrRouteEntriesResponseBodyVpnPbrRouteEntries struct {
	VpnPbrRouteEntry []*DescribeVpnPbrRouteEntriesResponseBodyVpnPbrRouteEntriesVpnPbrRouteEntry `json:"VpnPbrRouteEntry,omitempty" xml:"VpnPbrRouteEntry,omitempty" type:"Repeated"`
}

func (s DescribeVpnPbrRouteEntriesResponseBodyVpnPbrRouteEntries) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpnPbrRouteEntriesResponseBodyVpnPbrRouteEntries) GoString() string {
	return s.String()
}

func (s *DescribeVpnPbrRouteEntriesResponseBodyVpnPbrRouteEntries) SetVpnPbrRouteEntry(v []*DescribeVpnPbrRouteEntriesResponseBodyVpnPbrRouteEntriesVpnPbrRouteEntry) *DescribeVpnPbrRouteEntriesResponseBodyVpnPbrRouteEntries {
	s.VpnPbrRouteEntry = v
	return s
}

type DescribeVpnPbrRouteEntriesResponseBodyVpnPbrRouteEntriesVpnPbrRouteEntry struct {
	// The timestamp generated when the policy-based route was created. Unit: milliseconds.
	//
	// This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The next hop of the policy-based route.
	NextHop         *string `json:"NextHop,omitempty" xml:"NextHop,omitempty"`
	NextHopTunnelId *string `json:"NextHopTunnelId,omitempty" xml:"NextHopTunnelId,omitempty"`
	// The priority of the policy-based route.
	//
	// A smaller value indicates a higher priority.
	Priority *int32 `json:"Priority,omitempty" xml:"Priority,omitempty"`
	// The destination CIDR block of the policy-based route.
	RouteDest *string `json:"RouteDest,omitempty" xml:"RouteDest,omitempty"`
	// The source CIDR block of the policy-based route.
	RouteSource *string `json:"RouteSource,omitempty" xml:"RouteSource,omitempty"`
	// The status of the policy-based route. Valid values:
	//
	// *   **published**: advertised to the VPC route table.
	// *   **normal**: not advertised to the VPC route table.
	State *string `json:"State,omitempty" xml:"State,omitempty"`
	// The ID of the VPN gateway.
	VpnInstanceId *string `json:"VpnInstanceId,omitempty" xml:"VpnInstanceId,omitempty"`
	// The weight of the policy-based route. Valid values:
	//
	// *   **100**: The IPsec-VPN connection associated with the policy-based route serves as an active connection.
	// *   **0**: The IPsec-VPN connection associated with the policy-based route serves as a standby connection.
	Weight *int32 `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s DescribeVpnPbrRouteEntriesResponseBodyVpnPbrRouteEntriesVpnPbrRouteEntry) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpnPbrRouteEntriesResponseBodyVpnPbrRouteEntriesVpnPbrRouteEntry) GoString() string {
	return s.String()
}

func (s *DescribeVpnPbrRouteEntriesResponseBodyVpnPbrRouteEntriesVpnPbrRouteEntry) SetCreateTime(v int64) *DescribeVpnPbrRouteEntriesResponseBodyVpnPbrRouteEntriesVpnPbrRouteEntry {
	s.CreateTime = &v
	return s
}

func (s *DescribeVpnPbrRouteEntriesResponseBodyVpnPbrRouteEntriesVpnPbrRouteEntry) SetNextHop(v string) *DescribeVpnPbrRouteEntriesResponseBodyVpnPbrRouteEntriesVpnPbrRouteEntry {
	s.NextHop = &v
	return s
}

func (s *DescribeVpnPbrRouteEntriesResponseBodyVpnPbrRouteEntriesVpnPbrRouteEntry) SetNextHopTunnelId(v string) *DescribeVpnPbrRouteEntriesResponseBodyVpnPbrRouteEntriesVpnPbrRouteEntry {
	s.NextHopTunnelId = &v
	return s
}

func (s *DescribeVpnPbrRouteEntriesResponseBodyVpnPbrRouteEntriesVpnPbrRouteEntry) SetPriority(v int32) *DescribeVpnPbrRouteEntriesResponseBodyVpnPbrRouteEntriesVpnPbrRouteEntry {
	s.Priority = &v
	return s
}

func (s *DescribeVpnPbrRouteEntriesResponseBodyVpnPbrRouteEntriesVpnPbrRouteEntry) SetRouteDest(v string) *DescribeVpnPbrRouteEntriesResponseBodyVpnPbrRouteEntriesVpnPbrRouteEntry {
	s.RouteDest = &v
	return s
}

func (s *DescribeVpnPbrRouteEntriesResponseBodyVpnPbrRouteEntriesVpnPbrRouteEntry) SetRouteSource(v string) *DescribeVpnPbrRouteEntriesResponseBodyVpnPbrRouteEntriesVpnPbrRouteEntry {
	s.RouteSource = &v
	return s
}

func (s *DescribeVpnPbrRouteEntriesResponseBodyVpnPbrRouteEntriesVpnPbrRouteEntry) SetState(v string) *DescribeVpnPbrRouteEntriesResponseBodyVpnPbrRouteEntriesVpnPbrRouteEntry {
	s.State = &v
	return s
}

func (s *DescribeVpnPbrRouteEntriesResponseBodyVpnPbrRouteEntriesVpnPbrRouteEntry) SetVpnInstanceId(v string) *DescribeVpnPbrRouteEntriesResponseBodyVpnPbrRouteEntriesVpnPbrRouteEntry {
	s.VpnInstanceId = &v
	return s
}

func (s *DescribeVpnPbrRouteEntriesResponseBodyVpnPbrRouteEntriesVpnPbrRouteEntry) SetWeight(v int32) *DescribeVpnPbrRouteEntriesResponseBodyVpnPbrRouteEntriesVpnPbrRouteEntry {
	s.Weight = &v
	return s
}

type DescribeVpnPbrRouteEntriesResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeVpnPbrRouteEntriesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeVpnPbrRouteEntriesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpnPbrRouteEntriesResponse) GoString() string {
	return s.String()
}

func (s *DescribeVpnPbrRouteEntriesResponse) SetHeaders(v map[string]*string) *DescribeVpnPbrRouteEntriesResponse {
	s.Headers = v
	return s
}

func (s *DescribeVpnPbrRouteEntriesResponse) SetStatusCode(v int32) *DescribeVpnPbrRouteEntriesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeVpnPbrRouteEntriesResponse) SetBody(v *DescribeVpnPbrRouteEntriesResponseBody) *DescribeVpnPbrRouteEntriesResponse {
	s.Body = v
	return s
}

type DescribeVpnRouteEntriesRequest struct {
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of the page to return. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Maximum value: **50**. Default value: **10**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the region where the VPN gateway is created.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The type of the route entry. Valid values:
	//
	// *   **Custom**: custom
	// *   **System**: system
	RouteEntryType *string `json:"RouteEntryType,omitempty" xml:"RouteEntryType,omitempty"`
	// The ID of the VPN gateway.
	VpnGatewayId *string `json:"VpnGatewayId,omitempty" xml:"VpnGatewayId,omitempty"`
}

func (s DescribeVpnRouteEntriesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpnRouteEntriesRequest) GoString() string {
	return s.String()
}

func (s *DescribeVpnRouteEntriesRequest) SetOwnerAccount(v string) *DescribeVpnRouteEntriesRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeVpnRouteEntriesRequest) SetOwnerId(v int64) *DescribeVpnRouteEntriesRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeVpnRouteEntriesRequest) SetPageNumber(v int32) *DescribeVpnRouteEntriesRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeVpnRouteEntriesRequest) SetPageSize(v int32) *DescribeVpnRouteEntriesRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeVpnRouteEntriesRequest) SetRegionId(v string) *DescribeVpnRouteEntriesRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeVpnRouteEntriesRequest) SetResourceOwnerAccount(v string) *DescribeVpnRouteEntriesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeVpnRouteEntriesRequest) SetResourceOwnerId(v int64) *DescribeVpnRouteEntriesRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeVpnRouteEntriesRequest) SetRouteEntryType(v string) *DescribeVpnRouteEntriesRequest {
	s.RouteEntryType = &v
	return s
}

func (s *DescribeVpnRouteEntriesRequest) SetVpnGatewayId(v string) *DescribeVpnRouteEntriesRequest {
	s.VpnGatewayId = &v
	return s
}

type DescribeVpnRouteEntriesResponseBody struct {
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
	// The list of route entries.
	VpnRouteEntries *DescribeVpnRouteEntriesResponseBodyVpnRouteEntries `json:"VpnRouteEntries,omitempty" xml:"VpnRouteEntries,omitempty" type:"Struct"`
}

func (s DescribeVpnRouteEntriesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpnRouteEntriesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeVpnRouteEntriesResponseBody) SetPageNumber(v int32) *DescribeVpnRouteEntriesResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeVpnRouteEntriesResponseBody) SetPageSize(v int32) *DescribeVpnRouteEntriesResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeVpnRouteEntriesResponseBody) SetRequestId(v string) *DescribeVpnRouteEntriesResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeVpnRouteEntriesResponseBody) SetTotalCount(v int32) *DescribeVpnRouteEntriesResponseBody {
	s.TotalCount = &v
	return s
}

func (s *DescribeVpnRouteEntriesResponseBody) SetVpnRouteEntries(v *DescribeVpnRouteEntriesResponseBodyVpnRouteEntries) *DescribeVpnRouteEntriesResponseBody {
	s.VpnRouteEntries = v
	return s
}

type DescribeVpnRouteEntriesResponseBodyVpnRouteEntries struct {
	VpnRouteEntry []*DescribeVpnRouteEntriesResponseBodyVpnRouteEntriesVpnRouteEntry `json:"VpnRouteEntry,omitempty" xml:"VpnRouteEntry,omitempty" type:"Repeated"`
}

func (s DescribeVpnRouteEntriesResponseBodyVpnRouteEntries) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpnRouteEntriesResponseBodyVpnRouteEntries) GoString() string {
	return s.String()
}

func (s *DescribeVpnRouteEntriesResponseBodyVpnRouteEntries) SetVpnRouteEntry(v []*DescribeVpnRouteEntriesResponseBodyVpnRouteEntriesVpnRouteEntry) *DescribeVpnRouteEntriesResponseBodyVpnRouteEntries {
	s.VpnRouteEntry = v
	return s
}

type DescribeVpnRouteEntriesResponseBodyVpnRouteEntriesVpnRouteEntry struct {
	// The AS path of the route entry.
	AsPath *string `json:"AsPath,omitempty" xml:"AsPath,omitempty"`
	// The community attributes of the route entry.
	Community *string `json:"Community,omitempty" xml:"Community,omitempty"`
	// The timestamp when the route entry was created.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The next hop of the route entry.
	NextHop         *string `json:"NextHop,omitempty" xml:"NextHop,omitempty"`
	NextHopTunnelId *string `json:"NextHopTunnelId,omitempty" xml:"NextHopTunnelId,omitempty"`
	// The destination CIDR block of the route entry.
	RouteDest *string `json:"RouteDest,omitempty" xml:"RouteDest,omitempty"`
	// The type of the route entry. Valid values:
	//
	// *   **Custom**: custom
	// *   **System**: system
	RouteEntryType *string `json:"RouteEntryType,omitempty" xml:"RouteEntryType,omitempty"`
	// The source CIDR block of the route entry.
	Source *string `json:"Source,omitempty" xml:"Source,omitempty"`
	// The status of the route entry. Valid values:
	//
	// *   **published**: advertised
	// *   **normal**: not advertised
	State *string `json:"State,omitempty" xml:"State,omitempty"`
	// The ID of the VPN gateway.
	VpnInstanceId *string `json:"VpnInstanceId,omitempty" xml:"VpnInstanceId,omitempty"`
	// The weight of the route entry. Valid values: **0** and **100**.
	//
	// *   **0**: a low priority
	// *   **100**: a high priority
	Weight *int32 `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s DescribeVpnRouteEntriesResponseBodyVpnRouteEntriesVpnRouteEntry) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpnRouteEntriesResponseBodyVpnRouteEntriesVpnRouteEntry) GoString() string {
	return s.String()
}

func (s *DescribeVpnRouteEntriesResponseBodyVpnRouteEntriesVpnRouteEntry) SetAsPath(v string) *DescribeVpnRouteEntriesResponseBodyVpnRouteEntriesVpnRouteEntry {
	s.AsPath = &v
	return s
}

func (s *DescribeVpnRouteEntriesResponseBodyVpnRouteEntriesVpnRouteEntry) SetCommunity(v string) *DescribeVpnRouteEntriesResponseBodyVpnRouteEntriesVpnRouteEntry {
	s.Community = &v
	return s
}

func (s *DescribeVpnRouteEntriesResponseBodyVpnRouteEntriesVpnRouteEntry) SetCreateTime(v int64) *DescribeVpnRouteEntriesResponseBodyVpnRouteEntriesVpnRouteEntry {
	s.CreateTime = &v
	return s
}

func (s *DescribeVpnRouteEntriesResponseBodyVpnRouteEntriesVpnRouteEntry) SetNextHop(v string) *DescribeVpnRouteEntriesResponseBodyVpnRouteEntriesVpnRouteEntry {
	s.NextHop = &v
	return s
}

func (s *DescribeVpnRouteEntriesResponseBodyVpnRouteEntriesVpnRouteEntry) SetNextHopTunnelId(v string) *DescribeVpnRouteEntriesResponseBodyVpnRouteEntriesVpnRouteEntry {
	s.NextHopTunnelId = &v
	return s
}

func (s *DescribeVpnRouteEntriesResponseBodyVpnRouteEntriesVpnRouteEntry) SetRouteDest(v string) *DescribeVpnRouteEntriesResponseBodyVpnRouteEntriesVpnRouteEntry {
	s.RouteDest = &v
	return s
}

func (s *DescribeVpnRouteEntriesResponseBodyVpnRouteEntriesVpnRouteEntry) SetRouteEntryType(v string) *DescribeVpnRouteEntriesResponseBodyVpnRouteEntriesVpnRouteEntry {
	s.RouteEntryType = &v
	return s
}

func (s *DescribeVpnRouteEntriesResponseBodyVpnRouteEntriesVpnRouteEntry) SetSource(v string) *DescribeVpnRouteEntriesResponseBodyVpnRouteEntriesVpnRouteEntry {
	s.Source = &v
	return s
}

func (s *DescribeVpnRouteEntriesResponseBodyVpnRouteEntriesVpnRouteEntry) SetState(v string) *DescribeVpnRouteEntriesResponseBodyVpnRouteEntriesVpnRouteEntry {
	s.State = &v
	return s
}

func (s *DescribeVpnRouteEntriesResponseBodyVpnRouteEntriesVpnRouteEntry) SetVpnInstanceId(v string) *DescribeVpnRouteEntriesResponseBodyVpnRouteEntriesVpnRouteEntry {
	s.VpnInstanceId = &v
	return s
}

func (s *DescribeVpnRouteEntriesResponseBodyVpnRouteEntriesVpnRouteEntry) SetWeight(v int32) *DescribeVpnRouteEntriesResponseBodyVpnRouteEntriesVpnRouteEntry {
	s.Weight = &v
	return s
}

type DescribeVpnRouteEntriesResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeVpnRouteEntriesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeVpnRouteEntriesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpnRouteEntriesResponse) GoString() string {
	return s.String()
}

func (s *DescribeVpnRouteEntriesResponse) SetHeaders(v map[string]*string) *DescribeVpnRouteEntriesResponse {
	s.Headers = v
	return s
}

func (s *DescribeVpnRouteEntriesResponse) SetStatusCode(v int32) *DescribeVpnRouteEntriesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeVpnRouteEntriesResponse) SetBody(v *DescribeVpnRouteEntriesResponseBody) *DescribeVpnRouteEntriesResponse {
	s.Body = v
	return s
}

type DescribeVpnSslServerLogsRequest struct {
	// The beginning of the time range to query. The value must be a unix timestamp. For example, 1600738962 specifies 09:42:42 (UTC+8) on September 22, 2020.
	//
	// >  If you specify **From**, you must also specify **To** or **MinutePeriod**.
	From *int32 `json:"From,omitempty" xml:"From,omitempty"`
	// The interval at which log data is queried. Unit: minutes.
	//
	// >  If both **From** and **To** are not specified, you must specify **MinutePeriod**.
	MinutePeriod *int32  `json:"MinutePeriod,omitempty" xml:"MinutePeriod,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of the page to return. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Maximum value: **50**. Default value: **10**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the region where the SSL server is created. You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the SSL client certificate.
	SslVpnClientCertId *string `json:"SslVpnClientCertId,omitempty" xml:"SslVpnClientCertId,omitempty"`
	// The end of the time range to query. The value must be a unix timestamp. For example, 1600738962 specifies 09:42:42 (UTC+8) on September 22, 2020.
	//
	// >  If you specify **To**, you must also specify **From** or **MinutePeriod**.
	To *int32 `json:"To,omitempty" xml:"To,omitempty"`
	// The ID of the SSL server.
	VpnSslServerId *string `json:"VpnSslServerId,omitempty" xml:"VpnSslServerId,omitempty"`
}

func (s DescribeVpnSslServerLogsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpnSslServerLogsRequest) GoString() string {
	return s.String()
}

func (s *DescribeVpnSslServerLogsRequest) SetFrom(v int32) *DescribeVpnSslServerLogsRequest {
	s.From = &v
	return s
}

func (s *DescribeVpnSslServerLogsRequest) SetMinutePeriod(v int32) *DescribeVpnSslServerLogsRequest {
	s.MinutePeriod = &v
	return s
}

func (s *DescribeVpnSslServerLogsRequest) SetOwnerAccount(v string) *DescribeVpnSslServerLogsRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeVpnSslServerLogsRequest) SetOwnerId(v int64) *DescribeVpnSslServerLogsRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeVpnSslServerLogsRequest) SetPageNumber(v int32) *DescribeVpnSslServerLogsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeVpnSslServerLogsRequest) SetPageSize(v int32) *DescribeVpnSslServerLogsRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeVpnSslServerLogsRequest) SetRegionId(v string) *DescribeVpnSslServerLogsRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeVpnSslServerLogsRequest) SetResourceOwnerAccount(v string) *DescribeVpnSslServerLogsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeVpnSslServerLogsRequest) SetResourceOwnerId(v int64) *DescribeVpnSslServerLogsRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeVpnSslServerLogsRequest) SetSslVpnClientCertId(v string) *DescribeVpnSslServerLogsRequest {
	s.SslVpnClientCertId = &v
	return s
}

func (s *DescribeVpnSslServerLogsRequest) SetTo(v int32) *DescribeVpnSslServerLogsRequest {
	s.To = &v
	return s
}

func (s *DescribeVpnSslServerLogsRequest) SetVpnSslServerId(v string) *DescribeVpnSslServerLogsRequest {
	s.VpnSslServerId = &v
	return s
}

type DescribeVpnSslServerLogsResponseBody struct {
	// The number of log entries.
	Count *int32 `json:"Count,omitempty" xml:"Count,omitempty"`
	// An array of strings.
	//
	// Each item in the array is a log entry.
	Data *DescribeVpnSslServerLogsResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// Indicates whether the log is accurate. Valid values:
	//
	// *   **true**: accurate
	// *   **false**: inaccurate
	IsCompleted *bool `json:"IsCompleted,omitempty" xml:"IsCompleted,omitempty"`
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeVpnSslServerLogsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpnSslServerLogsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeVpnSslServerLogsResponseBody) SetCount(v int32) *DescribeVpnSslServerLogsResponseBody {
	s.Count = &v
	return s
}

func (s *DescribeVpnSslServerLogsResponseBody) SetData(v *DescribeVpnSslServerLogsResponseBodyData) *DescribeVpnSslServerLogsResponseBody {
	s.Data = v
	return s
}

func (s *DescribeVpnSslServerLogsResponseBody) SetIsCompleted(v bool) *DescribeVpnSslServerLogsResponseBody {
	s.IsCompleted = &v
	return s
}

func (s *DescribeVpnSslServerLogsResponseBody) SetPageNumber(v int32) *DescribeVpnSslServerLogsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeVpnSslServerLogsResponseBody) SetPageSize(v int32) *DescribeVpnSslServerLogsResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeVpnSslServerLogsResponseBody) SetRequestId(v string) *DescribeVpnSslServerLogsResponseBody {
	s.RequestId = &v
	return s
}

type DescribeVpnSslServerLogsResponseBodyData struct {
	Logs []*string `json:"Logs,omitempty" xml:"Logs,omitempty" type:"Repeated"`
}

func (s DescribeVpnSslServerLogsResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpnSslServerLogsResponseBodyData) GoString() string {
	return s.String()
}

func (s *DescribeVpnSslServerLogsResponseBodyData) SetLogs(v []*string) *DescribeVpnSslServerLogsResponseBodyData {
	s.Logs = v
	return s
}

type DescribeVpnSslServerLogsResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeVpnSslServerLogsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeVpnSslServerLogsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeVpnSslServerLogsResponse) GoString() string {
	return s.String()
}

func (s *DescribeVpnSslServerLogsResponse) SetHeaders(v map[string]*string) *DescribeVpnSslServerLogsResponse {
	s.Headers = v
	return s
}

func (s *DescribeVpnSslServerLogsResponse) SetStatusCode(v int32) *DescribeVpnSslServerLogsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeVpnSslServerLogsResponse) SetBody(v *DescribeVpnSslServerLogsResponseBody) *DescribeVpnSslServerLogsResponse {
	s.Body = v
	return s
}

type DescribeZonesRequest struct {
	// The language used in the **LocalName** parameter to display the zone names. Valid values:
	//
	// *   **zh-cn**: Chinese
	// *   **en-us**: English
	// *   **ja**: Japanese
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	OwnerAccount   *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId        *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region where zones are queried. You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The type of the zones to be queried. Default value: **AvailabilityZone**. This value indicates Alibaba Cloud zones.
	ZoneType *string `json:"ZoneType,omitempty" xml:"ZoneType,omitempty"`
}

func (s DescribeZonesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeZonesRequest) GoString() string {
	return s.String()
}

func (s *DescribeZonesRequest) SetAcceptLanguage(v string) *DescribeZonesRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *DescribeZonesRequest) SetOwnerAccount(v string) *DescribeZonesRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeZonesRequest) SetOwnerId(v int64) *DescribeZonesRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeZonesRequest) SetRegionId(v string) *DescribeZonesRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeZonesRequest) SetResourceOwnerAccount(v string) *DescribeZonesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeZonesRequest) SetResourceOwnerId(v int64) *DescribeZonesRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeZonesRequest) SetZoneType(v string) *DescribeZonesRequest {
	s.ZoneType = &v
	return s
}

type DescribeZonesResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The zones that are returned.
	Zones *DescribeZonesResponseBodyZones `json:"Zones,omitempty" xml:"Zones,omitempty" type:"Struct"`
}

func (s DescribeZonesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeZonesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeZonesResponseBody) SetRequestId(v string) *DescribeZonesResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeZonesResponseBody) SetZones(v *DescribeZonesResponseBodyZones) *DescribeZonesResponseBody {
	s.Zones = v
	return s
}

type DescribeZonesResponseBodyZones struct {
	Zone []*DescribeZonesResponseBodyZonesZone `json:"Zone,omitempty" xml:"Zone,omitempty" type:"Repeated"`
}

func (s DescribeZonesResponseBodyZones) String() string {
	return tea.Prettify(s)
}

func (s DescribeZonesResponseBodyZones) GoString() string {
	return s.String()
}

func (s *DescribeZonesResponseBodyZones) SetZone(v []*DescribeZonesResponseBodyZonesZone) *DescribeZonesResponseBodyZones {
	s.Zone = v
	return s
}

type DescribeZonesResponseBodyZonesZone struct {
	// The name of the zone.
	LocalName *string `json:"LocalName,omitempty" xml:"LocalName,omitempty"`
	// The ID of the zone.
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
	// The type of the zones to be queried. Default value: **AvailabilityZone**. This value indicates Alibaba Cloud zones.
	ZoneType *string `json:"ZoneType,omitempty" xml:"ZoneType,omitempty"`
}

func (s DescribeZonesResponseBodyZonesZone) String() string {
	return tea.Prettify(s)
}

func (s DescribeZonesResponseBodyZonesZone) GoString() string {
	return s.String()
}

func (s *DescribeZonesResponseBodyZonesZone) SetLocalName(v string) *DescribeZonesResponseBodyZonesZone {
	s.LocalName = &v
	return s
}

func (s *DescribeZonesResponseBodyZonesZone) SetZoneId(v string) *DescribeZonesResponseBodyZonesZone {
	s.ZoneId = &v
	return s
}

func (s *DescribeZonesResponseBodyZonesZone) SetZoneType(v string) *DescribeZonesResponseBodyZonesZone {
	s.ZoneType = &v
	return s
}

type DescribeZonesResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeZonesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeZonesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeZonesResponse) GoString() string {
	return s.String()
}

func (s *DescribeZonesResponse) SetHeaders(v map[string]*string) *DescribeZonesResponse {
	s.Headers = v
	return s
}

func (s *DescribeZonesResponse) SetStatusCode(v int32) *DescribeZonesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeZonesResponse) SetBody(v *DescribeZonesResponseBody) *DescribeZonesResponse {
	s.Body = v
	return s
}

type DetachDhcpOptionsSetFromVpcRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, the system uses **RequestId** as **ClientToken**. **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the DHCP options set to be disassociated from a VPC.
	DhcpOptionsSetId *string `json:"DhcpOptionsSetId,omitempty" xml:"DhcpOptionsSetId,omitempty"`
	// Specifies whether to check the request without performing the operation. Valid values:
	//
	// **true**: checks the request without performing the operation. The system checks your AccessKey pair, the Resource Access Management (RAM) user permissions, and the required parameters. If the request fails to pass the check, the corresponding error message is returned. If the request passes the check, the `DryRunOperation` error code is returned.
	//
	// **false** (default): sends the request. If the request passes the check, a 2XX HTTP status code is returned and the operation is performed.
	DryRun       *bool   `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region to which the DHCP options set belongs. You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the VPC.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s DetachDhcpOptionsSetFromVpcRequest) String() string {
	return tea.Prettify(s)
}

func (s DetachDhcpOptionsSetFromVpcRequest) GoString() string {
	return s.String()
}

func (s *DetachDhcpOptionsSetFromVpcRequest) SetClientToken(v string) *DetachDhcpOptionsSetFromVpcRequest {
	s.ClientToken = &v
	return s
}

func (s *DetachDhcpOptionsSetFromVpcRequest) SetDhcpOptionsSetId(v string) *DetachDhcpOptionsSetFromVpcRequest {
	s.DhcpOptionsSetId = &v
	return s
}

func (s *DetachDhcpOptionsSetFromVpcRequest) SetDryRun(v bool) *DetachDhcpOptionsSetFromVpcRequest {
	s.DryRun = &v
	return s
}

func (s *DetachDhcpOptionsSetFromVpcRequest) SetOwnerAccount(v string) *DetachDhcpOptionsSetFromVpcRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DetachDhcpOptionsSetFromVpcRequest) SetOwnerId(v int64) *DetachDhcpOptionsSetFromVpcRequest {
	s.OwnerId = &v
	return s
}

func (s *DetachDhcpOptionsSetFromVpcRequest) SetRegionId(v string) *DetachDhcpOptionsSetFromVpcRequest {
	s.RegionId = &v
	return s
}

func (s *DetachDhcpOptionsSetFromVpcRequest) SetResourceOwnerAccount(v string) *DetachDhcpOptionsSetFromVpcRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DetachDhcpOptionsSetFromVpcRequest) SetResourceOwnerId(v int64) *DetachDhcpOptionsSetFromVpcRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DetachDhcpOptionsSetFromVpcRequest) SetVpcId(v string) *DetachDhcpOptionsSetFromVpcRequest {
	s.VpcId = &v
	return s
}

type DetachDhcpOptionsSetFromVpcResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DetachDhcpOptionsSetFromVpcResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DetachDhcpOptionsSetFromVpcResponseBody) GoString() string {
	return s.String()
}

func (s *DetachDhcpOptionsSetFromVpcResponseBody) SetRequestId(v string) *DetachDhcpOptionsSetFromVpcResponseBody {
	s.RequestId = &v
	return s
}

type DetachDhcpOptionsSetFromVpcResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DetachDhcpOptionsSetFromVpcResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DetachDhcpOptionsSetFromVpcResponse) String() string {
	return tea.Prettify(s)
}

func (s DetachDhcpOptionsSetFromVpcResponse) GoString() string {
	return s.String()
}

func (s *DetachDhcpOptionsSetFromVpcResponse) SetHeaders(v map[string]*string) *DetachDhcpOptionsSetFromVpcResponse {
	s.Headers = v
	return s
}

func (s *DetachDhcpOptionsSetFromVpcResponse) SetStatusCode(v int32) *DetachDhcpOptionsSetFromVpcResponse {
	s.StatusCode = &v
	return s
}

func (s *DetachDhcpOptionsSetFromVpcResponse) SetBody(v *DetachDhcpOptionsSetFromVpcResponseBody) *DetachDhcpOptionsSetFromVpcResponse {
	s.Body = v
	return s
}

type DiagnoseVpnGatewayRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. ClientToken can contain only ASCII characters.
	//
	// >  If you do not set this parameter, ClientToken is set to the value of RequestId. The ID of each request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The configuration when you check the connectivity of the IPsec-VPN connection. Valid values:
	//
	// *   **PrivateSourceIp**: the source IP address used when you check the connectivity of the IPsec-VPN connection. The source IP address must be on the VPC side.
	// *   **PrivateDestinationIp**: the destination IP address used when you check the connectivity of the IPsec-VPN connection. The destination IP address must be on the data center side.
	IPsecExtendInfo *string `json:"IPsecExtendInfo,omitempty" xml:"IPsecExtendInfo,omitempty"`
	// The region ID of the VPN gateway.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource to be diagnosed.
	ResourceId *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	// The type of the resource.
	//
	// Set the value to **Ipsec**, which specifies an IPsec-VPN connection.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The ID of the VPN gateway.
	VpnGatewayId *string `json:"VpnGatewayId,omitempty" xml:"VpnGatewayId,omitempty"`
}

func (s DiagnoseVpnGatewayRequest) String() string {
	return tea.Prettify(s)
}

func (s DiagnoseVpnGatewayRequest) GoString() string {
	return s.String()
}

func (s *DiagnoseVpnGatewayRequest) SetClientToken(v string) *DiagnoseVpnGatewayRequest {
	s.ClientToken = &v
	return s
}

func (s *DiagnoseVpnGatewayRequest) SetIPsecExtendInfo(v string) *DiagnoseVpnGatewayRequest {
	s.IPsecExtendInfo = &v
	return s
}

func (s *DiagnoseVpnGatewayRequest) SetRegionId(v string) *DiagnoseVpnGatewayRequest {
	s.RegionId = &v
	return s
}

func (s *DiagnoseVpnGatewayRequest) SetResourceId(v string) *DiagnoseVpnGatewayRequest {
	s.ResourceId = &v
	return s
}

func (s *DiagnoseVpnGatewayRequest) SetResourceType(v string) *DiagnoseVpnGatewayRequest {
	s.ResourceType = &v
	return s
}

func (s *DiagnoseVpnGatewayRequest) SetVpnGatewayId(v string) *DiagnoseVpnGatewayRequest {
	s.VpnGatewayId = &v
	return s
}

type DiagnoseVpnGatewayResponseBody struct {
	// The ID of the diagnostic operation.
	DiagnoseId *string `json:"DiagnoseId,omitempty" xml:"DiagnoseId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DiagnoseVpnGatewayResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DiagnoseVpnGatewayResponseBody) GoString() string {
	return s.String()
}

func (s *DiagnoseVpnGatewayResponseBody) SetDiagnoseId(v string) *DiagnoseVpnGatewayResponseBody {
	s.DiagnoseId = &v
	return s
}

func (s *DiagnoseVpnGatewayResponseBody) SetRequestId(v string) *DiagnoseVpnGatewayResponseBody {
	s.RequestId = &v
	return s
}

type DiagnoseVpnGatewayResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DiagnoseVpnGatewayResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DiagnoseVpnGatewayResponse) String() string {
	return tea.Prettify(s)
}

func (s DiagnoseVpnGatewayResponse) GoString() string {
	return s.String()
}

func (s *DiagnoseVpnGatewayResponse) SetHeaders(v map[string]*string) *DiagnoseVpnGatewayResponse {
	s.Headers = v
	return s
}

func (s *DiagnoseVpnGatewayResponse) SetStatusCode(v int32) *DiagnoseVpnGatewayResponse {
	s.StatusCode = &v
	return s
}

func (s *DiagnoseVpnGatewayResponse) SetBody(v *DiagnoseVpnGatewayResponseBody) *DiagnoseVpnGatewayResponse {
	s.Body = v
	return s
}

type DisableNatGatewayEcsMetricRequest struct {
	// Specifies whether to precheck this request only. Valid values:
	//
	// **true**: The validity of the request is checked but ECS traffic monitoring is not disabled. Check items include whether your AccessKey pair is valid, whether Resource Access Management (RAM) users are authorized, and whether the required parameters are set. If the request fails the precheck, the corresponding error code is returned. If the request passes the precheck, the `DryRunOperation` error code is returned.
	//
	// **false** (default): The validity of the request is checked. If the request passes the precheck, a 2XX HTTP status code is returned and ECS traffic monitoring is disabled.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The ID of the NAT gateway for which you want to disable Elastic Compute Service (ECS) traffic monitoring.
	NatGatewayId *string `json:"NatGatewayId,omitempty" xml:"NatGatewayId,omitempty"`
	// The ID of the region where the NAT gateway is deployed. You can call the [DescribeRegions](~~36063~~) operation to query region IDs.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DisableNatGatewayEcsMetricRequest) String() string {
	return tea.Prettify(s)
}

func (s DisableNatGatewayEcsMetricRequest) GoString() string {
	return s.String()
}

func (s *DisableNatGatewayEcsMetricRequest) SetDryRun(v bool) *DisableNatGatewayEcsMetricRequest {
	s.DryRun = &v
	return s
}

func (s *DisableNatGatewayEcsMetricRequest) SetNatGatewayId(v string) *DisableNatGatewayEcsMetricRequest {
	s.NatGatewayId = &v
	return s
}

func (s *DisableNatGatewayEcsMetricRequest) SetRegionId(v string) *DisableNatGatewayEcsMetricRequest {
	s.RegionId = &v
	return s
}

type DisableNatGatewayEcsMetricResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DisableNatGatewayEcsMetricResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DisableNatGatewayEcsMetricResponseBody) GoString() string {
	return s.String()
}

func (s *DisableNatGatewayEcsMetricResponseBody) SetRequestId(v string) *DisableNatGatewayEcsMetricResponseBody {
	s.RequestId = &v
	return s
}

type DisableNatGatewayEcsMetricResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DisableNatGatewayEcsMetricResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DisableNatGatewayEcsMetricResponse) String() string {
	return tea.Prettify(s)
}

func (s DisableNatGatewayEcsMetricResponse) GoString() string {
	return s.String()
}

func (s *DisableNatGatewayEcsMetricResponse) SetHeaders(v map[string]*string) *DisableNatGatewayEcsMetricResponse {
	s.Headers = v
	return s
}

func (s *DisableNatGatewayEcsMetricResponse) SetStatusCode(v int32) *DisableNatGatewayEcsMetricResponse {
	s.StatusCode = &v
	return s
}

func (s *DisableNatGatewayEcsMetricResponse) SetBody(v *DisableNatGatewayEcsMetricResponseBody) *DisableNatGatewayEcsMetricResponse {
	s.Body = v
	return s
}

type DisableVpcClassicLinkRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, the system automatically uses **RequestId** as **ClientToken**. **RequestId** may be different for each API request.
	ClientToken  *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the VPC for which you want to disable ClassicLink.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the VPC for which you want to disable ClassicLink.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s DisableVpcClassicLinkRequest) String() string {
	return tea.Prettify(s)
}

func (s DisableVpcClassicLinkRequest) GoString() string {
	return s.String()
}

func (s *DisableVpcClassicLinkRequest) SetClientToken(v string) *DisableVpcClassicLinkRequest {
	s.ClientToken = &v
	return s
}

func (s *DisableVpcClassicLinkRequest) SetOwnerAccount(v string) *DisableVpcClassicLinkRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DisableVpcClassicLinkRequest) SetOwnerId(v int64) *DisableVpcClassicLinkRequest {
	s.OwnerId = &v
	return s
}

func (s *DisableVpcClassicLinkRequest) SetRegionId(v string) *DisableVpcClassicLinkRequest {
	s.RegionId = &v
	return s
}

func (s *DisableVpcClassicLinkRequest) SetResourceOwnerAccount(v string) *DisableVpcClassicLinkRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DisableVpcClassicLinkRequest) SetResourceOwnerId(v int64) *DisableVpcClassicLinkRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DisableVpcClassicLinkRequest) SetVpcId(v string) *DisableVpcClassicLinkRequest {
	s.VpcId = &v
	return s
}

type DisableVpcClassicLinkResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DisableVpcClassicLinkResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DisableVpcClassicLinkResponseBody) GoString() string {
	return s.String()
}

func (s *DisableVpcClassicLinkResponseBody) SetRequestId(v string) *DisableVpcClassicLinkResponseBody {
	s.RequestId = &v
	return s
}

type DisableVpcClassicLinkResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DisableVpcClassicLinkResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DisableVpcClassicLinkResponse) String() string {
	return tea.Prettify(s)
}

func (s DisableVpcClassicLinkResponse) GoString() string {
	return s.String()
}

func (s *DisableVpcClassicLinkResponse) SetHeaders(v map[string]*string) *DisableVpcClassicLinkResponse {
	s.Headers = v
	return s
}

func (s *DisableVpcClassicLinkResponse) SetStatusCode(v int32) *DisableVpcClassicLinkResponse {
	s.StatusCode = &v
	return s
}

func (s *DisableVpcClassicLinkResponse) SetBody(v *DisableVpcClassicLinkResponseBody) *DisableVpcClassicLinkResponse {
	s.Body = v
	return s
}

type DissociateRouteTableFromGatewayRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	//
	// >  If you do not set this parameter, the system automatically uses **RequestId** as **ClientToken**. **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to only precheck the request. Valid values:
	//
	// *   **true**: prechecks the request without performing the operation. The system prechecks the required parameters, request syntax, and limits. If the request fails to pass the precheck, an error message is returned. If the request passes the precheck, the `DryRunOperation` error code is returned.
	// *   **false** (default): sends the request. After the request passes the precheck, a 2xx HTTP status code is returned and the operation is performed.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The ID of the IPv4 gateway.
	GatewayId    *string `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the IPv4 gateway from which you want to disassociate the gateway route table.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the gateway route table.
	RouteTableId *string `json:"RouteTableId,omitempty" xml:"RouteTableId,omitempty"`
}

func (s DissociateRouteTableFromGatewayRequest) String() string {
	return tea.Prettify(s)
}

func (s DissociateRouteTableFromGatewayRequest) GoString() string {
	return s.String()
}

func (s *DissociateRouteTableFromGatewayRequest) SetClientToken(v string) *DissociateRouteTableFromGatewayRequest {
	s.ClientToken = &v
	return s
}

func (s *DissociateRouteTableFromGatewayRequest) SetDryRun(v bool) *DissociateRouteTableFromGatewayRequest {
	s.DryRun = &v
	return s
}

func (s *DissociateRouteTableFromGatewayRequest) SetGatewayId(v string) *DissociateRouteTableFromGatewayRequest {
	s.GatewayId = &v
	return s
}

func (s *DissociateRouteTableFromGatewayRequest) SetOwnerAccount(v string) *DissociateRouteTableFromGatewayRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DissociateRouteTableFromGatewayRequest) SetOwnerId(v int64) *DissociateRouteTableFromGatewayRequest {
	s.OwnerId = &v
	return s
}

func (s *DissociateRouteTableFromGatewayRequest) SetRegionId(v string) *DissociateRouteTableFromGatewayRequest {
	s.RegionId = &v
	return s
}

func (s *DissociateRouteTableFromGatewayRequest) SetResourceOwnerAccount(v string) *DissociateRouteTableFromGatewayRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DissociateRouteTableFromGatewayRequest) SetResourceOwnerId(v int64) *DissociateRouteTableFromGatewayRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DissociateRouteTableFromGatewayRequest) SetRouteTableId(v string) *DissociateRouteTableFromGatewayRequest {
	s.RouteTableId = &v
	return s
}

type DissociateRouteTableFromGatewayResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DissociateRouteTableFromGatewayResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DissociateRouteTableFromGatewayResponseBody) GoString() string {
	return s.String()
}

func (s *DissociateRouteTableFromGatewayResponseBody) SetRequestId(v string) *DissociateRouteTableFromGatewayResponseBody {
	s.RequestId = &v
	return s
}

type DissociateRouteTableFromGatewayResponse struct {
	Headers    map[string]*string                           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DissociateRouteTableFromGatewayResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DissociateRouteTableFromGatewayResponse) String() string {
	return tea.Prettify(s)
}

func (s DissociateRouteTableFromGatewayResponse) GoString() string {
	return s.String()
}

func (s *DissociateRouteTableFromGatewayResponse) SetHeaders(v map[string]*string) *DissociateRouteTableFromGatewayResponse {
	s.Headers = v
	return s
}

func (s *DissociateRouteTableFromGatewayResponse) SetStatusCode(v int32) *DissociateRouteTableFromGatewayResponse {
	s.StatusCode = &v
	return s
}

func (s *DissociateRouteTableFromGatewayResponse) SetBody(v *DissociateRouteTableFromGatewayResponseBody) *DissociateRouteTableFromGatewayResponse {
	s.Body = v
	return s
}

type DissociateRouteTablesFromVpcGatewayEndpointRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that it is unique among different requests. **ClientToken** can contain only ASCII characters and cannot exceed 64 characters in length.
	//
	// >  If you do not set this parameter, the system automatically uses **RequestId** as **ClientToken**. **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to precheck this request. Valid values:
	//
	// *   **true**: prechecks the request. The gateway endpoint is not disassociated from the route table. The system checks whether your AccessKey pair is valid, whether the Resource Access Management (RAM) user is authorized, and whether required parameters are set. If the request fails the precheck, the corresponding error message is returned. If the request passes the precheck, the `DryRunOperation` error code is returned.
	// *   **false**: sends the API request. After the request passes the check, a 2XX HTTP status code is returned and the gateway endpoint is disassociated from the route table. This is the default value.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The ID of the gateway endpoint to be disassociated from the route table.
	EndpointId   *string `json:"EndpointId,omitempty" xml:"EndpointId,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the gateway endpoint.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string   `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string   `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64    `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	RouteTableIds        []*string `json:"RouteTableIds,omitempty" xml:"RouteTableIds,omitempty" type:"Repeated"`
}

func (s DissociateRouteTablesFromVpcGatewayEndpointRequest) String() string {
	return tea.Prettify(s)
}

func (s DissociateRouteTablesFromVpcGatewayEndpointRequest) GoString() string {
	return s.String()
}

func (s *DissociateRouteTablesFromVpcGatewayEndpointRequest) SetClientToken(v string) *DissociateRouteTablesFromVpcGatewayEndpointRequest {
	s.ClientToken = &v
	return s
}

func (s *DissociateRouteTablesFromVpcGatewayEndpointRequest) SetDryRun(v bool) *DissociateRouteTablesFromVpcGatewayEndpointRequest {
	s.DryRun = &v
	return s
}

func (s *DissociateRouteTablesFromVpcGatewayEndpointRequest) SetEndpointId(v string) *DissociateRouteTablesFromVpcGatewayEndpointRequest {
	s.EndpointId = &v
	return s
}

func (s *DissociateRouteTablesFromVpcGatewayEndpointRequest) SetOwnerAccount(v string) *DissociateRouteTablesFromVpcGatewayEndpointRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DissociateRouteTablesFromVpcGatewayEndpointRequest) SetOwnerId(v int64) *DissociateRouteTablesFromVpcGatewayEndpointRequest {
	s.OwnerId = &v
	return s
}

func (s *DissociateRouteTablesFromVpcGatewayEndpointRequest) SetRegionId(v string) *DissociateRouteTablesFromVpcGatewayEndpointRequest {
	s.RegionId = &v
	return s
}

func (s *DissociateRouteTablesFromVpcGatewayEndpointRequest) SetResourceOwnerAccount(v string) *DissociateRouteTablesFromVpcGatewayEndpointRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DissociateRouteTablesFromVpcGatewayEndpointRequest) SetResourceOwnerId(v int64) *DissociateRouteTablesFromVpcGatewayEndpointRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DissociateRouteTablesFromVpcGatewayEndpointRequest) SetRouteTableIds(v []*string) *DissociateRouteTablesFromVpcGatewayEndpointRequest {
	s.RouteTableIds = v
	return s
}

type DissociateRouteTablesFromVpcGatewayEndpointResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DissociateRouteTablesFromVpcGatewayEndpointResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DissociateRouteTablesFromVpcGatewayEndpointResponseBody) GoString() string {
	return s.String()
}

func (s *DissociateRouteTablesFromVpcGatewayEndpointResponseBody) SetRequestId(v string) *DissociateRouteTablesFromVpcGatewayEndpointResponseBody {
	s.RequestId = &v
	return s
}

type DissociateRouteTablesFromVpcGatewayEndpointResponse struct {
	Headers    map[string]*string                                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DissociateRouteTablesFromVpcGatewayEndpointResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DissociateRouteTablesFromVpcGatewayEndpointResponse) String() string {
	return tea.Prettify(s)
}

func (s DissociateRouteTablesFromVpcGatewayEndpointResponse) GoString() string {
	return s.String()
}

func (s *DissociateRouteTablesFromVpcGatewayEndpointResponse) SetHeaders(v map[string]*string) *DissociateRouteTablesFromVpcGatewayEndpointResponse {
	s.Headers = v
	return s
}

func (s *DissociateRouteTablesFromVpcGatewayEndpointResponse) SetStatusCode(v int32) *DissociateRouteTablesFromVpcGatewayEndpointResponse {
	s.StatusCode = &v
	return s
}

func (s *DissociateRouteTablesFromVpcGatewayEndpointResponse) SetBody(v *DissociateRouteTablesFromVpcGatewayEndpointResponseBody) *DissociateRouteTablesFromVpcGatewayEndpointResponse {
	s.Body = v
	return s
}

type DissociateVpnGatewayWithCertificateRequest struct {
	// The certificate ID.
	//
	// > The certificate ID is generated after the SSL certificate is associated with the VPN gateway. It is not the ID of the SSL certificate. You can call [ListVpnCertificateAssociations](~~203359~~) to query certificate IDs.
	CertificateId *string `json:"CertificateId,omitempty" xml:"CertificateId,omitempty"`
	// The certificate type. Valid values:
	//
	// *   **Encryption**
	// *   **Signature**
	CertificateType *string `json:"CertificateType,omitempty" xml:"CertificateType,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among different requests. The client token can contain only ASCII characters.
	//
	// > If you do not specify this parameter, the system automatically uses the **request ID** as the **client token**. The **request ID** may be different for each request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to perform a dry run, without performing the actual request. Valid values:
	//
	// *   **true**: performs a dry run. The system checks the request for potential issues, including missing parameter values, incorrect request syntax, and service limits. If the request passes the dry run, the `DryRunOperation` error code is returned. Otherwise, an error message is returned.
	// *   **false** (default): performs a dry run and performs the actual request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The region ID of the VPN gateway.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the VPN gateway.
	VpnGatewayId *string `json:"VpnGatewayId,omitempty" xml:"VpnGatewayId,omitempty"`
}

func (s DissociateVpnGatewayWithCertificateRequest) String() string {
	return tea.Prettify(s)
}

func (s DissociateVpnGatewayWithCertificateRequest) GoString() string {
	return s.String()
}

func (s *DissociateVpnGatewayWithCertificateRequest) SetCertificateId(v string) *DissociateVpnGatewayWithCertificateRequest {
	s.CertificateId = &v
	return s
}

func (s *DissociateVpnGatewayWithCertificateRequest) SetCertificateType(v string) *DissociateVpnGatewayWithCertificateRequest {
	s.CertificateType = &v
	return s
}

func (s *DissociateVpnGatewayWithCertificateRequest) SetClientToken(v string) *DissociateVpnGatewayWithCertificateRequest {
	s.ClientToken = &v
	return s
}

func (s *DissociateVpnGatewayWithCertificateRequest) SetDryRun(v bool) *DissociateVpnGatewayWithCertificateRequest {
	s.DryRun = &v
	return s
}

func (s *DissociateVpnGatewayWithCertificateRequest) SetRegionId(v string) *DissociateVpnGatewayWithCertificateRequest {
	s.RegionId = &v
	return s
}

func (s *DissociateVpnGatewayWithCertificateRequest) SetVpnGatewayId(v string) *DissociateVpnGatewayWithCertificateRequest {
	s.VpnGatewayId = &v
	return s
}

type DissociateVpnGatewayWithCertificateResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DissociateVpnGatewayWithCertificateResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DissociateVpnGatewayWithCertificateResponseBody) GoString() string {
	return s.String()
}

func (s *DissociateVpnGatewayWithCertificateResponseBody) SetRequestId(v string) *DissociateVpnGatewayWithCertificateResponseBody {
	s.RequestId = &v
	return s
}

type DissociateVpnGatewayWithCertificateResponse struct {
	Headers    map[string]*string                               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DissociateVpnGatewayWithCertificateResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DissociateVpnGatewayWithCertificateResponse) String() string {
	return tea.Prettify(s)
}

func (s DissociateVpnGatewayWithCertificateResponse) GoString() string {
	return s.String()
}

func (s *DissociateVpnGatewayWithCertificateResponse) SetHeaders(v map[string]*string) *DissociateVpnGatewayWithCertificateResponse {
	s.Headers = v
	return s
}

func (s *DissociateVpnGatewayWithCertificateResponse) SetStatusCode(v int32) *DissociateVpnGatewayWithCertificateResponse {
	s.StatusCode = &v
	return s
}

func (s *DissociateVpnGatewayWithCertificateResponse) SetBody(v *DissociateVpnGatewayWithCertificateResponseBody) *DissociateVpnGatewayWithCertificateResponse {
	s.Body = v
	return s
}

type DownloadVpnConnectionConfigRequest struct {
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region where you want to create the IPsec-VPN connection.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the IPsec-VPN connection.
	VpnConnectionId *string `json:"VpnConnectionId,omitempty" xml:"VpnConnectionId,omitempty"`
}

func (s DownloadVpnConnectionConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s DownloadVpnConnectionConfigRequest) GoString() string {
	return s.String()
}

func (s *DownloadVpnConnectionConfigRequest) SetOwnerAccount(v string) *DownloadVpnConnectionConfigRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DownloadVpnConnectionConfigRequest) SetOwnerId(v int64) *DownloadVpnConnectionConfigRequest {
	s.OwnerId = &v
	return s
}

func (s *DownloadVpnConnectionConfigRequest) SetRegionId(v string) *DownloadVpnConnectionConfigRequest {
	s.RegionId = &v
	return s
}

func (s *DownloadVpnConnectionConfigRequest) SetResourceOwnerAccount(v string) *DownloadVpnConnectionConfigRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DownloadVpnConnectionConfigRequest) SetResourceOwnerId(v int64) *DownloadVpnConnectionConfigRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DownloadVpnConnectionConfigRequest) SetVpnConnectionId(v string) *DownloadVpnConnectionConfigRequest {
	s.VpnConnectionId = &v
	return s
}

type DownloadVpnConnectionConfigResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The configuration of the IPsec-VPN connection.
	VpnConnectionConfig *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfig `json:"VpnConnectionConfig,omitempty" xml:"VpnConnectionConfig,omitempty" type:"Struct"`
}

func (s DownloadVpnConnectionConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DownloadVpnConnectionConfigResponseBody) GoString() string {
	return s.String()
}

func (s *DownloadVpnConnectionConfigResponseBody) SetRequestId(v string) *DownloadVpnConnectionConfigResponseBody {
	s.RequestId = &v
	return s
}

func (s *DownloadVpnConnectionConfigResponseBody) SetVpnConnectionConfig(v *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfig) *DownloadVpnConnectionConfigResponseBody {
	s.VpnConnectionConfig = v
	return s
}

type DownloadVpnConnectionConfigResponseBodyVpnConnectionConfig struct {
	// The IKE configuration.
	IkeConfig *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigIkeConfig `json:"IkeConfig,omitempty" xml:"IkeConfig,omitempty" type:"Struct"`
	// The configuration of the IPsec-VPN connection.
	IpsecConfig *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigIpsecConfig `json:"IpsecConfig,omitempty" xml:"IpsecConfig,omitempty" type:"Struct"`
	// The identifier of the VPN gateway.
	Local *string `json:"Local,omitempty" xml:"Local,omitempty"`
	// The CIDR block on the virtual private cloud (VPC) side.
	LocalSubnet *string `json:"LocalSubnet,omitempty" xml:"LocalSubnet,omitempty"`
	// The identifier of the customer gateway.
	Remote *string `json:"Remote,omitempty" xml:"Remote,omitempty"`
	// The CIDR block on the data center side.
	RemoteSubnet  *string                                                                  `json:"RemoteSubnet,omitempty" xml:"RemoteSubnet,omitempty"`
	TunnelsConfig *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfig `json:"TunnelsConfig,omitempty" xml:"TunnelsConfig,omitempty" type:"Struct"`
}

func (s DownloadVpnConnectionConfigResponseBodyVpnConnectionConfig) String() string {
	return tea.Prettify(s)
}

func (s DownloadVpnConnectionConfigResponseBodyVpnConnectionConfig) GoString() string {
	return s.String()
}

func (s *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfig) SetIkeConfig(v *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigIkeConfig) *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfig {
	s.IkeConfig = v
	return s
}

func (s *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfig) SetIpsecConfig(v *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigIpsecConfig) *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfig {
	s.IpsecConfig = v
	return s
}

func (s *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfig) SetLocal(v string) *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfig {
	s.Local = &v
	return s
}

func (s *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfig) SetLocalSubnet(v string) *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfig {
	s.LocalSubnet = &v
	return s
}

func (s *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfig) SetRemote(v string) *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfig {
	s.Remote = &v
	return s
}

func (s *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfig) SetRemoteSubnet(v string) *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfig {
	s.RemoteSubnet = &v
	return s
}

func (s *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfig) SetTunnelsConfig(v *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfig) *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfig {
	s.TunnelsConfig = v
	return s
}

type DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigIkeConfig struct {
	// The IKE authentication algorithm. Valid values: **sha1** and **MD5**.
	IkeAuthAlg *string `json:"IkeAuthAlg,omitempty" xml:"IkeAuthAlg,omitempty"`
	// The IKE encryption algorithm.
	IkeEncAlg *string `json:"IkeEncAlg,omitempty" xml:"IkeEncAlg,omitempty"`
	// The IKE lifetime. Unit: seconds.
	IkeLifetime *int64 `json:"IkeLifetime,omitempty" xml:"IkeLifetime,omitempty"`
	// The IKE mode. Valid values: **main** and **aggressive**. The **main** mode offers higher security. If NAT traversal is enabled, we recommend that you use the **aggressive** mode.
	IkeMode *string `json:"IkeMode,omitempty" xml:"IkeMode,omitempty"`
	// The DH group.
	IkePfs *string `json:"IkePfs,omitempty" xml:"IkePfs,omitempty"`
	// The IKE version.
	IkeVersion *string `json:"IkeVersion,omitempty" xml:"IkeVersion,omitempty"`
	// The local ID. The default value is the IP address of the VPN gateway. You can specify the value as an IP address or in the FQDN format.
	LocalId *string `json:"LocalId,omitempty" xml:"LocalId,omitempty"`
	// The pre-shared key.
	Psk *string `json:"Psk,omitempty" xml:"Psk,omitempty"`
	// The peer ID. The default value is the IP address of the customer gateway. You can specify the value as an IP address or in the fully qualified domain name (FQDN) format.
	RemoteId *string `json:"RemoteId,omitempty" xml:"RemoteId,omitempty"`
}

func (s DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigIkeConfig) String() string {
	return tea.Prettify(s)
}

func (s DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigIkeConfig) GoString() string {
	return s.String()
}

func (s *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigIkeConfig) SetIkeAuthAlg(v string) *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigIkeConfig {
	s.IkeAuthAlg = &v
	return s
}

func (s *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigIkeConfig) SetIkeEncAlg(v string) *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigIkeConfig {
	s.IkeEncAlg = &v
	return s
}

func (s *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigIkeConfig) SetIkeLifetime(v int64) *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigIkeConfig {
	s.IkeLifetime = &v
	return s
}

func (s *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigIkeConfig) SetIkeMode(v string) *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigIkeConfig {
	s.IkeMode = &v
	return s
}

func (s *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigIkeConfig) SetIkePfs(v string) *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigIkeConfig {
	s.IkePfs = &v
	return s
}

func (s *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigIkeConfig) SetIkeVersion(v string) *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigIkeConfig {
	s.IkeVersion = &v
	return s
}

func (s *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigIkeConfig) SetLocalId(v string) *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigIkeConfig {
	s.LocalId = &v
	return s
}

func (s *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigIkeConfig) SetPsk(v string) *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigIkeConfig {
	s.Psk = &v
	return s
}

func (s *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigIkeConfig) SetRemoteId(v string) *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigIkeConfig {
	s.RemoteId = &v
	return s
}

type DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigIpsecConfig struct {
	// The IPsec authentication algorithm. Valid values: **sha1** and **md5**.
	IpsecAuthAlg *string `json:"IpsecAuthAlg,omitempty" xml:"IpsecAuthAlg,omitempty"`
	// The IPsec encryption algorithm.
	IpsecEncAlg *string `json:"IpsecEncAlg,omitempty" xml:"IpsecEncAlg,omitempty"`
	// The IPsec lifetime. Unit: seconds.
	IpsecLifetime *int64 `json:"IpsecLifetime,omitempty" xml:"IpsecLifetime,omitempty"`
	// The DH group.
	IpsecPfs *string `json:"IpsecPfs,omitempty" xml:"IpsecPfs,omitempty"`
}

func (s DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigIpsecConfig) String() string {
	return tea.Prettify(s)
}

func (s DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigIpsecConfig) GoString() string {
	return s.String()
}

func (s *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigIpsecConfig) SetIpsecAuthAlg(v string) *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigIpsecConfig {
	s.IpsecAuthAlg = &v
	return s
}

func (s *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigIpsecConfig) SetIpsecEncAlg(v string) *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigIpsecConfig {
	s.IpsecEncAlg = &v
	return s
}

func (s *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigIpsecConfig) SetIpsecLifetime(v int64) *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigIpsecConfig {
	s.IpsecLifetime = &v
	return s
}

func (s *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigIpsecConfig) SetIpsecPfs(v string) *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigIpsecConfig {
	s.IpsecPfs = &v
	return s
}

type DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfig struct {
	TunnelConfig []*DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfigTunnelConfig `json:"TunnelConfig,omitempty" xml:"TunnelConfig,omitempty" type:"Repeated"`
}

func (s DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfig) String() string {
	return tea.Prettify(s)
}

func (s DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfig) GoString() string {
	return s.String()
}

func (s *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfig) SetTunnelConfig(v []*DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfigTunnelConfig) *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfig {
	s.TunnelConfig = v
	return s
}

type DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfigTunnelConfig struct {
	IkeConfig   *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfigTunnelConfigIkeConfig   `json:"IkeConfig,omitempty" xml:"IkeConfig,omitempty" type:"Struct"`
	IpsecConfig *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfigTunnelConfigIpsecConfig `json:"IpsecConfig,omitempty" xml:"IpsecConfig,omitempty" type:"Struct"`
	Local       *string                                                                                         `json:"Local,omitempty" xml:"Local,omitempty"`
	Remote      *string                                                                                         `json:"Remote,omitempty" xml:"Remote,omitempty"`
	TunnelId    *string                                                                                         `json:"TunnelId,omitempty" xml:"TunnelId,omitempty"`
}

func (s DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfigTunnelConfig) String() string {
	return tea.Prettify(s)
}

func (s DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfigTunnelConfig) GoString() string {
	return s.String()
}

func (s *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfigTunnelConfig) SetIkeConfig(v *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfigTunnelConfigIkeConfig) *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfigTunnelConfig {
	s.IkeConfig = v
	return s
}

func (s *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfigTunnelConfig) SetIpsecConfig(v *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfigTunnelConfigIpsecConfig) *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfigTunnelConfig {
	s.IpsecConfig = v
	return s
}

func (s *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfigTunnelConfig) SetLocal(v string) *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfigTunnelConfig {
	s.Local = &v
	return s
}

func (s *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfigTunnelConfig) SetRemote(v string) *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfigTunnelConfig {
	s.Remote = &v
	return s
}

func (s *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfigTunnelConfig) SetTunnelId(v string) *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfigTunnelConfig {
	s.TunnelId = &v
	return s
}

type DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfigTunnelConfigIkeConfig struct {
	IkeAuthAlg  *string `json:"IkeAuthAlg,omitempty" xml:"IkeAuthAlg,omitempty"`
	IkeEncAlg   *string `json:"IkeEncAlg,omitempty" xml:"IkeEncAlg,omitempty"`
	IkeLifetime *int64  `json:"IkeLifetime,omitempty" xml:"IkeLifetime,omitempty"`
	IkeMode     *string `json:"IkeMode,omitempty" xml:"IkeMode,omitempty"`
	IkePfs      *string `json:"IkePfs,omitempty" xml:"IkePfs,omitempty"`
	IkeVersion  *string `json:"IkeVersion,omitempty" xml:"IkeVersion,omitempty"`
	LocalId     *string `json:"LocalId,omitempty" xml:"LocalId,omitempty"`
	Psk         *string `json:"Psk,omitempty" xml:"Psk,omitempty"`
	RemoteId    *string `json:"RemoteId,omitempty" xml:"RemoteId,omitempty"`
}

func (s DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfigTunnelConfigIkeConfig) String() string {
	return tea.Prettify(s)
}

func (s DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfigTunnelConfigIkeConfig) GoString() string {
	return s.String()
}

func (s *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfigTunnelConfigIkeConfig) SetIkeAuthAlg(v string) *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfigTunnelConfigIkeConfig {
	s.IkeAuthAlg = &v
	return s
}

func (s *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfigTunnelConfigIkeConfig) SetIkeEncAlg(v string) *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfigTunnelConfigIkeConfig {
	s.IkeEncAlg = &v
	return s
}

func (s *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfigTunnelConfigIkeConfig) SetIkeLifetime(v int64) *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfigTunnelConfigIkeConfig {
	s.IkeLifetime = &v
	return s
}

func (s *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfigTunnelConfigIkeConfig) SetIkeMode(v string) *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfigTunnelConfigIkeConfig {
	s.IkeMode = &v
	return s
}

func (s *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfigTunnelConfigIkeConfig) SetIkePfs(v string) *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfigTunnelConfigIkeConfig {
	s.IkePfs = &v
	return s
}

func (s *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfigTunnelConfigIkeConfig) SetIkeVersion(v string) *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfigTunnelConfigIkeConfig {
	s.IkeVersion = &v
	return s
}

func (s *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfigTunnelConfigIkeConfig) SetLocalId(v string) *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfigTunnelConfigIkeConfig {
	s.LocalId = &v
	return s
}

func (s *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfigTunnelConfigIkeConfig) SetPsk(v string) *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfigTunnelConfigIkeConfig {
	s.Psk = &v
	return s
}

func (s *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfigTunnelConfigIkeConfig) SetRemoteId(v string) *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfigTunnelConfigIkeConfig {
	s.RemoteId = &v
	return s
}

type DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfigTunnelConfigIpsecConfig struct {
	IpsecAuthAlg  *string `json:"IpsecAuthAlg,omitempty" xml:"IpsecAuthAlg,omitempty"`
	IpsecEncAlg   *string `json:"IpsecEncAlg,omitempty" xml:"IpsecEncAlg,omitempty"`
	IpsecLifetime *int64  `json:"IpsecLifetime,omitempty" xml:"IpsecLifetime,omitempty"`
	IpsecPfs      *string `json:"IpsecPfs,omitempty" xml:"IpsecPfs,omitempty"`
}

func (s DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfigTunnelConfigIpsecConfig) String() string {
	return tea.Prettify(s)
}

func (s DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfigTunnelConfigIpsecConfig) GoString() string {
	return s.String()
}

func (s *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfigTunnelConfigIpsecConfig) SetIpsecAuthAlg(v string) *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfigTunnelConfigIpsecConfig {
	s.IpsecAuthAlg = &v
	return s
}

func (s *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfigTunnelConfigIpsecConfig) SetIpsecEncAlg(v string) *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfigTunnelConfigIpsecConfig {
	s.IpsecEncAlg = &v
	return s
}

func (s *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfigTunnelConfigIpsecConfig) SetIpsecLifetime(v int64) *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfigTunnelConfigIpsecConfig {
	s.IpsecLifetime = &v
	return s
}

func (s *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfigTunnelConfigIpsecConfig) SetIpsecPfs(v string) *DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfigTunnelConfigIpsecConfig {
	s.IpsecPfs = &v
	return s
}

type DownloadVpnConnectionConfigResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DownloadVpnConnectionConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DownloadVpnConnectionConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s DownloadVpnConnectionConfigResponse) GoString() string {
	return s.String()
}

func (s *DownloadVpnConnectionConfigResponse) SetHeaders(v map[string]*string) *DownloadVpnConnectionConfigResponse {
	s.Headers = v
	return s
}

func (s *DownloadVpnConnectionConfigResponse) SetStatusCode(v int32) *DownloadVpnConnectionConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *DownloadVpnConnectionConfigResponse) SetBody(v *DownloadVpnConnectionConfigResponseBody) *DownloadVpnConnectionConfigResponse {
	s.Body = v
	return s
}

type EnableNatGatewayEcsMetricRequest struct {
	// Specifies whether to precheck only this request. Valid values:
	//
	// **true**: The validity of the request is checked but the traffic monitoring feature is not enabled. The system checks whether your AccessKey pair is valid, whether the Resource Access Management (RAM) user is authorized, and whether the required parameters are specified. If the request fails the precheck, the corresponding error code is returned. If the request passes the precheck, the `DryRunOperation` error code is returned.
	//
	// **false** (default): The validity of the request is checked. If the request passes the precheck, a 2XX HTTP status code is returned and the traffic monitoring feature is enabled.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The ID of the NAT gateway for which you want to enable the traffic monitoring feature.
	NatGatewayId *string `json:"NatGatewayId,omitempty" xml:"NatGatewayId,omitempty"`
	// The ID of the region where the NAT gateway is deployed. You can call the [DescribeRegions](~~36063~~) operation to query region IDs.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s EnableNatGatewayEcsMetricRequest) String() string {
	return tea.Prettify(s)
}

func (s EnableNatGatewayEcsMetricRequest) GoString() string {
	return s.String()
}

func (s *EnableNatGatewayEcsMetricRequest) SetDryRun(v bool) *EnableNatGatewayEcsMetricRequest {
	s.DryRun = &v
	return s
}

func (s *EnableNatGatewayEcsMetricRequest) SetNatGatewayId(v string) *EnableNatGatewayEcsMetricRequest {
	s.NatGatewayId = &v
	return s
}

func (s *EnableNatGatewayEcsMetricRequest) SetRegionId(v string) *EnableNatGatewayEcsMetricRequest {
	s.RegionId = &v
	return s
}

type EnableNatGatewayEcsMetricResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s EnableNatGatewayEcsMetricResponseBody) String() string {
	return tea.Prettify(s)
}

func (s EnableNatGatewayEcsMetricResponseBody) GoString() string {
	return s.String()
}

func (s *EnableNatGatewayEcsMetricResponseBody) SetRequestId(v string) *EnableNatGatewayEcsMetricResponseBody {
	s.RequestId = &v
	return s
}

type EnableNatGatewayEcsMetricResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *EnableNatGatewayEcsMetricResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s EnableNatGatewayEcsMetricResponse) String() string {
	return tea.Prettify(s)
}

func (s EnableNatGatewayEcsMetricResponse) GoString() string {
	return s.String()
}

func (s *EnableNatGatewayEcsMetricResponse) SetHeaders(v map[string]*string) *EnableNatGatewayEcsMetricResponse {
	s.Headers = v
	return s
}

func (s *EnableNatGatewayEcsMetricResponse) SetStatusCode(v int32) *EnableNatGatewayEcsMetricResponse {
	s.StatusCode = &v
	return s
}

func (s *EnableNatGatewayEcsMetricResponse) SetBody(v *EnableNatGatewayEcsMetricResponseBody) *EnableNatGatewayEcsMetricResponse {
	s.Body = v
	return s
}

type EnablePhysicalConnectionRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken  *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the Express Connect circuit.
	PhysicalConnectionId *string `json:"PhysicalConnectionId,omitempty" xml:"PhysicalConnectionId,omitempty"`
	// The region ID of the Express Connect circuit.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s EnablePhysicalConnectionRequest) String() string {
	return tea.Prettify(s)
}

func (s EnablePhysicalConnectionRequest) GoString() string {
	return s.String()
}

func (s *EnablePhysicalConnectionRequest) SetClientToken(v string) *EnablePhysicalConnectionRequest {
	s.ClientToken = &v
	return s
}

func (s *EnablePhysicalConnectionRequest) SetOwnerAccount(v string) *EnablePhysicalConnectionRequest {
	s.OwnerAccount = &v
	return s
}

func (s *EnablePhysicalConnectionRequest) SetOwnerId(v int64) *EnablePhysicalConnectionRequest {
	s.OwnerId = &v
	return s
}

func (s *EnablePhysicalConnectionRequest) SetPhysicalConnectionId(v string) *EnablePhysicalConnectionRequest {
	s.PhysicalConnectionId = &v
	return s
}

func (s *EnablePhysicalConnectionRequest) SetRegionId(v string) *EnablePhysicalConnectionRequest {
	s.RegionId = &v
	return s
}

func (s *EnablePhysicalConnectionRequest) SetResourceOwnerAccount(v string) *EnablePhysicalConnectionRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *EnablePhysicalConnectionRequest) SetResourceOwnerId(v int64) *EnablePhysicalConnectionRequest {
	s.ResourceOwnerId = &v
	return s
}

type EnablePhysicalConnectionResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s EnablePhysicalConnectionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s EnablePhysicalConnectionResponseBody) GoString() string {
	return s.String()
}

func (s *EnablePhysicalConnectionResponseBody) SetRequestId(v string) *EnablePhysicalConnectionResponseBody {
	s.RequestId = &v
	return s
}

type EnablePhysicalConnectionResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *EnablePhysicalConnectionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s EnablePhysicalConnectionResponse) String() string {
	return tea.Prettify(s)
}

func (s EnablePhysicalConnectionResponse) GoString() string {
	return s.String()
}

func (s *EnablePhysicalConnectionResponse) SetHeaders(v map[string]*string) *EnablePhysicalConnectionResponse {
	s.Headers = v
	return s
}

func (s *EnablePhysicalConnectionResponse) SetStatusCode(v int32) *EnablePhysicalConnectionResponse {
	s.StatusCode = &v
	return s
}

func (s *EnablePhysicalConnectionResponse) SetBody(v *EnablePhysicalConnectionResponseBody) *EnablePhysicalConnectionResponse {
	s.Body = v
	return s
}

type EnableVpcClassicLinkRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The client token can contain only ASCII characters.
	//
	// >  If you do not specify this parameter, the system automatically uses the value of **RequestId** as the value of **ClientToken**. **RequestId** may be different for each API request.
	ClientToken  *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the VPC for which you want to enable ClassicLink.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the VPC.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s EnableVpcClassicLinkRequest) String() string {
	return tea.Prettify(s)
}

func (s EnableVpcClassicLinkRequest) GoString() string {
	return s.String()
}

func (s *EnableVpcClassicLinkRequest) SetClientToken(v string) *EnableVpcClassicLinkRequest {
	s.ClientToken = &v
	return s
}

func (s *EnableVpcClassicLinkRequest) SetOwnerAccount(v string) *EnableVpcClassicLinkRequest {
	s.OwnerAccount = &v
	return s
}

func (s *EnableVpcClassicLinkRequest) SetOwnerId(v int64) *EnableVpcClassicLinkRequest {
	s.OwnerId = &v
	return s
}

func (s *EnableVpcClassicLinkRequest) SetRegionId(v string) *EnableVpcClassicLinkRequest {
	s.RegionId = &v
	return s
}

func (s *EnableVpcClassicLinkRequest) SetResourceOwnerAccount(v string) *EnableVpcClassicLinkRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *EnableVpcClassicLinkRequest) SetResourceOwnerId(v int64) *EnableVpcClassicLinkRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *EnableVpcClassicLinkRequest) SetVpcId(v string) *EnableVpcClassicLinkRequest {
	s.VpcId = &v
	return s
}

type EnableVpcClassicLinkResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s EnableVpcClassicLinkResponseBody) String() string {
	return tea.Prettify(s)
}

func (s EnableVpcClassicLinkResponseBody) GoString() string {
	return s.String()
}

func (s *EnableVpcClassicLinkResponseBody) SetRequestId(v string) *EnableVpcClassicLinkResponseBody {
	s.RequestId = &v
	return s
}

type EnableVpcClassicLinkResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *EnableVpcClassicLinkResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s EnableVpcClassicLinkResponse) String() string {
	return tea.Prettify(s)
}

func (s EnableVpcClassicLinkResponse) GoString() string {
	return s.String()
}

func (s *EnableVpcClassicLinkResponse) SetHeaders(v map[string]*string) *EnableVpcClassicLinkResponse {
	s.Headers = v
	return s
}

func (s *EnableVpcClassicLinkResponse) SetStatusCode(v int32) *EnableVpcClassicLinkResponse {
	s.StatusCode = &v
	return s
}

func (s *EnableVpcClassicLinkResponse) SetBody(v *EnableVpcClassicLinkResponseBody) *EnableVpcClassicLinkResponse {
	s.Body = v
	return s
}

type EnableVpcIpv4GatewayRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, the system uses **RequestId** as **ClientToken**. **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to check the request without performing the operation. Valid values:
	//
	// *   **true**: checks the request without performing the operation. The system checks the required parameters, request syntax, and limits. If the request fails the check, an error message is returned. If the request passes the check, the `DryRunOperation` error code is returned.
	// *   **false** (default): sends the API request. After the request passes the check, a 2xx HTTP status code is returned and the operation is performed.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The ID of the IPv4 gateway that you want to activate.
	Ipv4GatewayId *string `json:"Ipv4GatewayId,omitempty" xml:"Ipv4GatewayId,omitempty"`
	OwnerAccount  *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region where the IPv4 gateway is deployed.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string   `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string   `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64    `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	RouteTableList       []*string `json:"RouteTableList,omitempty" xml:"RouteTableList,omitempty" type:"Repeated"`
}

func (s EnableVpcIpv4GatewayRequest) String() string {
	return tea.Prettify(s)
}

func (s EnableVpcIpv4GatewayRequest) GoString() string {
	return s.String()
}

func (s *EnableVpcIpv4GatewayRequest) SetClientToken(v string) *EnableVpcIpv4GatewayRequest {
	s.ClientToken = &v
	return s
}

func (s *EnableVpcIpv4GatewayRequest) SetDryRun(v bool) *EnableVpcIpv4GatewayRequest {
	s.DryRun = &v
	return s
}

func (s *EnableVpcIpv4GatewayRequest) SetIpv4GatewayId(v string) *EnableVpcIpv4GatewayRequest {
	s.Ipv4GatewayId = &v
	return s
}

func (s *EnableVpcIpv4GatewayRequest) SetOwnerAccount(v string) *EnableVpcIpv4GatewayRequest {
	s.OwnerAccount = &v
	return s
}

func (s *EnableVpcIpv4GatewayRequest) SetOwnerId(v int64) *EnableVpcIpv4GatewayRequest {
	s.OwnerId = &v
	return s
}

func (s *EnableVpcIpv4GatewayRequest) SetRegionId(v string) *EnableVpcIpv4GatewayRequest {
	s.RegionId = &v
	return s
}

func (s *EnableVpcIpv4GatewayRequest) SetResourceOwnerAccount(v string) *EnableVpcIpv4GatewayRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *EnableVpcIpv4GatewayRequest) SetResourceOwnerId(v int64) *EnableVpcIpv4GatewayRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *EnableVpcIpv4GatewayRequest) SetRouteTableList(v []*string) *EnableVpcIpv4GatewayRequest {
	s.RouteTableList = v
	return s
}

type EnableVpcIpv4GatewayResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s EnableVpcIpv4GatewayResponseBody) String() string {
	return tea.Prettify(s)
}

func (s EnableVpcIpv4GatewayResponseBody) GoString() string {
	return s.String()
}

func (s *EnableVpcIpv4GatewayResponseBody) SetRequestId(v string) *EnableVpcIpv4GatewayResponseBody {
	s.RequestId = &v
	return s
}

type EnableVpcIpv4GatewayResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *EnableVpcIpv4GatewayResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s EnableVpcIpv4GatewayResponse) String() string {
	return tea.Prettify(s)
}

func (s EnableVpcIpv4GatewayResponse) GoString() string {
	return s.String()
}

func (s *EnableVpcIpv4GatewayResponse) SetHeaders(v map[string]*string) *EnableVpcIpv4GatewayResponse {
	s.Headers = v
	return s
}

func (s *EnableVpcIpv4GatewayResponse) SetStatusCode(v int32) *EnableVpcIpv4GatewayResponse {
	s.StatusCode = &v
	return s
}

func (s *EnableVpcIpv4GatewayResponse) SetBody(v *EnableVpcIpv4GatewayResponseBody) *EnableVpcIpv4GatewayResponse {
	s.Body = v
	return s
}

type GetDhcpOptionsSetRequest struct {
	// The ID of the DHCP options set.
	DhcpOptionsSetId *string `json:"DhcpOptionsSetId,omitempty" xml:"DhcpOptionsSetId,omitempty"`
	OwnerAccount     *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId          *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the DHCP options set that you want to query.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s GetDhcpOptionsSetRequest) String() string {
	return tea.Prettify(s)
}

func (s GetDhcpOptionsSetRequest) GoString() string {
	return s.String()
}

func (s *GetDhcpOptionsSetRequest) SetDhcpOptionsSetId(v string) *GetDhcpOptionsSetRequest {
	s.DhcpOptionsSetId = &v
	return s
}

func (s *GetDhcpOptionsSetRequest) SetOwnerAccount(v string) *GetDhcpOptionsSetRequest {
	s.OwnerAccount = &v
	return s
}

func (s *GetDhcpOptionsSetRequest) SetOwnerId(v int64) *GetDhcpOptionsSetRequest {
	s.OwnerId = &v
	return s
}

func (s *GetDhcpOptionsSetRequest) SetRegionId(v string) *GetDhcpOptionsSetRequest {
	s.RegionId = &v
	return s
}

func (s *GetDhcpOptionsSetRequest) SetResourceOwnerAccount(v string) *GetDhcpOptionsSetRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *GetDhcpOptionsSetRequest) SetResourceOwnerId(v int64) *GetDhcpOptionsSetRequest {
	s.ResourceOwnerId = &v
	return s
}

type GetDhcpOptionsSetResponseBody struct {
	// The information about the virtual private cloud (VPC) that is associated with the DHCP options set.
	AssociateVpcs []*GetDhcpOptionsSetResponseBodyAssociateVpcs `json:"AssociateVpcs,omitempty" xml:"AssociateVpcs,omitempty" type:"Repeated"`
	// The configuration information about the DHCP options set.
	DhcpOptions *GetDhcpOptionsSetResponseBodyDhcpOptions `json:"DhcpOptions,omitempty" xml:"DhcpOptions,omitempty" type:"Struct"`
	// The description of the DHCP options set.
	DhcpOptionsSetDescription *string `json:"DhcpOptionsSetDescription,omitempty" xml:"DhcpOptionsSetDescription,omitempty"`
	// The ID of the DHCP options set.
	DhcpOptionsSetId *string `json:"DhcpOptionsSetId,omitempty" xml:"DhcpOptionsSetId,omitempty"`
	// The name of the DHCP options set.
	DhcpOptionsSetName *string `json:"DhcpOptionsSetName,omitempty" xml:"DhcpOptionsSetName,omitempty"`
	// The ID of the Alibaba Cloud account to which the DHCP options set belongs.
	OwnerId *int64 `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the request.
	RequestId       *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The status of the DHCP options set. Valid values:
	//
	// *   **Available**: available
	// *   **InUse**: in use
	// *   **Deleted**: deleted
	// *   **Pending**: being configured
	Status *string                              `json:"Status,omitempty" xml:"Status,omitempty"`
	Tags   []*GetDhcpOptionsSetResponseBodyTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
}

func (s GetDhcpOptionsSetResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetDhcpOptionsSetResponseBody) GoString() string {
	return s.String()
}

func (s *GetDhcpOptionsSetResponseBody) SetAssociateVpcs(v []*GetDhcpOptionsSetResponseBodyAssociateVpcs) *GetDhcpOptionsSetResponseBody {
	s.AssociateVpcs = v
	return s
}

func (s *GetDhcpOptionsSetResponseBody) SetDhcpOptions(v *GetDhcpOptionsSetResponseBodyDhcpOptions) *GetDhcpOptionsSetResponseBody {
	s.DhcpOptions = v
	return s
}

func (s *GetDhcpOptionsSetResponseBody) SetDhcpOptionsSetDescription(v string) *GetDhcpOptionsSetResponseBody {
	s.DhcpOptionsSetDescription = &v
	return s
}

func (s *GetDhcpOptionsSetResponseBody) SetDhcpOptionsSetId(v string) *GetDhcpOptionsSetResponseBody {
	s.DhcpOptionsSetId = &v
	return s
}

func (s *GetDhcpOptionsSetResponseBody) SetDhcpOptionsSetName(v string) *GetDhcpOptionsSetResponseBody {
	s.DhcpOptionsSetName = &v
	return s
}

func (s *GetDhcpOptionsSetResponseBody) SetOwnerId(v int64) *GetDhcpOptionsSetResponseBody {
	s.OwnerId = &v
	return s
}

func (s *GetDhcpOptionsSetResponseBody) SetRequestId(v string) *GetDhcpOptionsSetResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetDhcpOptionsSetResponseBody) SetResourceGroupId(v string) *GetDhcpOptionsSetResponseBody {
	s.ResourceGroupId = &v
	return s
}

func (s *GetDhcpOptionsSetResponseBody) SetStatus(v string) *GetDhcpOptionsSetResponseBody {
	s.Status = &v
	return s
}

func (s *GetDhcpOptionsSetResponseBody) SetTags(v []*GetDhcpOptionsSetResponseBodyTags) *GetDhcpOptionsSetResponseBody {
	s.Tags = v
	return s
}

type GetDhcpOptionsSetResponseBodyAssociateVpcs struct {
	// The status of the VPC that is associated with the DHCP options set. Valid values:
	//
	// *   **InUse**: in use
	// *   **Pending**: being configured
	AssociateStatus *string `json:"AssociateStatus,omitempty" xml:"AssociateStatus,omitempty"`
	// The ID of the VPC that is associated with the DHCP options set.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s GetDhcpOptionsSetResponseBodyAssociateVpcs) String() string {
	return tea.Prettify(s)
}

func (s GetDhcpOptionsSetResponseBodyAssociateVpcs) GoString() string {
	return s.String()
}

func (s *GetDhcpOptionsSetResponseBodyAssociateVpcs) SetAssociateStatus(v string) *GetDhcpOptionsSetResponseBodyAssociateVpcs {
	s.AssociateStatus = &v
	return s
}

func (s *GetDhcpOptionsSetResponseBodyAssociateVpcs) SetVpcId(v string) *GetDhcpOptionsSetResponseBodyAssociateVpcs {
	s.VpcId = &v
	return s
}

type GetDhcpOptionsSetResponseBodyDhcpOptions struct {
	// The suffix of the hostname.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The IP address of the DNS server.
	DomainNameServers *string `json:"DomainNameServers,omitempty" xml:"DomainNameServers,omitempty"`
	// The lease time of the IPv6 addresses for the DHCP options set.
	//
	// *   If you use hours as the unit, Valid values are **24h to 1176h** and **87600h to 175200h**. Default value: **87600h**.
	// *   If you use days as the unit, Valid values are **1d to 49d** and **3650d to 7300d**. Default value: **3650d**.
	Ipv6LeaseTime *string `json:"Ipv6LeaseTime,omitempty" xml:"Ipv6LeaseTime,omitempty"`
	// The lease time of the IPv4 addresses for the DHCP options set.
	//
	// *   If you use hours as the unit, valid values are **24h to 1176h** and **87600h to 175200h**. Default value: **87600h**.
	// *   If you use days as the unit, valid values are **1d to 49d** and **3650d to 7300d**. Default value: **3650d**.
	LeaseTime *string `json:"LeaseTime,omitempty" xml:"LeaseTime,omitempty"`
}

func (s GetDhcpOptionsSetResponseBodyDhcpOptions) String() string {
	return tea.Prettify(s)
}

func (s GetDhcpOptionsSetResponseBodyDhcpOptions) GoString() string {
	return s.String()
}

func (s *GetDhcpOptionsSetResponseBodyDhcpOptions) SetDomainName(v string) *GetDhcpOptionsSetResponseBodyDhcpOptions {
	s.DomainName = &v
	return s
}

func (s *GetDhcpOptionsSetResponseBodyDhcpOptions) SetDomainNameServers(v string) *GetDhcpOptionsSetResponseBodyDhcpOptions {
	s.DomainNameServers = &v
	return s
}

func (s *GetDhcpOptionsSetResponseBodyDhcpOptions) SetIpv6LeaseTime(v string) *GetDhcpOptionsSetResponseBodyDhcpOptions {
	s.Ipv6LeaseTime = &v
	return s
}

func (s *GetDhcpOptionsSetResponseBodyDhcpOptions) SetLeaseTime(v string) *GetDhcpOptionsSetResponseBodyDhcpOptions {
	s.LeaseTime = &v
	return s
}

type GetDhcpOptionsSetResponseBodyTags struct {
	Key   *string `json:"Key,omitempty" xml:"Key,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s GetDhcpOptionsSetResponseBodyTags) String() string {
	return tea.Prettify(s)
}

func (s GetDhcpOptionsSetResponseBodyTags) GoString() string {
	return s.String()
}

func (s *GetDhcpOptionsSetResponseBodyTags) SetKey(v string) *GetDhcpOptionsSetResponseBodyTags {
	s.Key = &v
	return s
}

func (s *GetDhcpOptionsSetResponseBodyTags) SetValue(v string) *GetDhcpOptionsSetResponseBodyTags {
	s.Value = &v
	return s
}

type GetDhcpOptionsSetResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetDhcpOptionsSetResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetDhcpOptionsSetResponse) String() string {
	return tea.Prettify(s)
}

func (s GetDhcpOptionsSetResponse) GoString() string {
	return s.String()
}

func (s *GetDhcpOptionsSetResponse) SetHeaders(v map[string]*string) *GetDhcpOptionsSetResponse {
	s.Headers = v
	return s
}

func (s *GetDhcpOptionsSetResponse) SetStatusCode(v int32) *GetDhcpOptionsSetResponse {
	s.StatusCode = &v
	return s
}

func (s *GetDhcpOptionsSetResponse) SetBody(v *GetDhcpOptionsSetResponseBody) *GetDhcpOptionsSetResponse {
	s.Body = v
	return s
}

type GetFlowLogServiceStatusRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, the system automatically uses **RequestId** as **ClientToken**. The value of **RequestId** in each API request may be different.
	ClientToken  *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the flow log.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s GetFlowLogServiceStatusRequest) String() string {
	return tea.Prettify(s)
}

func (s GetFlowLogServiceStatusRequest) GoString() string {
	return s.String()
}

func (s *GetFlowLogServiceStatusRequest) SetClientToken(v string) *GetFlowLogServiceStatusRequest {
	s.ClientToken = &v
	return s
}

func (s *GetFlowLogServiceStatusRequest) SetOwnerAccount(v string) *GetFlowLogServiceStatusRequest {
	s.OwnerAccount = &v
	return s
}

func (s *GetFlowLogServiceStatusRequest) SetOwnerId(v int64) *GetFlowLogServiceStatusRequest {
	s.OwnerId = &v
	return s
}

func (s *GetFlowLogServiceStatusRequest) SetRegionId(v string) *GetFlowLogServiceStatusRequest {
	s.RegionId = &v
	return s
}

func (s *GetFlowLogServiceStatusRequest) SetResourceOwnerAccount(v string) *GetFlowLogServiceStatusRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *GetFlowLogServiceStatusRequest) SetResourceOwnerId(v int64) *GetFlowLogServiceStatusRequest {
	s.ResourceOwnerId = &v
	return s
}

type GetFlowLogServiceStatusResponseBody struct {
	// Indicates whether the flow log feature is enabled. Valid values:
	//
	// *   **true**: yes
	// *   **false**: no You can call the [OpenFlowLogService](~~449637~~) operation to enable the flow log feature.
	Enabled *bool `json:"Enabled,omitempty" xml:"Enabled,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetFlowLogServiceStatusResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetFlowLogServiceStatusResponseBody) GoString() string {
	return s.String()
}

func (s *GetFlowLogServiceStatusResponseBody) SetEnabled(v bool) *GetFlowLogServiceStatusResponseBody {
	s.Enabled = &v
	return s
}

func (s *GetFlowLogServiceStatusResponseBody) SetRequestId(v string) *GetFlowLogServiceStatusResponseBody {
	s.RequestId = &v
	return s
}

type GetFlowLogServiceStatusResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetFlowLogServiceStatusResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetFlowLogServiceStatusResponse) String() string {
	return tea.Prettify(s)
}

func (s GetFlowLogServiceStatusResponse) GoString() string {
	return s.String()
}

func (s *GetFlowLogServiceStatusResponse) SetHeaders(v map[string]*string) *GetFlowLogServiceStatusResponse {
	s.Headers = v
	return s
}

func (s *GetFlowLogServiceStatusResponse) SetStatusCode(v int32) *GetFlowLogServiceStatusResponse {
	s.StatusCode = &v
	return s
}

func (s *GetFlowLogServiceStatusResponse) SetBody(v *GetFlowLogServiceStatusResponseBody) *GetFlowLogServiceStatusResponse {
	s.Body = v
	return s
}

type GetIpv4GatewayAttributeRequest struct {
	// The ID of the IPv4 gateway.
	Ipv4GatewayId *string `json:"Ipv4GatewayId,omitempty" xml:"Ipv4GatewayId,omitempty"`
	OwnerAccount  *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the IPv4 gateway.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s GetIpv4GatewayAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s GetIpv4GatewayAttributeRequest) GoString() string {
	return s.String()
}

func (s *GetIpv4GatewayAttributeRequest) SetIpv4GatewayId(v string) *GetIpv4GatewayAttributeRequest {
	s.Ipv4GatewayId = &v
	return s
}

func (s *GetIpv4GatewayAttributeRequest) SetOwnerAccount(v string) *GetIpv4GatewayAttributeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *GetIpv4GatewayAttributeRequest) SetOwnerId(v int64) *GetIpv4GatewayAttributeRequest {
	s.OwnerId = &v
	return s
}

func (s *GetIpv4GatewayAttributeRequest) SetRegionId(v string) *GetIpv4GatewayAttributeRequest {
	s.RegionId = &v
	return s
}

func (s *GetIpv4GatewayAttributeRequest) SetResourceOwnerAccount(v string) *GetIpv4GatewayAttributeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *GetIpv4GatewayAttributeRequest) SetResourceOwnerId(v int64) *GetIpv4GatewayAttributeRequest {
	s.ResourceOwnerId = &v
	return s
}

type GetIpv4GatewayAttributeResponseBody struct {
	// The time when the IPv4 gateway was created.
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// Indicates whether the IPv4 gateway is activated. Valid values:
	//
	// *   **true**: yes
	// *   **false**: no
	Enabled *bool `json:"Enabled,omitempty" xml:"Enabled,omitempty"`
	// The description of the IPv4 gateway.
	Ipv4GatewayDescription *string `json:"Ipv4GatewayDescription,omitempty" xml:"Ipv4GatewayDescription,omitempty"`
	// The ID of the IPv4 gateway.
	Ipv4GatewayId *string `json:"Ipv4GatewayId,omitempty" xml:"Ipv4GatewayId,omitempty"`
	// The name of the IPv4 gateway.
	Ipv4GatewayName *string `json:"Ipv4GatewayName,omitempty" xml:"Ipv4GatewayName,omitempty"`
	// The ID of the route table associated with the IPv4 gateway.
	Ipv4GatewayRouteTableId *string `json:"Ipv4GatewayRouteTableId,omitempty" xml:"Ipv4GatewayRouteTableId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the resource group to which the IPv4 gateway belongs.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The status of the IPv4 gateway. Valid values:
	//
	// *   **Creating**
	// *   **Created**
	// *   **Modifying**
	// *   **Deleting**
	// *   **Deleted**
	// *   **Activating**
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The tag list.
	Tags []*GetIpv4GatewayAttributeResponseBodyTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
	// The ID of the virtual private cloud (VPC) with which the IPv4 gateway is associated.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s GetIpv4GatewayAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetIpv4GatewayAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *GetIpv4GatewayAttributeResponseBody) SetCreateTime(v string) *GetIpv4GatewayAttributeResponseBody {
	s.CreateTime = &v
	return s
}

func (s *GetIpv4GatewayAttributeResponseBody) SetEnabled(v bool) *GetIpv4GatewayAttributeResponseBody {
	s.Enabled = &v
	return s
}

func (s *GetIpv4GatewayAttributeResponseBody) SetIpv4GatewayDescription(v string) *GetIpv4GatewayAttributeResponseBody {
	s.Ipv4GatewayDescription = &v
	return s
}

func (s *GetIpv4GatewayAttributeResponseBody) SetIpv4GatewayId(v string) *GetIpv4GatewayAttributeResponseBody {
	s.Ipv4GatewayId = &v
	return s
}

func (s *GetIpv4GatewayAttributeResponseBody) SetIpv4GatewayName(v string) *GetIpv4GatewayAttributeResponseBody {
	s.Ipv4GatewayName = &v
	return s
}

func (s *GetIpv4GatewayAttributeResponseBody) SetIpv4GatewayRouteTableId(v string) *GetIpv4GatewayAttributeResponseBody {
	s.Ipv4GatewayRouteTableId = &v
	return s
}

func (s *GetIpv4GatewayAttributeResponseBody) SetRequestId(v string) *GetIpv4GatewayAttributeResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetIpv4GatewayAttributeResponseBody) SetResourceGroupId(v string) *GetIpv4GatewayAttributeResponseBody {
	s.ResourceGroupId = &v
	return s
}

func (s *GetIpv4GatewayAttributeResponseBody) SetStatus(v string) *GetIpv4GatewayAttributeResponseBody {
	s.Status = &v
	return s
}

func (s *GetIpv4GatewayAttributeResponseBody) SetTags(v []*GetIpv4GatewayAttributeResponseBodyTags) *GetIpv4GatewayAttributeResponseBody {
	s.Tags = v
	return s
}

func (s *GetIpv4GatewayAttributeResponseBody) SetVpcId(v string) *GetIpv4GatewayAttributeResponseBody {
	s.VpcId = &v
	return s
}

type GetIpv4GatewayAttributeResponseBodyTags struct {
	// The tag key.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s GetIpv4GatewayAttributeResponseBodyTags) String() string {
	return tea.Prettify(s)
}

func (s GetIpv4GatewayAttributeResponseBodyTags) GoString() string {
	return s.String()
}

func (s *GetIpv4GatewayAttributeResponseBodyTags) SetKey(v string) *GetIpv4GatewayAttributeResponseBodyTags {
	s.Key = &v
	return s
}

func (s *GetIpv4GatewayAttributeResponseBodyTags) SetValue(v string) *GetIpv4GatewayAttributeResponseBodyTags {
	s.Value = &v
	return s
}

type GetIpv4GatewayAttributeResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetIpv4GatewayAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetIpv4GatewayAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s GetIpv4GatewayAttributeResponse) GoString() string {
	return s.String()
}

func (s *GetIpv4GatewayAttributeResponse) SetHeaders(v map[string]*string) *GetIpv4GatewayAttributeResponse {
	s.Headers = v
	return s
}

func (s *GetIpv4GatewayAttributeResponse) SetStatusCode(v int32) *GetIpv4GatewayAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *GetIpv4GatewayAttributeResponse) SetBody(v *GetIpv4GatewayAttributeResponseBody) *GetIpv4GatewayAttributeResponse {
	s.Body = v
	return s
}

type GetNatGatewayAttributeRequest struct {
	// The ID of the NAT gateway.
	NatGatewayId *string `json:"NatGatewayId,omitempty" xml:"NatGatewayId,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region where the NAT gateway is deployed.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s GetNatGatewayAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s GetNatGatewayAttributeRequest) GoString() string {
	return s.String()
}

func (s *GetNatGatewayAttributeRequest) SetNatGatewayId(v string) *GetNatGatewayAttributeRequest {
	s.NatGatewayId = &v
	return s
}

func (s *GetNatGatewayAttributeRequest) SetOwnerAccount(v string) *GetNatGatewayAttributeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *GetNatGatewayAttributeRequest) SetOwnerId(v int64) *GetNatGatewayAttributeRequest {
	s.OwnerId = &v
	return s
}

func (s *GetNatGatewayAttributeRequest) SetRegionId(v string) *GetNatGatewayAttributeRequest {
	s.RegionId = &v
	return s
}

func (s *GetNatGatewayAttributeRequest) SetResourceOwnerAccount(v string) *GetNatGatewayAttributeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *GetNatGatewayAttributeRequest) SetResourceOwnerId(v int64) *GetNatGatewayAttributeRequest {
	s.ResourceOwnerId = &v
	return s
}

type GetNatGatewayAttributeResponseBody struct {
	// The billing information.
	BillingConfig *GetNatGatewayAttributeResponseBodyBillingConfig `json:"BillingConfig,omitempty" xml:"BillingConfig,omitempty" type:"Struct"`
	// The service status of the NAT gateway. Valid values:
	//
	// *   **Normal**: normal
	// *   **FinancialLocked**: locked due to overdue payments
	BusinessStatus *string `json:"BusinessStatus,omitempty" xml:"BusinessStatus,omitempty"`
	// The time when the NAT gateway was created. Format: YYYY-MM-DDThh:mm:ssZ.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The information about the deletion protection feature.
	DeletionProtectionInfo *GetNatGatewayAttributeResponseBodyDeletionProtectionInfo `json:"DeletionProtectionInfo,omitempty" xml:"DeletionProtectionInfo,omitempty" type:"Struct"`
	// The description of the NAT gateway.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// Indicates whether the traffic monitoring feature is enabled. Valid values:
	//
	// *   **true**: yes
	// *   **false**: no
	EcsMetricEnabled *bool `json:"EcsMetricEnabled,omitempty" xml:"EcsMetricEnabled,omitempty"`
	// The time when the NAT gateway expires.
	ExpiredTime *string `json:"ExpiredTime,omitempty" xml:"ExpiredTime,omitempty"`
	// The information about the DNAT table.
	ForwardTable *GetNatGatewayAttributeResponseBodyForwardTable `json:"ForwardTable,omitempty" xml:"ForwardTable,omitempty" type:"Struct"`
	// The information about the FULLNAT table.
	FullNatTable *GetNatGatewayAttributeResponseBodyFullNatTable `json:"FullNatTable,omitempty" xml:"FullNatTable,omitempty" type:"Struct"`
	// The elastic IP addresses (EIPs) that are associated with the Internet NAT gateway.
	IpList []*GetNatGatewayAttributeResponseBodyIpList `json:"IpList,omitempty" xml:"IpList,omitempty" type:"Repeated"`
	// The name of the NAT gateway.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the NAT gateway.
	NatGatewayId *string `json:"NatGatewayId,omitempty" xml:"NatGatewayId,omitempty"`
	// The type of the Internet NAT gateway. Only **Enhanced** is returned, which indicates an enhanced Internet NAT gateway.
	NatType *string `json:"NatType,omitempty" xml:"NatType,omitempty"`
	// The type of the NAT gateway. Valid values:
	//
	// *   **internet**: an Internet NAT gateway
	// *   **intranet**: a VPC NAT gateway
	NetworkType *string `json:"NetworkType,omitempty" xml:"NetworkType,omitempty"`
	// The private network information about the NAT gateway.
	PrivateInfo *GetNatGatewayAttributeResponseBodyPrivateInfo `json:"PrivateInfo,omitempty" xml:"PrivateInfo,omitempty" type:"Struct"`
	// Indicates whether the NAT gateway supports PrivateLink. Valid values:
	//
	// *   **true**: yes
	// *   **false**: no
	PrivateLinkEnabled *bool `json:"PrivateLinkEnabled,omitempty" xml:"PrivateLinkEnabled,omitempty"`
	// The mode that is used by PrivateLink. Valid values:
	//
	// *   **FullNat**: the FULLNAT mode
	// *   **Geneve**: the GENEVE mode
	PrivateLinkMode *string `json:"PrivateLinkMode,omitempty" xml:"PrivateLinkMode,omitempty"`
	// The ID of the region where the NAT gateway is deployed.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The information about the SNAT table.
	SnatTable *GetNatGatewayAttributeResponseBodySnatTable `json:"SnatTable,omitempty" xml:"SnatTable,omitempty" type:"Struct"`
	// The status of the NAT gateway. Valid values:
	//
	// *   **Creating**: being created. The operation to create a NAT gateway is asynchronous. The NAT gateway remains in the **Creating** state until it is created.
	// *   **Available**: available. After a NAT gateway is created, it remains in a stable state.
	// *   **Modifying**: being modified. The operation to upgrade or downgrade a NAT gateway is asynchronous. The NAT gateway remains in the **Modifying** state until it is upgraded or downgraded.
	// *   **Deleting**: being deleted. The operation to delete a NAT gateway is asynchronous. The NAT gateway remains in the **Deleting** state until it is deleted.
	// *   **Converting**: being converted. The operation to convert a standard NAT gateway to an enhanced NAT gateway is asynchronous. The NAT gateway remains in the **Converting** state until it is converted.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The ID of the VPC to which the NAT gateway belongs.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s GetNatGatewayAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetNatGatewayAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *GetNatGatewayAttributeResponseBody) SetBillingConfig(v *GetNatGatewayAttributeResponseBodyBillingConfig) *GetNatGatewayAttributeResponseBody {
	s.BillingConfig = v
	return s
}

func (s *GetNatGatewayAttributeResponseBody) SetBusinessStatus(v string) *GetNatGatewayAttributeResponseBody {
	s.BusinessStatus = &v
	return s
}

func (s *GetNatGatewayAttributeResponseBody) SetCreationTime(v string) *GetNatGatewayAttributeResponseBody {
	s.CreationTime = &v
	return s
}

func (s *GetNatGatewayAttributeResponseBody) SetDeletionProtectionInfo(v *GetNatGatewayAttributeResponseBodyDeletionProtectionInfo) *GetNatGatewayAttributeResponseBody {
	s.DeletionProtectionInfo = v
	return s
}

func (s *GetNatGatewayAttributeResponseBody) SetDescription(v string) *GetNatGatewayAttributeResponseBody {
	s.Description = &v
	return s
}

func (s *GetNatGatewayAttributeResponseBody) SetEcsMetricEnabled(v bool) *GetNatGatewayAttributeResponseBody {
	s.EcsMetricEnabled = &v
	return s
}

func (s *GetNatGatewayAttributeResponseBody) SetExpiredTime(v string) *GetNatGatewayAttributeResponseBody {
	s.ExpiredTime = &v
	return s
}

func (s *GetNatGatewayAttributeResponseBody) SetForwardTable(v *GetNatGatewayAttributeResponseBodyForwardTable) *GetNatGatewayAttributeResponseBody {
	s.ForwardTable = v
	return s
}

func (s *GetNatGatewayAttributeResponseBody) SetFullNatTable(v *GetNatGatewayAttributeResponseBodyFullNatTable) *GetNatGatewayAttributeResponseBody {
	s.FullNatTable = v
	return s
}

func (s *GetNatGatewayAttributeResponseBody) SetIpList(v []*GetNatGatewayAttributeResponseBodyIpList) *GetNatGatewayAttributeResponseBody {
	s.IpList = v
	return s
}

func (s *GetNatGatewayAttributeResponseBody) SetName(v string) *GetNatGatewayAttributeResponseBody {
	s.Name = &v
	return s
}

func (s *GetNatGatewayAttributeResponseBody) SetNatGatewayId(v string) *GetNatGatewayAttributeResponseBody {
	s.NatGatewayId = &v
	return s
}

func (s *GetNatGatewayAttributeResponseBody) SetNatType(v string) *GetNatGatewayAttributeResponseBody {
	s.NatType = &v
	return s
}

func (s *GetNatGatewayAttributeResponseBody) SetNetworkType(v string) *GetNatGatewayAttributeResponseBody {
	s.NetworkType = &v
	return s
}

func (s *GetNatGatewayAttributeResponseBody) SetPrivateInfo(v *GetNatGatewayAttributeResponseBodyPrivateInfo) *GetNatGatewayAttributeResponseBody {
	s.PrivateInfo = v
	return s
}

func (s *GetNatGatewayAttributeResponseBody) SetPrivateLinkEnabled(v bool) *GetNatGatewayAttributeResponseBody {
	s.PrivateLinkEnabled = &v
	return s
}

func (s *GetNatGatewayAttributeResponseBody) SetPrivateLinkMode(v string) *GetNatGatewayAttributeResponseBody {
	s.PrivateLinkMode = &v
	return s
}

func (s *GetNatGatewayAttributeResponseBody) SetRegionId(v string) *GetNatGatewayAttributeResponseBody {
	s.RegionId = &v
	return s
}

func (s *GetNatGatewayAttributeResponseBody) SetRequestId(v string) *GetNatGatewayAttributeResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetNatGatewayAttributeResponseBody) SetResourceGroupId(v string) *GetNatGatewayAttributeResponseBody {
	s.ResourceGroupId = &v
	return s
}

func (s *GetNatGatewayAttributeResponseBody) SetSnatTable(v *GetNatGatewayAttributeResponseBodySnatTable) *GetNatGatewayAttributeResponseBody {
	s.SnatTable = v
	return s
}

func (s *GetNatGatewayAttributeResponseBody) SetStatus(v string) *GetNatGatewayAttributeResponseBody {
	s.Status = &v
	return s
}

func (s *GetNatGatewayAttributeResponseBody) SetVpcId(v string) *GetNatGatewayAttributeResponseBody {
	s.VpcId = &v
	return s
}

type GetNatGatewayAttributeResponseBodyBillingConfig struct {
	// Indicates whether automatic payment is enabled. If the **InstanceChargeType** parameter is set to **PrePaid**, one of the following values is returned:
	//
	// *   **false**: disabled. After an order is generated, you must go to the Order Center to complete the payment.
	// *   **true**: enabled. Payments are automatically completed.
	//
	// The return value of this parameter is empty if **InstanceChargeType** is set to **PostPaid**.
	AutoPay *string `json:"AutoPay,omitempty" xml:"AutoPay,omitempty"`
	// The billing method of the NAT gateway. The value is set to **PostPaid**, which indicates the pay-as-you-go billing method.
	InstanceChargeType *string `json:"InstanceChargeType,omitempty" xml:"InstanceChargeType,omitempty"`
	// The metering method of the NAT gateway. Valid values:
	//
	// *   **PayBySpec**: pay-by-specification
	// *   **PayByLcu**: pay-by-CU
	InternetChargeType *string `json:"InternetChargeType,omitempty" xml:"InternetChargeType,omitempty"`
	// The specification of the Internet NAT gateway. If the **InternetChargeType** parameter is set to **PayBySpec**, one of the following values is returned:
	//
	// *   **Small**: small
	//
	// *   **Middle**: medium
	//
	// *   **Large**: large
	//
	//     The return value of this parameter is empty if **InternetChargeType** is set to **PayByLcu**.
	Spec *string `json:"Spec,omitempty" xml:"Spec,omitempty"`
}

func (s GetNatGatewayAttributeResponseBodyBillingConfig) String() string {
	return tea.Prettify(s)
}

func (s GetNatGatewayAttributeResponseBodyBillingConfig) GoString() string {
	return s.String()
}

func (s *GetNatGatewayAttributeResponseBodyBillingConfig) SetAutoPay(v string) *GetNatGatewayAttributeResponseBodyBillingConfig {
	s.AutoPay = &v
	return s
}

func (s *GetNatGatewayAttributeResponseBodyBillingConfig) SetInstanceChargeType(v string) *GetNatGatewayAttributeResponseBodyBillingConfig {
	s.InstanceChargeType = &v
	return s
}

func (s *GetNatGatewayAttributeResponseBodyBillingConfig) SetInternetChargeType(v string) *GetNatGatewayAttributeResponseBodyBillingConfig {
	s.InternetChargeType = &v
	return s
}

func (s *GetNatGatewayAttributeResponseBodyBillingConfig) SetSpec(v string) *GetNatGatewayAttributeResponseBodyBillingConfig {
	s.Spec = &v
	return s
}

type GetNatGatewayAttributeResponseBodyDeletionProtectionInfo struct {
	// Indicates whether deletion protection is enabled.
	//
	// *   **true**: yes
	// *   **false**: no
	Enabled *bool `json:"Enabled,omitempty" xml:"Enabled,omitempty"`
}

func (s GetNatGatewayAttributeResponseBodyDeletionProtectionInfo) String() string {
	return tea.Prettify(s)
}

func (s GetNatGatewayAttributeResponseBodyDeletionProtectionInfo) GoString() string {
	return s.String()
}

func (s *GetNatGatewayAttributeResponseBodyDeletionProtectionInfo) SetEnabled(v bool) *GetNatGatewayAttributeResponseBodyDeletionProtectionInfo {
	s.Enabled = &v
	return s
}

type GetNatGatewayAttributeResponseBodyForwardTable struct {
	// The number of DNAT entries.
	ForwardEntryCount *int32 `json:"ForwardEntryCount,omitempty" xml:"ForwardEntryCount,omitempty"`
	// The ID of the DNAT table.
	ForwardTableId *string `json:"ForwardTableId,omitempty" xml:"ForwardTableId,omitempty"`
}

func (s GetNatGatewayAttributeResponseBodyForwardTable) String() string {
	return tea.Prettify(s)
}

func (s GetNatGatewayAttributeResponseBodyForwardTable) GoString() string {
	return s.String()
}

func (s *GetNatGatewayAttributeResponseBodyForwardTable) SetForwardEntryCount(v int32) *GetNatGatewayAttributeResponseBodyForwardTable {
	s.ForwardEntryCount = &v
	return s
}

func (s *GetNatGatewayAttributeResponseBodyForwardTable) SetForwardTableId(v string) *GetNatGatewayAttributeResponseBodyForwardTable {
	s.ForwardTableId = &v
	return s
}

type GetNatGatewayAttributeResponseBodyFullNatTable struct {
	// The number of FULLNAT entries.
	FullNatEntryCount *int64 `json:"FullNatEntryCount,omitempty" xml:"FullNatEntryCount,omitempty"`
	// The ID of the FULLNAT table.
	FullNatTableId *string `json:"FullNatTableId,omitempty" xml:"FullNatTableId,omitempty"`
}

func (s GetNatGatewayAttributeResponseBodyFullNatTable) String() string {
	return tea.Prettify(s)
}

func (s GetNatGatewayAttributeResponseBodyFullNatTable) GoString() string {
	return s.String()
}

func (s *GetNatGatewayAttributeResponseBodyFullNatTable) SetFullNatEntryCount(v int64) *GetNatGatewayAttributeResponseBodyFullNatTable {
	s.FullNatEntryCount = &v
	return s
}

func (s *GetNatGatewayAttributeResponseBodyFullNatTable) SetFullNatTableId(v string) *GetNatGatewayAttributeResponseBodyFullNatTable {
	s.FullNatTableId = &v
	return s
}

type GetNatGatewayAttributeResponseBodyIpList struct {
	// The ID of the EIP.
	AllocationId *string `json:"AllocationId,omitempty" xml:"AllocationId,omitempty"`
	// The IP address of the EIP.
	IpAddress *string `json:"IpAddress,omitempty" xml:"IpAddress,omitempty"`
	// The association status of the EIP.
	//
	// *   **idle**: The EIP is not specified in an SNAT entry or a DNAT entry.
	// *   **UsedBySnatTable**: The EIP is specified in an SNAT entry.
	// *   **UsedByForwardTable**: The EIP is specified in a DNAT entry.
	UsingStatus *string `json:"UsingStatus,omitempty" xml:"UsingStatus,omitempty"`
}

func (s GetNatGatewayAttributeResponseBodyIpList) String() string {
	return tea.Prettify(s)
}

func (s GetNatGatewayAttributeResponseBodyIpList) GoString() string {
	return s.String()
}

func (s *GetNatGatewayAttributeResponseBodyIpList) SetAllocationId(v string) *GetNatGatewayAttributeResponseBodyIpList {
	s.AllocationId = &v
	return s
}

func (s *GetNatGatewayAttributeResponseBodyIpList) SetIpAddress(v string) *GetNatGatewayAttributeResponseBodyIpList {
	s.IpAddress = &v
	return s
}

func (s *GetNatGatewayAttributeResponseBodyIpList) SetUsingStatus(v string) *GetNatGatewayAttributeResponseBodyIpList {
	s.UsingStatus = &v
	return s
}

type GetNatGatewayAttributeResponseBodyPrivateInfo struct {
	// The ID of the elastic network interface (ENI).
	EniInstanceId *string `json:"EniInstanceId,omitempty" xml:"EniInstanceId,omitempty"`
	// The zone where the NAT gateway is deployed.
	IzNo *string `json:"IzNo,omitempty" xml:"IzNo,omitempty"`
	// The maximum bandwidth. Unit: Mbit/s.
	MaxBandwidth *int32 `json:"MaxBandwidth,omitempty" xml:"MaxBandwidth,omitempty"`
	// The private IP address.
	PrivateIpAddress *string `json:"PrivateIpAddress,omitempty" xml:"PrivateIpAddress,omitempty"`
	// The ID of the vSwitch to which the NAT gateway belongs.
	VswitchId *string `json:"VswitchId,omitempty" xml:"VswitchId,omitempty"`
}

func (s GetNatGatewayAttributeResponseBodyPrivateInfo) String() string {
	return tea.Prettify(s)
}

func (s GetNatGatewayAttributeResponseBodyPrivateInfo) GoString() string {
	return s.String()
}

func (s *GetNatGatewayAttributeResponseBodyPrivateInfo) SetEniInstanceId(v string) *GetNatGatewayAttributeResponseBodyPrivateInfo {
	s.EniInstanceId = &v
	return s
}

func (s *GetNatGatewayAttributeResponseBodyPrivateInfo) SetIzNo(v string) *GetNatGatewayAttributeResponseBodyPrivateInfo {
	s.IzNo = &v
	return s
}

func (s *GetNatGatewayAttributeResponseBodyPrivateInfo) SetMaxBandwidth(v int32) *GetNatGatewayAttributeResponseBodyPrivateInfo {
	s.MaxBandwidth = &v
	return s
}

func (s *GetNatGatewayAttributeResponseBodyPrivateInfo) SetPrivateIpAddress(v string) *GetNatGatewayAttributeResponseBodyPrivateInfo {
	s.PrivateIpAddress = &v
	return s
}

func (s *GetNatGatewayAttributeResponseBodyPrivateInfo) SetVswitchId(v string) *GetNatGatewayAttributeResponseBodyPrivateInfo {
	s.VswitchId = &v
	return s
}

type GetNatGatewayAttributeResponseBodySnatTable struct {
	// The number of SNAT entries.
	SnatEntryCount *int32 `json:"SnatEntryCount,omitempty" xml:"SnatEntryCount,omitempty"`
	// The ID of the SNAT table.
	SnatTableId *string `json:"SnatTableId,omitempty" xml:"SnatTableId,omitempty"`
}

func (s GetNatGatewayAttributeResponseBodySnatTable) String() string {
	return tea.Prettify(s)
}

func (s GetNatGatewayAttributeResponseBodySnatTable) GoString() string {
	return s.String()
}

func (s *GetNatGatewayAttributeResponseBodySnatTable) SetSnatEntryCount(v int32) *GetNatGatewayAttributeResponseBodySnatTable {
	s.SnatEntryCount = &v
	return s
}

func (s *GetNatGatewayAttributeResponseBodySnatTable) SetSnatTableId(v string) *GetNatGatewayAttributeResponseBodySnatTable {
	s.SnatTableId = &v
	return s
}

type GetNatGatewayAttributeResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetNatGatewayAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetNatGatewayAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s GetNatGatewayAttributeResponse) GoString() string {
	return s.String()
}

func (s *GetNatGatewayAttributeResponse) SetHeaders(v map[string]*string) *GetNatGatewayAttributeResponse {
	s.Headers = v
	return s
}

func (s *GetNatGatewayAttributeResponse) SetStatusCode(v int32) *GetNatGatewayAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *GetNatGatewayAttributeResponse) SetBody(v *GetNatGatewayAttributeResponseBody) *GetNatGatewayAttributeResponse {
	s.Body = v
	return s
}

type GetNatGatewayConvertStatusRequest struct {
	// The ID of the Internet NAT gateway to be queried.
	NatGatewayId *string `json:"NatGatewayId,omitempty" xml:"NatGatewayId,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region to which the NAT gateway belongs.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s GetNatGatewayConvertStatusRequest) String() string {
	return tea.Prettify(s)
}

func (s GetNatGatewayConvertStatusRequest) GoString() string {
	return s.String()
}

func (s *GetNatGatewayConvertStatusRequest) SetNatGatewayId(v string) *GetNatGatewayConvertStatusRequest {
	s.NatGatewayId = &v
	return s
}

func (s *GetNatGatewayConvertStatusRequest) SetOwnerAccount(v string) *GetNatGatewayConvertStatusRequest {
	s.OwnerAccount = &v
	return s
}

func (s *GetNatGatewayConvertStatusRequest) SetOwnerId(v int64) *GetNatGatewayConvertStatusRequest {
	s.OwnerId = &v
	return s
}

func (s *GetNatGatewayConvertStatusRequest) SetRegionId(v string) *GetNatGatewayConvertStatusRequest {
	s.RegionId = &v
	return s
}

func (s *GetNatGatewayConvertStatusRequest) SetResourceOwnerAccount(v string) *GetNatGatewayConvertStatusRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *GetNatGatewayConvertStatusRequest) SetResourceOwnerId(v int64) *GetNatGatewayConvertStatusRequest {
	s.ResourceOwnerId = &v
	return s
}

type GetNatGatewayConvertStatusResponseBody struct {
	// The status during the switch.
	ConvertSteps []*GetNatGatewayConvertStatusResponseBodyConvertSteps `json:"ConvertSteps,omitempty" xml:"ConvertSteps,omitempty" type:"Repeated"`
	// The type of the NAT gateway. Set the value to **Enhanced**, which specifies an enhanced Internet NAT gateway.
	DstNatType *string `json:"DstNatType,omitempty" xml:"DstNatType,omitempty"`
	// The ID of the Internet NAT gateway.
	NatGatewayId *string `json:"NatGatewayId,omitempty" xml:"NatGatewayId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetNatGatewayConvertStatusResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetNatGatewayConvertStatusResponseBody) GoString() string {
	return s.String()
}

func (s *GetNatGatewayConvertStatusResponseBody) SetConvertSteps(v []*GetNatGatewayConvertStatusResponseBodyConvertSteps) *GetNatGatewayConvertStatusResponseBody {
	s.ConvertSteps = v
	return s
}

func (s *GetNatGatewayConvertStatusResponseBody) SetDstNatType(v string) *GetNatGatewayConvertStatusResponseBody {
	s.DstNatType = &v
	return s
}

func (s *GetNatGatewayConvertStatusResponseBody) SetNatGatewayId(v string) *GetNatGatewayConvertStatusResponseBody {
	s.NatGatewayId = &v
	return s
}

func (s *GetNatGatewayConvertStatusResponseBody) SetRequestId(v string) *GetNatGatewayConvertStatusResponseBody {
	s.RequestId = &v
	return s
}

type GetNatGatewayConvertStatusResponseBodyConvertSteps struct {
	// Valid values:
	//
	// *   **init**: initializing
	// *   **check**: checking configurations
	// *   **configure**: pushing configurations
	// *   **activate**: switching
	// *   **conf_delete**: deleting configurations
	// *   **rollback**: rolling back
	// *   **end_success**: switched
	// *   **end_fail**: failed
	StepName *string `json:"StepName,omitempty" xml:"StepName,omitempty"`
	// The time when the switch started.
	StepStartTime *string `json:"StepStartTime,omitempty" xml:"StepStartTime,omitempty"`
	// The switch status. Valid values:
	//
	// *   **processing**: switching
	// *   **successful**: switched
	// *   **failed**: failed
	StepStatus *string `json:"StepStatus,omitempty" xml:"StepStatus,omitempty"`
}

func (s GetNatGatewayConvertStatusResponseBodyConvertSteps) String() string {
	return tea.Prettify(s)
}

func (s GetNatGatewayConvertStatusResponseBodyConvertSteps) GoString() string {
	return s.String()
}

func (s *GetNatGatewayConvertStatusResponseBodyConvertSteps) SetStepName(v string) *GetNatGatewayConvertStatusResponseBodyConvertSteps {
	s.StepName = &v
	return s
}

func (s *GetNatGatewayConvertStatusResponseBodyConvertSteps) SetStepStartTime(v string) *GetNatGatewayConvertStatusResponseBodyConvertSteps {
	s.StepStartTime = &v
	return s
}

func (s *GetNatGatewayConvertStatusResponseBodyConvertSteps) SetStepStatus(v string) *GetNatGatewayConvertStatusResponseBodyConvertSteps {
	s.StepStatus = &v
	return s
}

type GetNatGatewayConvertStatusResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetNatGatewayConvertStatusResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetNatGatewayConvertStatusResponse) String() string {
	return tea.Prettify(s)
}

func (s GetNatGatewayConvertStatusResponse) GoString() string {
	return s.String()
}

func (s *GetNatGatewayConvertStatusResponse) SetHeaders(v map[string]*string) *GetNatGatewayConvertStatusResponse {
	s.Headers = v
	return s
}

func (s *GetNatGatewayConvertStatusResponse) SetStatusCode(v int32) *GetNatGatewayConvertStatusResponse {
	s.StatusCode = &v
	return s
}

func (s *GetNatGatewayConvertStatusResponse) SetBody(v *GetNatGatewayConvertStatusResponseBody) *GetNatGatewayConvertStatusResponse {
	s.Body = v
	return s
}

type GetPhysicalConnectionServiceStatusRequest struct {
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region for which you want to query the status of outbound data transfer billing.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s GetPhysicalConnectionServiceStatusRequest) String() string {
	return tea.Prettify(s)
}

func (s GetPhysicalConnectionServiceStatusRequest) GoString() string {
	return s.String()
}

func (s *GetPhysicalConnectionServiceStatusRequest) SetOwnerAccount(v string) *GetPhysicalConnectionServiceStatusRequest {
	s.OwnerAccount = &v
	return s
}

func (s *GetPhysicalConnectionServiceStatusRequest) SetOwnerId(v int64) *GetPhysicalConnectionServiceStatusRequest {
	s.OwnerId = &v
	return s
}

func (s *GetPhysicalConnectionServiceStatusRequest) SetRegionId(v string) *GetPhysicalConnectionServiceStatusRequest {
	s.RegionId = &v
	return s
}

func (s *GetPhysicalConnectionServiceStatusRequest) SetResourceOwnerAccount(v string) *GetPhysicalConnectionServiceStatusRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *GetPhysicalConnectionServiceStatusRequest) SetResourceOwnerId(v int64) *GetPhysicalConnectionServiceStatusRequest {
	s.ResourceOwnerId = &v
	return s
}

type GetPhysicalConnectionServiceStatusResponseBody struct {
	// Indicates whether billing for outbound data transfer is enabled. Valid values:
	//
	// *   **true**: yes
	// *   **false**: no
	Enabled *bool `json:"Enabled,omitempty" xml:"Enabled,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetPhysicalConnectionServiceStatusResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetPhysicalConnectionServiceStatusResponseBody) GoString() string {
	return s.String()
}

func (s *GetPhysicalConnectionServiceStatusResponseBody) SetEnabled(v bool) *GetPhysicalConnectionServiceStatusResponseBody {
	s.Enabled = &v
	return s
}

func (s *GetPhysicalConnectionServiceStatusResponseBody) SetRequestId(v string) *GetPhysicalConnectionServiceStatusResponseBody {
	s.RequestId = &v
	return s
}

type GetPhysicalConnectionServiceStatusResponse struct {
	Headers    map[string]*string                              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetPhysicalConnectionServiceStatusResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetPhysicalConnectionServiceStatusResponse) String() string {
	return tea.Prettify(s)
}

func (s GetPhysicalConnectionServiceStatusResponse) GoString() string {
	return s.String()
}

func (s *GetPhysicalConnectionServiceStatusResponse) SetHeaders(v map[string]*string) *GetPhysicalConnectionServiceStatusResponse {
	s.Headers = v
	return s
}

func (s *GetPhysicalConnectionServiceStatusResponse) SetStatusCode(v int32) *GetPhysicalConnectionServiceStatusResponse {
	s.StatusCode = &v
	return s
}

func (s *GetPhysicalConnectionServiceStatusResponse) SetBody(v *GetPhysicalConnectionServiceStatusResponseBody) *GetPhysicalConnectionServiceStatusResponse {
	s.Body = v
	return s
}

type GetTrafficMirrorServiceStatusRequest struct {
	ClientToken          *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s GetTrafficMirrorServiceStatusRequest) String() string {
	return tea.Prettify(s)
}

func (s GetTrafficMirrorServiceStatusRequest) GoString() string {
	return s.String()
}

func (s *GetTrafficMirrorServiceStatusRequest) SetClientToken(v string) *GetTrafficMirrorServiceStatusRequest {
	s.ClientToken = &v
	return s
}

func (s *GetTrafficMirrorServiceStatusRequest) SetOwnerAccount(v string) *GetTrafficMirrorServiceStatusRequest {
	s.OwnerAccount = &v
	return s
}

func (s *GetTrafficMirrorServiceStatusRequest) SetOwnerId(v int64) *GetTrafficMirrorServiceStatusRequest {
	s.OwnerId = &v
	return s
}

func (s *GetTrafficMirrorServiceStatusRequest) SetRegionId(v string) *GetTrafficMirrorServiceStatusRequest {
	s.RegionId = &v
	return s
}

func (s *GetTrafficMirrorServiceStatusRequest) SetResourceOwnerAccount(v string) *GetTrafficMirrorServiceStatusRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *GetTrafficMirrorServiceStatusRequest) SetResourceOwnerId(v int64) *GetTrafficMirrorServiceStatusRequest {
	s.ResourceOwnerId = &v
	return s
}

type GetTrafficMirrorServiceStatusResponseBody struct {
	// Indicates whether the traffic mirroring feature is enabled. Valid values:
	//
	// *   **true**: enabled
	// *   **false**: disabled
	Enabled *bool `json:"Enabled,omitempty" xml:"Enabled,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetTrafficMirrorServiceStatusResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetTrafficMirrorServiceStatusResponseBody) GoString() string {
	return s.String()
}

func (s *GetTrafficMirrorServiceStatusResponseBody) SetEnabled(v bool) *GetTrafficMirrorServiceStatusResponseBody {
	s.Enabled = &v
	return s
}

func (s *GetTrafficMirrorServiceStatusResponseBody) SetRequestId(v string) *GetTrafficMirrorServiceStatusResponseBody {
	s.RequestId = &v
	return s
}

type GetTrafficMirrorServiceStatusResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetTrafficMirrorServiceStatusResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetTrafficMirrorServiceStatusResponse) String() string {
	return tea.Prettify(s)
}

func (s GetTrafficMirrorServiceStatusResponse) GoString() string {
	return s.String()
}

func (s *GetTrafficMirrorServiceStatusResponse) SetHeaders(v map[string]*string) *GetTrafficMirrorServiceStatusResponse {
	s.Headers = v
	return s
}

func (s *GetTrafficMirrorServiceStatusResponse) SetStatusCode(v int32) *GetTrafficMirrorServiceStatusResponse {
	s.StatusCode = &v
	return s
}

func (s *GetTrafficMirrorServiceStatusResponse) SetBody(v *GetTrafficMirrorServiceStatusResponseBody) *GetTrafficMirrorServiceStatusResponse {
	s.Body = v
	return s
}

type GetVpcGatewayEndpointAttributeRequest struct {
	// The ID of the gateway endpoint.
	EndpointId   *string `json:"EndpointId,omitempty" xml:"EndpointId,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the gateway endpoint.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s GetVpcGatewayEndpointAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s GetVpcGatewayEndpointAttributeRequest) GoString() string {
	return s.String()
}

func (s *GetVpcGatewayEndpointAttributeRequest) SetEndpointId(v string) *GetVpcGatewayEndpointAttributeRequest {
	s.EndpointId = &v
	return s
}

func (s *GetVpcGatewayEndpointAttributeRequest) SetOwnerAccount(v string) *GetVpcGatewayEndpointAttributeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *GetVpcGatewayEndpointAttributeRequest) SetOwnerId(v int64) *GetVpcGatewayEndpointAttributeRequest {
	s.OwnerId = &v
	return s
}

func (s *GetVpcGatewayEndpointAttributeRequest) SetRegionId(v string) *GetVpcGatewayEndpointAttributeRequest {
	s.RegionId = &v
	return s
}

func (s *GetVpcGatewayEndpointAttributeRequest) SetResourceOwnerAccount(v string) *GetVpcGatewayEndpointAttributeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *GetVpcGatewayEndpointAttributeRequest) SetResourceOwnerId(v int64) *GetVpcGatewayEndpointAttributeRequest {
	s.ResourceOwnerId = &v
	return s
}

type GetVpcGatewayEndpointAttributeResponseBody struct {
	// The time when the endpoint was created. The time follows the ISO 8601 standard in UTC in the YYYY-MM-DDThh:mm:ssZ format.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The description of the gateway endpoint.
	EndpointDescription *string `json:"EndpointDescription,omitempty" xml:"EndpointDescription,omitempty"`
	// The ID of the gateway endpoint.
	EndpointId *string `json:"EndpointId,omitempty" xml:"EndpointId,omitempty"`
	// The name of the gateway endpoint.
	EndpointName *string `json:"EndpointName,omitempty" xml:"EndpointName,omitempty"`
	// The status of the gateway endpoint. Valid values:
	//
	// *   **Creating**: being created
	// *   **Created**: created
	// *   **Modifying**: being modified
	// *   **Associating**: being associated
	// *   **Dissociating**: being disassociated
	// *   **Deleting**: being deleted
	EndpointStatus *string `json:"EndpointStatus,omitempty" xml:"EndpointStatus,omitempty"`
	// The access policy for the cloud service.
	PolicyDocument *string `json:"PolicyDocument,omitempty" xml:"PolicyDocument,omitempty"`
	// The ID of the request.
	RequestId       *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The ID of the route table associated with the gateway endpoint.
	RouteTables []*string `json:"RouteTables,omitempty" xml:"RouteTables,omitempty" type:"Repeated"`
	// The name of the endpoint service.
	ServiceName *string                                           `json:"ServiceName,omitempty" xml:"ServiceName,omitempty"`
	Tags        []*GetVpcGatewayEndpointAttributeResponseBodyTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
	// The ID of the virtual private cloud (VPC) to which the gateway endpoint belongs.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s GetVpcGatewayEndpointAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetVpcGatewayEndpointAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *GetVpcGatewayEndpointAttributeResponseBody) SetCreationTime(v string) *GetVpcGatewayEndpointAttributeResponseBody {
	s.CreationTime = &v
	return s
}

func (s *GetVpcGatewayEndpointAttributeResponseBody) SetEndpointDescription(v string) *GetVpcGatewayEndpointAttributeResponseBody {
	s.EndpointDescription = &v
	return s
}

func (s *GetVpcGatewayEndpointAttributeResponseBody) SetEndpointId(v string) *GetVpcGatewayEndpointAttributeResponseBody {
	s.EndpointId = &v
	return s
}

func (s *GetVpcGatewayEndpointAttributeResponseBody) SetEndpointName(v string) *GetVpcGatewayEndpointAttributeResponseBody {
	s.EndpointName = &v
	return s
}

func (s *GetVpcGatewayEndpointAttributeResponseBody) SetEndpointStatus(v string) *GetVpcGatewayEndpointAttributeResponseBody {
	s.EndpointStatus = &v
	return s
}

func (s *GetVpcGatewayEndpointAttributeResponseBody) SetPolicyDocument(v string) *GetVpcGatewayEndpointAttributeResponseBody {
	s.PolicyDocument = &v
	return s
}

func (s *GetVpcGatewayEndpointAttributeResponseBody) SetRequestId(v string) *GetVpcGatewayEndpointAttributeResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetVpcGatewayEndpointAttributeResponseBody) SetResourceGroupId(v string) *GetVpcGatewayEndpointAttributeResponseBody {
	s.ResourceGroupId = &v
	return s
}

func (s *GetVpcGatewayEndpointAttributeResponseBody) SetRouteTables(v []*string) *GetVpcGatewayEndpointAttributeResponseBody {
	s.RouteTables = v
	return s
}

func (s *GetVpcGatewayEndpointAttributeResponseBody) SetServiceName(v string) *GetVpcGatewayEndpointAttributeResponseBody {
	s.ServiceName = &v
	return s
}

func (s *GetVpcGatewayEndpointAttributeResponseBody) SetTags(v []*GetVpcGatewayEndpointAttributeResponseBodyTags) *GetVpcGatewayEndpointAttributeResponseBody {
	s.Tags = v
	return s
}

func (s *GetVpcGatewayEndpointAttributeResponseBody) SetVpcId(v string) *GetVpcGatewayEndpointAttributeResponseBody {
	s.VpcId = &v
	return s
}

type GetVpcGatewayEndpointAttributeResponseBodyTags struct {
	Key   *string `json:"Key,omitempty" xml:"Key,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s GetVpcGatewayEndpointAttributeResponseBodyTags) String() string {
	return tea.Prettify(s)
}

func (s GetVpcGatewayEndpointAttributeResponseBodyTags) GoString() string {
	return s.String()
}

func (s *GetVpcGatewayEndpointAttributeResponseBodyTags) SetKey(v string) *GetVpcGatewayEndpointAttributeResponseBodyTags {
	s.Key = &v
	return s
}

func (s *GetVpcGatewayEndpointAttributeResponseBodyTags) SetValue(v string) *GetVpcGatewayEndpointAttributeResponseBodyTags {
	s.Value = &v
	return s
}

type GetVpcGatewayEndpointAttributeResponse struct {
	Headers    map[string]*string                          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetVpcGatewayEndpointAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetVpcGatewayEndpointAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s GetVpcGatewayEndpointAttributeResponse) GoString() string {
	return s.String()
}

func (s *GetVpcGatewayEndpointAttributeResponse) SetHeaders(v map[string]*string) *GetVpcGatewayEndpointAttributeResponse {
	s.Headers = v
	return s
}

func (s *GetVpcGatewayEndpointAttributeResponse) SetStatusCode(v int32) *GetVpcGatewayEndpointAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *GetVpcGatewayEndpointAttributeResponse) SetBody(v *GetVpcGatewayEndpointAttributeResponseBody) *GetVpcGatewayEndpointAttributeResponse {
	s.Body = v
	return s
}

type GetVpcPrefixListAssociationsRequest struct {
	// The number of entries to return on each page. Valid values: **1** to **100**. Default value: **20**.
	MaxResults *int64 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The token that determines the start point of the next query. Valid values:
	//
	// *   If this is your first query and no next queries are to be sent, ignore this parameter.
	// *   If a next query is to be performed, set the value to the NextToken value returned in the last call to the ListListenerCertificates operation.
	NextToken    *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the prefix list that you want to query.
	PrefixListId *string `json:"PrefixListId,omitempty" xml:"PrefixListId,omitempty"`
	// The region ID of the prefix list.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s GetVpcPrefixListAssociationsRequest) String() string {
	return tea.Prettify(s)
}

func (s GetVpcPrefixListAssociationsRequest) GoString() string {
	return s.String()
}

func (s *GetVpcPrefixListAssociationsRequest) SetMaxResults(v int64) *GetVpcPrefixListAssociationsRequest {
	s.MaxResults = &v
	return s
}

func (s *GetVpcPrefixListAssociationsRequest) SetNextToken(v string) *GetVpcPrefixListAssociationsRequest {
	s.NextToken = &v
	return s
}

func (s *GetVpcPrefixListAssociationsRequest) SetOwnerAccount(v string) *GetVpcPrefixListAssociationsRequest {
	s.OwnerAccount = &v
	return s
}

func (s *GetVpcPrefixListAssociationsRequest) SetOwnerId(v int64) *GetVpcPrefixListAssociationsRequest {
	s.OwnerId = &v
	return s
}

func (s *GetVpcPrefixListAssociationsRequest) SetPrefixListId(v string) *GetVpcPrefixListAssociationsRequest {
	s.PrefixListId = &v
	return s
}

func (s *GetVpcPrefixListAssociationsRequest) SetRegionId(v string) *GetVpcPrefixListAssociationsRequest {
	s.RegionId = &v
	return s
}

func (s *GetVpcPrefixListAssociationsRequest) SetResourceOwnerAccount(v string) *GetVpcPrefixListAssociationsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *GetVpcPrefixListAssociationsRequest) SetResourceOwnerId(v int64) *GetVpcPrefixListAssociationsRequest {
	s.ResourceOwnerId = &v
	return s
}

type GetVpcPrefixListAssociationsResponseBody struct {
	// The number of entries returned.
	Count *int64 `json:"Count,omitempty" xml:"Count,omitempty"`
	// The token that determines the start point of the next query. Valid values:
	//
	// *   If no value is returned for **NextToken**, no next queries are sent.
	// *   If **NextToken** is not empty, the value indicates the token that is used for the next query.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The information about the network instances that are associated with the prefix list.
	PrefixListAssociation []*GetVpcPrefixListAssociationsResponseBodyPrefixListAssociation `json:"PrefixListAssociation,omitempty" xml:"PrefixListAssociation,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s GetVpcPrefixListAssociationsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetVpcPrefixListAssociationsResponseBody) GoString() string {
	return s.String()
}

func (s *GetVpcPrefixListAssociationsResponseBody) SetCount(v int64) *GetVpcPrefixListAssociationsResponseBody {
	s.Count = &v
	return s
}

func (s *GetVpcPrefixListAssociationsResponseBody) SetNextToken(v string) *GetVpcPrefixListAssociationsResponseBody {
	s.NextToken = &v
	return s
}

func (s *GetVpcPrefixListAssociationsResponseBody) SetPrefixListAssociation(v []*GetVpcPrefixListAssociationsResponseBodyPrefixListAssociation) *GetVpcPrefixListAssociationsResponseBody {
	s.PrefixListAssociation = v
	return s
}

func (s *GetVpcPrefixListAssociationsResponseBody) SetRequestId(v string) *GetVpcPrefixListAssociationsResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetVpcPrefixListAssociationsResponseBody) SetTotalCount(v int64) *GetVpcPrefixListAssociationsResponseBody {
	s.TotalCount = &v
	return s
}

type GetVpcPrefixListAssociationsResponseBodyPrefixListAssociation struct {
	// The ID of the Alibaba Cloud account to which the prefix list belongs.
	OwnerId *string `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the prefix list.
	PrefixListId *string `json:"PrefixListId,omitempty" xml:"PrefixListId,omitempty"`
	// The reason why the association failed.
	Reason *string `json:"Reason,omitempty" xml:"Reason,omitempty"`
	// The region ID of the prefix list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the associated resource.
	ResourceId *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	// The type of the associated resource. Valid values:
	//
	// *   **vpcRouteTable** :VPC route table.
	// *   **trRouteTable**: route table of a transit router.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The ID of the Alibaba Cloud account to which the resource associated with the prefix list belongs.
	ResourceUid *string `json:"ResourceUid,omitempty" xml:"ResourceUid,omitempty"`
	// The status of the prefix list. Valid values:
	//
	// *   **Created**
	// *   **ModifyFailed**
	// *   **Creating**
	// *   **Modifying**
	// *   **Deleting**
	// *   **Deleted**
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s GetVpcPrefixListAssociationsResponseBodyPrefixListAssociation) String() string {
	return tea.Prettify(s)
}

func (s GetVpcPrefixListAssociationsResponseBodyPrefixListAssociation) GoString() string {
	return s.String()
}

func (s *GetVpcPrefixListAssociationsResponseBodyPrefixListAssociation) SetOwnerId(v string) *GetVpcPrefixListAssociationsResponseBodyPrefixListAssociation {
	s.OwnerId = &v
	return s
}

func (s *GetVpcPrefixListAssociationsResponseBodyPrefixListAssociation) SetPrefixListId(v string) *GetVpcPrefixListAssociationsResponseBodyPrefixListAssociation {
	s.PrefixListId = &v
	return s
}

func (s *GetVpcPrefixListAssociationsResponseBodyPrefixListAssociation) SetReason(v string) *GetVpcPrefixListAssociationsResponseBodyPrefixListAssociation {
	s.Reason = &v
	return s
}

func (s *GetVpcPrefixListAssociationsResponseBodyPrefixListAssociation) SetRegionId(v string) *GetVpcPrefixListAssociationsResponseBodyPrefixListAssociation {
	s.RegionId = &v
	return s
}

func (s *GetVpcPrefixListAssociationsResponseBodyPrefixListAssociation) SetResourceId(v string) *GetVpcPrefixListAssociationsResponseBodyPrefixListAssociation {
	s.ResourceId = &v
	return s
}

func (s *GetVpcPrefixListAssociationsResponseBodyPrefixListAssociation) SetResourceType(v string) *GetVpcPrefixListAssociationsResponseBodyPrefixListAssociation {
	s.ResourceType = &v
	return s
}

func (s *GetVpcPrefixListAssociationsResponseBodyPrefixListAssociation) SetResourceUid(v string) *GetVpcPrefixListAssociationsResponseBodyPrefixListAssociation {
	s.ResourceUid = &v
	return s
}

func (s *GetVpcPrefixListAssociationsResponseBodyPrefixListAssociation) SetStatus(v string) *GetVpcPrefixListAssociationsResponseBodyPrefixListAssociation {
	s.Status = &v
	return s
}

type GetVpcPrefixListAssociationsResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetVpcPrefixListAssociationsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetVpcPrefixListAssociationsResponse) String() string {
	return tea.Prettify(s)
}

func (s GetVpcPrefixListAssociationsResponse) GoString() string {
	return s.String()
}

func (s *GetVpcPrefixListAssociationsResponse) SetHeaders(v map[string]*string) *GetVpcPrefixListAssociationsResponse {
	s.Headers = v
	return s
}

func (s *GetVpcPrefixListAssociationsResponse) SetStatusCode(v int32) *GetVpcPrefixListAssociationsResponse {
	s.StatusCode = &v
	return s
}

func (s *GetVpcPrefixListAssociationsResponse) SetBody(v *GetVpcPrefixListAssociationsResponseBody) *GetVpcPrefixListAssociationsResponse {
	s.Body = v
	return s
}

type GetVpcPrefixListEntriesRequest struct {
	// The number of entries to return on each page. Valid values: **1** to **100**. Default value: **20**.
	MaxResults *int64 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The token that is used for the next query. Valid values:
	//
	// *   If this is your first query and no next queries are to be sent, ignore this parameter.
	// *   If a next query is to be performed, set the value to the NextToken value returned in the last call to the ListenerCertificates operation.
	NextToken    *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the prefix list that you want to query.
	PrefixListId *string `json:"PrefixListId,omitempty" xml:"PrefixListId,omitempty"`
	// The region ID of the prefix list.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query available regions.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s GetVpcPrefixListEntriesRequest) String() string {
	return tea.Prettify(s)
}

func (s GetVpcPrefixListEntriesRequest) GoString() string {
	return s.String()
}

func (s *GetVpcPrefixListEntriesRequest) SetMaxResults(v int64) *GetVpcPrefixListEntriesRequest {
	s.MaxResults = &v
	return s
}

func (s *GetVpcPrefixListEntriesRequest) SetNextToken(v string) *GetVpcPrefixListEntriesRequest {
	s.NextToken = &v
	return s
}

func (s *GetVpcPrefixListEntriesRequest) SetOwnerAccount(v string) *GetVpcPrefixListEntriesRequest {
	s.OwnerAccount = &v
	return s
}

func (s *GetVpcPrefixListEntriesRequest) SetOwnerId(v int64) *GetVpcPrefixListEntriesRequest {
	s.OwnerId = &v
	return s
}

func (s *GetVpcPrefixListEntriesRequest) SetPrefixListId(v string) *GetVpcPrefixListEntriesRequest {
	s.PrefixListId = &v
	return s
}

func (s *GetVpcPrefixListEntriesRequest) SetRegionId(v string) *GetVpcPrefixListEntriesRequest {
	s.RegionId = &v
	return s
}

func (s *GetVpcPrefixListEntriesRequest) SetResourceOwnerAccount(v string) *GetVpcPrefixListEntriesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *GetVpcPrefixListEntriesRequest) SetResourceOwnerId(v int64) *GetVpcPrefixListEntriesRequest {
	s.ResourceOwnerId = &v
	return s
}

type GetVpcPrefixListEntriesResponseBody struct {
	// The number of entries.
	Count *int64 `json:"Count,omitempty" xml:"Count,omitempty"`
	// The token that is used for the next query. Valid values:
	//
	// *   If no value is returned for **NextToken**, no next queries are sent.
	// *   If **NextToken** is not empty, the value indicates the token that is used for the next query.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The information about the prefix list.
	PrefixListEntry []*GetVpcPrefixListEntriesResponseBodyPrefixListEntry `json:"PrefixListEntry,omitempty" xml:"PrefixListEntry,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s GetVpcPrefixListEntriesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetVpcPrefixListEntriesResponseBody) GoString() string {
	return s.String()
}

func (s *GetVpcPrefixListEntriesResponseBody) SetCount(v int64) *GetVpcPrefixListEntriesResponseBody {
	s.Count = &v
	return s
}

func (s *GetVpcPrefixListEntriesResponseBody) SetNextToken(v string) *GetVpcPrefixListEntriesResponseBody {
	s.NextToken = &v
	return s
}

func (s *GetVpcPrefixListEntriesResponseBody) SetPrefixListEntry(v []*GetVpcPrefixListEntriesResponseBodyPrefixListEntry) *GetVpcPrefixListEntriesResponseBody {
	s.PrefixListEntry = v
	return s
}

func (s *GetVpcPrefixListEntriesResponseBody) SetRequestId(v string) *GetVpcPrefixListEntriesResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetVpcPrefixListEntriesResponseBody) SetTotalCount(v int64) *GetVpcPrefixListEntriesResponseBody {
	s.TotalCount = &v
	return s
}

type GetVpcPrefixListEntriesResponseBodyPrefixListEntry struct {
	// The CIDR blocks specified in the prefix list.
	Cidr *string `json:"Cidr,omitempty" xml:"Cidr,omitempty"`
	// The description of the prefix list.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the prefix list.
	PrefixListId *string `json:"PrefixListId,omitempty" xml:"PrefixListId,omitempty"`
	// The region ID of the prefix list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s GetVpcPrefixListEntriesResponseBodyPrefixListEntry) String() string {
	return tea.Prettify(s)
}

func (s GetVpcPrefixListEntriesResponseBodyPrefixListEntry) GoString() string {
	return s.String()
}

func (s *GetVpcPrefixListEntriesResponseBodyPrefixListEntry) SetCidr(v string) *GetVpcPrefixListEntriesResponseBodyPrefixListEntry {
	s.Cidr = &v
	return s
}

func (s *GetVpcPrefixListEntriesResponseBodyPrefixListEntry) SetDescription(v string) *GetVpcPrefixListEntriesResponseBodyPrefixListEntry {
	s.Description = &v
	return s
}

func (s *GetVpcPrefixListEntriesResponseBodyPrefixListEntry) SetPrefixListId(v string) *GetVpcPrefixListEntriesResponseBodyPrefixListEntry {
	s.PrefixListId = &v
	return s
}

func (s *GetVpcPrefixListEntriesResponseBodyPrefixListEntry) SetRegionId(v string) *GetVpcPrefixListEntriesResponseBodyPrefixListEntry {
	s.RegionId = &v
	return s
}

type GetVpcPrefixListEntriesResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetVpcPrefixListEntriesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetVpcPrefixListEntriesResponse) String() string {
	return tea.Prettify(s)
}

func (s GetVpcPrefixListEntriesResponse) GoString() string {
	return s.String()
}

func (s *GetVpcPrefixListEntriesResponse) SetHeaders(v map[string]*string) *GetVpcPrefixListEntriesResponse {
	s.Headers = v
	return s
}

func (s *GetVpcPrefixListEntriesResponse) SetStatusCode(v int32) *GetVpcPrefixListEntriesResponse {
	s.StatusCode = &v
	return s
}

func (s *GetVpcPrefixListEntriesResponse) SetBody(v *GetVpcPrefixListEntriesResponseBody) *GetVpcPrefixListEntriesResponse {
	s.Body = v
	return s
}

type GetVpcRouteEntrySummaryRequest struct {
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the route table.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The type of the route. Valid values:
	//
	// *   **All**: all route types
	// *   **Custom**: a custom route
	// *   **System**: a system route
	// *   **BGP**: a BGP route
	// *   **CEN**: a Cloud Enterprise Network (CEN) route
	RouteEntryType *string `json:"RouteEntryType,omitempty" xml:"RouteEntryType,omitempty"`
	// The ID of the route table that you want to query.
	RouteTableId *string `json:"RouteTableId,omitempty" xml:"RouteTableId,omitempty"`
	// The ID of the virtual private cloud (VPC) to which the route table belongs.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s GetVpcRouteEntrySummaryRequest) String() string {
	return tea.Prettify(s)
}

func (s GetVpcRouteEntrySummaryRequest) GoString() string {
	return s.String()
}

func (s *GetVpcRouteEntrySummaryRequest) SetOwnerAccount(v string) *GetVpcRouteEntrySummaryRequest {
	s.OwnerAccount = &v
	return s
}

func (s *GetVpcRouteEntrySummaryRequest) SetOwnerId(v int64) *GetVpcRouteEntrySummaryRequest {
	s.OwnerId = &v
	return s
}

func (s *GetVpcRouteEntrySummaryRequest) SetRegionId(v string) *GetVpcRouteEntrySummaryRequest {
	s.RegionId = &v
	return s
}

func (s *GetVpcRouteEntrySummaryRequest) SetResourceOwnerAccount(v string) *GetVpcRouteEntrySummaryRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *GetVpcRouteEntrySummaryRequest) SetResourceOwnerId(v int64) *GetVpcRouteEntrySummaryRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *GetVpcRouteEntrySummaryRequest) SetRouteEntryType(v string) *GetVpcRouteEntrySummaryRequest {
	s.RouteEntryType = &v
	return s
}

func (s *GetVpcRouteEntrySummaryRequest) SetRouteTableId(v string) *GetVpcRouteEntrySummaryRequest {
	s.RouteTableId = &v
	return s
}

func (s *GetVpcRouteEntrySummaryRequest) SetVpcId(v string) *GetVpcRouteEntrySummaryRequest {
	s.VpcId = &v
	return s
}

type GetVpcRouteEntrySummaryResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The information about the routes in the route tables.
	RouteEntrySummarys []*GetVpcRouteEntrySummaryResponseBodyRouteEntrySummarys `json:"RouteEntrySummarys,omitempty" xml:"RouteEntrySummarys,omitempty" type:"Repeated"`
}

func (s GetVpcRouteEntrySummaryResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetVpcRouteEntrySummaryResponseBody) GoString() string {
	return s.String()
}

func (s *GetVpcRouteEntrySummaryResponseBody) SetRequestId(v string) *GetVpcRouteEntrySummaryResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetVpcRouteEntrySummaryResponseBody) SetRouteEntrySummarys(v []*GetVpcRouteEntrySummaryResponseBodyRouteEntrySummarys) *GetVpcRouteEntrySummaryResponseBody {
	s.RouteEntrySummarys = v
	return s
}

type GetVpcRouteEntrySummaryResponseBodyRouteEntrySummarys struct {
	// The information about the routes of different types in one route table.
	EntrySummarys []*GetVpcRouteEntrySummaryResponseBodyRouteEntrySummarysEntrySummarys `json:"EntrySummarys,omitempty" xml:"EntrySummarys,omitempty" type:"Repeated"`
	// The ID of the route table.
	RouteTableId *string `json:"RouteTableId,omitempty" xml:"RouteTableId,omitempty"`
}

func (s GetVpcRouteEntrySummaryResponseBodyRouteEntrySummarys) String() string {
	return tea.Prettify(s)
}

func (s GetVpcRouteEntrySummaryResponseBodyRouteEntrySummarys) GoString() string {
	return s.String()
}

func (s *GetVpcRouteEntrySummaryResponseBodyRouteEntrySummarys) SetEntrySummarys(v []*GetVpcRouteEntrySummaryResponseBodyRouteEntrySummarysEntrySummarys) *GetVpcRouteEntrySummaryResponseBodyRouteEntrySummarys {
	s.EntrySummarys = v
	return s
}

func (s *GetVpcRouteEntrySummaryResponseBodyRouteEntrySummarys) SetRouteTableId(v string) *GetVpcRouteEntrySummaryResponseBodyRouteEntrySummarys {
	s.RouteTableId = &v
	return s
}

type GetVpcRouteEntrySummaryResponseBodyRouteEntrySummarysEntrySummarys struct {
	// The number of entries returned.
	Count *int32 `json:"Count,omitempty" xml:"Count,omitempty"`
	// The type of the route. Valid values:
	//
	// *   **All**: all route types
	// *   **Custom**: a custom route
	// *   **System**: a system route
	// *   **BGP**: a BGP route
	// *   **CEN**: a CEN route
	RouteEntryType *string `json:"RouteEntryType,omitempty" xml:"RouteEntryType,omitempty"`
}

func (s GetVpcRouteEntrySummaryResponseBodyRouteEntrySummarysEntrySummarys) String() string {
	return tea.Prettify(s)
}

func (s GetVpcRouteEntrySummaryResponseBodyRouteEntrySummarysEntrySummarys) GoString() string {
	return s.String()
}

func (s *GetVpcRouteEntrySummaryResponseBodyRouteEntrySummarysEntrySummarys) SetCount(v int32) *GetVpcRouteEntrySummaryResponseBodyRouteEntrySummarysEntrySummarys {
	s.Count = &v
	return s
}

func (s *GetVpcRouteEntrySummaryResponseBodyRouteEntrySummarysEntrySummarys) SetRouteEntryType(v string) *GetVpcRouteEntrySummaryResponseBodyRouteEntrySummarysEntrySummarys {
	s.RouteEntryType = &v
	return s
}

type GetVpcRouteEntrySummaryResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetVpcRouteEntrySummaryResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetVpcRouteEntrySummaryResponse) String() string {
	return tea.Prettify(s)
}

func (s GetVpcRouteEntrySummaryResponse) GoString() string {
	return s.String()
}

func (s *GetVpcRouteEntrySummaryResponse) SetHeaders(v map[string]*string) *GetVpcRouteEntrySummaryResponse {
	s.Headers = v
	return s
}

func (s *GetVpcRouteEntrySummaryResponse) SetStatusCode(v int32) *GetVpcRouteEntrySummaryResponse {
	s.StatusCode = &v
	return s
}

func (s *GetVpcRouteEntrySummaryResponse) SetBody(v *GetVpcRouteEntrySummaryResponseBody) *GetVpcRouteEntrySummaryResponse {
	s.Body = v
	return s
}

type GetVpnGatewayDiagnoseResultRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. ClientToken can contain only ASCII characters.
	//
	// >  If you do not set this parameter, ClientToken is set to the value of RequestId. The ID of each request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the diagnostic.
	//
	// When you call the [DiagnoseVpnGateway](~~469751~~) operation, the system returns a corresponding ID.
	DiagnoseId *string `json:"DiagnoseId,omitempty" xml:"DiagnoseId,omitempty"`
	// The region ID of the VPN gateway.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to obtain the region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the VPN gateway.
	VpnGatewayId *string `json:"VpnGatewayId,omitempty" xml:"VpnGatewayId,omitempty"`
}

func (s GetVpnGatewayDiagnoseResultRequest) String() string {
	return tea.Prettify(s)
}

func (s GetVpnGatewayDiagnoseResultRequest) GoString() string {
	return s.String()
}

func (s *GetVpnGatewayDiagnoseResultRequest) SetClientToken(v string) *GetVpnGatewayDiagnoseResultRequest {
	s.ClientToken = &v
	return s
}

func (s *GetVpnGatewayDiagnoseResultRequest) SetDiagnoseId(v string) *GetVpnGatewayDiagnoseResultRequest {
	s.DiagnoseId = &v
	return s
}

func (s *GetVpnGatewayDiagnoseResultRequest) SetRegionId(v string) *GetVpnGatewayDiagnoseResultRequest {
	s.RegionId = &v
	return s
}

func (s *GetVpnGatewayDiagnoseResultRequest) SetVpnGatewayId(v string) *GetVpnGatewayDiagnoseResultRequest {
	s.VpnGatewayId = &v
	return s
}

type GetVpnGatewayDiagnoseResultResponseBody struct {
	// The time when the diagnostic started.
	//
	// The time follows the ISO8601 standard in the `YYYY-MM-DDThh:mm:ssZ` format. The time is displayed in UTC.
	BeginTime *string `json:"BeginTime,omitempty" xml:"BeginTime,omitempty"`
	// The ID of the diagnostic.
	DiagnoseId *string `json:"DiagnoseId,omitempty" xml:"DiagnoseId,omitempty"`
	// The information about the diagnostic items.
	DiagnoseResult []*GetVpnGatewayDiagnoseResultResponseBodyDiagnoseResult `json:"DiagnoseResult,omitempty" xml:"DiagnoseResult,omitempty" type:"Repeated"`
	// The timestamp when the system finishes diagnosing the item.
	//
	// The time follows the ISO8601 standard in the `YYYY-MM-DDThh:mm:ssZ` format. The time is displayed in UTC.
	FinishTime *string `json:"FinishTime,omitempty" xml:"FinishTime,omitempty"`
	// The number of diagnostic items that have been diagnosed.
	FinishedCount *int32 `json:"FinishedCount,omitempty" xml:"FinishedCount,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the resource that is diagnosed.
	ResourceInstanceId *string `json:"ResourceInstanceId,omitempty" xml:"ResourceInstanceId,omitempty"`
	// The type of the resource.
	//
	// The value is set to **IPsec**, which indicates an IPsec-VPN connection.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The total number of diagnostic items.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
	// The ID of the VPN gateway.
	VpnGatewayId *string `json:"VpnGatewayId,omitempty" xml:"VpnGatewayId,omitempty"`
}

func (s GetVpnGatewayDiagnoseResultResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetVpnGatewayDiagnoseResultResponseBody) GoString() string {
	return s.String()
}

func (s *GetVpnGatewayDiagnoseResultResponseBody) SetBeginTime(v string) *GetVpnGatewayDiagnoseResultResponseBody {
	s.BeginTime = &v
	return s
}

func (s *GetVpnGatewayDiagnoseResultResponseBody) SetDiagnoseId(v string) *GetVpnGatewayDiagnoseResultResponseBody {
	s.DiagnoseId = &v
	return s
}

func (s *GetVpnGatewayDiagnoseResultResponseBody) SetDiagnoseResult(v []*GetVpnGatewayDiagnoseResultResponseBodyDiagnoseResult) *GetVpnGatewayDiagnoseResultResponseBody {
	s.DiagnoseResult = v
	return s
}

func (s *GetVpnGatewayDiagnoseResultResponseBody) SetFinishTime(v string) *GetVpnGatewayDiagnoseResultResponseBody {
	s.FinishTime = &v
	return s
}

func (s *GetVpnGatewayDiagnoseResultResponseBody) SetFinishedCount(v int32) *GetVpnGatewayDiagnoseResultResponseBody {
	s.FinishedCount = &v
	return s
}

func (s *GetVpnGatewayDiagnoseResultResponseBody) SetRequestId(v string) *GetVpnGatewayDiagnoseResultResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetVpnGatewayDiagnoseResultResponseBody) SetResourceInstanceId(v string) *GetVpnGatewayDiagnoseResultResponseBody {
	s.ResourceInstanceId = &v
	return s
}

func (s *GetVpnGatewayDiagnoseResultResponseBody) SetResourceType(v string) *GetVpnGatewayDiagnoseResultResponseBody {
	s.ResourceType = &v
	return s
}

func (s *GetVpnGatewayDiagnoseResultResponseBody) SetTotalCount(v int32) *GetVpnGatewayDiagnoseResultResponseBody {
	s.TotalCount = &v
	return s
}

func (s *GetVpnGatewayDiagnoseResultResponseBody) SetVpnGatewayId(v string) *GetVpnGatewayDiagnoseResultResponseBody {
	s.VpnGatewayId = &v
	return s
}

type GetVpnGatewayDiagnoseResultResponseBodyDiagnoseResult struct {
	// The diagnostic item.
	//
	// *   **RouteEntryConflict**: route conflicts.
	// *   **VpnRouteQuota**: the quota of destination-based routes for the VPN gateway.
	// *   **VpnIPsecQuota**: the quota of IPsec-VPN connections for the VPN gateway.
	// *   **VpnPbrRouteQuota**: the quota of policy-based routes for the VPN gateway.
	// *   **VcoConfigConsistency**: the consistency of the IPsec-VPN connection.
	// *   **VcoUserInternetIpConnectivity**: Internet connectivity of the customer gateway.
	// *   **VcoPrivateConnectivity**: private network connectivity.
	//
	// For more information about the diagnostic items, see [Background information about quick diagnostics](~~190330~~).
	DiagnoseName *string `json:"DiagnoseName,omitempty" xml:"DiagnoseName,omitempty"`
	// The diagnostic result.
	//
	// The system returns different results for each diagnostic item.
	//
	// *   **RouteEntryConflict**: information about route conflicts.
	//
	// *   **VpnRouteQuota**:
	//
	//     *   **quotaName**: the quota ID of destination-based routes.
	//     *   **quantity**: the quota of destination-based routes for the VPN gateway.
	//     *   **used**: the number of destination-based routes created for the VPN gateway.
	//
	// *   **VpnIPsecQuota**:
	//
	//     *   **quotaName**: the quota ID of IPsec-VPN connections.
	//     *   **quantity**: the quota of IPsec-VPN connections for the VPN gateway.
	//     *   **used**: the number of IPsec-VPN connections created for the VPN gateway.
	//
	// *   **VpnPbrRouteQuota**:
	//
	//     *   **quotaName**: the quota ID of policy-based routes.
	//     *   **quantity**: the quota of policy-based routes for the VPN gateway.
	//     *   **used**: the number of policy-based routes created for the VPN gateway.
	//
	// *   **VcoConfigConsistency**:
	//
	//     *   **vcoLackConf**: The system cannot obtain the configuration of the peer of the IPsec-VPN connection.
	//     *   **vcoRunningConf**: the configurations that have been added to the peer of the IPsec-VPN connection.
	//     *   **vcoDiffConf**: the configurations that are inconsistent between the local end and the peer.
	//     *   **vcoConf**: the configurations that have been added to the local end.
	//
	// *   **VcoUserInternetIpConnectivity**:
	//
	//     *   **targetIp**: the public IP address of the customer gateway.
	//     *   **rtt**: the latency when the system accesses the public IP address of the customer gateway. Unit: milliseconds.
	//     *   **lossRate**: the packet loss when the system accesses the public IP address of the customer gateway.
	//
	// *   **VcoPrivateConnectivity**:
	//
	//     *   **targetIp**: the source IP address.
	//     *   **srcIp**: the destination IP address.
	//     *   **rtt**: the latency when the source IP address accesses the destination IP address. Unit: milliseconds.
	//     *   **lossRate**: the packet loss when the source IP address accesses the destination IP address.
	DiagnoseResultDescription *string `json:"DiagnoseResultDescription,omitempty" xml:"DiagnoseResultDescription,omitempty"`
	// The diagnostic result level.
	//
	// *   **normal**
	// *   **warning**
	// *   **error**
	//
	// For more information, see [Background information about quick diagnostics](~~190330~~).
	DiagnoseResultLevel *string `json:"DiagnoseResultLevel,omitempty" xml:"DiagnoseResultLevel,omitempty"`
}

func (s GetVpnGatewayDiagnoseResultResponseBodyDiagnoseResult) String() string {
	return tea.Prettify(s)
}

func (s GetVpnGatewayDiagnoseResultResponseBodyDiagnoseResult) GoString() string {
	return s.String()
}

func (s *GetVpnGatewayDiagnoseResultResponseBodyDiagnoseResult) SetDiagnoseName(v string) *GetVpnGatewayDiagnoseResultResponseBodyDiagnoseResult {
	s.DiagnoseName = &v
	return s
}

func (s *GetVpnGatewayDiagnoseResultResponseBodyDiagnoseResult) SetDiagnoseResultDescription(v string) *GetVpnGatewayDiagnoseResultResponseBodyDiagnoseResult {
	s.DiagnoseResultDescription = &v
	return s
}

func (s *GetVpnGatewayDiagnoseResultResponseBodyDiagnoseResult) SetDiagnoseResultLevel(v string) *GetVpnGatewayDiagnoseResultResponseBodyDiagnoseResult {
	s.DiagnoseResultLevel = &v
	return s
}

type GetVpnGatewayDiagnoseResultResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetVpnGatewayDiagnoseResultResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetVpnGatewayDiagnoseResultResponse) String() string {
	return tea.Prettify(s)
}

func (s GetVpnGatewayDiagnoseResultResponse) GoString() string {
	return s.String()
}

func (s *GetVpnGatewayDiagnoseResultResponse) SetHeaders(v map[string]*string) *GetVpnGatewayDiagnoseResultResponse {
	s.Headers = v
	return s
}

func (s *GetVpnGatewayDiagnoseResultResponse) SetStatusCode(v int32) *GetVpnGatewayDiagnoseResultResponse {
	s.StatusCode = &v
	return s
}

func (s *GetVpnGatewayDiagnoseResultResponse) SetBody(v *GetVpnGatewayDiagnoseResultResponseBody) *GetVpnGatewayDiagnoseResultResponse {
	s.Body = v
	return s
}

type GrantInstanceToCenRequest struct {
	// The ID of the CEN instance to which you want to grant permissions.
	CenId *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	// The user ID (UID) of the Alibaba Cloud account to which the CEN instance belongs.
	CenOwnerId *int64 `json:"CenOwnerId,omitempty" xml:"CenOwnerId,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must ensure that the value is unique among all requests. The token can contain only ASCII characters.
	//
	// >  If you do not specify this parameter, the system uses **RequestId** as **ClientToken**. **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the network instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The type of the network instance. Valid values:
	//
	// *   **VPC**: a VPC
	// *   **VBR**: a VBR
	InstanceType *string `json:"InstanceType,omitempty" xml:"InstanceType,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region where the network instance is deployed.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s GrantInstanceToCenRequest) String() string {
	return tea.Prettify(s)
}

func (s GrantInstanceToCenRequest) GoString() string {
	return s.String()
}

func (s *GrantInstanceToCenRequest) SetCenId(v string) *GrantInstanceToCenRequest {
	s.CenId = &v
	return s
}

func (s *GrantInstanceToCenRequest) SetCenOwnerId(v int64) *GrantInstanceToCenRequest {
	s.CenOwnerId = &v
	return s
}

func (s *GrantInstanceToCenRequest) SetClientToken(v string) *GrantInstanceToCenRequest {
	s.ClientToken = &v
	return s
}

func (s *GrantInstanceToCenRequest) SetInstanceId(v string) *GrantInstanceToCenRequest {
	s.InstanceId = &v
	return s
}

func (s *GrantInstanceToCenRequest) SetInstanceType(v string) *GrantInstanceToCenRequest {
	s.InstanceType = &v
	return s
}

func (s *GrantInstanceToCenRequest) SetOwnerAccount(v string) *GrantInstanceToCenRequest {
	s.OwnerAccount = &v
	return s
}

func (s *GrantInstanceToCenRequest) SetOwnerId(v int64) *GrantInstanceToCenRequest {
	s.OwnerId = &v
	return s
}

func (s *GrantInstanceToCenRequest) SetRegionId(v string) *GrantInstanceToCenRequest {
	s.RegionId = &v
	return s
}

func (s *GrantInstanceToCenRequest) SetResourceOwnerAccount(v string) *GrantInstanceToCenRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *GrantInstanceToCenRequest) SetResourceOwnerId(v int64) *GrantInstanceToCenRequest {
	s.ResourceOwnerId = &v
	return s
}

type GrantInstanceToCenResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GrantInstanceToCenResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GrantInstanceToCenResponseBody) GoString() string {
	return s.String()
}

func (s *GrantInstanceToCenResponseBody) SetRequestId(v string) *GrantInstanceToCenResponseBody {
	s.RequestId = &v
	return s
}

type GrantInstanceToCenResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GrantInstanceToCenResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GrantInstanceToCenResponse) String() string {
	return tea.Prettify(s)
}

func (s GrantInstanceToCenResponse) GoString() string {
	return s.String()
}

func (s *GrantInstanceToCenResponse) SetHeaders(v map[string]*string) *GrantInstanceToCenResponse {
	s.Headers = v
	return s
}

func (s *GrantInstanceToCenResponse) SetStatusCode(v int32) *GrantInstanceToCenResponse {
	s.StatusCode = &v
	return s
}

func (s *GrantInstanceToCenResponse) SetBody(v *GrantInstanceToCenResponseBody) *GrantInstanceToCenResponse {
	s.Body = v
	return s
}

type GrantInstanceToVbrRequest struct {
	// The VBRs that need to acquire permissions on the VPC. Valid values:
	//
	// *   **All**: Permissions on the VPC are granted to all VBRs that belong to the specified region and Alibaba Cloud account. In this case, you can leave **VbrInstanceIds** empty.
	// *   **Specify**: Permissions on the VPC are granted to the specified VBRs. **VbrInstanceIds** must be assigned a value.
	GrantType *string `json:"GrantType,omitempty" xml:"GrantType,omitempty"`
	// The ID of the VPC.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the region where the VPC is deployed.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The information about the VBRs.
	VbrInstanceIds []*string `json:"VbrInstanceIds,omitempty" xml:"VbrInstanceIds,omitempty" type:"Repeated"`
	// The ID of the Alibaba Cloud account to which the VBR belongs.
	VbrOwnerUid *int64 `json:"VbrOwnerUid,omitempty" xml:"VbrOwnerUid,omitempty"`
	// The ID of the region where the VBR is deployed.
	VbrRegionNo *string `json:"VbrRegionNo,omitempty" xml:"VbrRegionNo,omitempty"`
}

func (s GrantInstanceToVbrRequest) String() string {
	return tea.Prettify(s)
}

func (s GrantInstanceToVbrRequest) GoString() string {
	return s.String()
}

func (s *GrantInstanceToVbrRequest) SetGrantType(v string) *GrantInstanceToVbrRequest {
	s.GrantType = &v
	return s
}

func (s *GrantInstanceToVbrRequest) SetInstanceId(v string) *GrantInstanceToVbrRequest {
	s.InstanceId = &v
	return s
}

func (s *GrantInstanceToVbrRequest) SetRegionId(v string) *GrantInstanceToVbrRequest {
	s.RegionId = &v
	return s
}

func (s *GrantInstanceToVbrRequest) SetVbrInstanceIds(v []*string) *GrantInstanceToVbrRequest {
	s.VbrInstanceIds = v
	return s
}

func (s *GrantInstanceToVbrRequest) SetVbrOwnerUid(v int64) *GrantInstanceToVbrRequest {
	s.VbrOwnerUid = &v
	return s
}

func (s *GrantInstanceToVbrRequest) SetVbrRegionNo(v string) *GrantInstanceToVbrRequest {
	s.VbrRegionNo = &v
	return s
}

type GrantInstanceToVbrShrinkRequest struct {
	// The VBRs that need to acquire permissions on the VPC. Valid values:
	//
	// *   **All**: Permissions on the VPC are granted to all VBRs that belong to the specified region and Alibaba Cloud account. In this case, you can leave **VbrInstanceIds** empty.
	// *   **Specify**: Permissions on the VPC are granted to the specified VBRs. **VbrInstanceIds** must be assigned a value.
	GrantType *string `json:"GrantType,omitempty" xml:"GrantType,omitempty"`
	// The ID of the VPC.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the region where the VPC is deployed.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The information about the VBRs.
	VbrInstanceIdsShrink *string `json:"VbrInstanceIds,omitempty" xml:"VbrInstanceIds,omitempty"`
	// The ID of the Alibaba Cloud account to which the VBR belongs.
	VbrOwnerUid *int64 `json:"VbrOwnerUid,omitempty" xml:"VbrOwnerUid,omitempty"`
	// The ID of the region where the VBR is deployed.
	VbrRegionNo *string `json:"VbrRegionNo,omitempty" xml:"VbrRegionNo,omitempty"`
}

func (s GrantInstanceToVbrShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s GrantInstanceToVbrShrinkRequest) GoString() string {
	return s.String()
}

func (s *GrantInstanceToVbrShrinkRequest) SetGrantType(v string) *GrantInstanceToVbrShrinkRequest {
	s.GrantType = &v
	return s
}

func (s *GrantInstanceToVbrShrinkRequest) SetInstanceId(v string) *GrantInstanceToVbrShrinkRequest {
	s.InstanceId = &v
	return s
}

func (s *GrantInstanceToVbrShrinkRequest) SetRegionId(v string) *GrantInstanceToVbrShrinkRequest {
	s.RegionId = &v
	return s
}

func (s *GrantInstanceToVbrShrinkRequest) SetVbrInstanceIdsShrink(v string) *GrantInstanceToVbrShrinkRequest {
	s.VbrInstanceIdsShrink = &v
	return s
}

func (s *GrantInstanceToVbrShrinkRequest) SetVbrOwnerUid(v int64) *GrantInstanceToVbrShrinkRequest {
	s.VbrOwnerUid = &v
	return s
}

func (s *GrantInstanceToVbrShrinkRequest) SetVbrRegionNo(v string) *GrantInstanceToVbrShrinkRequest {
	s.VbrRegionNo = &v
	return s
}

type GrantInstanceToVbrResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GrantInstanceToVbrResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GrantInstanceToVbrResponseBody) GoString() string {
	return s.String()
}

func (s *GrantInstanceToVbrResponseBody) SetRequestId(v string) *GrantInstanceToVbrResponseBody {
	s.RequestId = &v
	return s
}

type GrantInstanceToVbrResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GrantInstanceToVbrResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GrantInstanceToVbrResponse) String() string {
	return tea.Prettify(s)
}

func (s GrantInstanceToVbrResponse) GoString() string {
	return s.String()
}

func (s *GrantInstanceToVbrResponse) SetHeaders(v map[string]*string) *GrantInstanceToVbrResponse {
	s.Headers = v
	return s
}

func (s *GrantInstanceToVbrResponse) SetStatusCode(v int32) *GrantInstanceToVbrResponse {
	s.StatusCode = &v
	return s
}

func (s *GrantInstanceToVbrResponse) SetBody(v *GrantInstanceToVbrResponseBody) *GrantInstanceToVbrResponse {
	s.Body = v
	return s
}

type ListBusinessAccessPointsRequest struct {
	// The region ID of the Express Connect circuit.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s ListBusinessAccessPointsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListBusinessAccessPointsRequest) GoString() string {
	return s.String()
}

func (s *ListBusinessAccessPointsRequest) SetRegionId(v string) *ListBusinessAccessPointsRequest {
	s.RegionId = &v
	return s
}

type ListBusinessAccessPointsResponseBody struct {
	// The list of access points.
	BusinessAccessPoints []*ListBusinessAccessPointsResponseBodyBusinessAccessPoints `json:"BusinessAccessPoints,omitempty" xml:"BusinessAccessPoints,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListBusinessAccessPointsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListBusinessAccessPointsResponseBody) GoString() string {
	return s.String()
}

func (s *ListBusinessAccessPointsResponseBody) SetBusinessAccessPoints(v []*ListBusinessAccessPointsResponseBodyBusinessAccessPoints) *ListBusinessAccessPointsResponseBody {
	s.BusinessAccessPoints = v
	return s
}

func (s *ListBusinessAccessPointsResponseBody) SetRequestId(v string) *ListBusinessAccessPointsResponseBody {
	s.RequestId = &v
	return s
}

type ListBusinessAccessPointsResponseBodyBusinessAccessPoints struct {
	// The ID of the access point.
	AccessPointId *string `json:"AccessPointId,omitempty" xml:"AccessPointId,omitempty"`
	// The name of the access point.
	AccessPointName *string `json:"AccessPointName,omitempty" xml:"AccessPointName,omitempty"`
	// The ID of the cloud box.
	//
	// >  This parameter is available if the Express Connect circuit supports cloud boxes and the access point supports cloud boxes.
	CloudBoxInstanceIds *string `json:"CloudBoxInstanceIds,omitempty" xml:"CloudBoxInstanceIds,omitempty"`
	// The latitude of the access point.
	Latitude *float64 `json:"Latitude,omitempty" xml:"Latitude,omitempty"`
	// The longitude of the access point.
	Longitude *float64 `json:"Longitude,omitempty" xml:"Longitude,omitempty"`
	// The connectivity provider of the Express Connect circuit. Valid values:
	//
	// *   **CT**: China Telecom
	// *   **CU**: China Unicom
	// *   **CM**: China Mobile
	// *   **CO**: other connectivity providers in the Chinese mainland
	// *   **Equinix**: Equinix
	// *   **Other**: other connectivity providers outside the Chinese mainland
	SupportLineOperator *string `json:"SupportLineOperator,omitempty" xml:"SupportLineOperator,omitempty"`
	// The port type supported by the access point. Valid values:
	//
	// *   **100Base-T**: 100 Mbit/s copper Ethernet port
	// *   **1000Base-T**: 1,000 Mbit/s copper Ethernet port
	// *   **1000Base-LX**: 1,000 Mbit/s single-mode optical port (10 km)
	// *   **10GBase-T**: 10,000 Mbit/s copper Ethernet port
	// *   **10GBase-LR**: 10,000 Mbit/s single-mode optical port (10 kilometers)
	// *   **40GBase-LR**: 40,000 Mbit/s single-mode optical port
	// *   **100GBase-LR**: 100,000 Mbit/s single-mode optical port
	//
	// >  If you want to use the 40GBase-LR or 100GBase-LR port for an Express Connect circuit, you must first contact your account manager to obtain information about resource supplies.
	SupportPortTypes *string `json:"SupportPortTypes,omitempty" xml:"SupportPortTypes,omitempty"`
}

func (s ListBusinessAccessPointsResponseBodyBusinessAccessPoints) String() string {
	return tea.Prettify(s)
}

func (s ListBusinessAccessPointsResponseBodyBusinessAccessPoints) GoString() string {
	return s.String()
}

func (s *ListBusinessAccessPointsResponseBodyBusinessAccessPoints) SetAccessPointId(v string) *ListBusinessAccessPointsResponseBodyBusinessAccessPoints {
	s.AccessPointId = &v
	return s
}

func (s *ListBusinessAccessPointsResponseBodyBusinessAccessPoints) SetAccessPointName(v string) *ListBusinessAccessPointsResponseBodyBusinessAccessPoints {
	s.AccessPointName = &v
	return s
}

func (s *ListBusinessAccessPointsResponseBodyBusinessAccessPoints) SetCloudBoxInstanceIds(v string) *ListBusinessAccessPointsResponseBodyBusinessAccessPoints {
	s.CloudBoxInstanceIds = &v
	return s
}

func (s *ListBusinessAccessPointsResponseBodyBusinessAccessPoints) SetLatitude(v float64) *ListBusinessAccessPointsResponseBodyBusinessAccessPoints {
	s.Latitude = &v
	return s
}

func (s *ListBusinessAccessPointsResponseBodyBusinessAccessPoints) SetLongitude(v float64) *ListBusinessAccessPointsResponseBodyBusinessAccessPoints {
	s.Longitude = &v
	return s
}

func (s *ListBusinessAccessPointsResponseBodyBusinessAccessPoints) SetSupportLineOperator(v string) *ListBusinessAccessPointsResponseBodyBusinessAccessPoints {
	s.SupportLineOperator = &v
	return s
}

func (s *ListBusinessAccessPointsResponseBodyBusinessAccessPoints) SetSupportPortTypes(v string) *ListBusinessAccessPointsResponseBodyBusinessAccessPoints {
	s.SupportPortTypes = &v
	return s
}

type ListBusinessAccessPointsResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListBusinessAccessPointsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListBusinessAccessPointsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListBusinessAccessPointsResponse) GoString() string {
	return s.String()
}

func (s *ListBusinessAccessPointsResponse) SetHeaders(v map[string]*string) *ListBusinessAccessPointsResponse {
	s.Headers = v
	return s
}

func (s *ListBusinessAccessPointsResponse) SetStatusCode(v int32) *ListBusinessAccessPointsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListBusinessAccessPointsResponse) SetBody(v *ListBusinessAccessPointsResponseBody) *ListBusinessAccessPointsResponse {
	s.Body = v
	return s
}

type ListDhcpOptionsSetsRequest struct {
	DhcpOptionsSetId []*string `json:"DhcpOptionsSetId,omitempty" xml:"DhcpOptionsSetId,omitempty" type:"Repeated"`
	// The name of the DHCP options set.
	//
	// The name must be 2 to 128 characters in length and can contain letters, digits, underscores (\_), and hyphens (-). It must start with a letter.
	DhcpOptionsSetName *string `json:"DhcpOptionsSetName,omitempty" xml:"DhcpOptionsSetName,omitempty"`
	// The root domain. For example, you can set the value to example.com.
	//
	// After a DHCP options set is associated with a virtual private cloud (VPC), the root domain in the DHCP options set is automatically synchronized with the Elastic Compute Service (ECS) instances in the VPC.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The number of entries to return on each page. Valid values: **1** to **100**. Default value: **10**.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The token that is used for the next query. Valid values:
	//
	// *   If this is your first query or no next queries are to be sent, ignore this parameter.
	// *   If a subsequent query is to be sent, set the value to the value of **NextToken** that is returned from the last call.
	NextToken    *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the DHCP options sets that you want to query.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string                           `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceGroupId      *string                           `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string                           `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64                            `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	Tags                 []*ListDhcpOptionsSetsRequestTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
}

func (s ListDhcpOptionsSetsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListDhcpOptionsSetsRequest) GoString() string {
	return s.String()
}

func (s *ListDhcpOptionsSetsRequest) SetDhcpOptionsSetId(v []*string) *ListDhcpOptionsSetsRequest {
	s.DhcpOptionsSetId = v
	return s
}

func (s *ListDhcpOptionsSetsRequest) SetDhcpOptionsSetName(v string) *ListDhcpOptionsSetsRequest {
	s.DhcpOptionsSetName = &v
	return s
}

func (s *ListDhcpOptionsSetsRequest) SetDomainName(v string) *ListDhcpOptionsSetsRequest {
	s.DomainName = &v
	return s
}

func (s *ListDhcpOptionsSetsRequest) SetMaxResults(v int32) *ListDhcpOptionsSetsRequest {
	s.MaxResults = &v
	return s
}

func (s *ListDhcpOptionsSetsRequest) SetNextToken(v string) *ListDhcpOptionsSetsRequest {
	s.NextToken = &v
	return s
}

func (s *ListDhcpOptionsSetsRequest) SetOwnerAccount(v string) *ListDhcpOptionsSetsRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ListDhcpOptionsSetsRequest) SetOwnerId(v int64) *ListDhcpOptionsSetsRequest {
	s.OwnerId = &v
	return s
}

func (s *ListDhcpOptionsSetsRequest) SetRegionId(v string) *ListDhcpOptionsSetsRequest {
	s.RegionId = &v
	return s
}

func (s *ListDhcpOptionsSetsRequest) SetResourceGroupId(v string) *ListDhcpOptionsSetsRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *ListDhcpOptionsSetsRequest) SetResourceOwnerAccount(v string) *ListDhcpOptionsSetsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ListDhcpOptionsSetsRequest) SetResourceOwnerId(v int64) *ListDhcpOptionsSetsRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ListDhcpOptionsSetsRequest) SetTags(v []*ListDhcpOptionsSetsRequestTags) *ListDhcpOptionsSetsRequest {
	s.Tags = v
	return s
}

type ListDhcpOptionsSetsRequestTags struct {
	Key   *string `json:"Key,omitempty" xml:"Key,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListDhcpOptionsSetsRequestTags) String() string {
	return tea.Prettify(s)
}

func (s ListDhcpOptionsSetsRequestTags) GoString() string {
	return s.String()
}

func (s *ListDhcpOptionsSetsRequestTags) SetKey(v string) *ListDhcpOptionsSetsRequestTags {
	s.Key = &v
	return s
}

func (s *ListDhcpOptionsSetsRequestTags) SetValue(v string) *ListDhcpOptionsSetsRequestTags {
	s.Value = &v
	return s
}

type ListDhcpOptionsSetsResponseBody struct {
	// The list of the DHCP options sets.
	DhcpOptionsSets []*ListDhcpOptionsSetsResponseBodyDhcpOptionsSets `json:"DhcpOptionsSets,omitempty" xml:"DhcpOptionsSets,omitempty" type:"Repeated"`
	// The token that is used for the next query. Valid values:
	//
	// *   If **NextToken** is empty, it indicates that no next query is to be sent.
	// *   If a value is returned for **NextToken**, the value is the token that is used for the next query.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the request.
	RequestId  *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	TotalCount *string `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListDhcpOptionsSetsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListDhcpOptionsSetsResponseBody) GoString() string {
	return s.String()
}

func (s *ListDhcpOptionsSetsResponseBody) SetDhcpOptionsSets(v []*ListDhcpOptionsSetsResponseBodyDhcpOptionsSets) *ListDhcpOptionsSetsResponseBody {
	s.DhcpOptionsSets = v
	return s
}

func (s *ListDhcpOptionsSetsResponseBody) SetNextToken(v string) *ListDhcpOptionsSetsResponseBody {
	s.NextToken = &v
	return s
}

func (s *ListDhcpOptionsSetsResponseBody) SetRequestId(v string) *ListDhcpOptionsSetsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListDhcpOptionsSetsResponseBody) SetTotalCount(v string) *ListDhcpOptionsSetsResponseBody {
	s.TotalCount = &v
	return s
}

type ListDhcpOptionsSetsResponseBodyDhcpOptionsSets struct {
	// The number of VPCs with which the DHCP options set is associated.
	AssociateVpcCount *int32 `json:"AssociateVpcCount,omitempty" xml:"AssociateVpcCount,omitempty"`
	// The configuration information about the DHCP options set.
	DhcpOptions *ListDhcpOptionsSetsResponseBodyDhcpOptionsSetsDhcpOptions `json:"DhcpOptions,omitempty" xml:"DhcpOptions,omitempty" type:"Struct"`
	// The description of the DHCP options set.
	DhcpOptionsSetDescription *string `json:"DhcpOptionsSetDescription,omitempty" xml:"DhcpOptionsSetDescription,omitempty"`
	// The ID of the DHCP options set.
	DhcpOptionsSetId *string `json:"DhcpOptionsSetId,omitempty" xml:"DhcpOptionsSetId,omitempty"`
	// The name of the DHCP options set.
	DhcpOptionsSetName *string `json:"DhcpOptionsSetName,omitempty" xml:"DhcpOptionsSetName,omitempty"`
	// The ID of the Alibaba Cloud account to which the DHCP options set belongs.
	OwnerId         *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The status of the DHCP options set. Valid values:
	//
	// *   **Available**: available
	// *   **InUse**: in use
	// *   **Pending**: being configured
	// *   **Deleted**: deleted
	Status *string                                               `json:"Status,omitempty" xml:"Status,omitempty"`
	Tags   []*ListDhcpOptionsSetsResponseBodyDhcpOptionsSetsTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
}

func (s ListDhcpOptionsSetsResponseBodyDhcpOptionsSets) String() string {
	return tea.Prettify(s)
}

func (s ListDhcpOptionsSetsResponseBodyDhcpOptionsSets) GoString() string {
	return s.String()
}

func (s *ListDhcpOptionsSetsResponseBodyDhcpOptionsSets) SetAssociateVpcCount(v int32) *ListDhcpOptionsSetsResponseBodyDhcpOptionsSets {
	s.AssociateVpcCount = &v
	return s
}

func (s *ListDhcpOptionsSetsResponseBodyDhcpOptionsSets) SetDhcpOptions(v *ListDhcpOptionsSetsResponseBodyDhcpOptionsSetsDhcpOptions) *ListDhcpOptionsSetsResponseBodyDhcpOptionsSets {
	s.DhcpOptions = v
	return s
}

func (s *ListDhcpOptionsSetsResponseBodyDhcpOptionsSets) SetDhcpOptionsSetDescription(v string) *ListDhcpOptionsSetsResponseBodyDhcpOptionsSets {
	s.DhcpOptionsSetDescription = &v
	return s
}

func (s *ListDhcpOptionsSetsResponseBodyDhcpOptionsSets) SetDhcpOptionsSetId(v string) *ListDhcpOptionsSetsResponseBodyDhcpOptionsSets {
	s.DhcpOptionsSetId = &v
	return s
}

func (s *ListDhcpOptionsSetsResponseBodyDhcpOptionsSets) SetDhcpOptionsSetName(v string) *ListDhcpOptionsSetsResponseBodyDhcpOptionsSets {
	s.DhcpOptionsSetName = &v
	return s
}

func (s *ListDhcpOptionsSetsResponseBodyDhcpOptionsSets) SetOwnerId(v int64) *ListDhcpOptionsSetsResponseBodyDhcpOptionsSets {
	s.OwnerId = &v
	return s
}

func (s *ListDhcpOptionsSetsResponseBodyDhcpOptionsSets) SetResourceGroupId(v string) *ListDhcpOptionsSetsResponseBodyDhcpOptionsSets {
	s.ResourceGroupId = &v
	return s
}

func (s *ListDhcpOptionsSetsResponseBodyDhcpOptionsSets) SetStatus(v string) *ListDhcpOptionsSetsResponseBodyDhcpOptionsSets {
	s.Status = &v
	return s
}

func (s *ListDhcpOptionsSetsResponseBodyDhcpOptionsSets) SetTags(v []*ListDhcpOptionsSetsResponseBodyDhcpOptionsSetsTags) *ListDhcpOptionsSetsResponseBodyDhcpOptionsSets {
	s.Tags = v
	return s
}

type ListDhcpOptionsSetsResponseBodyDhcpOptionsSetsDhcpOptions struct {
	// The suffix of the hostname.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The DNS server IP address.
	DomainNameServers *string `json:"DomainNameServers,omitempty" xml:"DomainNameServers,omitempty"`
	// The lease time of the IPv6 addresses for the DHCP options set.
	//
	// *   If you use hours as the unit, valid values are **24h to 1176h** and **87600h to 175200h**. Default value: **87600h**.
	// *   If you use days as the unit, valid values are **1d to 49d** and **3650d to 7300d**. Default value: **3650d**.
	Ipv6LeaseTime *string `json:"Ipv6LeaseTime,omitempty" xml:"Ipv6LeaseTime,omitempty"`
	// The lease time of the IPv4 addresses for the DHCP options set.
	//
	// *   If you use hours as the unit, valid values are **24h to 1176h** and **87600h to 175200h**. Default value: **87600h**.
	// *   If you use days as the unit, valid values are **1d to 49d** and **3650d to 7300d**. Default value: **3650d**.
	LeaseTime *string `json:"LeaseTime,omitempty" xml:"LeaseTime,omitempty"`
}

func (s ListDhcpOptionsSetsResponseBodyDhcpOptionsSetsDhcpOptions) String() string {
	return tea.Prettify(s)
}

func (s ListDhcpOptionsSetsResponseBodyDhcpOptionsSetsDhcpOptions) GoString() string {
	return s.String()
}

func (s *ListDhcpOptionsSetsResponseBodyDhcpOptionsSetsDhcpOptions) SetDomainName(v string) *ListDhcpOptionsSetsResponseBodyDhcpOptionsSetsDhcpOptions {
	s.DomainName = &v
	return s
}

func (s *ListDhcpOptionsSetsResponseBodyDhcpOptionsSetsDhcpOptions) SetDomainNameServers(v string) *ListDhcpOptionsSetsResponseBodyDhcpOptionsSetsDhcpOptions {
	s.DomainNameServers = &v
	return s
}

func (s *ListDhcpOptionsSetsResponseBodyDhcpOptionsSetsDhcpOptions) SetIpv6LeaseTime(v string) *ListDhcpOptionsSetsResponseBodyDhcpOptionsSetsDhcpOptions {
	s.Ipv6LeaseTime = &v
	return s
}

func (s *ListDhcpOptionsSetsResponseBodyDhcpOptionsSetsDhcpOptions) SetLeaseTime(v string) *ListDhcpOptionsSetsResponseBodyDhcpOptionsSetsDhcpOptions {
	s.LeaseTime = &v
	return s
}

type ListDhcpOptionsSetsResponseBodyDhcpOptionsSetsTags struct {
	Key   *string `json:"Key,omitempty" xml:"Key,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListDhcpOptionsSetsResponseBodyDhcpOptionsSetsTags) String() string {
	return tea.Prettify(s)
}

func (s ListDhcpOptionsSetsResponseBodyDhcpOptionsSetsTags) GoString() string {
	return s.String()
}

func (s *ListDhcpOptionsSetsResponseBodyDhcpOptionsSetsTags) SetKey(v string) *ListDhcpOptionsSetsResponseBodyDhcpOptionsSetsTags {
	s.Key = &v
	return s
}

func (s *ListDhcpOptionsSetsResponseBodyDhcpOptionsSetsTags) SetValue(v string) *ListDhcpOptionsSetsResponseBodyDhcpOptionsSetsTags {
	s.Value = &v
	return s
}

type ListDhcpOptionsSetsResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListDhcpOptionsSetsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListDhcpOptionsSetsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListDhcpOptionsSetsResponse) GoString() string {
	return s.String()
}

func (s *ListDhcpOptionsSetsResponse) SetHeaders(v map[string]*string) *ListDhcpOptionsSetsResponse {
	s.Headers = v
	return s
}

func (s *ListDhcpOptionsSetsResponse) SetStatusCode(v int32) *ListDhcpOptionsSetsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListDhcpOptionsSetsResponse) SetBody(v *ListDhcpOptionsSetsResponseBody) *ListDhcpOptionsSetsResponse {
	s.Body = v
	return s
}

type ListEnhanhcedNatGatewayAvailableZonesRequest struct {
	// The language to display the results. Valid values:
	//
	// *   **zh-CN** (default): Chinese
	// *   **en-US**: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	OwnerAccount   *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId        *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region that you want to query.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	//
	// In this example, zones that support NAT gateways in the UAE (Dubai) region are queried.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ListEnhanhcedNatGatewayAvailableZonesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListEnhanhcedNatGatewayAvailableZonesRequest) GoString() string {
	return s.String()
}

func (s *ListEnhanhcedNatGatewayAvailableZonesRequest) SetAcceptLanguage(v string) *ListEnhanhcedNatGatewayAvailableZonesRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ListEnhanhcedNatGatewayAvailableZonesRequest) SetOwnerAccount(v string) *ListEnhanhcedNatGatewayAvailableZonesRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ListEnhanhcedNatGatewayAvailableZonesRequest) SetOwnerId(v int64) *ListEnhanhcedNatGatewayAvailableZonesRequest {
	s.OwnerId = &v
	return s
}

func (s *ListEnhanhcedNatGatewayAvailableZonesRequest) SetRegionId(v string) *ListEnhanhcedNatGatewayAvailableZonesRequest {
	s.RegionId = &v
	return s
}

func (s *ListEnhanhcedNatGatewayAvailableZonesRequest) SetResourceOwnerAccount(v string) *ListEnhanhcedNatGatewayAvailableZonesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ListEnhanhcedNatGatewayAvailableZonesRequest) SetResourceOwnerId(v int64) *ListEnhanhcedNatGatewayAvailableZonesRequest {
	s.ResourceOwnerId = &v
	return s
}

type ListEnhanhcedNatGatewayAvailableZonesResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The list of zones.
	Zones []*ListEnhanhcedNatGatewayAvailableZonesResponseBodyZones `json:"Zones,omitempty" xml:"Zones,omitempty" type:"Repeated"`
}

func (s ListEnhanhcedNatGatewayAvailableZonesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListEnhanhcedNatGatewayAvailableZonesResponseBody) GoString() string {
	return s.String()
}

func (s *ListEnhanhcedNatGatewayAvailableZonesResponseBody) SetRequestId(v string) *ListEnhanhcedNatGatewayAvailableZonesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListEnhanhcedNatGatewayAvailableZonesResponseBody) SetZones(v []*ListEnhanhcedNatGatewayAvailableZonesResponseBodyZones) *ListEnhanhcedNatGatewayAvailableZonesResponseBody {
	s.Zones = v
	return s
}

type ListEnhanhcedNatGatewayAvailableZonesResponseBodyZones struct {
	// The name of the zone.
	LocalName *string `json:"LocalName,omitempty" xml:"LocalName,omitempty"`
	// The ID of the zone where the instance is deployed.
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
}

func (s ListEnhanhcedNatGatewayAvailableZonesResponseBodyZones) String() string {
	return tea.Prettify(s)
}

func (s ListEnhanhcedNatGatewayAvailableZonesResponseBodyZones) GoString() string {
	return s.String()
}

func (s *ListEnhanhcedNatGatewayAvailableZonesResponseBodyZones) SetLocalName(v string) *ListEnhanhcedNatGatewayAvailableZonesResponseBodyZones {
	s.LocalName = &v
	return s
}

func (s *ListEnhanhcedNatGatewayAvailableZonesResponseBodyZones) SetZoneId(v string) *ListEnhanhcedNatGatewayAvailableZonesResponseBodyZones {
	s.ZoneId = &v
	return s
}

type ListEnhanhcedNatGatewayAvailableZonesResponse struct {
	Headers    map[string]*string                                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListEnhanhcedNatGatewayAvailableZonesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListEnhanhcedNatGatewayAvailableZonesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListEnhanhcedNatGatewayAvailableZonesResponse) GoString() string {
	return s.String()
}

func (s *ListEnhanhcedNatGatewayAvailableZonesResponse) SetHeaders(v map[string]*string) *ListEnhanhcedNatGatewayAvailableZonesResponse {
	s.Headers = v
	return s
}

func (s *ListEnhanhcedNatGatewayAvailableZonesResponse) SetStatusCode(v int32) *ListEnhanhcedNatGatewayAvailableZonesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListEnhanhcedNatGatewayAvailableZonesResponse) SetBody(v *ListEnhanhcedNatGatewayAvailableZonesResponseBody) *ListEnhanhcedNatGatewayAvailableZonesResponse {
	s.Body = v
	return s
}

type ListFullNatEntriesRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must ensure that it is unique among all requests. The token can contain only ASCII characters.
	//
	// >  If you do not specify this parameter, the system uses **RequestId** as **ClientToken**. **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the FULLNAT entry that you want to query.
	FullNatEntryId *string `json:"FullNatEntryId,omitempty" xml:"FullNatEntryId,omitempty"`
	// The name of the FULLNAT entry.
	FullNatEntryNames []*string `json:"FullNatEntryNames,omitempty" xml:"FullNatEntryNames,omitempty" type:"Repeated"`
	// The ID of the FULLNAT table to which the FULLNAT entries to be queried belong.
	//
	// >  You must specify at least one of the **FullNatTableId** and **NatGatewayId** parameters.
	FullNatTableId *string `json:"FullNatTableId,omitempty" xml:"FullNatTableId,omitempty"`
	// The protocol of the packets that are forwarded by the port. Valid values:
	//
	// *   **TCP**
	// *   **UDP**
	IpProtocol *string `json:"IpProtocol,omitempty" xml:"IpProtocol,omitempty"`
	// The number of entries to return per page. Valid values: **1** to **100**. Default value: **20**.
	MaxResults *int64 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The ID of the NAT gateway.
	//
	// >  You must specify at least one of the **FullNatTableId** and **NatGatewayId** parameters.
	NatGatewayId *string `json:"NatGatewayId,omitempty" xml:"NatGatewayId,omitempty"`
	// The IDs of ENIs.
	NetworkInterfaceIds []*string `json:"NetworkInterfaceIds,omitempty" xml:"NetworkInterfaceIds,omitempty" type:"Repeated"`
	// The token that is used for the next query. Valid values:
	//
	// *   If this is your first query or no next queries are to be sent, ignore this parameter.
	// *   If a next query is to be sent, set the value to the value of **NextToken** that is returned from the last call.
	NextToken    *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the virtual private cloud (VPC) NAT gateway to which the FULLNAT entries to be queried belong.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ListFullNatEntriesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListFullNatEntriesRequest) GoString() string {
	return s.String()
}

func (s *ListFullNatEntriesRequest) SetClientToken(v string) *ListFullNatEntriesRequest {
	s.ClientToken = &v
	return s
}

func (s *ListFullNatEntriesRequest) SetFullNatEntryId(v string) *ListFullNatEntriesRequest {
	s.FullNatEntryId = &v
	return s
}

func (s *ListFullNatEntriesRequest) SetFullNatEntryNames(v []*string) *ListFullNatEntriesRequest {
	s.FullNatEntryNames = v
	return s
}

func (s *ListFullNatEntriesRequest) SetFullNatTableId(v string) *ListFullNatEntriesRequest {
	s.FullNatTableId = &v
	return s
}

func (s *ListFullNatEntriesRequest) SetIpProtocol(v string) *ListFullNatEntriesRequest {
	s.IpProtocol = &v
	return s
}

func (s *ListFullNatEntriesRequest) SetMaxResults(v int64) *ListFullNatEntriesRequest {
	s.MaxResults = &v
	return s
}

func (s *ListFullNatEntriesRequest) SetNatGatewayId(v string) *ListFullNatEntriesRequest {
	s.NatGatewayId = &v
	return s
}

func (s *ListFullNatEntriesRequest) SetNetworkInterfaceIds(v []*string) *ListFullNatEntriesRequest {
	s.NetworkInterfaceIds = v
	return s
}

func (s *ListFullNatEntriesRequest) SetNextToken(v string) *ListFullNatEntriesRequest {
	s.NextToken = &v
	return s
}

func (s *ListFullNatEntriesRequest) SetOwnerAccount(v string) *ListFullNatEntriesRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ListFullNatEntriesRequest) SetOwnerId(v int64) *ListFullNatEntriesRequest {
	s.OwnerId = &v
	return s
}

func (s *ListFullNatEntriesRequest) SetRegionId(v string) *ListFullNatEntriesRequest {
	s.RegionId = &v
	return s
}

func (s *ListFullNatEntriesRequest) SetResourceOwnerAccount(v string) *ListFullNatEntriesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ListFullNatEntriesRequest) SetResourceOwnerId(v int64) *ListFullNatEntriesRequest {
	s.ResourceOwnerId = &v
	return s
}

type ListFullNatEntriesResponseBody struct {
	// The information about the FULLNAT entries that are queried.
	FullNatEntries []*ListFullNatEntriesResponseBodyFullNatEntries `json:"FullNatEntries,omitempty" xml:"FullNatEntries,omitempty" type:"Repeated"`
	// The ID of the FULLNAT table to which the queried FULLNAT entries belong.
	FullNatTableId *string `json:"FullNatTableId,omitempty" xml:"FullNatTableId,omitempty"`
	// The maximum number of entries returned.
	MaxResults *int64 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The ID of the VPC NAT gateway.
	NatGatewayId *string `json:"NatGatewayId,omitempty" xml:"NatGatewayId,omitempty"`
	// Indicates whether the token for the next query exists. Valid values:
	//
	// *   If the value of **NextToken** is empty, no next queries are sent.
	// *   If the value of **NextToken** is returned, the value indicates the token that is used for the next query.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The number of FULLNAT entries returned.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListFullNatEntriesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListFullNatEntriesResponseBody) GoString() string {
	return s.String()
}

func (s *ListFullNatEntriesResponseBody) SetFullNatEntries(v []*ListFullNatEntriesResponseBodyFullNatEntries) *ListFullNatEntriesResponseBody {
	s.FullNatEntries = v
	return s
}

func (s *ListFullNatEntriesResponseBody) SetFullNatTableId(v string) *ListFullNatEntriesResponseBody {
	s.FullNatTableId = &v
	return s
}

func (s *ListFullNatEntriesResponseBody) SetMaxResults(v int64) *ListFullNatEntriesResponseBody {
	s.MaxResults = &v
	return s
}

func (s *ListFullNatEntriesResponseBody) SetNatGatewayId(v string) *ListFullNatEntriesResponseBody {
	s.NatGatewayId = &v
	return s
}

func (s *ListFullNatEntriesResponseBody) SetNextToken(v string) *ListFullNatEntriesResponseBody {
	s.NextToken = &v
	return s
}

func (s *ListFullNatEntriesResponseBody) SetRequestId(v string) *ListFullNatEntriesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListFullNatEntriesResponseBody) SetTotalCount(v int64) *ListFullNatEntriesResponseBody {
	s.TotalCount = &v
	return s
}

type ListFullNatEntriesResponseBodyFullNatEntries struct {
	// The backend IP address that is used for FULLNAT address translation in FULLNAT entries.
	AccessIp *string `json:"AccessIp,omitempty" xml:"AccessIp,omitempty"`
	// The backend port that is used for port mapping in FULLNAT entries. Valid values: **1** to **65535**.
	AccessPort *string `json:"AccessPort,omitempty" xml:"AccessPort,omitempty"`
	// The time when the FULLNAT entry was created.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The description of the FULLNAT entry.
	//
	// The name must be 2 to 128 characters in length. It must start with a letter but cannot start with `http://` or `https://`.
	FullNatEntryDescription *string `json:"FullNatEntryDescription,omitempty" xml:"FullNatEntryDescription,omitempty"`
	// The ID of the FULLNAT entry.
	FullNatEntryId *string `json:"FullNatEntryId,omitempty" xml:"FullNatEntryId,omitempty"`
	// The name of the FULLNAT entry.
	//
	// The name must be 2 to 128 characters in length and can contain letters, digits, underscores (\_), and hyphens (-). The name must start with a letter.
	FullNatEntryName *string `json:"FullNatEntryName,omitempty" xml:"FullNatEntryName,omitempty"`
	// The status of the FULLNAT entry. Valid values:
	//
	// *   **Pending**: The FULLNAT entry is being configured.
	// *   **Available**: The FULLNAT entry is available.
	// *   **Deleting**: The FULLNAT entry is being deleted.
	// *   **Deleted**: The FULLNAT entry is deleted.
	FullNatEntryStatus *string `json:"FullNatEntryStatus,omitempty" xml:"FullNatEntryStatus,omitempty"`
	// The ID of the FULLNAT table to which the FULLNAT entry belongs.
	FullNatTableId *string `json:"FullNatTableId,omitempty" xml:"FullNatTableId,omitempty"`
	// The protocol of the packets that are forwarded. Valid values:
	//
	// *   **TCP**
	// *   **UDP**
	IpProtocol *string `json:"IpProtocol,omitempty" xml:"IpProtocol,omitempty"`
	// The NAT IP address that is used for address translation in FULLNAT entries.
	NatIp *string `json:"NatIp,omitempty" xml:"NatIp,omitempty"`
	// The frontend port that is used for port mapping in FULLNAT entries. Valid values: **1** to **65535**.
	NatIpPort *string `json:"NatIpPort,omitempty" xml:"NatIpPort,omitempty"`
	// The ID of the ENI.
	NetworkInterfaceId *string `json:"NetworkInterfaceId,omitempty" xml:"NetworkInterfaceId,omitempty"`
	// The type of the ENI. The value is set to **Endpoint**, which indicates a reverse endpoint.
	NetworkInterfaceType *string `json:"NetworkInterfaceType,omitempty" xml:"NetworkInterfaceType,omitempty"`
}

func (s ListFullNatEntriesResponseBodyFullNatEntries) String() string {
	return tea.Prettify(s)
}

func (s ListFullNatEntriesResponseBodyFullNatEntries) GoString() string {
	return s.String()
}

func (s *ListFullNatEntriesResponseBodyFullNatEntries) SetAccessIp(v string) *ListFullNatEntriesResponseBodyFullNatEntries {
	s.AccessIp = &v
	return s
}

func (s *ListFullNatEntriesResponseBodyFullNatEntries) SetAccessPort(v string) *ListFullNatEntriesResponseBodyFullNatEntries {
	s.AccessPort = &v
	return s
}

func (s *ListFullNatEntriesResponseBodyFullNatEntries) SetCreationTime(v string) *ListFullNatEntriesResponseBodyFullNatEntries {
	s.CreationTime = &v
	return s
}

func (s *ListFullNatEntriesResponseBodyFullNatEntries) SetFullNatEntryDescription(v string) *ListFullNatEntriesResponseBodyFullNatEntries {
	s.FullNatEntryDescription = &v
	return s
}

func (s *ListFullNatEntriesResponseBodyFullNatEntries) SetFullNatEntryId(v string) *ListFullNatEntriesResponseBodyFullNatEntries {
	s.FullNatEntryId = &v
	return s
}

func (s *ListFullNatEntriesResponseBodyFullNatEntries) SetFullNatEntryName(v string) *ListFullNatEntriesResponseBodyFullNatEntries {
	s.FullNatEntryName = &v
	return s
}

func (s *ListFullNatEntriesResponseBodyFullNatEntries) SetFullNatEntryStatus(v string) *ListFullNatEntriesResponseBodyFullNatEntries {
	s.FullNatEntryStatus = &v
	return s
}

func (s *ListFullNatEntriesResponseBodyFullNatEntries) SetFullNatTableId(v string) *ListFullNatEntriesResponseBodyFullNatEntries {
	s.FullNatTableId = &v
	return s
}

func (s *ListFullNatEntriesResponseBodyFullNatEntries) SetIpProtocol(v string) *ListFullNatEntriesResponseBodyFullNatEntries {
	s.IpProtocol = &v
	return s
}

func (s *ListFullNatEntriesResponseBodyFullNatEntries) SetNatIp(v string) *ListFullNatEntriesResponseBodyFullNatEntries {
	s.NatIp = &v
	return s
}

func (s *ListFullNatEntriesResponseBodyFullNatEntries) SetNatIpPort(v string) *ListFullNatEntriesResponseBodyFullNatEntries {
	s.NatIpPort = &v
	return s
}

func (s *ListFullNatEntriesResponseBodyFullNatEntries) SetNetworkInterfaceId(v string) *ListFullNatEntriesResponseBodyFullNatEntries {
	s.NetworkInterfaceId = &v
	return s
}

func (s *ListFullNatEntriesResponseBodyFullNatEntries) SetNetworkInterfaceType(v string) *ListFullNatEntriesResponseBodyFullNatEntries {
	s.NetworkInterfaceType = &v
	return s
}

type ListFullNatEntriesResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListFullNatEntriesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListFullNatEntriesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListFullNatEntriesResponse) GoString() string {
	return s.String()
}

func (s *ListFullNatEntriesResponse) SetHeaders(v map[string]*string) *ListFullNatEntriesResponse {
	s.Headers = v
	return s
}

func (s *ListFullNatEntriesResponse) SetStatusCode(v int32) *ListFullNatEntriesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListFullNatEntriesResponse) SetBody(v *ListFullNatEntriesResponseBody) *ListFullNatEntriesResponse {
	s.Body = v
	return s
}

type ListGatewayRouteTableEntriesRequest struct {
	// The destination CIDR block of the route in the gateway route table.
	DestinationCidrBlock *string `json:"DestinationCidrBlock,omitempty" xml:"DestinationCidrBlock,omitempty"`
	// The ID of the gateway route table that you want to query.
	GatewayRouteTableId *string `json:"GatewayRouteTableId,omitempty" xml:"GatewayRouteTableId,omitempty"`
	// The number of entries to return on each page. Valid values: **1** to **100**. Default value: **10**.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The token that determines the start point of the query. Valid values:
	//
	// *   If this is your first query and no next queries are to be sent, ignore this parameter.
	// *   If a next query is to be sent, set the parameter to the value of NextToken that is returned from the last call.
	NextToken    *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the gateway route table.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ListGatewayRouteTableEntriesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayRouteTableEntriesRequest) GoString() string {
	return s.String()
}

func (s *ListGatewayRouteTableEntriesRequest) SetDestinationCidrBlock(v string) *ListGatewayRouteTableEntriesRequest {
	s.DestinationCidrBlock = &v
	return s
}

func (s *ListGatewayRouteTableEntriesRequest) SetGatewayRouteTableId(v string) *ListGatewayRouteTableEntriesRequest {
	s.GatewayRouteTableId = &v
	return s
}

func (s *ListGatewayRouteTableEntriesRequest) SetMaxResults(v int32) *ListGatewayRouteTableEntriesRequest {
	s.MaxResults = &v
	return s
}

func (s *ListGatewayRouteTableEntriesRequest) SetNextToken(v string) *ListGatewayRouteTableEntriesRequest {
	s.NextToken = &v
	return s
}

func (s *ListGatewayRouteTableEntriesRequest) SetOwnerAccount(v string) *ListGatewayRouteTableEntriesRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ListGatewayRouteTableEntriesRequest) SetOwnerId(v int64) *ListGatewayRouteTableEntriesRequest {
	s.OwnerId = &v
	return s
}

func (s *ListGatewayRouteTableEntriesRequest) SetRegionId(v string) *ListGatewayRouteTableEntriesRequest {
	s.RegionId = &v
	return s
}

func (s *ListGatewayRouteTableEntriesRequest) SetResourceOwnerAccount(v string) *ListGatewayRouteTableEntriesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ListGatewayRouteTableEntriesRequest) SetResourceOwnerId(v int64) *ListGatewayRouteTableEntriesRequest {
	s.ResourceOwnerId = &v
	return s
}

type ListGatewayRouteTableEntriesResponseBody struct {
	// The details of the routes in the gateway route table.
	GatewayRouteEntryModels []*ListGatewayRouteTableEntriesResponseBodyGatewayRouteEntryModels `json:"GatewayRouteEntryModels,omitempty" xml:"GatewayRouteEntryModels,omitempty" type:"Repeated"`
	// The token that determines the start point of the query. Valid values:
	//
	// *   If no value is returned for **NextToken**, no next queries are sent.
	// *   If a value of **NextToken** is returned, the value is the token that is used for the subsequent query.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalCount *string `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListGatewayRouteTableEntriesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayRouteTableEntriesResponseBody) GoString() string {
	return s.String()
}

func (s *ListGatewayRouteTableEntriesResponseBody) SetGatewayRouteEntryModels(v []*ListGatewayRouteTableEntriesResponseBodyGatewayRouteEntryModels) *ListGatewayRouteTableEntriesResponseBody {
	s.GatewayRouteEntryModels = v
	return s
}

func (s *ListGatewayRouteTableEntriesResponseBody) SetNextToken(v string) *ListGatewayRouteTableEntriesResponseBody {
	s.NextToken = &v
	return s
}

func (s *ListGatewayRouteTableEntriesResponseBody) SetRequestId(v string) *ListGatewayRouteTableEntriesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListGatewayRouteTableEntriesResponseBody) SetTotalCount(v string) *ListGatewayRouteTableEntriesResponseBody {
	s.TotalCount = &v
	return s
}

type ListGatewayRouteTableEntriesResponseBodyGatewayRouteEntryModels struct {
	// The name of the route.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The destination CIDR block of the route.
	DestinationCidrBlock *string `json:"DestinationCidrBlock,omitempty" xml:"DestinationCidrBlock,omitempty"`
	// The name of the route.
	//
	// The name must be 2 to 128 characters in length, and can contain letters, digits, periods (.), underscores (\_), and hyphens (-). It must start with a letter.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the next hop.
	NextHopId *string `json:"NextHopId,omitempty" xml:"NextHopId,omitempty"`
	// The type of the next hop. Valid values:
	//
	// *   **EcsInstance**: an Elastic Compute Service (ECS) instance
	// *   **NetworkInterface**: an elastic network interface (ENI)
	// *   **Local**: a local next hop
	NextHopType *string `json:"NextHopType,omitempty" xml:"NextHopType,omitempty"`
	// The information about the next hop.
	NextHops []*ListGatewayRouteTableEntriesResponseBodyGatewayRouteEntryModelsNextHops `json:"NextHops,omitempty" xml:"NextHops,omitempty" type:"Repeated"`
	// The status of the route. Valid values:
	//
	// *   **Pending**
	// *   **Available**
	// *   **Modifying**
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s ListGatewayRouteTableEntriesResponseBodyGatewayRouteEntryModels) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayRouteTableEntriesResponseBodyGatewayRouteEntryModels) GoString() string {
	return s.String()
}

func (s *ListGatewayRouteTableEntriesResponseBodyGatewayRouteEntryModels) SetDescription(v string) *ListGatewayRouteTableEntriesResponseBodyGatewayRouteEntryModels {
	s.Description = &v
	return s
}

func (s *ListGatewayRouteTableEntriesResponseBodyGatewayRouteEntryModels) SetDestinationCidrBlock(v string) *ListGatewayRouteTableEntriesResponseBodyGatewayRouteEntryModels {
	s.DestinationCidrBlock = &v
	return s
}

func (s *ListGatewayRouteTableEntriesResponseBodyGatewayRouteEntryModels) SetName(v string) *ListGatewayRouteTableEntriesResponseBodyGatewayRouteEntryModels {
	s.Name = &v
	return s
}

func (s *ListGatewayRouteTableEntriesResponseBodyGatewayRouteEntryModels) SetNextHopId(v string) *ListGatewayRouteTableEntriesResponseBodyGatewayRouteEntryModels {
	s.NextHopId = &v
	return s
}

func (s *ListGatewayRouteTableEntriesResponseBodyGatewayRouteEntryModels) SetNextHopType(v string) *ListGatewayRouteTableEntriesResponseBodyGatewayRouteEntryModels {
	s.NextHopType = &v
	return s
}

func (s *ListGatewayRouteTableEntriesResponseBodyGatewayRouteEntryModels) SetNextHops(v []*ListGatewayRouteTableEntriesResponseBodyGatewayRouteEntryModelsNextHops) *ListGatewayRouteTableEntriesResponseBodyGatewayRouteEntryModels {
	s.NextHops = v
	return s
}

func (s *ListGatewayRouteTableEntriesResponseBodyGatewayRouteEntryModels) SetStatus(v string) *ListGatewayRouteTableEntriesResponseBodyGatewayRouteEntryModels {
	s.Status = &v
	return s
}

type ListGatewayRouteTableEntriesResponseBodyGatewayRouteEntryModelsNextHops struct {
	// Indicates whether the route is available. Valid values:
	//
	// *   **0**: unavailable
	// *   **1**: available
	Enabled *string `json:"Enabled,omitempty" xml:"Enabled,omitempty"`
	// The ID of the next hop.
	NextHopId *string `json:"NextHopId,omitempty" xml:"NextHopId,omitempty"`
	// The type of the next hop. Valid values:
	//
	// *   **Instance** (default): an ECS instance
	// *   **HaVip**: a high-availability virtual IP address (HAVIP)
	// *   **VpnGateway**: a VPN gateway
	// *   **NatGateway**: a NAT gateway
	// *   **NetworkInterface**: a secondary ENI
	// *   **RouterInterface**: a router interface
	// *   **IPv6Gateway**: an IPv6 gateway
	// *   **Attachment**: a transit router
	NextHopType *string `json:"NextHopType,omitempty" xml:"NextHopType,omitempty"`
	// The weight of the route.
	Weight *string `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s ListGatewayRouteTableEntriesResponseBodyGatewayRouteEntryModelsNextHops) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayRouteTableEntriesResponseBodyGatewayRouteEntryModelsNextHops) GoString() string {
	return s.String()
}

func (s *ListGatewayRouteTableEntriesResponseBodyGatewayRouteEntryModelsNextHops) SetEnabled(v string) *ListGatewayRouteTableEntriesResponseBodyGatewayRouteEntryModelsNextHops {
	s.Enabled = &v
	return s
}

func (s *ListGatewayRouteTableEntriesResponseBodyGatewayRouteEntryModelsNextHops) SetNextHopId(v string) *ListGatewayRouteTableEntriesResponseBodyGatewayRouteEntryModelsNextHops {
	s.NextHopId = &v
	return s
}

func (s *ListGatewayRouteTableEntriesResponseBodyGatewayRouteEntryModelsNextHops) SetNextHopType(v string) *ListGatewayRouteTableEntriesResponseBodyGatewayRouteEntryModelsNextHops {
	s.NextHopType = &v
	return s
}

func (s *ListGatewayRouteTableEntriesResponseBodyGatewayRouteEntryModelsNextHops) SetWeight(v string) *ListGatewayRouteTableEntriesResponseBodyGatewayRouteEntryModelsNextHops {
	s.Weight = &v
	return s
}

type ListGatewayRouteTableEntriesResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListGatewayRouteTableEntriesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListGatewayRouteTableEntriesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayRouteTableEntriesResponse) GoString() string {
	return s.String()
}

func (s *ListGatewayRouteTableEntriesResponse) SetHeaders(v map[string]*string) *ListGatewayRouteTableEntriesResponse {
	s.Headers = v
	return s
}

func (s *ListGatewayRouteTableEntriesResponse) SetStatusCode(v int32) *ListGatewayRouteTableEntriesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListGatewayRouteTableEntriesResponse) SetBody(v *ListGatewayRouteTableEntriesResponseBody) *ListGatewayRouteTableEntriesResponse {
	s.Body = v
	return s
}

type ListGeographicSubRegionsResponseBody struct {
	// The number of entries returned.
	Count *int64 `json:"Count,omitempty" xml:"Count,omitempty"`
	// The list of regions available for Express Connect circuits.
	GeographicSubRegions []*string `json:"GeographicSubRegions,omitempty" xml:"GeographicSubRegions,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListGeographicSubRegionsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListGeographicSubRegionsResponseBody) GoString() string {
	return s.String()
}

func (s *ListGeographicSubRegionsResponseBody) SetCount(v int64) *ListGeographicSubRegionsResponseBody {
	s.Count = &v
	return s
}

func (s *ListGeographicSubRegionsResponseBody) SetGeographicSubRegions(v []*string) *ListGeographicSubRegionsResponseBody {
	s.GeographicSubRegions = v
	return s
}

func (s *ListGeographicSubRegionsResponseBody) SetRequestId(v string) *ListGeographicSubRegionsResponseBody {
	s.RequestId = &v
	return s
}

type ListGeographicSubRegionsResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListGeographicSubRegionsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListGeographicSubRegionsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListGeographicSubRegionsResponse) GoString() string {
	return s.String()
}

func (s *ListGeographicSubRegionsResponse) SetHeaders(v map[string]*string) *ListGeographicSubRegionsResponse {
	s.Headers = v
	return s
}

func (s *ListGeographicSubRegionsResponse) SetStatusCode(v int32) *ListGeographicSubRegionsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListGeographicSubRegionsResponse) SetBody(v *ListGeographicSubRegionsResponseBody) *ListGeographicSubRegionsResponse {
	s.Body = v
	return s
}

type ListIpsecServerLogsRequest struct {
	// The beginning of the time range to query. The value must be a UNIX timestamp. For example, 1671003744 specifies 15:42:24 (UTC+8) on December 14, 2022.
	//
	// >  If you specify **From**, you must also specify **To** or **MinutePeriod**.
	From *int32 `json:"From,omitempty" xml:"From,omitempty"`
	// The ID of the IPsec server.
	IpsecServerId *string `json:"IpsecServerId,omitempty" xml:"IpsecServerId,omitempty"`
	// The interval at which log data is queried. Valid values: **1** to **10**. Unit: minutes.
	//
	// >  If both **From** and **To** are not specified, you must specify **MinutePeriod**.
	MinutePeriod *int32 `json:"MinutePeriod,omitempty" xml:"MinutePeriod,omitempty"`
	// The number of the page to return. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Valid values: **1** to **50**. Default value: **10**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the region where the IPsec server is created.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to obtain the region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The end of the time range to query. The value must be a unix timestamp. For example, 1671004344 specifies 15:52:24 (UTC+8) on December 14, 2022.
	//
	// >  If you specify **To**, you must also specify **From** or **MinutePeriod**.
	To *int32 `json:"To,omitempty" xml:"To,omitempty"`
}

func (s ListIpsecServerLogsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListIpsecServerLogsRequest) GoString() string {
	return s.String()
}

func (s *ListIpsecServerLogsRequest) SetFrom(v int32) *ListIpsecServerLogsRequest {
	s.From = &v
	return s
}

func (s *ListIpsecServerLogsRequest) SetIpsecServerId(v string) *ListIpsecServerLogsRequest {
	s.IpsecServerId = &v
	return s
}

func (s *ListIpsecServerLogsRequest) SetMinutePeriod(v int32) *ListIpsecServerLogsRequest {
	s.MinutePeriod = &v
	return s
}

func (s *ListIpsecServerLogsRequest) SetPageNumber(v int32) *ListIpsecServerLogsRequest {
	s.PageNumber = &v
	return s
}

func (s *ListIpsecServerLogsRequest) SetPageSize(v int32) *ListIpsecServerLogsRequest {
	s.PageSize = &v
	return s
}

func (s *ListIpsecServerLogsRequest) SetRegionId(v string) *ListIpsecServerLogsRequest {
	s.RegionId = &v
	return s
}

func (s *ListIpsecServerLogsRequest) SetTo(v int32) *ListIpsecServerLogsRequest {
	s.To = &v
	return s
}

type ListIpsecServerLogsResponseBody struct {
	// The number of entries on the current page.
	Count *int32 `json:"Count,omitempty" xml:"Count,omitempty"`
	// An array of strings.
	//
	// Each item in the array is a log entry.
	Data []*string `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// Indicates whether the log is accurate. Valid values:
	//
	// *   **true**: accurate
	// *   **false**: inaccurate
	IsCompleted *bool `json:"IsCompleted,omitempty" xml:"IsCompleted,omitempty"`
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListIpsecServerLogsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListIpsecServerLogsResponseBody) GoString() string {
	return s.String()
}

func (s *ListIpsecServerLogsResponseBody) SetCount(v int32) *ListIpsecServerLogsResponseBody {
	s.Count = &v
	return s
}

func (s *ListIpsecServerLogsResponseBody) SetData(v []*string) *ListIpsecServerLogsResponseBody {
	s.Data = v
	return s
}

func (s *ListIpsecServerLogsResponseBody) SetIsCompleted(v bool) *ListIpsecServerLogsResponseBody {
	s.IsCompleted = &v
	return s
}

func (s *ListIpsecServerLogsResponseBody) SetPageNumber(v int32) *ListIpsecServerLogsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *ListIpsecServerLogsResponseBody) SetPageSize(v int32) *ListIpsecServerLogsResponseBody {
	s.PageSize = &v
	return s
}

func (s *ListIpsecServerLogsResponseBody) SetRequestId(v string) *ListIpsecServerLogsResponseBody {
	s.RequestId = &v
	return s
}

type ListIpsecServerLogsResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListIpsecServerLogsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListIpsecServerLogsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListIpsecServerLogsResponse) GoString() string {
	return s.String()
}

func (s *ListIpsecServerLogsResponse) SetHeaders(v map[string]*string) *ListIpsecServerLogsResponse {
	s.Headers = v
	return s
}

func (s *ListIpsecServerLogsResponse) SetStatusCode(v int32) *ListIpsecServerLogsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListIpsecServerLogsResponse) SetBody(v *ListIpsecServerLogsResponseBody) *ListIpsecServerLogsResponse {
	s.Body = v
	return s
}

type ListIpsecServersRequest struct {
	// The ID of the IPsec server.
	IpsecServerId []*string `json:"IpsecServerId,omitempty" xml:"IpsecServerId,omitempty" type:"Repeated"`
	// The name of the IPsec server.
	//
	// The name must be 1 to 100 characters in length and cannot start with `http://` or `https://`.
	IpsecServerName *string `json:"IpsecServerName,omitempty" xml:"IpsecServerName,omitempty"`
	// The number of entries to return on each page. Valid values: **1** to **20**. Default value: **10**.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The pagination token that is used in the next request to retrieve a new page of results. Valid values:
	//
	// *   If this is your first request and no next requests are to be performed, you do not need to specify this parameter.
	// *   You must specify the token that is obtained from the previous query as the value of **NextToken**.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the region where the IPsec server is created.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the VPN gateway.
	VpnGatewayId *string `json:"VpnGatewayId,omitempty" xml:"VpnGatewayId,omitempty"`
}

func (s ListIpsecServersRequest) String() string {
	return tea.Prettify(s)
}

func (s ListIpsecServersRequest) GoString() string {
	return s.String()
}

func (s *ListIpsecServersRequest) SetIpsecServerId(v []*string) *ListIpsecServersRequest {
	s.IpsecServerId = v
	return s
}

func (s *ListIpsecServersRequest) SetIpsecServerName(v string) *ListIpsecServersRequest {
	s.IpsecServerName = &v
	return s
}

func (s *ListIpsecServersRequest) SetMaxResults(v int32) *ListIpsecServersRequest {
	s.MaxResults = &v
	return s
}

func (s *ListIpsecServersRequest) SetNextToken(v string) *ListIpsecServersRequest {
	s.NextToken = &v
	return s
}

func (s *ListIpsecServersRequest) SetRegionId(v string) *ListIpsecServersRequest {
	s.RegionId = &v
	return s
}

func (s *ListIpsecServersRequest) SetVpnGatewayId(v string) *ListIpsecServersRequest {
	s.VpnGatewayId = &v
	return s
}

type ListIpsecServersResponseBody struct {
	// The Diffie-Hellman key exchange algorithm.
	IpsecServers []*ListIpsecServersResponseBodyIpsecServers `json:"IpsecServers,omitempty" xml:"IpsecServers,omitempty" type:"Repeated"`
	// The number of entries returned per page.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// A pagination token. It can be used in the next request to retrieve a new page of results. Valid values:
	//
	// *   If no value is returned for **NextToken**, no next queries are sent.
	// *   If a value is returned for **NextToken**, the value can be used in the next request to retrieve a new page of results.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListIpsecServersResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListIpsecServersResponseBody) GoString() string {
	return s.String()
}

func (s *ListIpsecServersResponseBody) SetIpsecServers(v []*ListIpsecServersResponseBodyIpsecServers) *ListIpsecServersResponseBody {
	s.IpsecServers = v
	return s
}

func (s *ListIpsecServersResponseBody) SetMaxResults(v int32) *ListIpsecServersResponseBody {
	s.MaxResults = &v
	return s
}

func (s *ListIpsecServersResponseBody) SetNextToken(v string) *ListIpsecServersResponseBody {
	s.NextToken = &v
	return s
}

func (s *ListIpsecServersResponseBody) SetRequestId(v string) *ListIpsecServersResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListIpsecServersResponseBody) SetTotalCount(v int32) *ListIpsecServersResponseBody {
	s.TotalCount = &v
	return s
}

type ListIpsecServersResponseBodyIpsecServers struct {
	// The client CIDR block. It refers to the CIDR block that is allocated to the virtual interface of the client.
	ClientIpPool *string `json:"ClientIpPool,omitempty" xml:"ClientIpPool,omitempty"`
	// The time when the IPsec server was created.
	//
	// T is used as a delimiter. Z indicates that the time is in UTC.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// Indicates whether the current IPsec tunnel is deleted and negotiations are reinitiated. Valid values:
	//
	// *   **true**: immediately initiates negotiations after the configuration is completed.
	// *   **false**: initiates negotiations when inbound traffic is detected.
	EffectImmediately *bool `json:"EffectImmediately,omitempty" xml:"EffectImmediately,omitempty"`
	// The ID of the Identity as a Service (IDaaS) instance.
	IDaaSInstanceId *string `json:"IDaaSInstanceId,omitempty" xml:"IDaaSInstanceId,omitempty"`
	// The configurations of phase 1 negotiations.
	IkeConfig *ListIpsecServersResponseBodyIpsecServersIkeConfig `json:"IkeConfig,omitempty" xml:"IkeConfig,omitempty" type:"Struct"`
	// The public IP address of the VPN gateway.
	InternetIp *string `json:"InternetIp,omitempty" xml:"InternetIp,omitempty"`
	// The configuration of phase 2 negotiations.
	IpsecConfig *ListIpsecServersResponseBodyIpsecServersIpsecConfig `json:"IpsecConfig,omitempty" xml:"IpsecConfig,omitempty" type:"Struct"`
	// The ID of the IPsec server.
	IpsecServerId *string `json:"IpsecServerId,omitempty" xml:"IpsecServerId,omitempty"`
	// The name of the IPsec server.
	IpsecServerName *string `json:"IpsecServerName,omitempty" xml:"IpsecServerName,omitempty"`
	// The local CIDR blocks, which refer to the CIDR blocks on the virtual private cloud (VPC) side.
	LocalSubnet *string `json:"LocalSubnet,omitempty" xml:"LocalSubnet,omitempty"`
	// The number of SSL-VPN connections supported by the VPN gateway.
	//
	// >  The number of SSL-VPN connections specified in this parameter includes both SSL-VPN and IPsec-VPN connections. For example, if a VPN gateway supports up to five SSL-VPN connections, and three SSL-VPN connections are already established to SSL clients. In this case, you can establish at most two connections to IPsec servers.
	MaxConnections *int32 `json:"MaxConnections,omitempty" xml:"MaxConnections,omitempty"`
	// Indicates whether two-factor authentication is enabled. Valid values:
	//
	// *   **true**: yes
	// *   **false**: no
	MultiFactorAuthEnabled *bool `json:"MultiFactorAuthEnabled,omitempty" xml:"MultiFactorAuthEnabled,omitempty"`
	// The number of clients that are connected to the IPsec server.
	OnlineClientCount *int32 `json:"OnlineClientCount,omitempty" xml:"OnlineClientCount,omitempty"`
	// The pre-shared key.
	Psk *string `json:"Psk,omitempty" xml:"Psk,omitempty"`
	// Indicates whether pre-shared key authentication is enabled. Pre-shared key authentication is enabled only when the value is set to **true**.
	PskEnabled *bool `json:"PskEnabled,omitempty" xml:"PskEnabled,omitempty"`
	// The ID of the region where the IPsec server is created.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the VPN gateway.
	VpnGatewayId *string `json:"VpnGatewayId,omitempty" xml:"VpnGatewayId,omitempty"`
}

func (s ListIpsecServersResponseBodyIpsecServers) String() string {
	return tea.Prettify(s)
}

func (s ListIpsecServersResponseBodyIpsecServers) GoString() string {
	return s.String()
}

func (s *ListIpsecServersResponseBodyIpsecServers) SetClientIpPool(v string) *ListIpsecServersResponseBodyIpsecServers {
	s.ClientIpPool = &v
	return s
}

func (s *ListIpsecServersResponseBodyIpsecServers) SetCreationTime(v string) *ListIpsecServersResponseBodyIpsecServers {
	s.CreationTime = &v
	return s
}

func (s *ListIpsecServersResponseBodyIpsecServers) SetEffectImmediately(v bool) *ListIpsecServersResponseBodyIpsecServers {
	s.EffectImmediately = &v
	return s
}

func (s *ListIpsecServersResponseBodyIpsecServers) SetIDaaSInstanceId(v string) *ListIpsecServersResponseBodyIpsecServers {
	s.IDaaSInstanceId = &v
	return s
}

func (s *ListIpsecServersResponseBodyIpsecServers) SetIkeConfig(v *ListIpsecServersResponseBodyIpsecServersIkeConfig) *ListIpsecServersResponseBodyIpsecServers {
	s.IkeConfig = v
	return s
}

func (s *ListIpsecServersResponseBodyIpsecServers) SetInternetIp(v string) *ListIpsecServersResponseBodyIpsecServers {
	s.InternetIp = &v
	return s
}

func (s *ListIpsecServersResponseBodyIpsecServers) SetIpsecConfig(v *ListIpsecServersResponseBodyIpsecServersIpsecConfig) *ListIpsecServersResponseBodyIpsecServers {
	s.IpsecConfig = v
	return s
}

func (s *ListIpsecServersResponseBodyIpsecServers) SetIpsecServerId(v string) *ListIpsecServersResponseBodyIpsecServers {
	s.IpsecServerId = &v
	return s
}

func (s *ListIpsecServersResponseBodyIpsecServers) SetIpsecServerName(v string) *ListIpsecServersResponseBodyIpsecServers {
	s.IpsecServerName = &v
	return s
}

func (s *ListIpsecServersResponseBodyIpsecServers) SetLocalSubnet(v string) *ListIpsecServersResponseBodyIpsecServers {
	s.LocalSubnet = &v
	return s
}

func (s *ListIpsecServersResponseBodyIpsecServers) SetMaxConnections(v int32) *ListIpsecServersResponseBodyIpsecServers {
	s.MaxConnections = &v
	return s
}

func (s *ListIpsecServersResponseBodyIpsecServers) SetMultiFactorAuthEnabled(v bool) *ListIpsecServersResponseBodyIpsecServers {
	s.MultiFactorAuthEnabled = &v
	return s
}

func (s *ListIpsecServersResponseBodyIpsecServers) SetOnlineClientCount(v int32) *ListIpsecServersResponseBodyIpsecServers {
	s.OnlineClientCount = &v
	return s
}

func (s *ListIpsecServersResponseBodyIpsecServers) SetPsk(v string) *ListIpsecServersResponseBodyIpsecServers {
	s.Psk = &v
	return s
}

func (s *ListIpsecServersResponseBodyIpsecServers) SetPskEnabled(v bool) *ListIpsecServersResponseBodyIpsecServers {
	s.PskEnabled = &v
	return s
}

func (s *ListIpsecServersResponseBodyIpsecServers) SetRegionId(v string) *ListIpsecServersResponseBodyIpsecServers {
	s.RegionId = &v
	return s
}

func (s *ListIpsecServersResponseBodyIpsecServers) SetVpnGatewayId(v string) *ListIpsecServersResponseBodyIpsecServers {
	s.VpnGatewayId = &v
	return s
}

type ListIpsecServersResponseBodyIpsecServersIkeConfig struct {
	// The IKE authentication algorithm.
	IkeAuthAlg *string `json:"IkeAuthAlg,omitempty" xml:"IkeAuthAlg,omitempty"`
	// The IKE encryption algorithm.
	IkeEncAlg *string `json:"IkeEncAlg,omitempty" xml:"IkeEncAlg,omitempty"`
	// The IKE lifetime. Unit: seconds.
	IkeLifetime *int64 `json:"IkeLifetime,omitempty" xml:"IkeLifetime,omitempty"`
	// The IKE negotiation mode. Valid values:
	//
	// **main**: This mode offers higher security during negotiations.
	IkeMode *string `json:"IkeMode,omitempty" xml:"IkeMode,omitempty"`
	// The Diffie-Hellman key exchange algorithm.
	IkePfs *string `json:"IkePfs,omitempty" xml:"IkePfs,omitempty"`
	// The IKE version.
	IkeVersion *string `json:"IkeVersion,omitempty" xml:"IkeVersion,omitempty"`
	// The ID of the IPsec server. The default value is the public IP address of the VPN gateway. Both FQDNs and IP addresses are supported.
	LocalId *string `json:"LocalId,omitempty" xml:"LocalId,omitempty"`
	// The identifier of the customer gateway. Both fully qualified domain names (FQDNs) and IP addresses are supported. By default, this parameter is empty.
	RemoteId *string `json:"RemoteId,omitempty" xml:"RemoteId,omitempty"`
}

func (s ListIpsecServersResponseBodyIpsecServersIkeConfig) String() string {
	return tea.Prettify(s)
}

func (s ListIpsecServersResponseBodyIpsecServersIkeConfig) GoString() string {
	return s.String()
}

func (s *ListIpsecServersResponseBodyIpsecServersIkeConfig) SetIkeAuthAlg(v string) *ListIpsecServersResponseBodyIpsecServersIkeConfig {
	s.IkeAuthAlg = &v
	return s
}

func (s *ListIpsecServersResponseBodyIpsecServersIkeConfig) SetIkeEncAlg(v string) *ListIpsecServersResponseBodyIpsecServersIkeConfig {
	s.IkeEncAlg = &v
	return s
}

func (s *ListIpsecServersResponseBodyIpsecServersIkeConfig) SetIkeLifetime(v int64) *ListIpsecServersResponseBodyIpsecServersIkeConfig {
	s.IkeLifetime = &v
	return s
}

func (s *ListIpsecServersResponseBodyIpsecServersIkeConfig) SetIkeMode(v string) *ListIpsecServersResponseBodyIpsecServersIkeConfig {
	s.IkeMode = &v
	return s
}

func (s *ListIpsecServersResponseBodyIpsecServersIkeConfig) SetIkePfs(v string) *ListIpsecServersResponseBodyIpsecServersIkeConfig {
	s.IkePfs = &v
	return s
}

func (s *ListIpsecServersResponseBodyIpsecServersIkeConfig) SetIkeVersion(v string) *ListIpsecServersResponseBodyIpsecServersIkeConfig {
	s.IkeVersion = &v
	return s
}

func (s *ListIpsecServersResponseBodyIpsecServersIkeConfig) SetLocalId(v string) *ListIpsecServersResponseBodyIpsecServersIkeConfig {
	s.LocalId = &v
	return s
}

func (s *ListIpsecServersResponseBodyIpsecServersIkeConfig) SetRemoteId(v string) *ListIpsecServersResponseBodyIpsecServersIkeConfig {
	s.RemoteId = &v
	return s
}

type ListIpsecServersResponseBodyIpsecServersIpsecConfig struct {
	// The IPsec authentication algorithm.
	IpsecAuthAlg *string `json:"IpsecAuthAlg,omitempty" xml:"IpsecAuthAlg,omitempty"`
	// The IPsec encryption algorithm.
	IpsecEncAlg *string `json:"IpsecEncAlg,omitempty" xml:"IpsecEncAlg,omitempty"`
	// The IPsec lifetime. Unit: seconds.
	IpsecLifetime *int64 `json:"IpsecLifetime,omitempty" xml:"IpsecLifetime,omitempty"`
	// The Diffie-Hellman key exchange algorithm.
	IpsecPfs *string `json:"IpsecPfs,omitempty" xml:"IpsecPfs,omitempty"`
}

func (s ListIpsecServersResponseBodyIpsecServersIpsecConfig) String() string {
	return tea.Prettify(s)
}

func (s ListIpsecServersResponseBodyIpsecServersIpsecConfig) GoString() string {
	return s.String()
}

func (s *ListIpsecServersResponseBodyIpsecServersIpsecConfig) SetIpsecAuthAlg(v string) *ListIpsecServersResponseBodyIpsecServersIpsecConfig {
	s.IpsecAuthAlg = &v
	return s
}

func (s *ListIpsecServersResponseBodyIpsecServersIpsecConfig) SetIpsecEncAlg(v string) *ListIpsecServersResponseBodyIpsecServersIpsecConfig {
	s.IpsecEncAlg = &v
	return s
}

func (s *ListIpsecServersResponseBodyIpsecServersIpsecConfig) SetIpsecLifetime(v int64) *ListIpsecServersResponseBodyIpsecServersIpsecConfig {
	s.IpsecLifetime = &v
	return s
}

func (s *ListIpsecServersResponseBodyIpsecServersIpsecConfig) SetIpsecPfs(v string) *ListIpsecServersResponseBodyIpsecServersIpsecConfig {
	s.IpsecPfs = &v
	return s
}

type ListIpsecServersResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListIpsecServersResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListIpsecServersResponse) String() string {
	return tea.Prettify(s)
}

func (s ListIpsecServersResponse) GoString() string {
	return s.String()
}

func (s *ListIpsecServersResponse) SetHeaders(v map[string]*string) *ListIpsecServersResponse {
	s.Headers = v
	return s
}

func (s *ListIpsecServersResponse) SetStatusCode(v int32) *ListIpsecServersResponse {
	s.StatusCode = &v
	return s
}

func (s *ListIpsecServersResponse) SetBody(v *ListIpsecServersResponseBody) *ListIpsecServersResponse {
	s.Body = v
	return s
}

type ListIpv4GatewaysRequest struct {
	// The ID of the IPv4 gateway.
	Ipv4GatewayId *string `json:"Ipv4GatewayId,omitempty" xml:"Ipv4GatewayId,omitempty"`
	// The name of the IPv4 gateway.
	//
	// The name must be 1 to 128 characters in length, and cannot start with `http://` or `https://`.
	Ipv4GatewayName *string `json:"Ipv4GatewayName,omitempty" xml:"Ipv4GatewayName,omitempty"`
	// The number of entries to return on each page. Valid values: **1** to **100**. Default value: **10**.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The token that is used for the next query. Valid values:
	//
	// *   If this is your first query and no next queries are to be sent, ignore this parameter.
	// *   If a next query is to be sent, set the value to the value of NextToken that is returned from the last call.
	NextToken    *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region where the IPv4 gateways to be queried are deployed.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group to which the IPv4 gateway belongs.
	ResourceGroupId      *string                        `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string                        `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64                         `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	Tags                 []*ListIpv4GatewaysRequestTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
	// The ID of the virtual private cloud (VPC) with which the IPv4 gateway is associated.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s ListIpv4GatewaysRequest) String() string {
	return tea.Prettify(s)
}

func (s ListIpv4GatewaysRequest) GoString() string {
	return s.String()
}

func (s *ListIpv4GatewaysRequest) SetIpv4GatewayId(v string) *ListIpv4GatewaysRequest {
	s.Ipv4GatewayId = &v
	return s
}

func (s *ListIpv4GatewaysRequest) SetIpv4GatewayName(v string) *ListIpv4GatewaysRequest {
	s.Ipv4GatewayName = &v
	return s
}

func (s *ListIpv4GatewaysRequest) SetMaxResults(v int32) *ListIpv4GatewaysRequest {
	s.MaxResults = &v
	return s
}

func (s *ListIpv4GatewaysRequest) SetNextToken(v string) *ListIpv4GatewaysRequest {
	s.NextToken = &v
	return s
}

func (s *ListIpv4GatewaysRequest) SetOwnerAccount(v string) *ListIpv4GatewaysRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ListIpv4GatewaysRequest) SetOwnerId(v int64) *ListIpv4GatewaysRequest {
	s.OwnerId = &v
	return s
}

func (s *ListIpv4GatewaysRequest) SetRegionId(v string) *ListIpv4GatewaysRequest {
	s.RegionId = &v
	return s
}

func (s *ListIpv4GatewaysRequest) SetResourceGroupId(v string) *ListIpv4GatewaysRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *ListIpv4GatewaysRequest) SetResourceOwnerAccount(v string) *ListIpv4GatewaysRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ListIpv4GatewaysRequest) SetResourceOwnerId(v int64) *ListIpv4GatewaysRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ListIpv4GatewaysRequest) SetTags(v []*ListIpv4GatewaysRequestTags) *ListIpv4GatewaysRequest {
	s.Tags = v
	return s
}

func (s *ListIpv4GatewaysRequest) SetVpcId(v string) *ListIpv4GatewaysRequest {
	s.VpcId = &v
	return s
}

type ListIpv4GatewaysRequestTags struct {
	// The tag key. You can specify at most 20 tag keys. The tag key cannot be an empty string.
	//
	// The key cannot exceed 64 characters in length, and can contain digits, periods (.), underscores (\_), and hyphens (-). The key must start with a letter but cannot start with `aliyun` or `acs:`. The key cannot contain `http://` or `https://`.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value. You can specify at most 20 tag values. It can be an empty string.
	//
	// The tag value cannot exceed 128 characters in length, and can contain digits, periods (.), underscores (\_), and hyphens (-). It must start with a letter but cannot start with `aliyun` or `acs:`. It cannot contain `http://` or `https://`.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListIpv4GatewaysRequestTags) String() string {
	return tea.Prettify(s)
}

func (s ListIpv4GatewaysRequestTags) GoString() string {
	return s.String()
}

func (s *ListIpv4GatewaysRequestTags) SetKey(v string) *ListIpv4GatewaysRequestTags {
	s.Key = &v
	return s
}

func (s *ListIpv4GatewaysRequestTags) SetValue(v string) *ListIpv4GatewaysRequestTags {
	s.Value = &v
	return s
}

type ListIpv4GatewaysResponseBody struct {
	// The list of IPv4 gateways.
	Ipv4GatewayModels []*ListIpv4GatewaysResponseBodyIpv4GatewayModels `json:"Ipv4GatewayModels,omitempty" xml:"Ipv4GatewayModels,omitempty" type:"Repeated"`
	// The token that is used for the next query. Valid values:
	//
	// *   If no value is returned for **NextToken**, no next queries are sent.
	// *   If a value of **NextToken** is returned, the value is the token that is used for the subsequent query.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalCount *string `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListIpv4GatewaysResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListIpv4GatewaysResponseBody) GoString() string {
	return s.String()
}

func (s *ListIpv4GatewaysResponseBody) SetIpv4GatewayModels(v []*ListIpv4GatewaysResponseBodyIpv4GatewayModels) *ListIpv4GatewaysResponseBody {
	s.Ipv4GatewayModels = v
	return s
}

func (s *ListIpv4GatewaysResponseBody) SetNextToken(v string) *ListIpv4GatewaysResponseBody {
	s.NextToken = &v
	return s
}

func (s *ListIpv4GatewaysResponseBody) SetRequestId(v string) *ListIpv4GatewaysResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListIpv4GatewaysResponseBody) SetTotalCount(v string) *ListIpv4GatewaysResponseBody {
	s.TotalCount = &v
	return s
}

type ListIpv4GatewaysResponseBodyIpv4GatewayModels struct {
	// Indicates whether the IPv4 gateway is activated. Valid values:
	//
	// *   **true**: yes
	// *   **false**: no
	Enabled *bool `json:"Enabled,omitempty" xml:"Enabled,omitempty"`
	// The time when the IPv4 gateway was created.
	GmtCreate *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The description of the IPv4 gateway.
	Ipv4GatewayDescription *string `json:"Ipv4GatewayDescription,omitempty" xml:"Ipv4GatewayDescription,omitempty"`
	// The ID of the IPv4 gateway.
	Ipv4GatewayId *string `json:"Ipv4GatewayId,omitempty" xml:"Ipv4GatewayId,omitempty"`
	// The name of the IPv4 gateway.
	Ipv4GatewayName *string `json:"Ipv4GatewayName,omitempty" xml:"Ipv4GatewayName,omitempty"`
	// The ID of the route table associated with the IPv4 gateway.
	Ipv4GatewayRouteTableId *string `json:"Ipv4GatewayRouteTableId,omitempty" xml:"Ipv4GatewayRouteTableId,omitempty"`
	// The ID of the resource group to which the IPv4 gateway belongs.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The status of the IPv4 gateway. Valid values:
	//
	// *   **Creating**
	// *   **Created**
	// *   **Modifying**
	// *   **Deleting**
	// *   **Deleted**
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The list of tags that are added to the resource group.
	Tags []*ListIpv4GatewaysResponseBodyIpv4GatewayModelsTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
	// The ID of the VPC with which the IPv4 gateways are associated.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s ListIpv4GatewaysResponseBodyIpv4GatewayModels) String() string {
	return tea.Prettify(s)
}

func (s ListIpv4GatewaysResponseBodyIpv4GatewayModels) GoString() string {
	return s.String()
}

func (s *ListIpv4GatewaysResponseBodyIpv4GatewayModels) SetEnabled(v bool) *ListIpv4GatewaysResponseBodyIpv4GatewayModels {
	s.Enabled = &v
	return s
}

func (s *ListIpv4GatewaysResponseBodyIpv4GatewayModels) SetGmtCreate(v string) *ListIpv4GatewaysResponseBodyIpv4GatewayModels {
	s.GmtCreate = &v
	return s
}

func (s *ListIpv4GatewaysResponseBodyIpv4GatewayModels) SetIpv4GatewayDescription(v string) *ListIpv4GatewaysResponseBodyIpv4GatewayModels {
	s.Ipv4GatewayDescription = &v
	return s
}

func (s *ListIpv4GatewaysResponseBodyIpv4GatewayModels) SetIpv4GatewayId(v string) *ListIpv4GatewaysResponseBodyIpv4GatewayModels {
	s.Ipv4GatewayId = &v
	return s
}

func (s *ListIpv4GatewaysResponseBodyIpv4GatewayModels) SetIpv4GatewayName(v string) *ListIpv4GatewaysResponseBodyIpv4GatewayModels {
	s.Ipv4GatewayName = &v
	return s
}

func (s *ListIpv4GatewaysResponseBodyIpv4GatewayModels) SetIpv4GatewayRouteTableId(v string) *ListIpv4GatewaysResponseBodyIpv4GatewayModels {
	s.Ipv4GatewayRouteTableId = &v
	return s
}

func (s *ListIpv4GatewaysResponseBodyIpv4GatewayModels) SetResourceGroupId(v string) *ListIpv4GatewaysResponseBodyIpv4GatewayModels {
	s.ResourceGroupId = &v
	return s
}

func (s *ListIpv4GatewaysResponseBodyIpv4GatewayModels) SetStatus(v string) *ListIpv4GatewaysResponseBodyIpv4GatewayModels {
	s.Status = &v
	return s
}

func (s *ListIpv4GatewaysResponseBodyIpv4GatewayModels) SetTags(v []*ListIpv4GatewaysResponseBodyIpv4GatewayModelsTags) *ListIpv4GatewaysResponseBodyIpv4GatewayModels {
	s.Tags = v
	return s
}

func (s *ListIpv4GatewaysResponseBodyIpv4GatewayModels) SetVpcId(v string) *ListIpv4GatewaysResponseBodyIpv4GatewayModels {
	s.VpcId = &v
	return s
}

type ListIpv4GatewaysResponseBodyIpv4GatewayModelsTags struct {
	// The tag key.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListIpv4GatewaysResponseBodyIpv4GatewayModelsTags) String() string {
	return tea.Prettify(s)
}

func (s ListIpv4GatewaysResponseBodyIpv4GatewayModelsTags) GoString() string {
	return s.String()
}

func (s *ListIpv4GatewaysResponseBodyIpv4GatewayModelsTags) SetKey(v string) *ListIpv4GatewaysResponseBodyIpv4GatewayModelsTags {
	s.Key = &v
	return s
}

func (s *ListIpv4GatewaysResponseBodyIpv4GatewayModelsTags) SetValue(v string) *ListIpv4GatewaysResponseBodyIpv4GatewayModelsTags {
	s.Value = &v
	return s
}

type ListIpv4GatewaysResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListIpv4GatewaysResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListIpv4GatewaysResponse) String() string {
	return tea.Prettify(s)
}

func (s ListIpv4GatewaysResponse) GoString() string {
	return s.String()
}

func (s *ListIpv4GatewaysResponse) SetHeaders(v map[string]*string) *ListIpv4GatewaysResponse {
	s.Headers = v
	return s
}

func (s *ListIpv4GatewaysResponse) SetStatusCode(v int32) *ListIpv4GatewaysResponse {
	s.StatusCode = &v
	return s
}

func (s *ListIpv4GatewaysResponse) SetBody(v *ListIpv4GatewaysResponseBody) *ListIpv4GatewaysResponse {
	s.Body = v
	return s
}

type ListNatIpCidrsRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	//
	// >  If you do not set this parameter, the system automatically uses **RequestId** as **ClientToken**. **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to only precheck this request. Valid values:
	//
	// *   **true**: checks the API request. The CIDR blocks of the NAT gateway are not queried if the API request passes the precheck. The system checks whether your AccessKey pair is valid, whether the Resource Access Management (RAM) user is authorized, and whether the required parameters are set. If the request fails to pass the precheck, the corresponding error message is returned. If the check succeeds, the DryRunOperation error code is returned.
	// *   **false**: sends the API request. If the request passes the precheck, 2xx HTTP status code is returned and the CIDR blocks of the NAT gateway are queried. This is the default value.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The number of entries to return on each page. Valid values: **1** to **100**. Default value: **20**.
	MaxResults *string `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The ID of the VPC NAT gateway that you want to query.
	NatGatewayId *string `json:"NatGatewayId,omitempty" xml:"NatGatewayId,omitempty"`
	// The CIDR block of the NAT gateway that you want to query.
	NatIpCidr *string `json:"NatIpCidr,omitempty" xml:"NatIpCidr,omitempty"`
	// The name of the CIDR block that you want to query. Valid values of **N**: **1** to **20**.
	NatIpCidrName []*string `json:"NatIpCidrName,omitempty" xml:"NatIpCidrName,omitempty" type:"Repeated"`
	// The status of the CIDR block that you want to query. Set the value to **Available**.
	NatIpCidrStatus *string `json:"NatIpCidrStatus,omitempty" xml:"NatIpCidrStatus,omitempty"`
	// The CIDR block of the NAT gateway that you want to query. Valid values of **N**: **1** to **20**.
	NatIpCidrs []*string `json:"NatIpCidrs,omitempty" xml:"NatIpCidrs,omitempty" type:"Repeated"`
	// The token that is used for the next query. Set the value as needed.
	//
	// *   If this is your first query or no next query is to be sent, ignore this parameter.
	// *   If a next query is to be sent, set the value to the value of NextToken that is returned from the last call.
	NextToken    *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the Virtual Private Cloud (VPC) NAT gateway that you want to query.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ListNatIpCidrsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListNatIpCidrsRequest) GoString() string {
	return s.String()
}

func (s *ListNatIpCidrsRequest) SetClientToken(v string) *ListNatIpCidrsRequest {
	s.ClientToken = &v
	return s
}

func (s *ListNatIpCidrsRequest) SetDryRun(v bool) *ListNatIpCidrsRequest {
	s.DryRun = &v
	return s
}

func (s *ListNatIpCidrsRequest) SetMaxResults(v string) *ListNatIpCidrsRequest {
	s.MaxResults = &v
	return s
}

func (s *ListNatIpCidrsRequest) SetNatGatewayId(v string) *ListNatIpCidrsRequest {
	s.NatGatewayId = &v
	return s
}

func (s *ListNatIpCidrsRequest) SetNatIpCidr(v string) *ListNatIpCidrsRequest {
	s.NatIpCidr = &v
	return s
}

func (s *ListNatIpCidrsRequest) SetNatIpCidrName(v []*string) *ListNatIpCidrsRequest {
	s.NatIpCidrName = v
	return s
}

func (s *ListNatIpCidrsRequest) SetNatIpCidrStatus(v string) *ListNatIpCidrsRequest {
	s.NatIpCidrStatus = &v
	return s
}

func (s *ListNatIpCidrsRequest) SetNatIpCidrs(v []*string) *ListNatIpCidrsRequest {
	s.NatIpCidrs = v
	return s
}

func (s *ListNatIpCidrsRequest) SetNextToken(v string) *ListNatIpCidrsRequest {
	s.NextToken = &v
	return s
}

func (s *ListNatIpCidrsRequest) SetOwnerAccount(v string) *ListNatIpCidrsRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ListNatIpCidrsRequest) SetOwnerId(v int64) *ListNatIpCidrsRequest {
	s.OwnerId = &v
	return s
}

func (s *ListNatIpCidrsRequest) SetRegionId(v string) *ListNatIpCidrsRequest {
	s.RegionId = &v
	return s
}

func (s *ListNatIpCidrsRequest) SetResourceOwnerAccount(v string) *ListNatIpCidrsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ListNatIpCidrsRequest) SetResourceOwnerId(v int64) *ListNatIpCidrsRequest {
	s.ResourceOwnerId = &v
	return s
}

type ListNatIpCidrsResponseBody struct {
	// The CIDR blocks of the NAT gateway.
	NatIpCidrs []*ListNatIpCidrsResponseBodyNatIpCidrs `json:"NatIpCidrs,omitempty" xml:"NatIpCidrs,omitempty" type:"Repeated"`
	// The token that is used for the next query. Valid values:
	//
	// *   If the value of **NextToken** is not returned, it indicates that no next query is to be sent.
	// *   If the value of **NextToken** is returned, the value indicates the token that is used for the next query.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The number of CIDR blocks that are returned.
	TotalCount *string `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListNatIpCidrsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListNatIpCidrsResponseBody) GoString() string {
	return s.String()
}

func (s *ListNatIpCidrsResponseBody) SetNatIpCidrs(v []*ListNatIpCidrsResponseBodyNatIpCidrs) *ListNatIpCidrsResponseBody {
	s.NatIpCidrs = v
	return s
}

func (s *ListNatIpCidrsResponseBody) SetNextToken(v string) *ListNatIpCidrsResponseBody {
	s.NextToken = &v
	return s
}

func (s *ListNatIpCidrsResponseBody) SetRequestId(v string) *ListNatIpCidrsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListNatIpCidrsResponseBody) SetTotalCount(v string) *ListNatIpCidrsResponseBody {
	s.TotalCount = &v
	return s
}

type ListNatIpCidrsResponseBodyNatIpCidrs struct {
	// The time when the CIDR block was created.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// Indicates whether the CIDR block is the default CIDR block of the NAT gateway. Valid values:
	//
	// *   **true**: The CIDR block is the default CIDR block of the NAT gateway.
	// *   **false**: The CIDR block is not the default CIDR block of the NAT gateway.
	IsDefault *bool `json:"IsDefault,omitempty" xml:"IsDefault,omitempty"`
	// The ID of the VPC NAT gateway.
	NatGatewayId *string `json:"NatGatewayId,omitempty" xml:"NatGatewayId,omitempty"`
	// The CIDR block of the NAT gateway.
	NatIpCidr *string `json:"NatIpCidr,omitempty" xml:"NatIpCidr,omitempty"`
	// The description of the CIDR block of the NAT gateway.
	NatIpCidrDescription *string `json:"NatIpCidrDescription,omitempty" xml:"NatIpCidrDescription,omitempty"`
	// The ID of the CIDR block of the NAT gateway.
	NatIpCidrId *string `json:"NatIpCidrId,omitempty" xml:"NatIpCidrId,omitempty"`
	// The name of the CIDR block of the NAT gateway.
	NatIpCidrName *string `json:"NatIpCidrName,omitempty" xml:"NatIpCidrName,omitempty"`
	// The status of the CIDR block of the NAT gateway. If **Available** is returned, it indicates that the CIDR block is available.
	NatIpCidrStatus *string `json:"NatIpCidrStatus,omitempty" xml:"NatIpCidrStatus,omitempty"`
}

func (s ListNatIpCidrsResponseBodyNatIpCidrs) String() string {
	return tea.Prettify(s)
}

func (s ListNatIpCidrsResponseBodyNatIpCidrs) GoString() string {
	return s.String()
}

func (s *ListNatIpCidrsResponseBodyNatIpCidrs) SetCreationTime(v string) *ListNatIpCidrsResponseBodyNatIpCidrs {
	s.CreationTime = &v
	return s
}

func (s *ListNatIpCidrsResponseBodyNatIpCidrs) SetIsDefault(v bool) *ListNatIpCidrsResponseBodyNatIpCidrs {
	s.IsDefault = &v
	return s
}

func (s *ListNatIpCidrsResponseBodyNatIpCidrs) SetNatGatewayId(v string) *ListNatIpCidrsResponseBodyNatIpCidrs {
	s.NatGatewayId = &v
	return s
}

func (s *ListNatIpCidrsResponseBodyNatIpCidrs) SetNatIpCidr(v string) *ListNatIpCidrsResponseBodyNatIpCidrs {
	s.NatIpCidr = &v
	return s
}

func (s *ListNatIpCidrsResponseBodyNatIpCidrs) SetNatIpCidrDescription(v string) *ListNatIpCidrsResponseBodyNatIpCidrs {
	s.NatIpCidrDescription = &v
	return s
}

func (s *ListNatIpCidrsResponseBodyNatIpCidrs) SetNatIpCidrId(v string) *ListNatIpCidrsResponseBodyNatIpCidrs {
	s.NatIpCidrId = &v
	return s
}

func (s *ListNatIpCidrsResponseBodyNatIpCidrs) SetNatIpCidrName(v string) *ListNatIpCidrsResponseBodyNatIpCidrs {
	s.NatIpCidrName = &v
	return s
}

func (s *ListNatIpCidrsResponseBodyNatIpCidrs) SetNatIpCidrStatus(v string) *ListNatIpCidrsResponseBodyNatIpCidrs {
	s.NatIpCidrStatus = &v
	return s
}

type ListNatIpCidrsResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListNatIpCidrsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListNatIpCidrsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListNatIpCidrsResponse) GoString() string {
	return s.String()
}

func (s *ListNatIpCidrsResponse) SetHeaders(v map[string]*string) *ListNatIpCidrsResponse {
	s.Headers = v
	return s
}

func (s *ListNatIpCidrsResponse) SetStatusCode(v int32) *ListNatIpCidrsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListNatIpCidrsResponse) SetBody(v *ListNatIpCidrsResponseBody) *ListNatIpCidrsResponse {
	s.Body = v
	return s
}

type ListNatIpsRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	//
	// >  If you do not set this parameter, the system automatically uses **RequestId** as **ClientToken**. **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to only precheck the request. Valid values:
	//
	// *   **true**: checks the API request. IP addresses are not queried. The system checks the required parameters, request syntax, and limits. If the request fails to pass the precheck, the corresponding error message is returned. If the request passes the precheck, the `DryRunOperation` error code is returned.
	// *   **false** (default): sends the request. If the request passes the precheck, a 2xx HTTP status code is returned and the operation is performed.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The number of entries to return on each page. Valid values: **1** to **100**. Default value: **20**.
	MaxResults *string `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The ID of the NAT gateway.
	NatGatewayId *string `json:"NatGatewayId,omitempty" xml:"NatGatewayId,omitempty"`
	// The CIDR block to which the IP address belongs.
	NatIpCidr *string `json:"NatIpCidr,omitempty" xml:"NatIpCidr,omitempty"`
	// The ID of the IP address. Valid values of **N**: **1** to **20**.
	NatIpIds []*string `json:"NatIpIds,omitempty" xml:"NatIpIds,omitempty" type:"Repeated"`
	// The name of the IP address. Valid values of **N**: **1** to **20**.
	NatIpName []*string `json:"NatIpName,omitempty" xml:"NatIpName,omitempty" type:"Repeated"`
	// The status of the IP address. Valid values:
	//
	// *   **Available**
	// *   **Deleting**
	// *   **Creating**
	NatIpStatus *string `json:"NatIpStatus,omitempty" xml:"NatIpStatus,omitempty"`
	// The token that is used for the next query. Valid values:
	//
	// *   If this is your first query or no next query is to be sent, ignore this parameter.
	// *   If a next query is to be sent, set the value to the value of NextToken that is returned from the last call.
	NextToken    *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region where the NAT gateway is deployed.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ListNatIpsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListNatIpsRequest) GoString() string {
	return s.String()
}

func (s *ListNatIpsRequest) SetClientToken(v string) *ListNatIpsRequest {
	s.ClientToken = &v
	return s
}

func (s *ListNatIpsRequest) SetDryRun(v bool) *ListNatIpsRequest {
	s.DryRun = &v
	return s
}

func (s *ListNatIpsRequest) SetMaxResults(v string) *ListNatIpsRequest {
	s.MaxResults = &v
	return s
}

func (s *ListNatIpsRequest) SetNatGatewayId(v string) *ListNatIpsRequest {
	s.NatGatewayId = &v
	return s
}

func (s *ListNatIpsRequest) SetNatIpCidr(v string) *ListNatIpsRequest {
	s.NatIpCidr = &v
	return s
}

func (s *ListNatIpsRequest) SetNatIpIds(v []*string) *ListNatIpsRequest {
	s.NatIpIds = v
	return s
}

func (s *ListNatIpsRequest) SetNatIpName(v []*string) *ListNatIpsRequest {
	s.NatIpName = v
	return s
}

func (s *ListNatIpsRequest) SetNatIpStatus(v string) *ListNatIpsRequest {
	s.NatIpStatus = &v
	return s
}

func (s *ListNatIpsRequest) SetNextToken(v string) *ListNatIpsRequest {
	s.NextToken = &v
	return s
}

func (s *ListNatIpsRequest) SetOwnerAccount(v string) *ListNatIpsRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ListNatIpsRequest) SetOwnerId(v int64) *ListNatIpsRequest {
	s.OwnerId = &v
	return s
}

func (s *ListNatIpsRequest) SetRegionId(v string) *ListNatIpsRequest {
	s.RegionId = &v
	return s
}

func (s *ListNatIpsRequest) SetResourceOwnerAccount(v string) *ListNatIpsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ListNatIpsRequest) SetResourceOwnerId(v int64) *ListNatIpsRequest {
	s.ResourceOwnerId = &v
	return s
}

type ListNatIpsResponseBody struct {
	// The list of IP addresses of the NAT gateway.
	NatIps []*ListNatIpsResponseBodyNatIps `json:"NatIps,omitempty" xml:"NatIps,omitempty" type:"Repeated"`
	// The token that is used for the next query. Valid values:
	//
	// *   If the value of **NextToken** is not returned, it indicates that no next query is to be sent.
	// *   If the value of **NextToken** is returned, the value indicates the token that is used for the next query.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The number of IP addresses that are returned.
	TotalCount *string `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListNatIpsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListNatIpsResponseBody) GoString() string {
	return s.String()
}

func (s *ListNatIpsResponseBody) SetNatIps(v []*ListNatIpsResponseBodyNatIps) *ListNatIpsResponseBody {
	s.NatIps = v
	return s
}

func (s *ListNatIpsResponseBody) SetNextToken(v string) *ListNatIpsResponseBody {
	s.NextToken = &v
	return s
}

func (s *ListNatIpsResponseBody) SetRequestId(v string) *ListNatIpsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListNatIpsResponseBody) SetTotalCount(v string) *ListNatIpsResponseBody {
	s.TotalCount = &v
	return s
}

type ListNatIpsResponseBodyNatIps struct {
	// Indicates whether the IP address is the default IP address of the NAT gateway. Valid values:
	//
	// *   **true**: yes
	// *   **false**: no
	IsDefault *bool `json:"IsDefault,omitempty" xml:"IsDefault,omitempty"`
	// The ID of the Virtual Private Cloud (VPC) NAT gateway to which the IP address is assigned.
	NatGatewayId *string `json:"NatGatewayId,omitempty" xml:"NatGatewayId,omitempty"`
	// The IP address.
	NatIp *string `json:"NatIp,omitempty" xml:"NatIp,omitempty"`
	// The CIDR block to which the IP address belongs.
	NatIpCidr *string `json:"NatIpCidr,omitempty" xml:"NatIpCidr,omitempty"`
	// The description of the IP address.
	NatIpDescription *string `json:"NatIpDescription,omitempty" xml:"NatIpDescription,omitempty"`
	// The ID of the IP address.
	NatIpId *string `json:"NatIpId,omitempty" xml:"NatIpId,omitempty"`
	// The name of the IP address.
	NatIpName *string `json:"NatIpName,omitempty" xml:"NatIpName,omitempty"`
	// The status of the IP address. Valid values:
	//
	// *   **Available**: available
	// *   **Deleted**: deleted
	// *   **Deleting**: deleting
	// *   **Creating**: creating
	// *   **Associated**: specified in an SNAT or DNAT entry
	// *   **Associating**: being specified in an SNAT or DNAT entry
	NatIpStatus *string `json:"NatIpStatus,omitempty" xml:"NatIpStatus,omitempty"`
}

func (s ListNatIpsResponseBodyNatIps) String() string {
	return tea.Prettify(s)
}

func (s ListNatIpsResponseBodyNatIps) GoString() string {
	return s.String()
}

func (s *ListNatIpsResponseBodyNatIps) SetIsDefault(v bool) *ListNatIpsResponseBodyNatIps {
	s.IsDefault = &v
	return s
}

func (s *ListNatIpsResponseBodyNatIps) SetNatGatewayId(v string) *ListNatIpsResponseBodyNatIps {
	s.NatGatewayId = &v
	return s
}

func (s *ListNatIpsResponseBodyNatIps) SetNatIp(v string) *ListNatIpsResponseBodyNatIps {
	s.NatIp = &v
	return s
}

func (s *ListNatIpsResponseBodyNatIps) SetNatIpCidr(v string) *ListNatIpsResponseBodyNatIps {
	s.NatIpCidr = &v
	return s
}

func (s *ListNatIpsResponseBodyNatIps) SetNatIpDescription(v string) *ListNatIpsResponseBodyNatIps {
	s.NatIpDescription = &v
	return s
}

func (s *ListNatIpsResponseBodyNatIps) SetNatIpId(v string) *ListNatIpsResponseBodyNatIps {
	s.NatIpId = &v
	return s
}

func (s *ListNatIpsResponseBodyNatIps) SetNatIpName(v string) *ListNatIpsResponseBodyNatIps {
	s.NatIpName = &v
	return s
}

func (s *ListNatIpsResponseBodyNatIps) SetNatIpStatus(v string) *ListNatIpsResponseBodyNatIps {
	s.NatIpStatus = &v
	return s
}

type ListNatIpsResponse struct {
	Headers    map[string]*string      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListNatIpsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListNatIpsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListNatIpsResponse) GoString() string {
	return s.String()
}

func (s *ListNatIpsResponse) SetHeaders(v map[string]*string) *ListNatIpsResponse {
	s.Headers = v
	return s
}

func (s *ListNatIpsResponse) SetStatusCode(v int32) *ListNatIpsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListNatIpsResponse) SetBody(v *ListNatIpsResponseBody) *ListNatIpsResponse {
	s.Body = v
	return s
}

type ListPrefixListsRequest struct {
	// The number of entries to return on each page. Valid values: **1** to **100**. Default value: **20**.
	MaxResults *int64 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The token that is used for the next query. Valid values:
	//
	// *   If this is your first query and no next queries are to be sent, ignore this parameter.
	// *   If a subsequent query is to be sent, set the parameter to the value of NextToken that is returned from the last call.
	NextToken     *string   `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	OwnerAccount  *string   `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId       *int64    `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	PrefixListIds []*string `json:"PrefixListIds,omitempty" xml:"PrefixListIds,omitempty" type:"Repeated"`
	// The name of the prefix list to query.
	//
	// The name must be 1 to 128 characters in length, and cannot start with `http://` or `https://`.
	PrefixListName *string `json:"PrefixListName,omitempty" xml:"PrefixListName,omitempty"`
	// The ID of the region where you want to query prefix lists.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group to which the prefix list belongs.
	ResourceGroupId      *string                       `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string                       `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64                        `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	Tags                 []*ListPrefixListsRequestTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
}

func (s ListPrefixListsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListPrefixListsRequest) GoString() string {
	return s.String()
}

func (s *ListPrefixListsRequest) SetMaxResults(v int64) *ListPrefixListsRequest {
	s.MaxResults = &v
	return s
}

func (s *ListPrefixListsRequest) SetNextToken(v string) *ListPrefixListsRequest {
	s.NextToken = &v
	return s
}

func (s *ListPrefixListsRequest) SetOwnerAccount(v string) *ListPrefixListsRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ListPrefixListsRequest) SetOwnerId(v int64) *ListPrefixListsRequest {
	s.OwnerId = &v
	return s
}

func (s *ListPrefixListsRequest) SetPrefixListIds(v []*string) *ListPrefixListsRequest {
	s.PrefixListIds = v
	return s
}

func (s *ListPrefixListsRequest) SetPrefixListName(v string) *ListPrefixListsRequest {
	s.PrefixListName = &v
	return s
}

func (s *ListPrefixListsRequest) SetRegionId(v string) *ListPrefixListsRequest {
	s.RegionId = &v
	return s
}

func (s *ListPrefixListsRequest) SetResourceGroupId(v string) *ListPrefixListsRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *ListPrefixListsRequest) SetResourceOwnerAccount(v string) *ListPrefixListsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ListPrefixListsRequest) SetResourceOwnerId(v int64) *ListPrefixListsRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ListPrefixListsRequest) SetTags(v []*ListPrefixListsRequestTags) *ListPrefixListsRequest {
	s.Tags = v
	return s
}

type ListPrefixListsRequestTags struct {
	// The tag key. You can specify at most 20 tag keys. The tag key cannot be an empty string.
	//
	// The key cannot exceed 64 characters in length, and can contain digits, periods (.), underscores (\_), and hyphens (-). The key must start with a letter but cannot start with `aliyun` or `acs:`. The key cannot contain `http://` or `https://`.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value. You can specify at most 20 tag values. It can be an empty string.
	//
	// The tag value cannot exceed 128 characters in length, and can contain digits, periods (.), underscores (\_), and hyphens (-). It must start with a letter but cannot start with `aliyun` or `acs:`. It cannot contain `http://` or `https://`.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListPrefixListsRequestTags) String() string {
	return tea.Prettify(s)
}

func (s ListPrefixListsRequestTags) GoString() string {
	return s.String()
}

func (s *ListPrefixListsRequestTags) SetKey(v string) *ListPrefixListsRequestTags {
	s.Key = &v
	return s
}

func (s *ListPrefixListsRequestTags) SetValue(v string) *ListPrefixListsRequestTags {
	s.Value = &v
	return s
}

type ListPrefixListsResponseBody struct {
	// The number of entries returned per page. Valid values: **1** to **100**. Default value: **20**.
	MaxResults *int64 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The token that is used for the next query. Valid values:
	//
	// *   If no value is returned for **NextToken**, no next queries are sent.
	// *   If a value is returned for **NextToken**, the value indicates the token that is used for the next query.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The information about the prefix lists.
	PrefixLists []*ListPrefixListsResponseBodyPrefixLists `json:"PrefixLists,omitempty" xml:"PrefixLists,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListPrefixListsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListPrefixListsResponseBody) GoString() string {
	return s.String()
}

func (s *ListPrefixListsResponseBody) SetMaxResults(v int64) *ListPrefixListsResponseBody {
	s.MaxResults = &v
	return s
}

func (s *ListPrefixListsResponseBody) SetNextToken(v string) *ListPrefixListsResponseBody {
	s.NextToken = &v
	return s
}

func (s *ListPrefixListsResponseBody) SetPrefixLists(v []*ListPrefixListsResponseBodyPrefixLists) *ListPrefixListsResponseBody {
	s.PrefixLists = v
	return s
}

func (s *ListPrefixListsResponseBody) SetRequestId(v string) *ListPrefixListsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListPrefixListsResponseBody) SetTotalCount(v int64) *ListPrefixListsResponseBody {
	s.TotalCount = &v
	return s
}

type ListPrefixListsResponseBodyPrefixLists struct {
	// The CIDR block specified in the prefix list.
	CidrBlocks []*string `json:"CidrBlocks,omitempty" xml:"CidrBlocks,omitempty" type:"Repeated"`
	// The time when the prefix list was created.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The IP version of the prefix list. Valid values:
	//
	// *   **IPv4**
	// *   **IPV6**
	IpVersion *string `json:"IpVersion,omitempty" xml:"IpVersion,omitempty"`
	// The maximum number of CIDR blocks that you can specify in the prefix list.
	MaxEntries *int32 `json:"MaxEntries,omitempty" xml:"MaxEntries,omitempty"`
	// The Alibaba Cloud account to which the prefix list belongs.
	OwnerId *string `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The description of the prefix list.
	PrefixListDescription *string `json:"PrefixListDescription,omitempty" xml:"PrefixListDescription,omitempty"`
	// The ID of the prefix list.
	PrefixListId *string `json:"PrefixListId,omitempty" xml:"PrefixListId,omitempty"`
	// The name of the prefix list.
	PrefixListName *string `json:"PrefixListName,omitempty" xml:"PrefixListName,omitempty"`
	// The status of the prefix list. Valid values:
	//
	// *   **Created**
	// *   **Deleted**
	// *   **Modifying**
	//
	// >  This parameter is the same as the **Status** parameter.
	PrefixListStatus *string `json:"PrefixListStatus,omitempty" xml:"PrefixListStatus,omitempty"`
	// The region ID of the prefix list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group to which the prefix list belongs.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// Indicates whether the prefix list is shared. Valid values:
	//
	// *   **Shared**: The prefix list is shared.
	// *   If an empty value is returned, it indicates that the prefix list is not shared.
	ShareType *string `json:"ShareType,omitempty" xml:"ShareType,omitempty"`
	// The status of the prefix list. Valid values:
	//
	// *   **Created**
	// *   **Deleted**
	// *   **Modifying**
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The list of tags that are added to the resource group.
	Tags []*ListPrefixListsResponseBodyPrefixListsTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
}

func (s ListPrefixListsResponseBodyPrefixLists) String() string {
	return tea.Prettify(s)
}

func (s ListPrefixListsResponseBodyPrefixLists) GoString() string {
	return s.String()
}

func (s *ListPrefixListsResponseBodyPrefixLists) SetCidrBlocks(v []*string) *ListPrefixListsResponseBodyPrefixLists {
	s.CidrBlocks = v
	return s
}

func (s *ListPrefixListsResponseBodyPrefixLists) SetCreationTime(v string) *ListPrefixListsResponseBodyPrefixLists {
	s.CreationTime = &v
	return s
}

func (s *ListPrefixListsResponseBodyPrefixLists) SetIpVersion(v string) *ListPrefixListsResponseBodyPrefixLists {
	s.IpVersion = &v
	return s
}

func (s *ListPrefixListsResponseBodyPrefixLists) SetMaxEntries(v int32) *ListPrefixListsResponseBodyPrefixLists {
	s.MaxEntries = &v
	return s
}

func (s *ListPrefixListsResponseBodyPrefixLists) SetOwnerId(v string) *ListPrefixListsResponseBodyPrefixLists {
	s.OwnerId = &v
	return s
}

func (s *ListPrefixListsResponseBodyPrefixLists) SetPrefixListDescription(v string) *ListPrefixListsResponseBodyPrefixLists {
	s.PrefixListDescription = &v
	return s
}

func (s *ListPrefixListsResponseBodyPrefixLists) SetPrefixListId(v string) *ListPrefixListsResponseBodyPrefixLists {
	s.PrefixListId = &v
	return s
}

func (s *ListPrefixListsResponseBodyPrefixLists) SetPrefixListName(v string) *ListPrefixListsResponseBodyPrefixLists {
	s.PrefixListName = &v
	return s
}

func (s *ListPrefixListsResponseBodyPrefixLists) SetPrefixListStatus(v string) *ListPrefixListsResponseBodyPrefixLists {
	s.PrefixListStatus = &v
	return s
}

func (s *ListPrefixListsResponseBodyPrefixLists) SetRegionId(v string) *ListPrefixListsResponseBodyPrefixLists {
	s.RegionId = &v
	return s
}

func (s *ListPrefixListsResponseBodyPrefixLists) SetResourceGroupId(v string) *ListPrefixListsResponseBodyPrefixLists {
	s.ResourceGroupId = &v
	return s
}

func (s *ListPrefixListsResponseBodyPrefixLists) SetShareType(v string) *ListPrefixListsResponseBodyPrefixLists {
	s.ShareType = &v
	return s
}

func (s *ListPrefixListsResponseBodyPrefixLists) SetStatus(v string) *ListPrefixListsResponseBodyPrefixLists {
	s.Status = &v
	return s
}

func (s *ListPrefixListsResponseBodyPrefixLists) SetTags(v []*ListPrefixListsResponseBodyPrefixListsTags) *ListPrefixListsResponseBodyPrefixLists {
	s.Tags = v
	return s
}

type ListPrefixListsResponseBodyPrefixListsTags struct {
	// The tag key.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListPrefixListsResponseBodyPrefixListsTags) String() string {
	return tea.Prettify(s)
}

func (s ListPrefixListsResponseBodyPrefixListsTags) GoString() string {
	return s.String()
}

func (s *ListPrefixListsResponseBodyPrefixListsTags) SetKey(v string) *ListPrefixListsResponseBodyPrefixListsTags {
	s.Key = &v
	return s
}

func (s *ListPrefixListsResponseBodyPrefixListsTags) SetValue(v string) *ListPrefixListsResponseBodyPrefixListsTags {
	s.Value = &v
	return s
}

type ListPrefixListsResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListPrefixListsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListPrefixListsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListPrefixListsResponse) GoString() string {
	return s.String()
}

func (s *ListPrefixListsResponse) SetHeaders(v map[string]*string) *ListPrefixListsResponse {
	s.Headers = v
	return s
}

func (s *ListPrefixListsResponse) SetStatusCode(v int32) *ListPrefixListsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListPrefixListsResponse) SetBody(v *ListPrefixListsResponseBody) *ListPrefixListsResponse {
	s.Body = v
	return s
}

type ListPublicIpAddressPoolCidrBlocksRequest struct {
	// The CIDR blocks.
	CidrBlock *string `json:"CidrBlock,omitempty" xml:"CidrBlock,omitempty"`
	// Specifies whether to perform a dry run. Valid values:
	//
	// *   **true**: performs a dry run. The system checks the required parameters, request syntax, and limits. If the request fails the dry run, an error message is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
	// *   **false** (default): performs a dry run and sends the request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The maximum number of entries to return. Valid values: **10** to **100**. Default value: **10**.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The token that is used for the next query. Valid values:
	//
	// *   If this is your first query and no next queries are to be sent, ignore this parameter.
	// *   If a subsequent query is to be sent, set the parameter to the value of NextToken that is returned from the last call.
	NextToken    *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the IP address pool.
	PublicIpAddressPoolId *string `json:"PublicIpAddressPoolId,omitempty" xml:"PublicIpAddressPoolId,omitempty"`
	// The region ID of the CIDR blocks.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ListPublicIpAddressPoolCidrBlocksRequest) String() string {
	return tea.Prettify(s)
}

func (s ListPublicIpAddressPoolCidrBlocksRequest) GoString() string {
	return s.String()
}

func (s *ListPublicIpAddressPoolCidrBlocksRequest) SetCidrBlock(v string) *ListPublicIpAddressPoolCidrBlocksRequest {
	s.CidrBlock = &v
	return s
}

func (s *ListPublicIpAddressPoolCidrBlocksRequest) SetDryRun(v bool) *ListPublicIpAddressPoolCidrBlocksRequest {
	s.DryRun = &v
	return s
}

func (s *ListPublicIpAddressPoolCidrBlocksRequest) SetMaxResults(v int32) *ListPublicIpAddressPoolCidrBlocksRequest {
	s.MaxResults = &v
	return s
}

func (s *ListPublicIpAddressPoolCidrBlocksRequest) SetNextToken(v string) *ListPublicIpAddressPoolCidrBlocksRequest {
	s.NextToken = &v
	return s
}

func (s *ListPublicIpAddressPoolCidrBlocksRequest) SetOwnerAccount(v string) *ListPublicIpAddressPoolCidrBlocksRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ListPublicIpAddressPoolCidrBlocksRequest) SetOwnerId(v int64) *ListPublicIpAddressPoolCidrBlocksRequest {
	s.OwnerId = &v
	return s
}

func (s *ListPublicIpAddressPoolCidrBlocksRequest) SetPublicIpAddressPoolId(v string) *ListPublicIpAddressPoolCidrBlocksRequest {
	s.PublicIpAddressPoolId = &v
	return s
}

func (s *ListPublicIpAddressPoolCidrBlocksRequest) SetRegionId(v string) *ListPublicIpAddressPoolCidrBlocksRequest {
	s.RegionId = &v
	return s
}

func (s *ListPublicIpAddressPoolCidrBlocksRequest) SetResourceOwnerAccount(v string) *ListPublicIpAddressPoolCidrBlocksRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ListPublicIpAddressPoolCidrBlocksRequest) SetResourceOwnerId(v int64) *ListPublicIpAddressPoolCidrBlocksRequest {
	s.ResourceOwnerId = &v
	return s
}

type ListPublicIpAddressPoolCidrBlocksResponseBody struct {
	// The token that is used for the next query. Valid values:
	//
	// *   If **NextToken** was not returned, it indicates that no additional results exist.
	// *   If **NextToken** is returned, the value is the token that is used for the next query.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The total number of entries returned.
	PublicIpPoolCidrBlockList []*ListPublicIpAddressPoolCidrBlocksResponseBodyPublicIpPoolCidrBlockList `json:"PublicIpPoolCidrBlockList,omitempty" xml:"PublicIpPoolCidrBlockList,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The maximum number of entries returned. Valid values: **10** to **100**. Default value: **10**.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListPublicIpAddressPoolCidrBlocksResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListPublicIpAddressPoolCidrBlocksResponseBody) GoString() string {
	return s.String()
}

func (s *ListPublicIpAddressPoolCidrBlocksResponseBody) SetNextToken(v string) *ListPublicIpAddressPoolCidrBlocksResponseBody {
	s.NextToken = &v
	return s
}

func (s *ListPublicIpAddressPoolCidrBlocksResponseBody) SetPublicIpPoolCidrBlockList(v []*ListPublicIpAddressPoolCidrBlocksResponseBodyPublicIpPoolCidrBlockList) *ListPublicIpAddressPoolCidrBlocksResponseBody {
	s.PublicIpPoolCidrBlockList = v
	return s
}

func (s *ListPublicIpAddressPoolCidrBlocksResponseBody) SetRequestId(v string) *ListPublicIpAddressPoolCidrBlocksResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListPublicIpAddressPoolCidrBlocksResponseBody) SetTotalCount(v int32) *ListPublicIpAddressPoolCidrBlocksResponseBody {
	s.TotalCount = &v
	return s
}

type ListPublicIpAddressPoolCidrBlocksResponseBodyPublicIpPoolCidrBlockList struct {
	// The ID of the IP address pool.
	CidrBlock *string `json:"CidrBlock,omitempty" xml:"CidrBlock,omitempty"`
	// The CIDR blocks.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The information about the CIDR blocks.
	PublicIpAddressPoolId *string `json:"PublicIpAddressPoolId,omitempty" xml:"PublicIpAddressPoolId,omitempty"`
	// The time when the CIDR block was created. The time is displayed in `YYYY-MM-DDThh:mm:ssZ` format.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The total number of available IP addresses in the CIDR block.
	TotalIpNum *int32 `json:"TotalIpNum,omitempty" xml:"TotalIpNum,omitempty"`
	// The status of the CIDR block in the IP address pool. Valid values:
	//
	// *   **Created**: available
	// *   **Deleting**: being deleted
	// *   **Modifying**: being modified
	UsedIpNum *int32 `json:"UsedIpNum,omitempty" xml:"UsedIpNum,omitempty"`
}

func (s ListPublicIpAddressPoolCidrBlocksResponseBodyPublicIpPoolCidrBlockList) String() string {
	return tea.Prettify(s)
}

func (s ListPublicIpAddressPoolCidrBlocksResponseBodyPublicIpPoolCidrBlockList) GoString() string {
	return s.String()
}

func (s *ListPublicIpAddressPoolCidrBlocksResponseBodyPublicIpPoolCidrBlockList) SetCidrBlock(v string) *ListPublicIpAddressPoolCidrBlocksResponseBodyPublicIpPoolCidrBlockList {
	s.CidrBlock = &v
	return s
}

func (s *ListPublicIpAddressPoolCidrBlocksResponseBodyPublicIpPoolCidrBlockList) SetCreationTime(v string) *ListPublicIpAddressPoolCidrBlocksResponseBodyPublicIpPoolCidrBlockList {
	s.CreationTime = &v
	return s
}

func (s *ListPublicIpAddressPoolCidrBlocksResponseBodyPublicIpPoolCidrBlockList) SetPublicIpAddressPoolId(v string) *ListPublicIpAddressPoolCidrBlocksResponseBodyPublicIpPoolCidrBlockList {
	s.PublicIpAddressPoolId = &v
	return s
}

func (s *ListPublicIpAddressPoolCidrBlocksResponseBodyPublicIpPoolCidrBlockList) SetStatus(v string) *ListPublicIpAddressPoolCidrBlocksResponseBodyPublicIpPoolCidrBlockList {
	s.Status = &v
	return s
}

func (s *ListPublicIpAddressPoolCidrBlocksResponseBodyPublicIpPoolCidrBlockList) SetTotalIpNum(v int32) *ListPublicIpAddressPoolCidrBlocksResponseBodyPublicIpPoolCidrBlockList {
	s.TotalIpNum = &v
	return s
}

func (s *ListPublicIpAddressPoolCidrBlocksResponseBodyPublicIpPoolCidrBlockList) SetUsedIpNum(v int32) *ListPublicIpAddressPoolCidrBlocksResponseBodyPublicIpPoolCidrBlockList {
	s.UsedIpNum = &v
	return s
}

type ListPublicIpAddressPoolCidrBlocksResponse struct {
	Headers    map[string]*string                             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListPublicIpAddressPoolCidrBlocksResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListPublicIpAddressPoolCidrBlocksResponse) String() string {
	return tea.Prettify(s)
}

func (s ListPublicIpAddressPoolCidrBlocksResponse) GoString() string {
	return s.String()
}

func (s *ListPublicIpAddressPoolCidrBlocksResponse) SetHeaders(v map[string]*string) *ListPublicIpAddressPoolCidrBlocksResponse {
	s.Headers = v
	return s
}

func (s *ListPublicIpAddressPoolCidrBlocksResponse) SetStatusCode(v int32) *ListPublicIpAddressPoolCidrBlocksResponse {
	s.StatusCode = &v
	return s
}

func (s *ListPublicIpAddressPoolCidrBlocksResponse) SetBody(v *ListPublicIpAddressPoolCidrBlocksResponseBody) *ListPublicIpAddressPoolCidrBlocksResponse {
	s.Body = v
	return s
}

type ListPublicIpAddressPoolsRequest struct {
	// Specifies whether to perform a dry run. Valid values:
	//
	// *   **true**: performs a dry run. The system checks the required parameters, request syntax, and limits. If the request fails the dry run, an error message is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
	// *   **false** (default): performs a dry run and sends the request. If the request passes the dry run, an HTTP 2xx status code is returned and the operation is performed.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The line type. Valid values:
	//
	// *   **BGP** (default): BGP (Multi-ISP) lines
	// *   **BGP_PRO**: BGP (Multi-ISP) Pro lines
	//
	// For more information about BGP (Multi-ISP) and BGP (Multi-ISP) Pro, see [EIP line types](~~32321~~).
	//
	// If you are allowed to use single-ISP bandwidth, you can also choose one of the following values:
	//
	// *   **ChinaTelecom**: China Telecom
	// *   **ChinaUnicom**: China Unicom
	// *   **ChinaMobile**: China Mobile
	// *   **ChinaTelecom_L2**: China Telecom L2
	// *   **ChinaUnicom_L2**: China Unicom L2
	// *   **ChinaMobile_L2**: China Mobile L2
	//
	// If your services are deployed in China East 1 Finance, this parameter is required and you must set the value to **BGP_FinanceCloud**.
	Isp *string `json:"Isp,omitempty" xml:"Isp,omitempty"`
	// The maximum number of entries to return. Valid values: **10** to **100**. Default value: **10**.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The name of the IP address pool.
	//
	// This parameter is optional. The name must be 1 to 128 characters in length, and can contain digits, periods (.), underscores (\_), and hyphens (-). The name must start with a letter but cannot start with `http://` or `https://`.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The token that determines the start point of the next query. Valid values:
	//
	// *   If this is your first query and no subsequent queries are to be sent, ignore this parameter.
	// *   If a subsequent query is to be sent, set the parameter to the value of NextToken that is returned from the last call.
	NextToken              *string   `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	OwnerAccount           *string   `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId                *int64    `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	PublicIpAddressPoolIds []*string `json:"PublicIpAddressPoolIds,omitempty" xml:"PublicIpAddressPoolIds,omitempty" type:"Repeated"`
	// The ID of the region where you want to query IP address pools.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group to which the IP address pool belongs.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The status of the IP address pool. Valid values:
	//
	// *   **Created**: The IP address pool is available.
	// *   **Deleting**: The IP address pool is being deleted.
	// *   **Modifying**: The IP address pool is being modified.
	Status *string                                `json:"Status,omitempty" xml:"Status,omitempty"`
	Tags   []*ListPublicIpAddressPoolsRequestTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
}

func (s ListPublicIpAddressPoolsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListPublicIpAddressPoolsRequest) GoString() string {
	return s.String()
}

func (s *ListPublicIpAddressPoolsRequest) SetDryRun(v bool) *ListPublicIpAddressPoolsRequest {
	s.DryRun = &v
	return s
}

func (s *ListPublicIpAddressPoolsRequest) SetIsp(v string) *ListPublicIpAddressPoolsRequest {
	s.Isp = &v
	return s
}

func (s *ListPublicIpAddressPoolsRequest) SetMaxResults(v int32) *ListPublicIpAddressPoolsRequest {
	s.MaxResults = &v
	return s
}

func (s *ListPublicIpAddressPoolsRequest) SetName(v string) *ListPublicIpAddressPoolsRequest {
	s.Name = &v
	return s
}

func (s *ListPublicIpAddressPoolsRequest) SetNextToken(v string) *ListPublicIpAddressPoolsRequest {
	s.NextToken = &v
	return s
}

func (s *ListPublicIpAddressPoolsRequest) SetOwnerAccount(v string) *ListPublicIpAddressPoolsRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ListPublicIpAddressPoolsRequest) SetOwnerId(v int64) *ListPublicIpAddressPoolsRequest {
	s.OwnerId = &v
	return s
}

func (s *ListPublicIpAddressPoolsRequest) SetPublicIpAddressPoolIds(v []*string) *ListPublicIpAddressPoolsRequest {
	s.PublicIpAddressPoolIds = v
	return s
}

func (s *ListPublicIpAddressPoolsRequest) SetRegionId(v string) *ListPublicIpAddressPoolsRequest {
	s.RegionId = &v
	return s
}

func (s *ListPublicIpAddressPoolsRequest) SetResourceGroupId(v string) *ListPublicIpAddressPoolsRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *ListPublicIpAddressPoolsRequest) SetResourceOwnerAccount(v string) *ListPublicIpAddressPoolsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ListPublicIpAddressPoolsRequest) SetResourceOwnerId(v int64) *ListPublicIpAddressPoolsRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ListPublicIpAddressPoolsRequest) SetStatus(v string) *ListPublicIpAddressPoolsRequest {
	s.Status = &v
	return s
}

func (s *ListPublicIpAddressPoolsRequest) SetTags(v []*ListPublicIpAddressPoolsRequestTags) *ListPublicIpAddressPoolsRequest {
	s.Tags = v
	return s
}

type ListPublicIpAddressPoolsRequestTags struct {
	// The key of the tag. You can specify at most 20 tag keys. The tag key cannot be an empty string.
	//
	// The key cannot exceed 64 characters in length, and can contain digits, periods (.), underscores (\_), and hyphens (-). The key must start with a letter but cannot start with `aliyun` or `acs:`. The key cannot contain `http://` or `https://`.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The value of the tag. You can specify at most 20 tag values. The tag value can be an empty string.
	//
	// The tag value cannot exceed 128 characters in length, and can contain digits, periods (.), underscores (\_), and hyphens (-). The key must start with a letter but cannot start with `aliyun` or `acs:`. The key cannot contain `http://` or `https://`.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListPublicIpAddressPoolsRequestTags) String() string {
	return tea.Prettify(s)
}

func (s ListPublicIpAddressPoolsRequestTags) GoString() string {
	return s.String()
}

func (s *ListPublicIpAddressPoolsRequestTags) SetKey(v string) *ListPublicIpAddressPoolsRequestTags {
	s.Key = &v
	return s
}

func (s *ListPublicIpAddressPoolsRequestTags) SetValue(v string) *ListPublicIpAddressPoolsRequestTags {
	s.Value = &v
	return s
}

type ListPublicIpAddressPoolsResponseBody struct {
	// The token that determines the start point of the next query. Valid values:
	//
	// *   If **NextToken** is returned, it indicates that no additional results exist.
	// *   If **NextToken** is returned, the value indicates the token that is used for the next query.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The total number of entries returned.
	PublicIpAddressPoolList []*ListPublicIpAddressPoolsResponseBodyPublicIpAddressPoolList `json:"PublicIpAddressPoolList,omitempty" xml:"PublicIpAddressPoolList,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The maximum number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListPublicIpAddressPoolsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListPublicIpAddressPoolsResponseBody) GoString() string {
	return s.String()
}

func (s *ListPublicIpAddressPoolsResponseBody) SetNextToken(v string) *ListPublicIpAddressPoolsResponseBody {
	s.NextToken = &v
	return s
}

func (s *ListPublicIpAddressPoolsResponseBody) SetPublicIpAddressPoolList(v []*ListPublicIpAddressPoolsResponseBodyPublicIpAddressPoolList) *ListPublicIpAddressPoolsResponseBody {
	s.PublicIpAddressPoolList = v
	return s
}

func (s *ListPublicIpAddressPoolsResponseBody) SetRequestId(v string) *ListPublicIpAddressPoolsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListPublicIpAddressPoolsResponseBody) SetTotalCount(v int32) *ListPublicIpAddressPoolsResponseBody {
	s.TotalCount = &v
	return s
}

type ListPublicIpAddressPoolsResponseBodyPublicIpAddressPoolList struct {
	// The region ID of the IP address pool.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The status of the IP address pool. Valid values:
	//
	// *   **Created**: The IP address pool is available.
	// *   **Deleting**: The IP address pool is being deleted.
	// *   **Modifying**: The IP address pool is being modified.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The number of occupied IP addresses in the public IP address pool.
	IpAddressRemaining *bool `json:"IpAddressRemaining,omitempty" xml:"IpAddressRemaining,omitempty"`
	// The time when the IP address pool was created. The time is displayed in `YYYY-MM-DDThh:mm:ssZ` format.
	Isp *string `json:"Isp,omitempty" xml:"Isp,omitempty"`
	// The line type.
	//
	// *   **BGP**: BGP (Multi-ISP) lines
	// *   **BGP_PRO**: BGP (Multi-ISP) Pro lines
	//
	// For more information about BGP (Multi-ISP) and BGP (Multi-ISP) Pro, see [EIP line types](~~32321~~).
	//
	// If you are allowed to use single-ISP bandwidth, one of the following values is returned:
	//
	// *   **ChinaTelecom**: China Telecom
	// *   **ChinaUnicom**: China Unicom
	// *   **ChinaMobile**: China Mobile
	// *   **ChinaTelecom_L2**: China Telecom L2
	// *   **ChinaUnicom_L2**: China Unicom L2
	// *   **ChinaMobile_L2**: China Mobile L2
	//
	// If your services are deployed in China East 1 Finance, **BGP_FinanceCloud** is returned.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// Indicates whether the IP address pool has idle IP addresses. Valid values:
	//
	// *   **true**: yes
	// *   **false**: no
	OwnerId *int64 `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The list of IP address pools.
	PublicIpAddressPoolId *string `json:"PublicIpAddressPoolId,omitempty" xml:"PublicIpAddressPoolId,omitempty"`
	// The ID of the IP address pool.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// Indicates whether the IP address pool is shared.
	//
	// *   **Shared**: The IP address pool is shared.
	// *   An empty value indicates that the IP address pool is not shared.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The Alibaba Cloud account to which the IP address pool belongs.
	ShareType *string `json:"ShareType,omitempty" xml:"ShareType,omitempty"`
	// The name of the IP address pool.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The ID of the resource group to which the IP address pool belongs.
	Tags []*ListPublicIpAddressPoolsResponseBodyPublicIpAddressPoolListTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
	// The description of the IP address pool.
	TotalIpNum *int32 `json:"TotalIpNum,omitempty" xml:"TotalIpNum,omitempty"`
	// The total number of IP addresses in the public IP address pool.
	UsedIpNum *int32 `json:"UsedIpNum,omitempty" xml:"UsedIpNum,omitempty"`
	UserType  *bool  `json:"UserType,omitempty" xml:"UserType,omitempty"`
}

func (s ListPublicIpAddressPoolsResponseBodyPublicIpAddressPoolList) String() string {
	return tea.Prettify(s)
}

func (s ListPublicIpAddressPoolsResponseBodyPublicIpAddressPoolList) GoString() string {
	return s.String()
}

func (s *ListPublicIpAddressPoolsResponseBodyPublicIpAddressPoolList) SetCreationTime(v string) *ListPublicIpAddressPoolsResponseBodyPublicIpAddressPoolList {
	s.CreationTime = &v
	return s
}

func (s *ListPublicIpAddressPoolsResponseBodyPublicIpAddressPoolList) SetDescription(v string) *ListPublicIpAddressPoolsResponseBodyPublicIpAddressPoolList {
	s.Description = &v
	return s
}

func (s *ListPublicIpAddressPoolsResponseBodyPublicIpAddressPoolList) SetIpAddressRemaining(v bool) *ListPublicIpAddressPoolsResponseBodyPublicIpAddressPoolList {
	s.IpAddressRemaining = &v
	return s
}

func (s *ListPublicIpAddressPoolsResponseBodyPublicIpAddressPoolList) SetIsp(v string) *ListPublicIpAddressPoolsResponseBodyPublicIpAddressPoolList {
	s.Isp = &v
	return s
}

func (s *ListPublicIpAddressPoolsResponseBodyPublicIpAddressPoolList) SetName(v string) *ListPublicIpAddressPoolsResponseBodyPublicIpAddressPoolList {
	s.Name = &v
	return s
}

func (s *ListPublicIpAddressPoolsResponseBodyPublicIpAddressPoolList) SetOwnerId(v int64) *ListPublicIpAddressPoolsResponseBodyPublicIpAddressPoolList {
	s.OwnerId = &v
	return s
}

func (s *ListPublicIpAddressPoolsResponseBodyPublicIpAddressPoolList) SetPublicIpAddressPoolId(v string) *ListPublicIpAddressPoolsResponseBodyPublicIpAddressPoolList {
	s.PublicIpAddressPoolId = &v
	return s
}

func (s *ListPublicIpAddressPoolsResponseBodyPublicIpAddressPoolList) SetRegionId(v string) *ListPublicIpAddressPoolsResponseBodyPublicIpAddressPoolList {
	s.RegionId = &v
	return s
}

func (s *ListPublicIpAddressPoolsResponseBodyPublicIpAddressPoolList) SetResourceGroupId(v string) *ListPublicIpAddressPoolsResponseBodyPublicIpAddressPoolList {
	s.ResourceGroupId = &v
	return s
}

func (s *ListPublicIpAddressPoolsResponseBodyPublicIpAddressPoolList) SetShareType(v string) *ListPublicIpAddressPoolsResponseBodyPublicIpAddressPoolList {
	s.ShareType = &v
	return s
}

func (s *ListPublicIpAddressPoolsResponseBodyPublicIpAddressPoolList) SetStatus(v string) *ListPublicIpAddressPoolsResponseBodyPublicIpAddressPoolList {
	s.Status = &v
	return s
}

func (s *ListPublicIpAddressPoolsResponseBodyPublicIpAddressPoolList) SetTags(v []*ListPublicIpAddressPoolsResponseBodyPublicIpAddressPoolListTags) *ListPublicIpAddressPoolsResponseBodyPublicIpAddressPoolList {
	s.Tags = v
	return s
}

func (s *ListPublicIpAddressPoolsResponseBodyPublicIpAddressPoolList) SetTotalIpNum(v int32) *ListPublicIpAddressPoolsResponseBodyPublicIpAddressPoolList {
	s.TotalIpNum = &v
	return s
}

func (s *ListPublicIpAddressPoolsResponseBodyPublicIpAddressPoolList) SetUsedIpNum(v int32) *ListPublicIpAddressPoolsResponseBodyPublicIpAddressPoolList {
	s.UsedIpNum = &v
	return s
}

func (s *ListPublicIpAddressPoolsResponseBodyPublicIpAddressPoolList) SetUserType(v bool) *ListPublicIpAddressPoolsResponseBodyPublicIpAddressPoolList {
	s.UserType = &v
	return s
}

type ListPublicIpAddressPoolsResponseBodyPublicIpAddressPoolListTags struct {
	// The list of tags.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The key of the tag.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListPublicIpAddressPoolsResponseBodyPublicIpAddressPoolListTags) String() string {
	return tea.Prettify(s)
}

func (s ListPublicIpAddressPoolsResponseBodyPublicIpAddressPoolListTags) GoString() string {
	return s.String()
}

func (s *ListPublicIpAddressPoolsResponseBodyPublicIpAddressPoolListTags) SetKey(v string) *ListPublicIpAddressPoolsResponseBodyPublicIpAddressPoolListTags {
	s.Key = &v
	return s
}

func (s *ListPublicIpAddressPoolsResponseBodyPublicIpAddressPoolListTags) SetValue(v string) *ListPublicIpAddressPoolsResponseBodyPublicIpAddressPoolListTags {
	s.Value = &v
	return s
}

type ListPublicIpAddressPoolsResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListPublicIpAddressPoolsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListPublicIpAddressPoolsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListPublicIpAddressPoolsResponse) GoString() string {
	return s.String()
}

func (s *ListPublicIpAddressPoolsResponse) SetHeaders(v map[string]*string) *ListPublicIpAddressPoolsResponse {
	s.Headers = v
	return s
}

func (s *ListPublicIpAddressPoolsResponse) SetStatusCode(v int32) *ListPublicIpAddressPoolsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListPublicIpAddressPoolsResponse) SetBody(v *ListPublicIpAddressPoolsResponseBody) *ListPublicIpAddressPoolsResponse {
	s.Body = v
	return s
}

type ListTagResourcesRequest struct {
	// The number of entries to return on each page. Valid values:**1** to **50**. Default value: **50**.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The pagination token that is used in the next request to retrieve a new page of results. Valid values:
	//
	// *   You do not need to specify this parameter for the first request.
	// *   You must specify the token that is obtained from the previous query as the value of **NextToken**.
	NextToken    *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the resource.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The resource ID. You can specify up to 20 resource IDs.
	ResourceId           []*string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty" type:"Repeated"`
	ResourceOwnerAccount *string   `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64    `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The resource type. Valid values:
	//
	// *   **VPC**
	// *   **VSWITCH**
	// *   **ROUTETABLE**
	// *   **EIP**
	// *   **VpnGateway**
	// *   **NATGATEWAY**
	// *   **COMMONBANDWIDTHPACKAGE**: EIP bandwidth plan
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The tag value. You can specify up to 20 tag values. It can be an empty string.
	//
	// The value can be up to 128 characters in length and can contain letters, digits, periods (.), underscores (\_), and hyphens (-). The value must start with a letter but cannot start with `aliyun` or `acs:`. The value cannot contain `http://` or `https://`.
	//
	// >  You must specify at least one of **ResourceId.N** and **Tag.N** (**Tag.N.Key** and **Tag.N.Value**).
	Tag []*ListTagResourcesRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s ListTagResourcesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesRequest) GoString() string {
	return s.String()
}

func (s *ListTagResourcesRequest) SetMaxResults(v int32) *ListTagResourcesRequest {
	s.MaxResults = &v
	return s
}

func (s *ListTagResourcesRequest) SetNextToken(v string) *ListTagResourcesRequest {
	s.NextToken = &v
	return s
}

func (s *ListTagResourcesRequest) SetOwnerAccount(v string) *ListTagResourcesRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ListTagResourcesRequest) SetOwnerId(v int64) *ListTagResourcesRequest {
	s.OwnerId = &v
	return s
}

func (s *ListTagResourcesRequest) SetRegionId(v string) *ListTagResourcesRequest {
	s.RegionId = &v
	return s
}

func (s *ListTagResourcesRequest) SetResourceId(v []*string) *ListTagResourcesRequest {
	s.ResourceId = v
	return s
}

func (s *ListTagResourcesRequest) SetResourceOwnerAccount(v string) *ListTagResourcesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ListTagResourcesRequest) SetResourceOwnerId(v int64) *ListTagResourcesRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ListTagResourcesRequest) SetResourceType(v string) *ListTagResourcesRequest {
	s.ResourceType = &v
	return s
}

func (s *ListTagResourcesRequest) SetTag(v []*ListTagResourcesRequestTag) *ListTagResourcesRequest {
	s.Tag = v
	return s
}

type ListTagResourcesRequestTag struct {
	// The key of the tag that is added to the resource. You can specify up to 20 tag keys. The tag key cannot be an empty string.
	//
	// The key can be up to 64 characters in length and can contain letters, digits, periods (.), underscores (\_), and hyphens (-). The key must start with a letter but cannot start with `aliyun` or `acs:`. The key cannot contain `http://` or `https://`.
	//
	// >  Specify at least one of the **ResourceId.N** and **Tag.N** parameters (**Tag.N.Key** and **Tag.N.Value**).
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The value of the tag that is added to the resource. You can specify up to 20 tag values. The tag value can be an empty string.
	//
	// The value can be up to 128 characters in length and can contain letters, digits, periods (.), underscores (\_), and hyphens (-). The value must start with a letter but cannot start with `aliyun` or `acs:`. The value cannot contain `http://` or `https://`.
	//
	// >  Specify at least one of the **ResourceId.N** and **Tag.N** parameters (**Tag.N.Key** and **Tag.N.Value**).
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListTagResourcesRequestTag) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesRequestTag) GoString() string {
	return s.String()
}

func (s *ListTagResourcesRequestTag) SetKey(v string) *ListTagResourcesRequestTag {
	s.Key = &v
	return s
}

func (s *ListTagResourcesRequestTag) SetValue(v string) *ListTagResourcesRequestTag {
	s.Value = &v
	return s
}

type ListTagResourcesResponseBody struct {
	// A pagination token. It can be used in the next request to retrieve a new page of results. Valid values:
	//
	// *   If no value is returned for **NextToken**, no next queries are sent.
	// *   If a value is returned for **NextToken**, the value is used to retrieve a new page of results.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The tag key.
	TagResources *ListTagResourcesResponseBodyTagResources `json:"TagResources,omitempty" xml:"TagResources,omitempty" type:"Struct"`
}

func (s ListTagResourcesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesResponseBody) GoString() string {
	return s.String()
}

func (s *ListTagResourcesResponseBody) SetNextToken(v string) *ListTagResourcesResponseBody {
	s.NextToken = &v
	return s
}

func (s *ListTagResourcesResponseBody) SetRequestId(v string) *ListTagResourcesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListTagResourcesResponseBody) SetTagResources(v *ListTagResourcesResponseBodyTagResources) *ListTagResourcesResponseBody {
	s.TagResources = v
	return s
}

type ListTagResourcesResponseBodyTagResources struct {
	TagResource []*ListTagResourcesResponseBodyTagResourcesTagResource `json:"TagResource,omitempty" xml:"TagResource,omitempty" type:"Repeated"`
}

func (s ListTagResourcesResponseBodyTagResources) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesResponseBodyTagResources) GoString() string {
	return s.String()
}

func (s *ListTagResourcesResponseBodyTagResources) SetTagResource(v []*ListTagResourcesResponseBodyTagResourcesTagResource) *ListTagResourcesResponseBodyTagResources {
	s.TagResource = v
	return s
}

type ListTagResourcesResponseBodyTagResourcesTagResource struct {
	// The ID of the resource.
	ResourceId *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	// The type of the resource. Valid values:
	//
	// *   **VPC**: virtual private cloud (VPC)
	// *   **VSWITCH**: vSwitch
	// *   **ROUTETABLE**: route table
	// *   **EIP**: EIP
	// *   **VpnGateWay**: VPN gateway
	// *   **NATGATEWAY**: NAT gateway
	// *   **COMMONBANDWIDTHPACKAGE**: EIP bandwidth plan
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The tag key.
	TagKey *string `json:"TagKey,omitempty" xml:"TagKey,omitempty"`
	// The tag value.
	TagValue *string `json:"TagValue,omitempty" xml:"TagValue,omitempty"`
}

func (s ListTagResourcesResponseBodyTagResourcesTagResource) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesResponseBodyTagResourcesTagResource) GoString() string {
	return s.String()
}

func (s *ListTagResourcesResponseBodyTagResourcesTagResource) SetResourceId(v string) *ListTagResourcesResponseBodyTagResourcesTagResource {
	s.ResourceId = &v
	return s
}

func (s *ListTagResourcesResponseBodyTagResourcesTagResource) SetResourceType(v string) *ListTagResourcesResponseBodyTagResourcesTagResource {
	s.ResourceType = &v
	return s
}

func (s *ListTagResourcesResponseBodyTagResourcesTagResource) SetTagKey(v string) *ListTagResourcesResponseBodyTagResourcesTagResource {
	s.TagKey = &v
	return s
}

func (s *ListTagResourcesResponseBodyTagResourcesTagResource) SetTagValue(v string) *ListTagResourcesResponseBodyTagResourcesTagResource {
	s.TagValue = &v
	return s
}

type ListTagResourcesResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListTagResourcesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListTagResourcesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesResponse) GoString() string {
	return s.String()
}

func (s *ListTagResourcesResponse) SetHeaders(v map[string]*string) *ListTagResourcesResponse {
	s.Headers = v
	return s
}

func (s *ListTagResourcesResponse) SetStatusCode(v int32) *ListTagResourcesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListTagResourcesResponse) SetBody(v *ListTagResourcesResponseBody) *ListTagResourcesResponse {
	s.Body = v
	return s
}

type ListTagResourcesForExpressConnectRequest struct {
	// The number of entries to return per page. Valid values: **1** to **100**. Default value: **20**.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The token that is used for the next query. Valid values:
	//
	// *   If this is your first query or no next query is to be sent, ignore this parameter.
	// *   If a next query is to be sent, set the value to the value of **NextToken** that is returned in the last call.
	NextToken    *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the resource.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string   `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceId           []*string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty" type:"Repeated"`
	ResourceOwnerAccount *string   `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64    `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The type of the resource. Set the value to **PHYSICALCONNECTION**, which specifies the Express Connect circuit.
	ResourceType *string                                        `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	Tag          []*ListTagResourcesForExpressConnectRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s ListTagResourcesForExpressConnectRequest) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesForExpressConnectRequest) GoString() string {
	return s.String()
}

func (s *ListTagResourcesForExpressConnectRequest) SetMaxResults(v int32) *ListTagResourcesForExpressConnectRequest {
	s.MaxResults = &v
	return s
}

func (s *ListTagResourcesForExpressConnectRequest) SetNextToken(v string) *ListTagResourcesForExpressConnectRequest {
	s.NextToken = &v
	return s
}

func (s *ListTagResourcesForExpressConnectRequest) SetOwnerAccount(v string) *ListTagResourcesForExpressConnectRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ListTagResourcesForExpressConnectRequest) SetOwnerId(v int64) *ListTagResourcesForExpressConnectRequest {
	s.OwnerId = &v
	return s
}

func (s *ListTagResourcesForExpressConnectRequest) SetRegionId(v string) *ListTagResourcesForExpressConnectRequest {
	s.RegionId = &v
	return s
}

func (s *ListTagResourcesForExpressConnectRequest) SetResourceId(v []*string) *ListTagResourcesForExpressConnectRequest {
	s.ResourceId = v
	return s
}

func (s *ListTagResourcesForExpressConnectRequest) SetResourceOwnerAccount(v string) *ListTagResourcesForExpressConnectRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ListTagResourcesForExpressConnectRequest) SetResourceOwnerId(v int64) *ListTagResourcesForExpressConnectRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ListTagResourcesForExpressConnectRequest) SetResourceType(v string) *ListTagResourcesForExpressConnectRequest {
	s.ResourceType = &v
	return s
}

func (s *ListTagResourcesForExpressConnectRequest) SetTag(v []*ListTagResourcesForExpressConnectRequestTag) *ListTagResourcesForExpressConnectRequest {
	s.Tag = v
	return s
}

type ListTagResourcesForExpressConnectRequestTag struct {
	// The key of tag N that is added to the resource. You can specify up to 20 tag keys. The tag key cannot be an empty string.
	//
	// The key cannot exceed 64 characters in length, and can contain digits, periods (.), underscores (\_), and hyphens (-). The key must start with a letter but cannot start with `aliyun` or `acs:`. The key cannot contain `http://` or `https://`.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The value of tag N that is added to the resource. You can specify up to 20 tag values. The tag value can be an empty string.
	//
	// The value cannot exceed 128 characters in length and can contain digits, periods (.), underscores (\_), and hyphens (-). The value must start with a letter but cannot start with `aliyun` or `acs:`. The value cannot contain `http://` or `https://`.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListTagResourcesForExpressConnectRequestTag) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesForExpressConnectRequestTag) GoString() string {
	return s.String()
}

func (s *ListTagResourcesForExpressConnectRequestTag) SetKey(v string) *ListTagResourcesForExpressConnectRequestTag {
	s.Key = &v
	return s
}

func (s *ListTagResourcesForExpressConnectRequestTag) SetValue(v string) *ListTagResourcesForExpressConnectRequestTag {
	s.Value = &v
	return s
}

type ListTagResourcesForExpressConnectResponseBody struct {
	// The token that is used for the next query. Valid values:
	//
	// *   If the return value of **NextToken** is empty, no next query is to be sent.
	// *   If a value is returned for **NextToken**, the value is the token that is used for the next query.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The details about the tag.
	TagResources *ListTagResourcesForExpressConnectResponseBodyTagResources `json:"TagResources,omitempty" xml:"TagResources,omitempty" type:"Struct"`
}

func (s ListTagResourcesForExpressConnectResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesForExpressConnectResponseBody) GoString() string {
	return s.String()
}

func (s *ListTagResourcesForExpressConnectResponseBody) SetNextToken(v string) *ListTagResourcesForExpressConnectResponseBody {
	s.NextToken = &v
	return s
}

func (s *ListTagResourcesForExpressConnectResponseBody) SetRequestId(v string) *ListTagResourcesForExpressConnectResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListTagResourcesForExpressConnectResponseBody) SetTagResources(v *ListTagResourcesForExpressConnectResponseBodyTagResources) *ListTagResourcesForExpressConnectResponseBody {
	s.TagResources = v
	return s
}

type ListTagResourcesForExpressConnectResponseBodyTagResources struct {
	TagResource []*ListTagResourcesForExpressConnectResponseBodyTagResourcesTagResource `json:"TagResource,omitempty" xml:"TagResource,omitempty" type:"Repeated"`
}

func (s ListTagResourcesForExpressConnectResponseBodyTagResources) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesForExpressConnectResponseBodyTagResources) GoString() string {
	return s.String()
}

func (s *ListTagResourcesForExpressConnectResponseBodyTagResources) SetTagResource(v []*ListTagResourcesForExpressConnectResponseBodyTagResourcesTagResource) *ListTagResourcesForExpressConnectResponseBodyTagResources {
	s.TagResource = v
	return s
}

type ListTagResourcesForExpressConnectResponseBodyTagResourcesTagResource struct {
	// The ID of the resource.
	ResourceId *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	// The type of the resource. The value is set to **PHYSICALCONNECTION**, which indicates the Express Connect circuit.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The key of the tag that is added to the resource.
	TagKey *string `json:"TagKey,omitempty" xml:"TagKey,omitempty"`
	// The value of the tag that is added to the resource.
	TagValue *string `json:"TagValue,omitempty" xml:"TagValue,omitempty"`
}

func (s ListTagResourcesForExpressConnectResponseBodyTagResourcesTagResource) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesForExpressConnectResponseBodyTagResourcesTagResource) GoString() string {
	return s.String()
}

func (s *ListTagResourcesForExpressConnectResponseBodyTagResourcesTagResource) SetResourceId(v string) *ListTagResourcesForExpressConnectResponseBodyTagResourcesTagResource {
	s.ResourceId = &v
	return s
}

func (s *ListTagResourcesForExpressConnectResponseBodyTagResourcesTagResource) SetResourceType(v string) *ListTagResourcesForExpressConnectResponseBodyTagResourcesTagResource {
	s.ResourceType = &v
	return s
}

func (s *ListTagResourcesForExpressConnectResponseBodyTagResourcesTagResource) SetTagKey(v string) *ListTagResourcesForExpressConnectResponseBodyTagResourcesTagResource {
	s.TagKey = &v
	return s
}

func (s *ListTagResourcesForExpressConnectResponseBodyTagResourcesTagResource) SetTagValue(v string) *ListTagResourcesForExpressConnectResponseBodyTagResourcesTagResource {
	s.TagValue = &v
	return s
}

type ListTagResourcesForExpressConnectResponse struct {
	Headers    map[string]*string                             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListTagResourcesForExpressConnectResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListTagResourcesForExpressConnectResponse) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesForExpressConnectResponse) GoString() string {
	return s.String()
}

func (s *ListTagResourcesForExpressConnectResponse) SetHeaders(v map[string]*string) *ListTagResourcesForExpressConnectResponse {
	s.Headers = v
	return s
}

func (s *ListTagResourcesForExpressConnectResponse) SetStatusCode(v int32) *ListTagResourcesForExpressConnectResponse {
	s.StatusCode = &v
	return s
}

func (s *ListTagResourcesForExpressConnectResponse) SetBody(v *ListTagResourcesForExpressConnectResponseBody) *ListTagResourcesForExpressConnectResponse {
	s.Body = v
	return s
}

type ListTrafficMirrorFiltersRequest struct {
	// The maximum number of entries to return.
	//
	// Valid values: **1** to **100**. Default value: **10**.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The token that is used for the next query. Valid values:
	//
	// *   If this is your first query and no next queries are to be sent, ignore this parameter.
	// *   If a next query is to be performed, set the value to the NextToken value returned in the last call to the ListListenerCertificates operation.
	NextToken    *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region to which the mirrored traffic belongs.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list. For more information about regions that support traffic mirroring, see [Overview of traffic mirroring](~~207513~~).
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group to which the mirrored traffic belongs.
	ResourceGroupId        *string                                `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount   *string                                `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId        *int64                                 `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	Tags                   []*ListTrafficMirrorFiltersRequestTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
	TrafficMirrorFilterIds []*string                              `json:"TrafficMirrorFilterIds,omitempty" xml:"TrafficMirrorFilterIds,omitempty" type:"Repeated"`
	// The name of the filter.
	TrafficMirrorFilterName *string `json:"TrafficMirrorFilterName,omitempty" xml:"TrafficMirrorFilterName,omitempty"`
}

func (s ListTrafficMirrorFiltersRequest) String() string {
	return tea.Prettify(s)
}

func (s ListTrafficMirrorFiltersRequest) GoString() string {
	return s.String()
}

func (s *ListTrafficMirrorFiltersRequest) SetMaxResults(v int32) *ListTrafficMirrorFiltersRequest {
	s.MaxResults = &v
	return s
}

func (s *ListTrafficMirrorFiltersRequest) SetNextToken(v string) *ListTrafficMirrorFiltersRequest {
	s.NextToken = &v
	return s
}

func (s *ListTrafficMirrorFiltersRequest) SetOwnerAccount(v string) *ListTrafficMirrorFiltersRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ListTrafficMirrorFiltersRequest) SetOwnerId(v int64) *ListTrafficMirrorFiltersRequest {
	s.OwnerId = &v
	return s
}

func (s *ListTrafficMirrorFiltersRequest) SetRegionId(v string) *ListTrafficMirrorFiltersRequest {
	s.RegionId = &v
	return s
}

func (s *ListTrafficMirrorFiltersRequest) SetResourceGroupId(v string) *ListTrafficMirrorFiltersRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *ListTrafficMirrorFiltersRequest) SetResourceOwnerAccount(v string) *ListTrafficMirrorFiltersRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ListTrafficMirrorFiltersRequest) SetResourceOwnerId(v int64) *ListTrafficMirrorFiltersRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ListTrafficMirrorFiltersRequest) SetTags(v []*ListTrafficMirrorFiltersRequestTags) *ListTrafficMirrorFiltersRequest {
	s.Tags = v
	return s
}

func (s *ListTrafficMirrorFiltersRequest) SetTrafficMirrorFilterIds(v []*string) *ListTrafficMirrorFiltersRequest {
	s.TrafficMirrorFilterIds = v
	return s
}

func (s *ListTrafficMirrorFiltersRequest) SetTrafficMirrorFilterName(v string) *ListTrafficMirrorFiltersRequest {
	s.TrafficMirrorFilterName = &v
	return s
}

type ListTrafficMirrorFiltersRequestTags struct {
	// The tag key. You can specify at most 20 tag keys. The tag key cannot be an empty string.
	//
	// The key cannot exceed 64 characters in length, and can contain digits, periods (.), underscores (\_), and hyphens (-). The key must start with a letter but cannot start with `aliyun` or `acs:`. The key cannot contain `http://` or `https://`.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value. You can specify at most 20 tag values. The tag value can be an empty string.
	//
	// The tag value cannot exceed 128 characters in length, and can contain digits, periods (.), underscores (\_), and hyphens (-). It must start with a letter but cannot start with `aliyun` or `acs:`. It cannot contain `http://` or `https://`.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListTrafficMirrorFiltersRequestTags) String() string {
	return tea.Prettify(s)
}

func (s ListTrafficMirrorFiltersRequestTags) GoString() string {
	return s.String()
}

func (s *ListTrafficMirrorFiltersRequestTags) SetKey(v string) *ListTrafficMirrorFiltersRequestTags {
	s.Key = &v
	return s
}

func (s *ListTrafficMirrorFiltersRequestTags) SetValue(v string) *ListTrafficMirrorFiltersRequestTags {
	s.Value = &v
	return s
}

type ListTrafficMirrorFiltersResponseBody struct {
	Count      *int32 `json:"Count,omitempty" xml:"Count,omitempty"`
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The token that is used for the next query. Valid values:
	//
	// *   If no value is returned for **NextToken**, no next queries are sent.
	// *   If the return value of **NextToken** is not empty, the value indicates the token that is used for the next query.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The number of entries returned.
	TotalCount *string `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
	// The details about the filters.
	TrafficMirrorFilters []*ListTrafficMirrorFiltersResponseBodyTrafficMirrorFilters `json:"TrafficMirrorFilters,omitempty" xml:"TrafficMirrorFilters,omitempty" type:"Repeated"`
}

func (s ListTrafficMirrorFiltersResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListTrafficMirrorFiltersResponseBody) GoString() string {
	return s.String()
}

func (s *ListTrafficMirrorFiltersResponseBody) SetCount(v int32) *ListTrafficMirrorFiltersResponseBody {
	s.Count = &v
	return s
}

func (s *ListTrafficMirrorFiltersResponseBody) SetMaxResults(v int32) *ListTrafficMirrorFiltersResponseBody {
	s.MaxResults = &v
	return s
}

func (s *ListTrafficMirrorFiltersResponseBody) SetNextToken(v string) *ListTrafficMirrorFiltersResponseBody {
	s.NextToken = &v
	return s
}

func (s *ListTrafficMirrorFiltersResponseBody) SetRequestId(v string) *ListTrafficMirrorFiltersResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListTrafficMirrorFiltersResponseBody) SetTotalCount(v string) *ListTrafficMirrorFiltersResponseBody {
	s.TotalCount = &v
	return s
}

func (s *ListTrafficMirrorFiltersResponseBody) SetTrafficMirrorFilters(v []*ListTrafficMirrorFiltersResponseBodyTrafficMirrorFilters) *ListTrafficMirrorFiltersResponseBody {
	s.TrafficMirrorFilters = v
	return s
}

type ListTrafficMirrorFiltersResponseBodyTrafficMirrorFilters struct {
	// The details about the outbound rules.
	EgressRules []*ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersEgressRules `json:"EgressRules,omitempty" xml:"EgressRules,omitempty" type:"Repeated"`
	// The details about the inbound rules.
	IngressRules []*ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersIngressRules `json:"IngressRules,omitempty" xml:"IngressRules,omitempty" type:"Repeated"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The list of tags.
	Tags []*ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
	// The description of the filter.
	TrafficMirrorFilterDescription *string `json:"TrafficMirrorFilterDescription,omitempty" xml:"TrafficMirrorFilterDescription,omitempty"`
	// The ID of the filter.
	TrafficMirrorFilterId *string `json:"TrafficMirrorFilterId,omitempty" xml:"TrafficMirrorFilterId,omitempty"`
	// The name of the filter.
	TrafficMirrorFilterName *string `json:"TrafficMirrorFilterName,omitempty" xml:"TrafficMirrorFilterName,omitempty"`
	// The status of the filter. Valid values:
	//
	// *   **Creating**
	// *   **Created**
	// *   **Modifying**
	// *   **Deleting**
	TrafficMirrorFilterStatus *string `json:"TrafficMirrorFilterStatus,omitempty" xml:"TrafficMirrorFilterStatus,omitempty"`
}

func (s ListTrafficMirrorFiltersResponseBodyTrafficMirrorFilters) String() string {
	return tea.Prettify(s)
}

func (s ListTrafficMirrorFiltersResponseBodyTrafficMirrorFilters) GoString() string {
	return s.String()
}

func (s *ListTrafficMirrorFiltersResponseBodyTrafficMirrorFilters) SetEgressRules(v []*ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersEgressRules) *ListTrafficMirrorFiltersResponseBodyTrafficMirrorFilters {
	s.EgressRules = v
	return s
}

func (s *ListTrafficMirrorFiltersResponseBodyTrafficMirrorFilters) SetIngressRules(v []*ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersIngressRules) *ListTrafficMirrorFiltersResponseBodyTrafficMirrorFilters {
	s.IngressRules = v
	return s
}

func (s *ListTrafficMirrorFiltersResponseBodyTrafficMirrorFilters) SetResourceGroupId(v string) *ListTrafficMirrorFiltersResponseBodyTrafficMirrorFilters {
	s.ResourceGroupId = &v
	return s
}

func (s *ListTrafficMirrorFiltersResponseBodyTrafficMirrorFilters) SetTags(v []*ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersTags) *ListTrafficMirrorFiltersResponseBodyTrafficMirrorFilters {
	s.Tags = v
	return s
}

func (s *ListTrafficMirrorFiltersResponseBodyTrafficMirrorFilters) SetTrafficMirrorFilterDescription(v string) *ListTrafficMirrorFiltersResponseBodyTrafficMirrorFilters {
	s.TrafficMirrorFilterDescription = &v
	return s
}

func (s *ListTrafficMirrorFiltersResponseBodyTrafficMirrorFilters) SetTrafficMirrorFilterId(v string) *ListTrafficMirrorFiltersResponseBodyTrafficMirrorFilters {
	s.TrafficMirrorFilterId = &v
	return s
}

func (s *ListTrafficMirrorFiltersResponseBodyTrafficMirrorFilters) SetTrafficMirrorFilterName(v string) *ListTrafficMirrorFiltersResponseBodyTrafficMirrorFilters {
	s.TrafficMirrorFilterName = &v
	return s
}

func (s *ListTrafficMirrorFiltersResponseBodyTrafficMirrorFilters) SetTrafficMirrorFilterStatus(v string) *ListTrafficMirrorFiltersResponseBodyTrafficMirrorFilters {
	s.TrafficMirrorFilterStatus = &v
	return s
}

type ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersEgressRules struct {
	// The action of the outbound rule. Valid values:
	//
	// *   **accept**: collects network traffic.
	// *   **drop**: does not collect network traffic.
	Action *string `json:"Action,omitempty" xml:"Action,omitempty"`
	// The destination CIDR block of the outbound traffic.
	DestinationCidrBlock *string `json:"DestinationCidrBlock,omitempty" xml:"DestinationCidrBlock,omitempty"`
	// The destination port range of the outbound traffic.
	DestinationPortRange *string `json:"DestinationPortRange,omitempty" xml:"DestinationPortRange,omitempty"`
	// The priority of the outbound rule. A smaller value indicates a higher priority.
	Priority *int32 `json:"Priority,omitempty" xml:"Priority,omitempty"`
	// The protocol that is used by the outbound traffic to be mirrored. Valid values:
	//
	// *   **ALL**: all protocols
	// *   **ICMP**: ICMP
	// *   **TCP**: TCP
	// *   **UDP**: UDP
	Protocol *string `json:"Protocol,omitempty" xml:"Protocol,omitempty"`
	// The source CIDR block of the outbound traffic.
	SourceCidrBlock *string `json:"SourceCidrBlock,omitempty" xml:"SourceCidrBlock,omitempty"`
	// The source port range of the outbound traffic.
	SourcePortRange *string `json:"SourcePortRange,omitempty" xml:"SourcePortRange,omitempty"`
	// The direction of the network traffic. Valid values:
	//
	// *   **egress**: outbound
	// *   **ingress**: inbound
	TrafficDirection *string `json:"TrafficDirection,omitempty" xml:"TrafficDirection,omitempty"`
	// The ID of the filter associated with the outbound rule.
	TrafficMirrorFilterId *string `json:"TrafficMirrorFilterId,omitempty" xml:"TrafficMirrorFilterId,omitempty"`
	// The ID of the outbound rule.
	TrafficMirrorFilterRuleId *string `json:"TrafficMirrorFilterRuleId,omitempty" xml:"TrafficMirrorFilterRuleId,omitempty"`
	// The status of the outbound rule. Valid values:
	//
	// *   **Creating**
	// *   **Created**
	// *   **Modifying**
	// *   **Deleting**
	TrafficMirrorFilterRuleStatus *string `json:"TrafficMirrorFilterRuleStatus,omitempty" xml:"TrafficMirrorFilterRuleStatus,omitempty"`
}

func (s ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersEgressRules) String() string {
	return tea.Prettify(s)
}

func (s ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersEgressRules) GoString() string {
	return s.String()
}

func (s *ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersEgressRules) SetAction(v string) *ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersEgressRules {
	s.Action = &v
	return s
}

func (s *ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersEgressRules) SetDestinationCidrBlock(v string) *ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersEgressRules {
	s.DestinationCidrBlock = &v
	return s
}

func (s *ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersEgressRules) SetDestinationPortRange(v string) *ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersEgressRules {
	s.DestinationPortRange = &v
	return s
}

func (s *ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersEgressRules) SetPriority(v int32) *ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersEgressRules {
	s.Priority = &v
	return s
}

func (s *ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersEgressRules) SetProtocol(v string) *ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersEgressRules {
	s.Protocol = &v
	return s
}

func (s *ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersEgressRules) SetSourceCidrBlock(v string) *ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersEgressRules {
	s.SourceCidrBlock = &v
	return s
}

func (s *ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersEgressRules) SetSourcePortRange(v string) *ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersEgressRules {
	s.SourcePortRange = &v
	return s
}

func (s *ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersEgressRules) SetTrafficDirection(v string) *ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersEgressRules {
	s.TrafficDirection = &v
	return s
}

func (s *ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersEgressRules) SetTrafficMirrorFilterId(v string) *ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersEgressRules {
	s.TrafficMirrorFilterId = &v
	return s
}

func (s *ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersEgressRules) SetTrafficMirrorFilterRuleId(v string) *ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersEgressRules {
	s.TrafficMirrorFilterRuleId = &v
	return s
}

func (s *ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersEgressRules) SetTrafficMirrorFilterRuleStatus(v string) *ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersEgressRules {
	s.TrafficMirrorFilterRuleStatus = &v
	return s
}

type ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersIngressRules struct {
	// The action of the inbound rule. Valid values:
	//
	// *   **accept**: accepts network traffic.
	// *   **drop**: does not collect network traffic.
	Action *string `json:"Action,omitempty" xml:"Action,omitempty"`
	// The destination CIDR block of the inbound traffic.
	DestinationCidrBlock *string `json:"DestinationCidrBlock,omitempty" xml:"DestinationCidrBlock,omitempty"`
	// The destination port range of the inbound traffic.
	DestinationPortRange *string `json:"DestinationPortRange,omitempty" xml:"DestinationPortRange,omitempty"`
	// The priority of the inbound rule. A smaller value indicates a higher priority.
	Priority *int32 `json:"Priority,omitempty" xml:"Priority,omitempty"`
	// The protocol that is used by the inbound traffic to be mirrored. Valid values:
	//
	// *   **ALL**: all protocols
	// *   **ICMP**: ICMP
	// *   **TCP**: TCP
	// *   **UDP**: UDP
	Protocol *string `json:"Protocol,omitempty" xml:"Protocol,omitempty"`
	// The source CIDR block of the inbound traffic.
	SourceCidrBlock *string `json:"SourceCidrBlock,omitempty" xml:"SourceCidrBlock,omitempty"`
	// The destination port range of the inbound traffic.
	SourcePortRange *string `json:"SourcePortRange,omitempty" xml:"SourcePortRange,omitempty"`
	// The direction of the network traffic. Valid values:
	//
	// *   **egress**: outbound
	// *   **ingress**: inbound
	TrafficDirection *string `json:"TrafficDirection,omitempty" xml:"TrafficDirection,omitempty"`
	// The ID of the filter associated with the inbound rule.
	TrafficMirrorFilterId *string `json:"TrafficMirrorFilterId,omitempty" xml:"TrafficMirrorFilterId,omitempty"`
	// The ID of the inbound rule.
	TrafficMirrorFilterRuleId *string `json:"TrafficMirrorFilterRuleId,omitempty" xml:"TrafficMirrorFilterRuleId,omitempty"`
	// The status of the inbound rule. Valid values:
	//
	// *   **Creating**
	// *   **Created**
	// *   **Modifying**
	// *   **Deleting**
	TrafficMirrorFilterRuleStatus *string `json:"TrafficMirrorFilterRuleStatus,omitempty" xml:"TrafficMirrorFilterRuleStatus,omitempty"`
}

func (s ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersIngressRules) String() string {
	return tea.Prettify(s)
}

func (s ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersIngressRules) GoString() string {
	return s.String()
}

func (s *ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersIngressRules) SetAction(v string) *ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersIngressRules {
	s.Action = &v
	return s
}

func (s *ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersIngressRules) SetDestinationCidrBlock(v string) *ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersIngressRules {
	s.DestinationCidrBlock = &v
	return s
}

func (s *ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersIngressRules) SetDestinationPortRange(v string) *ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersIngressRules {
	s.DestinationPortRange = &v
	return s
}

func (s *ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersIngressRules) SetPriority(v int32) *ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersIngressRules {
	s.Priority = &v
	return s
}

func (s *ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersIngressRules) SetProtocol(v string) *ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersIngressRules {
	s.Protocol = &v
	return s
}

func (s *ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersIngressRules) SetSourceCidrBlock(v string) *ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersIngressRules {
	s.SourceCidrBlock = &v
	return s
}

func (s *ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersIngressRules) SetSourcePortRange(v string) *ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersIngressRules {
	s.SourcePortRange = &v
	return s
}

func (s *ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersIngressRules) SetTrafficDirection(v string) *ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersIngressRules {
	s.TrafficDirection = &v
	return s
}

func (s *ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersIngressRules) SetTrafficMirrorFilterId(v string) *ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersIngressRules {
	s.TrafficMirrorFilterId = &v
	return s
}

func (s *ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersIngressRules) SetTrafficMirrorFilterRuleId(v string) *ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersIngressRules {
	s.TrafficMirrorFilterRuleId = &v
	return s
}

func (s *ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersIngressRules) SetTrafficMirrorFilterRuleStatus(v string) *ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersIngressRules {
	s.TrafficMirrorFilterRuleStatus = &v
	return s
}

type ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersTags struct {
	// The tag key.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersTags) String() string {
	return tea.Prettify(s)
}

func (s ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersTags) GoString() string {
	return s.String()
}

func (s *ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersTags) SetKey(v string) *ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersTags {
	s.Key = &v
	return s
}

func (s *ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersTags) SetValue(v string) *ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersTags {
	s.Value = &v
	return s
}

type ListTrafficMirrorFiltersResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListTrafficMirrorFiltersResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListTrafficMirrorFiltersResponse) String() string {
	return tea.Prettify(s)
}

func (s ListTrafficMirrorFiltersResponse) GoString() string {
	return s.String()
}

func (s *ListTrafficMirrorFiltersResponse) SetHeaders(v map[string]*string) *ListTrafficMirrorFiltersResponse {
	s.Headers = v
	return s
}

func (s *ListTrafficMirrorFiltersResponse) SetStatusCode(v int32) *ListTrafficMirrorFiltersResponse {
	s.StatusCode = &v
	return s
}

func (s *ListTrafficMirrorFiltersResponse) SetBody(v *ListTrafficMirrorFiltersResponseBody) *ListTrafficMirrorFiltersResponse {
	s.Body = v
	return s
}

type ListTrafficMirrorSessionsRequest struct {
	// Specifies whether to enable the traffic mirror session. Valid values:
	//
	// *   **false** (default): does not enable the traffic mirror session.
	// *   **true**: enables the traffic mirror session.
	Enabled *bool `json:"Enabled,omitempty" xml:"Enabled,omitempty"`
	// The maximum number of entries to return. Valid values: **1** to **100**. Default value: **10**.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The token that is used for the next query. Valid values:
	//
	// *   If this is your first query and no next queries are to be sent, ignore this parameter.
	// *   If a next query is to be sent, set the value to the value of NextToken that is returned from the last call.
	NextToken    *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The priority of the traffic mirror session. Valid values: **1** to **32766**.
	//
	// A smaller value indicates a higher priority. You cannot specify identical priorities for traffic mirror sessions that are created in the same region by using the same account.
	Priority *int32 `json:"Priority,omitempty" xml:"Priority,omitempty"`
	// The ID of the region to which the traffic mirror session belongs. You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list. For more information about regions that support traffic mirroring, see [Overview of traffic mirroring](~~207513~~).
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group to which the mirrored traffic belongs.
	ResourceGroupId      *string                                 `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string                                 `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64                                  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	Tags                 []*ListTrafficMirrorSessionsRequestTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
	// The ID of the traffic mirror filter.
	TrafficMirrorFilterId   *string   `json:"TrafficMirrorFilterId,omitempty" xml:"TrafficMirrorFilterId,omitempty"`
	TrafficMirrorSessionIds []*string `json:"TrafficMirrorSessionIds,omitempty" xml:"TrafficMirrorSessionIds,omitempty" type:"Repeated"`
	// The name of the traffic mirror session.
	//
	// The name must be 1 to 128 characters in length, and cannot start with `http://` or `https://`.
	TrafficMirrorSessionName *string `json:"TrafficMirrorSessionName,omitempty" xml:"TrafficMirrorSessionName,omitempty"`
	// The ID of the traffic mirror source. You can specify only an elastic network interface (ENI) as the mirror source.
	TrafficMirrorSourceId *string `json:"TrafficMirrorSourceId,omitempty" xml:"TrafficMirrorSourceId,omitempty"`
	// The ID of the traffic mirror destination. You can specify only an ENI or a Server Load Balancer (SLB) instance as a traffic mirror destination.
	TrafficMirrorTargetId *string `json:"TrafficMirrorTargetId,omitempty" xml:"TrafficMirrorTargetId,omitempty"`
	// The VXLAN network identifier (VNI) that is used to distinguish different mirrored traffic. Valid values: **0** to **16777215**. You can use VNIs to identify mirrored traffic from different sessions at the traffic mirror destination. You can specify a custom VNI or use a random VNI that is allocated by the system. If you want the system to randomly allocate a VNI, ignore this parameter.
	VirtualNetworkId *int32 `json:"VirtualNetworkId,omitempty" xml:"VirtualNetworkId,omitempty"`
}

func (s ListTrafficMirrorSessionsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListTrafficMirrorSessionsRequest) GoString() string {
	return s.String()
}

func (s *ListTrafficMirrorSessionsRequest) SetEnabled(v bool) *ListTrafficMirrorSessionsRequest {
	s.Enabled = &v
	return s
}

func (s *ListTrafficMirrorSessionsRequest) SetMaxResults(v int32) *ListTrafficMirrorSessionsRequest {
	s.MaxResults = &v
	return s
}

func (s *ListTrafficMirrorSessionsRequest) SetNextToken(v string) *ListTrafficMirrorSessionsRequest {
	s.NextToken = &v
	return s
}

func (s *ListTrafficMirrorSessionsRequest) SetOwnerAccount(v string) *ListTrafficMirrorSessionsRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ListTrafficMirrorSessionsRequest) SetOwnerId(v int64) *ListTrafficMirrorSessionsRequest {
	s.OwnerId = &v
	return s
}

func (s *ListTrafficMirrorSessionsRequest) SetPriority(v int32) *ListTrafficMirrorSessionsRequest {
	s.Priority = &v
	return s
}

func (s *ListTrafficMirrorSessionsRequest) SetRegionId(v string) *ListTrafficMirrorSessionsRequest {
	s.RegionId = &v
	return s
}

func (s *ListTrafficMirrorSessionsRequest) SetResourceGroupId(v string) *ListTrafficMirrorSessionsRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *ListTrafficMirrorSessionsRequest) SetResourceOwnerAccount(v string) *ListTrafficMirrorSessionsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ListTrafficMirrorSessionsRequest) SetResourceOwnerId(v int64) *ListTrafficMirrorSessionsRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ListTrafficMirrorSessionsRequest) SetTags(v []*ListTrafficMirrorSessionsRequestTags) *ListTrafficMirrorSessionsRequest {
	s.Tags = v
	return s
}

func (s *ListTrafficMirrorSessionsRequest) SetTrafficMirrorFilterId(v string) *ListTrafficMirrorSessionsRequest {
	s.TrafficMirrorFilterId = &v
	return s
}

func (s *ListTrafficMirrorSessionsRequest) SetTrafficMirrorSessionIds(v []*string) *ListTrafficMirrorSessionsRequest {
	s.TrafficMirrorSessionIds = v
	return s
}

func (s *ListTrafficMirrorSessionsRequest) SetTrafficMirrorSessionName(v string) *ListTrafficMirrorSessionsRequest {
	s.TrafficMirrorSessionName = &v
	return s
}

func (s *ListTrafficMirrorSessionsRequest) SetTrafficMirrorSourceId(v string) *ListTrafficMirrorSessionsRequest {
	s.TrafficMirrorSourceId = &v
	return s
}

func (s *ListTrafficMirrorSessionsRequest) SetTrafficMirrorTargetId(v string) *ListTrafficMirrorSessionsRequest {
	s.TrafficMirrorTargetId = &v
	return s
}

func (s *ListTrafficMirrorSessionsRequest) SetVirtualNetworkId(v int32) *ListTrafficMirrorSessionsRequest {
	s.VirtualNetworkId = &v
	return s
}

type ListTrafficMirrorSessionsRequestTags struct {
	// The tag key. You can specify at most 20 tag keys. The tag key cannot be an empty string.
	//
	// The key cannot exceed 64 characters in length, and can contain digits, periods (.), underscores (\_), and hyphens (-). The key must start with a letter but cannot start with `aliyun` or `acs:`. The key cannot contain `http://` or `https://`.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value. You can specify at most 20 tag values. The tag value can be an empty string.
	//
	// The tag value cannot exceed 128 characters in length, and can contain digits, periods (.), underscores (\_), and hyphens (-). It must start with a letter but cannot start with `aliyun` or `acs:`. It cannot contain `http://` or `https://`.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListTrafficMirrorSessionsRequestTags) String() string {
	return tea.Prettify(s)
}

func (s ListTrafficMirrorSessionsRequestTags) GoString() string {
	return s.String()
}

func (s *ListTrafficMirrorSessionsRequestTags) SetKey(v string) *ListTrafficMirrorSessionsRequestTags {
	s.Key = &v
	return s
}

func (s *ListTrafficMirrorSessionsRequestTags) SetValue(v string) *ListTrafficMirrorSessionsRequestTags {
	s.Value = &v
	return s
}

type ListTrafficMirrorSessionsResponseBody struct {
	// The token that is used for the next query. Valid values:
	//
	// *   If no value is returned for **NextToken**, no next queries are sent.
	// *   If a value of **NextToken** is returned, the value is the token that is used for the subsequent query.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalCount *string `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
	// The details about the traffic mirror session.
	TrafficMirrorSessions []*ListTrafficMirrorSessionsResponseBodyTrafficMirrorSessions `json:"TrafficMirrorSessions,omitempty" xml:"TrafficMirrorSessions,omitempty" type:"Repeated"`
}

func (s ListTrafficMirrorSessionsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListTrafficMirrorSessionsResponseBody) GoString() string {
	return s.String()
}

func (s *ListTrafficMirrorSessionsResponseBody) SetNextToken(v string) *ListTrafficMirrorSessionsResponseBody {
	s.NextToken = &v
	return s
}

func (s *ListTrafficMirrorSessionsResponseBody) SetRequestId(v string) *ListTrafficMirrorSessionsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListTrafficMirrorSessionsResponseBody) SetTotalCount(v string) *ListTrafficMirrorSessionsResponseBody {
	s.TotalCount = &v
	return s
}

func (s *ListTrafficMirrorSessionsResponseBody) SetTrafficMirrorSessions(v []*ListTrafficMirrorSessionsResponseBodyTrafficMirrorSessions) *ListTrafficMirrorSessionsResponseBody {
	s.TrafficMirrorSessions = v
	return s
}

type ListTrafficMirrorSessionsResponseBodyTrafficMirrorSessions struct {
	// Indicates whether the traffic mirror session was enabled.
	//
	// *   **false**: the traffic mirror session was disabled. This is the default value.
	// *   **true**: the traffic mirror session was enabled.
	Enabled *bool `json:"Enabled,omitempty" xml:"Enabled,omitempty"`
	// The maximum transmission unit (MTU).
	PacketLength *int32 `json:"PacketLength,omitempty" xml:"PacketLength,omitempty"`
	// The priority of the traffic mirror session.
	//
	// A smaller value indicates a higher priority.
	Priority *int32 `json:"Priority,omitempty" xml:"Priority,omitempty"`
	// The ID of the resource group to which the mirrored traffic belongs.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The list of tags.
	Tags []*ListTrafficMirrorSessionsResponseBodyTrafficMirrorSessionsTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
	// The ID of the traffic mirror filter.
	TrafficMirrorFilterId *string `json:"TrafficMirrorFilterId,omitempty" xml:"TrafficMirrorFilterId,omitempty"`
	// The status of the traffic mirror session.
	//
	// *   **Normal**: active
	// *   **FinancialLocked**: locked due to overdue payments
	TrafficMirrorSessionBusinessStatus *string `json:"TrafficMirrorSessionBusinessStatus,omitempty" xml:"TrafficMirrorSessionBusinessStatus,omitempty"`
	// The description of the traffic mirror session.
	TrafficMirrorSessionDescription *string `json:"TrafficMirrorSessionDescription,omitempty" xml:"TrafficMirrorSessionDescription,omitempty"`
	// The ID of the traffic mirror session.
	TrafficMirrorSessionId *string `json:"TrafficMirrorSessionId,omitempty" xml:"TrafficMirrorSessionId,omitempty"`
	// The name of the traffic mirror session.
	TrafficMirrorSessionName *string `json:"TrafficMirrorSessionName,omitempty" xml:"TrafficMirrorSessionName,omitempty"`
	// The status of the traffic mirror session. Valid values:
	//
	// *   **Creating**
	// *   **Created**
	// *   **Modifying**
	// *   **Deleting**
	TrafficMirrorSessionStatus *string `json:"TrafficMirrorSessionStatus,omitempty" xml:"TrafficMirrorSessionStatus,omitempty"`
	// The ID of the mirror source.
	TrafficMirrorSourceIds []*string `json:"TrafficMirrorSourceIds,omitempty" xml:"TrafficMirrorSourceIds,omitempty" type:"Repeated"`
	// The ID of the mirror destination.
	TrafficMirrorTargetId *string `json:"TrafficMirrorTargetId,omitempty" xml:"TrafficMirrorTargetId,omitempty"`
	// The type of the traffic mirror destination. Valid values:
	//
	// *   **NetworkInterface**: an ENI
	// *   **SLB**: an internal-facing SLB instance
	TrafficMirrorTargetType *string `json:"TrafficMirrorTargetType,omitempty" xml:"TrafficMirrorTargetType,omitempty"`
	// You can specify VNIs to distinguish different mirrored traffic.
	VirtualNetworkId *int32 `json:"VirtualNetworkId,omitempty" xml:"VirtualNetworkId,omitempty"`
}

func (s ListTrafficMirrorSessionsResponseBodyTrafficMirrorSessions) String() string {
	return tea.Prettify(s)
}

func (s ListTrafficMirrorSessionsResponseBodyTrafficMirrorSessions) GoString() string {
	return s.String()
}

func (s *ListTrafficMirrorSessionsResponseBodyTrafficMirrorSessions) SetEnabled(v bool) *ListTrafficMirrorSessionsResponseBodyTrafficMirrorSessions {
	s.Enabled = &v
	return s
}

func (s *ListTrafficMirrorSessionsResponseBodyTrafficMirrorSessions) SetPacketLength(v int32) *ListTrafficMirrorSessionsResponseBodyTrafficMirrorSessions {
	s.PacketLength = &v
	return s
}

func (s *ListTrafficMirrorSessionsResponseBodyTrafficMirrorSessions) SetPriority(v int32) *ListTrafficMirrorSessionsResponseBodyTrafficMirrorSessions {
	s.Priority = &v
	return s
}

func (s *ListTrafficMirrorSessionsResponseBodyTrafficMirrorSessions) SetResourceGroupId(v string) *ListTrafficMirrorSessionsResponseBodyTrafficMirrorSessions {
	s.ResourceGroupId = &v
	return s
}

func (s *ListTrafficMirrorSessionsResponseBodyTrafficMirrorSessions) SetTags(v []*ListTrafficMirrorSessionsResponseBodyTrafficMirrorSessionsTags) *ListTrafficMirrorSessionsResponseBodyTrafficMirrorSessions {
	s.Tags = v
	return s
}

func (s *ListTrafficMirrorSessionsResponseBodyTrafficMirrorSessions) SetTrafficMirrorFilterId(v string) *ListTrafficMirrorSessionsResponseBodyTrafficMirrorSessions {
	s.TrafficMirrorFilterId = &v
	return s
}

func (s *ListTrafficMirrorSessionsResponseBodyTrafficMirrorSessions) SetTrafficMirrorSessionBusinessStatus(v string) *ListTrafficMirrorSessionsResponseBodyTrafficMirrorSessions {
	s.TrafficMirrorSessionBusinessStatus = &v
	return s
}

func (s *ListTrafficMirrorSessionsResponseBodyTrafficMirrorSessions) SetTrafficMirrorSessionDescription(v string) *ListTrafficMirrorSessionsResponseBodyTrafficMirrorSessions {
	s.TrafficMirrorSessionDescription = &v
	return s
}

func (s *ListTrafficMirrorSessionsResponseBodyTrafficMirrorSessions) SetTrafficMirrorSessionId(v string) *ListTrafficMirrorSessionsResponseBodyTrafficMirrorSessions {
	s.TrafficMirrorSessionId = &v
	return s
}

func (s *ListTrafficMirrorSessionsResponseBodyTrafficMirrorSessions) SetTrafficMirrorSessionName(v string) *ListTrafficMirrorSessionsResponseBodyTrafficMirrorSessions {
	s.TrafficMirrorSessionName = &v
	return s
}

func (s *ListTrafficMirrorSessionsResponseBodyTrafficMirrorSessions) SetTrafficMirrorSessionStatus(v string) *ListTrafficMirrorSessionsResponseBodyTrafficMirrorSessions {
	s.TrafficMirrorSessionStatus = &v
	return s
}

func (s *ListTrafficMirrorSessionsResponseBodyTrafficMirrorSessions) SetTrafficMirrorSourceIds(v []*string) *ListTrafficMirrorSessionsResponseBodyTrafficMirrorSessions {
	s.TrafficMirrorSourceIds = v
	return s
}

func (s *ListTrafficMirrorSessionsResponseBodyTrafficMirrorSessions) SetTrafficMirrorTargetId(v string) *ListTrafficMirrorSessionsResponseBodyTrafficMirrorSessions {
	s.TrafficMirrorTargetId = &v
	return s
}

func (s *ListTrafficMirrorSessionsResponseBodyTrafficMirrorSessions) SetTrafficMirrorTargetType(v string) *ListTrafficMirrorSessionsResponseBodyTrafficMirrorSessions {
	s.TrafficMirrorTargetType = &v
	return s
}

func (s *ListTrafficMirrorSessionsResponseBodyTrafficMirrorSessions) SetVirtualNetworkId(v int32) *ListTrafficMirrorSessionsResponseBodyTrafficMirrorSessions {
	s.VirtualNetworkId = &v
	return s
}

type ListTrafficMirrorSessionsResponseBodyTrafficMirrorSessionsTags struct {
	// The tag key.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListTrafficMirrorSessionsResponseBodyTrafficMirrorSessionsTags) String() string {
	return tea.Prettify(s)
}

func (s ListTrafficMirrorSessionsResponseBodyTrafficMirrorSessionsTags) GoString() string {
	return s.String()
}

func (s *ListTrafficMirrorSessionsResponseBodyTrafficMirrorSessionsTags) SetKey(v string) *ListTrafficMirrorSessionsResponseBodyTrafficMirrorSessionsTags {
	s.Key = &v
	return s
}

func (s *ListTrafficMirrorSessionsResponseBodyTrafficMirrorSessionsTags) SetValue(v string) *ListTrafficMirrorSessionsResponseBodyTrafficMirrorSessionsTags {
	s.Value = &v
	return s
}

type ListTrafficMirrorSessionsResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListTrafficMirrorSessionsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListTrafficMirrorSessionsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListTrafficMirrorSessionsResponse) GoString() string {
	return s.String()
}

func (s *ListTrafficMirrorSessionsResponse) SetHeaders(v map[string]*string) *ListTrafficMirrorSessionsResponse {
	s.Headers = v
	return s
}

func (s *ListTrafficMirrorSessionsResponse) SetStatusCode(v int32) *ListTrafficMirrorSessionsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListTrafficMirrorSessionsResponse) SetBody(v *ListTrafficMirrorSessionsResponseBody) *ListTrafficMirrorSessionsResponse {
	s.Body = v
	return s
}

type ListVirtualPhysicalConnectionsRequest struct {
	// Specifies whether the hosted connection is accepted by the tenant. Valid values:
	//
	// *   **true**: yes
	// *   **false**: no
	IsConfirmed *bool `json:"IsConfirmed,omitempty" xml:"IsConfirmed,omitempty"`
	// The number of entries to return on each page. Valid values: **1** to **100**. Default value: **20**.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The token that is used for the next query. Valid values:
	//
	// *   If this is your first query or no subsequent query is to be sent, ignore this parameter.
	// *   If a subsequent query is to be sent, set the parameter to the value of NextToken that is returned from the last call.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the Express Connect circuit over which the hosted connection is created.
	//
	// Express Connect circuits in this topic refer to Express Connect circuits over which hosted connections are created.
	PhysicalConnectionId *string `json:"PhysicalConnectionId,omitempty" xml:"PhysicalConnectionId,omitempty"`
	// The region ID of the hosted connection.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId                         *string                                      `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceGroupId                  *string                                      `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	Tags                             []*ListVirtualPhysicalConnectionsRequestTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
	VirtualPhysicalConnectionAliUids []*string                                    `json:"VirtualPhysicalConnectionAliUids,omitempty" xml:"VirtualPhysicalConnectionAliUids,omitempty" type:"Repeated"`
	// The business status of the hosted connection. Valid values:
	//
	// *   **Normal**: normal
	// *   **FinancialLocked**: locked due to overdue payments
	// *   **SecurityLocked**: locked for security reasons
	VirtualPhysicalConnectionBusinessStatus *string   `json:"VirtualPhysicalConnectionBusinessStatus,omitempty" xml:"VirtualPhysicalConnectionBusinessStatus,omitempty"`
	VirtualPhysicalConnectionIds            []*string `json:"VirtualPhysicalConnectionIds,omitempty" xml:"VirtualPhysicalConnectionIds,omitempty" type:"Repeated"`
	VirtualPhysicalConnectionStatuses       []*string `json:"VirtualPhysicalConnectionStatuses,omitempty" xml:"VirtualPhysicalConnectionStatuses,omitempty" type:"Repeated"`
	VlanIds                                 []*string `json:"VlanIds,omitempty" xml:"VlanIds,omitempty" type:"Repeated"`
}

func (s ListVirtualPhysicalConnectionsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListVirtualPhysicalConnectionsRequest) GoString() string {
	return s.String()
}

func (s *ListVirtualPhysicalConnectionsRequest) SetIsConfirmed(v bool) *ListVirtualPhysicalConnectionsRequest {
	s.IsConfirmed = &v
	return s
}

func (s *ListVirtualPhysicalConnectionsRequest) SetMaxResults(v int32) *ListVirtualPhysicalConnectionsRequest {
	s.MaxResults = &v
	return s
}

func (s *ListVirtualPhysicalConnectionsRequest) SetNextToken(v string) *ListVirtualPhysicalConnectionsRequest {
	s.NextToken = &v
	return s
}

func (s *ListVirtualPhysicalConnectionsRequest) SetPhysicalConnectionId(v string) *ListVirtualPhysicalConnectionsRequest {
	s.PhysicalConnectionId = &v
	return s
}

func (s *ListVirtualPhysicalConnectionsRequest) SetRegionId(v string) *ListVirtualPhysicalConnectionsRequest {
	s.RegionId = &v
	return s
}

func (s *ListVirtualPhysicalConnectionsRequest) SetResourceGroupId(v string) *ListVirtualPhysicalConnectionsRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *ListVirtualPhysicalConnectionsRequest) SetTags(v []*ListVirtualPhysicalConnectionsRequestTags) *ListVirtualPhysicalConnectionsRequest {
	s.Tags = v
	return s
}

func (s *ListVirtualPhysicalConnectionsRequest) SetVirtualPhysicalConnectionAliUids(v []*string) *ListVirtualPhysicalConnectionsRequest {
	s.VirtualPhysicalConnectionAliUids = v
	return s
}

func (s *ListVirtualPhysicalConnectionsRequest) SetVirtualPhysicalConnectionBusinessStatus(v string) *ListVirtualPhysicalConnectionsRequest {
	s.VirtualPhysicalConnectionBusinessStatus = &v
	return s
}

func (s *ListVirtualPhysicalConnectionsRequest) SetVirtualPhysicalConnectionIds(v []*string) *ListVirtualPhysicalConnectionsRequest {
	s.VirtualPhysicalConnectionIds = v
	return s
}

func (s *ListVirtualPhysicalConnectionsRequest) SetVirtualPhysicalConnectionStatuses(v []*string) *ListVirtualPhysicalConnectionsRequest {
	s.VirtualPhysicalConnectionStatuses = v
	return s
}

func (s *ListVirtualPhysicalConnectionsRequest) SetVlanIds(v []*string) *ListVirtualPhysicalConnectionsRequest {
	s.VlanIds = v
	return s
}

type ListVirtualPhysicalConnectionsRequestTags struct {
	// The key of the tag that is added to the resource. You can specify at most 20 tag keys. The tag key cannot be an empty string.
	//
	// The key cannot exceed 64 characters in length, and can contain digits, periods (.), underscores (\_), and hyphens (-). The key must start with a letter but cannot start with `aliyun` or `acs:`. The key cannot contain `http://` or `https://`.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The value of the tag that is added to the resource. You can specify at most 20 tag values. The tag value can be an empty string.
	//
	// The value cannot exceed 128 characters in length and can contain digits, periods (.), underscores (\_), and hyphens (-). The value must start with a letter but cannot start with `aliyun` or `acs:`. The value cannot contain `http://` or `https://`.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListVirtualPhysicalConnectionsRequestTags) String() string {
	return tea.Prettify(s)
}

func (s ListVirtualPhysicalConnectionsRequestTags) GoString() string {
	return s.String()
}

func (s *ListVirtualPhysicalConnectionsRequestTags) SetKey(v string) *ListVirtualPhysicalConnectionsRequestTags {
	s.Key = &v
	return s
}

func (s *ListVirtualPhysicalConnectionsRequestTags) SetValue(v string) *ListVirtualPhysicalConnectionsRequestTags {
	s.Value = &v
	return s
}

type ListVirtualPhysicalConnectionsResponseBody struct {
	// The number of entries returned in this query.
	Count *int32 `json:"Count,omitempty" xml:"Count,omitempty"`
	// The token that determines the start point of the query. Valid values:
	//
	// *   If **NextToken** was not returned, it indicates that no additional results exist.
	// *   If **NextToken** is not empty, the value indicates the token that is used for the next query.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
	// The list of hosted connections returned.
	VirtualPhysicalConnections []*ListVirtualPhysicalConnectionsResponseBodyVirtualPhysicalConnections `json:"VirtualPhysicalConnections,omitempty" xml:"VirtualPhysicalConnections,omitempty" type:"Repeated"`
}

func (s ListVirtualPhysicalConnectionsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListVirtualPhysicalConnectionsResponseBody) GoString() string {
	return s.String()
}

func (s *ListVirtualPhysicalConnectionsResponseBody) SetCount(v int32) *ListVirtualPhysicalConnectionsResponseBody {
	s.Count = &v
	return s
}

func (s *ListVirtualPhysicalConnectionsResponseBody) SetNextToken(v string) *ListVirtualPhysicalConnectionsResponseBody {
	s.NextToken = &v
	return s
}

func (s *ListVirtualPhysicalConnectionsResponseBody) SetRequestId(v string) *ListVirtualPhysicalConnectionsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListVirtualPhysicalConnectionsResponseBody) SetTotalCount(v int32) *ListVirtualPhysicalConnectionsResponseBody {
	s.TotalCount = &v
	return s
}

func (s *ListVirtualPhysicalConnectionsResponseBody) SetVirtualPhysicalConnections(v []*ListVirtualPhysicalConnectionsResponseBodyVirtualPhysicalConnections) *ListVirtualPhysicalConnectionsResponseBody {
	s.VirtualPhysicalConnections = v
	return s
}

type ListVirtualPhysicalConnectionsResponseBodyVirtualPhysicalConnections struct {
	// The ID of the access point that is associated with the Express Connect circuit.
	AccessPointId *string `json:"AccessPointId,omitempty" xml:"AccessPointId,omitempty"`
	// The geographical location of the access device.
	AdLocation *string `json:"AdLocation,omitempty" xml:"AdLocation,omitempty"`
	// The Alibaba Cloud account ID of the hosted connection owner.
	AliUid *string `json:"AliUid,omitempty" xml:"AliUid,omitempty"`
	// The bandwidth of the Express Connect circuit. Unit: Mbit/s.
	Bandwidth *int64 `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	// The business status of the Express Connect circuit. Valid values:
	//
	// *   **Normal**: enabled
	// *   **FinancialLocked**: locked due to overdue payments
	// *   **SecurityLocked**: locked for security reasons
	BusinessStatus *string `json:"BusinessStatus,omitempty" xml:"BusinessStatus,omitempty"`
	// The billing method of the Express Connect circuit.
	//
	// The value is set to **Prepaid**, which indicates the subscription billing method.
	ChargeType *string `json:"ChargeType,omitempty" xml:"ChargeType,omitempty"`
	// The circuit code of the Express Connect circuit. The circuit code is provided by the connectivity provider.
	CircuitCode *string `json:"CircuitCode,omitempty" xml:"CircuitCode,omitempty"`
	// The time when the Express Connect circuit was created.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The description of the Express Connect circuit.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The time when the Express Connect circuit was enabled.
	EnabledTime *string `json:"EnabledTime,omitempty" xml:"EnabledTime,omitempty"`
	// The expiration date of the hosted connection.
	//
	// The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ssZ format. The time is displayed in UTC.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The estimated bandwidth value of the hosted connection. The estimated bandwidth takes effect after you complete the payment.
	//
	// **M** indicates Mbit/s and **G** indicates Gbit/s.
	ExpectSpec *string `json:"ExpectSpec,omitempty" xml:"ExpectSpec,omitempty"`
	// The connectivity provider of the Express Connect circuit. Valid values:
	//
	// *   **CT**: China Telecom
	// *   **CU**: China Unicom
	// *   **CM**: China Mobile
	// *   **CO**: other connectivity providers in the Chinese mainland
	// *   **Equinix**: Equinix
	// *   **Other**: other connectivity providers outside the Chinese mainland
	LineOperator *string `json:"LineOperator,omitempty" xml:"LineOperator,omitempty"`
	// The status of the LOA. Valid values:
	//
	// *   **Applying**: The LOA is pending approval.
	// *   **Accept**: The LOA is approved.
	// *   **Available**: The LOA is available.
	// *   **Rejected**: The LOA is rejected.
	// *   **Completing**: The Express Connect circuit is under construction.
	// *   **Complete**: The Express Connect circuit is installed.
	// *   **Deleted**: The LOA is deleted.
	LoaStatus *string `json:"LoaStatus,omitempty" xml:"LoaStatus,omitempty"`
	// The name of the Express Connect circuit.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The payer of the hosted connection. Valid values:
	//
	// *   **PayByPhysicalConnectionOwner**: the owner of the shared Express Connect circuit
	// *   **PayByVirtualPhysicalConnectionOwner**: the owner of the hosted connection
	OrderMode *string `json:"OrderMode,omitempty" xml:"OrderMode,omitempty"`
	// The ID of the Alibaba Cloud account to which the Express Connect circuit belongs.
	ParentPhysicalConnectionAliUid *string `json:"ParentPhysicalConnectionAliUid,omitempty" xml:"ParentPhysicalConnectionAliUid,omitempty"`
	// The ID of the Express Connect circuit.
	ParentPhysicalConnectionId *string `json:"ParentPhysicalConnectionId,omitempty" xml:"ParentPhysicalConnectionId,omitempty"`
	// The geographical location of the data center.
	PeerLocation *string `json:"PeerLocation,omitempty" xml:"PeerLocation,omitempty"`
	// The ID of the hosted connection.
	PhysicalConnectionId *string `json:"PhysicalConnectionId,omitempty" xml:"PhysicalConnectionId,omitempty"`
	// The port number of the access device.
	PortNumber *string `json:"PortNumber,omitempty" xml:"PortNumber,omitempty"`
	// The port type. Valid values:
	//
	// *   **100Base-T**: 100 Mbit/s copper Ethernet port
	// *   **1000Base-T**: 1,000 Mbit/s copper Ethernet port
	// *   **1000Base-LX**: 1,000 Mbit/s single-mode optical port (10 kilometers)
	// *   **10GBase-T**: 10,000 Mbit/s copper Ethernet port
	// *   **10GBase-LR**: 10,000 Mbit/s single-mode optical port (10 kilometers)
	// *   **40GBase-LR**: 40,000 Mbit/s single-mode optical port
	// *   **100GBase-LR**: 100,000 Mbit/s single-mode optical port
	PortType *string `json:"PortType,omitempty" xml:"PortType,omitempty"`
	// The type of connection over the Express Connect circuit. Valid values:
	//
	// *   **VirtualPhysicalConnection**: a hosted connection
	// *   **PhysicalConnection**: a dedicated connection
	ProductType *string `json:"ProductType,omitempty" xml:"ProductType,omitempty"`
	// The ID of the redundant Express Connect circuit.
	RedundantPhysicalConnectionId *string `json:"RedundantPhysicalConnectionId,omitempty" xml:"RedundantPhysicalConnectionId,omitempty"`
	ResourceGroupId               *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The bandwidth value of the hosted connection.
	//
	// **M** indicates Mbit/s and **G** indicates Gbit/s.
	Spec *string `json:"Spec,omitempty" xml:"Spec,omitempty"`
	// The status of the Express Connect circuit. Valid values:
	//
	// *   **Initial**: The application is under review.
	// *   **Approved**: The application is approved.
	// *   **Allocating**: The system is allocating resources.
	// *   **Allocated**: The Express Connect circuit is under construction.
	// *   **Confirmed**: The Express Connect circuit is pending user confirmation.
	// *   **Enabled**: The Express Connect circuit is enabled.
	// *   **Rejected**: The application is rejected.
	// *   **Canceled**: The application is canceled.
	// *   **Allocation Failed**: The system failed to allocate resources.
	// *   **Terminated**: The Express Connect circuit is disabled.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The type of Express Connect circuit. Default value: **VPC**.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The service status of the hosted connection. Valid values:
	//
	// *   **Confirmed**: accepted
	// *   **UnConfirmed**: pending acceptance
	// *   **Deleted**: deleted
	VirtualPhysicalConnectionStatus *string `json:"VirtualPhysicalConnectionStatus,omitempty" xml:"VirtualPhysicalConnectionStatus,omitempty"`
	// The VLAN ID of the hosted connection.
	VlanId *string `json:"VlanId,omitempty" xml:"VlanId,omitempty"`
}

func (s ListVirtualPhysicalConnectionsResponseBodyVirtualPhysicalConnections) String() string {
	return tea.Prettify(s)
}

func (s ListVirtualPhysicalConnectionsResponseBodyVirtualPhysicalConnections) GoString() string {
	return s.String()
}

func (s *ListVirtualPhysicalConnectionsResponseBodyVirtualPhysicalConnections) SetAccessPointId(v string) *ListVirtualPhysicalConnectionsResponseBodyVirtualPhysicalConnections {
	s.AccessPointId = &v
	return s
}

func (s *ListVirtualPhysicalConnectionsResponseBodyVirtualPhysicalConnections) SetAdLocation(v string) *ListVirtualPhysicalConnectionsResponseBodyVirtualPhysicalConnections {
	s.AdLocation = &v
	return s
}

func (s *ListVirtualPhysicalConnectionsResponseBodyVirtualPhysicalConnections) SetAliUid(v string) *ListVirtualPhysicalConnectionsResponseBodyVirtualPhysicalConnections {
	s.AliUid = &v
	return s
}

func (s *ListVirtualPhysicalConnectionsResponseBodyVirtualPhysicalConnections) SetBandwidth(v int64) *ListVirtualPhysicalConnectionsResponseBodyVirtualPhysicalConnections {
	s.Bandwidth = &v
	return s
}

func (s *ListVirtualPhysicalConnectionsResponseBodyVirtualPhysicalConnections) SetBusinessStatus(v string) *ListVirtualPhysicalConnectionsResponseBodyVirtualPhysicalConnections {
	s.BusinessStatus = &v
	return s
}

func (s *ListVirtualPhysicalConnectionsResponseBodyVirtualPhysicalConnections) SetChargeType(v string) *ListVirtualPhysicalConnectionsResponseBodyVirtualPhysicalConnections {
	s.ChargeType = &v
	return s
}

func (s *ListVirtualPhysicalConnectionsResponseBodyVirtualPhysicalConnections) SetCircuitCode(v string) *ListVirtualPhysicalConnectionsResponseBodyVirtualPhysicalConnections {
	s.CircuitCode = &v
	return s
}

func (s *ListVirtualPhysicalConnectionsResponseBodyVirtualPhysicalConnections) SetCreationTime(v string) *ListVirtualPhysicalConnectionsResponseBodyVirtualPhysicalConnections {
	s.CreationTime = &v
	return s
}

func (s *ListVirtualPhysicalConnectionsResponseBodyVirtualPhysicalConnections) SetDescription(v string) *ListVirtualPhysicalConnectionsResponseBodyVirtualPhysicalConnections {
	s.Description = &v
	return s
}

func (s *ListVirtualPhysicalConnectionsResponseBodyVirtualPhysicalConnections) SetEnabledTime(v string) *ListVirtualPhysicalConnectionsResponseBodyVirtualPhysicalConnections {
	s.EnabledTime = &v
	return s
}

func (s *ListVirtualPhysicalConnectionsResponseBodyVirtualPhysicalConnections) SetEndTime(v string) *ListVirtualPhysicalConnectionsResponseBodyVirtualPhysicalConnections {
	s.EndTime = &v
	return s
}

func (s *ListVirtualPhysicalConnectionsResponseBodyVirtualPhysicalConnections) SetExpectSpec(v string) *ListVirtualPhysicalConnectionsResponseBodyVirtualPhysicalConnections {
	s.ExpectSpec = &v
	return s
}

func (s *ListVirtualPhysicalConnectionsResponseBodyVirtualPhysicalConnections) SetLineOperator(v string) *ListVirtualPhysicalConnectionsResponseBodyVirtualPhysicalConnections {
	s.LineOperator = &v
	return s
}

func (s *ListVirtualPhysicalConnectionsResponseBodyVirtualPhysicalConnections) SetLoaStatus(v string) *ListVirtualPhysicalConnectionsResponseBodyVirtualPhysicalConnections {
	s.LoaStatus = &v
	return s
}

func (s *ListVirtualPhysicalConnectionsResponseBodyVirtualPhysicalConnections) SetName(v string) *ListVirtualPhysicalConnectionsResponseBodyVirtualPhysicalConnections {
	s.Name = &v
	return s
}

func (s *ListVirtualPhysicalConnectionsResponseBodyVirtualPhysicalConnections) SetOrderMode(v string) *ListVirtualPhysicalConnectionsResponseBodyVirtualPhysicalConnections {
	s.OrderMode = &v
	return s
}

func (s *ListVirtualPhysicalConnectionsResponseBodyVirtualPhysicalConnections) SetParentPhysicalConnectionAliUid(v string) *ListVirtualPhysicalConnectionsResponseBodyVirtualPhysicalConnections {
	s.ParentPhysicalConnectionAliUid = &v
	return s
}

func (s *ListVirtualPhysicalConnectionsResponseBodyVirtualPhysicalConnections) SetParentPhysicalConnectionId(v string) *ListVirtualPhysicalConnectionsResponseBodyVirtualPhysicalConnections {
	s.ParentPhysicalConnectionId = &v
	return s
}

func (s *ListVirtualPhysicalConnectionsResponseBodyVirtualPhysicalConnections) SetPeerLocation(v string) *ListVirtualPhysicalConnectionsResponseBodyVirtualPhysicalConnections {
	s.PeerLocation = &v
	return s
}

func (s *ListVirtualPhysicalConnectionsResponseBodyVirtualPhysicalConnections) SetPhysicalConnectionId(v string) *ListVirtualPhysicalConnectionsResponseBodyVirtualPhysicalConnections {
	s.PhysicalConnectionId = &v
	return s
}

func (s *ListVirtualPhysicalConnectionsResponseBodyVirtualPhysicalConnections) SetPortNumber(v string) *ListVirtualPhysicalConnectionsResponseBodyVirtualPhysicalConnections {
	s.PortNumber = &v
	return s
}

func (s *ListVirtualPhysicalConnectionsResponseBodyVirtualPhysicalConnections) SetPortType(v string) *ListVirtualPhysicalConnectionsResponseBodyVirtualPhysicalConnections {
	s.PortType = &v
	return s
}

func (s *ListVirtualPhysicalConnectionsResponseBodyVirtualPhysicalConnections) SetProductType(v string) *ListVirtualPhysicalConnectionsResponseBodyVirtualPhysicalConnections {
	s.ProductType = &v
	return s
}

func (s *ListVirtualPhysicalConnectionsResponseBodyVirtualPhysicalConnections) SetRedundantPhysicalConnectionId(v string) *ListVirtualPhysicalConnectionsResponseBodyVirtualPhysicalConnections {
	s.RedundantPhysicalConnectionId = &v
	return s
}

func (s *ListVirtualPhysicalConnectionsResponseBodyVirtualPhysicalConnections) SetResourceGroupId(v string) *ListVirtualPhysicalConnectionsResponseBodyVirtualPhysicalConnections {
	s.ResourceGroupId = &v
	return s
}

func (s *ListVirtualPhysicalConnectionsResponseBodyVirtualPhysicalConnections) SetSpec(v string) *ListVirtualPhysicalConnectionsResponseBodyVirtualPhysicalConnections {
	s.Spec = &v
	return s
}

func (s *ListVirtualPhysicalConnectionsResponseBodyVirtualPhysicalConnections) SetStatus(v string) *ListVirtualPhysicalConnectionsResponseBodyVirtualPhysicalConnections {
	s.Status = &v
	return s
}

func (s *ListVirtualPhysicalConnectionsResponseBodyVirtualPhysicalConnections) SetType(v string) *ListVirtualPhysicalConnectionsResponseBodyVirtualPhysicalConnections {
	s.Type = &v
	return s
}

func (s *ListVirtualPhysicalConnectionsResponseBodyVirtualPhysicalConnections) SetVirtualPhysicalConnectionStatus(v string) *ListVirtualPhysicalConnectionsResponseBodyVirtualPhysicalConnections {
	s.VirtualPhysicalConnectionStatus = &v
	return s
}

func (s *ListVirtualPhysicalConnectionsResponseBodyVirtualPhysicalConnections) SetVlanId(v string) *ListVirtualPhysicalConnectionsResponseBodyVirtualPhysicalConnections {
	s.VlanId = &v
	return s
}

type ListVirtualPhysicalConnectionsResponse struct {
	Headers    map[string]*string                          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListVirtualPhysicalConnectionsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListVirtualPhysicalConnectionsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListVirtualPhysicalConnectionsResponse) GoString() string {
	return s.String()
}

func (s *ListVirtualPhysicalConnectionsResponse) SetHeaders(v map[string]*string) *ListVirtualPhysicalConnectionsResponse {
	s.Headers = v
	return s
}

func (s *ListVirtualPhysicalConnectionsResponse) SetStatusCode(v int32) *ListVirtualPhysicalConnectionsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListVirtualPhysicalConnectionsResponse) SetBody(v *ListVirtualPhysicalConnectionsResponseBody) *ListVirtualPhysicalConnectionsResponse {
	s.Body = v
	return s
}

type ListVpcEndpointServicesByEndUserRequest struct {
	// The number of entries to return per page. Valid values: **1** to **100**. Default value: **20**.
	MaxResults *int64 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The token that is used for the next query. Valid values:
	//
	// *   If this is your first query and no next queries are to be sent, ignore this parameter.
	// *   If a next query is to be performed, set the value to the NextToken value returned in the last call to the ListListenerCertificates operation.
	NextToken    *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the gateway endpoint.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The name of the endpoint service that you want to query.
	ServiceName *string `json:"ServiceName,omitempty" xml:"ServiceName,omitempty"`
}

func (s ListVpcEndpointServicesByEndUserRequest) String() string {
	return tea.Prettify(s)
}

func (s ListVpcEndpointServicesByEndUserRequest) GoString() string {
	return s.String()
}

func (s *ListVpcEndpointServicesByEndUserRequest) SetMaxResults(v int64) *ListVpcEndpointServicesByEndUserRequest {
	s.MaxResults = &v
	return s
}

func (s *ListVpcEndpointServicesByEndUserRequest) SetNextToken(v string) *ListVpcEndpointServicesByEndUserRequest {
	s.NextToken = &v
	return s
}

func (s *ListVpcEndpointServicesByEndUserRequest) SetOwnerAccount(v string) *ListVpcEndpointServicesByEndUserRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ListVpcEndpointServicesByEndUserRequest) SetOwnerId(v int64) *ListVpcEndpointServicesByEndUserRequest {
	s.OwnerId = &v
	return s
}

func (s *ListVpcEndpointServicesByEndUserRequest) SetRegionId(v string) *ListVpcEndpointServicesByEndUserRequest {
	s.RegionId = &v
	return s
}

func (s *ListVpcEndpointServicesByEndUserRequest) SetResourceOwnerAccount(v string) *ListVpcEndpointServicesByEndUserRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ListVpcEndpointServicesByEndUserRequest) SetResourceOwnerId(v int64) *ListVpcEndpointServicesByEndUserRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ListVpcEndpointServicesByEndUserRequest) SetServiceName(v string) *ListVpcEndpointServicesByEndUserRequest {
	s.ServiceName = &v
	return s
}

type ListVpcEndpointServicesByEndUserResponseBody struct {
	// The number of entries returned per page.
	MaxResults *int64 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The token that is used for the next query. Valid values:
	//
	// *   If no value is returned for **NextToken**, no next queries are sent.
	// *   If **NextToken** is returned, the value is the token that is used for the next query.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The list of entries returned.
	Services []*ListVpcEndpointServicesByEndUserResponseBodyServices `json:"Services,omitempty" xml:"Services,omitempty" type:"Repeated"`
}

func (s ListVpcEndpointServicesByEndUserResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListVpcEndpointServicesByEndUserResponseBody) GoString() string {
	return s.String()
}

func (s *ListVpcEndpointServicesByEndUserResponseBody) SetMaxResults(v int64) *ListVpcEndpointServicesByEndUserResponseBody {
	s.MaxResults = &v
	return s
}

func (s *ListVpcEndpointServicesByEndUserResponseBody) SetNextToken(v string) *ListVpcEndpointServicesByEndUserResponseBody {
	s.NextToken = &v
	return s
}

func (s *ListVpcEndpointServicesByEndUserResponseBody) SetRequestId(v string) *ListVpcEndpointServicesByEndUserResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListVpcEndpointServicesByEndUserResponseBody) SetServices(v []*ListVpcEndpointServicesByEndUserResponseBodyServices) *ListVpcEndpointServicesByEndUserResponseBody {
	s.Services = v
	return s
}

type ListVpcEndpointServicesByEndUserResponseBodyServices struct {
	// The default access policy.
	DefaultPolicyDocument *string `json:"DefaultPolicyDocument,omitempty" xml:"DefaultPolicyDocument,omitempty"`
	// The domain name of the cloud service to which the endpoint service belongs.
	ServiceDomain *string `json:"ServiceDomain,omitempty" xml:"ServiceDomain,omitempty"`
	// The ID of the endpoint service.
	ServiceId *string `json:"ServiceId,omitempty" xml:"ServiceId,omitempty"`
	// The name of the endpoint service.
	ServiceName *string `json:"ServiceName,omitempty" xml:"ServiceName,omitempty"`
	// Indicate whether the endpoint service supports the access policy. Valid values:
	//
	// *   **false**: no
	// *   **true**: yes
	SupportPolicy *bool `json:"SupportPolicy,omitempty" xml:"SupportPolicy,omitempty"`
}

func (s ListVpcEndpointServicesByEndUserResponseBodyServices) String() string {
	return tea.Prettify(s)
}

func (s ListVpcEndpointServicesByEndUserResponseBodyServices) GoString() string {
	return s.String()
}

func (s *ListVpcEndpointServicesByEndUserResponseBodyServices) SetDefaultPolicyDocument(v string) *ListVpcEndpointServicesByEndUserResponseBodyServices {
	s.DefaultPolicyDocument = &v
	return s
}

func (s *ListVpcEndpointServicesByEndUserResponseBodyServices) SetServiceDomain(v string) *ListVpcEndpointServicesByEndUserResponseBodyServices {
	s.ServiceDomain = &v
	return s
}

func (s *ListVpcEndpointServicesByEndUserResponseBodyServices) SetServiceId(v string) *ListVpcEndpointServicesByEndUserResponseBodyServices {
	s.ServiceId = &v
	return s
}

func (s *ListVpcEndpointServicesByEndUserResponseBodyServices) SetServiceName(v string) *ListVpcEndpointServicesByEndUserResponseBodyServices {
	s.ServiceName = &v
	return s
}

func (s *ListVpcEndpointServicesByEndUserResponseBodyServices) SetSupportPolicy(v bool) *ListVpcEndpointServicesByEndUserResponseBodyServices {
	s.SupportPolicy = &v
	return s
}

type ListVpcEndpointServicesByEndUserResponse struct {
	Headers    map[string]*string                            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListVpcEndpointServicesByEndUserResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListVpcEndpointServicesByEndUserResponse) String() string {
	return tea.Prettify(s)
}

func (s ListVpcEndpointServicesByEndUserResponse) GoString() string {
	return s.String()
}

func (s *ListVpcEndpointServicesByEndUserResponse) SetHeaders(v map[string]*string) *ListVpcEndpointServicesByEndUserResponse {
	s.Headers = v
	return s
}

func (s *ListVpcEndpointServicesByEndUserResponse) SetStatusCode(v int32) *ListVpcEndpointServicesByEndUserResponse {
	s.StatusCode = &v
	return s
}

func (s *ListVpcEndpointServicesByEndUserResponse) SetBody(v *ListVpcEndpointServicesByEndUserResponseBody) *ListVpcEndpointServicesByEndUserResponse {
	s.Body = v
	return s
}

type ListVpcGatewayEndpointsRequest struct {
	// The ID of the gateway endpoint.
	EndpointId *string `json:"EndpointId,omitempty" xml:"EndpointId,omitempty"`
	// The name of the gateway endpoint.
	//
	// The name must be 1 to 128 characters in length.
	EndpointName *string `json:"EndpointName,omitempty" xml:"EndpointName,omitempty"`
	// The number of entries to return per page. Valid values: **1** to **100**. Default value: **20**.
	MaxResults *int64 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The token that is used for the next query. Valid values:
	//
	// *   If this is your first query and no next queries are to be sent, ignore this parameter.
	// *   If a next query is to be performed, set the value to the NextToken value returned in the last call to the ListListenerCertificates operation.
	NextToken    *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the gateway endpoint.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The name of the endpoint service.
	ServiceName *string                               `json:"ServiceName,omitempty" xml:"ServiceName,omitempty"`
	Tags        []*ListVpcGatewayEndpointsRequestTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
}

func (s ListVpcGatewayEndpointsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListVpcGatewayEndpointsRequest) GoString() string {
	return s.String()
}

func (s *ListVpcGatewayEndpointsRequest) SetEndpointId(v string) *ListVpcGatewayEndpointsRequest {
	s.EndpointId = &v
	return s
}

func (s *ListVpcGatewayEndpointsRequest) SetEndpointName(v string) *ListVpcGatewayEndpointsRequest {
	s.EndpointName = &v
	return s
}

func (s *ListVpcGatewayEndpointsRequest) SetMaxResults(v int64) *ListVpcGatewayEndpointsRequest {
	s.MaxResults = &v
	return s
}

func (s *ListVpcGatewayEndpointsRequest) SetNextToken(v string) *ListVpcGatewayEndpointsRequest {
	s.NextToken = &v
	return s
}

func (s *ListVpcGatewayEndpointsRequest) SetOwnerAccount(v string) *ListVpcGatewayEndpointsRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ListVpcGatewayEndpointsRequest) SetOwnerId(v int64) *ListVpcGatewayEndpointsRequest {
	s.OwnerId = &v
	return s
}

func (s *ListVpcGatewayEndpointsRequest) SetRegionId(v string) *ListVpcGatewayEndpointsRequest {
	s.RegionId = &v
	return s
}

func (s *ListVpcGatewayEndpointsRequest) SetResourceGroupId(v string) *ListVpcGatewayEndpointsRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *ListVpcGatewayEndpointsRequest) SetResourceOwnerAccount(v string) *ListVpcGatewayEndpointsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ListVpcGatewayEndpointsRequest) SetResourceOwnerId(v int64) *ListVpcGatewayEndpointsRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ListVpcGatewayEndpointsRequest) SetServiceName(v string) *ListVpcGatewayEndpointsRequest {
	s.ServiceName = &v
	return s
}

func (s *ListVpcGatewayEndpointsRequest) SetTags(v []*ListVpcGatewayEndpointsRequestTags) *ListVpcGatewayEndpointsRequest {
	s.Tags = v
	return s
}

type ListVpcGatewayEndpointsRequestTags struct {
	Key   *string `json:"Key,omitempty" xml:"Key,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListVpcGatewayEndpointsRequestTags) String() string {
	return tea.Prettify(s)
}

func (s ListVpcGatewayEndpointsRequestTags) GoString() string {
	return s.String()
}

func (s *ListVpcGatewayEndpointsRequestTags) SetKey(v string) *ListVpcGatewayEndpointsRequestTags {
	s.Key = &v
	return s
}

func (s *ListVpcGatewayEndpointsRequestTags) SetValue(v string) *ListVpcGatewayEndpointsRequestTags {
	s.Value = &v
	return s
}

type ListVpcGatewayEndpointsResponseBody struct {
	// The list of gateway endpoints.
	Endpoints []*ListVpcGatewayEndpointsResponseBodyEndpoints `json:"Endpoints,omitempty" xml:"Endpoints,omitempty" type:"Repeated"`
	// The number of entries returned per page.
	MaxResults *int64 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The token that is used for the next query. Valid values:
	//
	// *   If no value is returned for **NextToken**, no next queries are sent.
	// *   If **NextToken** is not empty, the value indicates the token that is used for the next query.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListVpcGatewayEndpointsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListVpcGatewayEndpointsResponseBody) GoString() string {
	return s.String()
}

func (s *ListVpcGatewayEndpointsResponseBody) SetEndpoints(v []*ListVpcGatewayEndpointsResponseBodyEndpoints) *ListVpcGatewayEndpointsResponseBody {
	s.Endpoints = v
	return s
}

func (s *ListVpcGatewayEndpointsResponseBody) SetMaxResults(v int64) *ListVpcGatewayEndpointsResponseBody {
	s.MaxResults = &v
	return s
}

func (s *ListVpcGatewayEndpointsResponseBody) SetNextToken(v string) *ListVpcGatewayEndpointsResponseBody {
	s.NextToken = &v
	return s
}

func (s *ListVpcGatewayEndpointsResponseBody) SetRequestId(v string) *ListVpcGatewayEndpointsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListVpcGatewayEndpointsResponseBody) SetTotalCount(v int64) *ListVpcGatewayEndpointsResponseBody {
	s.TotalCount = &v
	return s
}

type ListVpcGatewayEndpointsResponseBodyEndpoints struct {
	// The ID of the route table associated with the gateway endpoint.
	AssociatedRouteTables []*string `json:"AssociatedRouteTables,omitempty" xml:"AssociatedRouteTables,omitempty" type:"Repeated"`
	// The time when the endpoint was created. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ssZ format. The time must be in UTC.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The description of the gateway endpoint.
	EndpointDescription *string `json:"EndpointDescription,omitempty" xml:"EndpointDescription,omitempty"`
	// The ID of the gateway endpoint.
	EndpointId *string `json:"EndpointId,omitempty" xml:"EndpointId,omitempty"`
	// The name of the gateway endpoint.
	EndpointName *string `json:"EndpointName,omitempty" xml:"EndpointName,omitempty"`
	// The status of the gateway endpoint. Valid values:
	//
	// *   **Creating**
	// *   **Created**
	// *   **Modifying**
	// *   **Associating**
	// *   **Dissociating**
	// *   **Deleting**
	EndpointStatus *string `json:"EndpointStatus,omitempty" xml:"EndpointStatus,omitempty"`
	// The access policy for the cloud service.
	//
	// For more information about the syntax and structure of the access policy, see [Policy syntax and structure](~~93739~~).
	PolicyDocument  *string `json:"PolicyDocument,omitempty" xml:"PolicyDocument,omitempty"`
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The name of the endpoint service.
	ServiceName *string                                             `json:"ServiceName,omitempty" xml:"ServiceName,omitempty"`
	Tags        []*ListVpcGatewayEndpointsResponseBodyEndpointsTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
	// The ID of the virtual private cloud (VPC) to which the gateway endpoint belongs.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s ListVpcGatewayEndpointsResponseBodyEndpoints) String() string {
	return tea.Prettify(s)
}

func (s ListVpcGatewayEndpointsResponseBodyEndpoints) GoString() string {
	return s.String()
}

func (s *ListVpcGatewayEndpointsResponseBodyEndpoints) SetAssociatedRouteTables(v []*string) *ListVpcGatewayEndpointsResponseBodyEndpoints {
	s.AssociatedRouteTables = v
	return s
}

func (s *ListVpcGatewayEndpointsResponseBodyEndpoints) SetCreationTime(v string) *ListVpcGatewayEndpointsResponseBodyEndpoints {
	s.CreationTime = &v
	return s
}

func (s *ListVpcGatewayEndpointsResponseBodyEndpoints) SetEndpointDescription(v string) *ListVpcGatewayEndpointsResponseBodyEndpoints {
	s.EndpointDescription = &v
	return s
}

func (s *ListVpcGatewayEndpointsResponseBodyEndpoints) SetEndpointId(v string) *ListVpcGatewayEndpointsResponseBodyEndpoints {
	s.EndpointId = &v
	return s
}

func (s *ListVpcGatewayEndpointsResponseBodyEndpoints) SetEndpointName(v string) *ListVpcGatewayEndpointsResponseBodyEndpoints {
	s.EndpointName = &v
	return s
}

func (s *ListVpcGatewayEndpointsResponseBodyEndpoints) SetEndpointStatus(v string) *ListVpcGatewayEndpointsResponseBodyEndpoints {
	s.EndpointStatus = &v
	return s
}

func (s *ListVpcGatewayEndpointsResponseBodyEndpoints) SetPolicyDocument(v string) *ListVpcGatewayEndpointsResponseBodyEndpoints {
	s.PolicyDocument = &v
	return s
}

func (s *ListVpcGatewayEndpointsResponseBodyEndpoints) SetResourceGroupId(v string) *ListVpcGatewayEndpointsResponseBodyEndpoints {
	s.ResourceGroupId = &v
	return s
}

func (s *ListVpcGatewayEndpointsResponseBodyEndpoints) SetServiceName(v string) *ListVpcGatewayEndpointsResponseBodyEndpoints {
	s.ServiceName = &v
	return s
}

func (s *ListVpcGatewayEndpointsResponseBodyEndpoints) SetTags(v []*ListVpcGatewayEndpointsResponseBodyEndpointsTags) *ListVpcGatewayEndpointsResponseBodyEndpoints {
	s.Tags = v
	return s
}

func (s *ListVpcGatewayEndpointsResponseBodyEndpoints) SetVpcId(v string) *ListVpcGatewayEndpointsResponseBodyEndpoints {
	s.VpcId = &v
	return s
}

type ListVpcGatewayEndpointsResponseBodyEndpointsTags struct {
	Key   *string `json:"Key,omitempty" xml:"Key,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListVpcGatewayEndpointsResponseBodyEndpointsTags) String() string {
	return tea.Prettify(s)
}

func (s ListVpcGatewayEndpointsResponseBodyEndpointsTags) GoString() string {
	return s.String()
}

func (s *ListVpcGatewayEndpointsResponseBodyEndpointsTags) SetKey(v string) *ListVpcGatewayEndpointsResponseBodyEndpointsTags {
	s.Key = &v
	return s
}

func (s *ListVpcGatewayEndpointsResponseBodyEndpointsTags) SetValue(v string) *ListVpcGatewayEndpointsResponseBodyEndpointsTags {
	s.Value = &v
	return s
}

type ListVpcGatewayEndpointsResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListVpcGatewayEndpointsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListVpcGatewayEndpointsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListVpcGatewayEndpointsResponse) GoString() string {
	return s.String()
}

func (s *ListVpcGatewayEndpointsResponse) SetHeaders(v map[string]*string) *ListVpcGatewayEndpointsResponse {
	s.Headers = v
	return s
}

func (s *ListVpcGatewayEndpointsResponse) SetStatusCode(v int32) *ListVpcGatewayEndpointsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListVpcGatewayEndpointsResponse) SetBody(v *ListVpcGatewayEndpointsResponseBody) *ListVpcGatewayEndpointsResponse {
	s.Body = v
	return s
}

type ListVpnCertificateAssociationsRequest struct {
	// The list of certificate IDs.
	//
	// You can query the association between at most 20 SSL certificates and VPN gateways.
	CertificateId []*string `json:"CertificateId,omitempty" xml:"CertificateId,omitempty" type:"Repeated"`
	// The certificate type. Valid values:
	//
	// *   **Encryption**
	// *   **Signature**
	CertificateType *string `json:"CertificateType,omitempty" xml:"CertificateType,omitempty"`
	// The number of entries to return on each page. Valid values: **1** to **20**. Default value: **1**.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The pagination token that is used in the next request to retrieve a new page of results. Valid values:
	//
	// *   You do not need to specify this parameter for the first request.
	// *   You must specify the token that is obtained from the previous query as the value of **NextToken**.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The region ID of the VPN gateway.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The list of VPN gateway IDs.
	//
	// You can query the association between at most 20 VPN gateways and SSL certificates.
	VpnGatewayId []*string `json:"VpnGatewayId,omitempty" xml:"VpnGatewayId,omitempty" type:"Repeated"`
}

func (s ListVpnCertificateAssociationsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListVpnCertificateAssociationsRequest) GoString() string {
	return s.String()
}

func (s *ListVpnCertificateAssociationsRequest) SetCertificateId(v []*string) *ListVpnCertificateAssociationsRequest {
	s.CertificateId = v
	return s
}

func (s *ListVpnCertificateAssociationsRequest) SetCertificateType(v string) *ListVpnCertificateAssociationsRequest {
	s.CertificateType = &v
	return s
}

func (s *ListVpnCertificateAssociationsRequest) SetMaxResults(v int32) *ListVpnCertificateAssociationsRequest {
	s.MaxResults = &v
	return s
}

func (s *ListVpnCertificateAssociationsRequest) SetNextToken(v string) *ListVpnCertificateAssociationsRequest {
	s.NextToken = &v
	return s
}

func (s *ListVpnCertificateAssociationsRequest) SetRegionId(v string) *ListVpnCertificateAssociationsRequest {
	s.RegionId = &v
	return s
}

func (s *ListVpnCertificateAssociationsRequest) SetVpnGatewayId(v []*string) *ListVpnCertificateAssociationsRequest {
	s.VpnGatewayId = v
	return s
}

type ListVpnCertificateAssociationsResponseBody struct {
	// The number of entries returned per page.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The returned value of NextToken is a pagination token, which can be used in the next request to retrieve a new page of results. Valid values:
	//
	// *   If **NextToken** is empty, no next page exists.
	// *   If **NextToken** is not empty, the value indicates the token that is used for the next query.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
	// The association information.
	VpnCertificateRelations []*ListVpnCertificateAssociationsResponseBodyVpnCertificateRelations `json:"VpnCertificateRelations,omitempty" xml:"VpnCertificateRelations,omitempty" type:"Repeated"`
}

func (s ListVpnCertificateAssociationsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListVpnCertificateAssociationsResponseBody) GoString() string {
	return s.String()
}

func (s *ListVpnCertificateAssociationsResponseBody) SetMaxResults(v int32) *ListVpnCertificateAssociationsResponseBody {
	s.MaxResults = &v
	return s
}

func (s *ListVpnCertificateAssociationsResponseBody) SetNextToken(v string) *ListVpnCertificateAssociationsResponseBody {
	s.NextToken = &v
	return s
}

func (s *ListVpnCertificateAssociationsResponseBody) SetRequestId(v string) *ListVpnCertificateAssociationsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListVpnCertificateAssociationsResponseBody) SetTotalCount(v int32) *ListVpnCertificateAssociationsResponseBody {
	s.TotalCount = &v
	return s
}

func (s *ListVpnCertificateAssociationsResponseBody) SetVpnCertificateRelations(v []*ListVpnCertificateAssociationsResponseBodyVpnCertificateRelations) *ListVpnCertificateAssociationsResponseBody {
	s.VpnCertificateRelations = v
	return s
}

type ListVpnCertificateAssociationsResponseBodyVpnCertificateRelations struct {
	// The time when the certificate was associated.
	//
	// The time follows the ISO8601 standard in the YYYY-MM-DDThh:mmZ format. The time is displayed in UTC.
	AssociationTime *string `json:"AssociationTime,omitempty" xml:"AssociationTime,omitempty"`
	// The certificate ID.
	CertificateId *string `json:"CertificateId,omitempty" xml:"CertificateId,omitempty"`
	// The certificate type.
	//
	// *   **Encryption**
	// *   **Signature**
	CertificateType *string `json:"CertificateType,omitempty" xml:"CertificateType,omitempty"`
	// The ID of the region where the VPN gateway is created.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the VPN gateway.
	VpnGatewayId *string `json:"VpnGatewayId,omitempty" xml:"VpnGatewayId,omitempty"`
}

func (s ListVpnCertificateAssociationsResponseBodyVpnCertificateRelations) String() string {
	return tea.Prettify(s)
}

func (s ListVpnCertificateAssociationsResponseBodyVpnCertificateRelations) GoString() string {
	return s.String()
}

func (s *ListVpnCertificateAssociationsResponseBodyVpnCertificateRelations) SetAssociationTime(v string) *ListVpnCertificateAssociationsResponseBodyVpnCertificateRelations {
	s.AssociationTime = &v
	return s
}

func (s *ListVpnCertificateAssociationsResponseBodyVpnCertificateRelations) SetCertificateId(v string) *ListVpnCertificateAssociationsResponseBodyVpnCertificateRelations {
	s.CertificateId = &v
	return s
}

func (s *ListVpnCertificateAssociationsResponseBodyVpnCertificateRelations) SetCertificateType(v string) *ListVpnCertificateAssociationsResponseBodyVpnCertificateRelations {
	s.CertificateType = &v
	return s
}

func (s *ListVpnCertificateAssociationsResponseBodyVpnCertificateRelations) SetRegionId(v string) *ListVpnCertificateAssociationsResponseBodyVpnCertificateRelations {
	s.RegionId = &v
	return s
}

func (s *ListVpnCertificateAssociationsResponseBodyVpnCertificateRelations) SetVpnGatewayId(v string) *ListVpnCertificateAssociationsResponseBodyVpnCertificateRelations {
	s.VpnGatewayId = &v
	return s
}

type ListVpnCertificateAssociationsResponse struct {
	Headers    map[string]*string                          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListVpnCertificateAssociationsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListVpnCertificateAssociationsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListVpnCertificateAssociationsResponse) GoString() string {
	return s.String()
}

func (s *ListVpnCertificateAssociationsResponse) SetHeaders(v map[string]*string) *ListVpnCertificateAssociationsResponse {
	s.Headers = v
	return s
}

func (s *ListVpnCertificateAssociationsResponse) SetStatusCode(v int32) *ListVpnCertificateAssociationsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListVpnCertificateAssociationsResponse) SetBody(v *ListVpnCertificateAssociationsResponseBody) *ListVpnCertificateAssociationsResponse {
	s.Body = v
	return s
}

type ModifyBgpGroupAttributeRequest struct {
	// The authentication key of the BGP group.
	AuthKey *string `json:"AuthKey,omitempty" xml:"AuthKey,omitempty"`
	// The ID of the BGP group.
	BgpGroupId *string `json:"BgpGroupId,omitempty" xml:"BgpGroupId,omitempty"`
	// Specifies whether to clear the secret key. Valid values:
	//
	// *   **true:** clears the secret key.
	// *   **false:** does not clear the secret key.
	ClearAuthKey *bool `json:"ClearAuthKey,omitempty" xml:"ClearAuthKey,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that the value is unique among different requests. The ClientToken value can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The description of the BGP group.
	//
	// The description must be 2 to 256 characters in length. It must start with a letter and cannot start with `http://` or `https://`.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// Specifies whether to use a fake ASN. Valid values:
	//
	// *   **false:** does not use a fake ASN.
	// *   **true:** uses a fake ASN.
	//
	// >  A router that runs BGP typically belongs to only one autonomous system. If you want to use a different ASN to communicate with the peer but you cannot modify the BGP configuration because it may cause service interruptions, you can use a fake ASN. For example, you can use a fake ASN to communicate with the peer when you migrate or merge autonomous systems. This prevents service interruptions.
	IsFakeAsn *bool `json:"IsFakeAsn,omitempty" xml:"IsFakeAsn,omitempty"`
	// The custom autonomous system number (ASN) of the BGP on the Alibaba Cloud side. Default value: 45104. Valid values:
	//
	// *   **45104**
	// *   **64512~65534**
	// *   **4200000000~4294967294**
	//
	// >  The value of **65025** is reserved by Alibaba Cloud. If you do not use the default value (45104) in scenarios where multiple connections are established, BGP loops may occur. Proceed with caution.
	LocalAsn *int64 `json:"LocalAsn,omitempty" xml:"LocalAsn,omitempty"`
	// The name of the BGP group.
	//
	// The name must be 2 to 128 characters in length, and can contain digits, periods (.), underscores (\_), and hyphens (-). The name must start with a letter and cannot start with `http://` or `https://`.
	Name         *string `json:"Name,omitempty" xml:"Name,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ASN of the gateway device in the data center.
	PeerAsn *int64 `json:"PeerAsn,omitempty" xml:"PeerAsn,omitempty"`
	// The ID of the region to which the BGP group belongs.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to obtain the region ID.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The maximum number of routes supported by a BGP peer. Default value: **110**.
	RouteQuota *int32 `json:"RouteQuota,omitempty" xml:"RouteQuota,omitempty"`
}

func (s ModifyBgpGroupAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyBgpGroupAttributeRequest) GoString() string {
	return s.String()
}

func (s *ModifyBgpGroupAttributeRequest) SetAuthKey(v string) *ModifyBgpGroupAttributeRequest {
	s.AuthKey = &v
	return s
}

func (s *ModifyBgpGroupAttributeRequest) SetBgpGroupId(v string) *ModifyBgpGroupAttributeRequest {
	s.BgpGroupId = &v
	return s
}

func (s *ModifyBgpGroupAttributeRequest) SetClearAuthKey(v bool) *ModifyBgpGroupAttributeRequest {
	s.ClearAuthKey = &v
	return s
}

func (s *ModifyBgpGroupAttributeRequest) SetClientToken(v string) *ModifyBgpGroupAttributeRequest {
	s.ClientToken = &v
	return s
}

func (s *ModifyBgpGroupAttributeRequest) SetDescription(v string) *ModifyBgpGroupAttributeRequest {
	s.Description = &v
	return s
}

func (s *ModifyBgpGroupAttributeRequest) SetIsFakeAsn(v bool) *ModifyBgpGroupAttributeRequest {
	s.IsFakeAsn = &v
	return s
}

func (s *ModifyBgpGroupAttributeRequest) SetLocalAsn(v int64) *ModifyBgpGroupAttributeRequest {
	s.LocalAsn = &v
	return s
}

func (s *ModifyBgpGroupAttributeRequest) SetName(v string) *ModifyBgpGroupAttributeRequest {
	s.Name = &v
	return s
}

func (s *ModifyBgpGroupAttributeRequest) SetOwnerAccount(v string) *ModifyBgpGroupAttributeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyBgpGroupAttributeRequest) SetOwnerId(v int64) *ModifyBgpGroupAttributeRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyBgpGroupAttributeRequest) SetPeerAsn(v int64) *ModifyBgpGroupAttributeRequest {
	s.PeerAsn = &v
	return s
}

func (s *ModifyBgpGroupAttributeRequest) SetRegionId(v string) *ModifyBgpGroupAttributeRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyBgpGroupAttributeRequest) SetResourceOwnerAccount(v string) *ModifyBgpGroupAttributeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyBgpGroupAttributeRequest) SetResourceOwnerId(v int64) *ModifyBgpGroupAttributeRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ModifyBgpGroupAttributeRequest) SetRouteQuota(v int32) *ModifyBgpGroupAttributeRequest {
	s.RouteQuota = &v
	return s
}

type ModifyBgpGroupAttributeResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyBgpGroupAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyBgpGroupAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyBgpGroupAttributeResponseBody) SetRequestId(v string) *ModifyBgpGroupAttributeResponseBody {
	s.RequestId = &v
	return s
}

type ModifyBgpGroupAttributeResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyBgpGroupAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyBgpGroupAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyBgpGroupAttributeResponse) GoString() string {
	return s.String()
}

func (s *ModifyBgpGroupAttributeResponse) SetHeaders(v map[string]*string) *ModifyBgpGroupAttributeResponse {
	s.Headers = v
	return s
}

func (s *ModifyBgpGroupAttributeResponse) SetStatusCode(v int32) *ModifyBgpGroupAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyBgpGroupAttributeResponse) SetBody(v *ModifyBgpGroupAttributeResponseBody) *ModifyBgpGroupAttributeResponse {
	s.Body = v
	return s
}

type ModifyBgpPeerAttributeRequest struct {
	// The BFD hop count. Valid values: **1** to **255**.
	//
	// This parameter is required only if you enable BFD.
	//
	// The parameter specifies the maximum number of network devices that a packet can traverse from the source to the destination. You can set a proper value based on the factors that affect the physical connection.
	BfdMultiHop *int32 `json:"BfdMultiHop,omitempty" xml:"BfdMultiHop,omitempty"`
	// The ID of the BGP group to which the BGP peer that you want to modify belongs.
	BgpGroupId *string `json:"BgpGroupId,omitempty" xml:"BgpGroupId,omitempty"`
	// The ID of the BGP peer that you want to modify.
	BgpPeerId *string `json:"BgpPeerId,omitempty" xml:"BgpPeerId,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	//
	// >  If you do not set this parameter, the system automatically uses **RequestId** as **ClientToken**. **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to enable the Bidirectional Forwarding Detection (BFD) feature. Valid values:
	//
	// *   **true**: enables BFD.
	// *   **false**: disables BFD. This is the default value.
	EnableBfd    *bool   `json:"EnableBfd,omitempty" xml:"EnableBfd,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The IP address of the BGP peer that you want to modify.
	PeerIpAddress *string `json:"PeerIpAddress,omitempty" xml:"PeerIpAddress,omitempty"`
	// The region ID of the BGP group to which the BGP peer that you want to modify belongs.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ModifyBgpPeerAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyBgpPeerAttributeRequest) GoString() string {
	return s.String()
}

func (s *ModifyBgpPeerAttributeRequest) SetBfdMultiHop(v int32) *ModifyBgpPeerAttributeRequest {
	s.BfdMultiHop = &v
	return s
}

func (s *ModifyBgpPeerAttributeRequest) SetBgpGroupId(v string) *ModifyBgpPeerAttributeRequest {
	s.BgpGroupId = &v
	return s
}

func (s *ModifyBgpPeerAttributeRequest) SetBgpPeerId(v string) *ModifyBgpPeerAttributeRequest {
	s.BgpPeerId = &v
	return s
}

func (s *ModifyBgpPeerAttributeRequest) SetClientToken(v string) *ModifyBgpPeerAttributeRequest {
	s.ClientToken = &v
	return s
}

func (s *ModifyBgpPeerAttributeRequest) SetEnableBfd(v bool) *ModifyBgpPeerAttributeRequest {
	s.EnableBfd = &v
	return s
}

func (s *ModifyBgpPeerAttributeRequest) SetOwnerAccount(v string) *ModifyBgpPeerAttributeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyBgpPeerAttributeRequest) SetOwnerId(v int64) *ModifyBgpPeerAttributeRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyBgpPeerAttributeRequest) SetPeerIpAddress(v string) *ModifyBgpPeerAttributeRequest {
	s.PeerIpAddress = &v
	return s
}

func (s *ModifyBgpPeerAttributeRequest) SetRegionId(v string) *ModifyBgpPeerAttributeRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyBgpPeerAttributeRequest) SetResourceOwnerAccount(v string) *ModifyBgpPeerAttributeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyBgpPeerAttributeRequest) SetResourceOwnerId(v int64) *ModifyBgpPeerAttributeRequest {
	s.ResourceOwnerId = &v
	return s
}

type ModifyBgpPeerAttributeResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyBgpPeerAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyBgpPeerAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyBgpPeerAttributeResponseBody) SetRequestId(v string) *ModifyBgpPeerAttributeResponseBody {
	s.RequestId = &v
	return s
}

type ModifyBgpPeerAttributeResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyBgpPeerAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyBgpPeerAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyBgpPeerAttributeResponse) GoString() string {
	return s.String()
}

func (s *ModifyBgpPeerAttributeResponse) SetHeaders(v map[string]*string) *ModifyBgpPeerAttributeResponse {
	s.Headers = v
	return s
}

func (s *ModifyBgpPeerAttributeResponse) SetStatusCode(v int32) *ModifyBgpPeerAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyBgpPeerAttributeResponse) SetBody(v *ModifyBgpPeerAttributeResponseBody) *ModifyBgpPeerAttributeResponse {
	s.Body = v
	return s
}

type ModifyCommonBandwidthPackageAttributeRequest struct {
	// The ID of the EIP bandwidth plan.
	BandwidthPackageId *string `json:"BandwidthPackageId,omitempty" xml:"BandwidthPackageId,omitempty"`
	// The description of the EIP bandwidth plan. The description must be 2 to 256 characters in length. It must start with a letter but cannot start with `http://` or `https://`.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The name of the EIP bandwidth plan. The name must be 2 to 128 characters in length and can contain letters, digits, periods (.), underscores (\_), and hyphens (-). It must start with a letter. It cannot start with `http://` or `https://`.
	Name         *string `json:"Name,omitempty" xml:"Name,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region where the EIP bandwidth plan is created.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ModifyCommonBandwidthPackageAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyCommonBandwidthPackageAttributeRequest) GoString() string {
	return s.String()
}

func (s *ModifyCommonBandwidthPackageAttributeRequest) SetBandwidthPackageId(v string) *ModifyCommonBandwidthPackageAttributeRequest {
	s.BandwidthPackageId = &v
	return s
}

func (s *ModifyCommonBandwidthPackageAttributeRequest) SetDescription(v string) *ModifyCommonBandwidthPackageAttributeRequest {
	s.Description = &v
	return s
}

func (s *ModifyCommonBandwidthPackageAttributeRequest) SetName(v string) *ModifyCommonBandwidthPackageAttributeRequest {
	s.Name = &v
	return s
}

func (s *ModifyCommonBandwidthPackageAttributeRequest) SetOwnerAccount(v string) *ModifyCommonBandwidthPackageAttributeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyCommonBandwidthPackageAttributeRequest) SetOwnerId(v int64) *ModifyCommonBandwidthPackageAttributeRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyCommonBandwidthPackageAttributeRequest) SetRegionId(v string) *ModifyCommonBandwidthPackageAttributeRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyCommonBandwidthPackageAttributeRequest) SetResourceOwnerAccount(v string) *ModifyCommonBandwidthPackageAttributeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyCommonBandwidthPackageAttributeRequest) SetResourceOwnerId(v int64) *ModifyCommonBandwidthPackageAttributeRequest {
	s.ResourceOwnerId = &v
	return s
}

type ModifyCommonBandwidthPackageAttributeResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyCommonBandwidthPackageAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyCommonBandwidthPackageAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyCommonBandwidthPackageAttributeResponseBody) SetRequestId(v string) *ModifyCommonBandwidthPackageAttributeResponseBody {
	s.RequestId = &v
	return s
}

type ModifyCommonBandwidthPackageAttributeResponse struct {
	Headers    map[string]*string                                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyCommonBandwidthPackageAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyCommonBandwidthPackageAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyCommonBandwidthPackageAttributeResponse) GoString() string {
	return s.String()
}

func (s *ModifyCommonBandwidthPackageAttributeResponse) SetHeaders(v map[string]*string) *ModifyCommonBandwidthPackageAttributeResponse {
	s.Headers = v
	return s
}

func (s *ModifyCommonBandwidthPackageAttributeResponse) SetStatusCode(v int32) *ModifyCommonBandwidthPackageAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyCommonBandwidthPackageAttributeResponse) SetBody(v *ModifyCommonBandwidthPackageAttributeResponseBody) *ModifyCommonBandwidthPackageAttributeResponse {
	s.Body = v
	return s
}

type ModifyCommonBandwidthPackageIpBandwidthRequest struct {
	// The maximum bandwidth for the EIP. This value cannot be larger than the maximum bandwidth of the EIP bandwidth plan. Unit: Mbit/s.
	Bandwidth *string `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	// The ID of the EIP bandwidth plan.
	BandwidthPackageId *string `json:"BandwidthPackageId,omitempty" xml:"BandwidthPackageId,omitempty"`
	// The ID of the EIP that is associated with the EIP bandwidth plan.
	EipId        *string `json:"EipId,omitempty" xml:"EipId,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the EIP bandwidth plan. You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ModifyCommonBandwidthPackageIpBandwidthRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyCommonBandwidthPackageIpBandwidthRequest) GoString() string {
	return s.String()
}

func (s *ModifyCommonBandwidthPackageIpBandwidthRequest) SetBandwidth(v string) *ModifyCommonBandwidthPackageIpBandwidthRequest {
	s.Bandwidth = &v
	return s
}

func (s *ModifyCommonBandwidthPackageIpBandwidthRequest) SetBandwidthPackageId(v string) *ModifyCommonBandwidthPackageIpBandwidthRequest {
	s.BandwidthPackageId = &v
	return s
}

func (s *ModifyCommonBandwidthPackageIpBandwidthRequest) SetEipId(v string) *ModifyCommonBandwidthPackageIpBandwidthRequest {
	s.EipId = &v
	return s
}

func (s *ModifyCommonBandwidthPackageIpBandwidthRequest) SetOwnerAccount(v string) *ModifyCommonBandwidthPackageIpBandwidthRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyCommonBandwidthPackageIpBandwidthRequest) SetOwnerId(v int64) *ModifyCommonBandwidthPackageIpBandwidthRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyCommonBandwidthPackageIpBandwidthRequest) SetRegionId(v string) *ModifyCommonBandwidthPackageIpBandwidthRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyCommonBandwidthPackageIpBandwidthRequest) SetResourceOwnerAccount(v string) *ModifyCommonBandwidthPackageIpBandwidthRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyCommonBandwidthPackageIpBandwidthRequest) SetResourceOwnerId(v int64) *ModifyCommonBandwidthPackageIpBandwidthRequest {
	s.ResourceOwnerId = &v
	return s
}

type ModifyCommonBandwidthPackageIpBandwidthResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyCommonBandwidthPackageIpBandwidthResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyCommonBandwidthPackageIpBandwidthResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyCommonBandwidthPackageIpBandwidthResponseBody) SetRequestId(v string) *ModifyCommonBandwidthPackageIpBandwidthResponseBody {
	s.RequestId = &v
	return s
}

type ModifyCommonBandwidthPackageIpBandwidthResponse struct {
	Headers    map[string]*string                                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyCommonBandwidthPackageIpBandwidthResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyCommonBandwidthPackageIpBandwidthResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyCommonBandwidthPackageIpBandwidthResponse) GoString() string {
	return s.String()
}

func (s *ModifyCommonBandwidthPackageIpBandwidthResponse) SetHeaders(v map[string]*string) *ModifyCommonBandwidthPackageIpBandwidthResponse {
	s.Headers = v
	return s
}

func (s *ModifyCommonBandwidthPackageIpBandwidthResponse) SetStatusCode(v int32) *ModifyCommonBandwidthPackageIpBandwidthResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyCommonBandwidthPackageIpBandwidthResponse) SetBody(v *ModifyCommonBandwidthPackageIpBandwidthResponseBody) *ModifyCommonBandwidthPackageIpBandwidthResponse {
	s.Body = v
	return s
}

type ModifyCommonBandwidthPackageSpecRequest struct {
	// The maximum bandwidth of the EIP bandwidth plan. Unit: Mbit/s.
	//
	// Valid values: **1** to **1000**.
	Bandwidth *string `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	// The ID of the EIP bandwidth plan.
	BandwidthPackageId *string `json:"BandwidthPackageId,omitempty" xml:"BandwidthPackageId,omitempty"`
	OwnerAccount       *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId            *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the EIP bandwidth plan.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ModifyCommonBandwidthPackageSpecRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyCommonBandwidthPackageSpecRequest) GoString() string {
	return s.String()
}

func (s *ModifyCommonBandwidthPackageSpecRequest) SetBandwidth(v string) *ModifyCommonBandwidthPackageSpecRequest {
	s.Bandwidth = &v
	return s
}

func (s *ModifyCommonBandwidthPackageSpecRequest) SetBandwidthPackageId(v string) *ModifyCommonBandwidthPackageSpecRequest {
	s.BandwidthPackageId = &v
	return s
}

func (s *ModifyCommonBandwidthPackageSpecRequest) SetOwnerAccount(v string) *ModifyCommonBandwidthPackageSpecRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyCommonBandwidthPackageSpecRequest) SetOwnerId(v int64) *ModifyCommonBandwidthPackageSpecRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyCommonBandwidthPackageSpecRequest) SetRegionId(v string) *ModifyCommonBandwidthPackageSpecRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyCommonBandwidthPackageSpecRequest) SetResourceOwnerAccount(v string) *ModifyCommonBandwidthPackageSpecRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyCommonBandwidthPackageSpecRequest) SetResourceOwnerId(v int64) *ModifyCommonBandwidthPackageSpecRequest {
	s.ResourceOwnerId = &v
	return s
}

type ModifyCommonBandwidthPackageSpecResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyCommonBandwidthPackageSpecResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyCommonBandwidthPackageSpecResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyCommonBandwidthPackageSpecResponseBody) SetRequestId(v string) *ModifyCommonBandwidthPackageSpecResponseBody {
	s.RequestId = &v
	return s
}

type ModifyCommonBandwidthPackageSpecResponse struct {
	Headers    map[string]*string                            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyCommonBandwidthPackageSpecResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyCommonBandwidthPackageSpecResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyCommonBandwidthPackageSpecResponse) GoString() string {
	return s.String()
}

func (s *ModifyCommonBandwidthPackageSpecResponse) SetHeaders(v map[string]*string) *ModifyCommonBandwidthPackageSpecResponse {
	s.Headers = v
	return s
}

func (s *ModifyCommonBandwidthPackageSpecResponse) SetStatusCode(v int32) *ModifyCommonBandwidthPackageSpecResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyCommonBandwidthPackageSpecResponse) SetBody(v *ModifyCommonBandwidthPackageSpecResponseBody) *ModifyCommonBandwidthPackageSpecResponse {
	s.Body = v
	return s
}

type ModifyCustomerGatewayAttributeRequest struct {
	// The authentication key of the BGP routing protocol for the gateway device in the data center.
	//
	// The key must be 1 to 64 characters in length. It can contain only ASCII characters and cannot contain spaces or question marks (?).
	AuthKey *string `json:"AuthKey,omitempty" xml:"AuthKey,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. ClientToken can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the customer gateway.
	CustomerGatewayId *string `json:"CustomerGatewayId,omitempty" xml:"CustomerGatewayId,omitempty"`
	// The description of the customer gateway.
	//
	// The description must be 1 to 100 characters in length, and cannot start with `http://` or `https://`.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The name of the customer gateway.
	//
	// The name must be 1 to 100 characters in length, and cannot start with `http://` or `https://`.
	Name         *string `json:"Name,omitempty" xml:"Name,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region where the NAT gateway is deployed.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ModifyCustomerGatewayAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyCustomerGatewayAttributeRequest) GoString() string {
	return s.String()
}

func (s *ModifyCustomerGatewayAttributeRequest) SetAuthKey(v string) *ModifyCustomerGatewayAttributeRequest {
	s.AuthKey = &v
	return s
}

func (s *ModifyCustomerGatewayAttributeRequest) SetClientToken(v string) *ModifyCustomerGatewayAttributeRequest {
	s.ClientToken = &v
	return s
}

func (s *ModifyCustomerGatewayAttributeRequest) SetCustomerGatewayId(v string) *ModifyCustomerGatewayAttributeRequest {
	s.CustomerGatewayId = &v
	return s
}

func (s *ModifyCustomerGatewayAttributeRequest) SetDescription(v string) *ModifyCustomerGatewayAttributeRequest {
	s.Description = &v
	return s
}

func (s *ModifyCustomerGatewayAttributeRequest) SetName(v string) *ModifyCustomerGatewayAttributeRequest {
	s.Name = &v
	return s
}

func (s *ModifyCustomerGatewayAttributeRequest) SetOwnerAccount(v string) *ModifyCustomerGatewayAttributeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyCustomerGatewayAttributeRequest) SetOwnerId(v int64) *ModifyCustomerGatewayAttributeRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyCustomerGatewayAttributeRequest) SetRegionId(v string) *ModifyCustomerGatewayAttributeRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyCustomerGatewayAttributeRequest) SetResourceOwnerAccount(v string) *ModifyCustomerGatewayAttributeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyCustomerGatewayAttributeRequest) SetResourceOwnerId(v int64) *ModifyCustomerGatewayAttributeRequest {
	s.ResourceOwnerId = &v
	return s
}

type ModifyCustomerGatewayAttributeResponseBody struct {
	// The timestamp generated when the customer gateway was created.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The ID of the customer gateway.
	CustomerGatewayId *string `json:"CustomerGatewayId,omitempty" xml:"CustomerGatewayId,omitempty"`
	// The description of the customer gateway.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The public IP address of the gateway device in the data center.
	IpAddress *string `json:"IpAddress,omitempty" xml:"IpAddress,omitempty"`
	// The name of the customer gateway.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyCustomerGatewayAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyCustomerGatewayAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyCustomerGatewayAttributeResponseBody) SetCreateTime(v int64) *ModifyCustomerGatewayAttributeResponseBody {
	s.CreateTime = &v
	return s
}

func (s *ModifyCustomerGatewayAttributeResponseBody) SetCustomerGatewayId(v string) *ModifyCustomerGatewayAttributeResponseBody {
	s.CustomerGatewayId = &v
	return s
}

func (s *ModifyCustomerGatewayAttributeResponseBody) SetDescription(v string) *ModifyCustomerGatewayAttributeResponseBody {
	s.Description = &v
	return s
}

func (s *ModifyCustomerGatewayAttributeResponseBody) SetIpAddress(v string) *ModifyCustomerGatewayAttributeResponseBody {
	s.IpAddress = &v
	return s
}

func (s *ModifyCustomerGatewayAttributeResponseBody) SetName(v string) *ModifyCustomerGatewayAttributeResponseBody {
	s.Name = &v
	return s
}

func (s *ModifyCustomerGatewayAttributeResponseBody) SetRequestId(v string) *ModifyCustomerGatewayAttributeResponseBody {
	s.RequestId = &v
	return s
}

type ModifyCustomerGatewayAttributeResponse struct {
	Headers    map[string]*string                          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyCustomerGatewayAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyCustomerGatewayAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyCustomerGatewayAttributeResponse) GoString() string {
	return s.String()
}

func (s *ModifyCustomerGatewayAttributeResponse) SetHeaders(v map[string]*string) *ModifyCustomerGatewayAttributeResponse {
	s.Headers = v
	return s
}

func (s *ModifyCustomerGatewayAttributeResponse) SetStatusCode(v int32) *ModifyCustomerGatewayAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyCustomerGatewayAttributeResponse) SetBody(v *ModifyCustomerGatewayAttributeResponseBody) *ModifyCustomerGatewayAttributeResponse {
	s.Body = v
	return s
}

type ModifyEipAddressAttributeRequest struct {
	// The ID of the pay-as-you-go EIP.
	AllocationId *string `json:"AllocationId,omitempty" xml:"AllocationId,omitempty"`
	// The new maximum bandwidth of the EIP. Valid values:
	//
	// *   **1** to **200** if the metering method is pay-by-data-transfer. Unit: Mbit/s.
	// *   **1** to **500** if the metering method is pay-by-bandwidth. Unit: Mbit/s.
	Bandwidth *string `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	// The new description of the EIP.
	//
	// The description must be 2 to 256 characters in length. It must start with a letter but cannot start with `http://` or `https://`.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The new name of the EIP.
	//
	// The name must be 1 to 128 characters in length, and can contain digits, periods (.), underscores (\_), and hyphens (-).
	Name         *string `json:"Name,omitempty" xml:"Name,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the EIP.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ModifyEipAddressAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyEipAddressAttributeRequest) GoString() string {
	return s.String()
}

func (s *ModifyEipAddressAttributeRequest) SetAllocationId(v string) *ModifyEipAddressAttributeRequest {
	s.AllocationId = &v
	return s
}

func (s *ModifyEipAddressAttributeRequest) SetBandwidth(v string) *ModifyEipAddressAttributeRequest {
	s.Bandwidth = &v
	return s
}

func (s *ModifyEipAddressAttributeRequest) SetDescription(v string) *ModifyEipAddressAttributeRequest {
	s.Description = &v
	return s
}

func (s *ModifyEipAddressAttributeRequest) SetName(v string) *ModifyEipAddressAttributeRequest {
	s.Name = &v
	return s
}

func (s *ModifyEipAddressAttributeRequest) SetOwnerAccount(v string) *ModifyEipAddressAttributeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyEipAddressAttributeRequest) SetOwnerId(v int64) *ModifyEipAddressAttributeRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyEipAddressAttributeRequest) SetRegionId(v string) *ModifyEipAddressAttributeRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyEipAddressAttributeRequest) SetResourceOwnerAccount(v string) *ModifyEipAddressAttributeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyEipAddressAttributeRequest) SetResourceOwnerId(v int64) *ModifyEipAddressAttributeRequest {
	s.ResourceOwnerId = &v
	return s
}

type ModifyEipAddressAttributeResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyEipAddressAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyEipAddressAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyEipAddressAttributeResponseBody) SetRequestId(v string) *ModifyEipAddressAttributeResponseBody {
	s.RequestId = &v
	return s
}

type ModifyEipAddressAttributeResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyEipAddressAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyEipAddressAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyEipAddressAttributeResponse) GoString() string {
	return s.String()
}

func (s *ModifyEipAddressAttributeResponse) SetHeaders(v map[string]*string) *ModifyEipAddressAttributeResponse {
	s.Headers = v
	return s
}

func (s *ModifyEipAddressAttributeResponse) SetStatusCode(v int32) *ModifyEipAddressAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyEipAddressAttributeResponse) SetBody(v *ModifyEipAddressAttributeResponseBody) *ModifyEipAddressAttributeResponse {
	s.Body = v
	return s
}

type ModifyExpressCloudConnectionAttributeRequest struct {
	// The BGP autonomous system number (ASN) to be configured for the Smart Access Gateway (SAG) device.
	BgpAs *string `json:"BgpAs,omitempty" xml:"BgpAs,omitempty"`
	// The peer IP address when the SAG device is connected to the cloud.
	CeIp *string `json:"CeIp,omitempty" xml:"CeIp,omitempty"`
	// Descriptions of ECC.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the ECC instance.
	EccId *string `json:"EccId,omitempty" xml:"EccId,omitempty"`
	// The name of the ECC instance.
	Name         *string `json:"Name,omitempty" xml:"Name,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The on-premises IP address when the SAG device is connected to the cloud.
	PeIp *string `json:"PeIp,omitempty" xml:"PeIp,omitempty"`
	// The region ID of the ECC instance.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ModifyExpressCloudConnectionAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyExpressCloudConnectionAttributeRequest) GoString() string {
	return s.String()
}

func (s *ModifyExpressCloudConnectionAttributeRequest) SetBgpAs(v string) *ModifyExpressCloudConnectionAttributeRequest {
	s.BgpAs = &v
	return s
}

func (s *ModifyExpressCloudConnectionAttributeRequest) SetCeIp(v string) *ModifyExpressCloudConnectionAttributeRequest {
	s.CeIp = &v
	return s
}

func (s *ModifyExpressCloudConnectionAttributeRequest) SetDescription(v string) *ModifyExpressCloudConnectionAttributeRequest {
	s.Description = &v
	return s
}

func (s *ModifyExpressCloudConnectionAttributeRequest) SetEccId(v string) *ModifyExpressCloudConnectionAttributeRequest {
	s.EccId = &v
	return s
}

func (s *ModifyExpressCloudConnectionAttributeRequest) SetName(v string) *ModifyExpressCloudConnectionAttributeRequest {
	s.Name = &v
	return s
}

func (s *ModifyExpressCloudConnectionAttributeRequest) SetOwnerAccount(v string) *ModifyExpressCloudConnectionAttributeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyExpressCloudConnectionAttributeRequest) SetOwnerId(v int64) *ModifyExpressCloudConnectionAttributeRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyExpressCloudConnectionAttributeRequest) SetPeIp(v string) *ModifyExpressCloudConnectionAttributeRequest {
	s.PeIp = &v
	return s
}

func (s *ModifyExpressCloudConnectionAttributeRequest) SetRegionId(v string) *ModifyExpressCloudConnectionAttributeRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyExpressCloudConnectionAttributeRequest) SetResourceOwnerAccount(v string) *ModifyExpressCloudConnectionAttributeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyExpressCloudConnectionAttributeRequest) SetResourceOwnerId(v int64) *ModifyExpressCloudConnectionAttributeRequest {
	s.ResourceOwnerId = &v
	return s
}

type ModifyExpressCloudConnectionAttributeResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyExpressCloudConnectionAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyExpressCloudConnectionAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyExpressCloudConnectionAttributeResponseBody) SetRequestId(v string) *ModifyExpressCloudConnectionAttributeResponseBody {
	s.RequestId = &v
	return s
}

type ModifyExpressCloudConnectionAttributeResponse struct {
	Headers    map[string]*string                                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyExpressCloudConnectionAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyExpressCloudConnectionAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyExpressCloudConnectionAttributeResponse) GoString() string {
	return s.String()
}

func (s *ModifyExpressCloudConnectionAttributeResponse) SetHeaders(v map[string]*string) *ModifyExpressCloudConnectionAttributeResponse {
	s.Headers = v
	return s
}

func (s *ModifyExpressCloudConnectionAttributeResponse) SetStatusCode(v int32) *ModifyExpressCloudConnectionAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyExpressCloudConnectionAttributeResponse) SetBody(v *ModifyExpressCloudConnectionAttributeResponseBody) *ModifyExpressCloudConnectionAttributeResponse {
	s.Body = v
	return s
}

type ModifyExpressCloudConnectionBandwidthRequest struct {
	// The bandwidth of the ECC instance.
	Bandwidth *string `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	// The ID of the ECC instance.
	EccId        *string `json:"EccId,omitempty" xml:"EccId,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ModifyExpressCloudConnectionBandwidthRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyExpressCloudConnectionBandwidthRequest) GoString() string {
	return s.String()
}

func (s *ModifyExpressCloudConnectionBandwidthRequest) SetBandwidth(v string) *ModifyExpressCloudConnectionBandwidthRequest {
	s.Bandwidth = &v
	return s
}

func (s *ModifyExpressCloudConnectionBandwidthRequest) SetEccId(v string) *ModifyExpressCloudConnectionBandwidthRequest {
	s.EccId = &v
	return s
}

func (s *ModifyExpressCloudConnectionBandwidthRequest) SetOwnerAccount(v string) *ModifyExpressCloudConnectionBandwidthRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyExpressCloudConnectionBandwidthRequest) SetOwnerId(v int64) *ModifyExpressCloudConnectionBandwidthRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyExpressCloudConnectionBandwidthRequest) SetRegionId(v string) *ModifyExpressCloudConnectionBandwidthRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyExpressCloudConnectionBandwidthRequest) SetResourceOwnerAccount(v string) *ModifyExpressCloudConnectionBandwidthRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyExpressCloudConnectionBandwidthRequest) SetResourceOwnerId(v int64) *ModifyExpressCloudConnectionBandwidthRequest {
	s.ResourceOwnerId = &v
	return s
}

type ModifyExpressCloudConnectionBandwidthResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyExpressCloudConnectionBandwidthResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyExpressCloudConnectionBandwidthResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyExpressCloudConnectionBandwidthResponseBody) SetRequestId(v string) *ModifyExpressCloudConnectionBandwidthResponseBody {
	s.RequestId = &v
	return s
}

type ModifyExpressCloudConnectionBandwidthResponse struct {
	Headers    map[string]*string                                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyExpressCloudConnectionBandwidthResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyExpressCloudConnectionBandwidthResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyExpressCloudConnectionBandwidthResponse) GoString() string {
	return s.String()
}

func (s *ModifyExpressCloudConnectionBandwidthResponse) SetHeaders(v map[string]*string) *ModifyExpressCloudConnectionBandwidthResponse {
	s.Headers = v
	return s
}

func (s *ModifyExpressCloudConnectionBandwidthResponse) SetStatusCode(v int32) *ModifyExpressCloudConnectionBandwidthResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyExpressCloudConnectionBandwidthResponse) SetBody(v *ModifyExpressCloudConnectionBandwidthResponseBody) *ModifyExpressCloudConnectionBandwidthResponse {
	s.Body = v
	return s
}

type ModifyFlowLogAttributeRequest struct {
	// The new sampling interval of the flow log. Unit: seconds. Valid values: **1**, **5**, and **10**.
	AggregationInterval *int32 `json:"AggregationInterval,omitempty" xml:"AggregationInterval,omitempty"`
	// The new description of the flow log.
	//
	// The description must be 1 to 256 characters in length, and cannot start with `http://` or `https://`.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the flow log.
	FlowLogId *string `json:"FlowLogId,omitempty" xml:"FlowLogId,omitempty"`
	// The new name of the flow log.
	//
	// The name must be 1 to 128 characters in length, and cannot start with `http://` or `https://`.
	FlowLogName  *string `json:"FlowLogName,omitempty" xml:"FlowLogName,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region where the flow log is created.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ModifyFlowLogAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyFlowLogAttributeRequest) GoString() string {
	return s.String()
}

func (s *ModifyFlowLogAttributeRequest) SetAggregationInterval(v int32) *ModifyFlowLogAttributeRequest {
	s.AggregationInterval = &v
	return s
}

func (s *ModifyFlowLogAttributeRequest) SetDescription(v string) *ModifyFlowLogAttributeRequest {
	s.Description = &v
	return s
}

func (s *ModifyFlowLogAttributeRequest) SetFlowLogId(v string) *ModifyFlowLogAttributeRequest {
	s.FlowLogId = &v
	return s
}

func (s *ModifyFlowLogAttributeRequest) SetFlowLogName(v string) *ModifyFlowLogAttributeRequest {
	s.FlowLogName = &v
	return s
}

func (s *ModifyFlowLogAttributeRequest) SetOwnerAccount(v string) *ModifyFlowLogAttributeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyFlowLogAttributeRequest) SetOwnerId(v int64) *ModifyFlowLogAttributeRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyFlowLogAttributeRequest) SetRegionId(v string) *ModifyFlowLogAttributeRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyFlowLogAttributeRequest) SetResourceOwnerAccount(v string) *ModifyFlowLogAttributeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyFlowLogAttributeRequest) SetResourceOwnerId(v int64) *ModifyFlowLogAttributeRequest {
	s.ResourceOwnerId = &v
	return s
}

type ModifyFlowLogAttributeResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call is successful. Valid values:
	//
	// *   **true**: yes
	// *   **false**: no
	Success *string `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ModifyFlowLogAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyFlowLogAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyFlowLogAttributeResponseBody) SetRequestId(v string) *ModifyFlowLogAttributeResponseBody {
	s.RequestId = &v
	return s
}

func (s *ModifyFlowLogAttributeResponseBody) SetSuccess(v string) *ModifyFlowLogAttributeResponseBody {
	s.Success = &v
	return s
}

type ModifyFlowLogAttributeResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyFlowLogAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyFlowLogAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyFlowLogAttributeResponse) GoString() string {
	return s.String()
}

func (s *ModifyFlowLogAttributeResponse) SetHeaders(v map[string]*string) *ModifyFlowLogAttributeResponse {
	s.Headers = v
	return s
}

func (s *ModifyFlowLogAttributeResponse) SetStatusCode(v int32) *ModifyFlowLogAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyFlowLogAttributeResponse) SetBody(v *ModifyFlowLogAttributeResponseBody) *ModifyFlowLogAttributeResponse {
	s.Body = v
	return s
}

type ModifyForwardEntryRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among all requests. ClientToken can contain only ASCII characters.
	//
	// >  If you do not specify this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// *   When you modify DNAT entries of Internet NAT gateways, this parameter specifies the elastic IP addresses (EIPs) that are used to access the Internet.
	// *   When you modify DNAT entries of Virtual Private Cloud (VPC) NAT gateways, this parameter specifies the NAT IP addresses that are accessed by external networks.
	ExternalIp *string `json:"ExternalIp,omitempty" xml:"ExternalIp,omitempty"`
	// *   The external port that is used to forward traffic when you modify DNAT entries of Internet NAT gateways.
	//
	//     *   Valid values: **1** to **65535**.
	//     *   If you want to modify the port range, separate port numbers with a forward slash (/), such as `10/20`.
	//     *   If you want to modify **ExternalPort** and **InternalPort** at the same time, and set **ExternalPort** to a port range, you must also set **InternalPort** to a port range. For example, you can set **ExternalPort** to `10/20` and set **InternalPor** to `80/90`.
	//
	// *   The port that is accessed by external networks when you modify DNAT entries of VPC NAT gateways. Valid values: **1** to **65535**.
	ExternalPort *string `json:"ExternalPort,omitempty" xml:"ExternalPort,omitempty"`
	// The ID of the DNAT entry.
	ForwardEntryId *string `json:"ForwardEntryId,omitempty" xml:"ForwardEntryId,omitempty"`
	// The new name of the DNAT entry.
	//
	// The name must be 2 to 128 characters in length. It must start with a letter but cannot start with `http://` or `https://`.
	ForwardEntryName *string `json:"ForwardEntryName,omitempty" xml:"ForwardEntryName,omitempty"`
	// The ID of the DNAT table to which the DNAT entry belongs.
	ForwardTableId *string `json:"ForwardTableId,omitempty" xml:"ForwardTableId,omitempty"`
	// *   The private IP address of the ECS instance that uses DNAT entries to communicate with the Internet when you modify DNAT entries of Internet NAT gateways.
	// *   The private IP address that uses DNAT entries to communicate when you modify DNAT entries of VPC NAT gateways.
	InternalIp *string `json:"InternalIp,omitempty" xml:"InternalIp,omitempty"`
	// *   The internal port or port range that is used to forward traffic when you modify DNAT entries of Internet NAT gateways. Valid values: **1** to **65535**.
	// *   The port of the destination ECS instance to be mapped when you modify DNAT entries of VPC NAT gateways. Valid values: **1** to **65535**.
	InternalPort *string `json:"InternalPort,omitempty" xml:"InternalPort,omitempty"`
	// The protocol type. Valid values:
	//
	// *   **TCP**: The NAT gateway forwards TCP packets.
	// *   **UDP**: The NAT gateway forwards UDP packets.
	// *   **Any**: The NAT gateway forwards packets of all protocols.
	IpProtocol   *string `json:"IpProtocol,omitempty" xml:"IpProtocol,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// Specifies whether to remove limits on the port range. Valid values:
	//
	// *   **true**: yes
	// *   **false**: no If an SNAT entry and a DNAT entry use the same public IP address, and you want to specify a port number greater than `1024`, set `PortBreak` to `true`.
	PortBreak *bool `json:"PortBreak,omitempty" xml:"PortBreak,omitempty"`
	// The region ID of the NAT gateway.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ModifyForwardEntryRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyForwardEntryRequest) GoString() string {
	return s.String()
}

func (s *ModifyForwardEntryRequest) SetClientToken(v string) *ModifyForwardEntryRequest {
	s.ClientToken = &v
	return s
}

func (s *ModifyForwardEntryRequest) SetExternalIp(v string) *ModifyForwardEntryRequest {
	s.ExternalIp = &v
	return s
}

func (s *ModifyForwardEntryRequest) SetExternalPort(v string) *ModifyForwardEntryRequest {
	s.ExternalPort = &v
	return s
}

func (s *ModifyForwardEntryRequest) SetForwardEntryId(v string) *ModifyForwardEntryRequest {
	s.ForwardEntryId = &v
	return s
}

func (s *ModifyForwardEntryRequest) SetForwardEntryName(v string) *ModifyForwardEntryRequest {
	s.ForwardEntryName = &v
	return s
}

func (s *ModifyForwardEntryRequest) SetForwardTableId(v string) *ModifyForwardEntryRequest {
	s.ForwardTableId = &v
	return s
}

func (s *ModifyForwardEntryRequest) SetInternalIp(v string) *ModifyForwardEntryRequest {
	s.InternalIp = &v
	return s
}

func (s *ModifyForwardEntryRequest) SetInternalPort(v string) *ModifyForwardEntryRequest {
	s.InternalPort = &v
	return s
}

func (s *ModifyForwardEntryRequest) SetIpProtocol(v string) *ModifyForwardEntryRequest {
	s.IpProtocol = &v
	return s
}

func (s *ModifyForwardEntryRequest) SetOwnerAccount(v string) *ModifyForwardEntryRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyForwardEntryRequest) SetOwnerId(v int64) *ModifyForwardEntryRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyForwardEntryRequest) SetPortBreak(v bool) *ModifyForwardEntryRequest {
	s.PortBreak = &v
	return s
}

func (s *ModifyForwardEntryRequest) SetRegionId(v string) *ModifyForwardEntryRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyForwardEntryRequest) SetResourceOwnerAccount(v string) *ModifyForwardEntryRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyForwardEntryRequest) SetResourceOwnerId(v int64) *ModifyForwardEntryRequest {
	s.ResourceOwnerId = &v
	return s
}

type ModifyForwardEntryResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyForwardEntryResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyForwardEntryResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyForwardEntryResponseBody) SetRequestId(v string) *ModifyForwardEntryResponseBody {
	s.RequestId = &v
	return s
}

type ModifyForwardEntryResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyForwardEntryResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyForwardEntryResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyForwardEntryResponse) GoString() string {
	return s.String()
}

func (s *ModifyForwardEntryResponse) SetHeaders(v map[string]*string) *ModifyForwardEntryResponse {
	s.Headers = v
	return s
}

func (s *ModifyForwardEntryResponse) SetStatusCode(v int32) *ModifyForwardEntryResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyForwardEntryResponse) SetBody(v *ModifyForwardEntryResponseBody) *ModifyForwardEntryResponse {
	s.Body = v
	return s
}

type ModifyFullNatEntryAttributeRequest struct {
	// The backend IP address to be modified in FULLNAT address translation.
	AccessIp *string `json:"AccessIp,omitempty" xml:"AccessIp,omitempty"`
	// The backend port to be modified in FULLNAT port mapping. Valid values: **1** to **65535**.
	AccessPort *string `json:"AccessPort,omitempty" xml:"AccessPort,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether only to precheck this request. Valid values:
	//
	// *   **true**: prechecks the request but does not modify the FULLNAT entry. The system checks your AccessKey pair, the RAM user permissions, and the required parameters. If the request fails the precheck, an error code is returned. If the request passes the check, the `DryRunOperation` error code is returned.
	// *   **false**: sends the API request. After the request passes the check, a 2XX HTTP status code is returned and the FULLNAT entry is modified. This is the default value.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The new description of the FULLNAT entry.
	//
	// This parameter is optional. If you enter a description, the description must be 2 to 256 characters in length, and cannot start with `http://` or `https://`.
	FullNatEntryDescription *string `json:"FullNatEntryDescription,omitempty" xml:"FullNatEntryDescription,omitempty"`
	// The ID of the FULLNAT entry to be modified.
	FullNatEntryId *string `json:"FullNatEntryId,omitempty" xml:"FullNatEntryId,omitempty"`
	// The new name of the FULLNAT entry.
	//
	// The name must be 2 to 128 characters in length. It must start with a letter but cannot start with `http://` or `https://`.
	FullNatEntryName *string `json:"FullNatEntryName,omitempty" xml:"FullNatEntryName,omitempty"`
	// The ID of the FULLNAT table to be modified.
	FullNatTableId *string `json:"FullNatTableId,omitempty" xml:"FullNatTableId,omitempty"`
	// The protocol of the packets that are forwarded by the port. Valid values:
	//
	// *   **TCP**: TCP
	// *   **UDP**: UDP
	IpProtocol *string `json:"IpProtocol,omitempty" xml:"IpProtocol,omitempty"`
	// The NAT IP address to be modified.
	NatIp *string `json:"NatIp,omitempty" xml:"NatIp,omitempty"`
	// The frontend port to be modified in FULLNAT port mapping. Valid values: **1** to **65535**.
	NatIpPort *string `json:"NatIpPort,omitempty" xml:"NatIpPort,omitempty"`
	// The ID of the elastic network interface (ENI) to be modified.
	NetworkInterfaceId *string `json:"NetworkInterfaceId,omitempty" xml:"NetworkInterfaceId,omitempty"`
	OwnerAccount       *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId            *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the Virtual Private Cloud (VPC) NAT gateway to which the FULLNAT entry to be modified belongs.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ModifyFullNatEntryAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyFullNatEntryAttributeRequest) GoString() string {
	return s.String()
}

func (s *ModifyFullNatEntryAttributeRequest) SetAccessIp(v string) *ModifyFullNatEntryAttributeRequest {
	s.AccessIp = &v
	return s
}

func (s *ModifyFullNatEntryAttributeRequest) SetAccessPort(v string) *ModifyFullNatEntryAttributeRequest {
	s.AccessPort = &v
	return s
}

func (s *ModifyFullNatEntryAttributeRequest) SetClientToken(v string) *ModifyFullNatEntryAttributeRequest {
	s.ClientToken = &v
	return s
}

func (s *ModifyFullNatEntryAttributeRequest) SetDryRun(v bool) *ModifyFullNatEntryAttributeRequest {
	s.DryRun = &v
	return s
}

func (s *ModifyFullNatEntryAttributeRequest) SetFullNatEntryDescription(v string) *ModifyFullNatEntryAttributeRequest {
	s.FullNatEntryDescription = &v
	return s
}

func (s *ModifyFullNatEntryAttributeRequest) SetFullNatEntryId(v string) *ModifyFullNatEntryAttributeRequest {
	s.FullNatEntryId = &v
	return s
}

func (s *ModifyFullNatEntryAttributeRequest) SetFullNatEntryName(v string) *ModifyFullNatEntryAttributeRequest {
	s.FullNatEntryName = &v
	return s
}

func (s *ModifyFullNatEntryAttributeRequest) SetFullNatTableId(v string) *ModifyFullNatEntryAttributeRequest {
	s.FullNatTableId = &v
	return s
}

func (s *ModifyFullNatEntryAttributeRequest) SetIpProtocol(v string) *ModifyFullNatEntryAttributeRequest {
	s.IpProtocol = &v
	return s
}

func (s *ModifyFullNatEntryAttributeRequest) SetNatIp(v string) *ModifyFullNatEntryAttributeRequest {
	s.NatIp = &v
	return s
}

func (s *ModifyFullNatEntryAttributeRequest) SetNatIpPort(v string) *ModifyFullNatEntryAttributeRequest {
	s.NatIpPort = &v
	return s
}

func (s *ModifyFullNatEntryAttributeRequest) SetNetworkInterfaceId(v string) *ModifyFullNatEntryAttributeRequest {
	s.NetworkInterfaceId = &v
	return s
}

func (s *ModifyFullNatEntryAttributeRequest) SetOwnerAccount(v string) *ModifyFullNatEntryAttributeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyFullNatEntryAttributeRequest) SetOwnerId(v int64) *ModifyFullNatEntryAttributeRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyFullNatEntryAttributeRequest) SetRegionId(v string) *ModifyFullNatEntryAttributeRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyFullNatEntryAttributeRequest) SetResourceOwnerAccount(v string) *ModifyFullNatEntryAttributeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyFullNatEntryAttributeRequest) SetResourceOwnerId(v int64) *ModifyFullNatEntryAttributeRequest {
	s.ResourceOwnerId = &v
	return s
}

type ModifyFullNatEntryAttributeResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyFullNatEntryAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyFullNatEntryAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyFullNatEntryAttributeResponseBody) SetRequestId(v string) *ModifyFullNatEntryAttributeResponseBody {
	s.RequestId = &v
	return s
}

type ModifyFullNatEntryAttributeResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyFullNatEntryAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyFullNatEntryAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyFullNatEntryAttributeResponse) GoString() string {
	return s.String()
}

func (s *ModifyFullNatEntryAttributeResponse) SetHeaders(v map[string]*string) *ModifyFullNatEntryAttributeResponse {
	s.Headers = v
	return s
}

func (s *ModifyFullNatEntryAttributeResponse) SetStatusCode(v int32) *ModifyFullNatEntryAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyFullNatEntryAttributeResponse) SetBody(v *ModifyFullNatEntryAttributeResponseBody) *ModifyFullNatEntryAttributeResponse {
	s.Body = v
	return s
}

type ModifyGlobalAccelerationInstanceAttributesRequest struct {
	// The description of the GA instance.
	//
	// The description must be 2 to 256 characters in length. It must start with a letter but cannot start with `http://` or `https://`.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the GA instance.
	GlobalAccelerationInstanceId *string `json:"GlobalAccelerationInstanceId,omitempty" xml:"GlobalAccelerationInstanceId,omitempty"`
	// The name of the GA instance.
	//
	// The name must be 2 to 128 characters in length and can contain letters, digits, periods (.), underscores (\_), and hyphens (-). It cannot start with `http://` or `https://`.
	Name         *string `json:"Name,omitempty" xml:"Name,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the GA instance.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ModifyGlobalAccelerationInstanceAttributesRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyGlobalAccelerationInstanceAttributesRequest) GoString() string {
	return s.String()
}

func (s *ModifyGlobalAccelerationInstanceAttributesRequest) SetDescription(v string) *ModifyGlobalAccelerationInstanceAttributesRequest {
	s.Description = &v
	return s
}

func (s *ModifyGlobalAccelerationInstanceAttributesRequest) SetGlobalAccelerationInstanceId(v string) *ModifyGlobalAccelerationInstanceAttributesRequest {
	s.GlobalAccelerationInstanceId = &v
	return s
}

func (s *ModifyGlobalAccelerationInstanceAttributesRequest) SetName(v string) *ModifyGlobalAccelerationInstanceAttributesRequest {
	s.Name = &v
	return s
}

func (s *ModifyGlobalAccelerationInstanceAttributesRequest) SetOwnerAccount(v string) *ModifyGlobalAccelerationInstanceAttributesRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyGlobalAccelerationInstanceAttributesRequest) SetOwnerId(v int64) *ModifyGlobalAccelerationInstanceAttributesRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyGlobalAccelerationInstanceAttributesRequest) SetRegionId(v string) *ModifyGlobalAccelerationInstanceAttributesRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyGlobalAccelerationInstanceAttributesRequest) SetResourceOwnerAccount(v string) *ModifyGlobalAccelerationInstanceAttributesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyGlobalAccelerationInstanceAttributesRequest) SetResourceOwnerId(v int64) *ModifyGlobalAccelerationInstanceAttributesRequest {
	s.ResourceOwnerId = &v
	return s
}

type ModifyGlobalAccelerationInstanceAttributesResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyGlobalAccelerationInstanceAttributesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyGlobalAccelerationInstanceAttributesResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyGlobalAccelerationInstanceAttributesResponseBody) SetRequestId(v string) *ModifyGlobalAccelerationInstanceAttributesResponseBody {
	s.RequestId = &v
	return s
}

type ModifyGlobalAccelerationInstanceAttributesResponse struct {
	Headers    map[string]*string                                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyGlobalAccelerationInstanceAttributesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyGlobalAccelerationInstanceAttributesResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyGlobalAccelerationInstanceAttributesResponse) GoString() string {
	return s.String()
}

func (s *ModifyGlobalAccelerationInstanceAttributesResponse) SetHeaders(v map[string]*string) *ModifyGlobalAccelerationInstanceAttributesResponse {
	s.Headers = v
	return s
}

func (s *ModifyGlobalAccelerationInstanceAttributesResponse) SetStatusCode(v int32) *ModifyGlobalAccelerationInstanceAttributesResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyGlobalAccelerationInstanceAttributesResponse) SetBody(v *ModifyGlobalAccelerationInstanceAttributesResponseBody) *ModifyGlobalAccelerationInstanceAttributesResponse {
	s.Body = v
	return s
}

type ModifyGlobalAccelerationInstanceSpecRequest struct {
	// The maximum bandwidth of the GA instance. Unit: Mbit/s. Set the value to **10**.
	Bandwidth *string `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	// The ID of the GA instance.
	GlobalAccelerationInstanceId *string `json:"GlobalAccelerationInstanceId,omitempty" xml:"GlobalAccelerationInstanceId,omitempty"`
	OwnerAccount                 *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId                      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the GA instance.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ModifyGlobalAccelerationInstanceSpecRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyGlobalAccelerationInstanceSpecRequest) GoString() string {
	return s.String()
}

func (s *ModifyGlobalAccelerationInstanceSpecRequest) SetBandwidth(v string) *ModifyGlobalAccelerationInstanceSpecRequest {
	s.Bandwidth = &v
	return s
}

func (s *ModifyGlobalAccelerationInstanceSpecRequest) SetGlobalAccelerationInstanceId(v string) *ModifyGlobalAccelerationInstanceSpecRequest {
	s.GlobalAccelerationInstanceId = &v
	return s
}

func (s *ModifyGlobalAccelerationInstanceSpecRequest) SetOwnerAccount(v string) *ModifyGlobalAccelerationInstanceSpecRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyGlobalAccelerationInstanceSpecRequest) SetOwnerId(v int64) *ModifyGlobalAccelerationInstanceSpecRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyGlobalAccelerationInstanceSpecRequest) SetRegionId(v string) *ModifyGlobalAccelerationInstanceSpecRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyGlobalAccelerationInstanceSpecRequest) SetResourceOwnerAccount(v string) *ModifyGlobalAccelerationInstanceSpecRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyGlobalAccelerationInstanceSpecRequest) SetResourceOwnerId(v int64) *ModifyGlobalAccelerationInstanceSpecRequest {
	s.ResourceOwnerId = &v
	return s
}

type ModifyGlobalAccelerationInstanceSpecResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyGlobalAccelerationInstanceSpecResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyGlobalAccelerationInstanceSpecResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyGlobalAccelerationInstanceSpecResponseBody) SetRequestId(v string) *ModifyGlobalAccelerationInstanceSpecResponseBody {
	s.RequestId = &v
	return s
}

type ModifyGlobalAccelerationInstanceSpecResponse struct {
	Headers    map[string]*string                                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyGlobalAccelerationInstanceSpecResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyGlobalAccelerationInstanceSpecResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyGlobalAccelerationInstanceSpecResponse) GoString() string {
	return s.String()
}

func (s *ModifyGlobalAccelerationInstanceSpecResponse) SetHeaders(v map[string]*string) *ModifyGlobalAccelerationInstanceSpecResponse {
	s.Headers = v
	return s
}

func (s *ModifyGlobalAccelerationInstanceSpecResponse) SetStatusCode(v int32) *ModifyGlobalAccelerationInstanceSpecResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyGlobalAccelerationInstanceSpecResponse) SetBody(v *ModifyGlobalAccelerationInstanceSpecResponseBody) *ModifyGlobalAccelerationInstanceSpecResponse {
	s.Body = v
	return s
}

type ModifyHaVipAttributeRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among all requests. ClientToken can contain only ASCII characters.
	//
	// >  If you do not specify this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The description of the HAVIP.
	//
	// The description must be 1 to 256 characters in length and cannot start with `http://` or `https://`.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the HAVIP.
	HaVipId *string `json:"HaVipId,omitempty" xml:"HaVipId,omitempty"`
	// The name of the HAVIP.
	//
	// The name must be 1 to 128 characters in length, and cannot start with `http://` or `https://`.
	Name         *string `json:"Name,omitempty" xml:"Name,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region to which the HAVIP belongs.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ModifyHaVipAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyHaVipAttributeRequest) GoString() string {
	return s.String()
}

func (s *ModifyHaVipAttributeRequest) SetClientToken(v string) *ModifyHaVipAttributeRequest {
	s.ClientToken = &v
	return s
}

func (s *ModifyHaVipAttributeRequest) SetDescription(v string) *ModifyHaVipAttributeRequest {
	s.Description = &v
	return s
}

func (s *ModifyHaVipAttributeRequest) SetHaVipId(v string) *ModifyHaVipAttributeRequest {
	s.HaVipId = &v
	return s
}

func (s *ModifyHaVipAttributeRequest) SetName(v string) *ModifyHaVipAttributeRequest {
	s.Name = &v
	return s
}

func (s *ModifyHaVipAttributeRequest) SetOwnerAccount(v string) *ModifyHaVipAttributeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyHaVipAttributeRequest) SetOwnerId(v int64) *ModifyHaVipAttributeRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyHaVipAttributeRequest) SetRegionId(v string) *ModifyHaVipAttributeRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyHaVipAttributeRequest) SetResourceOwnerAccount(v string) *ModifyHaVipAttributeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyHaVipAttributeRequest) SetResourceOwnerId(v int64) *ModifyHaVipAttributeRequest {
	s.ResourceOwnerId = &v
	return s
}

type ModifyHaVipAttributeResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyHaVipAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyHaVipAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyHaVipAttributeResponseBody) SetRequestId(v string) *ModifyHaVipAttributeResponseBody {
	s.RequestId = &v
	return s
}

type ModifyHaVipAttributeResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyHaVipAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyHaVipAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyHaVipAttributeResponse) GoString() string {
	return s.String()
}

func (s *ModifyHaVipAttributeResponse) SetHeaders(v map[string]*string) *ModifyHaVipAttributeResponse {
	s.Headers = v
	return s
}

func (s *ModifyHaVipAttributeResponse) SetStatusCode(v int32) *ModifyHaVipAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyHaVipAttributeResponse) SetBody(v *ModifyHaVipAttributeResponseBody) *ModifyHaVipAttributeResponse {
	s.Body = v
	return s
}

type ModifyIPv6TranslatorAclAttributeRequest struct {
	// The ID of the ACL that you want to modify.
	AclId *string `json:"AclId,omitempty" xml:"AclId,omitempty"`
	// The name of the ACL.
	AclName *string `json:"AclName,omitempty" xml:"AclName,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters.
	ClientToken  *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region of the IPv6 Translation Service instance. You can call the DescribeRegions operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ModifyIPv6TranslatorAclAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyIPv6TranslatorAclAttributeRequest) GoString() string {
	return s.String()
}

func (s *ModifyIPv6TranslatorAclAttributeRequest) SetAclId(v string) *ModifyIPv6TranslatorAclAttributeRequest {
	s.AclId = &v
	return s
}

func (s *ModifyIPv6TranslatorAclAttributeRequest) SetAclName(v string) *ModifyIPv6TranslatorAclAttributeRequest {
	s.AclName = &v
	return s
}

func (s *ModifyIPv6TranslatorAclAttributeRequest) SetClientToken(v string) *ModifyIPv6TranslatorAclAttributeRequest {
	s.ClientToken = &v
	return s
}

func (s *ModifyIPv6TranslatorAclAttributeRequest) SetOwnerAccount(v string) *ModifyIPv6TranslatorAclAttributeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyIPv6TranslatorAclAttributeRequest) SetOwnerId(v int64) *ModifyIPv6TranslatorAclAttributeRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyIPv6TranslatorAclAttributeRequest) SetRegionId(v string) *ModifyIPv6TranslatorAclAttributeRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyIPv6TranslatorAclAttributeRequest) SetResourceOwnerAccount(v string) *ModifyIPv6TranslatorAclAttributeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyIPv6TranslatorAclAttributeRequest) SetResourceOwnerId(v int64) *ModifyIPv6TranslatorAclAttributeRequest {
	s.ResourceOwnerId = &v
	return s
}

type ModifyIPv6TranslatorAclAttributeResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyIPv6TranslatorAclAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyIPv6TranslatorAclAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyIPv6TranslatorAclAttributeResponseBody) SetRequestId(v string) *ModifyIPv6TranslatorAclAttributeResponseBody {
	s.RequestId = &v
	return s
}

type ModifyIPv6TranslatorAclAttributeResponse struct {
	Headers    map[string]*string                            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyIPv6TranslatorAclAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyIPv6TranslatorAclAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyIPv6TranslatorAclAttributeResponse) GoString() string {
	return s.String()
}

func (s *ModifyIPv6TranslatorAclAttributeResponse) SetHeaders(v map[string]*string) *ModifyIPv6TranslatorAclAttributeResponse {
	s.Headers = v
	return s
}

func (s *ModifyIPv6TranslatorAclAttributeResponse) SetStatusCode(v int32) *ModifyIPv6TranslatorAclAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyIPv6TranslatorAclAttributeResponse) SetBody(v *ModifyIPv6TranslatorAclAttributeResponseBody) *ModifyIPv6TranslatorAclAttributeResponse {
	s.Body = v
	return s
}

type ModifyIPv6TranslatorAclListEntryRequest struct {
	// The remarks of the ACL rule.
	//
	// It must be 2 to 100 characters in length, and can contain digits, underscores (\_), and hyphens (-). It must start with a letter.
	AclEntryComment *string `json:"AclEntryComment,omitempty" xml:"AclEntryComment,omitempty"`
	// The ID of the ACL rule to which the IP entry belongs.
	AclEntryId *string `json:"AclEntryId,omitempty" xml:"AclEntryId,omitempty"`
	// The ID of the ACL to which the IP entry belongs.
	AclId        *string `json:"AclId,omitempty" xml:"AclId,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region of the ACL.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ModifyIPv6TranslatorAclListEntryRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyIPv6TranslatorAclListEntryRequest) GoString() string {
	return s.String()
}

func (s *ModifyIPv6TranslatorAclListEntryRequest) SetAclEntryComment(v string) *ModifyIPv6TranslatorAclListEntryRequest {
	s.AclEntryComment = &v
	return s
}

func (s *ModifyIPv6TranslatorAclListEntryRequest) SetAclEntryId(v string) *ModifyIPv6TranslatorAclListEntryRequest {
	s.AclEntryId = &v
	return s
}

func (s *ModifyIPv6TranslatorAclListEntryRequest) SetAclId(v string) *ModifyIPv6TranslatorAclListEntryRequest {
	s.AclId = &v
	return s
}

func (s *ModifyIPv6TranslatorAclListEntryRequest) SetOwnerAccount(v string) *ModifyIPv6TranslatorAclListEntryRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyIPv6TranslatorAclListEntryRequest) SetOwnerId(v int64) *ModifyIPv6TranslatorAclListEntryRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyIPv6TranslatorAclListEntryRequest) SetRegionId(v string) *ModifyIPv6TranslatorAclListEntryRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyIPv6TranslatorAclListEntryRequest) SetResourceOwnerAccount(v string) *ModifyIPv6TranslatorAclListEntryRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyIPv6TranslatorAclListEntryRequest) SetResourceOwnerId(v int64) *ModifyIPv6TranslatorAclListEntryRequest {
	s.ResourceOwnerId = &v
	return s
}

type ModifyIPv6TranslatorAclListEntryResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyIPv6TranslatorAclListEntryResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyIPv6TranslatorAclListEntryResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyIPv6TranslatorAclListEntryResponseBody) SetRequestId(v string) *ModifyIPv6TranslatorAclListEntryResponseBody {
	s.RequestId = &v
	return s
}

type ModifyIPv6TranslatorAclListEntryResponse struct {
	Headers    map[string]*string                            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyIPv6TranslatorAclListEntryResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyIPv6TranslatorAclListEntryResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyIPv6TranslatorAclListEntryResponse) GoString() string {
	return s.String()
}

func (s *ModifyIPv6TranslatorAclListEntryResponse) SetHeaders(v map[string]*string) *ModifyIPv6TranslatorAclListEntryResponse {
	s.Headers = v
	return s
}

func (s *ModifyIPv6TranslatorAclListEntryResponse) SetStatusCode(v int32) *ModifyIPv6TranslatorAclListEntryResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyIPv6TranslatorAclListEntryResponse) SetBody(v *ModifyIPv6TranslatorAclListEntryResponseBody) *ModifyIPv6TranslatorAclListEntryResponse {
	s.Body = v
	return s
}

type ModifyIPv6TranslatorAttributeRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The description of IPv6 Translation Service. This parameter is empty by default. It must be 2 to 100 characters in length, and can contain letters, digits, periods (.), underscores (\_), and hyphens (-). It cannot start with http:// or [https://](https://。).
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the IPv6 Translation Service instance.
	Ipv6TranslatorId *string `json:"Ipv6TranslatorId,omitempty" xml:"Ipv6TranslatorId,omitempty"`
	// The name of the IPv6 Translation Service instance. The default name is the instance ID. It must be 2 to 100 characters in length, and can contain letters, digits, periods (.), underscores (\_), and hyphens (-). It cannot start with http:// or [https://](https://。).
	Name         *string `json:"Name,omitempty" xml:"Name,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region of the IPv6 Translation Service instance. You can call the **DescribeRegions** operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ModifyIPv6TranslatorAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyIPv6TranslatorAttributeRequest) GoString() string {
	return s.String()
}

func (s *ModifyIPv6TranslatorAttributeRequest) SetClientToken(v string) *ModifyIPv6TranslatorAttributeRequest {
	s.ClientToken = &v
	return s
}

func (s *ModifyIPv6TranslatorAttributeRequest) SetDescription(v string) *ModifyIPv6TranslatorAttributeRequest {
	s.Description = &v
	return s
}

func (s *ModifyIPv6TranslatorAttributeRequest) SetIpv6TranslatorId(v string) *ModifyIPv6TranslatorAttributeRequest {
	s.Ipv6TranslatorId = &v
	return s
}

func (s *ModifyIPv6TranslatorAttributeRequest) SetName(v string) *ModifyIPv6TranslatorAttributeRequest {
	s.Name = &v
	return s
}

func (s *ModifyIPv6TranslatorAttributeRequest) SetOwnerAccount(v string) *ModifyIPv6TranslatorAttributeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyIPv6TranslatorAttributeRequest) SetOwnerId(v int64) *ModifyIPv6TranslatorAttributeRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyIPv6TranslatorAttributeRequest) SetRegionId(v string) *ModifyIPv6TranslatorAttributeRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyIPv6TranslatorAttributeRequest) SetResourceOwnerAccount(v string) *ModifyIPv6TranslatorAttributeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyIPv6TranslatorAttributeRequest) SetResourceOwnerId(v int64) *ModifyIPv6TranslatorAttributeRequest {
	s.ResourceOwnerId = &v
	return s
}

type ModifyIPv6TranslatorAttributeResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyIPv6TranslatorAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyIPv6TranslatorAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyIPv6TranslatorAttributeResponseBody) SetRequestId(v string) *ModifyIPv6TranslatorAttributeResponseBody {
	s.RequestId = &v
	return s
}

type ModifyIPv6TranslatorAttributeResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyIPv6TranslatorAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyIPv6TranslatorAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyIPv6TranslatorAttributeResponse) GoString() string {
	return s.String()
}

func (s *ModifyIPv6TranslatorAttributeResponse) SetHeaders(v map[string]*string) *ModifyIPv6TranslatorAttributeResponse {
	s.Headers = v
	return s
}

func (s *ModifyIPv6TranslatorAttributeResponse) SetStatusCode(v int32) *ModifyIPv6TranslatorAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyIPv6TranslatorAttributeResponse) SetBody(v *ModifyIPv6TranslatorAttributeResponseBody) *ModifyIPv6TranslatorAttributeResponse {
	s.Body = v
	return s
}

type ModifyIPv6TranslatorBandwidthRequest struct {
	// Specifies whether to enable auto-payment for the instance. Valid values:
	//
	// *   **true**
	// *   **false** (default)
	AutoPay *bool `json:"AutoPay,omitempty" xml:"AutoPay,omitempty"`
	// The maximum bandwidth of the IPv6 Translation Service instance. Valid values: **1** to **200**. Unit: Mbit/s.
	Bandwidth *int32 `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the IPv6 Translation Service instance.
	Ipv6TranslatorId *string `json:"Ipv6TranslatorId,omitempty" xml:"Ipv6TranslatorId,omitempty"`
	OwnerAccount     *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId          *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region of the IPv6 Translation Service instance. You can call the **DescribeRegions** operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ModifyIPv6TranslatorBandwidthRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyIPv6TranslatorBandwidthRequest) GoString() string {
	return s.String()
}

func (s *ModifyIPv6TranslatorBandwidthRequest) SetAutoPay(v bool) *ModifyIPv6TranslatorBandwidthRequest {
	s.AutoPay = &v
	return s
}

func (s *ModifyIPv6TranslatorBandwidthRequest) SetBandwidth(v int32) *ModifyIPv6TranslatorBandwidthRequest {
	s.Bandwidth = &v
	return s
}

func (s *ModifyIPv6TranslatorBandwidthRequest) SetClientToken(v string) *ModifyIPv6TranslatorBandwidthRequest {
	s.ClientToken = &v
	return s
}

func (s *ModifyIPv6TranslatorBandwidthRequest) SetIpv6TranslatorId(v string) *ModifyIPv6TranslatorBandwidthRequest {
	s.Ipv6TranslatorId = &v
	return s
}

func (s *ModifyIPv6TranslatorBandwidthRequest) SetOwnerAccount(v string) *ModifyIPv6TranslatorBandwidthRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyIPv6TranslatorBandwidthRequest) SetOwnerId(v int64) *ModifyIPv6TranslatorBandwidthRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyIPv6TranslatorBandwidthRequest) SetRegionId(v string) *ModifyIPv6TranslatorBandwidthRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyIPv6TranslatorBandwidthRequest) SetResourceOwnerAccount(v string) *ModifyIPv6TranslatorBandwidthRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyIPv6TranslatorBandwidthRequest) SetResourceOwnerId(v int64) *ModifyIPv6TranslatorBandwidthRequest {
	s.ResourceOwnerId = &v
	return s
}

type ModifyIPv6TranslatorBandwidthResponseBody struct {
	// The order ID.
	OrderId *string `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyIPv6TranslatorBandwidthResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyIPv6TranslatorBandwidthResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyIPv6TranslatorBandwidthResponseBody) SetOrderId(v string) *ModifyIPv6TranslatorBandwidthResponseBody {
	s.OrderId = &v
	return s
}

func (s *ModifyIPv6TranslatorBandwidthResponseBody) SetRequestId(v string) *ModifyIPv6TranslatorBandwidthResponseBody {
	s.RequestId = &v
	return s
}

type ModifyIPv6TranslatorBandwidthResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyIPv6TranslatorBandwidthResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyIPv6TranslatorBandwidthResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyIPv6TranslatorBandwidthResponse) GoString() string {
	return s.String()
}

func (s *ModifyIPv6TranslatorBandwidthResponse) SetHeaders(v map[string]*string) *ModifyIPv6TranslatorBandwidthResponse {
	s.Headers = v
	return s
}

func (s *ModifyIPv6TranslatorBandwidthResponse) SetStatusCode(v int32) *ModifyIPv6TranslatorBandwidthResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyIPv6TranslatorBandwidthResponse) SetBody(v *ModifyIPv6TranslatorBandwidthResponseBody) *ModifyIPv6TranslatorBandwidthResponse {
	s.Body = v
	return s
}

type ModifyIPv6TranslatorEntryRequest struct {
	// The ID of the associated ACL.
	AclId *string `json:"AclId,omitempty" xml:"AclId,omitempty"`
	// Specifies whether to enable access control lists (ACLs). Valid values:
	//
	// *   **on**
	// *   **off**
	AclStatus *string `json:"AclStatus,omitempty" xml:"AclStatus,omitempty"`
	// The ACL type. Valid values:
	//
	// *   **white**: a whitelist. IPv6 addresses in the ACL are allowed to access backend services.
	// *   **black**: a blacklist. IPv6 addresses in the ACL are not allowed to access backend services.
	AclType *string `json:"AclType,omitempty" xml:"AclType,omitempty"`
	// The port that is used by the IPv6 address allocated to the IPv6 Translation Service instance.
	AllocateIpv6Port *int32 `json:"AllocateIpv6Port,omitempty" xml:"AllocateIpv6Port,omitempty"`
	// The public IPv4 address that needs to provide IPv6 services.
	BackendIpv4Addr *string `json:"BackendIpv4Addr,omitempty" xml:"BackendIpv4Addr,omitempty"`
	// The port of the public IPv4 address that needs to provide IPv6 services.
	BackendIpv4Port *int32 `json:"BackendIpv4Port,omitempty" xml:"BackendIpv4Port,omitempty"`
	// The maximum bandwidth specified in the IPv6 mapping entry. Unit: Mbit/s. Valid values:
	//
	// *   **-1** (default): does not limit the maximum bandwidth specified in the IPv6 mapping entry.
	// *   **1** to **200**: changes the maximum bandwidth specified in the IPv6 mapping entry.
	//
	// > The sum of maximum bandwidth values specified in all IPv6 entries cannot exceed the maximum bandwidth supported by the instance.
	EntryBandwidth *int32 `json:"EntryBandwidth,omitempty" xml:"EntryBandwidth,omitempty"`
	// The description of the IPv6 mapping entry. It must be 2 to 100 characters in length, and can contain digits, periods (.), underscores (\_), and hyphens (-). It must start with a letter. It cannot start with http:// or [https://](https://。).
	EntryDescription *string `json:"EntryDescription,omitempty" xml:"EntryDescription,omitempty"`
	// The name of the IPv6 mapping entry. It must be 2 to 100 characters in length, and can contain digits, periods (.), underscores (\_), and hyphens (-). It must start with a letter. It cannot start with http:// or [https://](https://。).
	EntryName *string `json:"EntryName,omitempty" xml:"EntryName,omitempty"`
	// The ID of the IPv6 mapping entry.
	Ipv6TranslatorEntryId *string `json:"Ipv6TranslatorEntryId,omitempty" xml:"Ipv6TranslatorEntryId,omitempty"`
	OwnerAccount          *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId               *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region of the IPv6 Translation Service instance. You can call the DescribeRegions operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The protocol. Valid values:
	//
	// *   **tcp**
	// *   **udp**
	TransProtocol *string `json:"TransProtocol,omitempty" xml:"TransProtocol,omitempty"`
}

func (s ModifyIPv6TranslatorEntryRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyIPv6TranslatorEntryRequest) GoString() string {
	return s.String()
}

func (s *ModifyIPv6TranslatorEntryRequest) SetAclId(v string) *ModifyIPv6TranslatorEntryRequest {
	s.AclId = &v
	return s
}

func (s *ModifyIPv6TranslatorEntryRequest) SetAclStatus(v string) *ModifyIPv6TranslatorEntryRequest {
	s.AclStatus = &v
	return s
}

func (s *ModifyIPv6TranslatorEntryRequest) SetAclType(v string) *ModifyIPv6TranslatorEntryRequest {
	s.AclType = &v
	return s
}

func (s *ModifyIPv6TranslatorEntryRequest) SetAllocateIpv6Port(v int32) *ModifyIPv6TranslatorEntryRequest {
	s.AllocateIpv6Port = &v
	return s
}

func (s *ModifyIPv6TranslatorEntryRequest) SetBackendIpv4Addr(v string) *ModifyIPv6TranslatorEntryRequest {
	s.BackendIpv4Addr = &v
	return s
}

func (s *ModifyIPv6TranslatorEntryRequest) SetBackendIpv4Port(v int32) *ModifyIPv6TranslatorEntryRequest {
	s.BackendIpv4Port = &v
	return s
}

func (s *ModifyIPv6TranslatorEntryRequest) SetEntryBandwidth(v int32) *ModifyIPv6TranslatorEntryRequest {
	s.EntryBandwidth = &v
	return s
}

func (s *ModifyIPv6TranslatorEntryRequest) SetEntryDescription(v string) *ModifyIPv6TranslatorEntryRequest {
	s.EntryDescription = &v
	return s
}

func (s *ModifyIPv6TranslatorEntryRequest) SetEntryName(v string) *ModifyIPv6TranslatorEntryRequest {
	s.EntryName = &v
	return s
}

func (s *ModifyIPv6TranslatorEntryRequest) SetIpv6TranslatorEntryId(v string) *ModifyIPv6TranslatorEntryRequest {
	s.Ipv6TranslatorEntryId = &v
	return s
}

func (s *ModifyIPv6TranslatorEntryRequest) SetOwnerAccount(v string) *ModifyIPv6TranslatorEntryRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyIPv6TranslatorEntryRequest) SetOwnerId(v int64) *ModifyIPv6TranslatorEntryRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyIPv6TranslatorEntryRequest) SetRegionId(v string) *ModifyIPv6TranslatorEntryRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyIPv6TranslatorEntryRequest) SetResourceOwnerAccount(v string) *ModifyIPv6TranslatorEntryRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyIPv6TranslatorEntryRequest) SetResourceOwnerId(v int64) *ModifyIPv6TranslatorEntryRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ModifyIPv6TranslatorEntryRequest) SetTransProtocol(v string) *ModifyIPv6TranslatorEntryRequest {
	s.TransProtocol = &v
	return s
}

type ModifyIPv6TranslatorEntryResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyIPv6TranslatorEntryResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyIPv6TranslatorEntryResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyIPv6TranslatorEntryResponseBody) SetRequestId(v string) *ModifyIPv6TranslatorEntryResponseBody {
	s.RequestId = &v
	return s
}

type ModifyIPv6TranslatorEntryResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyIPv6TranslatorEntryResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyIPv6TranslatorEntryResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyIPv6TranslatorEntryResponse) GoString() string {
	return s.String()
}

func (s *ModifyIPv6TranslatorEntryResponse) SetHeaders(v map[string]*string) *ModifyIPv6TranslatorEntryResponse {
	s.Headers = v
	return s
}

func (s *ModifyIPv6TranslatorEntryResponse) SetStatusCode(v int32) *ModifyIPv6TranslatorEntryResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyIPv6TranslatorEntryResponse) SetBody(v *ModifyIPv6TranslatorEntryResponseBody) *ModifyIPv6TranslatorEntryResponse {
	s.Body = v
	return s
}

type ModifyIpv6AddressAttributeRequest struct {
	// The description of the IPv6 address.
	//
	// It must be 2 to 256 characters in length, and can contain letters, digits, periods (.), underscores (\_), and hyphens (-). It must start with a letter. The name must start with a letter but cannot start with `http://` or `https://`.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the IPv6 address.
	Ipv6AddressId *string `json:"Ipv6AddressId,omitempty" xml:"Ipv6AddressId,omitempty"`
	// The name of the IPv6 address.
	//
	// The name must be 2 to 128 characters in length, and can contain letters, digits, periods (.), underscores (\_), and hyphens (-). The name must start with a letter. The name must start with a letter but cannot start with `http://` or `https://`.
	Name         *string `json:"Name,omitempty" xml:"Name,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the IPv6 address. You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ModifyIpv6AddressAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyIpv6AddressAttributeRequest) GoString() string {
	return s.String()
}

func (s *ModifyIpv6AddressAttributeRequest) SetDescription(v string) *ModifyIpv6AddressAttributeRequest {
	s.Description = &v
	return s
}

func (s *ModifyIpv6AddressAttributeRequest) SetIpv6AddressId(v string) *ModifyIpv6AddressAttributeRequest {
	s.Ipv6AddressId = &v
	return s
}

func (s *ModifyIpv6AddressAttributeRequest) SetName(v string) *ModifyIpv6AddressAttributeRequest {
	s.Name = &v
	return s
}

func (s *ModifyIpv6AddressAttributeRequest) SetOwnerAccount(v string) *ModifyIpv6AddressAttributeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyIpv6AddressAttributeRequest) SetOwnerId(v int64) *ModifyIpv6AddressAttributeRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyIpv6AddressAttributeRequest) SetRegionId(v string) *ModifyIpv6AddressAttributeRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyIpv6AddressAttributeRequest) SetResourceOwnerAccount(v string) *ModifyIpv6AddressAttributeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyIpv6AddressAttributeRequest) SetResourceOwnerId(v int64) *ModifyIpv6AddressAttributeRequest {
	s.ResourceOwnerId = &v
	return s
}

type ModifyIpv6AddressAttributeResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyIpv6AddressAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyIpv6AddressAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyIpv6AddressAttributeResponseBody) SetRequestId(v string) *ModifyIpv6AddressAttributeResponseBody {
	s.RequestId = &v
	return s
}

type ModifyIpv6AddressAttributeResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyIpv6AddressAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyIpv6AddressAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyIpv6AddressAttributeResponse) GoString() string {
	return s.String()
}

func (s *ModifyIpv6AddressAttributeResponse) SetHeaders(v map[string]*string) *ModifyIpv6AddressAttributeResponse {
	s.Headers = v
	return s
}

func (s *ModifyIpv6AddressAttributeResponse) SetStatusCode(v int32) *ModifyIpv6AddressAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyIpv6AddressAttributeResponse) SetBody(v *ModifyIpv6AddressAttributeResponseBody) *ModifyIpv6AddressAttributeResponse {
	s.Body = v
	return s
}

type ModifyIpv6GatewayAttributeRequest struct {
	// The description of the IPv6 gateway.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the IPv6 gateway that you want to modify.
	Ipv6GatewayId *string `json:"Ipv6GatewayId,omitempty" xml:"Ipv6GatewayId,omitempty"`
	// The name of the IPv6 gateway.
	//
	// It must be 2 to 256 characters in length, and can contain letters, digits, periods (.), underscores (\_), and hyphens (-). It must start with a letter. The name must start with a letter but cannot start with `http://` or `https://`.
	Name         *string `json:"Name,omitempty" xml:"Name,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region where the IPv6 gateway is deployed. You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ModifyIpv6GatewayAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyIpv6GatewayAttributeRequest) GoString() string {
	return s.String()
}

func (s *ModifyIpv6GatewayAttributeRequest) SetDescription(v string) *ModifyIpv6GatewayAttributeRequest {
	s.Description = &v
	return s
}

func (s *ModifyIpv6GatewayAttributeRequest) SetIpv6GatewayId(v string) *ModifyIpv6GatewayAttributeRequest {
	s.Ipv6GatewayId = &v
	return s
}

func (s *ModifyIpv6GatewayAttributeRequest) SetName(v string) *ModifyIpv6GatewayAttributeRequest {
	s.Name = &v
	return s
}

func (s *ModifyIpv6GatewayAttributeRequest) SetOwnerAccount(v string) *ModifyIpv6GatewayAttributeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyIpv6GatewayAttributeRequest) SetOwnerId(v int64) *ModifyIpv6GatewayAttributeRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyIpv6GatewayAttributeRequest) SetRegionId(v string) *ModifyIpv6GatewayAttributeRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyIpv6GatewayAttributeRequest) SetResourceOwnerAccount(v string) *ModifyIpv6GatewayAttributeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyIpv6GatewayAttributeRequest) SetResourceOwnerId(v int64) *ModifyIpv6GatewayAttributeRequest {
	s.ResourceOwnerId = &v
	return s
}

type ModifyIpv6GatewayAttributeResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyIpv6GatewayAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyIpv6GatewayAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyIpv6GatewayAttributeResponseBody) SetRequestId(v string) *ModifyIpv6GatewayAttributeResponseBody {
	s.RequestId = &v
	return s
}

type ModifyIpv6GatewayAttributeResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyIpv6GatewayAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyIpv6GatewayAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyIpv6GatewayAttributeResponse) GoString() string {
	return s.String()
}

func (s *ModifyIpv6GatewayAttributeResponse) SetHeaders(v map[string]*string) *ModifyIpv6GatewayAttributeResponse {
	s.Headers = v
	return s
}

func (s *ModifyIpv6GatewayAttributeResponse) SetStatusCode(v int32) *ModifyIpv6GatewayAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyIpv6GatewayAttributeResponse) SetBody(v *ModifyIpv6GatewayAttributeResponseBody) *ModifyIpv6GatewayAttributeResponse {
	s.Body = v
	return s
}

type ModifyIpv6GatewaySpecRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that the value is unique among different requests. The client token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the IPv6 gateway.
	Ipv6GatewayId *string `json:"Ipv6GatewayId,omitempty" xml:"Ipv6GatewayId,omitempty"`
	OwnerAccount  *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region where the IPv6 gateway is deployed. You can call the [DescribeRegions](~~36063~~) operation to query the available regions.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// This parameter is no longer used because no specifications options are available for the IPv6 gateway.
	Spec *string `json:"Spec,omitempty" xml:"Spec,omitempty"`
}

func (s ModifyIpv6GatewaySpecRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyIpv6GatewaySpecRequest) GoString() string {
	return s.String()
}

func (s *ModifyIpv6GatewaySpecRequest) SetClientToken(v string) *ModifyIpv6GatewaySpecRequest {
	s.ClientToken = &v
	return s
}

func (s *ModifyIpv6GatewaySpecRequest) SetIpv6GatewayId(v string) *ModifyIpv6GatewaySpecRequest {
	s.Ipv6GatewayId = &v
	return s
}

func (s *ModifyIpv6GatewaySpecRequest) SetOwnerAccount(v string) *ModifyIpv6GatewaySpecRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyIpv6GatewaySpecRequest) SetOwnerId(v int64) *ModifyIpv6GatewaySpecRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyIpv6GatewaySpecRequest) SetRegionId(v string) *ModifyIpv6GatewaySpecRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyIpv6GatewaySpecRequest) SetResourceOwnerAccount(v string) *ModifyIpv6GatewaySpecRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyIpv6GatewaySpecRequest) SetResourceOwnerId(v int64) *ModifyIpv6GatewaySpecRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ModifyIpv6GatewaySpecRequest) SetSpec(v string) *ModifyIpv6GatewaySpecRequest {
	s.Spec = &v
	return s
}

type ModifyIpv6GatewaySpecResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyIpv6GatewaySpecResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyIpv6GatewaySpecResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyIpv6GatewaySpecResponseBody) SetRequestId(v string) *ModifyIpv6GatewaySpecResponseBody {
	s.RequestId = &v
	return s
}

type ModifyIpv6GatewaySpecResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyIpv6GatewaySpecResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyIpv6GatewaySpecResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyIpv6GatewaySpecResponse) GoString() string {
	return s.String()
}

func (s *ModifyIpv6GatewaySpecResponse) SetHeaders(v map[string]*string) *ModifyIpv6GatewaySpecResponse {
	s.Headers = v
	return s
}

func (s *ModifyIpv6GatewaySpecResponse) SetStatusCode(v int32) *ModifyIpv6GatewaySpecResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyIpv6GatewaySpecResponse) SetBody(v *ModifyIpv6GatewaySpecResponseBody) *ModifyIpv6GatewaySpecResponse {
	s.Body = v
	return s
}

type ModifyIpv6InternetBandwidthRequest struct {
	// The Internet bandwidth for the IPv6 CIDR block. Valid values: **1** to **5000**. Unit: Mbit/s.
	Bandwidth *int64 `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must ensure that the value is unique among all requests. ClientToken can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the IPv6 address.
	//
	// >  You must set one of the **Ipv6AddressId** and **Ipv6InternetBandwidthId** parameters.
	Ipv6AddressId *string `json:"Ipv6AddressId,omitempty" xml:"Ipv6AddressId,omitempty"`
	// The ID of the Internet bandwidth that you purchase for the IPv6 CIDR block.
	//
	// >  You must set one of the **Ipv6AddressId** and **Ipv6InternetBandwidthId** parameters.
	Ipv6InternetBandwidthId *string `json:"Ipv6InternetBandwidthId,omitempty" xml:"Ipv6InternetBandwidthId,omitempty"`
	OwnerAccount            *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId                 *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region where the IPv6 gateway is deployed. You can call the [DescribeRegions](~~36063~~) operation to obtain the region ID.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ModifyIpv6InternetBandwidthRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyIpv6InternetBandwidthRequest) GoString() string {
	return s.String()
}

func (s *ModifyIpv6InternetBandwidthRequest) SetBandwidth(v int64) *ModifyIpv6InternetBandwidthRequest {
	s.Bandwidth = &v
	return s
}

func (s *ModifyIpv6InternetBandwidthRequest) SetClientToken(v string) *ModifyIpv6InternetBandwidthRequest {
	s.ClientToken = &v
	return s
}

func (s *ModifyIpv6InternetBandwidthRequest) SetIpv6AddressId(v string) *ModifyIpv6InternetBandwidthRequest {
	s.Ipv6AddressId = &v
	return s
}

func (s *ModifyIpv6InternetBandwidthRequest) SetIpv6InternetBandwidthId(v string) *ModifyIpv6InternetBandwidthRequest {
	s.Ipv6InternetBandwidthId = &v
	return s
}

func (s *ModifyIpv6InternetBandwidthRequest) SetOwnerAccount(v string) *ModifyIpv6InternetBandwidthRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyIpv6InternetBandwidthRequest) SetOwnerId(v int64) *ModifyIpv6InternetBandwidthRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyIpv6InternetBandwidthRequest) SetRegionId(v string) *ModifyIpv6InternetBandwidthRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyIpv6InternetBandwidthRequest) SetResourceOwnerAccount(v string) *ModifyIpv6InternetBandwidthRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyIpv6InternetBandwidthRequest) SetResourceOwnerId(v int64) *ModifyIpv6InternetBandwidthRequest {
	s.ResourceOwnerId = &v
	return s
}

type ModifyIpv6InternetBandwidthResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyIpv6InternetBandwidthResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyIpv6InternetBandwidthResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyIpv6InternetBandwidthResponseBody) SetRequestId(v string) *ModifyIpv6InternetBandwidthResponseBody {
	s.RequestId = &v
	return s
}

type ModifyIpv6InternetBandwidthResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyIpv6InternetBandwidthResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyIpv6InternetBandwidthResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyIpv6InternetBandwidthResponse) GoString() string {
	return s.String()
}

func (s *ModifyIpv6InternetBandwidthResponse) SetHeaders(v map[string]*string) *ModifyIpv6InternetBandwidthResponse {
	s.Headers = v
	return s
}

func (s *ModifyIpv6InternetBandwidthResponse) SetStatusCode(v int32) *ModifyIpv6InternetBandwidthResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyIpv6InternetBandwidthResponse) SetBody(v *ModifyIpv6InternetBandwidthResponseBody) *ModifyIpv6InternetBandwidthResponse {
	s.Body = v
	return s
}

type ModifyNatGatewayAttributeRequest struct {
	// The description of the NAT gateway.
	//
	// The description must be 1 to 128 characters in length, and cannot start with `http://` or `https://`.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The mode in which the NAT gateway is associated with an elastic IP address (EIP). You can leave this parameter empty. If you want to specify a value for this parameter, set the value to **NAT**, which indicates that the NAT gateway is associated with the EIP in NAT mode.
	//
	// >
	// *   If the EipBindMode parameter is set to MULTI_BINDED when the NAT gateway is created, you can change the value of this parameter from **MULTI_BINDED** to **NAT**. If the EipBindMode parameter is set to NAT when the NAT gateway is created, you cannot change the value of this parameter from **NAT** to **MULTI_BINDED**. For more information about **MULTI_BINDED**, see [CreateNatGateway](~~120219~~).
	// *   When the mode in which the NAT gateway is associated with an EIP is being changed, a transient connection that lasts a few seconds may occur. If the number of EIPs with which the NAT gateway is associated increases, the transient connection lasts longer. You can change the mode only for a NAT gateway that is associated with up to five EIPs. We recommend that you change the mode during off-peak hours.
	// *   After the mode is changed to **NAT**, the Internet NAT gateway is compatible with the IPv4 gateway. However, if you associate an EIP with the NAT gateway, the EIP occupies one private IP address on the vSwitch of the NAT gateway. Make sure that the vSwitch has sufficient private IP addresses. Otherwise, the EIP fails to be associated with the NAT gateway.
	EipBindMode *string `json:"EipBindMode,omitempty" xml:"EipBindMode,omitempty"`
	// Specifies whether to enable the Internet control message protocol (ICMP) non-retrieval feature. Valid values:
	//
	// *   **false**: disables the ICMP non-retrieval feature. This is the default value.
	// *   **true**: enables the ICMP non-retrieval feature.
	IcmpReplyEnabled *bool `json:"IcmpReplyEnabled,omitempty" xml:"IcmpReplyEnabled,omitempty"`
	// The name of the NAT gateway.
	//
	// The name must be 1 to 128 characters in length, and cannot start with `http://` or `https://`.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the NAT gateway.
	NatGatewayId *string `json:"NatGatewayId,omitempty" xml:"NatGatewayId,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the NAT gateway.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ModifyNatGatewayAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyNatGatewayAttributeRequest) GoString() string {
	return s.String()
}

func (s *ModifyNatGatewayAttributeRequest) SetDescription(v string) *ModifyNatGatewayAttributeRequest {
	s.Description = &v
	return s
}

func (s *ModifyNatGatewayAttributeRequest) SetEipBindMode(v string) *ModifyNatGatewayAttributeRequest {
	s.EipBindMode = &v
	return s
}

func (s *ModifyNatGatewayAttributeRequest) SetIcmpReplyEnabled(v bool) *ModifyNatGatewayAttributeRequest {
	s.IcmpReplyEnabled = &v
	return s
}

func (s *ModifyNatGatewayAttributeRequest) SetName(v string) *ModifyNatGatewayAttributeRequest {
	s.Name = &v
	return s
}

func (s *ModifyNatGatewayAttributeRequest) SetNatGatewayId(v string) *ModifyNatGatewayAttributeRequest {
	s.NatGatewayId = &v
	return s
}

func (s *ModifyNatGatewayAttributeRequest) SetOwnerAccount(v string) *ModifyNatGatewayAttributeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyNatGatewayAttributeRequest) SetOwnerId(v int64) *ModifyNatGatewayAttributeRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyNatGatewayAttributeRequest) SetRegionId(v string) *ModifyNatGatewayAttributeRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyNatGatewayAttributeRequest) SetResourceOwnerAccount(v string) *ModifyNatGatewayAttributeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyNatGatewayAttributeRequest) SetResourceOwnerId(v int64) *ModifyNatGatewayAttributeRequest {
	s.ResourceOwnerId = &v
	return s
}

type ModifyNatGatewayAttributeResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyNatGatewayAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyNatGatewayAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyNatGatewayAttributeResponseBody) SetRequestId(v string) *ModifyNatGatewayAttributeResponseBody {
	s.RequestId = &v
	return s
}

type ModifyNatGatewayAttributeResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyNatGatewayAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyNatGatewayAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyNatGatewayAttributeResponse) GoString() string {
	return s.String()
}

func (s *ModifyNatGatewayAttributeResponse) SetHeaders(v map[string]*string) *ModifyNatGatewayAttributeResponse {
	s.Headers = v
	return s
}

func (s *ModifyNatGatewayAttributeResponse) SetStatusCode(v int32) *ModifyNatGatewayAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyNatGatewayAttributeResponse) SetBody(v *ModifyNatGatewayAttributeResponseBody) *ModifyNatGatewayAttributeResponse {
	s.Body = v
	return s
}

type ModifyNatGatewaySpecRequest struct {
	// Specifies whether to automatically complete the payment.
	//
	// *   **true**: enables automatic payment. Payments are automatically completed.
	// *   **false** (default): disables automatic payment. If you select this option, you must go to the Order Center to complete the payment after an order is generated.
	AutoPay *bool `json:"AutoPay,omitempty" xml:"AutoPay,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can contain only ASCII characters.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the Internet NAT gateway that you want to upgrade.
	NatGatewayId *string `json:"NatGatewayId,omitempty" xml:"NatGatewayId,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region where the Internet NAT gateway is deployed.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The size of the Internet NAT gateway. Valid values:
	//
	// *   **Small**: small
	// *   **Middle**: medium
	// *   **Large**: large
	Spec *string `json:"Spec,omitempty" xml:"Spec,omitempty"`
}

func (s ModifyNatGatewaySpecRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyNatGatewaySpecRequest) GoString() string {
	return s.String()
}

func (s *ModifyNatGatewaySpecRequest) SetAutoPay(v bool) *ModifyNatGatewaySpecRequest {
	s.AutoPay = &v
	return s
}

func (s *ModifyNatGatewaySpecRequest) SetClientToken(v string) *ModifyNatGatewaySpecRequest {
	s.ClientToken = &v
	return s
}

func (s *ModifyNatGatewaySpecRequest) SetNatGatewayId(v string) *ModifyNatGatewaySpecRequest {
	s.NatGatewayId = &v
	return s
}

func (s *ModifyNatGatewaySpecRequest) SetOwnerAccount(v string) *ModifyNatGatewaySpecRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyNatGatewaySpecRequest) SetOwnerId(v int64) *ModifyNatGatewaySpecRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyNatGatewaySpecRequest) SetRegionId(v string) *ModifyNatGatewaySpecRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyNatGatewaySpecRequest) SetResourceOwnerAccount(v string) *ModifyNatGatewaySpecRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyNatGatewaySpecRequest) SetResourceOwnerId(v int64) *ModifyNatGatewaySpecRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ModifyNatGatewaySpecRequest) SetSpec(v string) *ModifyNatGatewaySpecRequest {
	s.Spec = &v
	return s
}

type ModifyNatGatewaySpecResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyNatGatewaySpecResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyNatGatewaySpecResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyNatGatewaySpecResponseBody) SetRequestId(v string) *ModifyNatGatewaySpecResponseBody {
	s.RequestId = &v
	return s
}

type ModifyNatGatewaySpecResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyNatGatewaySpecResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyNatGatewaySpecResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyNatGatewaySpecResponse) GoString() string {
	return s.String()
}

func (s *ModifyNatGatewaySpecResponse) SetHeaders(v map[string]*string) *ModifyNatGatewaySpecResponse {
	s.Headers = v
	return s
}

func (s *ModifyNatGatewaySpecResponse) SetStatusCode(v int32) *ModifyNatGatewaySpecResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyNatGatewaySpecResponse) SetBody(v *ModifyNatGatewaySpecResponseBody) *ModifyNatGatewaySpecResponse {
	s.Body = v
	return s
}

type ModifyNatIpAttributeRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether only to precheck this request. Valid values:
	//
	// *   **true**: sends the precheck request but does not modify the name or description of the NAT IP address. The system checks your AccessKey pair, the Resource Access Management (RAM) user permissions, and the required parameters. If the request fails the precheck, an error message is returned. If the request passes the precheck, the `DryRunOperation` error code is returned.
	// *   **false** (default): sends the request. If the request passes the precheck, a 2xx HTTP status code is returned and the name and description of the NAT IP address are modified.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The description of the NAT IP address that you want to modify.
	//
	// The description must be 2 to 256 characters in length. It must start with a letter but cannot start with `http://` or `https://`.
	NatIpDescription *string `json:"NatIpDescription,omitempty" xml:"NatIpDescription,omitempty"`
	// The ID of the NAT IP address that you want to modify.
	NatIpId *string `json:"NatIpId,omitempty" xml:"NatIpId,omitempty"`
	// The name of the NAT IP address that you want to modify.
	//
	// The name must be 2 to 128 characters in length, and can contain letters, digits, periods (.), underscores (\_), and hyphens (-). It must start with a letter. It cannot start with `http://` or `https://`.
	NatIpName    *string `json:"NatIpName,omitempty" xml:"NatIpName,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the NAT gateway to which the NAT IP address that you want to modify belongs.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ModifyNatIpAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyNatIpAttributeRequest) GoString() string {
	return s.String()
}

func (s *ModifyNatIpAttributeRequest) SetClientToken(v string) *ModifyNatIpAttributeRequest {
	s.ClientToken = &v
	return s
}

func (s *ModifyNatIpAttributeRequest) SetDryRun(v bool) *ModifyNatIpAttributeRequest {
	s.DryRun = &v
	return s
}

func (s *ModifyNatIpAttributeRequest) SetNatIpDescription(v string) *ModifyNatIpAttributeRequest {
	s.NatIpDescription = &v
	return s
}

func (s *ModifyNatIpAttributeRequest) SetNatIpId(v string) *ModifyNatIpAttributeRequest {
	s.NatIpId = &v
	return s
}

func (s *ModifyNatIpAttributeRequest) SetNatIpName(v string) *ModifyNatIpAttributeRequest {
	s.NatIpName = &v
	return s
}

func (s *ModifyNatIpAttributeRequest) SetOwnerAccount(v string) *ModifyNatIpAttributeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyNatIpAttributeRequest) SetOwnerId(v int64) *ModifyNatIpAttributeRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyNatIpAttributeRequest) SetRegionId(v string) *ModifyNatIpAttributeRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyNatIpAttributeRequest) SetResourceOwnerAccount(v string) *ModifyNatIpAttributeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyNatIpAttributeRequest) SetResourceOwnerId(v int64) *ModifyNatIpAttributeRequest {
	s.ResourceOwnerId = &v
	return s
}

type ModifyNatIpAttributeResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyNatIpAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyNatIpAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyNatIpAttributeResponseBody) SetRequestId(v string) *ModifyNatIpAttributeResponseBody {
	s.RequestId = &v
	return s
}

type ModifyNatIpAttributeResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyNatIpAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyNatIpAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyNatIpAttributeResponse) GoString() string {
	return s.String()
}

func (s *ModifyNatIpAttributeResponse) SetHeaders(v map[string]*string) *ModifyNatIpAttributeResponse {
	s.Headers = v
	return s
}

func (s *ModifyNatIpAttributeResponse) SetStatusCode(v int32) *ModifyNatIpAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyNatIpAttributeResponse) SetBody(v *ModifyNatIpAttributeResponseBody) *ModifyNatIpAttributeResponse {
	s.Body = v
	return s
}

type ModifyNatIpCidrAttributeRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. ClientToken can contain only ASCII characters.
	//
	// >  If you do not set this parameter, the system automatically uses **RequestId** as **ClientToken**. **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to check the request without performing the operation. Valid values:
	//
	// *   **true**: checks the request but does not modify information about the NAT CIDR block. The system checks whether your AccessKey pair is valid, whether RAM users are granted required permissions, and whether the required parameters are set. If the request fails the check, an error message is returned. If the request passes the check, the `DryRunOperation` error code is returned.
	// *   **false**: sends the request. This is the default value. If the request passes the check, a 2xx HTTP status code is returned and information about the NAT CIDR block is modified.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The ID of the Virtual Private Cloud (VPC) NAT gateway to which the NAT CIDR block belongs.
	NatGatewayId *string `json:"NatGatewayId,omitempty" xml:"NatGatewayId,omitempty"`
	// The NAT CIDR block whose name and description you want to modify.
	NatIpCidr *string `json:"NatIpCidr,omitempty" xml:"NatIpCidr,omitempty"`
	// The new description of the NAT CIDR block.
	//
	// The description must be 2 to 256 characters in length. It must start with a letter but cannot start with `http://` or `https://`.
	NatIpCidrDescription *string `json:"NatIpCidrDescription,omitempty" xml:"NatIpCidrDescription,omitempty"`
	// The new name of the NAT CIDR block.
	//
	// The name must be 2 to 128 characters in length and can contain digits, periods (.), underscores (\_), and hyphens (-). It must start with a letter.
	NatIpCidrName *string `json:"NatIpCidrName,omitempty" xml:"NatIpCidrName,omitempty"`
	OwnerAccount  *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the NAT gateway to which the NAT CIDR block belongs.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ModifyNatIpCidrAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyNatIpCidrAttributeRequest) GoString() string {
	return s.String()
}

func (s *ModifyNatIpCidrAttributeRequest) SetClientToken(v string) *ModifyNatIpCidrAttributeRequest {
	s.ClientToken = &v
	return s
}

func (s *ModifyNatIpCidrAttributeRequest) SetDryRun(v bool) *ModifyNatIpCidrAttributeRequest {
	s.DryRun = &v
	return s
}

func (s *ModifyNatIpCidrAttributeRequest) SetNatGatewayId(v string) *ModifyNatIpCidrAttributeRequest {
	s.NatGatewayId = &v
	return s
}

func (s *ModifyNatIpCidrAttributeRequest) SetNatIpCidr(v string) *ModifyNatIpCidrAttributeRequest {
	s.NatIpCidr = &v
	return s
}

func (s *ModifyNatIpCidrAttributeRequest) SetNatIpCidrDescription(v string) *ModifyNatIpCidrAttributeRequest {
	s.NatIpCidrDescription = &v
	return s
}

func (s *ModifyNatIpCidrAttributeRequest) SetNatIpCidrName(v string) *ModifyNatIpCidrAttributeRequest {
	s.NatIpCidrName = &v
	return s
}

func (s *ModifyNatIpCidrAttributeRequest) SetOwnerAccount(v string) *ModifyNatIpCidrAttributeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyNatIpCidrAttributeRequest) SetOwnerId(v int64) *ModifyNatIpCidrAttributeRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyNatIpCidrAttributeRequest) SetRegionId(v string) *ModifyNatIpCidrAttributeRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyNatIpCidrAttributeRequest) SetResourceOwnerAccount(v string) *ModifyNatIpCidrAttributeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyNatIpCidrAttributeRequest) SetResourceOwnerId(v int64) *ModifyNatIpCidrAttributeRequest {
	s.ResourceOwnerId = &v
	return s
}

type ModifyNatIpCidrAttributeResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyNatIpCidrAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyNatIpCidrAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyNatIpCidrAttributeResponseBody) SetRequestId(v string) *ModifyNatIpCidrAttributeResponseBody {
	s.RequestId = &v
	return s
}

type ModifyNatIpCidrAttributeResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyNatIpCidrAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyNatIpCidrAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyNatIpCidrAttributeResponse) GoString() string {
	return s.String()
}

func (s *ModifyNatIpCidrAttributeResponse) SetHeaders(v map[string]*string) *ModifyNatIpCidrAttributeResponse {
	s.Headers = v
	return s
}

func (s *ModifyNatIpCidrAttributeResponse) SetStatusCode(v int32) *ModifyNatIpCidrAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyNatIpCidrAttributeResponse) SetBody(v *ModifyNatIpCidrAttributeResponseBody) *ModifyNatIpCidrAttributeResponse {
	s.Body = v
	return s
}

type ModifyNetworkAclAttributesRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can contain only ASCII characters.
	//
	// >  If you do not specify this parameter, the system uses **RequestId** as **ClientToken**. **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The description of the network ACL.
	//
	// The description must be 1 to 256 characters in length and cannot start with `http://` or `https://`.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the network ACL.
	NetworkAclId *string `json:"NetworkAclId,omitempty" xml:"NetworkAclId,omitempty"`
	// The name of the network ACL.
	//
	// The name must be 1 to 128 characters in length and cannot start with `http://` or `https://`.
	NetworkAclName *string `json:"NetworkAclName,omitempty" xml:"NetworkAclName,omitempty"`
	OwnerId        *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the network ACL.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ModifyNetworkAclAttributesRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyNetworkAclAttributesRequest) GoString() string {
	return s.String()
}

func (s *ModifyNetworkAclAttributesRequest) SetClientToken(v string) *ModifyNetworkAclAttributesRequest {
	s.ClientToken = &v
	return s
}

func (s *ModifyNetworkAclAttributesRequest) SetDescription(v string) *ModifyNetworkAclAttributesRequest {
	s.Description = &v
	return s
}

func (s *ModifyNetworkAclAttributesRequest) SetNetworkAclId(v string) *ModifyNetworkAclAttributesRequest {
	s.NetworkAclId = &v
	return s
}

func (s *ModifyNetworkAclAttributesRequest) SetNetworkAclName(v string) *ModifyNetworkAclAttributesRequest {
	s.NetworkAclName = &v
	return s
}

func (s *ModifyNetworkAclAttributesRequest) SetOwnerId(v int64) *ModifyNetworkAclAttributesRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyNetworkAclAttributesRequest) SetRegionId(v string) *ModifyNetworkAclAttributesRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyNetworkAclAttributesRequest) SetResourceOwnerAccount(v string) *ModifyNetworkAclAttributesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyNetworkAclAttributesRequest) SetResourceOwnerId(v int64) *ModifyNetworkAclAttributesRequest {
	s.ResourceOwnerId = &v
	return s
}

type ModifyNetworkAclAttributesResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyNetworkAclAttributesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyNetworkAclAttributesResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyNetworkAclAttributesResponseBody) SetRequestId(v string) *ModifyNetworkAclAttributesResponseBody {
	s.RequestId = &v
	return s
}

type ModifyNetworkAclAttributesResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyNetworkAclAttributesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyNetworkAclAttributesResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyNetworkAclAttributesResponse) GoString() string {
	return s.String()
}

func (s *ModifyNetworkAclAttributesResponse) SetHeaders(v map[string]*string) *ModifyNetworkAclAttributesResponse {
	s.Headers = v
	return s
}

func (s *ModifyNetworkAclAttributesResponse) SetStatusCode(v int32) *ModifyNetworkAclAttributesResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyNetworkAclAttributesResponse) SetBody(v *ModifyNetworkAclAttributesResponseBody) *ModifyNetworkAclAttributesResponse {
	s.Body = v
	return s
}

type ModifyPhysicalConnectionAttributeRequest struct {
	// The circuit code of the Express Connect circuit. The circuit code is provided by the connectivity provider.
	CircuitCode *string `json:"CircuitCode,omitempty" xml:"CircuitCode,omitempty"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate a token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The description of the Express Connect circuit.
	//
	// The description must be 2 to 256 characters in length. It must start with a letter but cannot start with `http://` or `https://`.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The connectivity provider of the Express Connect circuit. Valid values:
	//
	// *   **CT**: China Telecom
	// *   **CU**: China Unicom
	// *   **CM**: China Mobile
	// *   **CO**: other connectivity providers in the Chinese mainland
	// *   **Equinix**: Equinix
	// *   **Other**: other connectivity providers outside the Chinese Mainland
	LineOperator *string `json:"LineOperator,omitempty" xml:"LineOperator,omitempty"`
	// The name of the Express Connect circuit.
	//
	// The name must be 2 to 128 characters in length and can contain letters, digits, periods (.), underscores (\_), and hyphens (-). The name must start with a letter but cannot start with `http://` or `https://`.
	Name         *string `json:"Name,omitempty" xml:"Name,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The geographical location of the data center.
	PeerLocation *string `json:"PeerLocation,omitempty" xml:"PeerLocation,omitempty"`
	// The ID of the Express Connect circuit.
	PhysicalConnectionId *string `json:"PhysicalConnectionId,omitempty" xml:"PhysicalConnectionId,omitempty"`
	// The port type of the Express Connect circuit. Valid values:
	//
	// *   **100Base-T**: 100 Mbit/s copper Ethernet port
	// *   **1000Base-T** (default): 1,000 Mbit/s copper Ethernet port
	// *   **1000Base-LX**: 1,000 Mbit/s single-mode optical port (10 kilometers)
	// *   **10GBase-T**: 10,000 Mbit/s copper Ethernet port
	// *   **10GBase-LR**: 10,000 Mbit/s single-mode optical port (10 kilometers)
	// *   **40GBase-LR**: 40,000 Mbit/s single-mode optical port
	// *   **100GBase-LR**: 100,000 Mbit/s single-mode optical port
	//
	// >  If you want to use the 40GBase-LR or 100GBase-LR port for an Express Connect circuit, you must first contact your account manager to obtain information about resource supplies.
	PortType *string `json:"PortType,omitempty" xml:"PortType,omitempty"`
	// The ID of the redundant Express Connect circuit. The redundant Express Connect circuit must be in the **Allocated**, **Confirmed**, or **Enabled** state.
	RedundantPhysicalConnectionId *string `json:"RedundantPhysicalConnectionId,omitempty" xml:"RedundantPhysicalConnectionId,omitempty"`
	// The region ID of the Express Connect circuit.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The bandwidth value for the connection over the Express Connect circuit. Unit: Mbit/s. Valid values: 2 to 10240.
	Bandwidth *int32 `json:"bandwidth,omitempty" xml:"bandwidth,omitempty"`
}

func (s ModifyPhysicalConnectionAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyPhysicalConnectionAttributeRequest) GoString() string {
	return s.String()
}

func (s *ModifyPhysicalConnectionAttributeRequest) SetCircuitCode(v string) *ModifyPhysicalConnectionAttributeRequest {
	s.CircuitCode = &v
	return s
}

func (s *ModifyPhysicalConnectionAttributeRequest) SetClientToken(v string) *ModifyPhysicalConnectionAttributeRequest {
	s.ClientToken = &v
	return s
}

func (s *ModifyPhysicalConnectionAttributeRequest) SetDescription(v string) *ModifyPhysicalConnectionAttributeRequest {
	s.Description = &v
	return s
}

func (s *ModifyPhysicalConnectionAttributeRequest) SetLineOperator(v string) *ModifyPhysicalConnectionAttributeRequest {
	s.LineOperator = &v
	return s
}

func (s *ModifyPhysicalConnectionAttributeRequest) SetName(v string) *ModifyPhysicalConnectionAttributeRequest {
	s.Name = &v
	return s
}

func (s *ModifyPhysicalConnectionAttributeRequest) SetOwnerAccount(v string) *ModifyPhysicalConnectionAttributeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyPhysicalConnectionAttributeRequest) SetOwnerId(v int64) *ModifyPhysicalConnectionAttributeRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyPhysicalConnectionAttributeRequest) SetPeerLocation(v string) *ModifyPhysicalConnectionAttributeRequest {
	s.PeerLocation = &v
	return s
}

func (s *ModifyPhysicalConnectionAttributeRequest) SetPhysicalConnectionId(v string) *ModifyPhysicalConnectionAttributeRequest {
	s.PhysicalConnectionId = &v
	return s
}

func (s *ModifyPhysicalConnectionAttributeRequest) SetPortType(v string) *ModifyPhysicalConnectionAttributeRequest {
	s.PortType = &v
	return s
}

func (s *ModifyPhysicalConnectionAttributeRequest) SetRedundantPhysicalConnectionId(v string) *ModifyPhysicalConnectionAttributeRequest {
	s.RedundantPhysicalConnectionId = &v
	return s
}

func (s *ModifyPhysicalConnectionAttributeRequest) SetRegionId(v string) *ModifyPhysicalConnectionAttributeRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyPhysicalConnectionAttributeRequest) SetResourceOwnerAccount(v string) *ModifyPhysicalConnectionAttributeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyPhysicalConnectionAttributeRequest) SetResourceOwnerId(v int64) *ModifyPhysicalConnectionAttributeRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ModifyPhysicalConnectionAttributeRequest) SetBandwidth(v int32) *ModifyPhysicalConnectionAttributeRequest {
	s.Bandwidth = &v
	return s
}

type ModifyPhysicalConnectionAttributeResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyPhysicalConnectionAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyPhysicalConnectionAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyPhysicalConnectionAttributeResponseBody) SetRequestId(v string) *ModifyPhysicalConnectionAttributeResponseBody {
	s.RequestId = &v
	return s
}

type ModifyPhysicalConnectionAttributeResponse struct {
	Headers    map[string]*string                             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyPhysicalConnectionAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyPhysicalConnectionAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyPhysicalConnectionAttributeResponse) GoString() string {
	return s.String()
}

func (s *ModifyPhysicalConnectionAttributeResponse) SetHeaders(v map[string]*string) *ModifyPhysicalConnectionAttributeResponse {
	s.Headers = v
	return s
}

func (s *ModifyPhysicalConnectionAttributeResponse) SetStatusCode(v int32) *ModifyPhysicalConnectionAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyPhysicalConnectionAttributeResponse) SetBody(v *ModifyPhysicalConnectionAttributeResponseBody) *ModifyPhysicalConnectionAttributeResponse {
	s.Body = v
	return s
}

type ModifyRouteEntryRequest struct {
	// The description of the route entry.
	//
	// The description must be 1 to 256 characters in length, and cannot start with `http://` or `https://`.
	Description  *string `json:"Description,omitempty" xml:"Description,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region to which the route belongs.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the custom route entry.
	RouteEntryId *string `json:"RouteEntryId,omitempty" xml:"RouteEntryId,omitempty"`
	// The name of the route entry.
	//
	// The name must be 1 to 128 characters in length, and cannot start with `http://` or `https://`.
	RouteEntryName *string `json:"RouteEntryName,omitempty" xml:"RouteEntryName,omitempty"`
}

func (s ModifyRouteEntryRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyRouteEntryRequest) GoString() string {
	return s.String()
}

func (s *ModifyRouteEntryRequest) SetDescription(v string) *ModifyRouteEntryRequest {
	s.Description = &v
	return s
}

func (s *ModifyRouteEntryRequest) SetOwnerAccount(v string) *ModifyRouteEntryRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyRouteEntryRequest) SetOwnerId(v int64) *ModifyRouteEntryRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyRouteEntryRequest) SetRegionId(v string) *ModifyRouteEntryRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyRouteEntryRequest) SetResourceOwnerAccount(v string) *ModifyRouteEntryRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyRouteEntryRequest) SetResourceOwnerId(v int64) *ModifyRouteEntryRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ModifyRouteEntryRequest) SetRouteEntryId(v string) *ModifyRouteEntryRequest {
	s.RouteEntryId = &v
	return s
}

func (s *ModifyRouteEntryRequest) SetRouteEntryName(v string) *ModifyRouteEntryRequest {
	s.RouteEntryName = &v
	return s
}

type ModifyRouteEntryResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyRouteEntryResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyRouteEntryResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyRouteEntryResponseBody) SetRequestId(v string) *ModifyRouteEntryResponseBody {
	s.RequestId = &v
	return s
}

type ModifyRouteEntryResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyRouteEntryResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyRouteEntryResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyRouteEntryResponse) GoString() string {
	return s.String()
}

func (s *ModifyRouteEntryResponse) SetHeaders(v map[string]*string) *ModifyRouteEntryResponse {
	s.Headers = v
	return s
}

func (s *ModifyRouteEntryResponse) SetStatusCode(v int32) *ModifyRouteEntryResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyRouteEntryResponse) SetBody(v *ModifyRouteEntryResponseBody) *ModifyRouteEntryResponse {
	s.Body = v
	return s
}

type ModifyRouteTableAttributesRequest struct {
	// The description of the route table.
	//
	// The description must be 1 to 256 characters in length, and cannot start with `http://` or `https://`.
	Description  *string `json:"Description,omitempty" xml:"Description,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the virtual private cloud (VPC) to which the route table belongs.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the route table.
	RouteTableId *string `json:"RouteTableId,omitempty" xml:"RouteTableId,omitempty"`
	// The name of the route table.
	//
	// The name must be 1 to 128 characters in length, and cannot start with `http://` or `https://`.
	RouteTableName *string `json:"RouteTableName,omitempty" xml:"RouteTableName,omitempty"`
}

func (s ModifyRouteTableAttributesRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyRouteTableAttributesRequest) GoString() string {
	return s.String()
}

func (s *ModifyRouteTableAttributesRequest) SetDescription(v string) *ModifyRouteTableAttributesRequest {
	s.Description = &v
	return s
}

func (s *ModifyRouteTableAttributesRequest) SetOwnerAccount(v string) *ModifyRouteTableAttributesRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyRouteTableAttributesRequest) SetOwnerId(v int64) *ModifyRouteTableAttributesRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyRouteTableAttributesRequest) SetRegionId(v string) *ModifyRouteTableAttributesRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyRouteTableAttributesRequest) SetResourceOwnerAccount(v string) *ModifyRouteTableAttributesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyRouteTableAttributesRequest) SetResourceOwnerId(v int64) *ModifyRouteTableAttributesRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ModifyRouteTableAttributesRequest) SetRouteTableId(v string) *ModifyRouteTableAttributesRequest {
	s.RouteTableId = &v
	return s
}

func (s *ModifyRouteTableAttributesRequest) SetRouteTableName(v string) *ModifyRouteTableAttributesRequest {
	s.RouteTableName = &v
	return s
}

type ModifyRouteTableAttributesResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyRouteTableAttributesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyRouteTableAttributesResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyRouteTableAttributesResponseBody) SetRequestId(v string) *ModifyRouteTableAttributesResponseBody {
	s.RequestId = &v
	return s
}

type ModifyRouteTableAttributesResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyRouteTableAttributesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyRouteTableAttributesResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyRouteTableAttributesResponse) GoString() string {
	return s.String()
}

func (s *ModifyRouteTableAttributesResponse) SetHeaders(v map[string]*string) *ModifyRouteTableAttributesResponse {
	s.Headers = v
	return s
}

func (s *ModifyRouteTableAttributesResponse) SetStatusCode(v int32) *ModifyRouteTableAttributesResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyRouteTableAttributesResponse) SetBody(v *ModifyRouteTableAttributesResponseBody) *ModifyRouteTableAttributesResponse {
	s.Body = v
	return s
}

type ModifyRouterInterfaceAttributeRequest struct {
	// Specifies whether to delete the health check IP addresses configured on the router interface. Valid values:
	//
	// *   **true**: yes
	// *   **false** (default): no
	DeleteHealthCheckIp *bool `json:"DeleteHealthCheckIp,omitempty" xml:"DeleteHealthCheckIp,omitempty"`
	// The description of the router interface.
	//
	// The value must be 2 to 256 characters in length. It must start with a letter but cannot start with `http://` or `https://`.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The rate of the heath check. Unit: milliseconds. The recommended value is **2000**. This value specifies the interval at which probe packets are sent during a health check.
	//
	// In this example, **HcThreshold** is set to **8** and **HcRate** is set to **2000**. In this example, probe packets are sent from **HealthCheckSourceIp** (source address) to **HealthCheckTargetIp** (destination address) every 2,000 seconds. If no response is returned for eight consecutive times, the health check fails.
	HcRate *int32 `json:"HcRate,omitempty" xml:"HcRate,omitempty"`
	// The health check threshold. Unit: packets. We recommend that you set the value to **8**. This value specifies the number of probe packets that are sent during a health check.
	HcThreshold *int32 `json:"HcThreshold,omitempty" xml:"HcThreshold,omitempty"`
	// The source IP address that is used to perform health checks. The source IP address must be an idle IP address of the local virtual private cloud (VPC).
	//
	// >  You can set this parameter if an Express Connect circuit is used.
	HealthCheckSourceIp *string `json:"HealthCheckSourceIp,omitempty" xml:"HealthCheckSourceIp,omitempty"`
	// The destination IP address that is used to perform health checks.
	//
	// >  This parameter is required when the **HealthCheckSourceIp** parameter is set.
	HealthCheckTargetIp *string `json:"HealthCheckTargetIp,omitempty" xml:"HealthCheckTargetIp,omitempty"`
	// The name of the router interface.
	//
	// The name must be 2 to 128 characters in length, and can contain letters, digits, underscores (\_), and hyphens (-). The name must start with a letter.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the peer router interface.
	OppositeInterfaceId *string `json:"OppositeInterfaceId,omitempty" xml:"OppositeInterfaceId,omitempty"`
	// The ID of the Alibaba Cloud account to which the peer router interface belongs.
	OppositeInterfaceOwnerId *int64 `json:"OppositeInterfaceOwnerId,omitempty" xml:"OppositeInterfaceOwnerId,omitempty"`
	// The ID of the peer router.
	OppositeRouterId *string `json:"OppositeRouterId,omitempty" xml:"OppositeRouterId,omitempty"`
	// The type of router to which the peer router interface belongs. Valid values:
	//
	// *   **VRouter**: vRouter
	// *   **VBR** (default): virtual border router (VBR)
	OppositeRouterType *string `json:"OppositeRouterType,omitempty" xml:"OppositeRouterType,omitempty"`
	OwnerId            *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region to which the router interface belongs.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the router interface.
	RouterInterfaceId *string `json:"RouterInterfaceId,omitempty" xml:"RouterInterfaceId,omitempty"`
}

func (s ModifyRouterInterfaceAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyRouterInterfaceAttributeRequest) GoString() string {
	return s.String()
}

func (s *ModifyRouterInterfaceAttributeRequest) SetDeleteHealthCheckIp(v bool) *ModifyRouterInterfaceAttributeRequest {
	s.DeleteHealthCheckIp = &v
	return s
}

func (s *ModifyRouterInterfaceAttributeRequest) SetDescription(v string) *ModifyRouterInterfaceAttributeRequest {
	s.Description = &v
	return s
}

func (s *ModifyRouterInterfaceAttributeRequest) SetHcRate(v int32) *ModifyRouterInterfaceAttributeRequest {
	s.HcRate = &v
	return s
}

func (s *ModifyRouterInterfaceAttributeRequest) SetHcThreshold(v int32) *ModifyRouterInterfaceAttributeRequest {
	s.HcThreshold = &v
	return s
}

func (s *ModifyRouterInterfaceAttributeRequest) SetHealthCheckSourceIp(v string) *ModifyRouterInterfaceAttributeRequest {
	s.HealthCheckSourceIp = &v
	return s
}

func (s *ModifyRouterInterfaceAttributeRequest) SetHealthCheckTargetIp(v string) *ModifyRouterInterfaceAttributeRequest {
	s.HealthCheckTargetIp = &v
	return s
}

func (s *ModifyRouterInterfaceAttributeRequest) SetName(v string) *ModifyRouterInterfaceAttributeRequest {
	s.Name = &v
	return s
}

func (s *ModifyRouterInterfaceAttributeRequest) SetOppositeInterfaceId(v string) *ModifyRouterInterfaceAttributeRequest {
	s.OppositeInterfaceId = &v
	return s
}

func (s *ModifyRouterInterfaceAttributeRequest) SetOppositeInterfaceOwnerId(v int64) *ModifyRouterInterfaceAttributeRequest {
	s.OppositeInterfaceOwnerId = &v
	return s
}

func (s *ModifyRouterInterfaceAttributeRequest) SetOppositeRouterId(v string) *ModifyRouterInterfaceAttributeRequest {
	s.OppositeRouterId = &v
	return s
}

func (s *ModifyRouterInterfaceAttributeRequest) SetOppositeRouterType(v string) *ModifyRouterInterfaceAttributeRequest {
	s.OppositeRouterType = &v
	return s
}

func (s *ModifyRouterInterfaceAttributeRequest) SetOwnerId(v int64) *ModifyRouterInterfaceAttributeRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyRouterInterfaceAttributeRequest) SetRegionId(v string) *ModifyRouterInterfaceAttributeRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyRouterInterfaceAttributeRequest) SetResourceOwnerAccount(v string) *ModifyRouterInterfaceAttributeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyRouterInterfaceAttributeRequest) SetResourceOwnerId(v int64) *ModifyRouterInterfaceAttributeRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ModifyRouterInterfaceAttributeRequest) SetRouterInterfaceId(v string) *ModifyRouterInterfaceAttributeRequest {
	s.RouterInterfaceId = &v
	return s
}

type ModifyRouterInterfaceAttributeResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyRouterInterfaceAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyRouterInterfaceAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyRouterInterfaceAttributeResponseBody) SetRequestId(v string) *ModifyRouterInterfaceAttributeResponseBody {
	s.RequestId = &v
	return s
}

type ModifyRouterInterfaceAttributeResponse struct {
	Headers    map[string]*string                          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyRouterInterfaceAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyRouterInterfaceAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyRouterInterfaceAttributeResponse) GoString() string {
	return s.String()
}

func (s *ModifyRouterInterfaceAttributeResponse) SetHeaders(v map[string]*string) *ModifyRouterInterfaceAttributeResponse {
	s.Headers = v
	return s
}

func (s *ModifyRouterInterfaceAttributeResponse) SetStatusCode(v int32) *ModifyRouterInterfaceAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyRouterInterfaceAttributeResponse) SetBody(v *ModifyRouterInterfaceAttributeResponseBody) *ModifyRouterInterfaceAttributeResponse {
	s.Body = v
	return s
}

type ModifyRouterInterfaceSpecRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, the system automatically uses **RequestId** as **ClientToken**. **RequestId** may be different for each API request.
	ClientToken  *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region where the router interface is deployed.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the router interface.
	RouterInterfaceId *string `json:"RouterInterfaceId,omitempty" xml:"RouterInterfaceId,omitempty"`
	// The specification of the router interface. Valid specifications and bandwidth values:
	//
	// *   **Mini.2**: 2 Mbit/s
	// *   **Mini.5**: 5 Mbit/s
	// *   **Small.1**: 10 Mbit/s
	// *   **Small.2**: 20 Mbit/s
	// *   **Small.5**: 50 Mbit/s
	// *   **Middle.1**: 100 Mbit/s
	// *   **Middle.2**: 200 Mbit/s
	// *   **Middle.5**: 500 Mbit/s
	// *   **Large.1**: 1,000 Mbit/s
	// *   **Large.2**: 2,000 Mbit/s
	// *   **Large.5**: 5,000 Mbit/s
	// *   **Xlarge.1**: 10,000 Mbit/s
	//
	// >  When **Role** is set to **AcceptingSide** (acceptor), **Spec** is set to **Negative**.
	Spec *string `json:"Spec,omitempty" xml:"Spec,omitempty"`
}

func (s ModifyRouterInterfaceSpecRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyRouterInterfaceSpecRequest) GoString() string {
	return s.String()
}

func (s *ModifyRouterInterfaceSpecRequest) SetClientToken(v string) *ModifyRouterInterfaceSpecRequest {
	s.ClientToken = &v
	return s
}

func (s *ModifyRouterInterfaceSpecRequest) SetOwnerAccount(v string) *ModifyRouterInterfaceSpecRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyRouterInterfaceSpecRequest) SetOwnerId(v int64) *ModifyRouterInterfaceSpecRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyRouterInterfaceSpecRequest) SetRegionId(v string) *ModifyRouterInterfaceSpecRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyRouterInterfaceSpecRequest) SetResourceOwnerAccount(v string) *ModifyRouterInterfaceSpecRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyRouterInterfaceSpecRequest) SetResourceOwnerId(v int64) *ModifyRouterInterfaceSpecRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ModifyRouterInterfaceSpecRequest) SetRouterInterfaceId(v string) *ModifyRouterInterfaceSpecRequest {
	s.RouterInterfaceId = &v
	return s
}

func (s *ModifyRouterInterfaceSpecRequest) SetSpec(v string) *ModifyRouterInterfaceSpecRequest {
	s.Spec = &v
	return s
}

type ModifyRouterInterfaceSpecResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The specification of the router interface. Valid values:
	//
	// *   **Mini.2**: 2 Mbit/s
	// *   **Mini.5**: 5 Mbit/s
	// *   **Small.1**: 10 Mbit/s
	// *   **Small.2**: 20 Mbit/s
	// *   **Small.5**: 50 Mbit/s
	// *   **Middle.1**: 100 Mbit/s
	// *   **Middle.2**: 200 Mbit/s
	// *   **Middle.5**: 500 Mbit/s
	// *   **Large.1**: 1,000 Mbit/s
	// *   **Large.2**: 2,000 Mbit/s
	// *   **Large.5**: 5,000 Mbit/s
	// *   **Xlarge.1**: 10,000 Mbit/s
	Spec *string `json:"Spec,omitempty" xml:"Spec,omitempty"`
}

func (s ModifyRouterInterfaceSpecResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyRouterInterfaceSpecResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyRouterInterfaceSpecResponseBody) SetRequestId(v string) *ModifyRouterInterfaceSpecResponseBody {
	s.RequestId = &v
	return s
}

func (s *ModifyRouterInterfaceSpecResponseBody) SetSpec(v string) *ModifyRouterInterfaceSpecResponseBody {
	s.Spec = &v
	return s
}

type ModifyRouterInterfaceSpecResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyRouterInterfaceSpecResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyRouterInterfaceSpecResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyRouterInterfaceSpecResponse) GoString() string {
	return s.String()
}

func (s *ModifyRouterInterfaceSpecResponse) SetHeaders(v map[string]*string) *ModifyRouterInterfaceSpecResponse {
	s.Headers = v
	return s
}

func (s *ModifyRouterInterfaceSpecResponse) SetStatusCode(v int32) *ModifyRouterInterfaceSpecResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyRouterInterfaceSpecResponse) SetBody(v *ModifyRouterInterfaceSpecResponseBody) *ModifyRouterInterfaceSpecResponse {
	s.Body = v
	return s
}

type ModifySnatEntryRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, the system automatically uses **RequestId** as **ClientToken**. The value of **RequestId** may be different for each API request.
	ClientToken  *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region where the NAT gateway is deployed.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the SNAT entry that you want to modify.
	SnatEntryId *string `json:"SnatEntryId,omitempty" xml:"SnatEntryId,omitempty"`
	// The name of the SNAT entry.
	//
	// The name must be 2 to 128 characters in length. It must start with a letter but cannot start with `http://` or `https://`.
	SnatEntryName *string `json:"SnatEntryName,omitempty" xml:"SnatEntryName,omitempty"`
	// *   The elastic IP addresses (EIPs) in the SNAT entry when you modify an SNAT entry of an Internet NAT gateway. Separate EIPs with commas (,).
	//
	//     If you select multiple EIPs to create an SNAT address pool, connections are hashed to these EIPs. Network traffic may not be evenly distributed to the EIPs because the amount of traffic passes through each connection varies. We recommend that you associate these EIPs with the same EIP bandwidth plan to prevent service interruptions due to the bandwidth limit of an individual EIP.
	//
	// *   When you modify an SNAT entry of a VPC NAT gateway, this parameter specifies the NAT IP address in the SNAT entry.
	SnatIp *string `json:"SnatIp,omitempty" xml:"SnatIp,omitempty"`
	// The ID of the SNAT table to which the SNAT entry belongs.
	SnatTableId *string `json:"SnatTableId,omitempty" xml:"SnatTableId,omitempty"`
}

func (s ModifySnatEntryRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifySnatEntryRequest) GoString() string {
	return s.String()
}

func (s *ModifySnatEntryRequest) SetClientToken(v string) *ModifySnatEntryRequest {
	s.ClientToken = &v
	return s
}

func (s *ModifySnatEntryRequest) SetOwnerAccount(v string) *ModifySnatEntryRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifySnatEntryRequest) SetOwnerId(v int64) *ModifySnatEntryRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifySnatEntryRequest) SetRegionId(v string) *ModifySnatEntryRequest {
	s.RegionId = &v
	return s
}

func (s *ModifySnatEntryRequest) SetResourceOwnerAccount(v string) *ModifySnatEntryRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifySnatEntryRequest) SetResourceOwnerId(v int64) *ModifySnatEntryRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ModifySnatEntryRequest) SetSnatEntryId(v string) *ModifySnatEntryRequest {
	s.SnatEntryId = &v
	return s
}

func (s *ModifySnatEntryRequest) SetSnatEntryName(v string) *ModifySnatEntryRequest {
	s.SnatEntryName = &v
	return s
}

func (s *ModifySnatEntryRequest) SetSnatIp(v string) *ModifySnatEntryRequest {
	s.SnatIp = &v
	return s
}

func (s *ModifySnatEntryRequest) SetSnatTableId(v string) *ModifySnatEntryRequest {
	s.SnatTableId = &v
	return s
}

type ModifySnatEntryResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifySnatEntryResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifySnatEntryResponseBody) GoString() string {
	return s.String()
}

func (s *ModifySnatEntryResponseBody) SetRequestId(v string) *ModifySnatEntryResponseBody {
	s.RequestId = &v
	return s
}

type ModifySnatEntryResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifySnatEntryResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifySnatEntryResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifySnatEntryResponse) GoString() string {
	return s.String()
}

func (s *ModifySnatEntryResponse) SetHeaders(v map[string]*string) *ModifySnatEntryResponse {
	s.Headers = v
	return s
}

func (s *ModifySnatEntryResponse) SetStatusCode(v int32) *ModifySnatEntryResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifySnatEntryResponse) SetBody(v *ModifySnatEntryResponseBody) *ModifySnatEntryResponse {
	s.Body = v
	return s
}

type ModifySslVpnClientCertRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The name of the SSL-VPN client certificate.
	//
	// The name must be 1 to 100 characters in length and cannot start with `http://` or `https://`.
	Name         *string `json:"Name,omitempty" xml:"Name,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region where the SSL client certificate is created.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the SSL-VPN client certificate.
	SslVpnClientCertId *string `json:"SslVpnClientCertId,omitempty" xml:"SslVpnClientCertId,omitempty"`
}

func (s ModifySslVpnClientCertRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifySslVpnClientCertRequest) GoString() string {
	return s.String()
}

func (s *ModifySslVpnClientCertRequest) SetClientToken(v string) *ModifySslVpnClientCertRequest {
	s.ClientToken = &v
	return s
}

func (s *ModifySslVpnClientCertRequest) SetName(v string) *ModifySslVpnClientCertRequest {
	s.Name = &v
	return s
}

func (s *ModifySslVpnClientCertRequest) SetOwnerAccount(v string) *ModifySslVpnClientCertRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifySslVpnClientCertRequest) SetOwnerId(v int64) *ModifySslVpnClientCertRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifySslVpnClientCertRequest) SetRegionId(v string) *ModifySslVpnClientCertRequest {
	s.RegionId = &v
	return s
}

func (s *ModifySslVpnClientCertRequest) SetResourceOwnerAccount(v string) *ModifySslVpnClientCertRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifySslVpnClientCertRequest) SetResourceOwnerId(v int64) *ModifySslVpnClientCertRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ModifySslVpnClientCertRequest) SetSslVpnClientCertId(v string) *ModifySslVpnClientCertRequest {
	s.SslVpnClientCertId = &v
	return s
}

type ModifySslVpnClientCertResponseBody struct {
	// The name of the SSL client certificate.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the SSL-VPN client certificate.
	SslVpnClientCertId *string `json:"SslVpnClientCertId,omitempty" xml:"SslVpnClientCertId,omitempty"`
}

func (s ModifySslVpnClientCertResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifySslVpnClientCertResponseBody) GoString() string {
	return s.String()
}

func (s *ModifySslVpnClientCertResponseBody) SetName(v string) *ModifySslVpnClientCertResponseBody {
	s.Name = &v
	return s
}

func (s *ModifySslVpnClientCertResponseBody) SetRequestId(v string) *ModifySslVpnClientCertResponseBody {
	s.RequestId = &v
	return s
}

func (s *ModifySslVpnClientCertResponseBody) SetSslVpnClientCertId(v string) *ModifySslVpnClientCertResponseBody {
	s.SslVpnClientCertId = &v
	return s
}

type ModifySslVpnClientCertResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifySslVpnClientCertResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifySslVpnClientCertResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifySslVpnClientCertResponse) GoString() string {
	return s.String()
}

func (s *ModifySslVpnClientCertResponse) SetHeaders(v map[string]*string) *ModifySslVpnClientCertResponse {
	s.Headers = v
	return s
}

func (s *ModifySslVpnClientCertResponse) SetStatusCode(v int32) *ModifySslVpnClientCertResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifySslVpnClientCertResponse) SetBody(v *ModifySslVpnClientCertResponseBody) *ModifySslVpnClientCertResponse {
	s.Body = v
	return s
}

type ModifySslVpnServerRequest struct {
	// The encryption algorithm that is used by the SSL server. Valid values:
	//
	// *   **AES-128-CBC** (default): AES-128-CBC
	// *   **AES-192-CBC**: AES-192-CBC
	// *   **AES-256-CBC**: AES-256-CBC
	// *   **none**: does not use an encryption algorithm.
	Cipher *string `json:"Cipher,omitempty" xml:"Cipher,omitempty"`
	// The client IP address pool.
	ClientIpPool *string `json:"ClientIpPool,omitempty" xml:"ClientIpPool,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. ClientToken can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to enable data compression. Valid values:
	//
	// *   **true** (default): yes
	// *   **false**: no
	Compress *bool `json:"Compress,omitempty" xml:"Compress,omitempty"`
	// Specifies whether to enable two-factor authentication.
	//
	// *   **true**: yes
	// *   **false** (default): no
	EnableMultiFactorAuth *bool `json:"EnableMultiFactorAuth,omitempty" xml:"EnableMultiFactorAuth,omitempty"`
	// The ID of the Identity as a Service (IDaaS) instance.
	IDaaSInstanceId *string `json:"IDaaSInstanceId,omitempty" xml:"IDaaSInstanceId,omitempty"`
	// The ID of the region where the IDaaS instance is created.
	IDaaSRegionId *string `json:"IDaaSRegionId,omitempty" xml:"IDaaSRegionId,omitempty"`
	// The CIDR block of the client.
	LocalSubnet *string `json:"LocalSubnet,omitempty" xml:"LocalSubnet,omitempty"`
	// The name of the SSL server.
	//
	// The name must be 1 to 100 characters in length and cannot start with `http://` or `https://`.
	Name         *string `json:"Name,omitempty" xml:"Name,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The port used by the SSL server. Default value: **1194**. The following ports are not supported:
	//
	// **22, 2222, 22222, 9000, 9001, 9002, 7505, 80, 443, 53, 68, 123, 4510, 4560, 500, and 4500**.
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
	// The protocol that is used by the SSL server. Valid values:
	//
	// *   **TCP**: TCP
	// *   **UDP** (default): UDP
	Proto *string `json:"Proto,omitempty" xml:"Proto,omitempty"`
	// The ID of the region where the VPN gateway is created.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the SSL server.
	SslVpnServerId *string `json:"SslVpnServerId,omitempty" xml:"SslVpnServerId,omitempty"`
}

func (s ModifySslVpnServerRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifySslVpnServerRequest) GoString() string {
	return s.String()
}

func (s *ModifySslVpnServerRequest) SetCipher(v string) *ModifySslVpnServerRequest {
	s.Cipher = &v
	return s
}

func (s *ModifySslVpnServerRequest) SetClientIpPool(v string) *ModifySslVpnServerRequest {
	s.ClientIpPool = &v
	return s
}

func (s *ModifySslVpnServerRequest) SetClientToken(v string) *ModifySslVpnServerRequest {
	s.ClientToken = &v
	return s
}

func (s *ModifySslVpnServerRequest) SetCompress(v bool) *ModifySslVpnServerRequest {
	s.Compress = &v
	return s
}

func (s *ModifySslVpnServerRequest) SetEnableMultiFactorAuth(v bool) *ModifySslVpnServerRequest {
	s.EnableMultiFactorAuth = &v
	return s
}

func (s *ModifySslVpnServerRequest) SetIDaaSInstanceId(v string) *ModifySslVpnServerRequest {
	s.IDaaSInstanceId = &v
	return s
}

func (s *ModifySslVpnServerRequest) SetIDaaSRegionId(v string) *ModifySslVpnServerRequest {
	s.IDaaSRegionId = &v
	return s
}

func (s *ModifySslVpnServerRequest) SetLocalSubnet(v string) *ModifySslVpnServerRequest {
	s.LocalSubnet = &v
	return s
}

func (s *ModifySslVpnServerRequest) SetName(v string) *ModifySslVpnServerRequest {
	s.Name = &v
	return s
}

func (s *ModifySslVpnServerRequest) SetOwnerAccount(v string) *ModifySslVpnServerRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifySslVpnServerRequest) SetOwnerId(v int64) *ModifySslVpnServerRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifySslVpnServerRequest) SetPort(v int32) *ModifySslVpnServerRequest {
	s.Port = &v
	return s
}

func (s *ModifySslVpnServerRequest) SetProto(v string) *ModifySslVpnServerRequest {
	s.Proto = &v
	return s
}

func (s *ModifySslVpnServerRequest) SetRegionId(v string) *ModifySslVpnServerRequest {
	s.RegionId = &v
	return s
}

func (s *ModifySslVpnServerRequest) SetResourceOwnerAccount(v string) *ModifySslVpnServerRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifySslVpnServerRequest) SetResourceOwnerId(v int64) *ModifySslVpnServerRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ModifySslVpnServerRequest) SetSslVpnServerId(v string) *ModifySslVpnServerRequest {
	s.SslVpnServerId = &v
	return s
}

type ModifySslVpnServerResponseBody struct {
	// The encryption algorithm.
	Cipher *string `json:"Cipher,omitempty" xml:"Cipher,omitempty"`
	// The client IP address pool.
	ClientIpPool *string `json:"ClientIpPool,omitempty" xml:"ClientIpPool,omitempty"`
	// Indicates whether data compression is enabled.
	Compress *bool `json:"Compress,omitempty" xml:"Compress,omitempty"`
	// The total number of current connections.
	Connections *int32 `json:"Connections,omitempty" xml:"Connections,omitempty"`
	// The time when the SSL server was created.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// Indicates whether two-factor authentication is enabled.
	//
	// *   **true**: enabled
	// *   **false** (default): disabled
	EnableMultiFactorAuth *bool `json:"EnableMultiFactorAuth,omitempty" xml:"EnableMultiFactorAuth,omitempty"`
	// The ID of the IDaaS instance.
	IDaaSInstanceId *string `json:"IDaaSInstanceId,omitempty" xml:"IDaaSInstanceId,omitempty"`
	// The public IP address.
	InternetIp *string `json:"InternetIp,omitempty" xml:"InternetIp,omitempty"`
	// The CIDR block of the client.
	LocalSubnet *string `json:"LocalSubnet,omitempty" xml:"LocalSubnet,omitempty"`
	// The maximum number of connections.
	MaxConnections *int32 `json:"MaxConnections,omitempty" xml:"MaxConnections,omitempty"`
	// The name of the SSL server.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The port that is used by the SSL server.
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
	// The protocol that is used by the SSL server.
	Proto *string `json:"Proto,omitempty" xml:"Proto,omitempty"`
	// The ID of the region where the SSL server is created.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the SSL server.
	SslVpnServerId *string `json:"SslVpnServerId,omitempty" xml:"SslVpnServerId,omitempty"`
	// The ID of the VPN gateway.
	VpnGatewayId *string `json:"VpnGatewayId,omitempty" xml:"VpnGatewayId,omitempty"`
}

func (s ModifySslVpnServerResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifySslVpnServerResponseBody) GoString() string {
	return s.String()
}

func (s *ModifySslVpnServerResponseBody) SetCipher(v string) *ModifySslVpnServerResponseBody {
	s.Cipher = &v
	return s
}

func (s *ModifySslVpnServerResponseBody) SetClientIpPool(v string) *ModifySslVpnServerResponseBody {
	s.ClientIpPool = &v
	return s
}

func (s *ModifySslVpnServerResponseBody) SetCompress(v bool) *ModifySslVpnServerResponseBody {
	s.Compress = &v
	return s
}

func (s *ModifySslVpnServerResponseBody) SetConnections(v int32) *ModifySslVpnServerResponseBody {
	s.Connections = &v
	return s
}

func (s *ModifySslVpnServerResponseBody) SetCreateTime(v int64) *ModifySslVpnServerResponseBody {
	s.CreateTime = &v
	return s
}

func (s *ModifySslVpnServerResponseBody) SetEnableMultiFactorAuth(v bool) *ModifySslVpnServerResponseBody {
	s.EnableMultiFactorAuth = &v
	return s
}

func (s *ModifySslVpnServerResponseBody) SetIDaaSInstanceId(v string) *ModifySslVpnServerResponseBody {
	s.IDaaSInstanceId = &v
	return s
}

func (s *ModifySslVpnServerResponseBody) SetInternetIp(v string) *ModifySslVpnServerResponseBody {
	s.InternetIp = &v
	return s
}

func (s *ModifySslVpnServerResponseBody) SetLocalSubnet(v string) *ModifySslVpnServerResponseBody {
	s.LocalSubnet = &v
	return s
}

func (s *ModifySslVpnServerResponseBody) SetMaxConnections(v int32) *ModifySslVpnServerResponseBody {
	s.MaxConnections = &v
	return s
}

func (s *ModifySslVpnServerResponseBody) SetName(v string) *ModifySslVpnServerResponseBody {
	s.Name = &v
	return s
}

func (s *ModifySslVpnServerResponseBody) SetPort(v int32) *ModifySslVpnServerResponseBody {
	s.Port = &v
	return s
}

func (s *ModifySslVpnServerResponseBody) SetProto(v string) *ModifySslVpnServerResponseBody {
	s.Proto = &v
	return s
}

func (s *ModifySslVpnServerResponseBody) SetRegionId(v string) *ModifySslVpnServerResponseBody {
	s.RegionId = &v
	return s
}

func (s *ModifySslVpnServerResponseBody) SetRequestId(v string) *ModifySslVpnServerResponseBody {
	s.RequestId = &v
	return s
}

func (s *ModifySslVpnServerResponseBody) SetSslVpnServerId(v string) *ModifySslVpnServerResponseBody {
	s.SslVpnServerId = &v
	return s
}

func (s *ModifySslVpnServerResponseBody) SetVpnGatewayId(v string) *ModifySslVpnServerResponseBody {
	s.VpnGatewayId = &v
	return s
}

type ModifySslVpnServerResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifySslVpnServerResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifySslVpnServerResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifySslVpnServerResponse) GoString() string {
	return s.String()
}

func (s *ModifySslVpnServerResponse) SetHeaders(v map[string]*string) *ModifySslVpnServerResponse {
	s.Headers = v
	return s
}

func (s *ModifySslVpnServerResponse) SetStatusCode(v int32) *ModifySslVpnServerResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifySslVpnServerResponse) SetBody(v *ModifySslVpnServerResponseBody) *ModifySslVpnServerResponse {
	s.Body = v
	return s
}

type ModifyVRouterAttributeRequest struct {
	// The description of the vRouter.
	//
	// The description must be 1 to 256 characters in length and cannot start with `http://` or `https://`.
	Description  *string `json:"Description,omitempty" xml:"Description,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region where the vRouter is deployed.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the vRouter.
	VRouterId *string `json:"VRouterId,omitempty" xml:"VRouterId,omitempty"`
	// The name of the vRouter.
	//
	// The name must be 1 to 128 characters in length and cannot start with `http://` or `https://`.
	VRouterName *string `json:"VRouterName,omitempty" xml:"VRouterName,omitempty"`
}

func (s ModifyVRouterAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyVRouterAttributeRequest) GoString() string {
	return s.String()
}

func (s *ModifyVRouterAttributeRequest) SetDescription(v string) *ModifyVRouterAttributeRequest {
	s.Description = &v
	return s
}

func (s *ModifyVRouterAttributeRequest) SetOwnerAccount(v string) *ModifyVRouterAttributeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyVRouterAttributeRequest) SetOwnerId(v int64) *ModifyVRouterAttributeRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyVRouterAttributeRequest) SetRegionId(v string) *ModifyVRouterAttributeRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyVRouterAttributeRequest) SetResourceOwnerAccount(v string) *ModifyVRouterAttributeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyVRouterAttributeRequest) SetResourceOwnerId(v int64) *ModifyVRouterAttributeRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ModifyVRouterAttributeRequest) SetVRouterId(v string) *ModifyVRouterAttributeRequest {
	s.VRouterId = &v
	return s
}

func (s *ModifyVRouterAttributeRequest) SetVRouterName(v string) *ModifyVRouterAttributeRequest {
	s.VRouterName = &v
	return s
}

type ModifyVRouterAttributeResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyVRouterAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyVRouterAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyVRouterAttributeResponseBody) SetRequestId(v string) *ModifyVRouterAttributeResponseBody {
	s.RequestId = &v
	return s
}

type ModifyVRouterAttributeResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyVRouterAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyVRouterAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyVRouterAttributeResponse) GoString() string {
	return s.String()
}

func (s *ModifyVRouterAttributeResponse) SetHeaders(v map[string]*string) *ModifyVRouterAttributeResponse {
	s.Headers = v
	return s
}

func (s *ModifyVRouterAttributeResponse) SetStatusCode(v int32) *ModifyVRouterAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyVRouterAttributeResponse) SetBody(v *ModifyVRouterAttributeResponseBody) *ModifyVRouterAttributeResponse {
	s.Body = v
	return s
}

type ModifyVSwitchAttributeRequest struct {
	// The new description for the vSwitch.
	//
	// The description must be 1 to 256 characters in length and cannot start with `http://` or `https://`.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// Specifies whether to enable the IPv6 feature for the vSwitch. Valid values:
	//
	// *   **true**: enables the IPv6 feature.
	// *   **false**: disables the IPv6 feature. This is the default value.
	EnableIPv6 *bool `json:"EnableIPv6,omitempty" xml:"EnableIPv6,omitempty"`
	// The last eight bits of the IPv6 CIDR block of the vSwitch. Valid values: **0** to **255**.
	//
	// You can set this parameter only when the IPv6 feature is enabled for the virtual private cloud (VPC) to which the vSwitch belongs.
	Ipv6CidrBlock *int32  `json:"Ipv6CidrBlock,omitempty" xml:"Ipv6CidrBlock,omitempty"`
	OwnerAccount  *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region where the vSwitch is deployed. You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the vSwitch.
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
	// The new name for the vSwitch.
	//
	// The name must be 1 to 128 characters in length, and cannot start with `http://` or `https://`.
	VSwitchName *string `json:"VSwitchName,omitempty" xml:"VSwitchName,omitempty"`
	// The IPv6 CIDR block of the VPC to which the vSwitch belongs.
	//
	// You can set this parameter only when the IPv6 feature is enabled for the VPC.
	VpcIpv6CidrBlock *string `json:"VpcIpv6CidrBlock,omitempty" xml:"VpcIpv6CidrBlock,omitempty"`
}

func (s ModifyVSwitchAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyVSwitchAttributeRequest) GoString() string {
	return s.String()
}

func (s *ModifyVSwitchAttributeRequest) SetDescription(v string) *ModifyVSwitchAttributeRequest {
	s.Description = &v
	return s
}

func (s *ModifyVSwitchAttributeRequest) SetEnableIPv6(v bool) *ModifyVSwitchAttributeRequest {
	s.EnableIPv6 = &v
	return s
}

func (s *ModifyVSwitchAttributeRequest) SetIpv6CidrBlock(v int32) *ModifyVSwitchAttributeRequest {
	s.Ipv6CidrBlock = &v
	return s
}

func (s *ModifyVSwitchAttributeRequest) SetOwnerAccount(v string) *ModifyVSwitchAttributeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyVSwitchAttributeRequest) SetOwnerId(v int64) *ModifyVSwitchAttributeRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyVSwitchAttributeRequest) SetRegionId(v string) *ModifyVSwitchAttributeRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyVSwitchAttributeRequest) SetResourceOwnerAccount(v string) *ModifyVSwitchAttributeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyVSwitchAttributeRequest) SetResourceOwnerId(v int64) *ModifyVSwitchAttributeRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ModifyVSwitchAttributeRequest) SetVSwitchId(v string) *ModifyVSwitchAttributeRequest {
	s.VSwitchId = &v
	return s
}

func (s *ModifyVSwitchAttributeRequest) SetVSwitchName(v string) *ModifyVSwitchAttributeRequest {
	s.VSwitchName = &v
	return s
}

func (s *ModifyVSwitchAttributeRequest) SetVpcIpv6CidrBlock(v string) *ModifyVSwitchAttributeRequest {
	s.VpcIpv6CidrBlock = &v
	return s
}

type ModifyVSwitchAttributeResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyVSwitchAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyVSwitchAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyVSwitchAttributeResponseBody) SetRequestId(v string) *ModifyVSwitchAttributeResponseBody {
	s.RequestId = &v
	return s
}

type ModifyVSwitchAttributeResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyVSwitchAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyVSwitchAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyVSwitchAttributeResponse) GoString() string {
	return s.String()
}

func (s *ModifyVSwitchAttributeResponse) SetHeaders(v map[string]*string) *ModifyVSwitchAttributeResponse {
	s.Headers = v
	return s
}

func (s *ModifyVSwitchAttributeResponse) SetStatusCode(v int32) *ModifyVSwitchAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyVSwitchAttributeResponse) SetBody(v *ModifyVSwitchAttributeResponseBody) *ModifyVSwitchAttributeResponse {
	s.Body = v
	return s
}

type ModifyVcoRouteEntryWeightRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among all requests. The token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The new weight of the destination-based route that you want to modify. Valid values:
	//
	// *   **0**: a low priority
	// *   **100**: a high priority
	NewWeight *int32 `json:"NewWeight,omitempty" xml:"NewWeight,omitempty"`
	// The next hop of the destination-based route that you want to modify.
	NextHop *string `json:"NextHop,omitempty" xml:"NextHop,omitempty"`
	// The tunneling protocol. Set the value to **Ipsec**, which specifies the IPsec tunneling protocol.
	OverlayMode  *string `json:"OverlayMode,omitempty" xml:"OverlayMode,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	// The ID of the region to which the IPsec-VPN connection belongs.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The destination CIDR block of the destination-based route that you want to modify.
	RouteDest *string `json:"RouteDest,omitempty" xml:"RouteDest,omitempty"`
	// The ID of the IPsec-VPN connection.
	VpnConnectionId *string `json:"VpnConnectionId,omitempty" xml:"VpnConnectionId,omitempty"`
	// The current weight of the destination-based route that you want to modify. Valid values:
	//
	// *   **0**: a low priority
	// *   **100**: a high priority
	Weight *int32 `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s ModifyVcoRouteEntryWeightRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyVcoRouteEntryWeightRequest) GoString() string {
	return s.String()
}

func (s *ModifyVcoRouteEntryWeightRequest) SetClientToken(v string) *ModifyVcoRouteEntryWeightRequest {
	s.ClientToken = &v
	return s
}

func (s *ModifyVcoRouteEntryWeightRequest) SetNewWeight(v int32) *ModifyVcoRouteEntryWeightRequest {
	s.NewWeight = &v
	return s
}

func (s *ModifyVcoRouteEntryWeightRequest) SetNextHop(v string) *ModifyVcoRouteEntryWeightRequest {
	s.NextHop = &v
	return s
}

func (s *ModifyVcoRouteEntryWeightRequest) SetOverlayMode(v string) *ModifyVcoRouteEntryWeightRequest {
	s.OverlayMode = &v
	return s
}

func (s *ModifyVcoRouteEntryWeightRequest) SetOwnerAccount(v string) *ModifyVcoRouteEntryWeightRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyVcoRouteEntryWeightRequest) SetRegionId(v string) *ModifyVcoRouteEntryWeightRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyVcoRouteEntryWeightRequest) SetResourceOwnerAccount(v string) *ModifyVcoRouteEntryWeightRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyVcoRouteEntryWeightRequest) SetResourceOwnerId(v int64) *ModifyVcoRouteEntryWeightRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ModifyVcoRouteEntryWeightRequest) SetRouteDest(v string) *ModifyVcoRouteEntryWeightRequest {
	s.RouteDest = &v
	return s
}

func (s *ModifyVcoRouteEntryWeightRequest) SetVpnConnectionId(v string) *ModifyVcoRouteEntryWeightRequest {
	s.VpnConnectionId = &v
	return s
}

func (s *ModifyVcoRouteEntryWeightRequest) SetWeight(v int32) *ModifyVcoRouteEntryWeightRequest {
	s.Weight = &v
	return s
}

type ModifyVcoRouteEntryWeightResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyVcoRouteEntryWeightResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyVcoRouteEntryWeightResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyVcoRouteEntryWeightResponseBody) SetRequestId(v string) *ModifyVcoRouteEntryWeightResponseBody {
	s.RequestId = &v
	return s
}

type ModifyVcoRouteEntryWeightResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyVcoRouteEntryWeightResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyVcoRouteEntryWeightResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyVcoRouteEntryWeightResponse) GoString() string {
	return s.String()
}

func (s *ModifyVcoRouteEntryWeightResponse) SetHeaders(v map[string]*string) *ModifyVcoRouteEntryWeightResponse {
	s.Headers = v
	return s
}

func (s *ModifyVcoRouteEntryWeightResponse) SetStatusCode(v int32) *ModifyVcoRouteEntryWeightResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyVcoRouteEntryWeightResponse) SetBody(v *ModifyVcoRouteEntryWeightResponseBody) *ModifyVcoRouteEntryWeightResponse {
	s.Body = v
	return s
}

type ModifyVirtualBorderRouterAttributeRequest struct {
	// The information about the Express Connect circuit associated with the VBR, including the following parameters:
	//
	// *   **CircuitCode**: the circuit code provided by the connectivity provider for the Express Connect circuit.
	// *   **LocalGatewayIp**: the IP address of the gateway device on the Alibaba Cloud side.
	// *   **PeerGatewayIp**: the IP address of the gateway device on the user side.
	// *   **PeeringSubnetMask**: the subnet mask for the IP addresses of gateway devices on the Alibaba Cloud side and the user side.
	// *   **PhysicalConnectionId**: the ID of the Express Connect circuit.
	AssociatedPhysicalConnections *string `json:"AssociatedPhysicalConnections,omitempty" xml:"AssociatedPhysicalConnections,omitempty"`
	// The bandwidth value. Unit: Mbit/s.
	Bandwidth *int32 `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	// The circuit code of the Express Connect circuit. The circuit code is provided by the connectivity provider.
	//
	// >  Only the owner of the Express Connect circuit can set this parameter.
	CircuitCode *string `json:"CircuitCode,omitempty" xml:"CircuitCode,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, the system uses **RequestId** as **ClientToken**. **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The description of the VBR.
	//
	// It must be 2 to 256 characters in length. It must start with a letter but cannot start with `http://` or `https://`.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The maximum number of dropped packets that is allowed by the receiver when the initiator transmits packets. This value can be used to check whether a connection works as expected.
	//
	// Valid values: **3 to 10**.
	DetectMultiplier *int64 `json:"DetectMultiplier,omitempty" xml:"DetectMultiplier,omitempty"`
	// Specifies whether to enable IPv6. Valid values:
	//
	// *   **true**: yes
	// *   **false** (default): no
	EnableIpv6 *bool `json:"EnableIpv6,omitempty" xml:"EnableIpv6,omitempty"`
	// The IP address of the gateway device on the Alibaba Cloud side.
	//
	// Only the owner of the VBR can set or modify this parameter.
	LocalGatewayIp *string `json:"LocalGatewayIp,omitempty" xml:"LocalGatewayIp,omitempty"`
	// The IPv6 address of the gateway device on the Alibaba Cloud side.
	LocalIpv6GatewayIp *string `json:"LocalIpv6GatewayIp,omitempty" xml:"LocalIpv6GatewayIp,omitempty"`
	// The time interval to receive BFD packets. Valid values: **200 to 1000**. Unit: milliseconds.
	MinRxInterval *int64 `json:"MinRxInterval,omitempty" xml:"MinRxInterval,omitempty"`
	// The time interval to send BFD packets. Valid values: **200 to 1000**. Unit: milliseconds.
	MinTxInterval *int64 `json:"MinTxInterval,omitempty" xml:"MinTxInterval,omitempty"`
	// The name of the VBR.
	//
	// The name must be 2 to 128 characters in length, and can contain letters, digits, underscores (\_), and hyphens (-). The name must start with a letter. It cannot start with `http://` or `https://`.
	Name         *string `json:"Name,omitempty" xml:"Name,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The IP address of the gateway device on the user side.
	//
	// Only the owner of the VBR can set or modify this parameter.
	PeerGatewayIp *string `json:"PeerGatewayIp,omitempty" xml:"PeerGatewayIp,omitempty"`
	// The IPv6 address of the gateway device in the data center.
	//
	// *   Only the owner of the VBR can set or modify this property.
	// *   This property is required when you create a VBR for the owner of the Express Connect circuit. You can ignore this property when you create a VBR for another Alibaba Cloud account.
	PeerIpv6GatewayIp *string `json:"PeerIpv6GatewayIp,omitempty" xml:"PeerIpv6GatewayIp,omitempty"`
	// The subnet mask of the IPv6 addresses of the VBR and the gateway device in the data center.
	//
	// The two IPv6 addresses must fall within the same subnet.
	PeeringIpv6SubnetMask *string `json:"PeeringIpv6SubnetMask,omitempty" xml:"PeeringIpv6SubnetMask,omitempty"`
	// The subnet mask for the IP addresses of the gateway devices on the Alibaba Cloud side and on the user side. Only the owner of the VBR can set or modify this parameter.
	//
	// The two IP addresses must fall within the same subnet.
	PeeringSubnetMask *string `json:"PeeringSubnetMask,omitempty" xml:"PeeringSubnetMask,omitempty"`
	// The region ID of the VBR.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the VBR.
	VbrId *string `json:"VbrId,omitempty" xml:"VbrId,omitempty"`
	// The VLAN ID of the VBR. Valid values: **0 to 2999**.
	//
	// >  Only the owner of the Express Connect circuit can set this parameter. The VLAN IDs of two VBRs of the same the Express Connect circuit must be different.
	VlanId *int32 `json:"VlanId,omitempty" xml:"VlanId,omitempty"`
}

func (s ModifyVirtualBorderRouterAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyVirtualBorderRouterAttributeRequest) GoString() string {
	return s.String()
}

func (s *ModifyVirtualBorderRouterAttributeRequest) SetAssociatedPhysicalConnections(v string) *ModifyVirtualBorderRouterAttributeRequest {
	s.AssociatedPhysicalConnections = &v
	return s
}

func (s *ModifyVirtualBorderRouterAttributeRequest) SetBandwidth(v int32) *ModifyVirtualBorderRouterAttributeRequest {
	s.Bandwidth = &v
	return s
}

func (s *ModifyVirtualBorderRouterAttributeRequest) SetCircuitCode(v string) *ModifyVirtualBorderRouterAttributeRequest {
	s.CircuitCode = &v
	return s
}

func (s *ModifyVirtualBorderRouterAttributeRequest) SetClientToken(v string) *ModifyVirtualBorderRouterAttributeRequest {
	s.ClientToken = &v
	return s
}

func (s *ModifyVirtualBorderRouterAttributeRequest) SetDescription(v string) *ModifyVirtualBorderRouterAttributeRequest {
	s.Description = &v
	return s
}

func (s *ModifyVirtualBorderRouterAttributeRequest) SetDetectMultiplier(v int64) *ModifyVirtualBorderRouterAttributeRequest {
	s.DetectMultiplier = &v
	return s
}

func (s *ModifyVirtualBorderRouterAttributeRequest) SetEnableIpv6(v bool) *ModifyVirtualBorderRouterAttributeRequest {
	s.EnableIpv6 = &v
	return s
}

func (s *ModifyVirtualBorderRouterAttributeRequest) SetLocalGatewayIp(v string) *ModifyVirtualBorderRouterAttributeRequest {
	s.LocalGatewayIp = &v
	return s
}

func (s *ModifyVirtualBorderRouterAttributeRequest) SetLocalIpv6GatewayIp(v string) *ModifyVirtualBorderRouterAttributeRequest {
	s.LocalIpv6GatewayIp = &v
	return s
}

func (s *ModifyVirtualBorderRouterAttributeRequest) SetMinRxInterval(v int64) *ModifyVirtualBorderRouterAttributeRequest {
	s.MinRxInterval = &v
	return s
}

func (s *ModifyVirtualBorderRouterAttributeRequest) SetMinTxInterval(v int64) *ModifyVirtualBorderRouterAttributeRequest {
	s.MinTxInterval = &v
	return s
}

func (s *ModifyVirtualBorderRouterAttributeRequest) SetName(v string) *ModifyVirtualBorderRouterAttributeRequest {
	s.Name = &v
	return s
}

func (s *ModifyVirtualBorderRouterAttributeRequest) SetOwnerAccount(v string) *ModifyVirtualBorderRouterAttributeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyVirtualBorderRouterAttributeRequest) SetOwnerId(v int64) *ModifyVirtualBorderRouterAttributeRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyVirtualBorderRouterAttributeRequest) SetPeerGatewayIp(v string) *ModifyVirtualBorderRouterAttributeRequest {
	s.PeerGatewayIp = &v
	return s
}

func (s *ModifyVirtualBorderRouterAttributeRequest) SetPeerIpv6GatewayIp(v string) *ModifyVirtualBorderRouterAttributeRequest {
	s.PeerIpv6GatewayIp = &v
	return s
}

func (s *ModifyVirtualBorderRouterAttributeRequest) SetPeeringIpv6SubnetMask(v string) *ModifyVirtualBorderRouterAttributeRequest {
	s.PeeringIpv6SubnetMask = &v
	return s
}

func (s *ModifyVirtualBorderRouterAttributeRequest) SetPeeringSubnetMask(v string) *ModifyVirtualBorderRouterAttributeRequest {
	s.PeeringSubnetMask = &v
	return s
}

func (s *ModifyVirtualBorderRouterAttributeRequest) SetRegionId(v string) *ModifyVirtualBorderRouterAttributeRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyVirtualBorderRouterAttributeRequest) SetResourceOwnerAccount(v string) *ModifyVirtualBorderRouterAttributeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyVirtualBorderRouterAttributeRequest) SetResourceOwnerId(v int64) *ModifyVirtualBorderRouterAttributeRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ModifyVirtualBorderRouterAttributeRequest) SetVbrId(v string) *ModifyVirtualBorderRouterAttributeRequest {
	s.VbrId = &v
	return s
}

func (s *ModifyVirtualBorderRouterAttributeRequest) SetVlanId(v int32) *ModifyVirtualBorderRouterAttributeRequest {
	s.VlanId = &v
	return s
}

type ModifyVirtualBorderRouterAttributeResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyVirtualBorderRouterAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyVirtualBorderRouterAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyVirtualBorderRouterAttributeResponseBody) SetRequestId(v string) *ModifyVirtualBorderRouterAttributeResponseBody {
	s.RequestId = &v
	return s
}

type ModifyVirtualBorderRouterAttributeResponse struct {
	Headers    map[string]*string                              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyVirtualBorderRouterAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyVirtualBorderRouterAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyVirtualBorderRouterAttributeResponse) GoString() string {
	return s.String()
}

func (s *ModifyVirtualBorderRouterAttributeResponse) SetHeaders(v map[string]*string) *ModifyVirtualBorderRouterAttributeResponse {
	s.Headers = v
	return s
}

func (s *ModifyVirtualBorderRouterAttributeResponse) SetStatusCode(v int32) *ModifyVirtualBorderRouterAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyVirtualBorderRouterAttributeResponse) SetBody(v *ModifyVirtualBorderRouterAttributeResponseBody) *ModifyVirtualBorderRouterAttributeResponse {
	s.Body = v
	return s
}

type ModifyVpcAttributeRequest struct {
	// The new IPv4 CIDR block of the VPC.
	//
	// You can specify a larger or smaller IPv4 CIDR block than the IPv4 CIDR block of the VPC. The subnet mask must be 8 to 28 bits in length. If you specify a smaller IPv4 CIDR block and existing IP addresses do not fall within the CIDR block, the modification fails.
	//
	// >  Your services are not affected when you modify the VPC CIDR block.
	CidrBlock *string `json:"CidrBlock,omitempty" xml:"CidrBlock,omitempty"`
	// The new description of the VPC.
	//
	// The description must be 1 to 256 characters in length, and cannot start with `http://` or `https://`.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// Specifies whether to enable IPv6 CIDR blocks. Valid values:
	//
	// *   **true**: yes
	// *   **false** (default): no
	EnableIPv6 *bool `json:"EnableIPv6,omitempty" xml:"EnableIPv6,omitempty"`
	// The IPv6 CIDR block of the VPC.
	Ipv6CidrBlock *string `json:"Ipv6CidrBlock,omitempty" xml:"Ipv6CidrBlock,omitempty"`
	// The type of IPv6 CIDR block. Valid values:
	//
	// *   **BGP** (default): Alibaba Cloud Border Gateway Protocol (BGP) IPv6
	// *   **ChinaMobile**: China Mobile (single ISP)
	// *   **ChinaUnicom**: China Unicom (single ISP)
	// *   **ChinaTelecom**: China Telecom (single ISP)
	//
	// >  If your Alibaba Cloud account is allowed to use single-ISP bandwidth, valid values are: **ChinaTelecom**, **ChinaUnicom**, and **ChinaMobile**.
	Ipv6Isp      *string `json:"Ipv6Isp,omitempty" xml:"Ipv6Isp,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the VPC.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the VPC that you want to modify.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
	// The new name of the VPC.
	//
	// The name must be 1 to 128 characters in length, and cannot start with `http://` or `https://`.
	VpcName *string `json:"VpcName,omitempty" xml:"VpcName,omitempty"`
}

func (s ModifyVpcAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyVpcAttributeRequest) GoString() string {
	return s.String()
}

func (s *ModifyVpcAttributeRequest) SetCidrBlock(v string) *ModifyVpcAttributeRequest {
	s.CidrBlock = &v
	return s
}

func (s *ModifyVpcAttributeRequest) SetDescription(v string) *ModifyVpcAttributeRequest {
	s.Description = &v
	return s
}

func (s *ModifyVpcAttributeRequest) SetEnableIPv6(v bool) *ModifyVpcAttributeRequest {
	s.EnableIPv6 = &v
	return s
}

func (s *ModifyVpcAttributeRequest) SetIpv6CidrBlock(v string) *ModifyVpcAttributeRequest {
	s.Ipv6CidrBlock = &v
	return s
}

func (s *ModifyVpcAttributeRequest) SetIpv6Isp(v string) *ModifyVpcAttributeRequest {
	s.Ipv6Isp = &v
	return s
}

func (s *ModifyVpcAttributeRequest) SetOwnerAccount(v string) *ModifyVpcAttributeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyVpcAttributeRequest) SetOwnerId(v int64) *ModifyVpcAttributeRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyVpcAttributeRequest) SetRegionId(v string) *ModifyVpcAttributeRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyVpcAttributeRequest) SetResourceOwnerAccount(v string) *ModifyVpcAttributeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyVpcAttributeRequest) SetResourceOwnerId(v int64) *ModifyVpcAttributeRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ModifyVpcAttributeRequest) SetVpcId(v string) *ModifyVpcAttributeRequest {
	s.VpcId = &v
	return s
}

func (s *ModifyVpcAttributeRequest) SetVpcName(v string) *ModifyVpcAttributeRequest {
	s.VpcName = &v
	return s
}

type ModifyVpcAttributeResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyVpcAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyVpcAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyVpcAttributeResponseBody) SetRequestId(v string) *ModifyVpcAttributeResponseBody {
	s.RequestId = &v
	return s
}

type ModifyVpcAttributeResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyVpcAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyVpcAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyVpcAttributeResponse) GoString() string {
	return s.String()
}

func (s *ModifyVpcAttributeResponse) SetHeaders(v map[string]*string) *ModifyVpcAttributeResponse {
	s.Headers = v
	return s
}

func (s *ModifyVpcAttributeResponse) SetStatusCode(v int32) *ModifyVpcAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyVpcAttributeResponse) SetBody(v *ModifyVpcAttributeResponseBody) *ModifyVpcAttributeResponse {
	s.Body = v
	return s
}

type ModifyVpcPrefixListRequest struct {
	AddPrefixListEntry []*ModifyVpcPrefixListRequestAddPrefixListEntry `json:"AddPrefixListEntry,omitempty" xml:"AddPrefixListEntry,omitempty" type:"Repeated"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can contain only ASCII characters.
	//
	// >  If you do not specify this parameter, the system uses **RequestId** as **ClientToken**. **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to only precheck the request. Valid values:
	//
	// *   **true**: checks the request without performing the operation. The system prechecks the required parameters, request syntax, and limits. If the request fails the precheck, an error message is returned. If the request passes the precheck, the `DryRunOperation` error code is returned.
	// *   **false** (default): sends the request. If the request passes the check, a 2xx HTTP status code is returned and the operation is performed.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The maximum number of CIDR blocks supported by the prefix list after the configuration of the prefix list is modified.
	MaxEntries   *int32  `json:"MaxEntries,omitempty" xml:"MaxEntries,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The new description of the prefix list.
	//
	// The description must be 1 to 256 characters in length, and cannot start with `http://` or `https://`.
	PrefixListDescription *string `json:"PrefixListDescription,omitempty" xml:"PrefixListDescription,omitempty"`
	// The ID of the prefix list.
	PrefixListId *string `json:"PrefixListId,omitempty" xml:"PrefixListId,omitempty"`
	// The new name of the prefix list.
	//
	// The name must be 1 to 128 characters in length, and cannot start with `http://` or `https://`.
	PrefixListName *string `json:"PrefixListName,omitempty" xml:"PrefixListName,omitempty"`
	// The region ID of the prefix list.
	RegionId              *string                                            `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	RemovePrefixListEntry []*ModifyVpcPrefixListRequestRemovePrefixListEntry `json:"RemovePrefixListEntry,omitempty" xml:"RemovePrefixListEntry,omitempty" type:"Repeated"`
	ResourceOwnerAccount  *string                                            `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId       *int64                                             `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ModifyVpcPrefixListRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyVpcPrefixListRequest) GoString() string {
	return s.String()
}

func (s *ModifyVpcPrefixListRequest) SetAddPrefixListEntry(v []*ModifyVpcPrefixListRequestAddPrefixListEntry) *ModifyVpcPrefixListRequest {
	s.AddPrefixListEntry = v
	return s
}

func (s *ModifyVpcPrefixListRequest) SetClientToken(v string) *ModifyVpcPrefixListRequest {
	s.ClientToken = &v
	return s
}

func (s *ModifyVpcPrefixListRequest) SetDryRun(v bool) *ModifyVpcPrefixListRequest {
	s.DryRun = &v
	return s
}

func (s *ModifyVpcPrefixListRequest) SetMaxEntries(v int32) *ModifyVpcPrefixListRequest {
	s.MaxEntries = &v
	return s
}

func (s *ModifyVpcPrefixListRequest) SetOwnerAccount(v string) *ModifyVpcPrefixListRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyVpcPrefixListRequest) SetOwnerId(v int64) *ModifyVpcPrefixListRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyVpcPrefixListRequest) SetPrefixListDescription(v string) *ModifyVpcPrefixListRequest {
	s.PrefixListDescription = &v
	return s
}

func (s *ModifyVpcPrefixListRequest) SetPrefixListId(v string) *ModifyVpcPrefixListRequest {
	s.PrefixListId = &v
	return s
}

func (s *ModifyVpcPrefixListRequest) SetPrefixListName(v string) *ModifyVpcPrefixListRequest {
	s.PrefixListName = &v
	return s
}

func (s *ModifyVpcPrefixListRequest) SetRegionId(v string) *ModifyVpcPrefixListRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyVpcPrefixListRequest) SetRemovePrefixListEntry(v []*ModifyVpcPrefixListRequestRemovePrefixListEntry) *ModifyVpcPrefixListRequest {
	s.RemovePrefixListEntry = v
	return s
}

func (s *ModifyVpcPrefixListRequest) SetResourceOwnerAccount(v string) *ModifyVpcPrefixListRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyVpcPrefixListRequest) SetResourceOwnerId(v int64) *ModifyVpcPrefixListRequest {
	s.ResourceOwnerId = &v
	return s
}

type ModifyVpcPrefixListRequestAddPrefixListEntry struct {
	// The CIDR block to be added to the prefix list.
	//
	// >  If the CIDR block already exists in the prefix list, you can only modify the description of the CIDR block by setting the **AddPrefixListEntry.N.Description** parameter.
	Cidr *string `json:"Cidr,omitempty" xml:"Cidr,omitempty"`
	// The description of the CIDR block to be added to the prefix list.
	//
	// The description must be 1 to 256 characters in length, and cannot start with `http://` or `https://`.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
}

func (s ModifyVpcPrefixListRequestAddPrefixListEntry) String() string {
	return tea.Prettify(s)
}

func (s ModifyVpcPrefixListRequestAddPrefixListEntry) GoString() string {
	return s.String()
}

func (s *ModifyVpcPrefixListRequestAddPrefixListEntry) SetCidr(v string) *ModifyVpcPrefixListRequestAddPrefixListEntry {
	s.Cidr = &v
	return s
}

func (s *ModifyVpcPrefixListRequestAddPrefixListEntry) SetDescription(v string) *ModifyVpcPrefixListRequestAddPrefixListEntry {
	s.Description = &v
	return s
}

type ModifyVpcPrefixListRequestRemovePrefixListEntry struct {
	// The CIDR block that you want to delete from the prefix list.
	Cidr *string `json:"Cidr,omitempty" xml:"Cidr,omitempty"`
	// The description of the CIDR block that you want to delete.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
}

func (s ModifyVpcPrefixListRequestRemovePrefixListEntry) String() string {
	return tea.Prettify(s)
}

func (s ModifyVpcPrefixListRequestRemovePrefixListEntry) GoString() string {
	return s.String()
}

func (s *ModifyVpcPrefixListRequestRemovePrefixListEntry) SetCidr(v string) *ModifyVpcPrefixListRequestRemovePrefixListEntry {
	s.Cidr = &v
	return s
}

func (s *ModifyVpcPrefixListRequestRemovePrefixListEntry) SetDescription(v string) *ModifyVpcPrefixListRequestRemovePrefixListEntry {
	s.Description = &v
	return s
}

type ModifyVpcPrefixListResponseBody struct {
	// The ID of the prefix list.
	PrefixListId *string `json:"PrefixListId,omitempty" xml:"PrefixListId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyVpcPrefixListResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyVpcPrefixListResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyVpcPrefixListResponseBody) SetPrefixListId(v string) *ModifyVpcPrefixListResponseBody {
	s.PrefixListId = &v
	return s
}

func (s *ModifyVpcPrefixListResponseBody) SetRequestId(v string) *ModifyVpcPrefixListResponseBody {
	s.RequestId = &v
	return s
}

type ModifyVpcPrefixListResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyVpcPrefixListResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyVpcPrefixListResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyVpcPrefixListResponse) GoString() string {
	return s.String()
}

func (s *ModifyVpcPrefixListResponse) SetHeaders(v map[string]*string) *ModifyVpcPrefixListResponse {
	s.Headers = v
	return s
}

func (s *ModifyVpcPrefixListResponse) SetStatusCode(v int32) *ModifyVpcPrefixListResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyVpcPrefixListResponse) SetBody(v *ModifyVpcPrefixListResponseBody) *ModifyVpcPrefixListResponse {
	s.Body = v
	return s
}

type ModifyVpnAttachmentAttributeRequest struct {
	// Specifies whether to automatically configure routes. Valid values:
	//
	// *   **true:** automatically configures routes.
	// *   **false:** does not automatically configure routes.
	AutoConfigRoute *bool `json:"AutoConfigRoute,omitempty" xml:"AutoConfigRoute,omitempty"`
	// The Border Gateway Protocol (BGP) configurations:
	//
	// *   **BgpConfig.EnableBgp:** specifies whether to enable BGP. Valid values:
	//
	//     *   **true:** enables BGP.
	//     *   **false:** disables BGP.
	//
	// *   **BgpConfig.LocalAsn:** the autonomous system number (ASN) on the Alibaba Cloud side. Valid values: **1** to **4294967295**.
	//
	// *   **BgpConfig.TunnelCidr:** the CIDR block of the IPsec tunnel. The CIDR block must belong to 169.254.0.0/16. The subnet mask of the CIDR block must be 30 bits in length.
	//
	// *   **LocalBgpIp:** the BGP IP address on the Alibaba Cloud side. This IP address must fall within the CIDR block of the IPsec tunnel.
	//
	// >
	// *   Before you configure BGP, we recommend that you learn about how BGP works and the limits. For more information, see [VPN Gateway supports BGP dynamic routing](~~170235~~).
	// *   We recommend that you use a private ASN to establish a connection to Alibaba Cloud over BGP. Refer to the relevant documentation for the private ASN range.
	BgpConfig *string `json:"BgpConfig,omitempty" xml:"BgpConfig,omitempty"`
	// The client token that you want to use to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters.
	//
	// >  If you do not specify this parameter, the system uses the value of **RequestId** as the value of **ClientToken**. The value of the **RequestId** parameter may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The customer gateways to be associated with the IPsec-VPN connections.
	CustomerGatewayId *string `json:"CustomerGatewayId,omitempty" xml:"CustomerGatewayId,omitempty"`
	// Specifies whether to immediately start IPsec negotiations after the configuration is complete. Valid values:
	//
	// *   **true:** immediately starts IPsec negotiations after the configuration is complete.
	// *   **false:** starts IPsec negotiations when inbound traffic is detected.
	EffectImmediately *bool `json:"EffectImmediately,omitempty" xml:"EffectImmediately,omitempty"`
	// Specifies whether to enable the dead peer detection (DPD) feature. Valid values:
	//
	// *   **true:** enables the DPD feature. The initiator of the IPsec-VPN connection sends DPD packets to verify the peer is active. If no feedback is received from the peer within a specified period of time, the connection fails, and ISAKMP SA, IPsec SA, and security tunnel are deleted.
	// *   **false:** disables the DPD feature. The initiator of the IPsec-VPN connection does not send DPD packets.
	EnableDpd *bool `json:"EnableDpd,omitempty" xml:"EnableDpd,omitempty"`
	// Specifies whether to enable NAT traversal. Valid values:
	//
	// *   **true:** enables NAT traversal. After NAT traversal is enabled, the initiator does not check the UDP ports during IKE negotiations and can automatically discover NAT gateway devices along the IPsec tunnel.
	// *   **false:** disables NAT traversal.
	EnableNatTraversal *bool `json:"EnableNatTraversal,omitempty" xml:"EnableNatTraversal,omitempty"`
	// The health check configurations:
	//
	// *   **HealthCheckConfig.enable:** specifies whether to enable the health check feature. Valid values:
	//
	//     *   **true:** enables the health check feature.
	//     *   **false:** disables the health check feature.
	//
	// *   **HealthCheckConfig.dip:** the destination IP address that is used for health checks. Enter the IP address on the data center side that the VPC can communicate with through the IPsec-VPN connection.
	//
	// *   **HealthCheckConfig.sip:** the source IP address that is used for health checks. Enter the IP address on the VPC side that the data center can communicate with through the IPsec-VPN connection.
	//
	// *   **HealthCheckConfig.interval:** the interval between two consecutive health checks. Unit: seconds.
	//
	// *   **HealthCheckConfig.retry:** the maximum number of health check retries.
	//
	// *   **HealthCheckConfig.Policy:** specifies whether to withdraw published routes when health checks fail. Valid values:
	//
	//     *   **revoke_route:** withdraw published routes when health checks fail.
	//     *   **reserve_route:** does not withdraw published routes when health checks fail.
	HealthCheckConfig *string `json:"HealthCheckConfig,omitempty" xml:"HealthCheckConfig,omitempty"`
	// The configurations of Phase 1 negotiations:
	//
	// *   **IkeConfig.Psk:** The pre-shared key that is used for authentication between the VPN gateway and the data center. The key must be 1 to 100 characters in length.
	//
	//     The pre-shared key of the IPsec-VPN connection must be the same as the authentication key of the data center. Otherwise, you cannot establish a connection between the data center and the VPN gateway.
	//
	// *   **IkeConfig.IkeVersion:** the version of the IKE protocol. Valid values: **ikev1** and **ikev2**.
	//
	// *   **IkeConfig.IkeMode:** the negotiation mode. Valid values: **main** and **aggressive**.
	//
	// *   **IkeConfig.IkeEncAlg:** the encryption algorithm that is used in Phase 1 negotiations. Valid values: **aes**, **aes192**, **aes256**, **des**, and **3des**.
	//
	// *   **IkeConfig.IkeAuthAlg:** the authentication algorithm that is used in Phase 1 negotiations. Valid values: **md5**, **sha1**, **sha256**, **sha384**, and **sha512**.
	//
	// *   **IkeConfig.IkePfs:** the Diffie-Hellman key exchange algorithm that is used in Phase 1 negotiations. Valid values: **group1**, **group2**, **group5**, and **group14**.
	//
	// *   **IkeConfig.IkeLifetime:** the security association (SA) lifetime that is determined by Phase 1 negotiations. Unit: seconds. Valid values: **0** to **86400**.
	//
	// *   **IkeConfig.LocalIdIPsec:** the identifier on the Alibaba Cloud side. The identifier cannot exceed 100 characters in length.
	//
	// *   **IkeConfig.RemoteId:** the identifier on the data center side. The identifier cannot exceed 100 characters in length.
	IkeConfig *string `json:"IkeConfig,omitempty" xml:"IkeConfig,omitempty"`
	// The configurations of Phase 2 negotiations:
	//
	// *   **IpsecConfig.IpsecEncAlg:** the encryption algorithm that is used in Phase 2 negotiations. Valid values: **aes**, **aes192**, **aes256**, **des**, and **3des**.
	// *   **IpsecConfig. IpsecAuthAlg:** the authentication algorithm that is used in Phase 2 negotiations. Valid values: **md5**, **sha1**, **sha256**, **sha384**, and **sha512**.
	// *   **IpsecConfig. IpsecPfs:** the Diffie-Hellman key exchange algorithm that is used in Phase 2 negotiations. Valid values: **disabled**, **group1**, **group2**, **group5**, and **group14**.
	// *   **IpsecConfig. IpsecLifetime:** the SA lifetime that is determined by Phase 2 negotiations. Unit: seconds. Valid values: **0** to **86400**.
	IpsecConfig *string `json:"IpsecConfig,omitempty" xml:"IpsecConfig,omitempty"`
	// The CIDR block on the VPC side. The CIDR block is used in Phase 2 negotiations.
	//
	// Separate multiple CIDR blocks with commas (,). Example: 192.168.1.0/24,192.168.2.0/24.
	//
	// The following routing modes are supported:
	//
	// *   If you set **LocalSubnet** and **RemoteSubnet** to 0.0.0.0/0, the routing mode of the IPsec-VPN connection is set to Destination Routing Mode.
	// *   If you set **LocalSubnet** and **RemoteSubnet** to specific CIDR blocks, the routing mode of the IPsec-VPN connection is set to Protected Data Flows.
	LocalSubnet *string `json:"LocalSubnet,omitempty" xml:"LocalSubnet,omitempty"`
	// The name of the IPsec-VPN connection.
	//
	// The name must be 1 to 100 characters in length and cannot start with `http://` or `https://`.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The network type of the IPsec-VPN connection. Valid values:
	//
	// *   **public:** an encrypted connection over the Internet.
	// *   **private:** an encrypted connection over private networks.
	NetworkType  *string `json:"NetworkType,omitempty" xml:"NetworkType,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	// The ID of the region to which the IPsec-VPN connection belongs.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the IDs of available regions.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The peer CA certificate when a ShangMi (SM) VPN gateway is used to create the IPsec-VPN connection.
	RemoteCaCert *string `json:"RemoteCaCert,omitempty" xml:"RemoteCaCert,omitempty"`
	// The CIDR block on the data center side. This CIDR block is used in Phase 2 negotiations.
	//
	// Separate multiple CIDR blocks with commas (,). Example: 192.168.3.0/24,192.168.4.0/24.
	//
	// The following routing modes are supported:
	//
	// *   If you set **LocalSubnet** and **RemoteSubnet** to 0.0.0.0/0, the routing mode of the IPsec-VPN connection is set to Destination Routing Mode.
	// *   If you set **LocalSubnet** and **RemoteSubnet** to specific CIDR blocks, the routing mode of the IPsec-VPN connection is set to Protected Data Flows.
	RemoteSubnet         *string `json:"RemoteSubnet,omitempty" xml:"RemoteSubnet,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the IPsec-VPN connection.
	VpnConnectionId *string `json:"VpnConnectionId,omitempty" xml:"VpnConnectionId,omitempty"`
}

func (s ModifyVpnAttachmentAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyVpnAttachmentAttributeRequest) GoString() string {
	return s.String()
}

func (s *ModifyVpnAttachmentAttributeRequest) SetAutoConfigRoute(v bool) *ModifyVpnAttachmentAttributeRequest {
	s.AutoConfigRoute = &v
	return s
}

func (s *ModifyVpnAttachmentAttributeRequest) SetBgpConfig(v string) *ModifyVpnAttachmentAttributeRequest {
	s.BgpConfig = &v
	return s
}

func (s *ModifyVpnAttachmentAttributeRequest) SetClientToken(v string) *ModifyVpnAttachmentAttributeRequest {
	s.ClientToken = &v
	return s
}

func (s *ModifyVpnAttachmentAttributeRequest) SetCustomerGatewayId(v string) *ModifyVpnAttachmentAttributeRequest {
	s.CustomerGatewayId = &v
	return s
}

func (s *ModifyVpnAttachmentAttributeRequest) SetEffectImmediately(v bool) *ModifyVpnAttachmentAttributeRequest {
	s.EffectImmediately = &v
	return s
}

func (s *ModifyVpnAttachmentAttributeRequest) SetEnableDpd(v bool) *ModifyVpnAttachmentAttributeRequest {
	s.EnableDpd = &v
	return s
}

func (s *ModifyVpnAttachmentAttributeRequest) SetEnableNatTraversal(v bool) *ModifyVpnAttachmentAttributeRequest {
	s.EnableNatTraversal = &v
	return s
}

func (s *ModifyVpnAttachmentAttributeRequest) SetHealthCheckConfig(v string) *ModifyVpnAttachmentAttributeRequest {
	s.HealthCheckConfig = &v
	return s
}

func (s *ModifyVpnAttachmentAttributeRequest) SetIkeConfig(v string) *ModifyVpnAttachmentAttributeRequest {
	s.IkeConfig = &v
	return s
}

func (s *ModifyVpnAttachmentAttributeRequest) SetIpsecConfig(v string) *ModifyVpnAttachmentAttributeRequest {
	s.IpsecConfig = &v
	return s
}

func (s *ModifyVpnAttachmentAttributeRequest) SetLocalSubnet(v string) *ModifyVpnAttachmentAttributeRequest {
	s.LocalSubnet = &v
	return s
}

func (s *ModifyVpnAttachmentAttributeRequest) SetName(v string) *ModifyVpnAttachmentAttributeRequest {
	s.Name = &v
	return s
}

func (s *ModifyVpnAttachmentAttributeRequest) SetNetworkType(v string) *ModifyVpnAttachmentAttributeRequest {
	s.NetworkType = &v
	return s
}

func (s *ModifyVpnAttachmentAttributeRequest) SetOwnerAccount(v string) *ModifyVpnAttachmentAttributeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyVpnAttachmentAttributeRequest) SetRegionId(v string) *ModifyVpnAttachmentAttributeRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyVpnAttachmentAttributeRequest) SetRemoteCaCert(v string) *ModifyVpnAttachmentAttributeRequest {
	s.RemoteCaCert = &v
	return s
}

func (s *ModifyVpnAttachmentAttributeRequest) SetRemoteSubnet(v string) *ModifyVpnAttachmentAttributeRequest {
	s.RemoteSubnet = &v
	return s
}

func (s *ModifyVpnAttachmentAttributeRequest) SetResourceOwnerAccount(v string) *ModifyVpnAttachmentAttributeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyVpnAttachmentAttributeRequest) SetResourceOwnerId(v int64) *ModifyVpnAttachmentAttributeRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ModifyVpnAttachmentAttributeRequest) SetVpnConnectionId(v string) *ModifyVpnAttachmentAttributeRequest {
	s.VpnConnectionId = &v
	return s
}

type ModifyVpnAttachmentAttributeResponseBody struct {
	// The ID of the Cloud Enterprise Network (CEN) instance to which the transit router associated with the IPsec-VPN connection belongs.
	AttachInstanceId *string `json:"AttachInstanceId,omitempty" xml:"AttachInstanceId,omitempty"`
	// The type of resource that is associated with the IPsec-VPN connection.
	//
	// *   **CEN:** indicates that the IPsec-VPN connection is associated with a transit router.
	// *   **VPNGW:** indicates that the IPsec-VPN connection is associated with a VPN gateway.
	// *   **NO_ASSOCIATED:** indicates that the IPsec-VPN connection is not associated with any resource.
	AttachType *string `json:"AttachType,omitempty" xml:"AttachType,omitempty"`
	// The timestamp generated when the IPsec-VPN connection was established. Unit: milliseconds.
	//
	// This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The ID of the customer gateway associated with the IPsec-VPN connection.
	CustomerGatewayId *string `json:"CustomerGatewayId,omitempty" xml:"CustomerGatewayId,omitempty"`
	// The description of the IPsec-VPN connection.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// Indicates whether IPsec negotiations immediately start after the configuration is complete. Valid values:
	//
	// *   **true:** IPsec negotiations immediately start after the configuration is complete.
	// *   **false:** IPsec negotiations start when inbound traffic is detected.
	EffectImmediately *bool `json:"EffectImmediately,omitempty" xml:"EffectImmediately,omitempty"`
	// Indicates whether the DPD feature is enabled for the IPsec-VPN connection.
	//
	// *   **true:** The DPD feature is enabled.
	// *   **false:** The DPD feature is disabled.
	EnableDpd *bool `json:"EnableDpd,omitempty" xml:"EnableDpd,omitempty"`
	// Indicates whether NAT traversal is enabled for the IPsec-VPN connection.
	//
	// *   **true:** NAT traversal is enabled.
	// *   **false:** NAT traversal is disabled.
	EnableNatTraversal *bool `json:"EnableNatTraversal,omitempty" xml:"EnableNatTraversal,omitempty"`
	// The configurations of Phase 1 negotiations.
	IkeConfig *ModifyVpnAttachmentAttributeResponseBodyIkeConfig `json:"IkeConfig,omitempty" xml:"IkeConfig,omitempty" type:"Struct"`
	// The configurations of Phase 2 negotiations.
	IpsecConfig *ModifyVpnAttachmentAttributeResponseBodyIpsecConfig `json:"IpsecConfig,omitempty" xml:"IpsecConfig,omitempty" type:"Struct"`
	// The CIDR block on the VPC side.
	LocalSubnet *string `json:"LocalSubnet,omitempty" xml:"LocalSubnet,omitempty"`
	// The name of the IPsec-VPN connection.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The network type of the IPsec-VPN connection.
	//
	// *   **public:** Internet.
	// *   **private:** private networks.
	NetworkType *string `json:"NetworkType,omitempty" xml:"NetworkType,omitempty"`
	// The CIDR block on the data center side.
	RemoteSubnet *string `json:"RemoteSubnet,omitempty" xml:"RemoteSubnet,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The bandwidth specification of the IPsec-VPN connection.
	//
	// **M** in the response indicates **Mbit/s**.
	Spec *string `json:"Spec,omitempty" xml:"Spec,omitempty"`
	// The status of the IPsec-VPN connection.
	//
	// *   **ike_sa_not_established:** Phase 1 negotiations failed.
	// *   **ike_sa_established:** Phase 1 negotiations were successful.
	// *   **ipsec_sa_not_established:** Phase 2 negotiations failed.
	// *   **ipsec_sa_established:** Phase 2 negotiations were successful.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The health check configurations of the IPsec-VPN connection.
	VcoHealthCheck *ModifyVpnAttachmentAttributeResponseBodyVcoHealthCheck `json:"VcoHealthCheck,omitempty" xml:"VcoHealthCheck,omitempty" type:"Struct"`
	// The BGP configurations of the IPsec-VPN connection.
	VpnBgpConfig *ModifyVpnAttachmentAttributeResponseBodyVpnBgpConfig `json:"VpnBgpConfig,omitempty" xml:"VpnBgpConfig,omitempty" type:"Struct"`
	// The ID of the IPsec-VPN connection.
	VpnConnectionId *string `json:"VpnConnectionId,omitempty" xml:"VpnConnectionId,omitempty"`
	// The ID of the VPN gateway associated with the IPsec-VPN connection.
	VpnGatewayId *string `json:"VpnGatewayId,omitempty" xml:"VpnGatewayId,omitempty"`
}

func (s ModifyVpnAttachmentAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyVpnAttachmentAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyVpnAttachmentAttributeResponseBody) SetAttachInstanceId(v string) *ModifyVpnAttachmentAttributeResponseBody {
	s.AttachInstanceId = &v
	return s
}

func (s *ModifyVpnAttachmentAttributeResponseBody) SetAttachType(v string) *ModifyVpnAttachmentAttributeResponseBody {
	s.AttachType = &v
	return s
}

func (s *ModifyVpnAttachmentAttributeResponseBody) SetCreateTime(v int64) *ModifyVpnAttachmentAttributeResponseBody {
	s.CreateTime = &v
	return s
}

func (s *ModifyVpnAttachmentAttributeResponseBody) SetCustomerGatewayId(v string) *ModifyVpnAttachmentAttributeResponseBody {
	s.CustomerGatewayId = &v
	return s
}

func (s *ModifyVpnAttachmentAttributeResponseBody) SetDescription(v string) *ModifyVpnAttachmentAttributeResponseBody {
	s.Description = &v
	return s
}

func (s *ModifyVpnAttachmentAttributeResponseBody) SetEffectImmediately(v bool) *ModifyVpnAttachmentAttributeResponseBody {
	s.EffectImmediately = &v
	return s
}

func (s *ModifyVpnAttachmentAttributeResponseBody) SetEnableDpd(v bool) *ModifyVpnAttachmentAttributeResponseBody {
	s.EnableDpd = &v
	return s
}

func (s *ModifyVpnAttachmentAttributeResponseBody) SetEnableNatTraversal(v bool) *ModifyVpnAttachmentAttributeResponseBody {
	s.EnableNatTraversal = &v
	return s
}

func (s *ModifyVpnAttachmentAttributeResponseBody) SetIkeConfig(v *ModifyVpnAttachmentAttributeResponseBodyIkeConfig) *ModifyVpnAttachmentAttributeResponseBody {
	s.IkeConfig = v
	return s
}

func (s *ModifyVpnAttachmentAttributeResponseBody) SetIpsecConfig(v *ModifyVpnAttachmentAttributeResponseBodyIpsecConfig) *ModifyVpnAttachmentAttributeResponseBody {
	s.IpsecConfig = v
	return s
}

func (s *ModifyVpnAttachmentAttributeResponseBody) SetLocalSubnet(v string) *ModifyVpnAttachmentAttributeResponseBody {
	s.LocalSubnet = &v
	return s
}

func (s *ModifyVpnAttachmentAttributeResponseBody) SetName(v string) *ModifyVpnAttachmentAttributeResponseBody {
	s.Name = &v
	return s
}

func (s *ModifyVpnAttachmentAttributeResponseBody) SetNetworkType(v string) *ModifyVpnAttachmentAttributeResponseBody {
	s.NetworkType = &v
	return s
}

func (s *ModifyVpnAttachmentAttributeResponseBody) SetRemoteSubnet(v string) *ModifyVpnAttachmentAttributeResponseBody {
	s.RemoteSubnet = &v
	return s
}

func (s *ModifyVpnAttachmentAttributeResponseBody) SetRequestId(v string) *ModifyVpnAttachmentAttributeResponseBody {
	s.RequestId = &v
	return s
}

func (s *ModifyVpnAttachmentAttributeResponseBody) SetSpec(v string) *ModifyVpnAttachmentAttributeResponseBody {
	s.Spec = &v
	return s
}

func (s *ModifyVpnAttachmentAttributeResponseBody) SetStatus(v string) *ModifyVpnAttachmentAttributeResponseBody {
	s.Status = &v
	return s
}

func (s *ModifyVpnAttachmentAttributeResponseBody) SetVcoHealthCheck(v *ModifyVpnAttachmentAttributeResponseBodyVcoHealthCheck) *ModifyVpnAttachmentAttributeResponseBody {
	s.VcoHealthCheck = v
	return s
}

func (s *ModifyVpnAttachmentAttributeResponseBody) SetVpnBgpConfig(v *ModifyVpnAttachmentAttributeResponseBodyVpnBgpConfig) *ModifyVpnAttachmentAttributeResponseBody {
	s.VpnBgpConfig = v
	return s
}

func (s *ModifyVpnAttachmentAttributeResponseBody) SetVpnConnectionId(v string) *ModifyVpnAttachmentAttributeResponseBody {
	s.VpnConnectionId = &v
	return s
}

func (s *ModifyVpnAttachmentAttributeResponseBody) SetVpnGatewayId(v string) *ModifyVpnAttachmentAttributeResponseBody {
	s.VpnGatewayId = &v
	return s
}

type ModifyVpnAttachmentAttributeResponseBodyIkeConfig struct {
	// The authentication algorithm that was used in Phase 1 negotiations.
	IkeAuthAlg *string `json:"IkeAuthAlg,omitempty" xml:"IkeAuthAlg,omitempty"`
	// The encryption algorithm that was used in Phase 1 negotiations.
	IkeEncAlg *string `json:"IkeEncAlg,omitempty" xml:"IkeEncAlg,omitempty"`
	// The SA lifetime that was determined by Phase 1 negotiations. Unit: seconds.
	IkeLifetime *int64 `json:"IkeLifetime,omitempty" xml:"IkeLifetime,omitempty"`
	// The negotiation mode.
	IkeMode *string `json:"IkeMode,omitempty" xml:"IkeMode,omitempty"`
	// The Diffie-Hellman key exchange algorithm that was used in Phase 1 negotiations.
	IkePfs *string `json:"IkePfs,omitempty" xml:"IkePfs,omitempty"`
	// The version of the IKE protocol.
	IkeVersion *string `json:"IkeVersion,omitempty" xml:"IkeVersion,omitempty"`
	// The identifier on the Alibaba Cloud side.
	LocalId *string `json:"LocalId,omitempty" xml:"LocalId,omitempty"`
	// The pre-shared key that was used for identity authentication between the VPN gateway and the data center.
	//
	// >  The pre-shared key of the IPsec-VPN connection must be the same as the authentication key of the data center. Otherwise, you cannot establish a connection between the data center and the VPN gateway.
	Psk *string `json:"Psk,omitempty" xml:"Psk,omitempty"`
	// The identifier on the data center side.
	RemoteId *string `json:"RemoteId,omitempty" xml:"RemoteId,omitempty"`
}

func (s ModifyVpnAttachmentAttributeResponseBodyIkeConfig) String() string {
	return tea.Prettify(s)
}

func (s ModifyVpnAttachmentAttributeResponseBodyIkeConfig) GoString() string {
	return s.String()
}

func (s *ModifyVpnAttachmentAttributeResponseBodyIkeConfig) SetIkeAuthAlg(v string) *ModifyVpnAttachmentAttributeResponseBodyIkeConfig {
	s.IkeAuthAlg = &v
	return s
}

func (s *ModifyVpnAttachmentAttributeResponseBodyIkeConfig) SetIkeEncAlg(v string) *ModifyVpnAttachmentAttributeResponseBodyIkeConfig {
	s.IkeEncAlg = &v
	return s
}

func (s *ModifyVpnAttachmentAttributeResponseBodyIkeConfig) SetIkeLifetime(v int64) *ModifyVpnAttachmentAttributeResponseBodyIkeConfig {
	s.IkeLifetime = &v
	return s
}

func (s *ModifyVpnAttachmentAttributeResponseBodyIkeConfig) SetIkeMode(v string) *ModifyVpnAttachmentAttributeResponseBodyIkeConfig {
	s.IkeMode = &v
	return s
}

func (s *ModifyVpnAttachmentAttributeResponseBodyIkeConfig) SetIkePfs(v string) *ModifyVpnAttachmentAttributeResponseBodyIkeConfig {
	s.IkePfs = &v
	return s
}

func (s *ModifyVpnAttachmentAttributeResponseBodyIkeConfig) SetIkeVersion(v string) *ModifyVpnAttachmentAttributeResponseBodyIkeConfig {
	s.IkeVersion = &v
	return s
}

func (s *ModifyVpnAttachmentAttributeResponseBodyIkeConfig) SetLocalId(v string) *ModifyVpnAttachmentAttributeResponseBodyIkeConfig {
	s.LocalId = &v
	return s
}

func (s *ModifyVpnAttachmentAttributeResponseBodyIkeConfig) SetPsk(v string) *ModifyVpnAttachmentAttributeResponseBodyIkeConfig {
	s.Psk = &v
	return s
}

func (s *ModifyVpnAttachmentAttributeResponseBodyIkeConfig) SetRemoteId(v string) *ModifyVpnAttachmentAttributeResponseBodyIkeConfig {
	s.RemoteId = &v
	return s
}

type ModifyVpnAttachmentAttributeResponseBodyIpsecConfig struct {
	// The authentication algorithm that was used in Phase 2 negotiations.
	IpsecAuthAlg *string `json:"IpsecAuthAlg,omitempty" xml:"IpsecAuthAlg,omitempty"`
	// The encryption algorithm that was used in Phase 2 negotiations.
	IpsecEncAlg *string `json:"IpsecEncAlg,omitempty" xml:"IpsecEncAlg,omitempty"`
	// The SA lifetime that was determined by Phase 2 negotiations. Unit: seconds.
	IpsecLifetime *int64 `json:"IpsecLifetime,omitempty" xml:"IpsecLifetime,omitempty"`
	// The Diffie-Hellman key exchange algorithm that was used in Phase 2 negotiations.
	IpsecPfs *string `json:"IpsecPfs,omitempty" xml:"IpsecPfs,omitempty"`
}

func (s ModifyVpnAttachmentAttributeResponseBodyIpsecConfig) String() string {
	return tea.Prettify(s)
}

func (s ModifyVpnAttachmentAttributeResponseBodyIpsecConfig) GoString() string {
	return s.String()
}

func (s *ModifyVpnAttachmentAttributeResponseBodyIpsecConfig) SetIpsecAuthAlg(v string) *ModifyVpnAttachmentAttributeResponseBodyIpsecConfig {
	s.IpsecAuthAlg = &v
	return s
}

func (s *ModifyVpnAttachmentAttributeResponseBodyIpsecConfig) SetIpsecEncAlg(v string) *ModifyVpnAttachmentAttributeResponseBodyIpsecConfig {
	s.IpsecEncAlg = &v
	return s
}

func (s *ModifyVpnAttachmentAttributeResponseBodyIpsecConfig) SetIpsecLifetime(v int64) *ModifyVpnAttachmentAttributeResponseBodyIpsecConfig {
	s.IpsecLifetime = &v
	return s
}

func (s *ModifyVpnAttachmentAttributeResponseBodyIpsecConfig) SetIpsecPfs(v string) *ModifyVpnAttachmentAttributeResponseBodyIpsecConfig {
	s.IpsecPfs = &v
	return s
}

type ModifyVpnAttachmentAttributeResponseBodyVcoHealthCheck struct {
	// The destination IP address that was used for health checks.
	Dip *string `json:"Dip,omitempty" xml:"Dip,omitempty"`
	// Indicates whether the health check feature is enabled for the IPsec-VPN connection.
	//
	// *   **true:** The health check feature is enabled.
	// *   **false:** The health check feature is disabled.
	Enable *string `json:"Enable,omitempty" xml:"Enable,omitempty"`
	// The interval between two consecutive health check retries. Unit: seconds.
	Interval *int32 `json:"Interval,omitempty" xml:"Interval,omitempty"`
	// Indicates whether published routes are withdrawn when the health check fails.
	//
	// *   **revoke_route:** Published routes were withdrawn when the health check failed.
	// *   **reserve_route:** Published routes were not withdrawn when the health check failed.
	Policy *string `json:"Policy,omitempty" xml:"Policy,omitempty"`
	// The maximum number of health check retries.
	Retry *int32 `json:"Retry,omitempty" xml:"Retry,omitempty"`
	// The source IP address that was used for health checks.
	Sip *string `json:"Sip,omitempty" xml:"Sip,omitempty"`
}

func (s ModifyVpnAttachmentAttributeResponseBodyVcoHealthCheck) String() string {
	return tea.Prettify(s)
}

func (s ModifyVpnAttachmentAttributeResponseBodyVcoHealthCheck) GoString() string {
	return s.String()
}

func (s *ModifyVpnAttachmentAttributeResponseBodyVcoHealthCheck) SetDip(v string) *ModifyVpnAttachmentAttributeResponseBodyVcoHealthCheck {
	s.Dip = &v
	return s
}

func (s *ModifyVpnAttachmentAttributeResponseBodyVcoHealthCheck) SetEnable(v string) *ModifyVpnAttachmentAttributeResponseBodyVcoHealthCheck {
	s.Enable = &v
	return s
}

func (s *ModifyVpnAttachmentAttributeResponseBodyVcoHealthCheck) SetInterval(v int32) *ModifyVpnAttachmentAttributeResponseBodyVcoHealthCheck {
	s.Interval = &v
	return s
}

func (s *ModifyVpnAttachmentAttributeResponseBodyVcoHealthCheck) SetPolicy(v string) *ModifyVpnAttachmentAttributeResponseBodyVcoHealthCheck {
	s.Policy = &v
	return s
}

func (s *ModifyVpnAttachmentAttributeResponseBodyVcoHealthCheck) SetRetry(v int32) *ModifyVpnAttachmentAttributeResponseBodyVcoHealthCheck {
	s.Retry = &v
	return s
}

func (s *ModifyVpnAttachmentAttributeResponseBodyVcoHealthCheck) SetSip(v string) *ModifyVpnAttachmentAttributeResponseBodyVcoHealthCheck {
	s.Sip = &v
	return s
}

type ModifyVpnAttachmentAttributeResponseBodyVpnBgpConfig struct {
	// Indicates whether BGP is enabled for the IPsec-VPN connection.
	//
	// *   **true:** BGP is enabled.
	// *   **false:** BGP is disabled.
	EnableBgp *string `json:"EnableBgp,omitempty" xml:"EnableBgp,omitempty"`
	// The ASN on the Alibaba Cloud side.
	LocalAsn *int64 `json:"LocalAsn,omitempty" xml:"LocalAsn,omitempty"`
	// The BGP IP address on the Alibaba Cloud side.
	LocalBgpIp *string `json:"LocalBgpIp,omitempty" xml:"LocalBgpIp,omitempty"`
	// The ASN on the data center side.
	PeerAsn *int64 `json:"PeerAsn,omitempty" xml:"PeerAsn,omitempty"`
	// The BGP IP address on the data center side.
	PeerBgpIp *string `json:"PeerBgpIp,omitempty" xml:"PeerBgpIp,omitempty"`
	// The negotiation status of BGP.
	//
	// *   **success:** normal.
	// *   **false:** abnormal.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The CIDR block of the IPsec tunnel.
	TunnelCidr *string `json:"TunnelCidr,omitempty" xml:"TunnelCidr,omitempty"`
}

func (s ModifyVpnAttachmentAttributeResponseBodyVpnBgpConfig) String() string {
	return tea.Prettify(s)
}

func (s ModifyVpnAttachmentAttributeResponseBodyVpnBgpConfig) GoString() string {
	return s.String()
}

func (s *ModifyVpnAttachmentAttributeResponseBodyVpnBgpConfig) SetEnableBgp(v string) *ModifyVpnAttachmentAttributeResponseBodyVpnBgpConfig {
	s.EnableBgp = &v
	return s
}

func (s *ModifyVpnAttachmentAttributeResponseBodyVpnBgpConfig) SetLocalAsn(v int64) *ModifyVpnAttachmentAttributeResponseBodyVpnBgpConfig {
	s.LocalAsn = &v
	return s
}

func (s *ModifyVpnAttachmentAttributeResponseBodyVpnBgpConfig) SetLocalBgpIp(v string) *ModifyVpnAttachmentAttributeResponseBodyVpnBgpConfig {
	s.LocalBgpIp = &v
	return s
}

func (s *ModifyVpnAttachmentAttributeResponseBodyVpnBgpConfig) SetPeerAsn(v int64) *ModifyVpnAttachmentAttributeResponseBodyVpnBgpConfig {
	s.PeerAsn = &v
	return s
}

func (s *ModifyVpnAttachmentAttributeResponseBodyVpnBgpConfig) SetPeerBgpIp(v string) *ModifyVpnAttachmentAttributeResponseBodyVpnBgpConfig {
	s.PeerBgpIp = &v
	return s
}

func (s *ModifyVpnAttachmentAttributeResponseBodyVpnBgpConfig) SetStatus(v string) *ModifyVpnAttachmentAttributeResponseBodyVpnBgpConfig {
	s.Status = &v
	return s
}

func (s *ModifyVpnAttachmentAttributeResponseBodyVpnBgpConfig) SetTunnelCidr(v string) *ModifyVpnAttachmentAttributeResponseBodyVpnBgpConfig {
	s.TunnelCidr = &v
	return s
}

type ModifyVpnAttachmentAttributeResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyVpnAttachmentAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyVpnAttachmentAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyVpnAttachmentAttributeResponse) GoString() string {
	return s.String()
}

func (s *ModifyVpnAttachmentAttributeResponse) SetHeaders(v map[string]*string) *ModifyVpnAttachmentAttributeResponse {
	s.Headers = v
	return s
}

func (s *ModifyVpnAttachmentAttributeResponse) SetStatusCode(v int32) *ModifyVpnAttachmentAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyVpnAttachmentAttributeResponse) SetBody(v *ModifyVpnAttachmentAttributeResponseBody) *ModifyVpnAttachmentAttributeResponse {
	s.Body = v
	return s
}

type ModifyVpnConnectionAttributeRequest struct {
	// Specifies whether to automatically advertise routes. Valid values:
	//
	// *   **true:** automatically advertise routes.
	// *   **false:** does not automatically advertise routes.
	AutoConfigRoute *bool `json:"AutoConfigRoute,omitempty" xml:"AutoConfigRoute,omitempty"`
	// The Border Gateway Protocol (BGP) configurations:
	//
	// *   **BgpConfig.EnableBgp:** specifies whether to enable BGP. Valid values: **true** and **false**.
	// *   **BgpConfig.LocalAsn:** the autonomous system number (ASN) on the Alibaba Cloud side. Valid values: **1** to **4294967295**.
	// *   **BgpConfig.TunnelCidr:** the CIDR block of the IPsec tunnel. The CIDR block must belong to 169.254.0.0/16. The subnet mask of the CIDR block must be 30 bits in length.
	// *   **LocalBgpIp:** the BGP IP address on the Alibaba Cloud side. This IP address must fall within the CIDR block of the IPsec tunnel.
	//
	// >
	// *   This parameter is required when the VPN gateway has dynamic BGP enabled.
	// *   Before you configure BGP, we recommend that you learn about how BGP works and the limits. For more information, see [VPN Gateway supports BGP dynamic routing](~~170235~~).
	// *   We recommend that you use a private ASN to establish a connection to Alibaba Cloud over BGP. Refer to the relevant documentation for the private ASN range.
	BgpConfig *string `json:"BgpConfig,omitempty" xml:"BgpConfig,omitempty"`
	// The client token that you want to use to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters.
	//
	// >  If you do not specify this parameter, the system uses the value of **RequestId** as the value of **ClientToken**. The value of the **RequestId** parameter may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to immediately start IPsec negotiations after the configuration takes effect. Valid values:
	//
	// *   **true:** immediately starts IPsec negotiations after the configuration takes effect.
	// *   **false:** starts IPsec negotiations when inbound traffic is detected.
	EffectImmediately *bool `json:"EffectImmediately,omitempty" xml:"EffectImmediately,omitempty"`
	// Specifies whether to enable the dead peer detection (DPD) feature. Valid values:
	//
	// *   **true:** enables the DPD feature. The initiator of the IPsec-VPN connection sends DPD packets to verify the peer is active. If no feedback is received from the peer within a specified period of time, the connection fails, and ISAKMP SA, IPsec SA, and security tunnel are deleted.
	// *   **false:** disables the DPD feature. The initiator of the IPsec-VPN connection does not send DPD packets.
	EnableDpd *bool `json:"EnableDpd,omitempty" xml:"EnableDpd,omitempty"`
	// Specifies whether to enable NAT traversal. Valid values:
	//
	// *   **true:** enables NAT traversal. After NAT traversal is enabled, the initiator does not check the UDP ports during IKE negotiations and can automatically discover NAT gateway devices along the IPsec tunnel.
	// *   **false:** disables NAT traversal.
	EnableNatTraversal *bool `json:"EnableNatTraversal,omitempty" xml:"EnableNatTraversal,omitempty"`
	EnableTunnelsBgp   *bool `json:"EnableTunnelsBgp,omitempty" xml:"EnableTunnelsBgp,omitempty"`
	// The health check configurations:
	//
	// *   **HealthCheckConfig.enable:** specifies whether to enable the health check feature. Valid values: **true** and **false**.
	// *   **HealthCheckConfig.dip:** the destination IP address that is used for health checks.
	// *   **HealthCheckConfig.sip:** the source IP address that is used for health checks.
	// *   **HealthCheckConfig.interval:** the interval between two consecutive health checks. Unit: seconds.
	// *   **HealthCheckConfig.retry:** the maximum number of health check retries.
	HealthCheckConfig *string `json:"HealthCheckConfig,omitempty" xml:"HealthCheckConfig,omitempty"`
	// The configurations of Phase 1 negotiations:
	//
	// *   **IkeConfig.Psk:** The pre-shared key that is used for authentication between the VPN gateway and the data center. The key must be 1 to 100 characters in length.
	//
	//     If you do not specify a pre-shared key, the system generates a random 16-bit string as the pre-shared key. You can call the [DescribeVpnConnection](~~120374~~) operation to query the pre-shared key that is generated by the system.
	//
	// > The pre-shared key of the IPsec-VPN connection must be the same as the authentication key of the data center. Otherwise, you cannot establish a connection between the data center and the VPN gateway.
	//
	// *   **IkeConfig.IkeVersion:** the version of the IKE protocol. Valid values: **ikev1** and **ikev2**.
	//
	// *   **IkeConfig.IkeMode:** the negotiation mode of IKE V1. Valid values: **main** and **aggressive**.
	//
	// *   **IkeConfig.IkeEncAlg:** the encryption algorithm that is used in Phase 1 negotiations. Valid values: **aes**, **aes192**, **aes256**, **des**, and **3des**.
	//
	// *   **IkeConfig.IkeAuthAlg:** the authentication algorithm that is used in Phase 1 negotiations. Valid values: **md5**, **sha1**, **sha256**, **sha384**, and **sha512**.
	//
	// *   **IkeConfig.IkePfs:** the Diffie-Hellman key exchange algorithm that is used in Phase 1 negotiations. Valid values: **group1**, **group2**, **group5**, and **group14**.
	//
	// *   **IkeConfig.IkeLifetime:** the security association (SA) lifetime that is determined by Phase 1 negotiations. Unit: seconds. Valid values: **0 to 86400**.
	//
	// *   **IkeConfig.LocalId:** the identifier of the VPN gateway. The identifier cannot exceed 100 characters in length. The default value is the IP address of the VPN gateway.
	//
	// *   **IkeConfig.RemoteId:** the identifier of the customer gateway. The identifier cannot exceed 100 characters in length. The default value is the IP address of the customer gateway.
	IkeConfig *string `json:"IkeConfig,omitempty" xml:"IkeConfig,omitempty"`
	// The configurations of Phase 2 negotiations:
	//
	// *   **IpsecConfig.IpsecEncAlg:** the encryption algorithm that is used in Phase 2 negotiations. Valid values: **aes**, **aes192**, **aes256**, **des**, and **3des**.
	// *   **IpsecConfig. IpsecAuthAlg:** the authentication algorithm that is used in Phase 2 negotiations. Valid values: **md5**, **sha1**, **sha256**, **sha384**, and **sha512**.
	// *   **IpsecConfig. IpsecPfs:** the Diffie-Hellman key exchange algorithm that is used in Phase 1 negotiations. If you specify this parameter, packets of all protocols are forwarded. Valid values: **disabled**, **group1**, **group2**, **group5**, and **group14**.
	// *   **IpsecConfig. IpsecLifetime:** the SA lifetime that is determined by Phase 2 negotiations. Unit: seconds. Valid values: **0 to 86400**.
	IpsecConfig *string `json:"IpsecConfig,omitempty" xml:"IpsecConfig,omitempty"`
	// The CIDR block on the virtual private cloud (VPC) side. The CIDR block is used in Phase 2 negotiations.
	//
	// Separate multiple CIDR blocks with commas (,). Example: 192.168.1.0/24,192.168.2.0/24.
	//
	// The following routing modes are supported:
	//
	// *   If you set **LocalSubnet** and **RemoteSubnet** to 0.0.0.0/0, the routing mode of the IPsec-VPN connection is set to Destination Routing Mode.
	// *   If you set **LocalSubnet** and **RemoteSubnet** to specific CIDR blocks, the routing mode of the IPsec-VPN connection is set to Protected Data Flows.
	LocalSubnet *string `json:"LocalSubnet,omitempty" xml:"LocalSubnet,omitempty"`
	// The name of the IPsec-VPN connection.
	//
	// The name must be 1 to 100 characters in length and cannot start with `http://` or `https://`.
	Name         *string `json:"Name,omitempty" xml:"Name,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region where the IPsec-VPN connection is established.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the IDs of available regions.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The peer CA certificate when a ShangMi (SM) VPN gateway is used to establish the IPsec-VPN connection.
	//
	// *   This parameter is required when an SM VPN gateway is used to establish the IPsec-VPN connection.
	// *   You can ignore this parameter when a standard VPN gateway is used to establish the IPsec-VPN connection.
	RemoteCaCertificate *string `json:"RemoteCaCertificate,omitempty" xml:"RemoteCaCertificate,omitempty"`
	// The CIDR block on the data center side. This CIDR block is used in Phase 2 negotiations.
	//
	// Separate multiple CIDR blocks with commas (,). Example: 192.168.3.0/24,192.168.4.0/24.
	//
	// The following routing modes are supported:
	//
	// *   If you set **LocalSubnet** and **RemoteSubnet** to 0.0.0.0/0, the routing mode of the IPsec-VPN connection is set to Destination Routing Mode.
	// *   If you set **LocalSubnet** and **RemoteSubnet** to specific CIDR blocks, the routing mode of the IPsec-VPN connection is set to Protected Data Flows.
	RemoteSubnet               *string                                                          `json:"RemoteSubnet,omitempty" xml:"RemoteSubnet,omitempty"`
	ResourceOwnerAccount       *string                                                          `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId            *int64                                                           `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	TunnelOptionsSpecification []*ModifyVpnConnectionAttributeRequestTunnelOptionsSpecification `json:"TunnelOptionsSpecification,omitempty" xml:"TunnelOptionsSpecification,omitempty" type:"Repeated"`
	// The ID of the IPsec-VPN connection.
	VpnConnectionId *string `json:"VpnConnectionId,omitempty" xml:"VpnConnectionId,omitempty"`
}

func (s ModifyVpnConnectionAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyVpnConnectionAttributeRequest) GoString() string {
	return s.String()
}

func (s *ModifyVpnConnectionAttributeRequest) SetAutoConfigRoute(v bool) *ModifyVpnConnectionAttributeRequest {
	s.AutoConfigRoute = &v
	return s
}

func (s *ModifyVpnConnectionAttributeRequest) SetBgpConfig(v string) *ModifyVpnConnectionAttributeRequest {
	s.BgpConfig = &v
	return s
}

func (s *ModifyVpnConnectionAttributeRequest) SetClientToken(v string) *ModifyVpnConnectionAttributeRequest {
	s.ClientToken = &v
	return s
}

func (s *ModifyVpnConnectionAttributeRequest) SetEffectImmediately(v bool) *ModifyVpnConnectionAttributeRequest {
	s.EffectImmediately = &v
	return s
}

func (s *ModifyVpnConnectionAttributeRequest) SetEnableDpd(v bool) *ModifyVpnConnectionAttributeRequest {
	s.EnableDpd = &v
	return s
}

func (s *ModifyVpnConnectionAttributeRequest) SetEnableNatTraversal(v bool) *ModifyVpnConnectionAttributeRequest {
	s.EnableNatTraversal = &v
	return s
}

func (s *ModifyVpnConnectionAttributeRequest) SetEnableTunnelsBgp(v bool) *ModifyVpnConnectionAttributeRequest {
	s.EnableTunnelsBgp = &v
	return s
}

func (s *ModifyVpnConnectionAttributeRequest) SetHealthCheckConfig(v string) *ModifyVpnConnectionAttributeRequest {
	s.HealthCheckConfig = &v
	return s
}

func (s *ModifyVpnConnectionAttributeRequest) SetIkeConfig(v string) *ModifyVpnConnectionAttributeRequest {
	s.IkeConfig = &v
	return s
}

func (s *ModifyVpnConnectionAttributeRequest) SetIpsecConfig(v string) *ModifyVpnConnectionAttributeRequest {
	s.IpsecConfig = &v
	return s
}

func (s *ModifyVpnConnectionAttributeRequest) SetLocalSubnet(v string) *ModifyVpnConnectionAttributeRequest {
	s.LocalSubnet = &v
	return s
}

func (s *ModifyVpnConnectionAttributeRequest) SetName(v string) *ModifyVpnConnectionAttributeRequest {
	s.Name = &v
	return s
}

func (s *ModifyVpnConnectionAttributeRequest) SetOwnerAccount(v string) *ModifyVpnConnectionAttributeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyVpnConnectionAttributeRequest) SetOwnerId(v int64) *ModifyVpnConnectionAttributeRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyVpnConnectionAttributeRequest) SetRegionId(v string) *ModifyVpnConnectionAttributeRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyVpnConnectionAttributeRequest) SetRemoteCaCertificate(v string) *ModifyVpnConnectionAttributeRequest {
	s.RemoteCaCertificate = &v
	return s
}

func (s *ModifyVpnConnectionAttributeRequest) SetRemoteSubnet(v string) *ModifyVpnConnectionAttributeRequest {
	s.RemoteSubnet = &v
	return s
}

func (s *ModifyVpnConnectionAttributeRequest) SetResourceOwnerAccount(v string) *ModifyVpnConnectionAttributeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyVpnConnectionAttributeRequest) SetResourceOwnerId(v int64) *ModifyVpnConnectionAttributeRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ModifyVpnConnectionAttributeRequest) SetTunnelOptionsSpecification(v []*ModifyVpnConnectionAttributeRequestTunnelOptionsSpecification) *ModifyVpnConnectionAttributeRequest {
	s.TunnelOptionsSpecification = v
	return s
}

func (s *ModifyVpnConnectionAttributeRequest) SetVpnConnectionId(v string) *ModifyVpnConnectionAttributeRequest {
	s.VpnConnectionId = &v
	return s
}

type ModifyVpnConnectionAttributeRequestTunnelOptionsSpecification struct {
	EnableDpd           *bool                                                                           `json:"EnableDpd,omitempty" xml:"EnableDpd,omitempty"`
	EnableNatTraversal  *bool                                                                           `json:"EnableNatTraversal,omitempty" xml:"EnableNatTraversal,omitempty"`
	RemoteCaCertificate *string                                                                         `json:"RemoteCaCertificate,omitempty" xml:"RemoteCaCertificate,omitempty"`
	TunnelBgpConfig     *ModifyVpnConnectionAttributeRequestTunnelOptionsSpecificationTunnelBgpConfig   `json:"TunnelBgpConfig,omitempty" xml:"TunnelBgpConfig,omitempty" type:"Struct"`
	TunnelId            *string                                                                         `json:"TunnelId,omitempty" xml:"TunnelId,omitempty"`
	TunnelIkeConfig     *ModifyVpnConnectionAttributeRequestTunnelOptionsSpecificationTunnelIkeConfig   `json:"TunnelIkeConfig,omitempty" xml:"TunnelIkeConfig,omitempty" type:"Struct"`
	TunnelIpsecConfig   *ModifyVpnConnectionAttributeRequestTunnelOptionsSpecificationTunnelIpsecConfig `json:"TunnelIpsecConfig,omitempty" xml:"TunnelIpsecConfig,omitempty" type:"Struct"`
}

func (s ModifyVpnConnectionAttributeRequestTunnelOptionsSpecification) String() string {
	return tea.Prettify(s)
}

func (s ModifyVpnConnectionAttributeRequestTunnelOptionsSpecification) GoString() string {
	return s.String()
}

func (s *ModifyVpnConnectionAttributeRequestTunnelOptionsSpecification) SetEnableDpd(v bool) *ModifyVpnConnectionAttributeRequestTunnelOptionsSpecification {
	s.EnableDpd = &v
	return s
}

func (s *ModifyVpnConnectionAttributeRequestTunnelOptionsSpecification) SetEnableNatTraversal(v bool) *ModifyVpnConnectionAttributeRequestTunnelOptionsSpecification {
	s.EnableNatTraversal = &v
	return s
}

func (s *ModifyVpnConnectionAttributeRequestTunnelOptionsSpecification) SetRemoteCaCertificate(v string) *ModifyVpnConnectionAttributeRequestTunnelOptionsSpecification {
	s.RemoteCaCertificate = &v
	return s
}

func (s *ModifyVpnConnectionAttributeRequestTunnelOptionsSpecification) SetTunnelBgpConfig(v *ModifyVpnConnectionAttributeRequestTunnelOptionsSpecificationTunnelBgpConfig) *ModifyVpnConnectionAttributeRequestTunnelOptionsSpecification {
	s.TunnelBgpConfig = v
	return s
}

func (s *ModifyVpnConnectionAttributeRequestTunnelOptionsSpecification) SetTunnelId(v string) *ModifyVpnConnectionAttributeRequestTunnelOptionsSpecification {
	s.TunnelId = &v
	return s
}

func (s *ModifyVpnConnectionAttributeRequestTunnelOptionsSpecification) SetTunnelIkeConfig(v *ModifyVpnConnectionAttributeRequestTunnelOptionsSpecificationTunnelIkeConfig) *ModifyVpnConnectionAttributeRequestTunnelOptionsSpecification {
	s.TunnelIkeConfig = v
	return s
}

func (s *ModifyVpnConnectionAttributeRequestTunnelOptionsSpecification) SetTunnelIpsecConfig(v *ModifyVpnConnectionAttributeRequestTunnelOptionsSpecificationTunnelIpsecConfig) *ModifyVpnConnectionAttributeRequestTunnelOptionsSpecification {
	s.TunnelIpsecConfig = v
	return s
}

type ModifyVpnConnectionAttributeRequestTunnelOptionsSpecificationTunnelBgpConfig struct {
	LocalAsn   *int64  `json:"LocalAsn,omitempty" xml:"LocalAsn,omitempty"`
	LocalBgpIp *string `json:"LocalBgpIp,omitempty" xml:"LocalBgpIp,omitempty"`
	TunnelCidr *string `json:"TunnelCidr,omitempty" xml:"TunnelCidr,omitempty"`
}

func (s ModifyVpnConnectionAttributeRequestTunnelOptionsSpecificationTunnelBgpConfig) String() string {
	return tea.Prettify(s)
}

func (s ModifyVpnConnectionAttributeRequestTunnelOptionsSpecificationTunnelBgpConfig) GoString() string {
	return s.String()
}

func (s *ModifyVpnConnectionAttributeRequestTunnelOptionsSpecificationTunnelBgpConfig) SetLocalAsn(v int64) *ModifyVpnConnectionAttributeRequestTunnelOptionsSpecificationTunnelBgpConfig {
	s.LocalAsn = &v
	return s
}

func (s *ModifyVpnConnectionAttributeRequestTunnelOptionsSpecificationTunnelBgpConfig) SetLocalBgpIp(v string) *ModifyVpnConnectionAttributeRequestTunnelOptionsSpecificationTunnelBgpConfig {
	s.LocalBgpIp = &v
	return s
}

func (s *ModifyVpnConnectionAttributeRequestTunnelOptionsSpecificationTunnelBgpConfig) SetTunnelCidr(v string) *ModifyVpnConnectionAttributeRequestTunnelOptionsSpecificationTunnelBgpConfig {
	s.TunnelCidr = &v
	return s
}

type ModifyVpnConnectionAttributeRequestTunnelOptionsSpecificationTunnelIkeConfig struct {
	IkeAuthAlg  *string `json:"IkeAuthAlg,omitempty" xml:"IkeAuthAlg,omitempty"`
	IkeEncAlg   *string `json:"IkeEncAlg,omitempty" xml:"IkeEncAlg,omitempty"`
	IkeLifetime *int64  `json:"IkeLifetime,omitempty" xml:"IkeLifetime,omitempty"`
	IkeMode     *string `json:"IkeMode,omitempty" xml:"IkeMode,omitempty"`
	IkePfs      *string `json:"IkePfs,omitempty" xml:"IkePfs,omitempty"`
	IkeVersion  *string `json:"IkeVersion,omitempty" xml:"IkeVersion,omitempty"`
	LocalId     *string `json:"LocalId,omitempty" xml:"LocalId,omitempty"`
	Psk         *string `json:"Psk,omitempty" xml:"Psk,omitempty"`
	RemoteId    *string `json:"RemoteId,omitempty" xml:"RemoteId,omitempty"`
}

func (s ModifyVpnConnectionAttributeRequestTunnelOptionsSpecificationTunnelIkeConfig) String() string {
	return tea.Prettify(s)
}

func (s ModifyVpnConnectionAttributeRequestTunnelOptionsSpecificationTunnelIkeConfig) GoString() string {
	return s.String()
}

func (s *ModifyVpnConnectionAttributeRequestTunnelOptionsSpecificationTunnelIkeConfig) SetIkeAuthAlg(v string) *ModifyVpnConnectionAttributeRequestTunnelOptionsSpecificationTunnelIkeConfig {
	s.IkeAuthAlg = &v
	return s
}

func (s *ModifyVpnConnectionAttributeRequestTunnelOptionsSpecificationTunnelIkeConfig) SetIkeEncAlg(v string) *ModifyVpnConnectionAttributeRequestTunnelOptionsSpecificationTunnelIkeConfig {
	s.IkeEncAlg = &v
	return s
}

func (s *ModifyVpnConnectionAttributeRequestTunnelOptionsSpecificationTunnelIkeConfig) SetIkeLifetime(v int64) *ModifyVpnConnectionAttributeRequestTunnelOptionsSpecificationTunnelIkeConfig {
	s.IkeLifetime = &v
	return s
}

func (s *ModifyVpnConnectionAttributeRequestTunnelOptionsSpecificationTunnelIkeConfig) SetIkeMode(v string) *ModifyVpnConnectionAttributeRequestTunnelOptionsSpecificationTunnelIkeConfig {
	s.IkeMode = &v
	return s
}

func (s *ModifyVpnConnectionAttributeRequestTunnelOptionsSpecificationTunnelIkeConfig) SetIkePfs(v string) *ModifyVpnConnectionAttributeRequestTunnelOptionsSpecificationTunnelIkeConfig {
	s.IkePfs = &v
	return s
}

func (s *ModifyVpnConnectionAttributeRequestTunnelOptionsSpecificationTunnelIkeConfig) SetIkeVersion(v string) *ModifyVpnConnectionAttributeRequestTunnelOptionsSpecificationTunnelIkeConfig {
	s.IkeVersion = &v
	return s
}

func (s *ModifyVpnConnectionAttributeRequestTunnelOptionsSpecificationTunnelIkeConfig) SetLocalId(v string) *ModifyVpnConnectionAttributeRequestTunnelOptionsSpecificationTunnelIkeConfig {
	s.LocalId = &v
	return s
}

func (s *ModifyVpnConnectionAttributeRequestTunnelOptionsSpecificationTunnelIkeConfig) SetPsk(v string) *ModifyVpnConnectionAttributeRequestTunnelOptionsSpecificationTunnelIkeConfig {
	s.Psk = &v
	return s
}

func (s *ModifyVpnConnectionAttributeRequestTunnelOptionsSpecificationTunnelIkeConfig) SetRemoteId(v string) *ModifyVpnConnectionAttributeRequestTunnelOptionsSpecificationTunnelIkeConfig {
	s.RemoteId = &v
	return s
}

type ModifyVpnConnectionAttributeRequestTunnelOptionsSpecificationTunnelIpsecConfig struct {
	IpsecAuthAlg  *string `json:"IpsecAuthAlg,omitempty" xml:"IpsecAuthAlg,omitempty"`
	IpsecEncAlg   *string `json:"IpsecEncAlg,omitempty" xml:"IpsecEncAlg,omitempty"`
	IpsecLifetime *int32  `json:"IpsecLifetime,omitempty" xml:"IpsecLifetime,omitempty"`
	IpsecPfs      *string `json:"IpsecPfs,omitempty" xml:"IpsecPfs,omitempty"`
}

func (s ModifyVpnConnectionAttributeRequestTunnelOptionsSpecificationTunnelIpsecConfig) String() string {
	return tea.Prettify(s)
}

func (s ModifyVpnConnectionAttributeRequestTunnelOptionsSpecificationTunnelIpsecConfig) GoString() string {
	return s.String()
}

func (s *ModifyVpnConnectionAttributeRequestTunnelOptionsSpecificationTunnelIpsecConfig) SetIpsecAuthAlg(v string) *ModifyVpnConnectionAttributeRequestTunnelOptionsSpecificationTunnelIpsecConfig {
	s.IpsecAuthAlg = &v
	return s
}

func (s *ModifyVpnConnectionAttributeRequestTunnelOptionsSpecificationTunnelIpsecConfig) SetIpsecEncAlg(v string) *ModifyVpnConnectionAttributeRequestTunnelOptionsSpecificationTunnelIpsecConfig {
	s.IpsecEncAlg = &v
	return s
}

func (s *ModifyVpnConnectionAttributeRequestTunnelOptionsSpecificationTunnelIpsecConfig) SetIpsecLifetime(v int32) *ModifyVpnConnectionAttributeRequestTunnelOptionsSpecificationTunnelIpsecConfig {
	s.IpsecLifetime = &v
	return s
}

func (s *ModifyVpnConnectionAttributeRequestTunnelOptionsSpecificationTunnelIpsecConfig) SetIpsecPfs(v string) *ModifyVpnConnectionAttributeRequestTunnelOptionsSpecificationTunnelIpsecConfig {
	s.IpsecPfs = &v
	return s
}

type ModifyVpnConnectionAttributeResponseBody struct {
	// The timestamp generated when the IPsec-VPN connection was established. Unit: milliseconds.
	//
	// This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The ID of the customer gateway.
	CustomerGatewayId *string `json:"CustomerGatewayId,omitempty" xml:"CustomerGatewayId,omitempty"`
	// The description of the IPsec-VPN connection.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// Indicates whether IPsec negotiations immediately start after the configuration takes effect. Valid values:
	//
	// *   **true:** IPsec negotiations immediately start after the configuration takes effect.
	// *   **false:** IPsec negotiations start when inbound traffic is detected.
	EffectImmediately *bool `json:"EffectImmediately,omitempty" xml:"EffectImmediately,omitempty"`
	// Indicates whether DPD is enabled. Valid values:
	//
	// *   **false:** The DPD feature is disabled.
	// *   **true:** The DPD feature is enabled.
	EnableDpd *bool `json:"EnableDpd,omitempty" xml:"EnableDpd,omitempty"`
	// Indicates whether NAT traversal is enabled. Valid values:
	//
	// *   **false:** NAT traversal is disabled.
	// *   **true:** NAT traversal is enabled.
	EnableNatTraversal *bool `json:"EnableNatTraversal,omitempty" xml:"EnableNatTraversal,omitempty"`
	EnableTunnelsBgp   *bool `json:"EnableTunnelsBgp,omitempty" xml:"EnableTunnelsBgp,omitempty"`
	// The configurations of Phase 1 negotiations.
	IkeConfig *ModifyVpnConnectionAttributeResponseBodyIkeConfig `json:"IkeConfig,omitempty" xml:"IkeConfig,omitempty" type:"Struct"`
	// The configurations of Phase 2 negotiations.
	IpsecConfig *ModifyVpnConnectionAttributeResponseBodyIpsecConfig `json:"IpsecConfig,omitempty" xml:"IpsecConfig,omitempty" type:"Struct"`
	// The CIDR block on the VPC side.
	LocalSubnet *string `json:"LocalSubnet,omitempty" xml:"LocalSubnet,omitempty"`
	// The name of the IPsec-VPN connection.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The CIDR block on the data center side.
	RemoteSubnet *string `json:"RemoteSubnet,omitempty" xml:"RemoteSubnet,omitempty"`
	// The ID of the request.
	RequestId                  *string                                                             `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	TunnelOptionsSpecification *ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecification `json:"TunnelOptionsSpecification,omitempty" xml:"TunnelOptionsSpecification,omitempty" type:"Struct"`
	// The health check configurations.
	VcoHealthCheck *ModifyVpnConnectionAttributeResponseBodyVcoHealthCheck `json:"VcoHealthCheck,omitempty" xml:"VcoHealthCheck,omitempty" type:"Struct"`
	// The BGP configurations.
	VpnBgpConfig *ModifyVpnConnectionAttributeResponseBodyVpnBgpConfig `json:"VpnBgpConfig,omitempty" xml:"VpnBgpConfig,omitempty" type:"Struct"`
	// The ID of the IPsec-VPN connection.
	VpnConnectionId *string `json:"VpnConnectionId,omitempty" xml:"VpnConnectionId,omitempty"`
	// The ID of the VPN gateway.
	VpnGatewayId *string `json:"VpnGatewayId,omitempty" xml:"VpnGatewayId,omitempty"`
}

func (s ModifyVpnConnectionAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyVpnConnectionAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyVpnConnectionAttributeResponseBody) SetCreateTime(v int64) *ModifyVpnConnectionAttributeResponseBody {
	s.CreateTime = &v
	return s
}

func (s *ModifyVpnConnectionAttributeResponseBody) SetCustomerGatewayId(v string) *ModifyVpnConnectionAttributeResponseBody {
	s.CustomerGatewayId = &v
	return s
}

func (s *ModifyVpnConnectionAttributeResponseBody) SetDescription(v string) *ModifyVpnConnectionAttributeResponseBody {
	s.Description = &v
	return s
}

func (s *ModifyVpnConnectionAttributeResponseBody) SetEffectImmediately(v bool) *ModifyVpnConnectionAttributeResponseBody {
	s.EffectImmediately = &v
	return s
}

func (s *ModifyVpnConnectionAttributeResponseBody) SetEnableDpd(v bool) *ModifyVpnConnectionAttributeResponseBody {
	s.EnableDpd = &v
	return s
}

func (s *ModifyVpnConnectionAttributeResponseBody) SetEnableNatTraversal(v bool) *ModifyVpnConnectionAttributeResponseBody {
	s.EnableNatTraversal = &v
	return s
}

func (s *ModifyVpnConnectionAttributeResponseBody) SetEnableTunnelsBgp(v bool) *ModifyVpnConnectionAttributeResponseBody {
	s.EnableTunnelsBgp = &v
	return s
}

func (s *ModifyVpnConnectionAttributeResponseBody) SetIkeConfig(v *ModifyVpnConnectionAttributeResponseBodyIkeConfig) *ModifyVpnConnectionAttributeResponseBody {
	s.IkeConfig = v
	return s
}

func (s *ModifyVpnConnectionAttributeResponseBody) SetIpsecConfig(v *ModifyVpnConnectionAttributeResponseBodyIpsecConfig) *ModifyVpnConnectionAttributeResponseBody {
	s.IpsecConfig = v
	return s
}

func (s *ModifyVpnConnectionAttributeResponseBody) SetLocalSubnet(v string) *ModifyVpnConnectionAttributeResponseBody {
	s.LocalSubnet = &v
	return s
}

func (s *ModifyVpnConnectionAttributeResponseBody) SetName(v string) *ModifyVpnConnectionAttributeResponseBody {
	s.Name = &v
	return s
}

func (s *ModifyVpnConnectionAttributeResponseBody) SetRemoteSubnet(v string) *ModifyVpnConnectionAttributeResponseBody {
	s.RemoteSubnet = &v
	return s
}

func (s *ModifyVpnConnectionAttributeResponseBody) SetRequestId(v string) *ModifyVpnConnectionAttributeResponseBody {
	s.RequestId = &v
	return s
}

func (s *ModifyVpnConnectionAttributeResponseBody) SetTunnelOptionsSpecification(v *ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecification) *ModifyVpnConnectionAttributeResponseBody {
	s.TunnelOptionsSpecification = v
	return s
}

func (s *ModifyVpnConnectionAttributeResponseBody) SetVcoHealthCheck(v *ModifyVpnConnectionAttributeResponseBodyVcoHealthCheck) *ModifyVpnConnectionAttributeResponseBody {
	s.VcoHealthCheck = v
	return s
}

func (s *ModifyVpnConnectionAttributeResponseBody) SetVpnBgpConfig(v *ModifyVpnConnectionAttributeResponseBodyVpnBgpConfig) *ModifyVpnConnectionAttributeResponseBody {
	s.VpnBgpConfig = v
	return s
}

func (s *ModifyVpnConnectionAttributeResponseBody) SetVpnConnectionId(v string) *ModifyVpnConnectionAttributeResponseBody {
	s.VpnConnectionId = &v
	return s
}

func (s *ModifyVpnConnectionAttributeResponseBody) SetVpnGatewayId(v string) *ModifyVpnConnectionAttributeResponseBody {
	s.VpnGatewayId = &v
	return s
}

type ModifyVpnConnectionAttributeResponseBodyIkeConfig struct {
	// The IKE authentication algorithm.
	IkeAuthAlg *string `json:"IkeAuthAlg,omitempty" xml:"IkeAuthAlg,omitempty"`
	// The IKE encryption algorithm.
	IkeEncAlg *string `json:"IkeEncAlg,omitempty" xml:"IkeEncAlg,omitempty"`
	// The IKE lifetime. Unit: seconds.
	IkeLifetime *int64 `json:"IkeLifetime,omitempty" xml:"IkeLifetime,omitempty"`
	// The IKE negotiation mode. Valid values:
	//
	// *   **main:** This mode offers higher security during negotiations.
	// *   **aggressive:** This mode is faster and has a higher success rate.
	IkeMode *string `json:"IkeMode,omitempty" xml:"IkeMode,omitempty"`
	// The Diffie-Hellman group.
	IkePfs *string `json:"IkePfs,omitempty" xml:"IkePfs,omitempty"`
	// The version of the IKE protocol.
	//
	// *   **ikev1**
	// *   **ikev2**
	//
	// Compared with IKEv1, IKEv2 simplifies the SA negotiation process and is more suitable for scenarios in which multiple CIDR blocks are used.
	IkeVersion *string `json:"IkeVersion,omitempty" xml:"IkeVersion,omitempty"`
	// The identifier on the VPC side. The default value is the IP address of the VPN gateway. The value can be an FQDN or an IP address.
	LocalId *string `json:"LocalId,omitempty" xml:"LocalId,omitempty"`
	// The pre-shared key.
	Psk *string `json:"Psk,omitempty" xml:"Psk,omitempty"`
	// The identifier on the data center side. The default value is the IP address of the customer gateway. The value can be a fully qualified domain name (FQDN) or an IP address.
	RemoteId *string `json:"RemoteId,omitempty" xml:"RemoteId,omitempty"`
}

func (s ModifyVpnConnectionAttributeResponseBodyIkeConfig) String() string {
	return tea.Prettify(s)
}

func (s ModifyVpnConnectionAttributeResponseBodyIkeConfig) GoString() string {
	return s.String()
}

func (s *ModifyVpnConnectionAttributeResponseBodyIkeConfig) SetIkeAuthAlg(v string) *ModifyVpnConnectionAttributeResponseBodyIkeConfig {
	s.IkeAuthAlg = &v
	return s
}

func (s *ModifyVpnConnectionAttributeResponseBodyIkeConfig) SetIkeEncAlg(v string) *ModifyVpnConnectionAttributeResponseBodyIkeConfig {
	s.IkeEncAlg = &v
	return s
}

func (s *ModifyVpnConnectionAttributeResponseBodyIkeConfig) SetIkeLifetime(v int64) *ModifyVpnConnectionAttributeResponseBodyIkeConfig {
	s.IkeLifetime = &v
	return s
}

func (s *ModifyVpnConnectionAttributeResponseBodyIkeConfig) SetIkeMode(v string) *ModifyVpnConnectionAttributeResponseBodyIkeConfig {
	s.IkeMode = &v
	return s
}

func (s *ModifyVpnConnectionAttributeResponseBodyIkeConfig) SetIkePfs(v string) *ModifyVpnConnectionAttributeResponseBodyIkeConfig {
	s.IkePfs = &v
	return s
}

func (s *ModifyVpnConnectionAttributeResponseBodyIkeConfig) SetIkeVersion(v string) *ModifyVpnConnectionAttributeResponseBodyIkeConfig {
	s.IkeVersion = &v
	return s
}

func (s *ModifyVpnConnectionAttributeResponseBodyIkeConfig) SetLocalId(v string) *ModifyVpnConnectionAttributeResponseBodyIkeConfig {
	s.LocalId = &v
	return s
}

func (s *ModifyVpnConnectionAttributeResponseBodyIkeConfig) SetPsk(v string) *ModifyVpnConnectionAttributeResponseBodyIkeConfig {
	s.Psk = &v
	return s
}

func (s *ModifyVpnConnectionAttributeResponseBodyIkeConfig) SetRemoteId(v string) *ModifyVpnConnectionAttributeResponseBodyIkeConfig {
	s.RemoteId = &v
	return s
}

type ModifyVpnConnectionAttributeResponseBodyIpsecConfig struct {
	// The IPsec authentication algorithm.
	IpsecAuthAlg *string `json:"IpsecAuthAlg,omitempty" xml:"IpsecAuthAlg,omitempty"`
	// The IPsec encryption algorithm.
	IpsecEncAlg *string `json:"IpsecEncAlg,omitempty" xml:"IpsecEncAlg,omitempty"`
	// The IPsec lifetime. Unit: seconds.
	IpsecLifetime *int64 `json:"IpsecLifetime,omitempty" xml:"IpsecLifetime,omitempty"`
	// The Diffie-Hellman group.
	IpsecPfs *string `json:"IpsecPfs,omitempty" xml:"IpsecPfs,omitempty"`
}

func (s ModifyVpnConnectionAttributeResponseBodyIpsecConfig) String() string {
	return tea.Prettify(s)
}

func (s ModifyVpnConnectionAttributeResponseBodyIpsecConfig) GoString() string {
	return s.String()
}

func (s *ModifyVpnConnectionAttributeResponseBodyIpsecConfig) SetIpsecAuthAlg(v string) *ModifyVpnConnectionAttributeResponseBodyIpsecConfig {
	s.IpsecAuthAlg = &v
	return s
}

func (s *ModifyVpnConnectionAttributeResponseBodyIpsecConfig) SetIpsecEncAlg(v string) *ModifyVpnConnectionAttributeResponseBodyIpsecConfig {
	s.IpsecEncAlg = &v
	return s
}

func (s *ModifyVpnConnectionAttributeResponseBodyIpsecConfig) SetIpsecLifetime(v int64) *ModifyVpnConnectionAttributeResponseBodyIpsecConfig {
	s.IpsecLifetime = &v
	return s
}

func (s *ModifyVpnConnectionAttributeResponseBodyIpsecConfig) SetIpsecPfs(v string) *ModifyVpnConnectionAttributeResponseBodyIpsecConfig {
	s.IpsecPfs = &v
	return s
}

type ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecification struct {
	TunnelOptions []*ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptions `json:"TunnelOptions,omitempty" xml:"TunnelOptions,omitempty" type:"Repeated"`
}

func (s ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecification) String() string {
	return tea.Prettify(s)
}

func (s ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecification) GoString() string {
	return s.String()
}

func (s *ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecification) SetTunnelOptions(v []*ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptions) *ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecification {
	s.TunnelOptions = v
	return s
}

type ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptions struct {
	CustomerGatewayId   *string                                                                                           `json:"CustomerGatewayId,omitempty" xml:"CustomerGatewayId,omitempty"`
	EnableDpd           *bool                                                                                             `json:"EnableDpd,omitempty" xml:"EnableDpd,omitempty"`
	EnableNatTraversal  *bool                                                                                             `json:"EnableNatTraversal,omitempty" xml:"EnableNatTraversal,omitempty"`
	InternetIp          *string                                                                                           `json:"InternetIp,omitempty" xml:"InternetIp,omitempty"`
	RemoteCaCertificate *string                                                                                           `json:"RemoteCaCertificate,omitempty" xml:"RemoteCaCertificate,omitempty"`
	Role                *string                                                                                           `json:"Role,omitempty" xml:"Role,omitempty"`
	State               *string                                                                                           `json:"State,omitempty" xml:"State,omitempty"`
	TunnelBgpConfig     *ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelBgpConfig   `json:"TunnelBgpConfig,omitempty" xml:"TunnelBgpConfig,omitempty" type:"Struct"`
	TunnelId            *string                                                                                           `json:"TunnelId,omitempty" xml:"TunnelId,omitempty"`
	TunnelIkeConfig     *ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig   `json:"TunnelIkeConfig,omitempty" xml:"TunnelIkeConfig,omitempty" type:"Struct"`
	TunnelIpsecConfig   *ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIpsecConfig `json:"TunnelIpsecConfig,omitempty" xml:"TunnelIpsecConfig,omitempty" type:"Struct"`
	ZoneNo              *string                                                                                           `json:"ZoneNo,omitempty" xml:"ZoneNo,omitempty"`
}

func (s ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptions) String() string {
	return tea.Prettify(s)
}

func (s ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptions) GoString() string {
	return s.String()
}

func (s *ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptions) SetCustomerGatewayId(v string) *ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptions {
	s.CustomerGatewayId = &v
	return s
}

func (s *ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptions) SetEnableDpd(v bool) *ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptions {
	s.EnableDpd = &v
	return s
}

func (s *ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptions) SetEnableNatTraversal(v bool) *ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptions {
	s.EnableNatTraversal = &v
	return s
}

func (s *ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptions) SetInternetIp(v string) *ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptions {
	s.InternetIp = &v
	return s
}

func (s *ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptions) SetRemoteCaCertificate(v string) *ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptions {
	s.RemoteCaCertificate = &v
	return s
}

func (s *ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptions) SetRole(v string) *ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptions {
	s.Role = &v
	return s
}

func (s *ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptions) SetState(v string) *ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptions {
	s.State = &v
	return s
}

func (s *ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptions) SetTunnelBgpConfig(v *ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelBgpConfig) *ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptions {
	s.TunnelBgpConfig = v
	return s
}

func (s *ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptions) SetTunnelId(v string) *ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptions {
	s.TunnelId = &v
	return s
}

func (s *ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptions) SetTunnelIkeConfig(v *ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig) *ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptions {
	s.TunnelIkeConfig = v
	return s
}

func (s *ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptions) SetTunnelIpsecConfig(v *ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIpsecConfig) *ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptions {
	s.TunnelIpsecConfig = v
	return s
}

func (s *ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptions) SetZoneNo(v string) *ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptions {
	s.ZoneNo = &v
	return s
}

type ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelBgpConfig struct {
	LocalAsn   *int64  `json:"LocalAsn,omitempty" xml:"LocalAsn,omitempty"`
	LocalBgpIp *string `json:"LocalBgpIp,omitempty" xml:"LocalBgpIp,omitempty"`
	PeerAsn    *int64  `json:"PeerAsn,omitempty" xml:"PeerAsn,omitempty"`
	PeerBgpIp  *string `json:"PeerBgpIp,omitempty" xml:"PeerBgpIp,omitempty"`
	TunnelCidr *string `json:"TunnelCidr,omitempty" xml:"TunnelCidr,omitempty"`
}

func (s ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelBgpConfig) String() string {
	return tea.Prettify(s)
}

func (s ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelBgpConfig) GoString() string {
	return s.String()
}

func (s *ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelBgpConfig) SetLocalAsn(v int64) *ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelBgpConfig {
	s.LocalAsn = &v
	return s
}

func (s *ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelBgpConfig) SetLocalBgpIp(v string) *ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelBgpConfig {
	s.LocalBgpIp = &v
	return s
}

func (s *ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelBgpConfig) SetPeerAsn(v int64) *ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelBgpConfig {
	s.PeerAsn = &v
	return s
}

func (s *ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelBgpConfig) SetPeerBgpIp(v string) *ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelBgpConfig {
	s.PeerBgpIp = &v
	return s
}

func (s *ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelBgpConfig) SetTunnelCidr(v string) *ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelBgpConfig {
	s.TunnelCidr = &v
	return s
}

type ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig struct {
	IkeAuthAlg  *string `json:"IkeAuthAlg,omitempty" xml:"IkeAuthAlg,omitempty"`
	IkeEncAlg   *string `json:"IkeEncAlg,omitempty" xml:"IkeEncAlg,omitempty"`
	IkeLifetime *int64  `json:"IkeLifetime,omitempty" xml:"IkeLifetime,omitempty"`
	IkeMode     *string `json:"IkeMode,omitempty" xml:"IkeMode,omitempty"`
	IkePfs      *string `json:"IkePfs,omitempty" xml:"IkePfs,omitempty"`
	IkeVersion  *string `json:"IkeVersion,omitempty" xml:"IkeVersion,omitempty"`
	LocalId     *string `json:"LocalId,omitempty" xml:"LocalId,omitempty"`
	Psk         *string `json:"Psk,omitempty" xml:"Psk,omitempty"`
	RemoteId    *string `json:"RemoteId,omitempty" xml:"RemoteId,omitempty"`
}

func (s ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig) String() string {
	return tea.Prettify(s)
}

func (s ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig) GoString() string {
	return s.String()
}

func (s *ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig) SetIkeAuthAlg(v string) *ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig {
	s.IkeAuthAlg = &v
	return s
}

func (s *ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig) SetIkeEncAlg(v string) *ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig {
	s.IkeEncAlg = &v
	return s
}

func (s *ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig) SetIkeLifetime(v int64) *ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig {
	s.IkeLifetime = &v
	return s
}

func (s *ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig) SetIkeMode(v string) *ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig {
	s.IkeMode = &v
	return s
}

func (s *ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig) SetIkePfs(v string) *ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig {
	s.IkePfs = &v
	return s
}

func (s *ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig) SetIkeVersion(v string) *ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig {
	s.IkeVersion = &v
	return s
}

func (s *ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig) SetLocalId(v string) *ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig {
	s.LocalId = &v
	return s
}

func (s *ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig) SetPsk(v string) *ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig {
	s.Psk = &v
	return s
}

func (s *ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig) SetRemoteId(v string) *ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig {
	s.RemoteId = &v
	return s
}

type ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIpsecConfig struct {
	IpsecAuthAlg  *string `json:"IpsecAuthAlg,omitempty" xml:"IpsecAuthAlg,omitempty"`
	IpsecEncAlg   *string `json:"IpsecEncAlg,omitempty" xml:"IpsecEncAlg,omitempty"`
	IpsecLifetime *int64  `json:"IpsecLifetime,omitempty" xml:"IpsecLifetime,omitempty"`
	IpsecPfs      *string `json:"IpsecPfs,omitempty" xml:"IpsecPfs,omitempty"`
}

func (s ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIpsecConfig) String() string {
	return tea.Prettify(s)
}

func (s ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIpsecConfig) GoString() string {
	return s.String()
}

func (s *ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIpsecConfig) SetIpsecAuthAlg(v string) *ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIpsecConfig {
	s.IpsecAuthAlg = &v
	return s
}

func (s *ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIpsecConfig) SetIpsecEncAlg(v string) *ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIpsecConfig {
	s.IpsecEncAlg = &v
	return s
}

func (s *ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIpsecConfig) SetIpsecLifetime(v int64) *ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIpsecConfig {
	s.IpsecLifetime = &v
	return s
}

func (s *ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIpsecConfig) SetIpsecPfs(v string) *ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIpsecConfig {
	s.IpsecPfs = &v
	return s
}

type ModifyVpnConnectionAttributeResponseBodyVcoHealthCheck struct {
	// The destination IP address that was used for health checks.
	Dip *string `json:"Dip,omitempty" xml:"Dip,omitempty"`
	// Indicates whether the health check feature is enabled. Valid values:
	//
	// *   **true:** The health check feature is enabled.
	// *   **false:** The health check feature is disabled.
	Enable *string `json:"Enable,omitempty" xml:"Enable,omitempty"`
	// The interval between two consecutive health check retries. Unit: seconds.
	Interval *int32 `json:"Interval,omitempty" xml:"Interval,omitempty"`
	// The maximum number of health check retries.
	Retry *int32 `json:"Retry,omitempty" xml:"Retry,omitempty"`
	// The source IP address that was used for health checks.
	Sip *string `json:"Sip,omitempty" xml:"Sip,omitempty"`
}

func (s ModifyVpnConnectionAttributeResponseBodyVcoHealthCheck) String() string {
	return tea.Prettify(s)
}

func (s ModifyVpnConnectionAttributeResponseBodyVcoHealthCheck) GoString() string {
	return s.String()
}

func (s *ModifyVpnConnectionAttributeResponseBodyVcoHealthCheck) SetDip(v string) *ModifyVpnConnectionAttributeResponseBodyVcoHealthCheck {
	s.Dip = &v
	return s
}

func (s *ModifyVpnConnectionAttributeResponseBodyVcoHealthCheck) SetEnable(v string) *ModifyVpnConnectionAttributeResponseBodyVcoHealthCheck {
	s.Enable = &v
	return s
}

func (s *ModifyVpnConnectionAttributeResponseBodyVcoHealthCheck) SetInterval(v int32) *ModifyVpnConnectionAttributeResponseBodyVcoHealthCheck {
	s.Interval = &v
	return s
}

func (s *ModifyVpnConnectionAttributeResponseBodyVcoHealthCheck) SetRetry(v int32) *ModifyVpnConnectionAttributeResponseBodyVcoHealthCheck {
	s.Retry = &v
	return s
}

func (s *ModifyVpnConnectionAttributeResponseBodyVcoHealthCheck) SetSip(v string) *ModifyVpnConnectionAttributeResponseBodyVcoHealthCheck {
	s.Sip = &v
	return s
}

type ModifyVpnConnectionAttributeResponseBodyVpnBgpConfig struct {
	// Indicates whether BGP is enabled. Valid values:
	//
	// *   **true:** BGP is enabled.
	// *   **false:** BGP is disabled.
	EnableBgp *string `json:"EnableBgp,omitempty" xml:"EnableBgp,omitempty"`
	// The ASN on the Alibaba Cloud side.
	LocalAsn *int32 `json:"LocalAsn,omitempty" xml:"LocalAsn,omitempty"`
	// The BGP IP address on the Alibaba Cloud side.
	LocalBgpIp *string `json:"LocalBgpIp,omitempty" xml:"LocalBgpIp,omitempty"`
	// The ASN on the data center side.
	PeerAsn *int32 `json:"PeerAsn,omitempty" xml:"PeerAsn,omitempty"`
	// The BGP IP address on the data center side.
	PeerBgpIp *string `json:"PeerBgpIp,omitempty" xml:"PeerBgpIp,omitempty"`
	// The negotiation status of BGP. Valid values:
	//
	// *   **success:** normal.
	// *   **false:** abnormal.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The CIDR block of the IPsec tunnel.
	TunnelCidr *string `json:"TunnelCidr,omitempty" xml:"TunnelCidr,omitempty"`
}

func (s ModifyVpnConnectionAttributeResponseBodyVpnBgpConfig) String() string {
	return tea.Prettify(s)
}

func (s ModifyVpnConnectionAttributeResponseBodyVpnBgpConfig) GoString() string {
	return s.String()
}

func (s *ModifyVpnConnectionAttributeResponseBodyVpnBgpConfig) SetEnableBgp(v string) *ModifyVpnConnectionAttributeResponseBodyVpnBgpConfig {
	s.EnableBgp = &v
	return s
}

func (s *ModifyVpnConnectionAttributeResponseBodyVpnBgpConfig) SetLocalAsn(v int32) *ModifyVpnConnectionAttributeResponseBodyVpnBgpConfig {
	s.LocalAsn = &v
	return s
}

func (s *ModifyVpnConnectionAttributeResponseBodyVpnBgpConfig) SetLocalBgpIp(v string) *ModifyVpnConnectionAttributeResponseBodyVpnBgpConfig {
	s.LocalBgpIp = &v
	return s
}

func (s *ModifyVpnConnectionAttributeResponseBodyVpnBgpConfig) SetPeerAsn(v int32) *ModifyVpnConnectionAttributeResponseBodyVpnBgpConfig {
	s.PeerAsn = &v
	return s
}

func (s *ModifyVpnConnectionAttributeResponseBodyVpnBgpConfig) SetPeerBgpIp(v string) *ModifyVpnConnectionAttributeResponseBodyVpnBgpConfig {
	s.PeerBgpIp = &v
	return s
}

func (s *ModifyVpnConnectionAttributeResponseBodyVpnBgpConfig) SetStatus(v string) *ModifyVpnConnectionAttributeResponseBodyVpnBgpConfig {
	s.Status = &v
	return s
}

func (s *ModifyVpnConnectionAttributeResponseBodyVpnBgpConfig) SetTunnelCidr(v string) *ModifyVpnConnectionAttributeResponseBodyVpnBgpConfig {
	s.TunnelCidr = &v
	return s
}

type ModifyVpnConnectionAttributeResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyVpnConnectionAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyVpnConnectionAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyVpnConnectionAttributeResponse) GoString() string {
	return s.String()
}

func (s *ModifyVpnConnectionAttributeResponse) SetHeaders(v map[string]*string) *ModifyVpnConnectionAttributeResponse {
	s.Headers = v
	return s
}

func (s *ModifyVpnConnectionAttributeResponse) SetStatusCode(v int32) *ModifyVpnConnectionAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyVpnConnectionAttributeResponse) SetBody(v *ModifyVpnConnectionAttributeResponseBody) *ModifyVpnConnectionAttributeResponse {
	s.Body = v
	return s
}

type ModifyVpnGatewayAttributeRequest struct {
	// Specifies whether to automatically advertise BGP routes to the virtual private cloud (VPC). Valid values:
	//
	// *   **true:** yes.
	// *   **false:** no.
	AutoPropagate *bool `json:"AutoPropagate,omitempty" xml:"AutoPropagate,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must ensure that it is unique among all requests. ClientToken can contain only ASCII characters.
	//
	// >  If you do not specify this parameter, the system automatically uses the request ID as the client token. The value of RequestId may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The new description of the VPN gateway.
	//
	// The description must be 1 to 100 characters in length and cannot start with `http://` or `https://`.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The new name of the VPN gateway.
	//
	// The name must be 1 to 100 characters in length, and cannot start with `http://` or `https://`.
	Name         *string `json:"Name,omitempty" xml:"Name,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region where the VPN gateway is created. You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the VPN gateway.
	VpnGatewayId *string `json:"VpnGatewayId,omitempty" xml:"VpnGatewayId,omitempty"`
}

func (s ModifyVpnGatewayAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyVpnGatewayAttributeRequest) GoString() string {
	return s.String()
}

func (s *ModifyVpnGatewayAttributeRequest) SetAutoPropagate(v bool) *ModifyVpnGatewayAttributeRequest {
	s.AutoPropagate = &v
	return s
}

func (s *ModifyVpnGatewayAttributeRequest) SetClientToken(v string) *ModifyVpnGatewayAttributeRequest {
	s.ClientToken = &v
	return s
}

func (s *ModifyVpnGatewayAttributeRequest) SetDescription(v string) *ModifyVpnGatewayAttributeRequest {
	s.Description = &v
	return s
}

func (s *ModifyVpnGatewayAttributeRequest) SetName(v string) *ModifyVpnGatewayAttributeRequest {
	s.Name = &v
	return s
}

func (s *ModifyVpnGatewayAttributeRequest) SetOwnerAccount(v string) *ModifyVpnGatewayAttributeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyVpnGatewayAttributeRequest) SetOwnerId(v int64) *ModifyVpnGatewayAttributeRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyVpnGatewayAttributeRequest) SetRegionId(v string) *ModifyVpnGatewayAttributeRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyVpnGatewayAttributeRequest) SetResourceOwnerAccount(v string) *ModifyVpnGatewayAttributeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyVpnGatewayAttributeRequest) SetResourceOwnerId(v int64) *ModifyVpnGatewayAttributeRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ModifyVpnGatewayAttributeRequest) SetVpnGatewayId(v string) *ModifyVpnGatewayAttributeRequest {
	s.VpnGatewayId = &v
	return s
}

type ModifyVpnGatewayAttributeResponseBody struct {
	// Indicates whether BGP routes are automatically advertised to the VPC. Valid values:
	//
	// *   **true:** yes.
	// *   **false:** no.
	AutoPropagate *bool `json:"AutoPropagate,omitempty" xml:"AutoPropagate,omitempty"`
	// The payment status of the VPN gateway. Valid values:
	//
	// *   **Normal:** The VPN gateway is running as expected.
	// *   **FinancialLocked:** The VPN gateway is locked due to overdue payments.
	BusinessStatus *string `json:"BusinessStatus,omitempty" xml:"BusinessStatus,omitempty"`
	// The timestamp generated when the VPN gateway was created. Unit: milliseconds.
	//
	// This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The description of the VPN gateway.
	Description                *string `json:"Description,omitempty" xml:"Description,omitempty"`
	DisasterRecoveryInternetIp *string `json:"DisasterRecoveryInternetIp,omitempty" xml:"DisasterRecoveryInternetIp,omitempty"`
	DisasterRecoveryVSwitchId  *string `json:"DisasterRecoveryVSwitchId,omitempty" xml:"DisasterRecoveryVSwitchId,omitempty"`
	// The BGP status of the VPN gateway. Valid values:
	//
	// *   **true:** enabled.
	// *   **false:** disabled.
	EnableBgp *bool `json:"EnableBgp,omitempty" xml:"EnableBgp,omitempty"`
	// The timestamp generated when the VPN gateway expires. Unit: milliseconds.
	//
	// This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
	EndTime *int64 `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The public IP address of the VPN gateway.
	InternetIp *string `json:"InternetIp,omitempty" xml:"InternetIp,omitempty"`
	// The private IP address of the VPN gateway.
	IntranetIp *string `json:"IntranetIp,omitempty" xml:"IntranetIp,omitempty"`
	// The name of the VPN gateway.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The maximum bandwidth of the VPN gateway. Unit: Mbit/s.
	Spec             *string `json:"Spec,omitempty" xml:"Spec,omitempty"`
	SslVpnInternetIp *string `json:"SslVpnInternetIp,omitempty" xml:"SslVpnInternetIp,omitempty"`
	// The status of the VPN gateway. Valid values:
	//
	// *   **init:** The VPN gateway is being initialized.
	// *   **provisioning:** The VPN gateway is being prepared.
	// *   **active:** The VPN gateway is ready.
	// *   **updating:** The VPN gateway is being updated.
	// *   **deleting:** The VPN gateway is being deleted.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The ID of the vSwitch to which the VPN gateway belongs.
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
	// The ID of the VPC to which the VPN gateway belongs.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
	// The ID of the VPN gateway.
	VpnGatewayId *string `json:"VpnGatewayId,omitempty" xml:"VpnGatewayId,omitempty"`
}

func (s ModifyVpnGatewayAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyVpnGatewayAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyVpnGatewayAttributeResponseBody) SetAutoPropagate(v bool) *ModifyVpnGatewayAttributeResponseBody {
	s.AutoPropagate = &v
	return s
}

func (s *ModifyVpnGatewayAttributeResponseBody) SetBusinessStatus(v string) *ModifyVpnGatewayAttributeResponseBody {
	s.BusinessStatus = &v
	return s
}

func (s *ModifyVpnGatewayAttributeResponseBody) SetCreateTime(v int64) *ModifyVpnGatewayAttributeResponseBody {
	s.CreateTime = &v
	return s
}

func (s *ModifyVpnGatewayAttributeResponseBody) SetDescription(v string) *ModifyVpnGatewayAttributeResponseBody {
	s.Description = &v
	return s
}

func (s *ModifyVpnGatewayAttributeResponseBody) SetDisasterRecoveryInternetIp(v string) *ModifyVpnGatewayAttributeResponseBody {
	s.DisasterRecoveryInternetIp = &v
	return s
}

func (s *ModifyVpnGatewayAttributeResponseBody) SetDisasterRecoveryVSwitchId(v string) *ModifyVpnGatewayAttributeResponseBody {
	s.DisasterRecoveryVSwitchId = &v
	return s
}

func (s *ModifyVpnGatewayAttributeResponseBody) SetEnableBgp(v bool) *ModifyVpnGatewayAttributeResponseBody {
	s.EnableBgp = &v
	return s
}

func (s *ModifyVpnGatewayAttributeResponseBody) SetEndTime(v int64) *ModifyVpnGatewayAttributeResponseBody {
	s.EndTime = &v
	return s
}

func (s *ModifyVpnGatewayAttributeResponseBody) SetInternetIp(v string) *ModifyVpnGatewayAttributeResponseBody {
	s.InternetIp = &v
	return s
}

func (s *ModifyVpnGatewayAttributeResponseBody) SetIntranetIp(v string) *ModifyVpnGatewayAttributeResponseBody {
	s.IntranetIp = &v
	return s
}

func (s *ModifyVpnGatewayAttributeResponseBody) SetName(v string) *ModifyVpnGatewayAttributeResponseBody {
	s.Name = &v
	return s
}

func (s *ModifyVpnGatewayAttributeResponseBody) SetRequestId(v string) *ModifyVpnGatewayAttributeResponseBody {
	s.RequestId = &v
	return s
}

func (s *ModifyVpnGatewayAttributeResponseBody) SetSpec(v string) *ModifyVpnGatewayAttributeResponseBody {
	s.Spec = &v
	return s
}

func (s *ModifyVpnGatewayAttributeResponseBody) SetSslVpnInternetIp(v string) *ModifyVpnGatewayAttributeResponseBody {
	s.SslVpnInternetIp = &v
	return s
}

func (s *ModifyVpnGatewayAttributeResponseBody) SetStatus(v string) *ModifyVpnGatewayAttributeResponseBody {
	s.Status = &v
	return s
}

func (s *ModifyVpnGatewayAttributeResponseBody) SetVSwitchId(v string) *ModifyVpnGatewayAttributeResponseBody {
	s.VSwitchId = &v
	return s
}

func (s *ModifyVpnGatewayAttributeResponseBody) SetVpcId(v string) *ModifyVpnGatewayAttributeResponseBody {
	s.VpcId = &v
	return s
}

func (s *ModifyVpnGatewayAttributeResponseBody) SetVpnGatewayId(v string) *ModifyVpnGatewayAttributeResponseBody {
	s.VpnGatewayId = &v
	return s
}

type ModifyVpnGatewayAttributeResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyVpnGatewayAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyVpnGatewayAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyVpnGatewayAttributeResponse) GoString() string {
	return s.String()
}

func (s *ModifyVpnGatewayAttributeResponse) SetHeaders(v map[string]*string) *ModifyVpnGatewayAttributeResponse {
	s.Headers = v
	return s
}

func (s *ModifyVpnGatewayAttributeResponse) SetStatusCode(v int32) *ModifyVpnGatewayAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyVpnGatewayAttributeResponse) SetBody(v *ModifyVpnGatewayAttributeResponseBody) *ModifyVpnGatewayAttributeResponse {
	s.Body = v
	return s
}

type ModifyVpnPbrRouteEntryAttributeRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, the system sets **ClientToken** to the value of **RequestId**. The value of **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The new priority of the policy-based route. Valid values: **1** to **100**.
	//
	// A smaller value indicates a higher priority.
	//
	// If you do not set this parameter, the priority of the policy-based route is not modified.
	NewPriority *int32 `json:"NewPriority,omitempty" xml:"NewPriority,omitempty"`
	// The new weight of the policy-based route. Valid values:
	//
	// *   **100**: The IPsec-VPN connection associated with the policy-based route serves as an active connection.
	// *   **0**: The IPsec-VPN connection associated with the policy-based route serves as a standby connection.
	//
	// If you do not set this parameter, the weight of the policy-based route is not modified.
	NewWeight *int32 `json:"NewWeight,omitempty" xml:"NewWeight,omitempty"`
	// The next hop of the policy-based route.
	NextHop      *string `json:"NextHop,omitempty" xml:"NextHop,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The original priority of the policy-based route. Valid values: **1** to **100**.
	//
	// A smaller value indicates a higher priority.
	Priority *int32 `json:"Priority,omitempty" xml:"Priority,omitempty"`
	// The region ID of the VPN gateway.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The destination CIDR block of the policy-based route.
	RouteDest *string `json:"RouteDest,omitempty" xml:"RouteDest,omitempty"`
	// The source CIDR block of the policy-based route.
	RouteSource *string `json:"RouteSource,omitempty" xml:"RouteSource,omitempty"`
	// The ID of the VPN gateway.
	VpnGatewayId *string `json:"VpnGatewayId,omitempty" xml:"VpnGatewayId,omitempty"`
	// The original weight of the policy-based route. Valid values:
	//
	// *   **100**: The IPsec-VPN connection associated with the policy-based route serves as an active connection.
	// *   **0**: The IPsec-VPN connection associated with the policy-based route serves as a standby connection.
	Weight *int32 `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s ModifyVpnPbrRouteEntryAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyVpnPbrRouteEntryAttributeRequest) GoString() string {
	return s.String()
}

func (s *ModifyVpnPbrRouteEntryAttributeRequest) SetClientToken(v string) *ModifyVpnPbrRouteEntryAttributeRequest {
	s.ClientToken = &v
	return s
}

func (s *ModifyVpnPbrRouteEntryAttributeRequest) SetNewPriority(v int32) *ModifyVpnPbrRouteEntryAttributeRequest {
	s.NewPriority = &v
	return s
}

func (s *ModifyVpnPbrRouteEntryAttributeRequest) SetNewWeight(v int32) *ModifyVpnPbrRouteEntryAttributeRequest {
	s.NewWeight = &v
	return s
}

func (s *ModifyVpnPbrRouteEntryAttributeRequest) SetNextHop(v string) *ModifyVpnPbrRouteEntryAttributeRequest {
	s.NextHop = &v
	return s
}

func (s *ModifyVpnPbrRouteEntryAttributeRequest) SetOwnerAccount(v string) *ModifyVpnPbrRouteEntryAttributeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyVpnPbrRouteEntryAttributeRequest) SetOwnerId(v int64) *ModifyVpnPbrRouteEntryAttributeRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyVpnPbrRouteEntryAttributeRequest) SetPriority(v int32) *ModifyVpnPbrRouteEntryAttributeRequest {
	s.Priority = &v
	return s
}

func (s *ModifyVpnPbrRouteEntryAttributeRequest) SetRegionId(v string) *ModifyVpnPbrRouteEntryAttributeRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyVpnPbrRouteEntryAttributeRequest) SetResourceOwnerAccount(v string) *ModifyVpnPbrRouteEntryAttributeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyVpnPbrRouteEntryAttributeRequest) SetResourceOwnerId(v int64) *ModifyVpnPbrRouteEntryAttributeRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ModifyVpnPbrRouteEntryAttributeRequest) SetRouteDest(v string) *ModifyVpnPbrRouteEntryAttributeRequest {
	s.RouteDest = &v
	return s
}

func (s *ModifyVpnPbrRouteEntryAttributeRequest) SetRouteSource(v string) *ModifyVpnPbrRouteEntryAttributeRequest {
	s.RouteSource = &v
	return s
}

func (s *ModifyVpnPbrRouteEntryAttributeRequest) SetVpnGatewayId(v string) *ModifyVpnPbrRouteEntryAttributeRequest {
	s.VpnGatewayId = &v
	return s
}

func (s *ModifyVpnPbrRouteEntryAttributeRequest) SetWeight(v int32) *ModifyVpnPbrRouteEntryAttributeRequest {
	s.Weight = &v
	return s
}

type ModifyVpnPbrRouteEntryAttributeResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyVpnPbrRouteEntryAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyVpnPbrRouteEntryAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyVpnPbrRouteEntryAttributeResponseBody) SetRequestId(v string) *ModifyVpnPbrRouteEntryAttributeResponseBody {
	s.RequestId = &v
	return s
}

type ModifyVpnPbrRouteEntryAttributeResponse struct {
	Headers    map[string]*string                           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyVpnPbrRouteEntryAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyVpnPbrRouteEntryAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyVpnPbrRouteEntryAttributeResponse) GoString() string {
	return s.String()
}

func (s *ModifyVpnPbrRouteEntryAttributeResponse) SetHeaders(v map[string]*string) *ModifyVpnPbrRouteEntryAttributeResponse {
	s.Headers = v
	return s
}

func (s *ModifyVpnPbrRouteEntryAttributeResponse) SetStatusCode(v int32) *ModifyVpnPbrRouteEntryAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyVpnPbrRouteEntryAttributeResponse) SetBody(v *ModifyVpnPbrRouteEntryAttributeResponseBody) *ModifyVpnPbrRouteEntryAttributeResponse {
	s.Body = v
	return s
}

type ModifyVpnPbrRouteEntryPriorityRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, the system sets **ClientToken** to the value of **RequestId**. The value of **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The new priority of the policy-based route. Valid values: **1** to **100**.
	//
	// A smaller value indicates a higher priority.
	NewPriority *int32 `json:"NewPriority,omitempty" xml:"NewPriority,omitempty"`
	// The next hop of the policy-based route.
	NextHop      *string `json:"NextHop,omitempty" xml:"NextHop,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The original priority of the policy-based route. Valid values: **1** to **100**.
	//
	// A smaller value indicates a higher priority.
	Priority *int32 `json:"Priority,omitempty" xml:"Priority,omitempty"`
	// The ID of the region where the VPN gateway is created.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The destination CIDR block of the policy-based route.
	RouteDest *string `json:"RouteDest,omitempty" xml:"RouteDest,omitempty"`
	// The source CIDR block of the policy-based route.
	RouteSource *string `json:"RouteSource,omitempty" xml:"RouteSource,omitempty"`
	// The ID of the VPN gateway.
	VpnGatewayId *string `json:"VpnGatewayId,omitempty" xml:"VpnGatewayId,omitempty"`
	// The weight of the policy-based route.
	Weight *int32 `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s ModifyVpnPbrRouteEntryPriorityRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyVpnPbrRouteEntryPriorityRequest) GoString() string {
	return s.String()
}

func (s *ModifyVpnPbrRouteEntryPriorityRequest) SetClientToken(v string) *ModifyVpnPbrRouteEntryPriorityRequest {
	s.ClientToken = &v
	return s
}

func (s *ModifyVpnPbrRouteEntryPriorityRequest) SetNewPriority(v int32) *ModifyVpnPbrRouteEntryPriorityRequest {
	s.NewPriority = &v
	return s
}

func (s *ModifyVpnPbrRouteEntryPriorityRequest) SetNextHop(v string) *ModifyVpnPbrRouteEntryPriorityRequest {
	s.NextHop = &v
	return s
}

func (s *ModifyVpnPbrRouteEntryPriorityRequest) SetOwnerAccount(v string) *ModifyVpnPbrRouteEntryPriorityRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyVpnPbrRouteEntryPriorityRequest) SetOwnerId(v int64) *ModifyVpnPbrRouteEntryPriorityRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyVpnPbrRouteEntryPriorityRequest) SetPriority(v int32) *ModifyVpnPbrRouteEntryPriorityRequest {
	s.Priority = &v
	return s
}

func (s *ModifyVpnPbrRouteEntryPriorityRequest) SetRegionId(v string) *ModifyVpnPbrRouteEntryPriorityRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyVpnPbrRouteEntryPriorityRequest) SetResourceOwnerAccount(v string) *ModifyVpnPbrRouteEntryPriorityRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyVpnPbrRouteEntryPriorityRequest) SetResourceOwnerId(v int64) *ModifyVpnPbrRouteEntryPriorityRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ModifyVpnPbrRouteEntryPriorityRequest) SetRouteDest(v string) *ModifyVpnPbrRouteEntryPriorityRequest {
	s.RouteDest = &v
	return s
}

func (s *ModifyVpnPbrRouteEntryPriorityRequest) SetRouteSource(v string) *ModifyVpnPbrRouteEntryPriorityRequest {
	s.RouteSource = &v
	return s
}

func (s *ModifyVpnPbrRouteEntryPriorityRequest) SetVpnGatewayId(v string) *ModifyVpnPbrRouteEntryPriorityRequest {
	s.VpnGatewayId = &v
	return s
}

func (s *ModifyVpnPbrRouteEntryPriorityRequest) SetWeight(v int32) *ModifyVpnPbrRouteEntryPriorityRequest {
	s.Weight = &v
	return s
}

type ModifyVpnPbrRouteEntryPriorityResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyVpnPbrRouteEntryPriorityResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyVpnPbrRouteEntryPriorityResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyVpnPbrRouteEntryPriorityResponseBody) SetRequestId(v string) *ModifyVpnPbrRouteEntryPriorityResponseBody {
	s.RequestId = &v
	return s
}

type ModifyVpnPbrRouteEntryPriorityResponse struct {
	Headers    map[string]*string                          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyVpnPbrRouteEntryPriorityResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyVpnPbrRouteEntryPriorityResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyVpnPbrRouteEntryPriorityResponse) GoString() string {
	return s.String()
}

func (s *ModifyVpnPbrRouteEntryPriorityResponse) SetHeaders(v map[string]*string) *ModifyVpnPbrRouteEntryPriorityResponse {
	s.Headers = v
	return s
}

func (s *ModifyVpnPbrRouteEntryPriorityResponse) SetStatusCode(v int32) *ModifyVpnPbrRouteEntryPriorityResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyVpnPbrRouteEntryPriorityResponse) SetBody(v *ModifyVpnPbrRouteEntryPriorityResponseBody) *ModifyVpnPbrRouteEntryPriorityResponse {
	s.Body = v
	return s
}

type ModifyVpnPbrRouteEntryWeightRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that the value is unique among different requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The new weight of the policy-based route. Valid values:
	//
	// *   **100**: The IPsec-VPN connection associated with the policy-based route serves as an active connection.
	// *   **0**: The IPsec-VPN connection associated with the policy-based route serves as a standby connection.
	NewWeight *int32 `json:"NewWeight,omitempty" xml:"NewWeight,omitempty"`
	// The next hop of the policy-based route.
	NextHop *string `json:"NextHop,omitempty" xml:"NextHop,omitempty"`
	// The tunneling protocol. Set the value to **Ipsec**.
	OverlayMode  *string `json:"OverlayMode,omitempty" xml:"OverlayMode,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The priority of the policy-based route.
	//
	// *   If the route was not assigned a priority, this parameter is optional.
	//
	// *   If the route was assigned a priority, this parameter is optional.
	//
	//     If you set this parameter, set the value to the priority that was assigned to the route. Otherwise, the operation fails.
	Priority *int32 `json:"Priority,omitempty" xml:"Priority,omitempty"`
	// The ID of the region where the VPN gateway is created. You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The destination CIDR block of the policy-based route.
	RouteDest *string `json:"RouteDest,omitempty" xml:"RouteDest,omitempty"`
	// The source CIDR block of the policy-based route.
	RouteSource *string `json:"RouteSource,omitempty" xml:"RouteSource,omitempty"`
	// The ID of the VPN gateway.
	VpnGatewayId *string `json:"VpnGatewayId,omitempty" xml:"VpnGatewayId,omitempty"`
	// The original weight of the policy-based route. Valid values:
	//
	// *   **100**: The IPsec-VPN connection associated with the policy-based route serves as an active connection.
	// *   **0**: The IPsec-VPN connection associated with the policy-based route serves as a standby connection.
	Weight *int32 `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s ModifyVpnPbrRouteEntryWeightRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyVpnPbrRouteEntryWeightRequest) GoString() string {
	return s.String()
}

func (s *ModifyVpnPbrRouteEntryWeightRequest) SetClientToken(v string) *ModifyVpnPbrRouteEntryWeightRequest {
	s.ClientToken = &v
	return s
}

func (s *ModifyVpnPbrRouteEntryWeightRequest) SetNewWeight(v int32) *ModifyVpnPbrRouteEntryWeightRequest {
	s.NewWeight = &v
	return s
}

func (s *ModifyVpnPbrRouteEntryWeightRequest) SetNextHop(v string) *ModifyVpnPbrRouteEntryWeightRequest {
	s.NextHop = &v
	return s
}

func (s *ModifyVpnPbrRouteEntryWeightRequest) SetOverlayMode(v string) *ModifyVpnPbrRouteEntryWeightRequest {
	s.OverlayMode = &v
	return s
}

func (s *ModifyVpnPbrRouteEntryWeightRequest) SetOwnerAccount(v string) *ModifyVpnPbrRouteEntryWeightRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyVpnPbrRouteEntryWeightRequest) SetOwnerId(v int64) *ModifyVpnPbrRouteEntryWeightRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyVpnPbrRouteEntryWeightRequest) SetPriority(v int32) *ModifyVpnPbrRouteEntryWeightRequest {
	s.Priority = &v
	return s
}

func (s *ModifyVpnPbrRouteEntryWeightRequest) SetRegionId(v string) *ModifyVpnPbrRouteEntryWeightRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyVpnPbrRouteEntryWeightRequest) SetResourceOwnerAccount(v string) *ModifyVpnPbrRouteEntryWeightRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyVpnPbrRouteEntryWeightRequest) SetResourceOwnerId(v int64) *ModifyVpnPbrRouteEntryWeightRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ModifyVpnPbrRouteEntryWeightRequest) SetRouteDest(v string) *ModifyVpnPbrRouteEntryWeightRequest {
	s.RouteDest = &v
	return s
}

func (s *ModifyVpnPbrRouteEntryWeightRequest) SetRouteSource(v string) *ModifyVpnPbrRouteEntryWeightRequest {
	s.RouteSource = &v
	return s
}

func (s *ModifyVpnPbrRouteEntryWeightRequest) SetVpnGatewayId(v string) *ModifyVpnPbrRouteEntryWeightRequest {
	s.VpnGatewayId = &v
	return s
}

func (s *ModifyVpnPbrRouteEntryWeightRequest) SetWeight(v int32) *ModifyVpnPbrRouteEntryWeightRequest {
	s.Weight = &v
	return s
}

type ModifyVpnPbrRouteEntryWeightResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyVpnPbrRouteEntryWeightResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyVpnPbrRouteEntryWeightResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyVpnPbrRouteEntryWeightResponseBody) SetRequestId(v string) *ModifyVpnPbrRouteEntryWeightResponseBody {
	s.RequestId = &v
	return s
}

type ModifyVpnPbrRouteEntryWeightResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyVpnPbrRouteEntryWeightResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyVpnPbrRouteEntryWeightResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyVpnPbrRouteEntryWeightResponse) GoString() string {
	return s.String()
}

func (s *ModifyVpnPbrRouteEntryWeightResponse) SetHeaders(v map[string]*string) *ModifyVpnPbrRouteEntryWeightResponse {
	s.Headers = v
	return s
}

func (s *ModifyVpnPbrRouteEntryWeightResponse) SetStatusCode(v int32) *ModifyVpnPbrRouteEntryWeightResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyVpnPbrRouteEntryWeightResponse) SetBody(v *ModifyVpnPbrRouteEntryWeightResponseBody) *ModifyVpnPbrRouteEntryWeightResponse {
	s.Body = v
	return s
}

type ModifyVpnRouteEntryWeightRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, the system automatically uses **RequestId** as **ClientToken**. **RequestId** of each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The new weight that you want to set for the destination-based route. Valid values:
	//
	// *   **0**: a low priority
	// *   **100**: a high priority
	NewWeight *int32 `json:"NewWeight,omitempty" xml:"NewWeight,omitempty"`
	// The next hop of the destination-based route.
	NextHop *string `json:"NextHop,omitempty" xml:"NextHop,omitempty"`
	// The tunneling protocol. Set the value to **Ipsec**.
	OverlayMode  *string `json:"OverlayMode,omitempty" xml:"OverlayMode,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region where the VPN gateway is created. You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The destination CIDR block of the destination-based route.
	RouteDest *string `json:"RouteDest,omitempty" xml:"RouteDest,omitempty"`
	// The ID of the VPN gateway.
	VpnGatewayId *string `json:"VpnGatewayId,omitempty" xml:"VpnGatewayId,omitempty"`
	// The previous weight of the destination-based route. Valid values:
	//
	// *   **0**: a low priority
	// *   **100**: a high priority
	Weight *int32 `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s ModifyVpnRouteEntryWeightRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyVpnRouteEntryWeightRequest) GoString() string {
	return s.String()
}

func (s *ModifyVpnRouteEntryWeightRequest) SetClientToken(v string) *ModifyVpnRouteEntryWeightRequest {
	s.ClientToken = &v
	return s
}

func (s *ModifyVpnRouteEntryWeightRequest) SetNewWeight(v int32) *ModifyVpnRouteEntryWeightRequest {
	s.NewWeight = &v
	return s
}

func (s *ModifyVpnRouteEntryWeightRequest) SetNextHop(v string) *ModifyVpnRouteEntryWeightRequest {
	s.NextHop = &v
	return s
}

func (s *ModifyVpnRouteEntryWeightRequest) SetOverlayMode(v string) *ModifyVpnRouteEntryWeightRequest {
	s.OverlayMode = &v
	return s
}

func (s *ModifyVpnRouteEntryWeightRequest) SetOwnerAccount(v string) *ModifyVpnRouteEntryWeightRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyVpnRouteEntryWeightRequest) SetOwnerId(v int64) *ModifyVpnRouteEntryWeightRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyVpnRouteEntryWeightRequest) SetRegionId(v string) *ModifyVpnRouteEntryWeightRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyVpnRouteEntryWeightRequest) SetResourceOwnerAccount(v string) *ModifyVpnRouteEntryWeightRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyVpnRouteEntryWeightRequest) SetResourceOwnerId(v int64) *ModifyVpnRouteEntryWeightRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ModifyVpnRouteEntryWeightRequest) SetRouteDest(v string) *ModifyVpnRouteEntryWeightRequest {
	s.RouteDest = &v
	return s
}

func (s *ModifyVpnRouteEntryWeightRequest) SetVpnGatewayId(v string) *ModifyVpnRouteEntryWeightRequest {
	s.VpnGatewayId = &v
	return s
}

func (s *ModifyVpnRouteEntryWeightRequest) SetWeight(v int32) *ModifyVpnRouteEntryWeightRequest {
	s.Weight = &v
	return s
}

type ModifyVpnRouteEntryWeightResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyVpnRouteEntryWeightResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyVpnRouteEntryWeightResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyVpnRouteEntryWeightResponseBody) SetRequestId(v string) *ModifyVpnRouteEntryWeightResponseBody {
	s.RequestId = &v
	return s
}

type ModifyVpnRouteEntryWeightResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyVpnRouteEntryWeightResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyVpnRouteEntryWeightResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyVpnRouteEntryWeightResponse) GoString() string {
	return s.String()
}

func (s *ModifyVpnRouteEntryWeightResponse) SetHeaders(v map[string]*string) *ModifyVpnRouteEntryWeightResponse {
	s.Headers = v
	return s
}

func (s *ModifyVpnRouteEntryWeightResponse) SetStatusCode(v int32) *ModifyVpnRouteEntryWeightResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyVpnRouteEntryWeightResponse) SetBody(v *ModifyVpnRouteEntryWeightResponseBody) *ModifyVpnRouteEntryWeightResponse {
	s.Body = v
	return s
}

type MoveResourceGroupRequest struct {
	// The ID of the resource group to which the cloud resource is to be moved.
	//
	// >  You can use resource groups to manage resources owned by your Alibaba Cloud account. Resource groups simplify the resource and permission management of your Alibaba Cloud account. For more information, see [What is resource management?](~~94475~~).
	NewResourceGroupId *string `json:"NewResourceGroupId,omitempty" xml:"NewResourceGroupId,omitempty"`
	OwnerAccount       *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId            *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region to which the cloud resource belongs.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the instance that you want to move.
	ResourceId           *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The type of the resource. Valid values:
	//
	// *   **vpc**: a virtual private cloud (VPC)
	// *   **eip**: an elastic IP address (EIP)
	// *   **bandwidthpackage**: an EIP bandwidth plan
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
}

func (s MoveResourceGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s MoveResourceGroupRequest) GoString() string {
	return s.String()
}

func (s *MoveResourceGroupRequest) SetNewResourceGroupId(v string) *MoveResourceGroupRequest {
	s.NewResourceGroupId = &v
	return s
}

func (s *MoveResourceGroupRequest) SetOwnerAccount(v string) *MoveResourceGroupRequest {
	s.OwnerAccount = &v
	return s
}

func (s *MoveResourceGroupRequest) SetOwnerId(v int64) *MoveResourceGroupRequest {
	s.OwnerId = &v
	return s
}

func (s *MoveResourceGroupRequest) SetRegionId(v string) *MoveResourceGroupRequest {
	s.RegionId = &v
	return s
}

func (s *MoveResourceGroupRequest) SetResourceId(v string) *MoveResourceGroupRequest {
	s.ResourceId = &v
	return s
}

func (s *MoveResourceGroupRequest) SetResourceOwnerAccount(v string) *MoveResourceGroupRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *MoveResourceGroupRequest) SetResourceOwnerId(v int64) *MoveResourceGroupRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *MoveResourceGroupRequest) SetResourceType(v string) *MoveResourceGroupRequest {
	s.ResourceType = &v
	return s
}

type MoveResourceGroupResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s MoveResourceGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s MoveResourceGroupResponseBody) GoString() string {
	return s.String()
}

func (s *MoveResourceGroupResponseBody) SetRequestId(v string) *MoveResourceGroupResponseBody {
	s.RequestId = &v
	return s
}

type MoveResourceGroupResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *MoveResourceGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s MoveResourceGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s MoveResourceGroupResponse) GoString() string {
	return s.String()
}

func (s *MoveResourceGroupResponse) SetHeaders(v map[string]*string) *MoveResourceGroupResponse {
	s.Headers = v
	return s
}

func (s *MoveResourceGroupResponse) SetStatusCode(v int32) *MoveResourceGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *MoveResourceGroupResponse) SetBody(v *MoveResourceGroupResponseBody) *MoveResourceGroupResponse {
	s.Body = v
	return s
}

type OpenFlowLogServiceRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, the system automatically set **ClientToken** to the value of **RequestId**. The value of **RequestId** for each API request is different.
	ClientToken  *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the flow log.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s OpenFlowLogServiceRequest) String() string {
	return tea.Prettify(s)
}

func (s OpenFlowLogServiceRequest) GoString() string {
	return s.String()
}

func (s *OpenFlowLogServiceRequest) SetClientToken(v string) *OpenFlowLogServiceRequest {
	s.ClientToken = &v
	return s
}

func (s *OpenFlowLogServiceRequest) SetOwnerAccount(v string) *OpenFlowLogServiceRequest {
	s.OwnerAccount = &v
	return s
}

func (s *OpenFlowLogServiceRequest) SetOwnerId(v int64) *OpenFlowLogServiceRequest {
	s.OwnerId = &v
	return s
}

func (s *OpenFlowLogServiceRequest) SetRegionId(v string) *OpenFlowLogServiceRequest {
	s.RegionId = &v
	return s
}

func (s *OpenFlowLogServiceRequest) SetResourceOwnerAccount(v string) *OpenFlowLogServiceRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *OpenFlowLogServiceRequest) SetResourceOwnerId(v int64) *OpenFlowLogServiceRequest {
	s.ResourceOwnerId = &v
	return s
}

type OpenFlowLogServiceResponseBody struct {
	// The HTTP status code.
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The information returned after the flow log feature is enabled.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s OpenFlowLogServiceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s OpenFlowLogServiceResponseBody) GoString() string {
	return s.String()
}

func (s *OpenFlowLogServiceResponseBody) SetCode(v string) *OpenFlowLogServiceResponseBody {
	s.Code = &v
	return s
}

func (s *OpenFlowLogServiceResponseBody) SetMessage(v string) *OpenFlowLogServiceResponseBody {
	s.Message = &v
	return s
}

func (s *OpenFlowLogServiceResponseBody) SetRequestId(v string) *OpenFlowLogServiceResponseBody {
	s.RequestId = &v
	return s
}

type OpenFlowLogServiceResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *OpenFlowLogServiceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s OpenFlowLogServiceResponse) String() string {
	return tea.Prettify(s)
}

func (s OpenFlowLogServiceResponse) GoString() string {
	return s.String()
}

func (s *OpenFlowLogServiceResponse) SetHeaders(v map[string]*string) *OpenFlowLogServiceResponse {
	s.Headers = v
	return s
}

func (s *OpenFlowLogServiceResponse) SetStatusCode(v int32) *OpenFlowLogServiceResponse {
	s.StatusCode = &v
	return s
}

func (s *OpenFlowLogServiceResponse) SetBody(v *OpenFlowLogServiceResponseBody) *OpenFlowLogServiceResponse {
	s.Body = v
	return s
}

type OpenPhysicalConnectionServiceRequest struct {
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region where the Express Connect circuit is deployed.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s OpenPhysicalConnectionServiceRequest) String() string {
	return tea.Prettify(s)
}

func (s OpenPhysicalConnectionServiceRequest) GoString() string {
	return s.String()
}

func (s *OpenPhysicalConnectionServiceRequest) SetOwnerAccount(v string) *OpenPhysicalConnectionServiceRequest {
	s.OwnerAccount = &v
	return s
}

func (s *OpenPhysicalConnectionServiceRequest) SetOwnerId(v int64) *OpenPhysicalConnectionServiceRequest {
	s.OwnerId = &v
	return s
}

func (s *OpenPhysicalConnectionServiceRequest) SetRegionId(v string) *OpenPhysicalConnectionServiceRequest {
	s.RegionId = &v
	return s
}

func (s *OpenPhysicalConnectionServiceRequest) SetResourceOwnerAccount(v string) *OpenPhysicalConnectionServiceRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *OpenPhysicalConnectionServiceRequest) SetResourceOwnerId(v int64) *OpenPhysicalConnectionServiceRequest {
	s.ResourceOwnerId = &v
	return s
}

type OpenPhysicalConnectionServiceResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s OpenPhysicalConnectionServiceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s OpenPhysicalConnectionServiceResponseBody) GoString() string {
	return s.String()
}

func (s *OpenPhysicalConnectionServiceResponseBody) SetRequestId(v string) *OpenPhysicalConnectionServiceResponseBody {
	s.RequestId = &v
	return s
}

type OpenPhysicalConnectionServiceResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *OpenPhysicalConnectionServiceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s OpenPhysicalConnectionServiceResponse) String() string {
	return tea.Prettify(s)
}

func (s OpenPhysicalConnectionServiceResponse) GoString() string {
	return s.String()
}

func (s *OpenPhysicalConnectionServiceResponse) SetHeaders(v map[string]*string) *OpenPhysicalConnectionServiceResponse {
	s.Headers = v
	return s
}

func (s *OpenPhysicalConnectionServiceResponse) SetStatusCode(v int32) *OpenPhysicalConnectionServiceResponse {
	s.StatusCode = &v
	return s
}

func (s *OpenPhysicalConnectionServiceResponse) SetBody(v *OpenPhysicalConnectionServiceResponseBody) *OpenPhysicalConnectionServiceResponse {
	s.Body = v
	return s
}

type OpenTrafficMirrorServiceRequest struct {
	ClientToken          *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s OpenTrafficMirrorServiceRequest) String() string {
	return tea.Prettify(s)
}

func (s OpenTrafficMirrorServiceRequest) GoString() string {
	return s.String()
}

func (s *OpenTrafficMirrorServiceRequest) SetClientToken(v string) *OpenTrafficMirrorServiceRequest {
	s.ClientToken = &v
	return s
}

func (s *OpenTrafficMirrorServiceRequest) SetOwnerAccount(v string) *OpenTrafficMirrorServiceRequest {
	s.OwnerAccount = &v
	return s
}

func (s *OpenTrafficMirrorServiceRequest) SetOwnerId(v int64) *OpenTrafficMirrorServiceRequest {
	s.OwnerId = &v
	return s
}

func (s *OpenTrafficMirrorServiceRequest) SetRegionId(v string) *OpenTrafficMirrorServiceRequest {
	s.RegionId = &v
	return s
}

func (s *OpenTrafficMirrorServiceRequest) SetResourceOwnerAccount(v string) *OpenTrafficMirrorServiceRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *OpenTrafficMirrorServiceRequest) SetResourceOwnerId(v int64) *OpenTrafficMirrorServiceRequest {
	s.ResourceOwnerId = &v
	return s
}

type OpenTrafficMirrorServiceResponseBody struct {
	Code    *string `json:"Code,omitempty" xml:"Code,omitempty"`
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s OpenTrafficMirrorServiceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s OpenTrafficMirrorServiceResponseBody) GoString() string {
	return s.String()
}

func (s *OpenTrafficMirrorServiceResponseBody) SetCode(v string) *OpenTrafficMirrorServiceResponseBody {
	s.Code = &v
	return s
}

func (s *OpenTrafficMirrorServiceResponseBody) SetMessage(v string) *OpenTrafficMirrorServiceResponseBody {
	s.Message = &v
	return s
}

func (s *OpenTrafficMirrorServiceResponseBody) SetRequestId(v string) *OpenTrafficMirrorServiceResponseBody {
	s.RequestId = &v
	return s
}

type OpenTrafficMirrorServiceResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *OpenTrafficMirrorServiceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s OpenTrafficMirrorServiceResponse) String() string {
	return tea.Prettify(s)
}

func (s OpenTrafficMirrorServiceResponse) GoString() string {
	return s.String()
}

func (s *OpenTrafficMirrorServiceResponse) SetHeaders(v map[string]*string) *OpenTrafficMirrorServiceResponse {
	s.Headers = v
	return s
}

func (s *OpenTrafficMirrorServiceResponse) SetStatusCode(v int32) *OpenTrafficMirrorServiceResponse {
	s.StatusCode = &v
	return s
}

func (s *OpenTrafficMirrorServiceResponse) SetBody(v *OpenTrafficMirrorServiceResponseBody) *OpenTrafficMirrorServiceResponse {
	s.Body = v
	return s
}

type PublishVpnRouteEntryRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The next hop of the VPN gateway route.
	NextHop      *string `json:"NextHop,omitempty" xml:"NextHop,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// Specifies whether to advertise the VPN gateway route to the VPC route table. Valid values:
	//
	// *   **true**: yes
	// *   **false**: no
	PublishVpc *bool `json:"PublishVpc,omitempty" xml:"PublishVpc,omitempty"`
	// The ID of the region where the VPN gateway is created.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The destination CIDR block of the VPN gateway route.
	RouteDest *string `json:"RouteDest,omitempty" xml:"RouteDest,omitempty"`
	// The type of the VPN gateway route. Valid values:
	//
	// *   **pbr**: policy-based route
	// *   **dbr**: destination-based route
	RouteType *string `json:"RouteType,omitempty" xml:"RouteType,omitempty"`
	// The ID of the VPN gateway.
	VpnGatewayId *string `json:"VpnGatewayId,omitempty" xml:"VpnGatewayId,omitempty"`
}

func (s PublishVpnRouteEntryRequest) String() string {
	return tea.Prettify(s)
}

func (s PublishVpnRouteEntryRequest) GoString() string {
	return s.String()
}

func (s *PublishVpnRouteEntryRequest) SetClientToken(v string) *PublishVpnRouteEntryRequest {
	s.ClientToken = &v
	return s
}

func (s *PublishVpnRouteEntryRequest) SetNextHop(v string) *PublishVpnRouteEntryRequest {
	s.NextHop = &v
	return s
}

func (s *PublishVpnRouteEntryRequest) SetOwnerAccount(v string) *PublishVpnRouteEntryRequest {
	s.OwnerAccount = &v
	return s
}

func (s *PublishVpnRouteEntryRequest) SetOwnerId(v int64) *PublishVpnRouteEntryRequest {
	s.OwnerId = &v
	return s
}

func (s *PublishVpnRouteEntryRequest) SetPublishVpc(v bool) *PublishVpnRouteEntryRequest {
	s.PublishVpc = &v
	return s
}

func (s *PublishVpnRouteEntryRequest) SetRegionId(v string) *PublishVpnRouteEntryRequest {
	s.RegionId = &v
	return s
}

func (s *PublishVpnRouteEntryRequest) SetResourceOwnerAccount(v string) *PublishVpnRouteEntryRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *PublishVpnRouteEntryRequest) SetResourceOwnerId(v int64) *PublishVpnRouteEntryRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *PublishVpnRouteEntryRequest) SetRouteDest(v string) *PublishVpnRouteEntryRequest {
	s.RouteDest = &v
	return s
}

func (s *PublishVpnRouteEntryRequest) SetRouteType(v string) *PublishVpnRouteEntryRequest {
	s.RouteType = &v
	return s
}

func (s *PublishVpnRouteEntryRequest) SetVpnGatewayId(v string) *PublishVpnRouteEntryRequest {
	s.VpnGatewayId = &v
	return s
}

type PublishVpnRouteEntryResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s PublishVpnRouteEntryResponseBody) String() string {
	return tea.Prettify(s)
}

func (s PublishVpnRouteEntryResponseBody) GoString() string {
	return s.String()
}

func (s *PublishVpnRouteEntryResponseBody) SetRequestId(v string) *PublishVpnRouteEntryResponseBody {
	s.RequestId = &v
	return s
}

type PublishVpnRouteEntryResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *PublishVpnRouteEntryResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s PublishVpnRouteEntryResponse) String() string {
	return tea.Prettify(s)
}

func (s PublishVpnRouteEntryResponse) GoString() string {
	return s.String()
}

func (s *PublishVpnRouteEntryResponse) SetHeaders(v map[string]*string) *PublishVpnRouteEntryResponse {
	s.Headers = v
	return s
}

func (s *PublishVpnRouteEntryResponse) SetStatusCode(v int32) *PublishVpnRouteEntryResponse {
	s.StatusCode = &v
	return s
}

func (s *PublishVpnRouteEntryResponse) SetBody(v *PublishVpnRouteEntryResponseBody) *PublishVpnRouteEntryResponse {
	s.Body = v
	return s
}

type RecoverPhysicalConnectionRequest struct {
	// Specifies whether to precheck the request only. Valid values:
	//
	// *   **true**: only prechecks the request but does not resume the Express Connect circuit. The system prechecks the request syntax, instance status, and whether the required parameters are specified. An error message is returned if the request fails to pass the precheck. If the request passes the precheck, the system returns the ID of the request.
	// *   **false** (default): sends the request. If the request passes the precheck, the Express Connect circuit is resumed.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The ID of the Express Connect circuit.
	//
	// >  You can resume only shared Express Connect circuits.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The region ID of the Express Connect circuit.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate a token, but you must make sure that it is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	Token *string `json:"Token,omitempty" xml:"Token,omitempty"`
}

func (s RecoverPhysicalConnectionRequest) String() string {
	return tea.Prettify(s)
}

func (s RecoverPhysicalConnectionRequest) GoString() string {
	return s.String()
}

func (s *RecoverPhysicalConnectionRequest) SetDryRun(v bool) *RecoverPhysicalConnectionRequest {
	s.DryRun = &v
	return s
}

func (s *RecoverPhysicalConnectionRequest) SetInstanceId(v string) *RecoverPhysicalConnectionRequest {
	s.InstanceId = &v
	return s
}

func (s *RecoverPhysicalConnectionRequest) SetRegionId(v string) *RecoverPhysicalConnectionRequest {
	s.RegionId = &v
	return s
}

func (s *RecoverPhysicalConnectionRequest) SetToken(v string) *RecoverPhysicalConnectionRequest {
	s.Token = &v
	return s
}

type RecoverPhysicalConnectionResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s RecoverPhysicalConnectionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RecoverPhysicalConnectionResponseBody) GoString() string {
	return s.String()
}

func (s *RecoverPhysicalConnectionResponseBody) SetRequestId(v string) *RecoverPhysicalConnectionResponseBody {
	s.RequestId = &v
	return s
}

type RecoverPhysicalConnectionResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RecoverPhysicalConnectionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RecoverPhysicalConnectionResponse) String() string {
	return tea.Prettify(s)
}

func (s RecoverPhysicalConnectionResponse) GoString() string {
	return s.String()
}

func (s *RecoverPhysicalConnectionResponse) SetHeaders(v map[string]*string) *RecoverPhysicalConnectionResponse {
	s.Headers = v
	return s
}

func (s *RecoverPhysicalConnectionResponse) SetStatusCode(v int32) *RecoverPhysicalConnectionResponse {
	s.StatusCode = &v
	return s
}

func (s *RecoverPhysicalConnectionResponse) SetBody(v *RecoverPhysicalConnectionResponseBody) *RecoverPhysicalConnectionResponse {
	s.Body = v
	return s
}

type RecoverVirtualBorderRouterRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value. Make sure that the value is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken  *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region where the VBR is deployed.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the VBR.
	VbrId *string `json:"VbrId,omitempty" xml:"VbrId,omitempty"`
}

func (s RecoverVirtualBorderRouterRequest) String() string {
	return tea.Prettify(s)
}

func (s RecoverVirtualBorderRouterRequest) GoString() string {
	return s.String()
}

func (s *RecoverVirtualBorderRouterRequest) SetClientToken(v string) *RecoverVirtualBorderRouterRequest {
	s.ClientToken = &v
	return s
}

func (s *RecoverVirtualBorderRouterRequest) SetOwnerAccount(v string) *RecoverVirtualBorderRouterRequest {
	s.OwnerAccount = &v
	return s
}

func (s *RecoverVirtualBorderRouterRequest) SetOwnerId(v int64) *RecoverVirtualBorderRouterRequest {
	s.OwnerId = &v
	return s
}

func (s *RecoverVirtualBorderRouterRequest) SetRegionId(v string) *RecoverVirtualBorderRouterRequest {
	s.RegionId = &v
	return s
}

func (s *RecoverVirtualBorderRouterRequest) SetResourceOwnerAccount(v string) *RecoverVirtualBorderRouterRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *RecoverVirtualBorderRouterRequest) SetResourceOwnerId(v int64) *RecoverVirtualBorderRouterRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *RecoverVirtualBorderRouterRequest) SetVbrId(v string) *RecoverVirtualBorderRouterRequest {
	s.VbrId = &v
	return s
}

type RecoverVirtualBorderRouterResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s RecoverVirtualBorderRouterResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RecoverVirtualBorderRouterResponseBody) GoString() string {
	return s.String()
}

func (s *RecoverVirtualBorderRouterResponseBody) SetRequestId(v string) *RecoverVirtualBorderRouterResponseBody {
	s.RequestId = &v
	return s
}

type RecoverVirtualBorderRouterResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RecoverVirtualBorderRouterResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RecoverVirtualBorderRouterResponse) String() string {
	return tea.Prettify(s)
}

func (s RecoverVirtualBorderRouterResponse) GoString() string {
	return s.String()
}

func (s *RecoverVirtualBorderRouterResponse) SetHeaders(v map[string]*string) *RecoverVirtualBorderRouterResponse {
	s.Headers = v
	return s
}

func (s *RecoverVirtualBorderRouterResponse) SetStatusCode(v int32) *RecoverVirtualBorderRouterResponse {
	s.StatusCode = &v
	return s
}

func (s *RecoverVirtualBorderRouterResponse) SetBody(v *RecoverVirtualBorderRouterResponseBody) *RecoverVirtualBorderRouterResponse {
	s.Body = v
	return s
}

type ReleaseEipAddressRequest struct {
	// The ID of the EIP that you want to release.
	AllocationId *string `json:"AllocationId,omitempty" xml:"AllocationId,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region to which the EIP belongs. You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ReleaseEipAddressRequest) String() string {
	return tea.Prettify(s)
}

func (s ReleaseEipAddressRequest) GoString() string {
	return s.String()
}

func (s *ReleaseEipAddressRequest) SetAllocationId(v string) *ReleaseEipAddressRequest {
	s.AllocationId = &v
	return s
}

func (s *ReleaseEipAddressRequest) SetOwnerAccount(v string) *ReleaseEipAddressRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ReleaseEipAddressRequest) SetOwnerId(v int64) *ReleaseEipAddressRequest {
	s.OwnerId = &v
	return s
}

func (s *ReleaseEipAddressRequest) SetRegionId(v string) *ReleaseEipAddressRequest {
	s.RegionId = &v
	return s
}

func (s *ReleaseEipAddressRequest) SetResourceOwnerAccount(v string) *ReleaseEipAddressRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ReleaseEipAddressRequest) SetResourceOwnerId(v int64) *ReleaseEipAddressRequest {
	s.ResourceOwnerId = &v
	return s
}

type ReleaseEipAddressResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ReleaseEipAddressResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ReleaseEipAddressResponseBody) GoString() string {
	return s.String()
}

func (s *ReleaseEipAddressResponseBody) SetRequestId(v string) *ReleaseEipAddressResponseBody {
	s.RequestId = &v
	return s
}

type ReleaseEipAddressResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ReleaseEipAddressResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ReleaseEipAddressResponse) String() string {
	return tea.Prettify(s)
}

func (s ReleaseEipAddressResponse) GoString() string {
	return s.String()
}

func (s *ReleaseEipAddressResponse) SetHeaders(v map[string]*string) *ReleaseEipAddressResponse {
	s.Headers = v
	return s
}

func (s *ReleaseEipAddressResponse) SetStatusCode(v int32) *ReleaseEipAddressResponse {
	s.StatusCode = &v
	return s
}

func (s *ReleaseEipAddressResponse) SetBody(v *ReleaseEipAddressResponseBody) *ReleaseEipAddressResponse {
	s.Body = v
	return s
}

type ReleaseEipSegmentAddressRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, the system uses **RequestId** as **ClientToken**. The value of **RequestId** for each API request may be different.
	ClientToken  *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the contiguous EIPs. You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the group to which the contiguous EIPs to be released belongs.
	//
	// The system releases all EIPs in the group.
	SegmentInstanceId *string `json:"SegmentInstanceId,omitempty" xml:"SegmentInstanceId,omitempty"`
}

func (s ReleaseEipSegmentAddressRequest) String() string {
	return tea.Prettify(s)
}

func (s ReleaseEipSegmentAddressRequest) GoString() string {
	return s.String()
}

func (s *ReleaseEipSegmentAddressRequest) SetClientToken(v string) *ReleaseEipSegmentAddressRequest {
	s.ClientToken = &v
	return s
}

func (s *ReleaseEipSegmentAddressRequest) SetOwnerAccount(v string) *ReleaseEipSegmentAddressRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ReleaseEipSegmentAddressRequest) SetOwnerId(v int64) *ReleaseEipSegmentAddressRequest {
	s.OwnerId = &v
	return s
}

func (s *ReleaseEipSegmentAddressRequest) SetRegionId(v string) *ReleaseEipSegmentAddressRequest {
	s.RegionId = &v
	return s
}

func (s *ReleaseEipSegmentAddressRequest) SetResourceOwnerAccount(v string) *ReleaseEipSegmentAddressRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ReleaseEipSegmentAddressRequest) SetResourceOwnerId(v int64) *ReleaseEipSegmentAddressRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ReleaseEipSegmentAddressRequest) SetSegmentInstanceId(v string) *ReleaseEipSegmentAddressRequest {
	s.SegmentInstanceId = &v
	return s
}

type ReleaseEipSegmentAddressResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ReleaseEipSegmentAddressResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ReleaseEipSegmentAddressResponseBody) GoString() string {
	return s.String()
}

func (s *ReleaseEipSegmentAddressResponseBody) SetRequestId(v string) *ReleaseEipSegmentAddressResponseBody {
	s.RequestId = &v
	return s
}

type ReleaseEipSegmentAddressResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ReleaseEipSegmentAddressResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ReleaseEipSegmentAddressResponse) String() string {
	return tea.Prettify(s)
}

func (s ReleaseEipSegmentAddressResponse) GoString() string {
	return s.String()
}

func (s *ReleaseEipSegmentAddressResponse) SetHeaders(v map[string]*string) *ReleaseEipSegmentAddressResponse {
	s.Headers = v
	return s
}

func (s *ReleaseEipSegmentAddressResponse) SetStatusCode(v int32) *ReleaseEipSegmentAddressResponse {
	s.StatusCode = &v
	return s
}

func (s *ReleaseEipSegmentAddressResponse) SetBody(v *ReleaseEipSegmentAddressResponseBody) *ReleaseEipSegmentAddressResponse {
	s.Body = v
	return s
}

type RemoveCommonBandwidthPackageIpRequest struct {
	// The ID of the EIP bandwidth plan.
	BandwidthPackageId *string `json:"BandwidthPackageId,omitempty" xml:"BandwidthPackageId,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. ClientToken can contain only ASCII characters.
	//
	// >  If you do not set this parameter, the system automatically uses **RequestId** as **ClientToken**. **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the EIP.
	//
	// You can call the [DescribeEipAddresses](~~36018~~) operation to query the most recent region list.
	IpInstanceId *string `json:"IpInstanceId,omitempty" xml:"IpInstanceId,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the EIP bandwidth plan.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s RemoveCommonBandwidthPackageIpRequest) String() string {
	return tea.Prettify(s)
}

func (s RemoveCommonBandwidthPackageIpRequest) GoString() string {
	return s.String()
}

func (s *RemoveCommonBandwidthPackageIpRequest) SetBandwidthPackageId(v string) *RemoveCommonBandwidthPackageIpRequest {
	s.BandwidthPackageId = &v
	return s
}

func (s *RemoveCommonBandwidthPackageIpRequest) SetClientToken(v string) *RemoveCommonBandwidthPackageIpRequest {
	s.ClientToken = &v
	return s
}

func (s *RemoveCommonBandwidthPackageIpRequest) SetIpInstanceId(v string) *RemoveCommonBandwidthPackageIpRequest {
	s.IpInstanceId = &v
	return s
}

func (s *RemoveCommonBandwidthPackageIpRequest) SetOwnerAccount(v string) *RemoveCommonBandwidthPackageIpRequest {
	s.OwnerAccount = &v
	return s
}

func (s *RemoveCommonBandwidthPackageIpRequest) SetOwnerId(v int64) *RemoveCommonBandwidthPackageIpRequest {
	s.OwnerId = &v
	return s
}

func (s *RemoveCommonBandwidthPackageIpRequest) SetRegionId(v string) *RemoveCommonBandwidthPackageIpRequest {
	s.RegionId = &v
	return s
}

func (s *RemoveCommonBandwidthPackageIpRequest) SetResourceOwnerAccount(v string) *RemoveCommonBandwidthPackageIpRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *RemoveCommonBandwidthPackageIpRequest) SetResourceOwnerId(v int64) *RemoveCommonBandwidthPackageIpRequest {
	s.ResourceOwnerId = &v
	return s
}

type RemoveCommonBandwidthPackageIpResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s RemoveCommonBandwidthPackageIpResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RemoveCommonBandwidthPackageIpResponseBody) GoString() string {
	return s.String()
}

func (s *RemoveCommonBandwidthPackageIpResponseBody) SetRequestId(v string) *RemoveCommonBandwidthPackageIpResponseBody {
	s.RequestId = &v
	return s
}

type RemoveCommonBandwidthPackageIpResponse struct {
	Headers    map[string]*string                          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RemoveCommonBandwidthPackageIpResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RemoveCommonBandwidthPackageIpResponse) String() string {
	return tea.Prettify(s)
}

func (s RemoveCommonBandwidthPackageIpResponse) GoString() string {
	return s.String()
}

func (s *RemoveCommonBandwidthPackageIpResponse) SetHeaders(v map[string]*string) *RemoveCommonBandwidthPackageIpResponse {
	s.Headers = v
	return s
}

func (s *RemoveCommonBandwidthPackageIpResponse) SetStatusCode(v int32) *RemoveCommonBandwidthPackageIpResponse {
	s.StatusCode = &v
	return s
}

func (s *RemoveCommonBandwidthPackageIpResponse) SetBody(v *RemoveCommonBandwidthPackageIpResponseBody) *RemoveCommonBandwidthPackageIpResponse {
	s.Body = v
	return s
}

type RemoveGlobalAccelerationInstanceIpRequest struct {
	// The ID of the shared-bandwidth instance.
	GlobalAccelerationInstanceId *string `json:"GlobalAccelerationInstanceId,omitempty" xml:"GlobalAccelerationInstanceId,omitempty"`
	// The ID of the EIP.
	//
	// To query the EIP ID, call DescribeEipAddresses.
	IpInstanceId *string `json:"IpInstanceId,omitempty" xml:"IpInstanceId,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region where the shared-bandwidth instance is located.
	//
	// To query the region ID, call DescribeRegions.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s RemoveGlobalAccelerationInstanceIpRequest) String() string {
	return tea.Prettify(s)
}

func (s RemoveGlobalAccelerationInstanceIpRequest) GoString() string {
	return s.String()
}

func (s *RemoveGlobalAccelerationInstanceIpRequest) SetGlobalAccelerationInstanceId(v string) *RemoveGlobalAccelerationInstanceIpRequest {
	s.GlobalAccelerationInstanceId = &v
	return s
}

func (s *RemoveGlobalAccelerationInstanceIpRequest) SetIpInstanceId(v string) *RemoveGlobalAccelerationInstanceIpRequest {
	s.IpInstanceId = &v
	return s
}

func (s *RemoveGlobalAccelerationInstanceIpRequest) SetOwnerAccount(v string) *RemoveGlobalAccelerationInstanceIpRequest {
	s.OwnerAccount = &v
	return s
}

func (s *RemoveGlobalAccelerationInstanceIpRequest) SetOwnerId(v int64) *RemoveGlobalAccelerationInstanceIpRequest {
	s.OwnerId = &v
	return s
}

func (s *RemoveGlobalAccelerationInstanceIpRequest) SetRegionId(v string) *RemoveGlobalAccelerationInstanceIpRequest {
	s.RegionId = &v
	return s
}

func (s *RemoveGlobalAccelerationInstanceIpRequest) SetResourceOwnerAccount(v string) *RemoveGlobalAccelerationInstanceIpRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *RemoveGlobalAccelerationInstanceIpRequest) SetResourceOwnerId(v int64) *RemoveGlobalAccelerationInstanceIpRequest {
	s.ResourceOwnerId = &v
	return s
}

type RemoveGlobalAccelerationInstanceIpResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s RemoveGlobalAccelerationInstanceIpResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RemoveGlobalAccelerationInstanceIpResponseBody) GoString() string {
	return s.String()
}

func (s *RemoveGlobalAccelerationInstanceIpResponseBody) SetRequestId(v string) *RemoveGlobalAccelerationInstanceIpResponseBody {
	s.RequestId = &v
	return s
}

type RemoveGlobalAccelerationInstanceIpResponse struct {
	Headers    map[string]*string                              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RemoveGlobalAccelerationInstanceIpResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RemoveGlobalAccelerationInstanceIpResponse) String() string {
	return tea.Prettify(s)
}

func (s RemoveGlobalAccelerationInstanceIpResponse) GoString() string {
	return s.String()
}

func (s *RemoveGlobalAccelerationInstanceIpResponse) SetHeaders(v map[string]*string) *RemoveGlobalAccelerationInstanceIpResponse {
	s.Headers = v
	return s
}

func (s *RemoveGlobalAccelerationInstanceIpResponse) SetStatusCode(v int32) *RemoveGlobalAccelerationInstanceIpResponse {
	s.StatusCode = &v
	return s
}

func (s *RemoveGlobalAccelerationInstanceIpResponse) SetBody(v *RemoveGlobalAccelerationInstanceIpResponseBody) *RemoveGlobalAccelerationInstanceIpResponse {
	s.Body = v
	return s
}

type RemoveIPv6TranslatorAclListEntryRequest struct {
	// The ID of the ACL entry to be deleted.
	AclEntryId *string `json:"AclEntryId,omitempty" xml:"AclEntryId,omitempty"`
	// The ID of the ACL to which the ACL entry belongs.
	AclId *string `json:"AclId,omitempty" xml:"AclId,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters.
	ClientToken  *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region of the ACL.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s RemoveIPv6TranslatorAclListEntryRequest) String() string {
	return tea.Prettify(s)
}

func (s RemoveIPv6TranslatorAclListEntryRequest) GoString() string {
	return s.String()
}

func (s *RemoveIPv6TranslatorAclListEntryRequest) SetAclEntryId(v string) *RemoveIPv6TranslatorAclListEntryRequest {
	s.AclEntryId = &v
	return s
}

func (s *RemoveIPv6TranslatorAclListEntryRequest) SetAclId(v string) *RemoveIPv6TranslatorAclListEntryRequest {
	s.AclId = &v
	return s
}

func (s *RemoveIPv6TranslatorAclListEntryRequest) SetClientToken(v string) *RemoveIPv6TranslatorAclListEntryRequest {
	s.ClientToken = &v
	return s
}

func (s *RemoveIPv6TranslatorAclListEntryRequest) SetOwnerAccount(v string) *RemoveIPv6TranslatorAclListEntryRequest {
	s.OwnerAccount = &v
	return s
}

func (s *RemoveIPv6TranslatorAclListEntryRequest) SetOwnerId(v int64) *RemoveIPv6TranslatorAclListEntryRequest {
	s.OwnerId = &v
	return s
}

func (s *RemoveIPv6TranslatorAclListEntryRequest) SetRegionId(v string) *RemoveIPv6TranslatorAclListEntryRequest {
	s.RegionId = &v
	return s
}

func (s *RemoveIPv6TranslatorAclListEntryRequest) SetResourceOwnerAccount(v string) *RemoveIPv6TranslatorAclListEntryRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *RemoveIPv6TranslatorAclListEntryRequest) SetResourceOwnerId(v int64) *RemoveIPv6TranslatorAclListEntryRequest {
	s.ResourceOwnerId = &v
	return s
}

type RemoveIPv6TranslatorAclListEntryResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s RemoveIPv6TranslatorAclListEntryResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RemoveIPv6TranslatorAclListEntryResponseBody) GoString() string {
	return s.String()
}

func (s *RemoveIPv6TranslatorAclListEntryResponseBody) SetRequestId(v string) *RemoveIPv6TranslatorAclListEntryResponseBody {
	s.RequestId = &v
	return s
}

type RemoveIPv6TranslatorAclListEntryResponse struct {
	Headers    map[string]*string                            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RemoveIPv6TranslatorAclListEntryResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RemoveIPv6TranslatorAclListEntryResponse) String() string {
	return tea.Prettify(s)
}

func (s RemoveIPv6TranslatorAclListEntryResponse) GoString() string {
	return s.String()
}

func (s *RemoveIPv6TranslatorAclListEntryResponse) SetHeaders(v map[string]*string) *RemoveIPv6TranslatorAclListEntryResponse {
	s.Headers = v
	return s
}

func (s *RemoveIPv6TranslatorAclListEntryResponse) SetStatusCode(v int32) *RemoveIPv6TranslatorAclListEntryResponse {
	s.StatusCode = &v
	return s
}

func (s *RemoveIPv6TranslatorAclListEntryResponse) SetBody(v *RemoveIPv6TranslatorAclListEntryResponseBody) *RemoveIPv6TranslatorAclListEntryResponse {
	s.Body = v
	return s
}

type RemoveSourcesFromTrafficMirrorSessionRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that the value is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	//
	// >  If you do not set this parameter, the system uses **RequestId** as **ClientToken**. **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to check the request without performing the operation. Valid values:
	//
	// *   **true**: checks the request without performing the operation. The system checks the required parameters, request format, and limits. If the request fails the check, an error message is returned. If the request passes the check, the `DryRunOperation` error code is returned.
	// *   **false** (default): sends the request. After the request passes the check, the operation is performed.
	DryRun       *bool   `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region to which the traffic mirror session belongs. You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list. For more information about regions that support traffic mirroring, see [Overview of traffic mirroring](~~207513~~).
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the traffic mirror session from which you want to delete a traffic mirror source.
	TrafficMirrorSessionId *string   `json:"TrafficMirrorSessionId,omitempty" xml:"TrafficMirrorSessionId,omitempty"`
	TrafficMirrorSourceIds []*string `json:"TrafficMirrorSourceIds,omitempty" xml:"TrafficMirrorSourceIds,omitempty" type:"Repeated"`
}

func (s RemoveSourcesFromTrafficMirrorSessionRequest) String() string {
	return tea.Prettify(s)
}

func (s RemoveSourcesFromTrafficMirrorSessionRequest) GoString() string {
	return s.String()
}

func (s *RemoveSourcesFromTrafficMirrorSessionRequest) SetClientToken(v string) *RemoveSourcesFromTrafficMirrorSessionRequest {
	s.ClientToken = &v
	return s
}

func (s *RemoveSourcesFromTrafficMirrorSessionRequest) SetDryRun(v bool) *RemoveSourcesFromTrafficMirrorSessionRequest {
	s.DryRun = &v
	return s
}

func (s *RemoveSourcesFromTrafficMirrorSessionRequest) SetOwnerAccount(v string) *RemoveSourcesFromTrafficMirrorSessionRequest {
	s.OwnerAccount = &v
	return s
}

func (s *RemoveSourcesFromTrafficMirrorSessionRequest) SetOwnerId(v int64) *RemoveSourcesFromTrafficMirrorSessionRequest {
	s.OwnerId = &v
	return s
}

func (s *RemoveSourcesFromTrafficMirrorSessionRequest) SetRegionId(v string) *RemoveSourcesFromTrafficMirrorSessionRequest {
	s.RegionId = &v
	return s
}

func (s *RemoveSourcesFromTrafficMirrorSessionRequest) SetResourceOwnerAccount(v string) *RemoveSourcesFromTrafficMirrorSessionRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *RemoveSourcesFromTrafficMirrorSessionRequest) SetResourceOwnerId(v int64) *RemoveSourcesFromTrafficMirrorSessionRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *RemoveSourcesFromTrafficMirrorSessionRequest) SetTrafficMirrorSessionId(v string) *RemoveSourcesFromTrafficMirrorSessionRequest {
	s.TrafficMirrorSessionId = &v
	return s
}

func (s *RemoveSourcesFromTrafficMirrorSessionRequest) SetTrafficMirrorSourceIds(v []*string) *RemoveSourcesFromTrafficMirrorSessionRequest {
	s.TrafficMirrorSourceIds = v
	return s
}

type RemoveSourcesFromTrafficMirrorSessionResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s RemoveSourcesFromTrafficMirrorSessionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RemoveSourcesFromTrafficMirrorSessionResponseBody) GoString() string {
	return s.String()
}

func (s *RemoveSourcesFromTrafficMirrorSessionResponseBody) SetRequestId(v string) *RemoveSourcesFromTrafficMirrorSessionResponseBody {
	s.RequestId = &v
	return s
}

type RemoveSourcesFromTrafficMirrorSessionResponse struct {
	Headers    map[string]*string                                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RemoveSourcesFromTrafficMirrorSessionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RemoveSourcesFromTrafficMirrorSessionResponse) String() string {
	return tea.Prettify(s)
}

func (s RemoveSourcesFromTrafficMirrorSessionResponse) GoString() string {
	return s.String()
}

func (s *RemoveSourcesFromTrafficMirrorSessionResponse) SetHeaders(v map[string]*string) *RemoveSourcesFromTrafficMirrorSessionResponse {
	s.Headers = v
	return s
}

func (s *RemoveSourcesFromTrafficMirrorSessionResponse) SetStatusCode(v int32) *RemoveSourcesFromTrafficMirrorSessionResponse {
	s.StatusCode = &v
	return s
}

func (s *RemoveSourcesFromTrafficMirrorSessionResponse) SetBody(v *RemoveSourcesFromTrafficMirrorSessionResponseBody) *RemoveSourcesFromTrafficMirrorSessionResponse {
	s.Body = v
	return s
}

type ReplaceVpcDhcpOptionsSetRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, the system uses **RequestId** as **ClientToken**. **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the new DHCP options set.
	DhcpOptionsSetId *string `json:"DhcpOptionsSetId,omitempty" xml:"DhcpOptionsSetId,omitempty"`
	// Specifies whether to check the request without performing the operation. Valid values:
	//
	// *   **true**: checks the request without performing the operation. The system checks whether your AccessKey pair is valid, whether the Resource Access Management (RAM) user is authorized, and whether the required parameters are set. If the request fails to pass the check, the corresponding error message is returned. If the request passes the check, the DryRunOperation error code is returned.
	// *   **false** (default): sends the request. If the request passes the check, a 2XX HTTP status code is returned and the operation is performed.
	DryRun       *bool   `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region to which the DHCP options set belongs. You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the associated VPC.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s ReplaceVpcDhcpOptionsSetRequest) String() string {
	return tea.Prettify(s)
}

func (s ReplaceVpcDhcpOptionsSetRequest) GoString() string {
	return s.String()
}

func (s *ReplaceVpcDhcpOptionsSetRequest) SetClientToken(v string) *ReplaceVpcDhcpOptionsSetRequest {
	s.ClientToken = &v
	return s
}

func (s *ReplaceVpcDhcpOptionsSetRequest) SetDhcpOptionsSetId(v string) *ReplaceVpcDhcpOptionsSetRequest {
	s.DhcpOptionsSetId = &v
	return s
}

func (s *ReplaceVpcDhcpOptionsSetRequest) SetDryRun(v bool) *ReplaceVpcDhcpOptionsSetRequest {
	s.DryRun = &v
	return s
}

func (s *ReplaceVpcDhcpOptionsSetRequest) SetOwnerAccount(v string) *ReplaceVpcDhcpOptionsSetRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ReplaceVpcDhcpOptionsSetRequest) SetOwnerId(v int64) *ReplaceVpcDhcpOptionsSetRequest {
	s.OwnerId = &v
	return s
}

func (s *ReplaceVpcDhcpOptionsSetRequest) SetRegionId(v string) *ReplaceVpcDhcpOptionsSetRequest {
	s.RegionId = &v
	return s
}

func (s *ReplaceVpcDhcpOptionsSetRequest) SetResourceOwnerAccount(v string) *ReplaceVpcDhcpOptionsSetRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ReplaceVpcDhcpOptionsSetRequest) SetResourceOwnerId(v int64) *ReplaceVpcDhcpOptionsSetRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ReplaceVpcDhcpOptionsSetRequest) SetVpcId(v string) *ReplaceVpcDhcpOptionsSetRequest {
	s.VpcId = &v
	return s
}

type ReplaceVpcDhcpOptionsSetResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ReplaceVpcDhcpOptionsSetResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ReplaceVpcDhcpOptionsSetResponseBody) GoString() string {
	return s.String()
}

func (s *ReplaceVpcDhcpOptionsSetResponseBody) SetRequestId(v string) *ReplaceVpcDhcpOptionsSetResponseBody {
	s.RequestId = &v
	return s
}

type ReplaceVpcDhcpOptionsSetResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ReplaceVpcDhcpOptionsSetResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ReplaceVpcDhcpOptionsSetResponse) String() string {
	return tea.Prettify(s)
}

func (s ReplaceVpcDhcpOptionsSetResponse) GoString() string {
	return s.String()
}

func (s *ReplaceVpcDhcpOptionsSetResponse) SetHeaders(v map[string]*string) *ReplaceVpcDhcpOptionsSetResponse {
	s.Headers = v
	return s
}

func (s *ReplaceVpcDhcpOptionsSetResponse) SetStatusCode(v int32) *ReplaceVpcDhcpOptionsSetResponse {
	s.StatusCode = &v
	return s
}

func (s *ReplaceVpcDhcpOptionsSetResponse) SetBody(v *ReplaceVpcDhcpOptionsSetResponseBody) *ReplaceVpcDhcpOptionsSetResponse {
	s.Body = v
	return s
}

type RetryVpcPrefixListAssociationRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, the system automatically uses **RequestId** as **ClientToken**. **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to only precheck the request. Valid values:
	//
	// *   **true**: prechecks the request without associating the prefix list. The system prechecks the required parameters, request syntax, and limits. If the request fails the precheck, an error message is returned. If the request passes the precheck, the `DryRunOperation` error code is returned.
	// *   **false**: sends the request. If the request passes the precheck, a 2xx HTTP status code is returned and the prefix list is associated. This is the default value.
	DryRun       *bool   `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the prefix list that you want to re-apply.
	PrefixListId *string `json:"PrefixListId,omitempty" xml:"PrefixListId,omitempty"`
	// The region ID of the prefix list that you want to re-apply.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the associated resource.
	ResourceId           *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The type of the resource with which the prefix list is associated. Valid values:
	//
	// *   **vpcRouteTable**: VPC route table
	// *   **trRouteTable**: route table of a transit router
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
}

func (s RetryVpcPrefixListAssociationRequest) String() string {
	return tea.Prettify(s)
}

func (s RetryVpcPrefixListAssociationRequest) GoString() string {
	return s.String()
}

func (s *RetryVpcPrefixListAssociationRequest) SetClientToken(v string) *RetryVpcPrefixListAssociationRequest {
	s.ClientToken = &v
	return s
}

func (s *RetryVpcPrefixListAssociationRequest) SetDryRun(v bool) *RetryVpcPrefixListAssociationRequest {
	s.DryRun = &v
	return s
}

func (s *RetryVpcPrefixListAssociationRequest) SetOwnerAccount(v string) *RetryVpcPrefixListAssociationRequest {
	s.OwnerAccount = &v
	return s
}

func (s *RetryVpcPrefixListAssociationRequest) SetOwnerId(v int64) *RetryVpcPrefixListAssociationRequest {
	s.OwnerId = &v
	return s
}

func (s *RetryVpcPrefixListAssociationRequest) SetPrefixListId(v string) *RetryVpcPrefixListAssociationRequest {
	s.PrefixListId = &v
	return s
}

func (s *RetryVpcPrefixListAssociationRequest) SetRegionId(v string) *RetryVpcPrefixListAssociationRequest {
	s.RegionId = &v
	return s
}

func (s *RetryVpcPrefixListAssociationRequest) SetResourceId(v string) *RetryVpcPrefixListAssociationRequest {
	s.ResourceId = &v
	return s
}

func (s *RetryVpcPrefixListAssociationRequest) SetResourceOwnerAccount(v string) *RetryVpcPrefixListAssociationRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *RetryVpcPrefixListAssociationRequest) SetResourceOwnerId(v int64) *RetryVpcPrefixListAssociationRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *RetryVpcPrefixListAssociationRequest) SetResourceType(v string) *RetryVpcPrefixListAssociationRequest {
	s.ResourceType = &v
	return s
}

type RetryVpcPrefixListAssociationResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s RetryVpcPrefixListAssociationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RetryVpcPrefixListAssociationResponseBody) GoString() string {
	return s.String()
}

func (s *RetryVpcPrefixListAssociationResponseBody) SetRequestId(v string) *RetryVpcPrefixListAssociationResponseBody {
	s.RequestId = &v
	return s
}

type RetryVpcPrefixListAssociationResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RetryVpcPrefixListAssociationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RetryVpcPrefixListAssociationResponse) String() string {
	return tea.Prettify(s)
}

func (s RetryVpcPrefixListAssociationResponse) GoString() string {
	return s.String()
}

func (s *RetryVpcPrefixListAssociationResponse) SetHeaders(v map[string]*string) *RetryVpcPrefixListAssociationResponse {
	s.Headers = v
	return s
}

func (s *RetryVpcPrefixListAssociationResponse) SetStatusCode(v int32) *RetryVpcPrefixListAssociationResponse {
	s.StatusCode = &v
	return s
}

func (s *RetryVpcPrefixListAssociationResponse) SetBody(v *RetryVpcPrefixListAssociationResponseBody) *RetryVpcPrefixListAssociationResponse {
	s.Body = v
	return s
}

type RevokeInstanceFromCenRequest struct {
	// The ID of the CEN instance to which the network instance is attached.
	CenId *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	// The user ID (UID) of the Alibaba Cloud account to which the CEN instance belongs.
	CenOwnerId *int64 `json:"CenOwnerId,omitempty" xml:"CenOwnerId,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, the system uses **RequestId** as **ClientToken**. The value of **RequestId** for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the network instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The type of the network instance. Valid values:
	//
	// *   **VPC**: a VPC
	// *   **VBR**: a VBR
	// *   **CCN**: a CCN instance
	InstanceType *string `json:"InstanceType,omitempty" xml:"InstanceType,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region where the network instance is deployed.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s RevokeInstanceFromCenRequest) String() string {
	return tea.Prettify(s)
}

func (s RevokeInstanceFromCenRequest) GoString() string {
	return s.String()
}

func (s *RevokeInstanceFromCenRequest) SetCenId(v string) *RevokeInstanceFromCenRequest {
	s.CenId = &v
	return s
}

func (s *RevokeInstanceFromCenRequest) SetCenOwnerId(v int64) *RevokeInstanceFromCenRequest {
	s.CenOwnerId = &v
	return s
}

func (s *RevokeInstanceFromCenRequest) SetClientToken(v string) *RevokeInstanceFromCenRequest {
	s.ClientToken = &v
	return s
}

func (s *RevokeInstanceFromCenRequest) SetInstanceId(v string) *RevokeInstanceFromCenRequest {
	s.InstanceId = &v
	return s
}

func (s *RevokeInstanceFromCenRequest) SetInstanceType(v string) *RevokeInstanceFromCenRequest {
	s.InstanceType = &v
	return s
}

func (s *RevokeInstanceFromCenRequest) SetOwnerAccount(v string) *RevokeInstanceFromCenRequest {
	s.OwnerAccount = &v
	return s
}

func (s *RevokeInstanceFromCenRequest) SetOwnerId(v int64) *RevokeInstanceFromCenRequest {
	s.OwnerId = &v
	return s
}

func (s *RevokeInstanceFromCenRequest) SetRegionId(v string) *RevokeInstanceFromCenRequest {
	s.RegionId = &v
	return s
}

func (s *RevokeInstanceFromCenRequest) SetResourceOwnerAccount(v string) *RevokeInstanceFromCenRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *RevokeInstanceFromCenRequest) SetResourceOwnerId(v int64) *RevokeInstanceFromCenRequest {
	s.ResourceOwnerId = &v
	return s
}

type RevokeInstanceFromCenResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s RevokeInstanceFromCenResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RevokeInstanceFromCenResponseBody) GoString() string {
	return s.String()
}

func (s *RevokeInstanceFromCenResponseBody) SetRequestId(v string) *RevokeInstanceFromCenResponseBody {
	s.RequestId = &v
	return s
}

type RevokeInstanceFromCenResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RevokeInstanceFromCenResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RevokeInstanceFromCenResponse) String() string {
	return tea.Prettify(s)
}

func (s RevokeInstanceFromCenResponse) GoString() string {
	return s.String()
}

func (s *RevokeInstanceFromCenResponse) SetHeaders(v map[string]*string) *RevokeInstanceFromCenResponse {
	s.Headers = v
	return s
}

func (s *RevokeInstanceFromCenResponse) SetStatusCode(v int32) *RevokeInstanceFromCenResponse {
	s.StatusCode = &v
	return s
}

func (s *RevokeInstanceFromCenResponse) SetBody(v *RevokeInstanceFromCenResponseBody) *RevokeInstanceFromCenResponse {
	s.Body = v
	return s
}

type RevokeInstanceFromVbrRequest struct {
	// The VBRs for which you want to revoke permissions on the VPC. Valid values:
	//
	// *   **ALL**: Permissions on the VPC are revoked for all VBRs in the specified region. **VbrInstanceIds** can be left empty.
	// *   **Specify**: Permissions on the VPC are revoked for the specified VBRs. **VbrInstanceIds** must be assigned a value.
	GrantType *string `json:"GrantType,omitempty" xml:"GrantType,omitempty"`
	// The VPC ID.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the region where the VPC is deployed.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The IDs of the VBRs for which you want to revoke the permissions.
	VbrInstanceIds []*string `json:"VbrInstanceIds,omitempty" xml:"VbrInstanceIds,omitempty" type:"Repeated"`
	// The ID of the Alibaba Cloud account to which the VBR belongs.
	VbrOwnerUid *string `json:"VbrOwnerUid,omitempty" xml:"VbrOwnerUid,omitempty"`
	// The ID of the region where the VBR is deployed.
	VbrRegionNo *string `json:"VbrRegionNo,omitempty" xml:"VbrRegionNo,omitempty"`
}

func (s RevokeInstanceFromVbrRequest) String() string {
	return tea.Prettify(s)
}

func (s RevokeInstanceFromVbrRequest) GoString() string {
	return s.String()
}

func (s *RevokeInstanceFromVbrRequest) SetGrantType(v string) *RevokeInstanceFromVbrRequest {
	s.GrantType = &v
	return s
}

func (s *RevokeInstanceFromVbrRequest) SetInstanceId(v string) *RevokeInstanceFromVbrRequest {
	s.InstanceId = &v
	return s
}

func (s *RevokeInstanceFromVbrRequest) SetRegionId(v string) *RevokeInstanceFromVbrRequest {
	s.RegionId = &v
	return s
}

func (s *RevokeInstanceFromVbrRequest) SetVbrInstanceIds(v []*string) *RevokeInstanceFromVbrRequest {
	s.VbrInstanceIds = v
	return s
}

func (s *RevokeInstanceFromVbrRequest) SetVbrOwnerUid(v string) *RevokeInstanceFromVbrRequest {
	s.VbrOwnerUid = &v
	return s
}

func (s *RevokeInstanceFromVbrRequest) SetVbrRegionNo(v string) *RevokeInstanceFromVbrRequest {
	s.VbrRegionNo = &v
	return s
}

type RevokeInstanceFromVbrShrinkRequest struct {
	// The VBRs for which you want to revoke permissions on the VPC. Valid values:
	//
	// *   **ALL**: Permissions on the VPC are revoked for all VBRs in the specified region. **VbrInstanceIds** can be left empty.
	// *   **Specify**: Permissions on the VPC are revoked for the specified VBRs. **VbrInstanceIds** must be assigned a value.
	GrantType *string `json:"GrantType,omitempty" xml:"GrantType,omitempty"`
	// The VPC ID.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the region where the VPC is deployed.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The IDs of the VBRs for which you want to revoke the permissions.
	VbrInstanceIdsShrink *string `json:"VbrInstanceIds,omitempty" xml:"VbrInstanceIds,omitempty"`
	// The ID of the Alibaba Cloud account to which the VBR belongs.
	VbrOwnerUid *string `json:"VbrOwnerUid,omitempty" xml:"VbrOwnerUid,omitempty"`
	// The ID of the region where the VBR is deployed.
	VbrRegionNo *string `json:"VbrRegionNo,omitempty" xml:"VbrRegionNo,omitempty"`
}

func (s RevokeInstanceFromVbrShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s RevokeInstanceFromVbrShrinkRequest) GoString() string {
	return s.String()
}

func (s *RevokeInstanceFromVbrShrinkRequest) SetGrantType(v string) *RevokeInstanceFromVbrShrinkRequest {
	s.GrantType = &v
	return s
}

func (s *RevokeInstanceFromVbrShrinkRequest) SetInstanceId(v string) *RevokeInstanceFromVbrShrinkRequest {
	s.InstanceId = &v
	return s
}

func (s *RevokeInstanceFromVbrShrinkRequest) SetRegionId(v string) *RevokeInstanceFromVbrShrinkRequest {
	s.RegionId = &v
	return s
}

func (s *RevokeInstanceFromVbrShrinkRequest) SetVbrInstanceIdsShrink(v string) *RevokeInstanceFromVbrShrinkRequest {
	s.VbrInstanceIdsShrink = &v
	return s
}

func (s *RevokeInstanceFromVbrShrinkRequest) SetVbrOwnerUid(v string) *RevokeInstanceFromVbrShrinkRequest {
	s.VbrOwnerUid = &v
	return s
}

func (s *RevokeInstanceFromVbrShrinkRequest) SetVbrRegionNo(v string) *RevokeInstanceFromVbrShrinkRequest {
	s.VbrRegionNo = &v
	return s
}

type RevokeInstanceFromVbrResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s RevokeInstanceFromVbrResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RevokeInstanceFromVbrResponseBody) GoString() string {
	return s.String()
}

func (s *RevokeInstanceFromVbrResponseBody) SetRequestId(v string) *RevokeInstanceFromVbrResponseBody {
	s.RequestId = &v
	return s
}

type RevokeInstanceFromVbrResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RevokeInstanceFromVbrResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RevokeInstanceFromVbrResponse) String() string {
	return tea.Prettify(s)
}

func (s RevokeInstanceFromVbrResponse) GoString() string {
	return s.String()
}

func (s *RevokeInstanceFromVbrResponse) SetHeaders(v map[string]*string) *RevokeInstanceFromVbrResponse {
	s.Headers = v
	return s
}

func (s *RevokeInstanceFromVbrResponse) SetStatusCode(v int32) *RevokeInstanceFromVbrResponse {
	s.StatusCode = &v
	return s
}

func (s *RevokeInstanceFromVbrResponse) SetBody(v *RevokeInstanceFromVbrResponseBody) *RevokeInstanceFromVbrResponse {
	s.Body = v
	return s
}

type SecondApplyPhysicalConnectionLOARequest struct {
	Bandwidth            *int32                                           `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	ClientToken          *string                                          `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	CompanyName          *string                                          `json:"CompanyName,omitempty" xml:"CompanyName,omitempty"`
	ConstructionTime     *string                                          `json:"ConstructionTime,omitempty" xml:"ConstructionTime,omitempty"`
	InstanceId           *string                                          `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	LineType             *string                                          `json:"LineType,omitempty" xml:"LineType,omitempty"`
	OwnerAccount         *string                                          `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64                                           `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	PMInfo               []*SecondApplyPhysicalConnectionLOARequestPMInfo `json:"PMInfo,omitempty" xml:"PMInfo,omitempty" type:"Repeated"`
	PeerLocation         *string                                          `json:"PeerLocation,omitempty" xml:"PeerLocation,omitempty"`
	RegionId             *string                                          `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string                                          `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64                                           `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	Si                   *string                                          `json:"Si,omitempty" xml:"Si,omitempty"`
}

func (s SecondApplyPhysicalConnectionLOARequest) String() string {
	return tea.Prettify(s)
}

func (s SecondApplyPhysicalConnectionLOARequest) GoString() string {
	return s.String()
}

func (s *SecondApplyPhysicalConnectionLOARequest) SetBandwidth(v int32) *SecondApplyPhysicalConnectionLOARequest {
	s.Bandwidth = &v
	return s
}

func (s *SecondApplyPhysicalConnectionLOARequest) SetClientToken(v string) *SecondApplyPhysicalConnectionLOARequest {
	s.ClientToken = &v
	return s
}

func (s *SecondApplyPhysicalConnectionLOARequest) SetCompanyName(v string) *SecondApplyPhysicalConnectionLOARequest {
	s.CompanyName = &v
	return s
}

func (s *SecondApplyPhysicalConnectionLOARequest) SetConstructionTime(v string) *SecondApplyPhysicalConnectionLOARequest {
	s.ConstructionTime = &v
	return s
}

func (s *SecondApplyPhysicalConnectionLOARequest) SetInstanceId(v string) *SecondApplyPhysicalConnectionLOARequest {
	s.InstanceId = &v
	return s
}

func (s *SecondApplyPhysicalConnectionLOARequest) SetLineType(v string) *SecondApplyPhysicalConnectionLOARequest {
	s.LineType = &v
	return s
}

func (s *SecondApplyPhysicalConnectionLOARequest) SetOwnerAccount(v string) *SecondApplyPhysicalConnectionLOARequest {
	s.OwnerAccount = &v
	return s
}

func (s *SecondApplyPhysicalConnectionLOARequest) SetOwnerId(v int64) *SecondApplyPhysicalConnectionLOARequest {
	s.OwnerId = &v
	return s
}

func (s *SecondApplyPhysicalConnectionLOARequest) SetPMInfo(v []*SecondApplyPhysicalConnectionLOARequestPMInfo) *SecondApplyPhysicalConnectionLOARequest {
	s.PMInfo = v
	return s
}

func (s *SecondApplyPhysicalConnectionLOARequest) SetPeerLocation(v string) *SecondApplyPhysicalConnectionLOARequest {
	s.PeerLocation = &v
	return s
}

func (s *SecondApplyPhysicalConnectionLOARequest) SetRegionId(v string) *SecondApplyPhysicalConnectionLOARequest {
	s.RegionId = &v
	return s
}

func (s *SecondApplyPhysicalConnectionLOARequest) SetResourceOwnerAccount(v string) *SecondApplyPhysicalConnectionLOARequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *SecondApplyPhysicalConnectionLOARequest) SetResourceOwnerId(v int64) *SecondApplyPhysicalConnectionLOARequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *SecondApplyPhysicalConnectionLOARequest) SetSi(v string) *SecondApplyPhysicalConnectionLOARequest {
	s.Si = &v
	return s
}

type SecondApplyPhysicalConnectionLOARequestPMInfo struct {
	PMCertificateNo   *string `json:"PMCertificateNo,omitempty" xml:"PMCertificateNo,omitempty"`
	PMCertificateType *string `json:"PMCertificateType,omitempty" xml:"PMCertificateType,omitempty"`
	PMContactInfo     *string `json:"PMContactInfo,omitempty" xml:"PMContactInfo,omitempty"`
	PMGender          *string `json:"PMGender,omitempty" xml:"PMGender,omitempty"`
	PMName            *string `json:"PMName,omitempty" xml:"PMName,omitempty"`
}

func (s SecondApplyPhysicalConnectionLOARequestPMInfo) String() string {
	return tea.Prettify(s)
}

func (s SecondApplyPhysicalConnectionLOARequestPMInfo) GoString() string {
	return s.String()
}

func (s *SecondApplyPhysicalConnectionLOARequestPMInfo) SetPMCertificateNo(v string) *SecondApplyPhysicalConnectionLOARequestPMInfo {
	s.PMCertificateNo = &v
	return s
}

func (s *SecondApplyPhysicalConnectionLOARequestPMInfo) SetPMCertificateType(v string) *SecondApplyPhysicalConnectionLOARequestPMInfo {
	s.PMCertificateType = &v
	return s
}

func (s *SecondApplyPhysicalConnectionLOARequestPMInfo) SetPMContactInfo(v string) *SecondApplyPhysicalConnectionLOARequestPMInfo {
	s.PMContactInfo = &v
	return s
}

func (s *SecondApplyPhysicalConnectionLOARequestPMInfo) SetPMGender(v string) *SecondApplyPhysicalConnectionLOARequestPMInfo {
	s.PMGender = &v
	return s
}

func (s *SecondApplyPhysicalConnectionLOARequestPMInfo) SetPMName(v string) *SecondApplyPhysicalConnectionLOARequestPMInfo {
	s.PMName = &v
	return s
}

type SecondApplyPhysicalConnectionLOAResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SecondApplyPhysicalConnectionLOAResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SecondApplyPhysicalConnectionLOAResponseBody) GoString() string {
	return s.String()
}

func (s *SecondApplyPhysicalConnectionLOAResponseBody) SetRequestId(v string) *SecondApplyPhysicalConnectionLOAResponseBody {
	s.RequestId = &v
	return s
}

type SecondApplyPhysicalConnectionLOAResponse struct {
	Headers    map[string]*string                            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SecondApplyPhysicalConnectionLOAResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SecondApplyPhysicalConnectionLOAResponse) String() string {
	return tea.Prettify(s)
}

func (s SecondApplyPhysicalConnectionLOAResponse) GoString() string {
	return s.String()
}

func (s *SecondApplyPhysicalConnectionLOAResponse) SetHeaders(v map[string]*string) *SecondApplyPhysicalConnectionLOAResponse {
	s.Headers = v
	return s
}

func (s *SecondApplyPhysicalConnectionLOAResponse) SetStatusCode(v int32) *SecondApplyPhysicalConnectionLOAResponse {
	s.StatusCode = &v
	return s
}

func (s *SecondApplyPhysicalConnectionLOAResponse) SetBody(v *SecondApplyPhysicalConnectionLOAResponseBody) *SecondApplyPhysicalConnectionLOAResponse {
	s.Body = v
	return s
}

type SetHighDefinitionMonitorLogStatusRequest struct {
	// The ID of the instance for which you want to configure fine-grained monitoring.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The type of the instance. Set the value to **EIP**.
	InstanceType *string `json:"InstanceType,omitempty" xml:"InstanceType,omitempty"`
	// The name of the project of Log Service.
	LogProject *string `json:"LogProject,omitempty" xml:"LogProject,omitempty"`
	// The name of the Logstore of Log Service.
	LogStore     *string `json:"LogStore,omitempty" xml:"LogStore,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region where the instance is deployed.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The status of fine-grained monitoring. Valid values:
	//
	// *   **ON**: enables fine-grained monitoring.
	// *   **OFF**: disables fine-grained monitoring.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s SetHighDefinitionMonitorLogStatusRequest) String() string {
	return tea.Prettify(s)
}

func (s SetHighDefinitionMonitorLogStatusRequest) GoString() string {
	return s.String()
}

func (s *SetHighDefinitionMonitorLogStatusRequest) SetInstanceId(v string) *SetHighDefinitionMonitorLogStatusRequest {
	s.InstanceId = &v
	return s
}

func (s *SetHighDefinitionMonitorLogStatusRequest) SetInstanceType(v string) *SetHighDefinitionMonitorLogStatusRequest {
	s.InstanceType = &v
	return s
}

func (s *SetHighDefinitionMonitorLogStatusRequest) SetLogProject(v string) *SetHighDefinitionMonitorLogStatusRequest {
	s.LogProject = &v
	return s
}

func (s *SetHighDefinitionMonitorLogStatusRequest) SetLogStore(v string) *SetHighDefinitionMonitorLogStatusRequest {
	s.LogStore = &v
	return s
}

func (s *SetHighDefinitionMonitorLogStatusRequest) SetOwnerAccount(v string) *SetHighDefinitionMonitorLogStatusRequest {
	s.OwnerAccount = &v
	return s
}

func (s *SetHighDefinitionMonitorLogStatusRequest) SetOwnerId(v int64) *SetHighDefinitionMonitorLogStatusRequest {
	s.OwnerId = &v
	return s
}

func (s *SetHighDefinitionMonitorLogStatusRequest) SetRegionId(v string) *SetHighDefinitionMonitorLogStatusRequest {
	s.RegionId = &v
	return s
}

func (s *SetHighDefinitionMonitorLogStatusRequest) SetResourceOwnerAccount(v string) *SetHighDefinitionMonitorLogStatusRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *SetHighDefinitionMonitorLogStatusRequest) SetResourceOwnerId(v int64) *SetHighDefinitionMonitorLogStatusRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *SetHighDefinitionMonitorLogStatusRequest) SetStatus(v string) *SetHighDefinitionMonitorLogStatusRequest {
	s.Status = &v
	return s
}

type SetHighDefinitionMonitorLogStatusResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the operation is performed. Valid values:
	//
	// *   **true**: yes
	// *   **false**: no
	Success *string `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s SetHighDefinitionMonitorLogStatusResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SetHighDefinitionMonitorLogStatusResponseBody) GoString() string {
	return s.String()
}

func (s *SetHighDefinitionMonitorLogStatusResponseBody) SetRequestId(v string) *SetHighDefinitionMonitorLogStatusResponseBody {
	s.RequestId = &v
	return s
}

func (s *SetHighDefinitionMonitorLogStatusResponseBody) SetSuccess(v string) *SetHighDefinitionMonitorLogStatusResponseBody {
	s.Success = &v
	return s
}

type SetHighDefinitionMonitorLogStatusResponse struct {
	Headers    map[string]*string                             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SetHighDefinitionMonitorLogStatusResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SetHighDefinitionMonitorLogStatusResponse) String() string {
	return tea.Prettify(s)
}

func (s SetHighDefinitionMonitorLogStatusResponse) GoString() string {
	return s.String()
}

func (s *SetHighDefinitionMonitorLogStatusResponse) SetHeaders(v map[string]*string) *SetHighDefinitionMonitorLogStatusResponse {
	s.Headers = v
	return s
}

func (s *SetHighDefinitionMonitorLogStatusResponse) SetStatusCode(v int32) *SetHighDefinitionMonitorLogStatusResponse {
	s.StatusCode = &v
	return s
}

func (s *SetHighDefinitionMonitorLogStatusResponse) SetBody(v *SetHighDefinitionMonitorLogStatusResponseBody) *SetHighDefinitionMonitorLogStatusResponse {
	s.Body = v
	return s
}

type TagResourcesRequest struct {
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the resource.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The resource ID. You can specify at most 20 IDs.
	ResourceId           []*string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty" type:"Repeated"`
	ResourceOwnerAccount *string   `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64    `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The resource type. Valid values:
	//
	// *   **VPC**: a VPC
	// *   **VSWITCH**: a vSwitch
	// *   **ROUTETABLE**: a route table
	// *   **EIP**: an EIP
	// *   **VpnGateway**: a VPN gateway
	// *   **NATGATEWAY**: a NAT gateway
	// *   **COMMONBANDWIDTHPACKAGE**: an EIP bandwidth plan
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The tag value of the resource. You must enter at least one tag value and at most 20 tag values. It can be an empty string.
	//
	// The tag value cannot exceed 128 characters in length, and can contain digits, periods (.), underscores (\_), and hyphens (-). The key must start with a letter but cannot start with `aliyun` or `acs:`. The key cannot contain `http://` or `https://`.
	//
	// >  When you call this operation, **Tag.N.Value** is required.
	Tag []*TagResourcesRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s TagResourcesRequest) String() string {
	return tea.Prettify(s)
}

func (s TagResourcesRequest) GoString() string {
	return s.String()
}

func (s *TagResourcesRequest) SetOwnerAccount(v string) *TagResourcesRequest {
	s.OwnerAccount = &v
	return s
}

func (s *TagResourcesRequest) SetOwnerId(v int64) *TagResourcesRequest {
	s.OwnerId = &v
	return s
}

func (s *TagResourcesRequest) SetRegionId(v string) *TagResourcesRequest {
	s.RegionId = &v
	return s
}

func (s *TagResourcesRequest) SetResourceId(v []*string) *TagResourcesRequest {
	s.ResourceId = v
	return s
}

func (s *TagResourcesRequest) SetResourceOwnerAccount(v string) *TagResourcesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *TagResourcesRequest) SetResourceOwnerId(v int64) *TagResourcesRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *TagResourcesRequest) SetResourceType(v string) *TagResourcesRequest {
	s.ResourceType = &v
	return s
}

func (s *TagResourcesRequest) SetTag(v []*TagResourcesRequestTag) *TagResourcesRequest {
	s.Tag = v
	return s
}

type TagResourcesRequestTag struct {
	// The key of the tag that is added to the resource. You can specify at most 20 tag keys. The tag value cannot be an empty string.
	//
	// The key cannot exceed 64 characters in length, and can contain digits, periods (.), underscores (\_), and hyphens (-). The key must start with a letter but cannot start with `aliyun` or `acs:`. The key cannot contain `http://` or `https://`.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The value of the tag that is added to the resource. You can specify at most 20 tag values. The tag value can be an empty string.
	//
	// The tag value cannot exceed 128 characters in length, and can contain digits, periods (.), underscores (\_), and hyphens (-). The key must start with a letter but cannot start with `aliyun` or `acs:`. The key cannot contain `http://` or `https://`.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s TagResourcesRequestTag) String() string {
	return tea.Prettify(s)
}

func (s TagResourcesRequestTag) GoString() string {
	return s.String()
}

func (s *TagResourcesRequestTag) SetKey(v string) *TagResourcesRequestTag {
	s.Key = &v
	return s
}

func (s *TagResourcesRequestTag) SetValue(v string) *TagResourcesRequestTag {
	s.Value = &v
	return s
}

type TagResourcesResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s TagResourcesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s TagResourcesResponseBody) GoString() string {
	return s.String()
}

func (s *TagResourcesResponseBody) SetRequestId(v string) *TagResourcesResponseBody {
	s.RequestId = &v
	return s
}

type TagResourcesResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *TagResourcesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s TagResourcesResponse) String() string {
	return tea.Prettify(s)
}

func (s TagResourcesResponse) GoString() string {
	return s.String()
}

func (s *TagResourcesResponse) SetHeaders(v map[string]*string) *TagResourcesResponse {
	s.Headers = v
	return s
}

func (s *TagResourcesResponse) SetStatusCode(v int32) *TagResourcesResponse {
	s.StatusCode = &v
	return s
}

func (s *TagResourcesResponse) SetBody(v *TagResourcesResponseBody) *TagResourcesResponse {
	s.Body = v
	return s
}

type TagResourcesForExpressConnectRequest struct {
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the resource to which you want to create and add tags.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string   `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceId           []*string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty" type:"Repeated"`
	ResourceOwnerAccount *string   `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64    `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The type of the resource. Set the value to **PHYSICALCONNECTION**, which indicates the Express Connect circuit.
	ResourceType *string                                    `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	Tag          []*TagResourcesForExpressConnectRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s TagResourcesForExpressConnectRequest) String() string {
	return tea.Prettify(s)
}

func (s TagResourcesForExpressConnectRequest) GoString() string {
	return s.String()
}

func (s *TagResourcesForExpressConnectRequest) SetOwnerAccount(v string) *TagResourcesForExpressConnectRequest {
	s.OwnerAccount = &v
	return s
}

func (s *TagResourcesForExpressConnectRequest) SetOwnerId(v int64) *TagResourcesForExpressConnectRequest {
	s.OwnerId = &v
	return s
}

func (s *TagResourcesForExpressConnectRequest) SetRegionId(v string) *TagResourcesForExpressConnectRequest {
	s.RegionId = &v
	return s
}

func (s *TagResourcesForExpressConnectRequest) SetResourceId(v []*string) *TagResourcesForExpressConnectRequest {
	s.ResourceId = v
	return s
}

func (s *TagResourcesForExpressConnectRequest) SetResourceOwnerAccount(v string) *TagResourcesForExpressConnectRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *TagResourcesForExpressConnectRequest) SetResourceOwnerId(v int64) *TagResourcesForExpressConnectRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *TagResourcesForExpressConnectRequest) SetResourceType(v string) *TagResourcesForExpressConnectRequest {
	s.ResourceType = &v
	return s
}

func (s *TagResourcesForExpressConnectRequest) SetTag(v []*TagResourcesForExpressConnectRequestTag) *TagResourcesForExpressConnectRequest {
	s.Tag = v
	return s
}

type TagResourcesForExpressConnectRequestTag struct {
	// The key of tag N that is added to the resource. You can specify up to 20 tag keys. The tag key cannot be an empty string.
	//
	// The key can be up to 64 characters in length and can contain letters, digits, periods (.), underscores (\_), and hyphens (-). The key must start with a letter but cannot start with `aliyun` or `acs:`. The key cannot contain `http://` or `https://`.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The value of tag N that is added to the resource. You can specify up to 20 tag values. The tag value can be an empty string.
	//
	// The value can be up to 128 characters in length and can contain letters, digits, periods (.), underscores (\_), and hyphens (-). The value must start with a letter but cannot start with `aliyun` or `acs:`. The value cannot contain `http://` or `https://`.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s TagResourcesForExpressConnectRequestTag) String() string {
	return tea.Prettify(s)
}

func (s TagResourcesForExpressConnectRequestTag) GoString() string {
	return s.String()
}

func (s *TagResourcesForExpressConnectRequestTag) SetKey(v string) *TagResourcesForExpressConnectRequestTag {
	s.Key = &v
	return s
}

func (s *TagResourcesForExpressConnectRequestTag) SetValue(v string) *TagResourcesForExpressConnectRequestTag {
	s.Value = &v
	return s
}

type TagResourcesForExpressConnectResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s TagResourcesForExpressConnectResponseBody) String() string {
	return tea.Prettify(s)
}

func (s TagResourcesForExpressConnectResponseBody) GoString() string {
	return s.String()
}

func (s *TagResourcesForExpressConnectResponseBody) SetRequestId(v string) *TagResourcesForExpressConnectResponseBody {
	s.RequestId = &v
	return s
}

type TagResourcesForExpressConnectResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *TagResourcesForExpressConnectResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s TagResourcesForExpressConnectResponse) String() string {
	return tea.Prettify(s)
}

func (s TagResourcesForExpressConnectResponse) GoString() string {
	return s.String()
}

func (s *TagResourcesForExpressConnectResponse) SetHeaders(v map[string]*string) *TagResourcesForExpressConnectResponse {
	s.Headers = v
	return s
}

func (s *TagResourcesForExpressConnectResponse) SetStatusCode(v int32) *TagResourcesForExpressConnectResponse {
	s.StatusCode = &v
	return s
}

func (s *TagResourcesForExpressConnectResponse) SetBody(v *TagResourcesForExpressConnectResponseBody) *TagResourcesForExpressConnectResponse {
	s.Body = v
	return s
}

type TerminatePhysicalConnectionRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken  *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the Express Connect circuit.
	PhysicalConnectionId *string `json:"PhysicalConnectionId,omitempty" xml:"PhysicalConnectionId,omitempty"`
	// The region ID of the Express Connect circuit.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s TerminatePhysicalConnectionRequest) String() string {
	return tea.Prettify(s)
}

func (s TerminatePhysicalConnectionRequest) GoString() string {
	return s.String()
}

func (s *TerminatePhysicalConnectionRequest) SetClientToken(v string) *TerminatePhysicalConnectionRequest {
	s.ClientToken = &v
	return s
}

func (s *TerminatePhysicalConnectionRequest) SetOwnerAccount(v string) *TerminatePhysicalConnectionRequest {
	s.OwnerAccount = &v
	return s
}

func (s *TerminatePhysicalConnectionRequest) SetOwnerId(v int64) *TerminatePhysicalConnectionRequest {
	s.OwnerId = &v
	return s
}

func (s *TerminatePhysicalConnectionRequest) SetPhysicalConnectionId(v string) *TerminatePhysicalConnectionRequest {
	s.PhysicalConnectionId = &v
	return s
}

func (s *TerminatePhysicalConnectionRequest) SetRegionId(v string) *TerminatePhysicalConnectionRequest {
	s.RegionId = &v
	return s
}

func (s *TerminatePhysicalConnectionRequest) SetResourceOwnerAccount(v string) *TerminatePhysicalConnectionRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *TerminatePhysicalConnectionRequest) SetResourceOwnerId(v int64) *TerminatePhysicalConnectionRequest {
	s.ResourceOwnerId = &v
	return s
}

type TerminatePhysicalConnectionResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s TerminatePhysicalConnectionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s TerminatePhysicalConnectionResponseBody) GoString() string {
	return s.String()
}

func (s *TerminatePhysicalConnectionResponseBody) SetRequestId(v string) *TerminatePhysicalConnectionResponseBody {
	s.RequestId = &v
	return s
}

type TerminatePhysicalConnectionResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *TerminatePhysicalConnectionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s TerminatePhysicalConnectionResponse) String() string {
	return tea.Prettify(s)
}

func (s TerminatePhysicalConnectionResponse) GoString() string {
	return s.String()
}

func (s *TerminatePhysicalConnectionResponse) SetHeaders(v map[string]*string) *TerminatePhysicalConnectionResponse {
	s.Headers = v
	return s
}

func (s *TerminatePhysicalConnectionResponse) SetStatusCode(v int32) *TerminatePhysicalConnectionResponse {
	s.StatusCode = &v
	return s
}

func (s *TerminatePhysicalConnectionResponse) SetBody(v *TerminatePhysicalConnectionResponseBody) *TerminatePhysicalConnectionResponse {
	s.Body = v
	return s
}

type TerminateVirtualBorderRouterRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can contain only ASCII characters.
	//
	// >  If you do not specify this parameter, the system uses **RequestId** as **ClientToken**. **RequestId** may be different for each API request.
	ClientToken  *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the VBR.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the VBR.
	VbrId *string `json:"VbrId,omitempty" xml:"VbrId,omitempty"`
}

func (s TerminateVirtualBorderRouterRequest) String() string {
	return tea.Prettify(s)
}

func (s TerminateVirtualBorderRouterRequest) GoString() string {
	return s.String()
}

func (s *TerminateVirtualBorderRouterRequest) SetClientToken(v string) *TerminateVirtualBorderRouterRequest {
	s.ClientToken = &v
	return s
}

func (s *TerminateVirtualBorderRouterRequest) SetOwnerAccount(v string) *TerminateVirtualBorderRouterRequest {
	s.OwnerAccount = &v
	return s
}

func (s *TerminateVirtualBorderRouterRequest) SetOwnerId(v int64) *TerminateVirtualBorderRouterRequest {
	s.OwnerId = &v
	return s
}

func (s *TerminateVirtualBorderRouterRequest) SetRegionId(v string) *TerminateVirtualBorderRouterRequest {
	s.RegionId = &v
	return s
}

func (s *TerminateVirtualBorderRouterRequest) SetResourceOwnerAccount(v string) *TerminateVirtualBorderRouterRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *TerminateVirtualBorderRouterRequest) SetResourceOwnerId(v int64) *TerminateVirtualBorderRouterRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *TerminateVirtualBorderRouterRequest) SetVbrId(v string) *TerminateVirtualBorderRouterRequest {
	s.VbrId = &v
	return s
}

type TerminateVirtualBorderRouterResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s TerminateVirtualBorderRouterResponseBody) String() string {
	return tea.Prettify(s)
}

func (s TerminateVirtualBorderRouterResponseBody) GoString() string {
	return s.String()
}

func (s *TerminateVirtualBorderRouterResponseBody) SetRequestId(v string) *TerminateVirtualBorderRouterResponseBody {
	s.RequestId = &v
	return s
}

type TerminateVirtualBorderRouterResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *TerminateVirtualBorderRouterResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s TerminateVirtualBorderRouterResponse) String() string {
	return tea.Prettify(s)
}

func (s TerminateVirtualBorderRouterResponse) GoString() string {
	return s.String()
}

func (s *TerminateVirtualBorderRouterResponse) SetHeaders(v map[string]*string) *TerminateVirtualBorderRouterResponse {
	s.Headers = v
	return s
}

func (s *TerminateVirtualBorderRouterResponse) SetStatusCode(v int32) *TerminateVirtualBorderRouterResponse {
	s.StatusCode = &v
	return s
}

func (s *TerminateVirtualBorderRouterResponse) SetBody(v *TerminateVirtualBorderRouterResponseBody) *TerminateVirtualBorderRouterResponse {
	s.Body = v
	return s
}

type UnTagResourcesRequest struct {
	// Specifies whether to remove all tags from the specified resource. Valid values:
	//
	// *   **true**
	// *   **false** (default)
	All          *bool   `json:"All,omitempty" xml:"All,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the resource.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The resource ID. You can specify up to 20 resource IDs.
	ResourceId           []*string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty" type:"Repeated"`
	ResourceOwnerAccount *string   `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64    `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The resource type. Valid values:
	//
	// *   **VPC**
	// *   **VSWITCH**
	// *   **ROUTETABLE**
	// *   **EIP**
	// *   **VpnGateway**
	// *   **NATGATEWAY**
	// *   **COMMONBANDWIDTHPACKAGE**: EIP bandwidth plan
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The key of the tag that you want to remove. You can specify at most 20 tag keys. It can be an empty string.
	//
	// The key cannot exceed 64 characters in length, and can contain digits, periods (.), underscores (\_), and hyphens (-). The key must start with a letter but cannot start with `aliyun` or `acs:`. The key cannot contain `http://` or `https://`.
	TagKey []*string `json:"TagKey,omitempty" xml:"TagKey,omitempty" type:"Repeated"`
}

func (s UnTagResourcesRequest) String() string {
	return tea.Prettify(s)
}

func (s UnTagResourcesRequest) GoString() string {
	return s.String()
}

func (s *UnTagResourcesRequest) SetAll(v bool) *UnTagResourcesRequest {
	s.All = &v
	return s
}

func (s *UnTagResourcesRequest) SetOwnerAccount(v string) *UnTagResourcesRequest {
	s.OwnerAccount = &v
	return s
}

func (s *UnTagResourcesRequest) SetOwnerId(v int64) *UnTagResourcesRequest {
	s.OwnerId = &v
	return s
}

func (s *UnTagResourcesRequest) SetRegionId(v string) *UnTagResourcesRequest {
	s.RegionId = &v
	return s
}

func (s *UnTagResourcesRequest) SetResourceId(v []*string) *UnTagResourcesRequest {
	s.ResourceId = v
	return s
}

func (s *UnTagResourcesRequest) SetResourceOwnerAccount(v string) *UnTagResourcesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *UnTagResourcesRequest) SetResourceOwnerId(v int64) *UnTagResourcesRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *UnTagResourcesRequest) SetResourceType(v string) *UnTagResourcesRequest {
	s.ResourceType = &v
	return s
}

func (s *UnTagResourcesRequest) SetTagKey(v []*string) *UnTagResourcesRequest {
	s.TagKey = v
	return s
}

type UnTagResourcesResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UnTagResourcesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UnTagResourcesResponseBody) GoString() string {
	return s.String()
}

func (s *UnTagResourcesResponseBody) SetRequestId(v string) *UnTagResourcesResponseBody {
	s.RequestId = &v
	return s
}

type UnTagResourcesResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UnTagResourcesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UnTagResourcesResponse) String() string {
	return tea.Prettify(s)
}

func (s UnTagResourcesResponse) GoString() string {
	return s.String()
}

func (s *UnTagResourcesResponse) SetHeaders(v map[string]*string) *UnTagResourcesResponse {
	s.Headers = v
	return s
}

func (s *UnTagResourcesResponse) SetStatusCode(v int32) *UnTagResourcesResponse {
	s.StatusCode = &v
	return s
}

func (s *UnTagResourcesResponse) SetBody(v *UnTagResourcesResponseBody) *UnTagResourcesResponse {
	s.Body = v
	return s
}

type UnassociateEipAddressRequest struct {
	// The ID of the EIP that you want to disassociate.
	AllocationId *string `json:"AllocationId,omitempty" xml:"AllocationId,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, the system uses **RequestId** as **ClientToken**. **RequestId** might be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to disassociate the EIP from a NAT gateway if a DNAT or SNAT entry is added to the NAT gateway. Valid values:
	//
	// *   **false** (default): does not disassociate the EIP from a NAT gateway if a DNAT or SNAT entry is added to the NAT gateway.
	// *   **true**: disassociates the EIP from a NAT gateway if a DNAT or SNAT entry is added to the NAT gateway.
	Force *bool `json:"Force,omitempty" xml:"Force,omitempty"`
	// The ID of the instance from which you want to disassociate the EIP.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The type of instance from which you want to disassociate the EIP. Valid values:
	//
	// *   **EcsInstance** (default): an Elastic Compute Service (ECS) instance in a virtual private cloud (VPC)
	// *   **SlbInstance**: a Server Load Balancer (SLB) instance in a VPC
	// *   **NetworkInterface**: a secondary elastic network interface (ENI) in a VPC
	// *   **Nat**: a NAT gateway
	// *   **HaVip**: a high-availability virtual IP address (HAVIP)
	InstanceType *string `json:"InstanceType,omitempty" xml:"InstanceType,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The private IP address of the ECS instance or the secondary ENI from which you want to disassociate the EIP.
	PrivateIpAddress *string `json:"PrivateIpAddress,omitempty" xml:"PrivateIpAddress,omitempty"`
	// The ID of the region to which the EIP belongs.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s UnassociateEipAddressRequest) String() string {
	return tea.Prettify(s)
}

func (s UnassociateEipAddressRequest) GoString() string {
	return s.String()
}

func (s *UnassociateEipAddressRequest) SetAllocationId(v string) *UnassociateEipAddressRequest {
	s.AllocationId = &v
	return s
}

func (s *UnassociateEipAddressRequest) SetClientToken(v string) *UnassociateEipAddressRequest {
	s.ClientToken = &v
	return s
}

func (s *UnassociateEipAddressRequest) SetForce(v bool) *UnassociateEipAddressRequest {
	s.Force = &v
	return s
}

func (s *UnassociateEipAddressRequest) SetInstanceId(v string) *UnassociateEipAddressRequest {
	s.InstanceId = &v
	return s
}

func (s *UnassociateEipAddressRequest) SetInstanceType(v string) *UnassociateEipAddressRequest {
	s.InstanceType = &v
	return s
}

func (s *UnassociateEipAddressRequest) SetOwnerAccount(v string) *UnassociateEipAddressRequest {
	s.OwnerAccount = &v
	return s
}

func (s *UnassociateEipAddressRequest) SetOwnerId(v int64) *UnassociateEipAddressRequest {
	s.OwnerId = &v
	return s
}

func (s *UnassociateEipAddressRequest) SetPrivateIpAddress(v string) *UnassociateEipAddressRequest {
	s.PrivateIpAddress = &v
	return s
}

func (s *UnassociateEipAddressRequest) SetRegionId(v string) *UnassociateEipAddressRequest {
	s.RegionId = &v
	return s
}

func (s *UnassociateEipAddressRequest) SetResourceOwnerAccount(v string) *UnassociateEipAddressRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *UnassociateEipAddressRequest) SetResourceOwnerId(v int64) *UnassociateEipAddressRequest {
	s.ResourceOwnerId = &v
	return s
}

type UnassociateEipAddressResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UnassociateEipAddressResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UnassociateEipAddressResponseBody) GoString() string {
	return s.String()
}

func (s *UnassociateEipAddressResponseBody) SetRequestId(v string) *UnassociateEipAddressResponseBody {
	s.RequestId = &v
	return s
}

type UnassociateEipAddressResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UnassociateEipAddressResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UnassociateEipAddressResponse) String() string {
	return tea.Prettify(s)
}

func (s UnassociateEipAddressResponse) GoString() string {
	return s.String()
}

func (s *UnassociateEipAddressResponse) SetHeaders(v map[string]*string) *UnassociateEipAddressResponse {
	s.Headers = v
	return s
}

func (s *UnassociateEipAddressResponse) SetStatusCode(v int32) *UnassociateEipAddressResponse {
	s.StatusCode = &v
	return s
}

func (s *UnassociateEipAddressResponse) SetBody(v *UnassociateEipAddressResponseBody) *UnassociateEipAddressResponse {
	s.Body = v
	return s
}

type UnassociateGlobalAccelerationInstanceRequest struct {
	// The ID of the GA instance.
	GlobalAccelerationInstanceId *string `json:"GlobalAccelerationInstanceId,omitempty" xml:"GlobalAccelerationInstanceId,omitempty"`
	// The backend server type. Valid values:
	//
	// *   **RemoteEcsInstance**: Elastic Compute Service (ECS) instance
	// *   **RemoteSlbInstance**: Server Load Balancer (SLB) instance
	// *   **RemoteEniInstance**: elastic network interface (ENI)
	InstanceType *string `json:"InstanceType,omitempty" xml:"InstanceType,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the GA instance.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s UnassociateGlobalAccelerationInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s UnassociateGlobalAccelerationInstanceRequest) GoString() string {
	return s.String()
}

func (s *UnassociateGlobalAccelerationInstanceRequest) SetGlobalAccelerationInstanceId(v string) *UnassociateGlobalAccelerationInstanceRequest {
	s.GlobalAccelerationInstanceId = &v
	return s
}

func (s *UnassociateGlobalAccelerationInstanceRequest) SetInstanceType(v string) *UnassociateGlobalAccelerationInstanceRequest {
	s.InstanceType = &v
	return s
}

func (s *UnassociateGlobalAccelerationInstanceRequest) SetOwnerAccount(v string) *UnassociateGlobalAccelerationInstanceRequest {
	s.OwnerAccount = &v
	return s
}

func (s *UnassociateGlobalAccelerationInstanceRequest) SetOwnerId(v int64) *UnassociateGlobalAccelerationInstanceRequest {
	s.OwnerId = &v
	return s
}

func (s *UnassociateGlobalAccelerationInstanceRequest) SetRegionId(v string) *UnassociateGlobalAccelerationInstanceRequest {
	s.RegionId = &v
	return s
}

func (s *UnassociateGlobalAccelerationInstanceRequest) SetResourceOwnerAccount(v string) *UnassociateGlobalAccelerationInstanceRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *UnassociateGlobalAccelerationInstanceRequest) SetResourceOwnerId(v int64) *UnassociateGlobalAccelerationInstanceRequest {
	s.ResourceOwnerId = &v
	return s
}

type UnassociateGlobalAccelerationInstanceResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UnassociateGlobalAccelerationInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UnassociateGlobalAccelerationInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *UnassociateGlobalAccelerationInstanceResponseBody) SetRequestId(v string) *UnassociateGlobalAccelerationInstanceResponseBody {
	s.RequestId = &v
	return s
}

type UnassociateGlobalAccelerationInstanceResponse struct {
	Headers    map[string]*string                                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UnassociateGlobalAccelerationInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UnassociateGlobalAccelerationInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s UnassociateGlobalAccelerationInstanceResponse) GoString() string {
	return s.String()
}

func (s *UnassociateGlobalAccelerationInstanceResponse) SetHeaders(v map[string]*string) *UnassociateGlobalAccelerationInstanceResponse {
	s.Headers = v
	return s
}

func (s *UnassociateGlobalAccelerationInstanceResponse) SetStatusCode(v int32) *UnassociateGlobalAccelerationInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *UnassociateGlobalAccelerationInstanceResponse) SetBody(v *UnassociateGlobalAccelerationInstanceResponseBody) *UnassociateGlobalAccelerationInstanceResponse {
	s.Body = v
	return s
}

type UnassociateHaVipRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that the value is unique among different requests. The `ClientToken` value can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to forcefully disassociate the HAVIP from the ECS instance or ENI. Valid values:
	//
	// *   **True**: yes
	// *   **False** (default): no
	//
	// >  If you set the value to **False**, you cannot disassociate the HAVIP from the primary instance.
	Force *string `json:"Force,omitempty" xml:"Force,omitempty"`
	// The ID of the HAVIP that you want to disassociate.
	HaVipId *string `json:"HaVipId,omitempty" xml:"HaVipId,omitempty"`
	// The ID of the ECS instance or ENI from which you want to disassociate the HAVIP.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The type of the instance from which you want to disassociate the HAVIP. Valid values:
	//
	// *   **EcsInstance**: an ECS instance
	// *   **NetworkInterface**: an ENI
	//
	// >  If you want to disassociate the HAVIP from an ENI, this parameter is required.
	InstanceType *string `json:"InstanceType,omitempty" xml:"InstanceType,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region to which the HAVIP belongs.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s UnassociateHaVipRequest) String() string {
	return tea.Prettify(s)
}

func (s UnassociateHaVipRequest) GoString() string {
	return s.String()
}

func (s *UnassociateHaVipRequest) SetClientToken(v string) *UnassociateHaVipRequest {
	s.ClientToken = &v
	return s
}

func (s *UnassociateHaVipRequest) SetForce(v string) *UnassociateHaVipRequest {
	s.Force = &v
	return s
}

func (s *UnassociateHaVipRequest) SetHaVipId(v string) *UnassociateHaVipRequest {
	s.HaVipId = &v
	return s
}

func (s *UnassociateHaVipRequest) SetInstanceId(v string) *UnassociateHaVipRequest {
	s.InstanceId = &v
	return s
}

func (s *UnassociateHaVipRequest) SetInstanceType(v string) *UnassociateHaVipRequest {
	s.InstanceType = &v
	return s
}

func (s *UnassociateHaVipRequest) SetOwnerAccount(v string) *UnassociateHaVipRequest {
	s.OwnerAccount = &v
	return s
}

func (s *UnassociateHaVipRequest) SetOwnerId(v int64) *UnassociateHaVipRequest {
	s.OwnerId = &v
	return s
}

func (s *UnassociateHaVipRequest) SetRegionId(v string) *UnassociateHaVipRequest {
	s.RegionId = &v
	return s
}

func (s *UnassociateHaVipRequest) SetResourceOwnerAccount(v string) *UnassociateHaVipRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *UnassociateHaVipRequest) SetResourceOwnerId(v int64) *UnassociateHaVipRequest {
	s.ResourceOwnerId = &v
	return s
}

type UnassociateHaVipResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UnassociateHaVipResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UnassociateHaVipResponseBody) GoString() string {
	return s.String()
}

func (s *UnassociateHaVipResponseBody) SetRequestId(v string) *UnassociateHaVipResponseBody {
	s.RequestId = &v
	return s
}

type UnassociateHaVipResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UnassociateHaVipResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UnassociateHaVipResponse) String() string {
	return tea.Prettify(s)
}

func (s UnassociateHaVipResponse) GoString() string {
	return s.String()
}

func (s *UnassociateHaVipResponse) SetHeaders(v map[string]*string) *UnassociateHaVipResponse {
	s.Headers = v
	return s
}

func (s *UnassociateHaVipResponse) SetStatusCode(v int32) *UnassociateHaVipResponse {
	s.StatusCode = &v
	return s
}

func (s *UnassociateHaVipResponse) SetBody(v *UnassociateHaVipResponseBody) *UnassociateHaVipResponse {
	s.Body = v
	return s
}

type UnassociateNetworkAclRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that the value is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	//
	// >  If you do not set this parameter, the system uses the value of **RequestId** as **ClientToken**. The value of **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the network ACL that you want to disassociate from a resource.
	NetworkAclId *string `json:"NetworkAclId,omitempty" xml:"NetworkAclId,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the network ACL. You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string                                 `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	Resource             []*UnassociateNetworkAclRequestResource `json:"Resource,omitempty" xml:"Resource,omitempty" type:"Repeated"`
	ResourceOwnerAccount *string                                 `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64                                  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s UnassociateNetworkAclRequest) String() string {
	return tea.Prettify(s)
}

func (s UnassociateNetworkAclRequest) GoString() string {
	return s.String()
}

func (s *UnassociateNetworkAclRequest) SetClientToken(v string) *UnassociateNetworkAclRequest {
	s.ClientToken = &v
	return s
}

func (s *UnassociateNetworkAclRequest) SetNetworkAclId(v string) *UnassociateNetworkAclRequest {
	s.NetworkAclId = &v
	return s
}

func (s *UnassociateNetworkAclRequest) SetOwnerId(v int64) *UnassociateNetworkAclRequest {
	s.OwnerId = &v
	return s
}

func (s *UnassociateNetworkAclRequest) SetRegionId(v string) *UnassociateNetworkAclRequest {
	s.RegionId = &v
	return s
}

func (s *UnassociateNetworkAclRequest) SetResource(v []*UnassociateNetworkAclRequestResource) *UnassociateNetworkAclRequest {
	s.Resource = v
	return s
}

func (s *UnassociateNetworkAclRequest) SetResourceOwnerAccount(v string) *UnassociateNetworkAclRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *UnassociateNetworkAclRequest) SetResourceOwnerId(v int64) *UnassociateNetworkAclRequest {
	s.ResourceOwnerId = &v
	return s
}

type UnassociateNetworkAclRequestResource struct {
	// The ID of the resource from which you want to disassociate the network ACL.
	ResourceId *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	// The type of the resource from which you want to disassociate the network ACL. Set the value to **VSwitch**.
	//
	// Valid values of **N**: 0 to 29. You can disassociate a network ACL from at most 30 resources at a time.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
}

func (s UnassociateNetworkAclRequestResource) String() string {
	return tea.Prettify(s)
}

func (s UnassociateNetworkAclRequestResource) GoString() string {
	return s.String()
}

func (s *UnassociateNetworkAclRequestResource) SetResourceId(v string) *UnassociateNetworkAclRequestResource {
	s.ResourceId = &v
	return s
}

func (s *UnassociateNetworkAclRequestResource) SetResourceType(v string) *UnassociateNetworkAclRequestResource {
	s.ResourceType = &v
	return s
}

type UnassociateNetworkAclResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UnassociateNetworkAclResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UnassociateNetworkAclResponseBody) GoString() string {
	return s.String()
}

func (s *UnassociateNetworkAclResponseBody) SetRequestId(v string) *UnassociateNetworkAclResponseBody {
	s.RequestId = &v
	return s
}

type UnassociateNetworkAclResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UnassociateNetworkAclResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UnassociateNetworkAclResponse) String() string {
	return tea.Prettify(s)
}

func (s UnassociateNetworkAclResponse) GoString() string {
	return s.String()
}

func (s *UnassociateNetworkAclResponse) SetHeaders(v map[string]*string) *UnassociateNetworkAclResponse {
	s.Headers = v
	return s
}

func (s *UnassociateNetworkAclResponse) SetStatusCode(v int32) *UnassociateNetworkAclResponse {
	s.StatusCode = &v
	return s
}

func (s *UnassociateNetworkAclResponse) SetBody(v *UnassociateNetworkAclResponseBody) *UnassociateNetworkAclResponse {
	s.Body = v
	return s
}

type UnassociatePhysicalConnectionFromVirtualBorderRouterRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must ensure that the value is unique among all requests. The token can contain only ASCII characters.
	//
	// >  If you do not specify this parameter, the system uses **RequestId** as **ClientToken**. **RequestId** may be different for each API request.
	ClientToken  *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the Express Connect circuit.
	PhysicalConnectionId *string `json:"PhysicalConnectionId,omitempty" xml:"PhysicalConnectionId,omitempty"`
	// The region ID of the Express Connect circuit.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the VBR that you want to disassociate from the Express Connect circuit.
	VbrId *string `json:"VbrId,omitempty" xml:"VbrId,omitempty"`
}

func (s UnassociatePhysicalConnectionFromVirtualBorderRouterRequest) String() string {
	return tea.Prettify(s)
}

func (s UnassociatePhysicalConnectionFromVirtualBorderRouterRequest) GoString() string {
	return s.String()
}

func (s *UnassociatePhysicalConnectionFromVirtualBorderRouterRequest) SetClientToken(v string) *UnassociatePhysicalConnectionFromVirtualBorderRouterRequest {
	s.ClientToken = &v
	return s
}

func (s *UnassociatePhysicalConnectionFromVirtualBorderRouterRequest) SetOwnerAccount(v string) *UnassociatePhysicalConnectionFromVirtualBorderRouterRequest {
	s.OwnerAccount = &v
	return s
}

func (s *UnassociatePhysicalConnectionFromVirtualBorderRouterRequest) SetOwnerId(v int64) *UnassociatePhysicalConnectionFromVirtualBorderRouterRequest {
	s.OwnerId = &v
	return s
}

func (s *UnassociatePhysicalConnectionFromVirtualBorderRouterRequest) SetPhysicalConnectionId(v string) *UnassociatePhysicalConnectionFromVirtualBorderRouterRequest {
	s.PhysicalConnectionId = &v
	return s
}

func (s *UnassociatePhysicalConnectionFromVirtualBorderRouterRequest) SetRegionId(v string) *UnassociatePhysicalConnectionFromVirtualBorderRouterRequest {
	s.RegionId = &v
	return s
}

func (s *UnassociatePhysicalConnectionFromVirtualBorderRouterRequest) SetResourceOwnerAccount(v string) *UnassociatePhysicalConnectionFromVirtualBorderRouterRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *UnassociatePhysicalConnectionFromVirtualBorderRouterRequest) SetResourceOwnerId(v int64) *UnassociatePhysicalConnectionFromVirtualBorderRouterRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *UnassociatePhysicalConnectionFromVirtualBorderRouterRequest) SetVbrId(v string) *UnassociatePhysicalConnectionFromVirtualBorderRouterRequest {
	s.VbrId = &v
	return s
}

type UnassociatePhysicalConnectionFromVirtualBorderRouterResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UnassociatePhysicalConnectionFromVirtualBorderRouterResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UnassociatePhysicalConnectionFromVirtualBorderRouterResponseBody) GoString() string {
	return s.String()
}

func (s *UnassociatePhysicalConnectionFromVirtualBorderRouterResponseBody) SetRequestId(v string) *UnassociatePhysicalConnectionFromVirtualBorderRouterResponseBody {
	s.RequestId = &v
	return s
}

type UnassociatePhysicalConnectionFromVirtualBorderRouterResponse struct {
	Headers    map[string]*string                                                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UnassociatePhysicalConnectionFromVirtualBorderRouterResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UnassociatePhysicalConnectionFromVirtualBorderRouterResponse) String() string {
	return tea.Prettify(s)
}

func (s UnassociatePhysicalConnectionFromVirtualBorderRouterResponse) GoString() string {
	return s.String()
}

func (s *UnassociatePhysicalConnectionFromVirtualBorderRouterResponse) SetHeaders(v map[string]*string) *UnassociatePhysicalConnectionFromVirtualBorderRouterResponse {
	s.Headers = v
	return s
}

func (s *UnassociatePhysicalConnectionFromVirtualBorderRouterResponse) SetStatusCode(v int32) *UnassociatePhysicalConnectionFromVirtualBorderRouterResponse {
	s.StatusCode = &v
	return s
}

func (s *UnassociatePhysicalConnectionFromVirtualBorderRouterResponse) SetBody(v *UnassociatePhysicalConnectionFromVirtualBorderRouterResponseBody) *UnassociatePhysicalConnectionFromVirtualBorderRouterResponse {
	s.Body = v
	return s
}

type UnassociateRouteTableRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among all requests. The token can contain only ASCII characters.
	//
	// >  If you do not specify this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** may be different for each API request.
	ClientToken  *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the virtual private cloud (VPC) to which the route table belongs.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the route table.
	RouteTableId *string `json:"RouteTableId,omitempty" xml:"RouteTableId,omitempty"`
	// The ID of the vSwitch from which you want to disassociate the route table.
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
}

func (s UnassociateRouteTableRequest) String() string {
	return tea.Prettify(s)
}

func (s UnassociateRouteTableRequest) GoString() string {
	return s.String()
}

func (s *UnassociateRouteTableRequest) SetClientToken(v string) *UnassociateRouteTableRequest {
	s.ClientToken = &v
	return s
}

func (s *UnassociateRouteTableRequest) SetOwnerAccount(v string) *UnassociateRouteTableRequest {
	s.OwnerAccount = &v
	return s
}

func (s *UnassociateRouteTableRequest) SetOwnerId(v int64) *UnassociateRouteTableRequest {
	s.OwnerId = &v
	return s
}

func (s *UnassociateRouteTableRequest) SetRegionId(v string) *UnassociateRouteTableRequest {
	s.RegionId = &v
	return s
}

func (s *UnassociateRouteTableRequest) SetResourceOwnerAccount(v string) *UnassociateRouteTableRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *UnassociateRouteTableRequest) SetResourceOwnerId(v int64) *UnassociateRouteTableRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *UnassociateRouteTableRequest) SetRouteTableId(v string) *UnassociateRouteTableRequest {
	s.RouteTableId = &v
	return s
}

func (s *UnassociateRouteTableRequest) SetVSwitchId(v string) *UnassociateRouteTableRequest {
	s.VSwitchId = &v
	return s
}

type UnassociateRouteTableResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UnassociateRouteTableResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UnassociateRouteTableResponseBody) GoString() string {
	return s.String()
}

func (s *UnassociateRouteTableResponseBody) SetRequestId(v string) *UnassociateRouteTableResponseBody {
	s.RequestId = &v
	return s
}

type UnassociateRouteTableResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UnassociateRouteTableResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UnassociateRouteTableResponse) String() string {
	return tea.Prettify(s)
}

func (s UnassociateRouteTableResponse) GoString() string {
	return s.String()
}

func (s *UnassociateRouteTableResponse) SetHeaders(v map[string]*string) *UnassociateRouteTableResponse {
	s.Headers = v
	return s
}

func (s *UnassociateRouteTableResponse) SetStatusCode(v int32) *UnassociateRouteTableResponse {
	s.StatusCode = &v
	return s
}

func (s *UnassociateRouteTableResponse) SetBody(v *UnassociateRouteTableResponseBody) *UnassociateRouteTableResponse {
	s.Body = v
	return s
}

type UnassociateVpcCidrBlockRequest struct {
	// The secondary IPv6 CIDR block to be deleted.
	//
	// >  You must set one of the **Ipv6CidrBlock** and **SecondaryCidrBlock** parameters.
	IPv6CidrBlock *string `json:"IPv6CidrBlock,omitempty" xml:"IPv6CidrBlock,omitempty"`
	OwnerAccount  *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the VPC to which the secondary CIDR block to be deleted belongs.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The secondary IPv4 CIDR block to be deleted.
	//
	// >  You must set one of the **SecondaryCidrBlock** and **Ipv6CidrBlock** parameters.
	SecondaryCidrBlock *string `json:"SecondaryCidrBlock,omitempty" xml:"SecondaryCidrBlock,omitempty"`
	// The ID of the VPC from which you want to delete a secondary CIDR block.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s UnassociateVpcCidrBlockRequest) String() string {
	return tea.Prettify(s)
}

func (s UnassociateVpcCidrBlockRequest) GoString() string {
	return s.String()
}

func (s *UnassociateVpcCidrBlockRequest) SetIPv6CidrBlock(v string) *UnassociateVpcCidrBlockRequest {
	s.IPv6CidrBlock = &v
	return s
}

func (s *UnassociateVpcCidrBlockRequest) SetOwnerAccount(v string) *UnassociateVpcCidrBlockRequest {
	s.OwnerAccount = &v
	return s
}

func (s *UnassociateVpcCidrBlockRequest) SetOwnerId(v int64) *UnassociateVpcCidrBlockRequest {
	s.OwnerId = &v
	return s
}

func (s *UnassociateVpcCidrBlockRequest) SetRegionId(v string) *UnassociateVpcCidrBlockRequest {
	s.RegionId = &v
	return s
}

func (s *UnassociateVpcCidrBlockRequest) SetResourceOwnerAccount(v string) *UnassociateVpcCidrBlockRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *UnassociateVpcCidrBlockRequest) SetResourceOwnerId(v int64) *UnassociateVpcCidrBlockRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *UnassociateVpcCidrBlockRequest) SetSecondaryCidrBlock(v string) *UnassociateVpcCidrBlockRequest {
	s.SecondaryCidrBlock = &v
	return s
}

func (s *UnassociateVpcCidrBlockRequest) SetVpcId(v string) *UnassociateVpcCidrBlockRequest {
	s.VpcId = &v
	return s
}

type UnassociateVpcCidrBlockResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UnassociateVpcCidrBlockResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UnassociateVpcCidrBlockResponseBody) GoString() string {
	return s.String()
}

func (s *UnassociateVpcCidrBlockResponseBody) SetRequestId(v string) *UnassociateVpcCidrBlockResponseBody {
	s.RequestId = &v
	return s
}

type UnassociateVpcCidrBlockResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UnassociateVpcCidrBlockResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UnassociateVpcCidrBlockResponse) String() string {
	return tea.Prettify(s)
}

func (s UnassociateVpcCidrBlockResponse) GoString() string {
	return s.String()
}

func (s *UnassociateVpcCidrBlockResponse) SetHeaders(v map[string]*string) *UnassociateVpcCidrBlockResponse {
	s.Headers = v
	return s
}

func (s *UnassociateVpcCidrBlockResponse) SetStatusCode(v int32) *UnassociateVpcCidrBlockResponse {
	s.StatusCode = &v
	return s
}

func (s *UnassociateVpcCidrBlockResponse) SetBody(v *UnassociateVpcCidrBlockResponseBody) *UnassociateVpcCidrBlockResponse {
	s.Body = v
	return s
}

type UntagResourcesForExpressConnectRequest struct {
	// Specifies whether to remove all tags from the specified resource. Valid values:
	//
	// *   **true**: removes all tags from the specified resource.
	// *   **false**: does not remove all tags from the specified resource. This is the default value.
	All          *bool   `json:"All,omitempty" xml:"All,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the resource.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string   `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceId           []*string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty" type:"Repeated"`
	ResourceOwnerAccount *string   `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64    `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The type of the resource. Set the value to **PHYSICALCONNECTION**, which indicates the Express Connect circuit.
	ResourceType *string   `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	TagKey       []*string `json:"TagKey,omitempty" xml:"TagKey,omitempty" type:"Repeated"`
}

func (s UntagResourcesForExpressConnectRequest) String() string {
	return tea.Prettify(s)
}

func (s UntagResourcesForExpressConnectRequest) GoString() string {
	return s.String()
}

func (s *UntagResourcesForExpressConnectRequest) SetAll(v bool) *UntagResourcesForExpressConnectRequest {
	s.All = &v
	return s
}

func (s *UntagResourcesForExpressConnectRequest) SetOwnerAccount(v string) *UntagResourcesForExpressConnectRequest {
	s.OwnerAccount = &v
	return s
}

func (s *UntagResourcesForExpressConnectRequest) SetOwnerId(v int64) *UntagResourcesForExpressConnectRequest {
	s.OwnerId = &v
	return s
}

func (s *UntagResourcesForExpressConnectRequest) SetRegionId(v string) *UntagResourcesForExpressConnectRequest {
	s.RegionId = &v
	return s
}

func (s *UntagResourcesForExpressConnectRequest) SetResourceId(v []*string) *UntagResourcesForExpressConnectRequest {
	s.ResourceId = v
	return s
}

func (s *UntagResourcesForExpressConnectRequest) SetResourceOwnerAccount(v string) *UntagResourcesForExpressConnectRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *UntagResourcesForExpressConnectRequest) SetResourceOwnerId(v int64) *UntagResourcesForExpressConnectRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *UntagResourcesForExpressConnectRequest) SetResourceType(v string) *UntagResourcesForExpressConnectRequest {
	s.ResourceType = &v
	return s
}

func (s *UntagResourcesForExpressConnectRequest) SetTagKey(v []*string) *UntagResourcesForExpressConnectRequest {
	s.TagKey = v
	return s
}

type UntagResourcesForExpressConnectResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UntagResourcesForExpressConnectResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UntagResourcesForExpressConnectResponseBody) GoString() string {
	return s.String()
}

func (s *UntagResourcesForExpressConnectResponseBody) SetRequestId(v string) *UntagResourcesForExpressConnectResponseBody {
	s.RequestId = &v
	return s
}

type UntagResourcesForExpressConnectResponse struct {
	Headers    map[string]*string                           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UntagResourcesForExpressConnectResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UntagResourcesForExpressConnectResponse) String() string {
	return tea.Prettify(s)
}

func (s UntagResourcesForExpressConnectResponse) GoString() string {
	return s.String()
}

func (s *UntagResourcesForExpressConnectResponse) SetHeaders(v map[string]*string) *UntagResourcesForExpressConnectResponse {
	s.Headers = v
	return s
}

func (s *UntagResourcesForExpressConnectResponse) SetStatusCode(v int32) *UntagResourcesForExpressConnectResponse {
	s.StatusCode = &v
	return s
}

func (s *UntagResourcesForExpressConnectResponse) SetBody(v *UntagResourcesForExpressConnectResponseBody) *UntagResourcesForExpressConnectResponse {
	s.Body = v
	return s
}

type UpdateDhcpOptionsSetAttributeRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Enter a description for the DHCP options set.
	//
	// The description must be 2 to 256 characters in length. It must start with a letter and cannot start with `http://` or `https://`. You can also leave the description empty.
	DhcpOptionsSetDescription *string `json:"DhcpOptionsSetDescription,omitempty" xml:"DhcpOptionsSetDescription,omitempty"`
	// The ID of the DHCP options set.
	DhcpOptionsSetId *string `json:"DhcpOptionsSetId,omitempty" xml:"DhcpOptionsSetId,omitempty"`
	// The name of the DHCP options set.
	//
	// The name must be 2 to 128 characters in length, and can contain letters, digits, underscores (\_), and hyphens (-). The name must start with a letter.
	DhcpOptionsSetName *string `json:"DhcpOptionsSetName,omitempty" xml:"DhcpOptionsSetName,omitempty"`
	// The root domain. For example, you can set the value to example.com.
	//
	// After a DHCP options set is associated with a virtual private cloud (VPC), the root domain in the DHCP options set is automatically synchronized with the ECS instances in the VPC.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The IP address of the DNS server. You can enter at most four DNS server IP addresses. Separate IP addresses with commas (,).
	//
	// >  If you do not specify a DNS server IP address, Elastic Compute Service (ECS) instances use the IP addresses of the Alibaba Cloud DNS servers, which are 100.100.2.136 and 100.100.2.138.
	DomainNameServers *string `json:"DomainNameServers,omitempty" xml:"DomainNameServers,omitempty"`
	// Specifies whether to perform a dry run. Valid values:
	//
	// **true**: performs a dry run. The system checks the required parameters, request format, and limits. If the request fails the dry run, an error message is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
	//
	// **false** (default): performs a dry run and sends the request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The lease time of the IPv6 addresses for the DHCP options set.
	//
	// *   If you use hours as the unit, valid values are **24h to 1176h** and **87600h to 175200h**. Default value: **87600h**.
	// *   If you use days as the unit, valid values are **1d to 49d** and **3650d to 7300d**. Default value: **3650d**.
	//
	// >  If you specify a value, you must also specify the unit.
	Ipv6LeaseTime *string `json:"Ipv6LeaseTime,omitempty" xml:"Ipv6LeaseTime,omitempty"`
	// The lease time of the IPv4 addresses for the DHCP options set.
	//
	// *   If you use hours as the unit, valid values are **24h to 1176h** and **87600h to 175200h**. Default value: **87600h**.
	// *   If you use days as the unit, valid values are **1d to 49d** and **3650d to 7300d**. Default value: **3650d**.
	//
	// >  If you specify a value, you must also specify the unit.
	LeaseTime    *string `json:"LeaseTime,omitempty" xml:"LeaseTime,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region where the DHCP options set is deployed. You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s UpdateDhcpOptionsSetAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateDhcpOptionsSetAttributeRequest) GoString() string {
	return s.String()
}

func (s *UpdateDhcpOptionsSetAttributeRequest) SetClientToken(v string) *UpdateDhcpOptionsSetAttributeRequest {
	s.ClientToken = &v
	return s
}

func (s *UpdateDhcpOptionsSetAttributeRequest) SetDhcpOptionsSetDescription(v string) *UpdateDhcpOptionsSetAttributeRequest {
	s.DhcpOptionsSetDescription = &v
	return s
}

func (s *UpdateDhcpOptionsSetAttributeRequest) SetDhcpOptionsSetId(v string) *UpdateDhcpOptionsSetAttributeRequest {
	s.DhcpOptionsSetId = &v
	return s
}

func (s *UpdateDhcpOptionsSetAttributeRequest) SetDhcpOptionsSetName(v string) *UpdateDhcpOptionsSetAttributeRequest {
	s.DhcpOptionsSetName = &v
	return s
}

func (s *UpdateDhcpOptionsSetAttributeRequest) SetDomainName(v string) *UpdateDhcpOptionsSetAttributeRequest {
	s.DomainName = &v
	return s
}

func (s *UpdateDhcpOptionsSetAttributeRequest) SetDomainNameServers(v string) *UpdateDhcpOptionsSetAttributeRequest {
	s.DomainNameServers = &v
	return s
}

func (s *UpdateDhcpOptionsSetAttributeRequest) SetDryRun(v bool) *UpdateDhcpOptionsSetAttributeRequest {
	s.DryRun = &v
	return s
}

func (s *UpdateDhcpOptionsSetAttributeRequest) SetIpv6LeaseTime(v string) *UpdateDhcpOptionsSetAttributeRequest {
	s.Ipv6LeaseTime = &v
	return s
}

func (s *UpdateDhcpOptionsSetAttributeRequest) SetLeaseTime(v string) *UpdateDhcpOptionsSetAttributeRequest {
	s.LeaseTime = &v
	return s
}

func (s *UpdateDhcpOptionsSetAttributeRequest) SetOwnerAccount(v string) *UpdateDhcpOptionsSetAttributeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *UpdateDhcpOptionsSetAttributeRequest) SetOwnerId(v int64) *UpdateDhcpOptionsSetAttributeRequest {
	s.OwnerId = &v
	return s
}

func (s *UpdateDhcpOptionsSetAttributeRequest) SetRegionId(v string) *UpdateDhcpOptionsSetAttributeRequest {
	s.RegionId = &v
	return s
}

func (s *UpdateDhcpOptionsSetAttributeRequest) SetResourceOwnerAccount(v string) *UpdateDhcpOptionsSetAttributeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *UpdateDhcpOptionsSetAttributeRequest) SetResourceOwnerId(v int64) *UpdateDhcpOptionsSetAttributeRequest {
	s.ResourceOwnerId = &v
	return s
}

type UpdateDhcpOptionsSetAttributeResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateDhcpOptionsSetAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateDhcpOptionsSetAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateDhcpOptionsSetAttributeResponseBody) SetRequestId(v string) *UpdateDhcpOptionsSetAttributeResponseBody {
	s.RequestId = &v
	return s
}

type UpdateDhcpOptionsSetAttributeResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateDhcpOptionsSetAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateDhcpOptionsSetAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateDhcpOptionsSetAttributeResponse) GoString() string {
	return s.String()
}

func (s *UpdateDhcpOptionsSetAttributeResponse) SetHeaders(v map[string]*string) *UpdateDhcpOptionsSetAttributeResponse {
	s.Headers = v
	return s
}

func (s *UpdateDhcpOptionsSetAttributeResponse) SetStatusCode(v int32) *UpdateDhcpOptionsSetAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateDhcpOptionsSetAttributeResponse) SetBody(v *UpdateDhcpOptionsSetAttributeResponseBody) *UpdateDhcpOptionsSetAttributeResponse {
	s.Body = v
	return s
}

type UpdateGatewayRouteTableEntryAttributeRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among all requests. The client token can contain only ASCII characters.
	//
	// >  If you do not specify this parameter, the system automatically uses the value of **RequestId** as the value of **ClientToken**. The value of **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The description of the gateway route table.
	//
	// The description must be 2 to 256 characters in length. The description must start with a letter but cannot start with `http://` or `https://`.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The destination CIDR block of the route entry.
	DestinationCidrBlock *string `json:"DestinationCidrBlock,omitempty" xml:"DestinationCidrBlock,omitempty"`
	// Specifies whether to check the request without performing the operation. Valid values:
	//
	// *   **true**: checks the request but does not modify the route entry. The system checks the required parameters, request syntax, and limits. If the request fails to pass the check, an error message is returned. If the request passes the check, the `DryRunOperation` error code is returned.
	// *   **false** (default): sends the request. If the request passes the check, a 2xx HTTP status code is returned and the route entry is modified.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The ID of the gateway route table that you want to modify.
	IPv4GatewayRouteTableId *string `json:"IPv4GatewayRouteTableId,omitempty" xml:"IPv4GatewayRouteTableId,omitempty"`
	// The name of the gateway route table.
	//
	// The name must be 2 to 128 characters in length and can contain letter, digits, periods (.), underscores (\_), and hyphens (-). The name must start with a letter.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The next hop ID of the route entry after the route entry is modified.
	//
	// *   If you set **NextHopType** to **Instance**, specify an ECS instance ID for the **NextHopId** parameter.
	// *   If you set **NextHopType** to **NetworkInterface**, specify an ENI ID for the **NextHopId** parameter.
	// *   If you set **NextHopType** to **Local**, leave the **NextHopId** parameter empty, which specifies a local next hop.
	//
	// >  If you want to modify a route entry whose next hop type is **Instance** or **NetworkInterface**, you must first change the value of the **NextHopType** parameter to **Local**. Then, change the value of **NextHopType** to **Instance** or **NetworkInterface** and specify the **NextHopId** parameter. When you modify a route entry whose next hop type is Instance or NetworkInterface, you cannot directly specify a different ENI ID or ECS instance ID for the NextHopId parameter.
	NextHopId *string `json:"NextHopId,omitempty" xml:"NextHopId,omitempty"`
	// The next hop type of the route entry after the route entry is modified. Valid values:
	//
	// *   **EcsInstance**: an Elastic Compute Service (ECS) instance
	// *   **NetworkInterface**: an elastic network interface (ENI)
	// *   **Local**: a local next hop
	NextHopType  *string `json:"NextHopType,omitempty" xml:"NextHopType,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region to which the gateway route table that you want to modify belongs.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s UpdateGatewayRouteTableEntryAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteTableEntryAttributeRequest) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteTableEntryAttributeRequest) SetClientToken(v string) *UpdateGatewayRouteTableEntryAttributeRequest {
	s.ClientToken = &v
	return s
}

func (s *UpdateGatewayRouteTableEntryAttributeRequest) SetDescription(v string) *UpdateGatewayRouteTableEntryAttributeRequest {
	s.Description = &v
	return s
}

func (s *UpdateGatewayRouteTableEntryAttributeRequest) SetDestinationCidrBlock(v string) *UpdateGatewayRouteTableEntryAttributeRequest {
	s.DestinationCidrBlock = &v
	return s
}

func (s *UpdateGatewayRouteTableEntryAttributeRequest) SetDryRun(v bool) *UpdateGatewayRouteTableEntryAttributeRequest {
	s.DryRun = &v
	return s
}

func (s *UpdateGatewayRouteTableEntryAttributeRequest) SetIPv4GatewayRouteTableId(v string) *UpdateGatewayRouteTableEntryAttributeRequest {
	s.IPv4GatewayRouteTableId = &v
	return s
}

func (s *UpdateGatewayRouteTableEntryAttributeRequest) SetName(v string) *UpdateGatewayRouteTableEntryAttributeRequest {
	s.Name = &v
	return s
}

func (s *UpdateGatewayRouteTableEntryAttributeRequest) SetNextHopId(v string) *UpdateGatewayRouteTableEntryAttributeRequest {
	s.NextHopId = &v
	return s
}

func (s *UpdateGatewayRouteTableEntryAttributeRequest) SetNextHopType(v string) *UpdateGatewayRouteTableEntryAttributeRequest {
	s.NextHopType = &v
	return s
}

func (s *UpdateGatewayRouteTableEntryAttributeRequest) SetOwnerAccount(v string) *UpdateGatewayRouteTableEntryAttributeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *UpdateGatewayRouteTableEntryAttributeRequest) SetOwnerId(v int64) *UpdateGatewayRouteTableEntryAttributeRequest {
	s.OwnerId = &v
	return s
}

func (s *UpdateGatewayRouteTableEntryAttributeRequest) SetRegionId(v string) *UpdateGatewayRouteTableEntryAttributeRequest {
	s.RegionId = &v
	return s
}

func (s *UpdateGatewayRouteTableEntryAttributeRequest) SetResourceOwnerAccount(v string) *UpdateGatewayRouteTableEntryAttributeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *UpdateGatewayRouteTableEntryAttributeRequest) SetResourceOwnerId(v int64) *UpdateGatewayRouteTableEntryAttributeRequest {
	s.ResourceOwnerId = &v
	return s
}

type UpdateGatewayRouteTableEntryAttributeResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateGatewayRouteTableEntryAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteTableEntryAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteTableEntryAttributeResponseBody) SetRequestId(v string) *UpdateGatewayRouteTableEntryAttributeResponseBody {
	s.RequestId = &v
	return s
}

type UpdateGatewayRouteTableEntryAttributeResponse struct {
	Headers    map[string]*string                                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateGatewayRouteTableEntryAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateGatewayRouteTableEntryAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteTableEntryAttributeResponse) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteTableEntryAttributeResponse) SetHeaders(v map[string]*string) *UpdateGatewayRouteTableEntryAttributeResponse {
	s.Headers = v
	return s
}

func (s *UpdateGatewayRouteTableEntryAttributeResponse) SetStatusCode(v int32) *UpdateGatewayRouteTableEntryAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateGatewayRouteTableEntryAttributeResponse) SetBody(v *UpdateGatewayRouteTableEntryAttributeResponseBody) *UpdateGatewayRouteTableEntryAttributeResponse {
	s.Body = v
	return s
}

type UpdateIpsecServerRequest struct {
	// The client CIDR block. It refers to the CIDR block that is used to allocate an IP address to the client.
	//
	// >  The client CIDR block must not overlap with the CIDR block of the virtual private cloud (VPC).
	ClientIpPool *string `json:"ClientIpPool,omitempty" xml:"ClientIpPool,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. ClientToken can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to precheck the request without performing the operation. Valid values:
	//
	// *   **true**: only prechecks the request. After the request passes the precheck, the system does not modify the configurations of the IPsec server. The system checks whether the required parameters are set, whether the values are in valid formats, and the service limits. If the request fails to pass the precheck, a corresponding error code is returned. If the request passes the precheck, the `DryRunOperation` error code is returned.
	// *   **false** (default): prechecks the request. After the request passes the precheck, the system modifies the configurations of the IPsec server.
	DryRun *string `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// Specifies whether to delete the current IPsec tunnel and reinitiate negotiations. Valid values:
	//
	// *   **true**: starts the negotiation immediately after the configuration is completed.
	// *   **false** (default): initiates negotiations when inbound traffic is detected.
	EffectImmediately *bool `json:"EffectImmediately,omitempty" xml:"EffectImmediately,omitempty"`
	// The configuration of Phase 1 negotiations. Valid values:
	//
	// *   **IkeVersion**: the IKE version. Valid values: **ikev1** and **ikev2**. Default value: **ikev2**.
	// *   **IkeMode**: the IKE negotiation mode. Default value: **main**.
	// *   **IkeEncAlg**: the encryption algorithm that is used in Phase 1 negotiations. Default value: **aes**.
	// *   **IkeAuthAlg**: the authentication algorithm that is used in Phase 1 negotiations. Default value: **sha1**.
	// *   **IkePfs**: the Diffie-Hellman key exchange algorithm that is used in Phase 1 negotiations. Default value: **group2**.
	// *   **IkeLifetime**: the SA lifetime determined by Phase 1 negotiations. Unit: seconds. Valid values: **0** to **86400**. Default value: **86400**.
	// *   **LocalId**: the ID of the IPsec server. The value can be a fully qualified domain name (FQDN) or an IP address. By default, the ID of the IPsec server is the public IP address of the VPN gateway.
	// *   **RemoteId**: the identifier of the customer gateway. The value can be an FQDN or an IP address. By default, this parameter is not specified.
	IkeConfig *string `json:"IkeConfig,omitempty" xml:"IkeConfig,omitempty"`
	// The configuration of Phase 2 negotiations. Valid values:
	//
	// *   **IpsecEncAlg**: the encryption algorithm that is used in Phase 2 negotiations. Default value: **aes**.
	// *   **IpsecAuthAlg**: the authentication algorithm that is used in Phase 2 negotiations. Default value: **sha1**.
	// *   **IpsecPfs**: forwards packets of all protocols. The Diffie-Hellman key exchange algorithm used in Phase 2 negotiations. Default value: **group2**.
	// *   **IpsecLifetime**: the SA lifetime determined by Phase 2 negotiations. Unit: seconds. Valid values: **0** to **86400**. Default value: **86400**.
	IpsecConfig *string `json:"IpsecConfig,omitempty" xml:"IpsecConfig,omitempty"`
	// The ID of the IPsec server.
	IpsecServerId *string `json:"IpsecServerId,omitempty" xml:"IpsecServerId,omitempty"`
	// The name of the IPsec server.
	//
	// The name must be 1 to 100 characters in length, and cannot start with `http://` or `https://`.
	IpsecServerName *string `json:"IpsecServerName,omitempty" xml:"IpsecServerName,omitempty"`
	// The local CIDR blocks, which refer to the CIDR blocks on the virtual private cloud (VPC) side.
	//
	// Separate multiple CIDR blocks with commas (,). Example: 192.168.1.0/24,192.168.2.0/24.
	LocalSubnet *string `json:"LocalSubnet,omitempty" xml:"LocalSubnet,omitempty"`
	// The pre-shared key.
	//
	// Enter the pre-shared key that is used for identity authentication between the IPsec server and the client. The key must be 1 to 100 characters in length.
	//
	// If you do not specify a pre-shared key, the system randomly generates a 16-character string as the pre-shared key. You can call the [ListIpsecServers](~~205453~~) operation to query the pre-shared keys that are generated by the system.
	//
	// >  The pre-shared key of the IPsec server must be the same as the authentication key of the client. Otherwise, a connection cannot be established between the IPsec server and the client.
	Psk *string `json:"Psk,omitempty" xml:"Psk,omitempty"`
	// Specifies whether to enable pre-shared key authentication. If you set the value to **true**, pre-shared key authentication is enabled.
	PskEnabled *bool `json:"PskEnabled,omitempty" xml:"PskEnabled,omitempty"`
	// The ID of the region where the IPsec server is created.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s UpdateIpsecServerRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateIpsecServerRequest) GoString() string {
	return s.String()
}

func (s *UpdateIpsecServerRequest) SetClientIpPool(v string) *UpdateIpsecServerRequest {
	s.ClientIpPool = &v
	return s
}

func (s *UpdateIpsecServerRequest) SetClientToken(v string) *UpdateIpsecServerRequest {
	s.ClientToken = &v
	return s
}

func (s *UpdateIpsecServerRequest) SetDryRun(v string) *UpdateIpsecServerRequest {
	s.DryRun = &v
	return s
}

func (s *UpdateIpsecServerRequest) SetEffectImmediately(v bool) *UpdateIpsecServerRequest {
	s.EffectImmediately = &v
	return s
}

func (s *UpdateIpsecServerRequest) SetIkeConfig(v string) *UpdateIpsecServerRequest {
	s.IkeConfig = &v
	return s
}

func (s *UpdateIpsecServerRequest) SetIpsecConfig(v string) *UpdateIpsecServerRequest {
	s.IpsecConfig = &v
	return s
}

func (s *UpdateIpsecServerRequest) SetIpsecServerId(v string) *UpdateIpsecServerRequest {
	s.IpsecServerId = &v
	return s
}

func (s *UpdateIpsecServerRequest) SetIpsecServerName(v string) *UpdateIpsecServerRequest {
	s.IpsecServerName = &v
	return s
}

func (s *UpdateIpsecServerRequest) SetLocalSubnet(v string) *UpdateIpsecServerRequest {
	s.LocalSubnet = &v
	return s
}

func (s *UpdateIpsecServerRequest) SetPsk(v string) *UpdateIpsecServerRequest {
	s.Psk = &v
	return s
}

func (s *UpdateIpsecServerRequest) SetPskEnabled(v bool) *UpdateIpsecServerRequest {
	s.PskEnabled = &v
	return s
}

func (s *UpdateIpsecServerRequest) SetRegionId(v string) *UpdateIpsecServerRequest {
	s.RegionId = &v
	return s
}

type UpdateIpsecServerResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateIpsecServerResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateIpsecServerResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateIpsecServerResponseBody) SetRequestId(v string) *UpdateIpsecServerResponseBody {
	s.RequestId = &v
	return s
}

type UpdateIpsecServerResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateIpsecServerResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateIpsecServerResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateIpsecServerResponse) GoString() string {
	return s.String()
}

func (s *UpdateIpsecServerResponse) SetHeaders(v map[string]*string) *UpdateIpsecServerResponse {
	s.Headers = v
	return s
}

func (s *UpdateIpsecServerResponse) SetStatusCode(v int32) *UpdateIpsecServerResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateIpsecServerResponse) SetBody(v *UpdateIpsecServerResponseBody) *UpdateIpsecServerResponse {
	s.Body = v
	return s
}

type UpdateIpv4GatewayAttributeRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, the system uses **RequestId** as **ClientToken**. **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to check the request without performing the operation. Valid values:
	//
	// *   **true**: checks the request without performing the operation. The system checks the required parameters, request syntax, and limits. If the request fails the check, an error message is returned. If the request passes the check, the `DryRunOperation` error code is returned.
	// *   **false** (default): sends the request. If the request passes the check, a 2xx HTTP status code is returned and the operation is performed.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The new description of the IPv4 gateway.
	Ipv4GatewayDescription *string `json:"Ipv4GatewayDescription,omitempty" xml:"Ipv4GatewayDescription,omitempty"`
	// The ID of the IPv4 gateway whose name or description you want to modify.
	Ipv4GatewayId *string `json:"Ipv4GatewayId,omitempty" xml:"Ipv4GatewayId,omitempty"`
	// The new name of the IPv4 gateway.
	Ipv4GatewayName *string `json:"Ipv4GatewayName,omitempty" xml:"Ipv4GatewayName,omitempty"`
	OwnerAccount    *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId         *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the IPv4 gateway whose name or description you want to modify.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s UpdateIpv4GatewayAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateIpv4GatewayAttributeRequest) GoString() string {
	return s.String()
}

func (s *UpdateIpv4GatewayAttributeRequest) SetClientToken(v string) *UpdateIpv4GatewayAttributeRequest {
	s.ClientToken = &v
	return s
}

func (s *UpdateIpv4GatewayAttributeRequest) SetDryRun(v bool) *UpdateIpv4GatewayAttributeRequest {
	s.DryRun = &v
	return s
}

func (s *UpdateIpv4GatewayAttributeRequest) SetIpv4GatewayDescription(v string) *UpdateIpv4GatewayAttributeRequest {
	s.Ipv4GatewayDescription = &v
	return s
}

func (s *UpdateIpv4GatewayAttributeRequest) SetIpv4GatewayId(v string) *UpdateIpv4GatewayAttributeRequest {
	s.Ipv4GatewayId = &v
	return s
}

func (s *UpdateIpv4GatewayAttributeRequest) SetIpv4GatewayName(v string) *UpdateIpv4GatewayAttributeRequest {
	s.Ipv4GatewayName = &v
	return s
}

func (s *UpdateIpv4GatewayAttributeRequest) SetOwnerAccount(v string) *UpdateIpv4GatewayAttributeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *UpdateIpv4GatewayAttributeRequest) SetOwnerId(v int64) *UpdateIpv4GatewayAttributeRequest {
	s.OwnerId = &v
	return s
}

func (s *UpdateIpv4GatewayAttributeRequest) SetRegionId(v string) *UpdateIpv4GatewayAttributeRequest {
	s.RegionId = &v
	return s
}

func (s *UpdateIpv4GatewayAttributeRequest) SetResourceOwnerAccount(v string) *UpdateIpv4GatewayAttributeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *UpdateIpv4GatewayAttributeRequest) SetResourceOwnerId(v int64) *UpdateIpv4GatewayAttributeRequest {
	s.ResourceOwnerId = &v
	return s
}

type UpdateIpv4GatewayAttributeResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateIpv4GatewayAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateIpv4GatewayAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateIpv4GatewayAttributeResponseBody) SetRequestId(v string) *UpdateIpv4GatewayAttributeResponseBody {
	s.RequestId = &v
	return s
}

type UpdateIpv4GatewayAttributeResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateIpv4GatewayAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateIpv4GatewayAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateIpv4GatewayAttributeResponse) GoString() string {
	return s.String()
}

func (s *UpdateIpv4GatewayAttributeResponse) SetHeaders(v map[string]*string) *UpdateIpv4GatewayAttributeResponse {
	s.Headers = v
	return s
}

func (s *UpdateIpv4GatewayAttributeResponse) SetStatusCode(v int32) *UpdateIpv4GatewayAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateIpv4GatewayAttributeResponse) SetBody(v *UpdateIpv4GatewayAttributeResponseBody) *UpdateIpv4GatewayAttributeResponse {
	s.Body = v
	return s
}

type UpdateNatGatewayNatTypeRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether only to precheck this request. Valid values:
	//
	// **true**: prechecks the request but does not upgrade the Internet NAT gateway. The system checks your AccessKey pair, the Resource Access Management (RAM) user permissions, and the required parameters. If the request fails the precheck, an error message is returned. If the request passes the precheck, the `DryRunOperation` error code is returned.
	//
	// **false** (default): If the request passes the precheck, a 2XX HTTP status code is returned and the standard NAT gateway is upgraded.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The ID of the standard NAT gateway to be upgraded.
	NatGatewayId *string `json:"NatGatewayId,omitempty" xml:"NatGatewayId,omitempty"`
	// The type of Internet NAT gateway. Set the value to **Enhanced**, which specifies an enhanced Internet NAT gateway.
	NatType      *string `json:"NatType,omitempty" xml:"NatType,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region where the NAT gateway that you want to upgrade is deployed.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The vSwitch to which the enhanced Internet NAT gateway belongs.
	//
	// >  If you do not set this parameter, the system creates an Internet NAT gateway in a random vSwitch of a virtual private cloud (VPC).
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
}

func (s UpdateNatGatewayNatTypeRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateNatGatewayNatTypeRequest) GoString() string {
	return s.String()
}

func (s *UpdateNatGatewayNatTypeRequest) SetClientToken(v string) *UpdateNatGatewayNatTypeRequest {
	s.ClientToken = &v
	return s
}

func (s *UpdateNatGatewayNatTypeRequest) SetDryRun(v bool) *UpdateNatGatewayNatTypeRequest {
	s.DryRun = &v
	return s
}

func (s *UpdateNatGatewayNatTypeRequest) SetNatGatewayId(v string) *UpdateNatGatewayNatTypeRequest {
	s.NatGatewayId = &v
	return s
}

func (s *UpdateNatGatewayNatTypeRequest) SetNatType(v string) *UpdateNatGatewayNatTypeRequest {
	s.NatType = &v
	return s
}

func (s *UpdateNatGatewayNatTypeRequest) SetOwnerAccount(v string) *UpdateNatGatewayNatTypeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *UpdateNatGatewayNatTypeRequest) SetOwnerId(v int64) *UpdateNatGatewayNatTypeRequest {
	s.OwnerId = &v
	return s
}

func (s *UpdateNatGatewayNatTypeRequest) SetRegionId(v string) *UpdateNatGatewayNatTypeRequest {
	s.RegionId = &v
	return s
}

func (s *UpdateNatGatewayNatTypeRequest) SetResourceOwnerAccount(v string) *UpdateNatGatewayNatTypeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *UpdateNatGatewayNatTypeRequest) SetResourceOwnerId(v int64) *UpdateNatGatewayNatTypeRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *UpdateNatGatewayNatTypeRequest) SetVSwitchId(v string) *UpdateNatGatewayNatTypeRequest {
	s.VSwitchId = &v
	return s
}

type UpdateNatGatewayNatTypeResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateNatGatewayNatTypeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateNatGatewayNatTypeResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateNatGatewayNatTypeResponseBody) SetRequestId(v string) *UpdateNatGatewayNatTypeResponseBody {
	s.RequestId = &v
	return s
}

type UpdateNatGatewayNatTypeResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateNatGatewayNatTypeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateNatGatewayNatTypeResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateNatGatewayNatTypeResponse) GoString() string {
	return s.String()
}

func (s *UpdateNatGatewayNatTypeResponse) SetHeaders(v map[string]*string) *UpdateNatGatewayNatTypeResponse {
	s.Headers = v
	return s
}

func (s *UpdateNatGatewayNatTypeResponse) SetStatusCode(v int32) *UpdateNatGatewayNatTypeResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateNatGatewayNatTypeResponse) SetBody(v *UpdateNatGatewayNatTypeResponseBody) *UpdateNatGatewayNatTypeResponse {
	s.Body = v
	return s
}

type UpdateNetworkAclEntriesRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can contain only ASCII characters.
	//
	// >  If you do not specify this parameter, the system uses **RequestId** as **ClientToken**. **RequestId** may be different for each API request.
	ClientToken       *string                                            `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	EgressAclEntries  []*UpdateNetworkAclEntriesRequestEgressAclEntries  `json:"EgressAclEntries,omitempty" xml:"EgressAclEntries,omitempty" type:"Repeated"`
	IngressAclEntries []*UpdateNetworkAclEntriesRequestIngressAclEntries `json:"IngressAclEntries,omitempty" xml:"IngressAclEntries,omitempty" type:"Repeated"`
	// The ID of the network ACL.
	NetworkAclId *string `json:"NetworkAclId,omitempty" xml:"NetworkAclId,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the network ACL.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// Specifies whether to update outbound rules. Valid values:
	//
	// *   **true**: yes
	// *   **false** (default): no
	UpdateEgressAclEntries *bool `json:"UpdateEgressAclEntries,omitempty" xml:"UpdateEgressAclEntries,omitempty"`
	// Specifies whether to update inbound rules. Valid values:
	//
	// *   **true**: yes
	// *   **false** (default): no
	UpdateIngressAclEntries *bool `json:"UpdateIngressAclEntries,omitempty" xml:"UpdateIngressAclEntries,omitempty"`
}

func (s UpdateNetworkAclEntriesRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateNetworkAclEntriesRequest) GoString() string {
	return s.String()
}

func (s *UpdateNetworkAclEntriesRequest) SetClientToken(v string) *UpdateNetworkAclEntriesRequest {
	s.ClientToken = &v
	return s
}

func (s *UpdateNetworkAclEntriesRequest) SetEgressAclEntries(v []*UpdateNetworkAclEntriesRequestEgressAclEntries) *UpdateNetworkAclEntriesRequest {
	s.EgressAclEntries = v
	return s
}

func (s *UpdateNetworkAclEntriesRequest) SetIngressAclEntries(v []*UpdateNetworkAclEntriesRequestIngressAclEntries) *UpdateNetworkAclEntriesRequest {
	s.IngressAclEntries = v
	return s
}

func (s *UpdateNetworkAclEntriesRequest) SetNetworkAclId(v string) *UpdateNetworkAclEntriesRequest {
	s.NetworkAclId = &v
	return s
}

func (s *UpdateNetworkAclEntriesRequest) SetOwnerId(v int64) *UpdateNetworkAclEntriesRequest {
	s.OwnerId = &v
	return s
}

func (s *UpdateNetworkAclEntriesRequest) SetRegionId(v string) *UpdateNetworkAclEntriesRequest {
	s.RegionId = &v
	return s
}

func (s *UpdateNetworkAclEntriesRequest) SetResourceOwnerAccount(v string) *UpdateNetworkAclEntriesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *UpdateNetworkAclEntriesRequest) SetResourceOwnerId(v int64) *UpdateNetworkAclEntriesRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *UpdateNetworkAclEntriesRequest) SetUpdateEgressAclEntries(v bool) *UpdateNetworkAclEntriesRequest {
	s.UpdateEgressAclEntries = &v
	return s
}

func (s *UpdateNetworkAclEntriesRequest) SetUpdateIngressAclEntries(v bool) *UpdateNetworkAclEntriesRequest {
	s.UpdateIngressAclEntries = &v
	return s
}

type UpdateNetworkAclEntriesRequestEgressAclEntries struct {
	// The description of the outbound rule.
	//
	// The description must be 1 to 256 characters in length, and cannot start with `http://` or `https://`.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The destination CIDR block.
	DestinationCidrIp *string `json:"DestinationCidrIp,omitempty" xml:"DestinationCidrIp,omitempty"`
	// The type of the rule. Set the value to **custom**, which specifies custom rules.
	EntryType *string `json:"EntryType,omitempty" xml:"EntryType,omitempty"`
	// The ID of the outbound rule.
	//
	// Valid values of **N**: **0** to **29**. You can update at most 30 outbound rules.
	NetworkAclEntryId *string `json:"NetworkAclEntryId,omitempty" xml:"NetworkAclEntryId,omitempty"`
	// The name of the outbound rule.
	//
	// The name must be 1 to 128 characters in length, and cannot start with `http://` or `https://`.
	NetworkAclEntryName *string `json:"NetworkAclEntryName,omitempty" xml:"NetworkAclEntryName,omitempty"`
	// The action to be performed on network traffic that matches the rule. Valid values:
	//
	// *   **accept**: allows the network traffic.
	// *   **drop**: blocks the network traffic.
	Policy *string `json:"Policy,omitempty" xml:"Policy,omitempty"`
	// The destination port range of the outbound rule.
	//
	// *   If **Protocol** of the outbound rule is set to **all**, **icmp**, or **gre**, the port range is **-1/-1**, which specifies all ports.
	// *   If **Protocol** of the outbound rule is set to **tcp** or **udp**, set the port range in the following format: **1/200** or **80/80**, which specifies port 1 to port 200 or port 80. Valid values for a port: **1** to **65535**.
	Port *string `json:"Port,omitempty" xml:"Port,omitempty"`
	// The protocol type. Valid values:
	//
	// *   **icmp**: ICMP
	// *   **gre**: GRE
	// *   **tcp**: TCP
	// *   **udp**: UDP
	// *   **all**: all protocols
	Protocol *string `json:"Protocol,omitempty" xml:"Protocol,omitempty"`
}

func (s UpdateNetworkAclEntriesRequestEgressAclEntries) String() string {
	return tea.Prettify(s)
}

func (s UpdateNetworkAclEntriesRequestEgressAclEntries) GoString() string {
	return s.String()
}

func (s *UpdateNetworkAclEntriesRequestEgressAclEntries) SetDescription(v string) *UpdateNetworkAclEntriesRequestEgressAclEntries {
	s.Description = &v
	return s
}

func (s *UpdateNetworkAclEntriesRequestEgressAclEntries) SetDestinationCidrIp(v string) *UpdateNetworkAclEntriesRequestEgressAclEntries {
	s.DestinationCidrIp = &v
	return s
}

func (s *UpdateNetworkAclEntriesRequestEgressAclEntries) SetEntryType(v string) *UpdateNetworkAclEntriesRequestEgressAclEntries {
	s.EntryType = &v
	return s
}

func (s *UpdateNetworkAclEntriesRequestEgressAclEntries) SetNetworkAclEntryId(v string) *UpdateNetworkAclEntriesRequestEgressAclEntries {
	s.NetworkAclEntryId = &v
	return s
}

func (s *UpdateNetworkAclEntriesRequestEgressAclEntries) SetNetworkAclEntryName(v string) *UpdateNetworkAclEntriesRequestEgressAclEntries {
	s.NetworkAclEntryName = &v
	return s
}

func (s *UpdateNetworkAclEntriesRequestEgressAclEntries) SetPolicy(v string) *UpdateNetworkAclEntriesRequestEgressAclEntries {
	s.Policy = &v
	return s
}

func (s *UpdateNetworkAclEntriesRequestEgressAclEntries) SetPort(v string) *UpdateNetworkAclEntriesRequestEgressAclEntries {
	s.Port = &v
	return s
}

func (s *UpdateNetworkAclEntriesRequestEgressAclEntries) SetProtocol(v string) *UpdateNetworkAclEntriesRequestEgressAclEntries {
	s.Protocol = &v
	return s
}

type UpdateNetworkAclEntriesRequestIngressAclEntries struct {
	// The description of the inbound rule.
	//
	// The description must be 1 to 256 characters in length, and cannot start with `http://` or `https://`.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The type of the rule. Set the value to **custom**, which specifies custom rules.
	EntryType *string `json:"EntryType,omitempty" xml:"EntryType,omitempty"`
	// The ID of the inbound rule.
	//
	// Valid values of **N**: **0** to **29**. You can update at most 30 inbound rules.
	NetworkAclEntryId *string `json:"NetworkAclEntryId,omitempty" xml:"NetworkAclEntryId,omitempty"`
	// The name of the inbound rule.
	//
	// The name must be 1 to 128 characters in length, and cannot start with `http://` or `https://`.
	NetworkAclEntryName *string `json:"NetworkAclEntryName,omitempty" xml:"NetworkAclEntryName,omitempty"`
	// The action to be performed on network traffic that matches the rule. Valid values:
	//
	// *   **accept**: allows the network traffic.
	// *   **drop**: blocks the network traffic.
	Policy *string `json:"Policy,omitempty" xml:"Policy,omitempty"`
	// The source port range of the inbound rule.
	//
	// *   If **Protocol** of the inbound rule is set to **all**, **icmp**, or **gre**, the port range is **-1/-1**, which specifies all ports.
	// *   If **Protocol** of the inbound rule is set to **tcp** or **udp**, set the port range in the following format: **1/200** or **80/80**, which specifies port 1 to port 200 or port 80. Valid values for a port: **1** to **65535**.
	Port *string `json:"Port,omitempty" xml:"Port,omitempty"`
	// The protocol type. Valid values:
	//
	// *   **icmp**: Internet Control Message Protocol (ICMP)
	// *   **gre**: Generic Routing Encapsulation (GRE)
	// *   **tcp**: TCP
	// *   **udp**: UDP
	// *   **all**: all protocols
	Protocol *string `json:"Protocol,omitempty" xml:"Protocol,omitempty"`
	// The source CIDR block.
	SourceCidrIp *string `json:"SourceCidrIp,omitempty" xml:"SourceCidrIp,omitempty"`
}

func (s UpdateNetworkAclEntriesRequestIngressAclEntries) String() string {
	return tea.Prettify(s)
}

func (s UpdateNetworkAclEntriesRequestIngressAclEntries) GoString() string {
	return s.String()
}

func (s *UpdateNetworkAclEntriesRequestIngressAclEntries) SetDescription(v string) *UpdateNetworkAclEntriesRequestIngressAclEntries {
	s.Description = &v
	return s
}

func (s *UpdateNetworkAclEntriesRequestIngressAclEntries) SetEntryType(v string) *UpdateNetworkAclEntriesRequestIngressAclEntries {
	s.EntryType = &v
	return s
}

func (s *UpdateNetworkAclEntriesRequestIngressAclEntries) SetNetworkAclEntryId(v string) *UpdateNetworkAclEntriesRequestIngressAclEntries {
	s.NetworkAclEntryId = &v
	return s
}

func (s *UpdateNetworkAclEntriesRequestIngressAclEntries) SetNetworkAclEntryName(v string) *UpdateNetworkAclEntriesRequestIngressAclEntries {
	s.NetworkAclEntryName = &v
	return s
}

func (s *UpdateNetworkAclEntriesRequestIngressAclEntries) SetPolicy(v string) *UpdateNetworkAclEntriesRequestIngressAclEntries {
	s.Policy = &v
	return s
}

func (s *UpdateNetworkAclEntriesRequestIngressAclEntries) SetPort(v string) *UpdateNetworkAclEntriesRequestIngressAclEntries {
	s.Port = &v
	return s
}

func (s *UpdateNetworkAclEntriesRequestIngressAclEntries) SetProtocol(v string) *UpdateNetworkAclEntriesRequestIngressAclEntries {
	s.Protocol = &v
	return s
}

func (s *UpdateNetworkAclEntriesRequestIngressAclEntries) SetSourceCidrIp(v string) *UpdateNetworkAclEntriesRequestIngressAclEntries {
	s.SourceCidrIp = &v
	return s
}

type UpdateNetworkAclEntriesResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateNetworkAclEntriesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateNetworkAclEntriesResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateNetworkAclEntriesResponseBody) SetRequestId(v string) *UpdateNetworkAclEntriesResponseBody {
	s.RequestId = &v
	return s
}

type UpdateNetworkAclEntriesResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateNetworkAclEntriesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateNetworkAclEntriesResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateNetworkAclEntriesResponse) GoString() string {
	return s.String()
}

func (s *UpdateNetworkAclEntriesResponse) SetHeaders(v map[string]*string) *UpdateNetworkAclEntriesResponse {
	s.Headers = v
	return s
}

func (s *UpdateNetworkAclEntriesResponse) SetStatusCode(v int32) *UpdateNetworkAclEntriesResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateNetworkAclEntriesResponse) SetBody(v *UpdateNetworkAclEntriesResponseBody) *UpdateNetworkAclEntriesResponse {
	s.Body = v
	return s
}

type UpdatePublicIpAddressPoolAttributeRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can contain only ASCII characters.
	//
	// >  If you do not specify this parameter, the system uses **RequestId** as **ClientToken**. The value of **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The description of the IP address pool.
	//
	// This parameter is optional. If you enter a description, the description must be 2 to 256 characters in length, and cannot start with http:// or https://.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// Specifies whether to perform a dry run. Valid values:
	//
	// *   **true**: performs a dry run. The system checks the required parameters, request syntax, and limits. If the request fails the dry run, an error message is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
	// *   **false** (default): performs a dry run and sends the request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The name of the IP address pool.
	//
	// This parameter is optional. If you enter a name, the name must be 1 to 128 characters in length and can contain digits, periods (.), underscores (\_), and hyphens (-). The name must start with a letter but cannot start with `http://` or `https://`.
	Name         *string `json:"Name,omitempty" xml:"Name,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the IP address pool.
	PublicIpAddressPoolId *string `json:"PublicIpAddressPoolId,omitempty" xml:"PublicIpAddressPoolId,omitempty"`
	// The region ID of the IP address pool that you want to modify.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s UpdatePublicIpAddressPoolAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdatePublicIpAddressPoolAttributeRequest) GoString() string {
	return s.String()
}

func (s *UpdatePublicIpAddressPoolAttributeRequest) SetClientToken(v string) *UpdatePublicIpAddressPoolAttributeRequest {
	s.ClientToken = &v
	return s
}

func (s *UpdatePublicIpAddressPoolAttributeRequest) SetDescription(v string) *UpdatePublicIpAddressPoolAttributeRequest {
	s.Description = &v
	return s
}

func (s *UpdatePublicIpAddressPoolAttributeRequest) SetDryRun(v bool) *UpdatePublicIpAddressPoolAttributeRequest {
	s.DryRun = &v
	return s
}

func (s *UpdatePublicIpAddressPoolAttributeRequest) SetName(v string) *UpdatePublicIpAddressPoolAttributeRequest {
	s.Name = &v
	return s
}

func (s *UpdatePublicIpAddressPoolAttributeRequest) SetOwnerAccount(v string) *UpdatePublicIpAddressPoolAttributeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *UpdatePublicIpAddressPoolAttributeRequest) SetOwnerId(v int64) *UpdatePublicIpAddressPoolAttributeRequest {
	s.OwnerId = &v
	return s
}

func (s *UpdatePublicIpAddressPoolAttributeRequest) SetPublicIpAddressPoolId(v string) *UpdatePublicIpAddressPoolAttributeRequest {
	s.PublicIpAddressPoolId = &v
	return s
}

func (s *UpdatePublicIpAddressPoolAttributeRequest) SetRegionId(v string) *UpdatePublicIpAddressPoolAttributeRequest {
	s.RegionId = &v
	return s
}

func (s *UpdatePublicIpAddressPoolAttributeRequest) SetResourceOwnerAccount(v string) *UpdatePublicIpAddressPoolAttributeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *UpdatePublicIpAddressPoolAttributeRequest) SetResourceOwnerId(v int64) *UpdatePublicIpAddressPoolAttributeRequest {
	s.ResourceOwnerId = &v
	return s
}

type UpdatePublicIpAddressPoolAttributeResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdatePublicIpAddressPoolAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdatePublicIpAddressPoolAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *UpdatePublicIpAddressPoolAttributeResponseBody) SetRequestId(v string) *UpdatePublicIpAddressPoolAttributeResponseBody {
	s.RequestId = &v
	return s
}

type UpdatePublicIpAddressPoolAttributeResponse struct {
	Headers    map[string]*string                              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdatePublicIpAddressPoolAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdatePublicIpAddressPoolAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdatePublicIpAddressPoolAttributeResponse) GoString() string {
	return s.String()
}

func (s *UpdatePublicIpAddressPoolAttributeResponse) SetHeaders(v map[string]*string) *UpdatePublicIpAddressPoolAttributeResponse {
	s.Headers = v
	return s
}

func (s *UpdatePublicIpAddressPoolAttributeResponse) SetStatusCode(v int32) *UpdatePublicIpAddressPoolAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdatePublicIpAddressPoolAttributeResponse) SetBody(v *UpdatePublicIpAddressPoolAttributeResponseBody) *UpdatePublicIpAddressPoolAttributeResponse {
	s.Body = v
	return s
}

type UpdateTrafficMirrorFilterAttributeRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can contain only ASCII characters.
	//
	// >  If you do not specify this parameter, the system uses **RequestId** as **ClientToken**. **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to check the request without performing the operation. Valid values:
	//
	// *   **true**: checks the request without performing the operation. The system checks the required parameters, request syntax, and limits. If the request fails the check, an error message is returned. If the request passes the check, the `DryRunOperation` error code is returned.
	// *   **false** (default): sends the request. If the request passes the check, a 2xx HTTP status code is returned and the operation is performed.
	DryRun       *bool   `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region to which the mirrored traffic belongs.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list. For more information about regions that support traffic mirroring, see [Overview of traffic mirroring](~~207513~~).
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The description of the filter.
	//
	// The description must be 1 to 256 characters in length and cannot start with `http://` or `https://`.
	TrafficMirrorFilterDescription *string `json:"TrafficMirrorFilterDescription,omitempty" xml:"TrafficMirrorFilterDescription,omitempty"`
	// The ID of the filter.
	TrafficMirrorFilterId *string `json:"TrafficMirrorFilterId,omitempty" xml:"TrafficMirrorFilterId,omitempty"`
	// The name of the filter.
	//
	// The name must be 1 to 128 characters in length and cannot start with `http://` or `https://`.
	TrafficMirrorFilterName *string `json:"TrafficMirrorFilterName,omitempty" xml:"TrafficMirrorFilterName,omitempty"`
}

func (s UpdateTrafficMirrorFilterAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateTrafficMirrorFilterAttributeRequest) GoString() string {
	return s.String()
}

func (s *UpdateTrafficMirrorFilterAttributeRequest) SetClientToken(v string) *UpdateTrafficMirrorFilterAttributeRequest {
	s.ClientToken = &v
	return s
}

func (s *UpdateTrafficMirrorFilterAttributeRequest) SetDryRun(v bool) *UpdateTrafficMirrorFilterAttributeRequest {
	s.DryRun = &v
	return s
}

func (s *UpdateTrafficMirrorFilterAttributeRequest) SetOwnerAccount(v string) *UpdateTrafficMirrorFilterAttributeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *UpdateTrafficMirrorFilterAttributeRequest) SetOwnerId(v int64) *UpdateTrafficMirrorFilterAttributeRequest {
	s.OwnerId = &v
	return s
}

func (s *UpdateTrafficMirrorFilterAttributeRequest) SetRegionId(v string) *UpdateTrafficMirrorFilterAttributeRequest {
	s.RegionId = &v
	return s
}

func (s *UpdateTrafficMirrorFilterAttributeRequest) SetResourceOwnerAccount(v string) *UpdateTrafficMirrorFilterAttributeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *UpdateTrafficMirrorFilterAttributeRequest) SetResourceOwnerId(v int64) *UpdateTrafficMirrorFilterAttributeRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *UpdateTrafficMirrorFilterAttributeRequest) SetTrafficMirrorFilterDescription(v string) *UpdateTrafficMirrorFilterAttributeRequest {
	s.TrafficMirrorFilterDescription = &v
	return s
}

func (s *UpdateTrafficMirrorFilterAttributeRequest) SetTrafficMirrorFilterId(v string) *UpdateTrafficMirrorFilterAttributeRequest {
	s.TrafficMirrorFilterId = &v
	return s
}

func (s *UpdateTrafficMirrorFilterAttributeRequest) SetTrafficMirrorFilterName(v string) *UpdateTrafficMirrorFilterAttributeRequest {
	s.TrafficMirrorFilterName = &v
	return s
}

type UpdateTrafficMirrorFilterAttributeResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateTrafficMirrorFilterAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateTrafficMirrorFilterAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateTrafficMirrorFilterAttributeResponseBody) SetRequestId(v string) *UpdateTrafficMirrorFilterAttributeResponseBody {
	s.RequestId = &v
	return s
}

type UpdateTrafficMirrorFilterAttributeResponse struct {
	Headers    map[string]*string                              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateTrafficMirrorFilterAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateTrafficMirrorFilterAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateTrafficMirrorFilterAttributeResponse) GoString() string {
	return s.String()
}

func (s *UpdateTrafficMirrorFilterAttributeResponse) SetHeaders(v map[string]*string) *UpdateTrafficMirrorFilterAttributeResponse {
	s.Headers = v
	return s
}

func (s *UpdateTrafficMirrorFilterAttributeResponse) SetStatusCode(v int32) *UpdateTrafficMirrorFilterAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateTrafficMirrorFilterAttributeResponse) SetBody(v *UpdateTrafficMirrorFilterAttributeResponseBody) *UpdateTrafficMirrorFilterAttributeResponse {
	s.Body = v
	return s
}

type UpdateTrafficMirrorFilterRuleAttributeRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, the system uses **RequestId** as **ClientToken**. **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The new destination CIDR block of the inbound or outbound traffic.
	DestinationCidrBlock *string `json:"DestinationCidrBlock,omitempty" xml:"DestinationCidrBlock,omitempty"`
	// The new destination port range of the inbound or outbound traffic.
	//
	// >  If you set **Protocol** to **ICMP**, you cannot change the port range.
	DestinationPortRange *string `json:"DestinationPortRange,omitempty" xml:"DestinationPortRange,omitempty"`
	// Specifies whether to check the request without performing the operation. Valid values:
	//
	// *   **true**: only checks the API request. The configuration of the inbound or outbound rule is not modified. The system checks the required parameters, request syntax, and limits. If the request fails to pass the check, an error message is returned. If the request passes the precheck, the `DryRunOperation` error code is returned.
	// *   **false**: sends the request. This is the default value. If the request passes the check, a 2xx HTTP status code is returned and the configuration of the inbound or outbound rule is modified.
	DryRun       *bool   `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The new priority of the inbound or outbound rule. A smaller value indicates a higher priority.
	Priority *int32 `json:"Priority,omitempty" xml:"Priority,omitempty"`
	// The new protocol that is used by the traffic to be mirrored by the inbound or outbound rule. Valid values:
	//
	// *   **ALL**: all protocols
	// *   **ICMP**: Internet Control Message Protocol (ICMP)
	// *   **TCP**: TCP
	// *   **UDP**: User Datagram Protocol (UDP)
	Protocol *string `json:"Protocol,omitempty" xml:"Protocol,omitempty"`
	// The ID of the region to which the mirrored traffic belongs.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list. For more information about regions that support traffic mirroring, see [Overview of traffic mirroring](~~207513~~).
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The new action of the inbound or outbound rule. Valid values:
	//
	// *   **accept**: accepts network traffic.
	// *   **drop**: drops network traffic.
	RuleAction *string `json:"RuleAction,omitempty" xml:"RuleAction,omitempty"`
	// The new source CIDR block of the inbound or outbound traffic.
	SourceCidrBlock *string `json:"SourceCidrBlock,omitempty" xml:"SourceCidrBlock,omitempty"`
	// The new source port range of the inbound or outbound traffic.
	//
	// >  If you set **Protocol** to **ICMP**, you cannot change the port range.
	SourcePortRange *string `json:"SourcePortRange,omitempty" xml:"SourcePortRange,omitempty"`
	// The ID of the inbound or outbound rule.
	TrafficMirrorFilterRuleId *string `json:"TrafficMirrorFilterRuleId,omitempty" xml:"TrafficMirrorFilterRuleId,omitempty"`
}

func (s UpdateTrafficMirrorFilterRuleAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateTrafficMirrorFilterRuleAttributeRequest) GoString() string {
	return s.String()
}

func (s *UpdateTrafficMirrorFilterRuleAttributeRequest) SetClientToken(v string) *UpdateTrafficMirrorFilterRuleAttributeRequest {
	s.ClientToken = &v
	return s
}

func (s *UpdateTrafficMirrorFilterRuleAttributeRequest) SetDestinationCidrBlock(v string) *UpdateTrafficMirrorFilterRuleAttributeRequest {
	s.DestinationCidrBlock = &v
	return s
}

func (s *UpdateTrafficMirrorFilterRuleAttributeRequest) SetDestinationPortRange(v string) *UpdateTrafficMirrorFilterRuleAttributeRequest {
	s.DestinationPortRange = &v
	return s
}

func (s *UpdateTrafficMirrorFilterRuleAttributeRequest) SetDryRun(v bool) *UpdateTrafficMirrorFilterRuleAttributeRequest {
	s.DryRun = &v
	return s
}

func (s *UpdateTrafficMirrorFilterRuleAttributeRequest) SetOwnerAccount(v string) *UpdateTrafficMirrorFilterRuleAttributeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *UpdateTrafficMirrorFilterRuleAttributeRequest) SetOwnerId(v int64) *UpdateTrafficMirrorFilterRuleAttributeRequest {
	s.OwnerId = &v
	return s
}

func (s *UpdateTrafficMirrorFilterRuleAttributeRequest) SetPriority(v int32) *UpdateTrafficMirrorFilterRuleAttributeRequest {
	s.Priority = &v
	return s
}

func (s *UpdateTrafficMirrorFilterRuleAttributeRequest) SetProtocol(v string) *UpdateTrafficMirrorFilterRuleAttributeRequest {
	s.Protocol = &v
	return s
}

func (s *UpdateTrafficMirrorFilterRuleAttributeRequest) SetRegionId(v string) *UpdateTrafficMirrorFilterRuleAttributeRequest {
	s.RegionId = &v
	return s
}

func (s *UpdateTrafficMirrorFilterRuleAttributeRequest) SetResourceOwnerAccount(v string) *UpdateTrafficMirrorFilterRuleAttributeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *UpdateTrafficMirrorFilterRuleAttributeRequest) SetResourceOwnerId(v int64) *UpdateTrafficMirrorFilterRuleAttributeRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *UpdateTrafficMirrorFilterRuleAttributeRequest) SetRuleAction(v string) *UpdateTrafficMirrorFilterRuleAttributeRequest {
	s.RuleAction = &v
	return s
}

func (s *UpdateTrafficMirrorFilterRuleAttributeRequest) SetSourceCidrBlock(v string) *UpdateTrafficMirrorFilterRuleAttributeRequest {
	s.SourceCidrBlock = &v
	return s
}

func (s *UpdateTrafficMirrorFilterRuleAttributeRequest) SetSourcePortRange(v string) *UpdateTrafficMirrorFilterRuleAttributeRequest {
	s.SourcePortRange = &v
	return s
}

func (s *UpdateTrafficMirrorFilterRuleAttributeRequest) SetTrafficMirrorFilterRuleId(v string) *UpdateTrafficMirrorFilterRuleAttributeRequest {
	s.TrafficMirrorFilterRuleId = &v
	return s
}

type UpdateTrafficMirrorFilterRuleAttributeResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateTrafficMirrorFilterRuleAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateTrafficMirrorFilterRuleAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateTrafficMirrorFilterRuleAttributeResponseBody) SetRequestId(v string) *UpdateTrafficMirrorFilterRuleAttributeResponseBody {
	s.RequestId = &v
	return s
}

type UpdateTrafficMirrorFilterRuleAttributeResponse struct {
	Headers    map[string]*string                                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateTrafficMirrorFilterRuleAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateTrafficMirrorFilterRuleAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateTrafficMirrorFilterRuleAttributeResponse) GoString() string {
	return s.String()
}

func (s *UpdateTrafficMirrorFilterRuleAttributeResponse) SetHeaders(v map[string]*string) *UpdateTrafficMirrorFilterRuleAttributeResponse {
	s.Headers = v
	return s
}

func (s *UpdateTrafficMirrorFilterRuleAttributeResponse) SetStatusCode(v int32) *UpdateTrafficMirrorFilterRuleAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateTrafficMirrorFilterRuleAttributeResponse) SetBody(v *UpdateTrafficMirrorFilterRuleAttributeResponseBody) *UpdateTrafficMirrorFilterRuleAttributeResponse {
	s.Body = v
	return s
}

type UpdateTrafficMirrorSessionAttributeRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can contain only ASCII characters.
	//
	// >  If you do not specify this parameter, the system uses **RequestId** as **ClientToken**. **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to precheck the request without performing the operation. Valid values:
	//
	// *   **true**: checks the request without performing the operation. The system prechecks the required parameters, request syntax, and limits. If the request fails the precheck, an error message is returned. If the request passes the precheck, the `DryRunOperation` error code is returned.
	// *   **false**: sends the request. If the request passes the check, a 2xx HTTP status code is returned and the operation is performed. This is the default value.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// Specifies whether to enable the traffic mirror session.
	//
	// *   **false**: disables the traffic mirror session. This is the default value.
	// *   **true**: enables the traffic mirror session.
	Enabled      *bool   `json:"Enabled,omitempty" xml:"Enabled,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	PacketLength *int32  `json:"PacketLength,omitempty" xml:"PacketLength,omitempty"`
	// The priority of the traffic mirror session. Valid values: **1** to **32766**.
	//
	// A smaller value specifies a higher priority. You cannot specify identical priorities for traffic mirror sessions that are created in the same region by using the same account.
	Priority *int32 `json:"Priority,omitempty" xml:"Priority,omitempty"`
	// The region ID of the traffic mirror session. You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list. For more information about regions that support traffic mirroring, see [Overview of traffic mirroring](~~207513~~).
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the traffic mirror filter.
	TrafficMirrorFilterId *string `json:"TrafficMirrorFilterId,omitempty" xml:"TrafficMirrorFilterId,omitempty"`
	// The description of the traffic mirror session.
	//
	// The description must be 1 to 256 characters in length and cannot start with `http://` or `https://`.
	TrafficMirrorSessionDescription *string `json:"TrafficMirrorSessionDescription,omitempty" xml:"TrafficMirrorSessionDescription,omitempty"`
	// The ID of the traffic mirror session.
	TrafficMirrorSessionId *string `json:"TrafficMirrorSessionId,omitempty" xml:"TrafficMirrorSessionId,omitempty"`
	// The name of the traffic mirror session.
	//
	// The name must be 1 to 128 characters in length and cannot start with `http://` or `https://`.
	TrafficMirrorSessionName *string `json:"TrafficMirrorSessionName,omitempty" xml:"TrafficMirrorSessionName,omitempty"`
	// The ID of the traffic mirror destination.
	TrafficMirrorTargetId *string `json:"TrafficMirrorTargetId,omitempty" xml:"TrafficMirrorTargetId,omitempty"`
	// The type of the traffic mirror destination. Valid values:
	//
	// *   **NetworkInterface**: an ENI
	// *   **SLB**: an internal-facing Server Load Balancer (SLB) instance
	TrafficMirrorTargetType *string `json:"TrafficMirrorTargetType,omitempty" xml:"TrafficMirrorTargetType,omitempty"`
	// The VXLAN network identifier (VNI) that is used to distinguish different mirrored traffic. Valid values: **0** to **16777215**.
	//
	// You can use VNIs to identify mirrored traffic from different sessions at the traffic mirror destination. If you do not specify a VNI, the system randomly allocates a VNI. If you want the system to randomly allocate a VNI, ignore this parameter.
	VirtualNetworkId *int32 `json:"VirtualNetworkId,omitempty" xml:"VirtualNetworkId,omitempty"`
}

func (s UpdateTrafficMirrorSessionAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateTrafficMirrorSessionAttributeRequest) GoString() string {
	return s.String()
}

func (s *UpdateTrafficMirrorSessionAttributeRequest) SetClientToken(v string) *UpdateTrafficMirrorSessionAttributeRequest {
	s.ClientToken = &v
	return s
}

func (s *UpdateTrafficMirrorSessionAttributeRequest) SetDryRun(v bool) *UpdateTrafficMirrorSessionAttributeRequest {
	s.DryRun = &v
	return s
}

func (s *UpdateTrafficMirrorSessionAttributeRequest) SetEnabled(v bool) *UpdateTrafficMirrorSessionAttributeRequest {
	s.Enabled = &v
	return s
}

func (s *UpdateTrafficMirrorSessionAttributeRequest) SetOwnerAccount(v string) *UpdateTrafficMirrorSessionAttributeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *UpdateTrafficMirrorSessionAttributeRequest) SetOwnerId(v int64) *UpdateTrafficMirrorSessionAttributeRequest {
	s.OwnerId = &v
	return s
}

func (s *UpdateTrafficMirrorSessionAttributeRequest) SetPacketLength(v int32) *UpdateTrafficMirrorSessionAttributeRequest {
	s.PacketLength = &v
	return s
}

func (s *UpdateTrafficMirrorSessionAttributeRequest) SetPriority(v int32) *UpdateTrafficMirrorSessionAttributeRequest {
	s.Priority = &v
	return s
}

func (s *UpdateTrafficMirrorSessionAttributeRequest) SetRegionId(v string) *UpdateTrafficMirrorSessionAttributeRequest {
	s.RegionId = &v
	return s
}

func (s *UpdateTrafficMirrorSessionAttributeRequest) SetResourceOwnerAccount(v string) *UpdateTrafficMirrorSessionAttributeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *UpdateTrafficMirrorSessionAttributeRequest) SetResourceOwnerId(v int64) *UpdateTrafficMirrorSessionAttributeRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *UpdateTrafficMirrorSessionAttributeRequest) SetTrafficMirrorFilterId(v string) *UpdateTrafficMirrorSessionAttributeRequest {
	s.TrafficMirrorFilterId = &v
	return s
}

func (s *UpdateTrafficMirrorSessionAttributeRequest) SetTrafficMirrorSessionDescription(v string) *UpdateTrafficMirrorSessionAttributeRequest {
	s.TrafficMirrorSessionDescription = &v
	return s
}

func (s *UpdateTrafficMirrorSessionAttributeRequest) SetTrafficMirrorSessionId(v string) *UpdateTrafficMirrorSessionAttributeRequest {
	s.TrafficMirrorSessionId = &v
	return s
}

func (s *UpdateTrafficMirrorSessionAttributeRequest) SetTrafficMirrorSessionName(v string) *UpdateTrafficMirrorSessionAttributeRequest {
	s.TrafficMirrorSessionName = &v
	return s
}

func (s *UpdateTrafficMirrorSessionAttributeRequest) SetTrafficMirrorTargetId(v string) *UpdateTrafficMirrorSessionAttributeRequest {
	s.TrafficMirrorTargetId = &v
	return s
}

func (s *UpdateTrafficMirrorSessionAttributeRequest) SetTrafficMirrorTargetType(v string) *UpdateTrafficMirrorSessionAttributeRequest {
	s.TrafficMirrorTargetType = &v
	return s
}

func (s *UpdateTrafficMirrorSessionAttributeRequest) SetVirtualNetworkId(v int32) *UpdateTrafficMirrorSessionAttributeRequest {
	s.VirtualNetworkId = &v
	return s
}

type UpdateTrafficMirrorSessionAttributeResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateTrafficMirrorSessionAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateTrafficMirrorSessionAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateTrafficMirrorSessionAttributeResponseBody) SetRequestId(v string) *UpdateTrafficMirrorSessionAttributeResponseBody {
	s.RequestId = &v
	return s
}

type UpdateTrafficMirrorSessionAttributeResponse struct {
	Headers    map[string]*string                               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateTrafficMirrorSessionAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateTrafficMirrorSessionAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateTrafficMirrorSessionAttributeResponse) GoString() string {
	return s.String()
}

func (s *UpdateTrafficMirrorSessionAttributeResponse) SetHeaders(v map[string]*string) *UpdateTrafficMirrorSessionAttributeResponse {
	s.Headers = v
	return s
}

func (s *UpdateTrafficMirrorSessionAttributeResponse) SetStatusCode(v int32) *UpdateTrafficMirrorSessionAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateTrafficMirrorSessionAttributeResponse) SetBody(v *UpdateTrafficMirrorSessionAttributeResponseBody) *UpdateTrafficMirrorSessionAttributeResponse {
	s.Body = v
	return s
}

type UpdateVirtualBorderBandwidthRequest struct {
	// The new maximum bandwidth of the VBR. Unit: Mbit/s.
	Bandwidth *int32 `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	//
	// >  If you do not set this parameter, the system uses **RequestId** as **ClientToken**. **RequestId** may be different for each API request.
	ClientToken  *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the VBR.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the VBR.
	VirtualBorderRouterId *string `json:"VirtualBorderRouterId,omitempty" xml:"VirtualBorderRouterId,omitempty"`
}

func (s UpdateVirtualBorderBandwidthRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateVirtualBorderBandwidthRequest) GoString() string {
	return s.String()
}

func (s *UpdateVirtualBorderBandwidthRequest) SetBandwidth(v int32) *UpdateVirtualBorderBandwidthRequest {
	s.Bandwidth = &v
	return s
}

func (s *UpdateVirtualBorderBandwidthRequest) SetClientToken(v string) *UpdateVirtualBorderBandwidthRequest {
	s.ClientToken = &v
	return s
}

func (s *UpdateVirtualBorderBandwidthRequest) SetOwnerAccount(v string) *UpdateVirtualBorderBandwidthRequest {
	s.OwnerAccount = &v
	return s
}

func (s *UpdateVirtualBorderBandwidthRequest) SetOwnerId(v int64) *UpdateVirtualBorderBandwidthRequest {
	s.OwnerId = &v
	return s
}

func (s *UpdateVirtualBorderBandwidthRequest) SetRegionId(v string) *UpdateVirtualBorderBandwidthRequest {
	s.RegionId = &v
	return s
}

func (s *UpdateVirtualBorderBandwidthRequest) SetResourceOwnerAccount(v string) *UpdateVirtualBorderBandwidthRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *UpdateVirtualBorderBandwidthRequest) SetResourceOwnerId(v int64) *UpdateVirtualBorderBandwidthRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *UpdateVirtualBorderBandwidthRequest) SetVirtualBorderRouterId(v string) *UpdateVirtualBorderBandwidthRequest {
	s.VirtualBorderRouterId = &v
	return s
}

type UpdateVirtualBorderBandwidthResponseBody struct {
	// The response code.
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The HTTP status code.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The response message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the maximum bandwidth is updated. Valid values:
	//
	// *   **true**
	// *   **false**
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateVirtualBorderBandwidthResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateVirtualBorderBandwidthResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateVirtualBorderBandwidthResponseBody) SetCode(v string) *UpdateVirtualBorderBandwidthResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateVirtualBorderBandwidthResponseBody) SetHttpStatusCode(v int32) *UpdateVirtualBorderBandwidthResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *UpdateVirtualBorderBandwidthResponseBody) SetMessage(v string) *UpdateVirtualBorderBandwidthResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateVirtualBorderBandwidthResponseBody) SetRequestId(v string) *UpdateVirtualBorderBandwidthResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateVirtualBorderBandwidthResponseBody) SetSuccess(v bool) *UpdateVirtualBorderBandwidthResponseBody {
	s.Success = &v
	return s
}

type UpdateVirtualBorderBandwidthResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateVirtualBorderBandwidthResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateVirtualBorderBandwidthResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateVirtualBorderBandwidthResponse) GoString() string {
	return s.String()
}

func (s *UpdateVirtualBorderBandwidthResponse) SetHeaders(v map[string]*string) *UpdateVirtualBorderBandwidthResponse {
	s.Headers = v
	return s
}

func (s *UpdateVirtualBorderBandwidthResponse) SetStatusCode(v int32) *UpdateVirtualBorderBandwidthResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateVirtualBorderBandwidthResponse) SetBody(v *UpdateVirtualBorderBandwidthResponseBody) *UpdateVirtualBorderBandwidthResponse {
	s.Body = v
	return s
}

type UpdateVirtualPhysicalConnectionRequest struct {
	// Specifies whether to check the request without performing the operation. Valid values:
	//
	// *   **true**: checks the request without performing the operation. The VLAN ID of the hosted connection is not changed. The system checks the required parameters, request syntax, and instance status. If the check fails, the corresponding error message is returned. If the request passes the check, the system returns the ID of the request.
	// *   **false** (default): sends the request. If the request passes the check, the VLAN ID of the hosted connection is changed.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The estimated bandwidth value of the hosted connection. The estimated bandwidth value takes effect after the payment is completed.
	//
	// Valid values: **50M**, **100M**, **200M**, **300M**, **400M**, **500M**, **1G**, **2G**, **5G**, **8G**, and **10G**.
	//
	// >  By default, the values of **2G**, **5G**, **8G**, and **10G** are unavailable. If you want to specify these values, contact your customer manager.
	//
	// **M** indicates Mbit/s and **G** indicates Gbit/s.
	ExpectSpec *string `json:"ExpectSpec,omitempty" xml:"ExpectSpec,omitempty"`
	// The ID of the shared Express Connect circuit.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The region ID of the hosted connection.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among all requests. The token can contain only ASCII characters.
	//
	// >  If you do not specify this parameter, the system automatically uses **RequestId** as **ClientToken**. The value of **RequestId** in each API request may be different.
	Token *string `json:"Token,omitempty" xml:"Token,omitempty"`
	// The VLAN ID of the hosted connection. Valid values: **0** to **2999**.
	//
	// *   If the VLAN ID is set to **0**, it indicates that the switch port of the virtual border router (VBR) is a Layer 3 router interface instead of a VLAN interface. When a Layer 3 router interface is used, each Express Connect circuit corresponds to a VBR.
	// *   If the VLAN ID is set to a value from **1** to **2999**, the switch port of the VBR is a Layer 3 VLAN subinterface. When a Layer 3 VLAN subinterface is used, each VLAN ID corresponds to one VBR. In this case, the Express Connect circuit with which the VBR is associated can be used to connect to VPCs that belong to different Alibaba Cloud accounts. VBRs in different VLANs are isolated from each other at Layer 2.
	VlanId *int64 `json:"VlanId,omitempty" xml:"VlanId,omitempty"`
}

func (s UpdateVirtualPhysicalConnectionRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateVirtualPhysicalConnectionRequest) GoString() string {
	return s.String()
}

func (s *UpdateVirtualPhysicalConnectionRequest) SetDryRun(v bool) *UpdateVirtualPhysicalConnectionRequest {
	s.DryRun = &v
	return s
}

func (s *UpdateVirtualPhysicalConnectionRequest) SetExpectSpec(v string) *UpdateVirtualPhysicalConnectionRequest {
	s.ExpectSpec = &v
	return s
}

func (s *UpdateVirtualPhysicalConnectionRequest) SetInstanceId(v string) *UpdateVirtualPhysicalConnectionRequest {
	s.InstanceId = &v
	return s
}

func (s *UpdateVirtualPhysicalConnectionRequest) SetRegionId(v string) *UpdateVirtualPhysicalConnectionRequest {
	s.RegionId = &v
	return s
}

func (s *UpdateVirtualPhysicalConnectionRequest) SetToken(v string) *UpdateVirtualPhysicalConnectionRequest {
	s.Token = &v
	return s
}

func (s *UpdateVirtualPhysicalConnectionRequest) SetVlanId(v int64) *UpdateVirtualPhysicalConnectionRequest {
	s.VlanId = &v
	return s
}

type UpdateVirtualPhysicalConnectionResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the VLAN ID of the hosted connection is changed. Valid values:
	//
	// *   **true**: The VLAN ID of the hosted connection is changed.
	// *   **false**: The VLAN ID of the hosted connection is not changed.
	Success *string `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateVirtualPhysicalConnectionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateVirtualPhysicalConnectionResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateVirtualPhysicalConnectionResponseBody) SetRequestId(v string) *UpdateVirtualPhysicalConnectionResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateVirtualPhysicalConnectionResponseBody) SetSuccess(v string) *UpdateVirtualPhysicalConnectionResponseBody {
	s.Success = &v
	return s
}

type UpdateVirtualPhysicalConnectionResponse struct {
	Headers    map[string]*string                           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateVirtualPhysicalConnectionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateVirtualPhysicalConnectionResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateVirtualPhysicalConnectionResponse) GoString() string {
	return s.String()
}

func (s *UpdateVirtualPhysicalConnectionResponse) SetHeaders(v map[string]*string) *UpdateVirtualPhysicalConnectionResponse {
	s.Headers = v
	return s
}

func (s *UpdateVirtualPhysicalConnectionResponse) SetStatusCode(v int32) *UpdateVirtualPhysicalConnectionResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateVirtualPhysicalConnectionResponse) SetBody(v *UpdateVirtualPhysicalConnectionResponseBody) *UpdateVirtualPhysicalConnectionResponse {
	s.Body = v
	return s
}

type UpdateVpcGatewayEndpointAttributeRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among all requests. The token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, the system uses **RequestId** as **ClientToken**. The value of **RequestId** of each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to perform a dry run. Valid values:
	//
	// *   **true**: performs a dry run. The system checks your AccessKey pair, the RAM user permissions, and the required parameters If the request fails the dry run, the corresponding error message is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
	// *   **false** (default): performs a dry run and sends the request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The new description of the gateway endpoint.
	//
	// The description must be 1 to 255 characters in length.
	EndpointDescription *string `json:"EndpointDescription,omitempty" xml:"EndpointDescription,omitempty"`
	// The ID of the gateway endpoint that you want to modify.
	EndpointId *string `json:"EndpointId,omitempty" xml:"EndpointId,omitempty"`
	// The new name of the gateway endpoint.
	//
	// The name must be 1 to 128 characters in length.
	EndpointName *string `json:"EndpointName,omitempty" xml:"EndpointName,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The access policy for the cloud service.
	//
	// For more information about the syntax and structure of the access policy, see [Policy syntax and structure](~~93739~~).
	PolicyDocument *string `json:"PolicyDocument,omitempty" xml:"PolicyDocument,omitempty"`
	// The region ID of the gateway endpoint.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s UpdateVpcGatewayEndpointAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateVpcGatewayEndpointAttributeRequest) GoString() string {
	return s.String()
}

func (s *UpdateVpcGatewayEndpointAttributeRequest) SetClientToken(v string) *UpdateVpcGatewayEndpointAttributeRequest {
	s.ClientToken = &v
	return s
}

func (s *UpdateVpcGatewayEndpointAttributeRequest) SetDryRun(v bool) *UpdateVpcGatewayEndpointAttributeRequest {
	s.DryRun = &v
	return s
}

func (s *UpdateVpcGatewayEndpointAttributeRequest) SetEndpointDescription(v string) *UpdateVpcGatewayEndpointAttributeRequest {
	s.EndpointDescription = &v
	return s
}

func (s *UpdateVpcGatewayEndpointAttributeRequest) SetEndpointId(v string) *UpdateVpcGatewayEndpointAttributeRequest {
	s.EndpointId = &v
	return s
}

func (s *UpdateVpcGatewayEndpointAttributeRequest) SetEndpointName(v string) *UpdateVpcGatewayEndpointAttributeRequest {
	s.EndpointName = &v
	return s
}

func (s *UpdateVpcGatewayEndpointAttributeRequest) SetOwnerAccount(v string) *UpdateVpcGatewayEndpointAttributeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *UpdateVpcGatewayEndpointAttributeRequest) SetOwnerId(v int64) *UpdateVpcGatewayEndpointAttributeRequest {
	s.OwnerId = &v
	return s
}

func (s *UpdateVpcGatewayEndpointAttributeRequest) SetPolicyDocument(v string) *UpdateVpcGatewayEndpointAttributeRequest {
	s.PolicyDocument = &v
	return s
}

func (s *UpdateVpcGatewayEndpointAttributeRequest) SetRegionId(v string) *UpdateVpcGatewayEndpointAttributeRequest {
	s.RegionId = &v
	return s
}

func (s *UpdateVpcGatewayEndpointAttributeRequest) SetResourceOwnerAccount(v string) *UpdateVpcGatewayEndpointAttributeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *UpdateVpcGatewayEndpointAttributeRequest) SetResourceOwnerId(v int64) *UpdateVpcGatewayEndpointAttributeRequest {
	s.ResourceOwnerId = &v
	return s
}

type UpdateVpcGatewayEndpointAttributeResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateVpcGatewayEndpointAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateVpcGatewayEndpointAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateVpcGatewayEndpointAttributeResponseBody) SetRequestId(v string) *UpdateVpcGatewayEndpointAttributeResponseBody {
	s.RequestId = &v
	return s
}

type UpdateVpcGatewayEndpointAttributeResponse struct {
	Headers    map[string]*string                             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateVpcGatewayEndpointAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateVpcGatewayEndpointAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateVpcGatewayEndpointAttributeResponse) GoString() string {
	return s.String()
}

func (s *UpdateVpcGatewayEndpointAttributeResponse) SetHeaders(v map[string]*string) *UpdateVpcGatewayEndpointAttributeResponse {
	s.Headers = v
	return s
}

func (s *UpdateVpcGatewayEndpointAttributeResponse) SetStatusCode(v int32) *UpdateVpcGatewayEndpointAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateVpcGatewayEndpointAttributeResponse) SetBody(v *UpdateVpcGatewayEndpointAttributeResponseBody) *UpdateVpcGatewayEndpointAttributeResponse {
	s.Body = v
	return s
}

type VpcDescribeVpcNatGatewayNetworkInterfaceQuotaRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among all requests. ClientToken can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the VPC NAT gateway.
	NatGatewayId *string `json:"NatGatewayId,omitempty" xml:"NatGatewayId,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the VPC NAT gateway.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the Alibaba Cloud account to which the resource belongs.
	ResourceUid *int64 `json:"ResourceUid,omitempty" xml:"ResourceUid,omitempty"`
}

func (s VpcDescribeVpcNatGatewayNetworkInterfaceQuotaRequest) String() string {
	return tea.Prettify(s)
}

func (s VpcDescribeVpcNatGatewayNetworkInterfaceQuotaRequest) GoString() string {
	return s.String()
}

func (s *VpcDescribeVpcNatGatewayNetworkInterfaceQuotaRequest) SetClientToken(v string) *VpcDescribeVpcNatGatewayNetworkInterfaceQuotaRequest {
	s.ClientToken = &v
	return s
}

func (s *VpcDescribeVpcNatGatewayNetworkInterfaceQuotaRequest) SetNatGatewayId(v string) *VpcDescribeVpcNatGatewayNetworkInterfaceQuotaRequest {
	s.NatGatewayId = &v
	return s
}

func (s *VpcDescribeVpcNatGatewayNetworkInterfaceQuotaRequest) SetOwnerAccount(v string) *VpcDescribeVpcNatGatewayNetworkInterfaceQuotaRequest {
	s.OwnerAccount = &v
	return s
}

func (s *VpcDescribeVpcNatGatewayNetworkInterfaceQuotaRequest) SetOwnerId(v int64) *VpcDescribeVpcNatGatewayNetworkInterfaceQuotaRequest {
	s.OwnerId = &v
	return s
}

func (s *VpcDescribeVpcNatGatewayNetworkInterfaceQuotaRequest) SetRegionId(v string) *VpcDescribeVpcNatGatewayNetworkInterfaceQuotaRequest {
	s.RegionId = &v
	return s
}

func (s *VpcDescribeVpcNatGatewayNetworkInterfaceQuotaRequest) SetResourceOwnerAccount(v string) *VpcDescribeVpcNatGatewayNetworkInterfaceQuotaRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *VpcDescribeVpcNatGatewayNetworkInterfaceQuotaRequest) SetResourceOwnerId(v int64) *VpcDescribeVpcNatGatewayNetworkInterfaceQuotaRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *VpcDescribeVpcNatGatewayNetworkInterfaceQuotaRequest) SetResourceUid(v int64) *VpcDescribeVpcNatGatewayNetworkInterfaceQuotaRequest {
	s.ResourceUid = &v
	return s
}

type VpcDescribeVpcNatGatewayNetworkInterfaceQuotaResponseBody struct {
	// The number of endpoints that can be created.
	Quota *int64 `json:"Quota,omitempty" xml:"Quota,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s VpcDescribeVpcNatGatewayNetworkInterfaceQuotaResponseBody) String() string {
	return tea.Prettify(s)
}

func (s VpcDescribeVpcNatGatewayNetworkInterfaceQuotaResponseBody) GoString() string {
	return s.String()
}

func (s *VpcDescribeVpcNatGatewayNetworkInterfaceQuotaResponseBody) SetQuota(v int64) *VpcDescribeVpcNatGatewayNetworkInterfaceQuotaResponseBody {
	s.Quota = &v
	return s
}

func (s *VpcDescribeVpcNatGatewayNetworkInterfaceQuotaResponseBody) SetRequestId(v string) *VpcDescribeVpcNatGatewayNetworkInterfaceQuotaResponseBody {
	s.RequestId = &v
	return s
}

type VpcDescribeVpcNatGatewayNetworkInterfaceQuotaResponse struct {
	Headers    map[string]*string                                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *VpcDescribeVpcNatGatewayNetworkInterfaceQuotaResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s VpcDescribeVpcNatGatewayNetworkInterfaceQuotaResponse) String() string {
	return tea.Prettify(s)
}

func (s VpcDescribeVpcNatGatewayNetworkInterfaceQuotaResponse) GoString() string {
	return s.String()
}

func (s *VpcDescribeVpcNatGatewayNetworkInterfaceQuotaResponse) SetHeaders(v map[string]*string) *VpcDescribeVpcNatGatewayNetworkInterfaceQuotaResponse {
	s.Headers = v
	return s
}

func (s *VpcDescribeVpcNatGatewayNetworkInterfaceQuotaResponse) SetStatusCode(v int32) *VpcDescribeVpcNatGatewayNetworkInterfaceQuotaResponse {
	s.StatusCode = &v
	return s
}

func (s *VpcDescribeVpcNatGatewayNetworkInterfaceQuotaResponse) SetBody(v *VpcDescribeVpcNatGatewayNetworkInterfaceQuotaResponseBody) *VpcDescribeVpcNatGatewayNetworkInterfaceQuotaResponse {
	s.Body = v
	return s
}

type Client struct {
	openapi.Client
}

func NewClient(config *openapi.Config) (*Client, error) {
	client := new(Client)
	err := client.Init(config)
	return client, err
}

func (client *Client) Init(config *openapi.Config) (_err error) {
	_err = client.Client.Init(config)
	if _err != nil {
		return _err
	}
	client.EndpointRule = tea.String("regional")
	client.EndpointMap = map[string]*string{
		"cn-qingdao":                  tea.String("vpc.aliyuncs.com"),
		"cn-beijing":                  tea.String("vpc.aliyuncs.com"),
		"cn-hangzhou":                 tea.String("vpc.aliyuncs.com"),
		"cn-shanghai":                 tea.String("vpc.aliyuncs.com"),
		"cn-shenzhen":                 tea.String("vpc.aliyuncs.com"),
		"cn-hongkong":                 tea.String("vpc.aliyuncs.com"),
		"ap-southeast-1":              tea.String("vpc.aliyuncs.com"),
		"us-east-1":                   tea.String("vpc.aliyuncs.com"),
		"us-west-1":                   tea.String("vpc.aliyuncs.com"),
		"cn-shanghai-finance-1":       tea.String("vpc.aliyuncs.com"),
		"cn-shenzhen-finance-1":       tea.String("vpc.aliyuncs.com"),
		"cn-north-2-gov-1":            tea.String("vpc.aliyuncs.com"),
		"ap-northeast-2-pop":          tea.String("vpc.aliyuncs.com"),
		"cn-beijing-finance-pop":      tea.String("vpc.aliyuncs.com"),
		"cn-beijing-gov-1":            tea.String("vpc.aliyuncs.com"),
		"cn-beijing-nu16-b01":         tea.String("vpc.aliyuncs.com"),
		"cn-edge-1":                   tea.String("vpc-nebula.cn-qingdao-nebula.aliyuncs.com"),
		"cn-fujian":                   tea.String("vpc.aliyuncs.com"),
		"cn-haidian-cm12-c01":         tea.String("vpc.aliyuncs.com"),
		"cn-hangzhou-bj-b01":          tea.String("vpc.aliyuncs.com"),
		"cn-hangzhou-finance":         tea.String("vpc.aliyuncs.com"),
		"cn-hangzhou-internal-prod-1": tea.String("vpc.aliyuncs.com"),
		"cn-hangzhou-internal-test-1": tea.String("vpc.aliyuncs.com"),
		"cn-hangzhou-internal-test-2": tea.String("vpc.aliyuncs.com"),
		"cn-hangzhou-internal-test-3": tea.String("vpc.aliyuncs.com"),
		"cn-hangzhou-test-306":        tea.String("vpc.aliyuncs.com"),
		"cn-hongkong-finance-pop":     tea.String("vpc.aliyuncs.com"),
		"cn-huhehaote-nebula-1":       tea.String("vpc-nebula.cn-qingdao-nebula.aliyuncs.com"),
		"cn-qingdao-nebula":           tea.String("vpc-nebula.cn-qingdao-nebula.aliyuncs.com"),
		"cn-shanghai-et15-b01":        tea.String("vpc.aliyuncs.com"),
		"cn-shanghai-et2-b01":         tea.String("vpc.aliyuncs.com"),
		"cn-shanghai-inner":           tea.String("vpc.aliyuncs.com"),
		"cn-shanghai-internal-test-1": tea.String("vpc.aliyuncs.com"),
		"cn-shenzhen-inner":           tea.String("vpc.aliyuncs.com"),
		"cn-shenzhen-st4-d01":         tea.String("vpc.aliyuncs.com"),
		"cn-shenzhen-su18-b01":        tea.String("vpc.aliyuncs.com"),
		"cn-wuhan":                    tea.String("vpc.aliyuncs.com"),
		"cn-yushanfang":               tea.String("vpc.aliyuncs.com"),
		"cn-zhangbei":                 tea.String("vpc.aliyuncs.com"),
		"cn-zhangbei-na61-b01":        tea.String("vpc.aliyuncs.com"),
		"cn-zhangjiakou-na62-a01":     tea.String("vpc.cn-zhangjiakou.aliyuncs.com"),
		"cn-zhengzhou-nebula-1":       tea.String("vpc-nebula.cn-qingdao-nebula.aliyuncs.com"),
		"eu-west-1-oxs":               tea.String("vpc-nebula.cn-shenzhen-cloudstone.aliyuncs.com"),
		"rus-west-1-pop":              tea.String("vpc.aliyuncs.com"),
	}
	_err = client.CheckConfig(config)
	if _err != nil {
		return _err
	}
	client.Endpoint, _err = client.GetEndpoint(tea.String("vpc"), client.RegionId, client.EndpointRule, client.Network, client.Suffix, client.EndpointMap, client.Endpoint)
	if _err != nil {
		return _err
	}

	return nil
}

func (client *Client) GetEndpoint(productId *string, regionId *string, endpointRule *string, network *string, suffix *string, endpointMap map[string]*string, endpoint *string) (_result *string, _err error) {
	if !tea.BoolValue(util.Empty(endpoint)) {
		_result = endpoint
		return _result, _err
	}

	if !tea.BoolValue(util.IsUnset(endpointMap)) && !tea.BoolValue(util.Empty(endpointMap[tea.StringValue(regionId)])) {
		_result = endpointMap[tea.StringValue(regionId)]
		return _result, _err
	}

	_body, _err := endpointutil.GetEndpointRules(productId, regionId, endpointRule, network, suffix)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * After you call this operation, the router interface enters the **Activating** state. After the router interface is activated, it enters the **Active** state.
 * >  You cannot activate a router interface that has overdue payments.
 *
 * @param request ActivateRouterInterfaceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ActivateRouterInterfaceResponse
 */
func (client *Client) ActivateRouterInterfaceWithOptions(request *ActivateRouterInterfaceRequest, runtime *util.RuntimeOptions) (_result *ActivateRouterInterfaceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RouterInterfaceId)) {
		query["RouterInterfaceId"] = request.RouterInterfaceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ActivateRouterInterface"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ActivateRouterInterfaceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * After you call this operation, the router interface enters the **Activating** state. After the router interface is activated, it enters the **Active** state.
 * >  You cannot activate a router interface that has overdue payments.
 *
 * @param request ActivateRouterInterfaceRequest
 * @return ActivateRouterInterfaceResponse
 */
func (client *Client) ActivateRouterInterface(request *ActivateRouterInterfaceRequest) (_result *ActivateRouterInterfaceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ActivateRouterInterfaceResponse{}
	_body, _err := client.ActivateRouterInterfaceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   The **ActiveFlowLog** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeFlowLogs](~~87923~~) operation to query the status of a flow log:
 *     *   If the flow log is in the **Activating** state, the flow log is being started.
 *     *   If the flow log is in the **Active** state, the flow log is started.
 * *   You cannot repeatedly call the **ActiveFlowLog** operation to start a flow log within the specified period of time.
 *
 * @param request ActiveFlowLogRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ActiveFlowLogResponse
 */
func (client *Client) ActiveFlowLogWithOptions(request *ActiveFlowLogRequest, runtime *util.RuntimeOptions) (_result *ActiveFlowLogResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.FlowLogId)) {
		query["FlowLogId"] = request.FlowLogId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ActiveFlowLog"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ActiveFlowLogResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   The **ActiveFlowLog** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeFlowLogs](~~87923~~) operation to query the status of a flow log:
 *     *   If the flow log is in the **Activating** state, the flow log is being started.
 *     *   If the flow log is in the **Active** state, the flow log is started.
 * *   You cannot repeatedly call the **ActiveFlowLog** operation to start a flow log within the specified period of time.
 *
 * @param request ActiveFlowLogRequest
 * @return ActiveFlowLogResponse
 */
func (client *Client) ActiveFlowLog(request *ActiveFlowLogRequest) (_result *ActiveFlowLogResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ActiveFlowLogResponse{}
	_body, _err := client.ActiveFlowLogWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AddBgpNetworkWithOptions(request *AddBgpNetworkRequest, runtime *util.RuntimeOptions) (_result *AddBgpNetworkResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DstCidrBlock)) {
		query["DstCidrBlock"] = request.DstCidrBlock
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RouterId)) {
		query["RouterId"] = request.RouterId
	}

	if !tea.BoolValue(util.IsUnset(request.VpcId)) {
		query["VpcId"] = request.VpcId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddBgpNetwork"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddBgpNetworkResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AddBgpNetwork(request *AddBgpNetworkRequest) (_result *AddBgpNetworkResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddBgpNetworkResponse{}
	_body, _err := client.AddBgpNetworkWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   When you call this operation to associate an EIP with an EIP bandwidth plan, make sure that the EIP meets the following requirements:
 *     *   The EIP uses the pay-as-you-go billing method.
 *     *   The EIP and the EIP bandwidth plan belong to the same region.
 *     *   The line type of the EIP is the same as that of the EIP bandwidth plan.
 * *   The **AddCommonBandwidthPackageIp** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeCommonBandwidthPackages](~~120309~~) operation to query the status of an EIP bandwidth plan:
 *     *   If the EIP bandwidth plan is in the **BINDING** state, the EIP is being associated with the EIP bandwidth plan. In this state, you can only query the EIP bandwidth plan and cannot perform other operations.
 *     *   If the EIP bandwidth plan is in the **BINDED** state, the EIP is associated with the EIP bandwidth plan.
 *
 * @param request AddCommonBandwidthPackageIpRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddCommonBandwidthPackageIpResponse
 */
func (client *Client) AddCommonBandwidthPackageIpWithOptions(request *AddCommonBandwidthPackageIpRequest, runtime *util.RuntimeOptions) (_result *AddCommonBandwidthPackageIpResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BandwidthPackageId)) {
		query["BandwidthPackageId"] = request.BandwidthPackageId
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.IpInstanceId)) {
		query["IpInstanceId"] = request.IpInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.IpType)) {
		query["IpType"] = request.IpType
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddCommonBandwidthPackageIp"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddCommonBandwidthPackageIpResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   When you call this operation to associate an EIP with an EIP bandwidth plan, make sure that the EIP meets the following requirements:
 *     *   The EIP uses the pay-as-you-go billing method.
 *     *   The EIP and the EIP bandwidth plan belong to the same region.
 *     *   The line type of the EIP is the same as that of the EIP bandwidth plan.
 * *   The **AddCommonBandwidthPackageIp** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeCommonBandwidthPackages](~~120309~~) operation to query the status of an EIP bandwidth plan:
 *     *   If the EIP bandwidth plan is in the **BINDING** state, the EIP is being associated with the EIP bandwidth plan. In this state, you can only query the EIP bandwidth plan and cannot perform other operations.
 *     *   If the EIP bandwidth plan is in the **BINDED** state, the EIP is associated with the EIP bandwidth plan.
 *
 * @param request AddCommonBandwidthPackageIpRequest
 * @return AddCommonBandwidthPackageIpResponse
 */
func (client *Client) AddCommonBandwidthPackageIp(request *AddCommonBandwidthPackageIpRequest) (_result *AddCommonBandwidthPackageIpResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddCommonBandwidthPackageIpResponse{}
	_body, _err := client.AddCommonBandwidthPackageIpWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   When you call this operation to associate EIPs with an EIP bandwidth plan, make sure that the EIPs meet the following requirements:
 *     *   The EIPs use the pay-as-you-go billing method.
 *     *   The EIPs and the EIP bandwidth plan belong to the same region.
 *     *   The line type of the EIPs is the same as that of the EIP bandwidth plan.
 * *   The **AddCommonBandwidthPackageIps** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeCommonBandwidthPackages](~~120309~~) operation to query the status of an EIP bandwidth plan:
 *     *   If the EIP bandwidth plan is in the **BINDING** state, the EIPs are being associated with the EIP bandwidth plan. In this state, you can only query the EIP bandwidth plan and cannot perform other operations.
 *     *   If the EIP bandwidth plan is in the **BINDED** state, the EIPs are associated with the EIP bandwidth plan.
 *
 * @param request AddCommonBandwidthPackageIpsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddCommonBandwidthPackageIpsResponse
 */
func (client *Client) AddCommonBandwidthPackageIpsWithOptions(request *AddCommonBandwidthPackageIpsRequest, runtime *util.RuntimeOptions) (_result *AddCommonBandwidthPackageIpsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BandwidthPackageId)) {
		query["BandwidthPackageId"] = request.BandwidthPackageId
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.IpInstanceIds)) {
		query["IpInstanceIds"] = request.IpInstanceIds
	}

	if !tea.BoolValue(util.IsUnset(request.IpType)) {
		query["IpType"] = request.IpType
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddCommonBandwidthPackageIps"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddCommonBandwidthPackageIpsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   When you call this operation to associate EIPs with an EIP bandwidth plan, make sure that the EIPs meet the following requirements:
 *     *   The EIPs use the pay-as-you-go billing method.
 *     *   The EIPs and the EIP bandwidth plan belong to the same region.
 *     *   The line type of the EIPs is the same as that of the EIP bandwidth plan.
 * *   The **AddCommonBandwidthPackageIps** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeCommonBandwidthPackages](~~120309~~) operation to query the status of an EIP bandwidth plan:
 *     *   If the EIP bandwidth plan is in the **BINDING** state, the EIPs are being associated with the EIP bandwidth plan. In this state, you can only query the EIP bandwidth plan and cannot perform other operations.
 *     *   If the EIP bandwidth plan is in the **BINDED** state, the EIPs are associated with the EIP bandwidth plan.
 *
 * @param request AddCommonBandwidthPackageIpsRequest
 * @return AddCommonBandwidthPackageIpsResponse
 */
func (client *Client) AddCommonBandwidthPackageIps(request *AddCommonBandwidthPackageIpsRequest) (_result *AddCommonBandwidthPackageIpsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddCommonBandwidthPackageIpsResponse{}
	_body, _err := client.AddCommonBandwidthPackageIpsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AddGlobalAccelerationInstanceIpWithOptions(request *AddGlobalAccelerationInstanceIpRequest, runtime *util.RuntimeOptions) (_result *AddGlobalAccelerationInstanceIpResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.GlobalAccelerationInstanceId)) {
		query["GlobalAccelerationInstanceId"] = request.GlobalAccelerationInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.IpInstanceId)) {
		query["IpInstanceId"] = request.IpInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddGlobalAccelerationInstanceIp"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddGlobalAccelerationInstanceIpResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AddGlobalAccelerationInstanceIp(request *AddGlobalAccelerationInstanceIpRequest) (_result *AddGlobalAccelerationInstanceIpResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddGlobalAccelerationInstanceIpResponse{}
	_body, _err := client.AddGlobalAccelerationInstanceIpWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * @deprecated
 *
 * @param request AddIPv6TranslatorAclListEntryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddIPv6TranslatorAclListEntryResponse
 */
// Deprecated
func (client *Client) AddIPv6TranslatorAclListEntryWithOptions(request *AddIPv6TranslatorAclListEntryRequest, runtime *util.RuntimeOptions) (_result *AddIPv6TranslatorAclListEntryResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AclEntryComment)) {
		query["AclEntryComment"] = request.AclEntryComment
	}

	if !tea.BoolValue(util.IsUnset(request.AclEntryIp)) {
		query["AclEntryIp"] = request.AclEntryIp
	}

	if !tea.BoolValue(util.IsUnset(request.AclId)) {
		query["AclId"] = request.AclId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddIPv6TranslatorAclListEntry"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddIPv6TranslatorAclListEntryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * @deprecated
 *
 * @param request AddIPv6TranslatorAclListEntryRequest
 * @return AddIPv6TranslatorAclListEntryResponse
 */
// Deprecated
func (client *Client) AddIPv6TranslatorAclListEntry(request *AddIPv6TranslatorAclListEntryRequest) (_result *AddIPv6TranslatorAclListEntryResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddIPv6TranslatorAclListEntryResponse{}
	_body, _err := client.AddIPv6TranslatorAclListEntryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Before you call this operation, take note of the following limits:
 * *   The CIDR block and the IP address pool must belong to the same region.
 * *   The CIDR block and the IP address pool must use the same line type.
 * *   The **AddPublicIpAddressPoolCidrBlock** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [ListPublicIpAddressPoolCidrBlocks](~~429436~~) operation to query the status of a CIDR block in an IP address pool:
 *     *   If the CIDR block is in the **Modifying** state, the CIDR block is being added. In this state, you can only query the CIDR block and cannot perform other operations.
 *     *   If the CIDR block is in the **Created** state, the CIDR block is added.
 * *   You cannot repeatedly call the **AddPublicIpAddressPoolCidrBlock** operation to add a CIDR block to an IP address pool within the specified period of time.
 *
 * @param request AddPublicIpAddressPoolCidrBlockRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddPublicIpAddressPoolCidrBlockResponse
 */
func (client *Client) AddPublicIpAddressPoolCidrBlockWithOptions(request *AddPublicIpAddressPoolCidrBlockRequest, runtime *util.RuntimeOptions) (_result *AddPublicIpAddressPoolCidrBlockResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CidrBlock)) {
		query["CidrBlock"] = request.CidrBlock
	}

	if !tea.BoolValue(util.IsUnset(request.CidrMask)) {
		query["CidrMask"] = request.CidrMask
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PublicIpAddressPoolId)) {
		query["PublicIpAddressPoolId"] = request.PublicIpAddressPoolId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddPublicIpAddressPoolCidrBlock"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddPublicIpAddressPoolCidrBlockResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Before you call this operation, take note of the following limits:
 * *   The CIDR block and the IP address pool must belong to the same region.
 * *   The CIDR block and the IP address pool must use the same line type.
 * *   The **AddPublicIpAddressPoolCidrBlock** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [ListPublicIpAddressPoolCidrBlocks](~~429436~~) operation to query the status of a CIDR block in an IP address pool:
 *     *   If the CIDR block is in the **Modifying** state, the CIDR block is being added. In this state, you can only query the CIDR block and cannot perform other operations.
 *     *   If the CIDR block is in the **Created** state, the CIDR block is added.
 * *   You cannot repeatedly call the **AddPublicIpAddressPoolCidrBlock** operation to add a CIDR block to an IP address pool within the specified period of time.
 *
 * @param request AddPublicIpAddressPoolCidrBlockRequest
 * @return AddPublicIpAddressPoolCidrBlockResponse
 */
func (client *Client) AddPublicIpAddressPoolCidrBlock(request *AddPublicIpAddressPoolCidrBlockRequest) (_result *AddPublicIpAddressPoolCidrBlockResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddPublicIpAddressPoolCidrBlockResponse{}
	_body, _err := client.AddPublicIpAddressPoolCidrBlockWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   The **AddSourcesToTrafficMirrorSession** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [ListTrafficMirrorSessions](~~261367~~) operation to query the status of a traffic mirror session:
 *     *   If the traffic mirror session is in the **Modifying** state, the traffic mirror source is being added to the traffic mirror session.
 *     *   If the traffic mirror session is in the **Created** state, the traffic mirror source is being added to the traffic mirror session.
 * *   You cannot repeatedly call the **AddSourcesToTrafficMirrorSession** operation to add a traffic mirror source to a traffic mirror session within the specified period of time.
 *
 * @param request AddSourcesToTrafficMirrorSessionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddSourcesToTrafficMirrorSessionResponse
 */
func (client *Client) AddSourcesToTrafficMirrorSessionWithOptions(request *AddSourcesToTrafficMirrorSessionRequest, runtime *util.RuntimeOptions) (_result *AddSourcesToTrafficMirrorSessionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.TrafficMirrorSessionId)) {
		query["TrafficMirrorSessionId"] = request.TrafficMirrorSessionId
	}

	if !tea.BoolValue(util.IsUnset(request.TrafficMirrorSourceIds)) {
		query["TrafficMirrorSourceIds"] = request.TrafficMirrorSourceIds
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddSourcesToTrafficMirrorSession"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddSourcesToTrafficMirrorSessionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   The **AddSourcesToTrafficMirrorSession** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [ListTrafficMirrorSessions](~~261367~~) operation to query the status of a traffic mirror session:
 *     *   If the traffic mirror session is in the **Modifying** state, the traffic mirror source is being added to the traffic mirror session.
 *     *   If the traffic mirror session is in the **Created** state, the traffic mirror source is being added to the traffic mirror session.
 * *   You cannot repeatedly call the **AddSourcesToTrafficMirrorSession** operation to add a traffic mirror source to a traffic mirror session within the specified period of time.
 *
 * @param request AddSourcesToTrafficMirrorSessionRequest
 * @return AddSourcesToTrafficMirrorSessionResponse
 */
func (client *Client) AddSourcesToTrafficMirrorSession(request *AddSourcesToTrafficMirrorSessionRequest) (_result *AddSourcesToTrafficMirrorSessionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddSourcesToTrafficMirrorSessionResponse{}
	_body, _err := client.AddSourcesToTrafficMirrorSessionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Before you call this operation, make sure that you understand the billing methods and pricing of EIPs. For more information, see [Billing overview](~~122035~~).
 * After you call this operation, the system randomly allocates an EIP that is in the **Available** state in the specified region. EIPs support only ICMP, TCP, and UDP at the transport layer. IGMP and SCTP are not supported.
 *
 * @param request AllocateEipAddressRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AllocateEipAddressResponse
 */
func (client *Client) AllocateEipAddressWithOptions(request *AllocateEipAddressRequest, runtime *util.RuntimeOptions) (_result *AllocateEipAddressResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ActivityId)) {
		query["ActivityId"] = request.ActivityId
	}

	if !tea.BoolValue(util.IsUnset(request.AutoPay)) {
		query["AutoPay"] = request.AutoPay
	}

	if !tea.BoolValue(util.IsUnset(request.Bandwidth)) {
		query["Bandwidth"] = request.Bandwidth
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.ISP)) {
		query["ISP"] = request.ISP
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceChargeType)) {
		query["InstanceChargeType"] = request.InstanceChargeType
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.InternetChargeType)) {
		query["InternetChargeType"] = request.InternetChargeType
	}

	if !tea.BoolValue(util.IsUnset(request.IpAddress)) {
		query["IpAddress"] = request.IpAddress
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.Netmode)) {
		query["Netmode"] = request.Netmode
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Period)) {
		query["Period"] = request.Period
	}

	if !tea.BoolValue(util.IsUnset(request.PricingCycle)) {
		query["PricingCycle"] = request.PricingCycle
	}

	if !tea.BoolValue(util.IsUnset(request.PublicIpAddressPoolId)) {
		query["PublicIpAddressPoolId"] = request.PublicIpAddressPoolId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityProtectionTypes)) {
		query["SecurityProtectionTypes"] = request.SecurityProtectionTypes
	}

	if !tea.BoolValue(util.IsUnset(request.Zone)) {
		query["Zone"] = request.Zone
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AllocateEipAddress"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AllocateEipAddressResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Before you call this operation, make sure that you understand the billing methods and pricing of EIPs. For more information, see [Billing overview](~~122035~~).
 * After you call this operation, the system randomly allocates an EIP that is in the **Available** state in the specified region. EIPs support only ICMP, TCP, and UDP at the transport layer. IGMP and SCTP are not supported.
 *
 * @param request AllocateEipAddressRequest
 * @return AllocateEipAddressResponse
 */
func (client *Client) AllocateEipAddress(request *AllocateEipAddressRequest) (_result *AllocateEipAddressResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AllocateEipAddressResponse{}
	_body, _err := client.AllocateEipAddressWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AllocateEipAddressProWithOptions(request *AllocateEipAddressProRequest, runtime *util.RuntimeOptions) (_result *AllocateEipAddressProResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AutoPay)) {
		query["AutoPay"] = request.AutoPay
	}

	if !tea.BoolValue(util.IsUnset(request.Bandwidth)) {
		query["Bandwidth"] = request.Bandwidth
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.ISP)) {
		query["ISP"] = request.ISP
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceChargeType)) {
		query["InstanceChargeType"] = request.InstanceChargeType
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.InternetChargeType)) {
		query["InternetChargeType"] = request.InternetChargeType
	}

	if !tea.BoolValue(util.IsUnset(request.IpAddress)) {
		query["IpAddress"] = request.IpAddress
	}

	if !tea.BoolValue(util.IsUnset(request.Netmode)) {
		query["Netmode"] = request.Netmode
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Period)) {
		query["Period"] = request.Period
	}

	if !tea.BoolValue(util.IsUnset(request.PricingCycle)) {
		query["PricingCycle"] = request.PricingCycle
	}

	if !tea.BoolValue(util.IsUnset(request.PublicIpAddressPoolId)) {
		query["PublicIpAddressPoolId"] = request.PublicIpAddressPoolId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityProtectionTypes)) {
		query["SecurityProtectionTypes"] = request.SecurityProtectionTypes
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AllocateEipAddressPro"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AllocateEipAddressProResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AllocateEipAddressPro(request *AllocateEipAddressProRequest) (_result *AllocateEipAddressProResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AllocateEipAddressProResponse{}
	_body, _err := client.AllocateEipAddressProWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * **AllocateEipSegmentAddress** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeEipSegment](/help/en/elastic-ip-address/latest/156063) operation to query the status of a contiguous EIP group:
 * - If the contiguous EIP group is in the **Allocating** state, the EIPs are being allocated. In this case, you can only perform the query operation and cannot perform other operations.
 * - If the contiguous EIP group is in the **Allocated** state, the EIPs are allocated.
 *
 * @param request AllocateEipSegmentAddressRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AllocateEipSegmentAddressResponse
 */
func (client *Client) AllocateEipSegmentAddressWithOptions(request *AllocateEipSegmentAddressRequest, runtime *util.RuntimeOptions) (_result *AllocateEipSegmentAddressResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Bandwidth)) {
		query["Bandwidth"] = request.Bandwidth
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.EipMask)) {
		query["EipMask"] = request.EipMask
	}

	if !tea.BoolValue(util.IsUnset(request.InternetChargeType)) {
		query["InternetChargeType"] = request.InternetChargeType
	}

	if !tea.BoolValue(util.IsUnset(request.Isp)) {
		query["Isp"] = request.Isp
	}

	if !tea.BoolValue(util.IsUnset(request.Netmode)) {
		query["Netmode"] = request.Netmode
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Zone)) {
		query["Zone"] = request.Zone
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AllocateEipSegmentAddress"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AllocateEipSegmentAddressResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * **AllocateEipSegmentAddress** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeEipSegment](/help/en/elastic-ip-address/latest/156063) operation to query the status of a contiguous EIP group:
 * - If the contiguous EIP group is in the **Allocating** state, the EIPs are being allocated. In this case, you can only perform the query operation and cannot perform other operations.
 * - If the contiguous EIP group is in the **Allocated** state, the EIPs are allocated.
 *
 * @param request AllocateEipSegmentAddressRequest
 * @return AllocateEipSegmentAddressResponse
 */
func (client *Client) AllocateEipSegmentAddress(request *AllocateEipSegmentAddressRequest) (_result *AllocateEipSegmentAddressResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AllocateEipSegmentAddressResponse{}
	_body, _err := client.AllocateEipSegmentAddressWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You cannot call the **AllocateIpv6InternetBandwidth** operation to purchase Internet bandwidth for an IPv6 gateway at the same time.
 *
 * @param request AllocateIpv6InternetBandwidthRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AllocateIpv6InternetBandwidthResponse
 */
func (client *Client) AllocateIpv6InternetBandwidthWithOptions(request *AllocateIpv6InternetBandwidthRequest, runtime *util.RuntimeOptions) (_result *AllocateIpv6InternetBandwidthResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Bandwidth)) {
		query["Bandwidth"] = request.Bandwidth
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.InternetChargeType)) {
		query["InternetChargeType"] = request.InternetChargeType
	}

	if !tea.BoolValue(util.IsUnset(request.Ipv6AddressId)) {
		query["Ipv6AddressId"] = request.Ipv6AddressId
	}

	if !tea.BoolValue(util.IsUnset(request.Ipv6GatewayId)) {
		query["Ipv6GatewayId"] = request.Ipv6GatewayId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AllocateIpv6InternetBandwidth"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AllocateIpv6InternetBandwidthResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You cannot call the **AllocateIpv6InternetBandwidth** operation to purchase Internet bandwidth for an IPv6 gateway at the same time.
 *
 * @param request AllocateIpv6InternetBandwidthRequest
 * @return AllocateIpv6InternetBandwidthResponse
 */
func (client *Client) AllocateIpv6InternetBandwidth(request *AllocateIpv6InternetBandwidthRequest) (_result *AllocateIpv6InternetBandwidthResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AllocateIpv6InternetBandwidthResponse{}
	_body, _err := client.AllocateIpv6InternetBandwidthWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The following section describes how to allocate an IPv6 CIDR block to a virtual private cloud (VPC):
 * 1\\. Call the AllocateVpcIpv6Cidr operation to reserve an IPv6 CIDR block.
 * 2\\. If you want to allocate the reserved IPv6 CIDR block to an existing VPC, call the [AssociateVpcCidrBlock](~~146745~~) operation, specify the **RegionId** and **VpcId** parameters, and set the **IPv6CidrBlock** parameter to the reserved IPv6 CIDR block and the **IpVersion** parameter to **IPV6**. If you want to allocate the reserved IPv6 CIDR block to a new VPC, call the [CreateVpc](~~35737~~) operation, specify the **RegionId** parameter, and set the **Ipv6CidrBlock** parameter to the reserved IPv6 CIDR block and the **EnableIpv6** parameter to **true**.
 *
 * @param request AllocateVpcIpv6CidrRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AllocateVpcIpv6CidrResponse
 */
func (client *Client) AllocateVpcIpv6CidrWithOptions(request *AllocateVpcIpv6CidrRequest, runtime *util.RuntimeOptions) (_result *AllocateVpcIpv6CidrResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AddressPoolType)) {
		query["AddressPoolType"] = request.AddressPoolType
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Ipv6CidrBlock)) {
		query["Ipv6CidrBlock"] = request.Ipv6CidrBlock
	}

	if !tea.BoolValue(util.IsUnset(request.Ipv6Isp)) {
		query["Ipv6Isp"] = request.Ipv6Isp
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AllocateVpcIpv6Cidr"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AllocateVpcIpv6CidrResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The following section describes how to allocate an IPv6 CIDR block to a virtual private cloud (VPC):
 * 1\\. Call the AllocateVpcIpv6Cidr operation to reserve an IPv6 CIDR block.
 * 2\\. If you want to allocate the reserved IPv6 CIDR block to an existing VPC, call the [AssociateVpcCidrBlock](~~146745~~) operation, specify the **RegionId** and **VpcId** parameters, and set the **IPv6CidrBlock** parameter to the reserved IPv6 CIDR block and the **IpVersion** parameter to **IPV6**. If you want to allocate the reserved IPv6 CIDR block to a new VPC, call the [CreateVpc](~~35737~~) operation, specify the **RegionId** parameter, and set the **Ipv6CidrBlock** parameter to the reserved IPv6 CIDR block and the **EnableIpv6** parameter to **true**.
 *
 * @param request AllocateVpcIpv6CidrRequest
 * @return AllocateVpcIpv6CidrResponse
 */
func (client *Client) AllocateVpcIpv6Cidr(request *AllocateVpcIpv6CidrRequest) (_result *AllocateVpcIpv6CidrResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AllocateVpcIpv6CidrResponse{}
	_body, _err := client.AllocateVpcIpv6CidrWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ApplyPhysicalConnectionLOAWithOptions(request *ApplyPhysicalConnectionLOARequest, runtime *util.RuntimeOptions) (_result *ApplyPhysicalConnectionLOAResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Bandwidth)) {
		query["Bandwidth"] = request.Bandwidth
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.CompanyName)) {
		query["CompanyName"] = request.CompanyName
	}

	if !tea.BoolValue(util.IsUnset(request.ConstructionTime)) {
		query["ConstructionTime"] = request.ConstructionTime
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.LineType)) {
		query["LineType"] = request.LineType
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PMInfo)) {
		query["PMInfo"] = request.PMInfo
	}

	if !tea.BoolValue(util.IsUnset(request.PeerLocation)) {
		query["PeerLocation"] = request.PeerLocation
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Si)) {
		query["Si"] = request.Si
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ApplyPhysicalConnectionLOA"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ApplyPhysicalConnectionLOAResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ApplyPhysicalConnectionLOA(request *ApplyPhysicalConnectionLOARequest) (_result *ApplyPhysicalConnectionLOAResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ApplyPhysicalConnectionLOAResponse{}
	_body, _err := client.ApplyPhysicalConnectionLOAWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   You can associate an EIP with an Elastic Compute Service (ECS) instance, a Classic Load Balancer (CLB) instance, a secondary elastic network interface (ENI), a NAT gateway, or a high-availability virtual IP address (HAVIP) in the same region. The ECS instance and CLB instance must be deployed in a virtual private cloud (VPC).
 * *   **AssociateEipAddress** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeEipAddresses](~~120193~~) operation to query the status of an EIP.
 *     *   If the EIP is in the **Associating** state, the EIP is being associated. In this state, you can only query the EIP and cannot perform other operations.
 *     *   If the EIP is in the **InUse** state, the EIP is associated.
 * *   You cannot repeatedly call **AssociateEipAddress** to associate an EIP with an instance within the specified period of time.
 *
 * @param request AssociateEipAddressRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AssociateEipAddressResponse
 */
func (client *Client) AssociateEipAddressWithOptions(request *AssociateEipAddressRequest, runtime *util.RuntimeOptions) (_result *AssociateEipAddressResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AllocationId)) {
		query["AllocationId"] = request.AllocationId
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceRegionId)) {
		query["InstanceRegionId"] = request.InstanceRegionId
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceType)) {
		query["InstanceType"] = request.InstanceType
	}

	if !tea.BoolValue(util.IsUnset(request.Mode)) {
		query["Mode"] = request.Mode
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PrivateIpAddress)) {
		query["PrivateIpAddress"] = request.PrivateIpAddress
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.VpcId)) {
		query["VpcId"] = request.VpcId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AssociateEipAddress"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AssociateEipAddressResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   You can associate an EIP with an Elastic Compute Service (ECS) instance, a Classic Load Balancer (CLB) instance, a secondary elastic network interface (ENI), a NAT gateway, or a high-availability virtual IP address (HAVIP) in the same region. The ECS instance and CLB instance must be deployed in a virtual private cloud (VPC).
 * *   **AssociateEipAddress** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeEipAddresses](~~120193~~) operation to query the status of an EIP.
 *     *   If the EIP is in the **Associating** state, the EIP is being associated. In this state, you can only query the EIP and cannot perform other operations.
 *     *   If the EIP is in the **InUse** state, the EIP is associated.
 * *   You cannot repeatedly call **AssociateEipAddress** to associate an EIP with an instance within the specified period of time.
 *
 * @param request AssociateEipAddressRequest
 * @return AssociateEipAddressResponse
 */
func (client *Client) AssociateEipAddress(request *AssociateEipAddressRequest) (_result *AssociateEipAddressResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AssociateEipAddressResponse{}
	_body, _err := client.AssociateEipAddressWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   You can call the **AssociateEipAddressBatch** operation to associate EIPs with a NAT gateway or a secondary elastic network interface (ENI) in the same region. For more information about how to associate EIPs with other instances, see [AssociateEipAddress](~~120195~~).
 * *   The **AssociateEipAddressBatch** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeEipAddresses](~~120193~~) operation to query the status of an EIP.
 *     *   If the EIP is in the **Associating** state, the EIP is being associated. In this state, you can only query the EIP and cannot perform other operations.
 *     *   If the EIP is in the **InUse** state, the EIP is associated.
 * *   You cannot repeatedly call **AssociateEipAddressBatch** to associate an EIP with an instance within the specified period of time.
 *
 * @param request AssociateEipAddressBatchRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AssociateEipAddressBatchResponse
 */
func (client *Client) AssociateEipAddressBatchWithOptions(request *AssociateEipAddressBatchRequest, runtime *util.RuntimeOptions) (_result *AssociateEipAddressBatchResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BindedInstanceId)) {
		query["BindedInstanceId"] = request.BindedInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.BindedInstanceType)) {
		query["BindedInstanceType"] = request.BindedInstanceType
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceIds)) {
		query["InstanceIds"] = request.InstanceIds
	}

	if !tea.BoolValue(util.IsUnset(request.Mode)) {
		query["Mode"] = request.Mode
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AssociateEipAddressBatch"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AssociateEipAddressBatchResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   You can call the **AssociateEipAddressBatch** operation to associate EIPs with a NAT gateway or a secondary elastic network interface (ENI) in the same region. For more information about how to associate EIPs with other instances, see [AssociateEipAddress](~~120195~~).
 * *   The **AssociateEipAddressBatch** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeEipAddresses](~~120193~~) operation to query the status of an EIP.
 *     *   If the EIP is in the **Associating** state, the EIP is being associated. In this state, you can only query the EIP and cannot perform other operations.
 *     *   If the EIP is in the **InUse** state, the EIP is associated.
 * *   You cannot repeatedly call **AssociateEipAddressBatch** to associate an EIP with an instance within the specified period of time.
 *
 * @param request AssociateEipAddressBatchRequest
 * @return AssociateEipAddressBatchResponse
 */
func (client *Client) AssociateEipAddressBatch(request *AssociateEipAddressBatchRequest) (_result *AssociateEipAddressBatchResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AssociateEipAddressBatchResponse{}
	_body, _err := client.AssociateEipAddressBatchWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Usage notes
 * When you call this operation, take note of the following items:
 * *   You can specify only an Elastic Compute Service (ECS) instance in a virtual private cloud (VPC) or a Server Load Balancer (SLB) instance as a backend server.
 * *   You can associate each GA instance with only one backend server.
 * *   You can associate multiple GA instances with the same backend server.
 * *   The backend server and the GA instance must belong to the same Alibaba Cloud account.
 * *   The region of the backend server must belong to the service area of the GA instance.
 * *   You can call this operation to associate only a dedicated-bandwidth GA instance with a backend server.
 * To associate a shared-bandwidth GA instance with a backend server, perform the following operations:
 * 1.  Associate an elastic IP address (EIP) with the shared-bandwidth GA instance: For more information, see [AddGlobalAccelerationInstanceIp](~~86045~~).
 * 2.  Associate the EIP with a backend server. For more information, see [AssociateEipAddress](~~120195~~). When you call AssociateEipAddress, specify **InstanceRegionId**.
 *
 * @param request AssociateGlobalAccelerationInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AssociateGlobalAccelerationInstanceResponse
 */
func (client *Client) AssociateGlobalAccelerationInstanceWithOptions(request *AssociateGlobalAccelerationInstanceRequest, runtime *util.RuntimeOptions) (_result *AssociateGlobalAccelerationInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BackendServerId)) {
		query["BackendServerId"] = request.BackendServerId
	}

	if !tea.BoolValue(util.IsUnset(request.BackendServerRegionId)) {
		query["BackendServerRegionId"] = request.BackendServerRegionId
	}

	if !tea.BoolValue(util.IsUnset(request.BackendServerType)) {
		query["BackendServerType"] = request.BackendServerType
	}

	if !tea.BoolValue(util.IsUnset(request.GlobalAccelerationInstanceId)) {
		query["GlobalAccelerationInstanceId"] = request.GlobalAccelerationInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AssociateGlobalAccelerationInstance"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AssociateGlobalAccelerationInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Usage notes
 * When you call this operation, take note of the following items:
 * *   You can specify only an Elastic Compute Service (ECS) instance in a virtual private cloud (VPC) or a Server Load Balancer (SLB) instance as a backend server.
 * *   You can associate each GA instance with only one backend server.
 * *   You can associate multiple GA instances with the same backend server.
 * *   The backend server and the GA instance must belong to the same Alibaba Cloud account.
 * *   The region of the backend server must belong to the service area of the GA instance.
 * *   You can call this operation to associate only a dedicated-bandwidth GA instance with a backend server.
 * To associate a shared-bandwidth GA instance with a backend server, perform the following operations:
 * 1.  Associate an elastic IP address (EIP) with the shared-bandwidth GA instance: For more information, see [AddGlobalAccelerationInstanceIp](~~86045~~).
 * 2.  Associate the EIP with a backend server. For more information, see [AssociateEipAddress](~~120195~~). When you call AssociateEipAddress, specify **InstanceRegionId**.
 *
 * @param request AssociateGlobalAccelerationInstanceRequest
 * @return AssociateGlobalAccelerationInstanceResponse
 */
func (client *Client) AssociateGlobalAccelerationInstance(request *AssociateGlobalAccelerationInstanceRequest) (_result *AssociateGlobalAccelerationInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AssociateGlobalAccelerationInstanceResponse{}
	_body, _err := client.AssociateGlobalAccelerationInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * When you call this operation, take note of the following limits:
 * *   An HAVIP immediately takes effect after it is associated. You do not need to restart the ECS instance. However, you must associate the HAVIP with the ENI of the ECS instance.
 * *   The HAVIP and ECS instance must belong to the same vSwitch.
 * *   You can associate an HAVIP with at most two ECS instances.
 * *   The ECS instance must be in the **Running** or **Stopped** state.
 * *   The HAVIP must be in the **Available** or **InUse** state.
 * *   The **AssociateHaVip** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeHaVips](~~114611~~) operation to query the status of an HAVIP:
 *     *   If the HAVIP is in the **Associating** state, the HAVIP is being associated.
 *     *   If the HAVIP is in the **InUse** state, the HAVIP is associated.
 * *   You cannot repeatedly call the **AssociateHaVip** operation to associate an HAVIP within the specified period of time.
 *
 * @param request AssociateHaVipRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AssociateHaVipResponse
 */
func (client *Client) AssociateHaVipWithOptions(request *AssociateHaVipRequest, runtime *util.RuntimeOptions) (_result *AssociateHaVipResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.HaVipId)) {
		query["HaVipId"] = request.HaVipId
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceType)) {
		query["InstanceType"] = request.InstanceType
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AssociateHaVip"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AssociateHaVipResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * When you call this operation, take note of the following limits:
 * *   An HAVIP immediately takes effect after it is associated. You do not need to restart the ECS instance. However, you must associate the HAVIP with the ENI of the ECS instance.
 * *   The HAVIP and ECS instance must belong to the same vSwitch.
 * *   You can associate an HAVIP with at most two ECS instances.
 * *   The ECS instance must be in the **Running** or **Stopped** state.
 * *   The HAVIP must be in the **Available** or **InUse** state.
 * *   The **AssociateHaVip** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeHaVips](~~114611~~) operation to query the status of an HAVIP:
 *     *   If the HAVIP is in the **Associating** state, the HAVIP is being associated.
 *     *   If the HAVIP is in the **InUse** state, the HAVIP is associated.
 * *   You cannot repeatedly call the **AssociateHaVip** operation to associate an HAVIP within the specified period of time.
 *
 * @param request AssociateHaVipRequest
 * @return AssociateHaVipResponse
 */
func (client *Client) AssociateHaVip(request *AssociateHaVipRequest) (_result *AssociateHaVipResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AssociateHaVipResponse{}
	_body, _err := client.AssociateHaVipWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   The **AssociateNetworkAcl** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeNetworkAclAttributes](~~116542~~) operation to query the status of a network ACL:
 *     *   If the network ACL is in the **BINDING** state, the network ACL is being associated.
 *     *   If the network ACL is in the **BINDED** state, the network ACL is associated.
 * *   You cannot repeatedly call the **AssociateNetworkAcl** operation to associate a network ACL within the specified period of time.
 *
 * @param request AssociateNetworkAclRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AssociateNetworkAclResponse
 */
func (client *Client) AssociateNetworkAclWithOptions(request *AssociateNetworkAclRequest, runtime *util.RuntimeOptions) (_result *AssociateNetworkAclResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.NetworkAclId)) {
		query["NetworkAclId"] = request.NetworkAclId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.Resource)) {
		query["Resource"] = request.Resource
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AssociateNetworkAcl"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AssociateNetworkAclResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   The **AssociateNetworkAcl** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeNetworkAclAttributes](~~116542~~) operation to query the status of a network ACL:
 *     *   If the network ACL is in the **BINDING** state, the network ACL is being associated.
 *     *   If the network ACL is in the **BINDED** state, the network ACL is associated.
 * *   You cannot repeatedly call the **AssociateNetworkAcl** operation to associate a network ACL within the specified period of time.
 *
 * @param request AssociateNetworkAclRequest
 * @return AssociateNetworkAclResponse
 */
func (client *Client) AssociateNetworkAcl(request *AssociateNetworkAclRequest) (_result *AssociateNetworkAclResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AssociateNetworkAclResponse{}
	_body, _err := client.AssociateNetworkAclWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AssociatePhysicalConnectionToVirtualBorderRouterWithOptions(request *AssociatePhysicalConnectionToVirtualBorderRouterRequest, runtime *util.RuntimeOptions) (_result *AssociatePhysicalConnectionToVirtualBorderRouterResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CircuitCode)) {
		query["CircuitCode"] = request.CircuitCode
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.EnableIpv6)) {
		query["EnableIpv6"] = request.EnableIpv6
	}

	if !tea.BoolValue(util.IsUnset(request.LocalGatewayIp)) {
		query["LocalGatewayIp"] = request.LocalGatewayIp
	}

	if !tea.BoolValue(util.IsUnset(request.LocalIpv6GatewayIp)) {
		query["LocalIpv6GatewayIp"] = request.LocalIpv6GatewayIp
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PeerGatewayIp)) {
		query["PeerGatewayIp"] = request.PeerGatewayIp
	}

	if !tea.BoolValue(util.IsUnset(request.PeerIpv6GatewayIp)) {
		query["PeerIpv6GatewayIp"] = request.PeerIpv6GatewayIp
	}

	if !tea.BoolValue(util.IsUnset(request.PeeringIpv6SubnetMask)) {
		query["PeeringIpv6SubnetMask"] = request.PeeringIpv6SubnetMask
	}

	if !tea.BoolValue(util.IsUnset(request.PeeringSubnetMask)) {
		query["PeeringSubnetMask"] = request.PeeringSubnetMask
	}

	if !tea.BoolValue(util.IsUnset(request.PhysicalConnectionId)) {
		query["PhysicalConnectionId"] = request.PhysicalConnectionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.VbrId)) {
		query["VbrId"] = request.VbrId
	}

	if !tea.BoolValue(util.IsUnset(request.VlanId)) {
		query["VlanId"] = request.VlanId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AssociatePhysicalConnectionToVirtualBorderRouter"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AssociatePhysicalConnectionToVirtualBorderRouterResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AssociatePhysicalConnectionToVirtualBorderRouter(request *AssociatePhysicalConnectionToVirtualBorderRouterRequest) (_result *AssociatePhysicalConnectionToVirtualBorderRouterResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AssociatePhysicalConnectionToVirtualBorderRouterResponse{}
	_body, _err := client.AssociatePhysicalConnectionToVirtualBorderRouterWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The **AssociateRouteTable** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeVSwitchAttributes](~~94567~~) operation to query the status of a vSwitch:
 * *   If the vSwitch is in the **Pending** state, the route table is being associated with the vSwitch.
 * *   If the vSwitch is in the **Available** state, the route table is associated with the vSwitch.
 *
 * @param request AssociateRouteTableRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AssociateRouteTableResponse
 */
func (client *Client) AssociateRouteTableWithOptions(request *AssociateRouteTableRequest, runtime *util.RuntimeOptions) (_result *AssociateRouteTableResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RouteTableId)) {
		query["RouteTableId"] = request.RouteTableId
	}

	if !tea.BoolValue(util.IsUnset(request.VSwitchId)) {
		query["VSwitchId"] = request.VSwitchId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AssociateRouteTable"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AssociateRouteTableResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The **AssociateRouteTable** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeVSwitchAttributes](~~94567~~) operation to query the status of a vSwitch:
 * *   If the vSwitch is in the **Pending** state, the route table is being associated with the vSwitch.
 * *   If the vSwitch is in the **Available** state, the route table is associated with the vSwitch.
 *
 * @param request AssociateRouteTableRequest
 * @return AssociateRouteTableResponse
 */
func (client *Client) AssociateRouteTable(request *AssociateRouteTableRequest) (_result *AssociateRouteTableResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AssociateRouteTableResponse{}
	_body, _err := client.AssociateRouteTableWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AssociateRouteTableWithGatewayWithOptions(request *AssociateRouteTableWithGatewayRequest, runtime *util.RuntimeOptions) (_result *AssociateRouteTableWithGatewayResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayId)) {
		query["GatewayId"] = request.GatewayId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RouteTableId)) {
		query["RouteTableId"] = request.RouteTableId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AssociateRouteTableWithGateway"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AssociateRouteTableWithGatewayResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AssociateRouteTableWithGateway(request *AssociateRouteTableWithGatewayRequest) (_result *AssociateRouteTableWithGatewayResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AssociateRouteTableWithGatewayResponse{}
	_body, _err := client.AssociateRouteTableWithGatewayWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * When you call this operation, take note of the following limits:
 * *   The gateway endpoint to be associated with the route table cannot be in one of the following states: **Creating**, **Modifying**, **Associating**, **Dissociating**, or **Deleting**.
 * *   The route table cannot be in one of the following states: **Creating**, **Modifying**, **Associating**, **Dissociating**, or **Deleting**.
 * *   The gateway endpoint and route table must belong to the same virtual private cloud (VPC).
 * *   The route table cannot be shared.
 * *   You cannot associate a gateway endpoint with a virtual border router (VBR) route table.
 * *   You can associate a gateway endpoint with at most 20 route tables at a time.
 * *   **AssociateRouteTablesWithVpcGatewayEndpoint** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [GetVpcGatewayEndpointAttribute](~~311017~~) operation to query whether a route table is associated with a gateway endpoint.
 *     *   If the **Associating** status is returned, the route table is being associated with the gateway endpoint.
 *     *   If the **Created** status is returned, the route table is associated with the gateway endpoint.
 * *   You cannot repeatedly call the **AssociateRouteTablesWithVpcGatewayEndpoint** operation within a specific period of time.
 *
 * @param request AssociateRouteTablesWithVpcGatewayEndpointRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AssociateRouteTablesWithVpcGatewayEndpointResponse
 */
func (client *Client) AssociateRouteTablesWithVpcGatewayEndpointWithOptions(request *AssociateRouteTablesWithVpcGatewayEndpointRequest, runtime *util.RuntimeOptions) (_result *AssociateRouteTablesWithVpcGatewayEndpointResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.EndpointId)) {
		query["EndpointId"] = request.EndpointId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RouteTableIds)) {
		query["RouteTableIds"] = request.RouteTableIds
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AssociateRouteTablesWithVpcGatewayEndpoint"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AssociateRouteTablesWithVpcGatewayEndpointResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * When you call this operation, take note of the following limits:
 * *   The gateway endpoint to be associated with the route table cannot be in one of the following states: **Creating**, **Modifying**, **Associating**, **Dissociating**, or **Deleting**.
 * *   The route table cannot be in one of the following states: **Creating**, **Modifying**, **Associating**, **Dissociating**, or **Deleting**.
 * *   The gateway endpoint and route table must belong to the same virtual private cloud (VPC).
 * *   The route table cannot be shared.
 * *   You cannot associate a gateway endpoint with a virtual border router (VBR) route table.
 * *   You can associate a gateway endpoint with at most 20 route tables at a time.
 * *   **AssociateRouteTablesWithVpcGatewayEndpoint** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [GetVpcGatewayEndpointAttribute](~~311017~~) operation to query whether a route table is associated with a gateway endpoint.
 *     *   If the **Associating** status is returned, the route table is being associated with the gateway endpoint.
 *     *   If the **Created** status is returned, the route table is associated with the gateway endpoint.
 * *   You cannot repeatedly call the **AssociateRouteTablesWithVpcGatewayEndpoint** operation within a specific period of time.
 *
 * @param request AssociateRouteTablesWithVpcGatewayEndpointRequest
 * @return AssociateRouteTablesWithVpcGatewayEndpointResponse
 */
func (client *Client) AssociateRouteTablesWithVpcGatewayEndpoint(request *AssociateRouteTablesWithVpcGatewayEndpointRequest) (_result *AssociateRouteTablesWithVpcGatewayEndpointResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AssociateRouteTablesWithVpcGatewayEndpointResponse{}
	_body, _err := client.AssociateRouteTablesWithVpcGatewayEndpointWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   The following list describes the limits on the maximum number of secondary CIDR blocks that can be added:
 *     *   You can add up to five secondary IPv4 CIDR blocks to each VPC.
 *     *   You can add up to three secondary IPv6 CIDR blocks to each VPC.
 * *   You cannot repeatedly call the **AssociateVpcCidrBlock** operation to add secondary CIDR blocks to a VPC within the specified period of time.
 *
 * @param request AssociateVpcCidrBlockRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AssociateVpcCidrBlockResponse
 */
func (client *Client) AssociateVpcCidrBlockWithOptions(request *AssociateVpcCidrBlockRequest, runtime *util.RuntimeOptions) (_result *AssociateVpcCidrBlockResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IPv6CidrBlock)) {
		query["IPv6CidrBlock"] = request.IPv6CidrBlock
	}

	if !tea.BoolValue(util.IsUnset(request.IpVersion)) {
		query["IpVersion"] = request.IpVersion
	}

	if !tea.BoolValue(util.IsUnset(request.IpamPoolId)) {
		query["IpamPoolId"] = request.IpamPoolId
	}

	if !tea.BoolValue(util.IsUnset(request.Ipv6Isp)) {
		query["Ipv6Isp"] = request.Ipv6Isp
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecondaryCidrBlock)) {
		query["SecondaryCidrBlock"] = request.SecondaryCidrBlock
	}

	if !tea.BoolValue(util.IsUnset(request.VpcId)) {
		query["VpcId"] = request.VpcId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AssociateVpcCidrBlock"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AssociateVpcCidrBlockResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   The following list describes the limits on the maximum number of secondary CIDR blocks that can be added:
 *     *   You can add up to five secondary IPv4 CIDR blocks to each VPC.
 *     *   You can add up to three secondary IPv6 CIDR blocks to each VPC.
 * *   You cannot repeatedly call the **AssociateVpcCidrBlock** operation to add secondary CIDR blocks to a VPC within the specified period of time.
 *
 * @param request AssociateVpcCidrBlockRequest
 * @return AssociateVpcCidrBlockResponse
 */
func (client *Client) AssociateVpcCidrBlock(request *AssociateVpcCidrBlockRequest) (_result *AssociateVpcCidrBlockResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AssociateVpcCidrBlockResponse{}
	_body, _err := client.AssociateVpcCidrBlockWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Usage notes
 * Before you associate a VPN gateway with an SSL certificate, take note of the following items:
 * *   You can associate only VPN gateways of the ShangMi (SM) type with SSL certificates. You need to associate a VPN gateway of the SM type with two SSL certificates, one as the encryption certificate and the other as the signature certificate.
 * *   The SSL certificates must use the SM algorithm.
 * *   You cannot specify one SSL certificate as both the encryption certificate and signature certificate for one VPN gateway.
 * *   The first time you associate a VPN gateway of the SM type with an SSL certificate, the system automatically creates the AliyunServiceRoleForVPNCertificate service-linked role. In addition, the system adds the AliyunServiceRolePolicyForVPNCertificate policy to the role, which allows the VPN gateway to access other cloud resources. For more information, see [AliyunServiceRoleForVPNCertificate](~~203323~~).
 * *   **AssociateVpnGatewayWithCertificate** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](~~73720~~) operation to query the status of the task.
 *     *   If the VPN gateway is in the **updating** state, the SSL certificate is being associated.
 *     *   If the VPN gateway is in the **active** state, the SSL certificate is being associated.
 * *   You cannot call **AssociateVpnGatewayWithCertificate** within a specific period of time.
 * ## Prerequisites
 * Make sure that you have two SSL certificates that use the SM algorithm in the Certificate Management Service console. For more information about SSL certificates, see [What is Certificate Management Service?](~~28535~~).
 *
 * @param request AssociateVpnGatewayWithCertificateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AssociateVpnGatewayWithCertificateResponse
 */
func (client *Client) AssociateVpnGatewayWithCertificateWithOptions(request *AssociateVpnGatewayWithCertificateRequest, runtime *util.RuntimeOptions) (_result *AssociateVpnGatewayWithCertificateResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CertificateId)) {
		query["CertificateId"] = request.CertificateId
	}

	if !tea.BoolValue(util.IsUnset(request.CertificateType)) {
		query["CertificateType"] = request.CertificateType
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.VpnGatewayId)) {
		query["VpnGatewayId"] = request.VpnGatewayId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AssociateVpnGatewayWithCertificate"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AssociateVpnGatewayWithCertificateResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Usage notes
 * Before you associate a VPN gateway with an SSL certificate, take note of the following items:
 * *   You can associate only VPN gateways of the ShangMi (SM) type with SSL certificates. You need to associate a VPN gateway of the SM type with two SSL certificates, one as the encryption certificate and the other as the signature certificate.
 * *   The SSL certificates must use the SM algorithm.
 * *   You cannot specify one SSL certificate as both the encryption certificate and signature certificate for one VPN gateway.
 * *   The first time you associate a VPN gateway of the SM type with an SSL certificate, the system automatically creates the AliyunServiceRoleForVPNCertificate service-linked role. In addition, the system adds the AliyunServiceRolePolicyForVPNCertificate policy to the role, which allows the VPN gateway to access other cloud resources. For more information, see [AliyunServiceRoleForVPNCertificate](~~203323~~).
 * *   **AssociateVpnGatewayWithCertificate** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](~~73720~~) operation to query the status of the task.
 *     *   If the VPN gateway is in the **updating** state, the SSL certificate is being associated.
 *     *   If the VPN gateway is in the **active** state, the SSL certificate is being associated.
 * *   You cannot call **AssociateVpnGatewayWithCertificate** within a specific period of time.
 * ## Prerequisites
 * Make sure that you have two SSL certificates that use the SM algorithm in the Certificate Management Service console. For more information about SSL certificates, see [What is Certificate Management Service?](~~28535~~).
 *
 * @param request AssociateVpnGatewayWithCertificateRequest
 * @return AssociateVpnGatewayWithCertificateResponse
 */
func (client *Client) AssociateVpnGatewayWithCertificate(request *AssociateVpnGatewayWithCertificateRequest) (_result *AssociateVpnGatewayWithCertificateResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AssociateVpnGatewayWithCertificateResponse{}
	_body, _err := client.AssociateVpnGatewayWithCertificateWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   The **AttachDhcpOptionsSetToVpc** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeVpcAttribute](~~94565~~) operation to query the status of a DHCP options set:
 *     *   If the DHCP options set is in the **Pending** state, the DHCP options set is being associated.
 *     *   If the DHCP options set is in the **InUse** state, the DHCP options set is associated.
 * *   You cannot repeatedly call the **AttachDhcpOptionsSetToVpc** operation to associate DHCP options sets with a VPC within the specified period of time.
 *
 * @param request AttachDhcpOptionsSetToVpcRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AttachDhcpOptionsSetToVpcResponse
 */
func (client *Client) AttachDhcpOptionsSetToVpcWithOptions(request *AttachDhcpOptionsSetToVpcRequest, runtime *util.RuntimeOptions) (_result *AttachDhcpOptionsSetToVpcResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DhcpOptionsSetId)) {
		query["DhcpOptionsSetId"] = request.DhcpOptionsSetId
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.VpcId)) {
		query["VpcId"] = request.VpcId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AttachDhcpOptionsSetToVpc"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AttachDhcpOptionsSetToVpcResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   The **AttachDhcpOptionsSetToVpc** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeVpcAttribute](~~94565~~) operation to query the status of a DHCP options set:
 *     *   If the DHCP options set is in the **Pending** state, the DHCP options set is being associated.
 *     *   If the DHCP options set is in the **InUse** state, the DHCP options set is associated.
 * *   You cannot repeatedly call the **AttachDhcpOptionsSetToVpc** operation to associate DHCP options sets with a VPC within the specified period of time.
 *
 * @param request AttachDhcpOptionsSetToVpcRequest
 * @return AttachDhcpOptionsSetToVpcResponse
 */
func (client *Client) AttachDhcpOptionsSetToVpc(request *AttachDhcpOptionsSetToVpcRequest) (_result *AttachDhcpOptionsSetToVpcResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AttachDhcpOptionsSetToVpcResponse{}
	_body, _err := client.AttachDhcpOptionsSetToVpcWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AttachVbrToVpconnWithOptions(request *AttachVbrToVpconnRequest, runtime *util.RuntimeOptions) (_result *AttachVbrToVpconnResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.Token)) {
		query["Token"] = request.Token
	}

	if !tea.BoolValue(util.IsUnset(request.VbrId)) {
		query["VbrId"] = request.VbrId
	}

	if !tea.BoolValue(util.IsUnset(request.VpconnId)) {
		query["VpconnId"] = request.VpconnId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AttachVbrToVpconn"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AttachVbrToVpconnResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AttachVbrToVpconn(request *AttachVbrToVpconnRequest) (_result *AttachVbrToVpconnResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AttachVbrToVpconnResponse{}
	_body, _err := client.AttachVbrToVpconnWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   After this operation is performed, the maximum bandwidth of the EIP equals that of the EIP bandwidth plan.
 * *   You cannot repeatedly call the **CancelCommonBandwidthPackageIpBandwidth** operation to remove the maximum bandwidth configured for an EIP within the specified period of time.
 *
 * @param request CancelCommonBandwidthPackageIpBandwidthRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CancelCommonBandwidthPackageIpBandwidthResponse
 */
func (client *Client) CancelCommonBandwidthPackageIpBandwidthWithOptions(request *CancelCommonBandwidthPackageIpBandwidthRequest, runtime *util.RuntimeOptions) (_result *CancelCommonBandwidthPackageIpBandwidthResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BandwidthPackageId)) {
		query["BandwidthPackageId"] = request.BandwidthPackageId
	}

	if !tea.BoolValue(util.IsUnset(request.EipId)) {
		query["EipId"] = request.EipId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CancelCommonBandwidthPackageIpBandwidth"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CancelCommonBandwidthPackageIpBandwidthResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   After this operation is performed, the maximum bandwidth of the EIP equals that of the EIP bandwidth plan.
 * *   You cannot repeatedly call the **CancelCommonBandwidthPackageIpBandwidth** operation to remove the maximum bandwidth configured for an EIP within the specified period of time.
 *
 * @param request CancelCommonBandwidthPackageIpBandwidthRequest
 * @return CancelCommonBandwidthPackageIpBandwidthResponse
 */
func (client *Client) CancelCommonBandwidthPackageIpBandwidth(request *CancelCommonBandwidthPackageIpBandwidthRequest) (_result *CancelCommonBandwidthPackageIpBandwidthResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CancelCommonBandwidthPackageIpBandwidthResponse{}
	_body, _err := client.CancelCommonBandwidthPackageIpBandwidthWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * You can cancel only an Express Connect circuit that is in the **Initial**, **Approved**, **Allocated**, or **Confirmed** state.
 *
 * @param request CancelPhysicalConnectionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CancelPhysicalConnectionResponse
 */
func (client *Client) CancelPhysicalConnectionWithOptions(request *CancelPhysicalConnectionRequest, runtime *util.RuntimeOptions) (_result *CancelPhysicalConnectionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PhysicalConnectionId)) {
		query["PhysicalConnectionId"] = request.PhysicalConnectionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CancelPhysicalConnection"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CancelPhysicalConnectionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * You can cancel only an Express Connect circuit that is in the **Initial**, **Approved**, **Allocated**, or **Confirmed** state.
 *
 * @param request CancelPhysicalConnectionRequest
 * @return CancelPhysicalConnectionResponse
 */
func (client *Client) CancelPhysicalConnection(request *CancelPhysicalConnectionRequest) (_result *CancelPhysicalConnectionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CancelPhysicalConnectionResponse{}
	_body, _err := client.CancelPhysicalConnectionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You cannot repeatedly call the **ChangeResourceGroup** operation within the specified period of time.
 *
 * @param request ChangeResourceGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ChangeResourceGroupResponse
 */
func (client *Client) ChangeResourceGroupWithOptions(request *ChangeResourceGroupRequest, runtime *util.RuntimeOptions) (_result *ChangeResourceGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.NewResourceGroupId)) {
		query["NewResourceGroupId"] = request.NewResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceId)) {
		query["ResourceId"] = request.ResourceId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ChangeResourceGroup"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ChangeResourceGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You cannot repeatedly call the **ChangeResourceGroup** operation within the specified period of time.
 *
 * @param request ChangeResourceGroupRequest
 * @return ChangeResourceGroupResponse
 */
func (client *Client) ChangeResourceGroup(request *ChangeResourceGroupRequest) (_result *ChangeResourceGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ChangeResourceGroupResponse{}
	_body, _err := client.ChangeResourceGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CheckCanAllocateVpcPrivateIpAddressWithOptions(request *CheckCanAllocateVpcPrivateIpAddressRequest, runtime *util.RuntimeOptions) (_result *CheckCanAllocateVpcPrivateIpAddressResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IpVersion)) {
		query["IpVersion"] = request.IpVersion
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PrivateIpAddress)) {
		query["PrivateIpAddress"] = request.PrivateIpAddress
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.VSwitchId)) {
		query["VSwitchId"] = request.VSwitchId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CheckCanAllocateVpcPrivateIpAddress"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CheckCanAllocateVpcPrivateIpAddressResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CheckCanAllocateVpcPrivateIpAddress(request *CheckCanAllocateVpcPrivateIpAddressRequest) (_result *CheckCanAllocateVpcPrivateIpAddressResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CheckCanAllocateVpcPrivateIpAddressResponse{}
	_body, _err := client.CheckCanAllocateVpcPrivateIpAddressWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CheckVpnBgpEnabledWithOptions(request *CheckVpnBgpEnabledRequest, runtime *util.RuntimeOptions) (_result *CheckVpnBgpEnabledResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CheckVpnBgpEnabled"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CheckVpnBgpEnabledResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CheckVpnBgpEnabled(request *CheckVpnBgpEnabledRequest) (_result *CheckVpnBgpEnabledResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CheckVpnBgpEnabledResponse{}
	_body, _err := client.CheckVpnBgpEnabledWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CompletePhysicalConnectionLOAWithOptions(request *CompletePhysicalConnectionLOARequest, runtime *util.RuntimeOptions) (_result *CompletePhysicalConnectionLOAResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.LineCode)) {
		query["LineCode"] = request.LineCode
	}

	if !tea.BoolValue(util.IsUnset(request.LineLabel)) {
		query["LineLabel"] = request.LineLabel
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CompletePhysicalConnectionLOA"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CompletePhysicalConnectionLOAResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CompletePhysicalConnectionLOA(request *CompletePhysicalConnectionLOARequest) (_result *CompletePhysicalConnectionLOAResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CompletePhysicalConnectionLOAResponse{}
	_body, _err := client.CompletePhysicalConnectionLOAWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ConfirmPhysicalConnectionWithOptions(request *ConfirmPhysicalConnectionRequest, runtime *util.RuntimeOptions) (_result *ConfirmPhysicalConnectionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PhysicalConnectionId)) {
		query["PhysicalConnectionId"] = request.PhysicalConnectionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ConfirmPhysicalConnection"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ConfirmPhysicalConnectionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ConfirmPhysicalConnection(request *ConfirmPhysicalConnectionRequest) (_result *ConfirmPhysicalConnectionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ConfirmPhysicalConnectionResponse{}
	_body, _err := client.ConfirmPhysicalConnectionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * After you call this operation, the router interface enters the **Connecting** state. When the connection is established, it enters the **Active** state.
 * When you call this operation, take note of the following rules:
 * *   Only an initiator router interface in the **Idle** state can initiate a connection.
 * *   You can create only one pair of connected router interfaces between two routers.
 * *   You cannot initiate a connection if your Alibaba Cloud account has a router interface with overdue payments.
 *
 * @param request ConnectRouterInterfaceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ConnectRouterInterfaceResponse
 */
func (client *Client) ConnectRouterInterfaceWithOptions(request *ConnectRouterInterfaceRequest, runtime *util.RuntimeOptions) (_result *ConnectRouterInterfaceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RouterInterfaceId)) {
		query["RouterInterfaceId"] = request.RouterInterfaceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ConnectRouterInterface"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ConnectRouterInterfaceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * After you call this operation, the router interface enters the **Connecting** state. When the connection is established, it enters the **Active** state.
 * When you call this operation, take note of the following rules:
 * *   Only an initiator router interface in the **Idle** state can initiate a connection.
 * *   You can create only one pair of connected router interfaces between two routers.
 * *   You cannot initiate a connection if your Alibaba Cloud account has a router interface with overdue payments.
 *
 * @param request ConnectRouterInterfaceRequest
 * @return ConnectRouterInterfaceResponse
 */
func (client *Client) ConnectRouterInterface(request *ConnectRouterInterfaceRequest) (_result *ConnectRouterInterfaceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ConnectRouterInterfaceResponse{}
	_body, _err := client.ConnectRouterInterfaceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Before you convert a NAT bandwidth package to an Internet Shared Bandwidth instance, make sure you are aware of the following:
 * *   The conversion does not incur any additional fees.
 * *   The conversion does not affect the SNAT or DNAT entries of the NAT Gateway, and has no impact on the running services. However, we recommend that you perform the conversion during off-peak hours.
 * *   After the conversion, the public IP address in the NAT bandwidth package is converted to an EIP. The peak bandwidth and billing method of the Internet Shared Bandwidth instance are consistent with those of the original NAT bandwidth package.
 *
 * @param request ConvertBandwidthPackageRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ConvertBandwidthPackageResponse
 */
func (client *Client) ConvertBandwidthPackageWithOptions(request *ConvertBandwidthPackageRequest, runtime *util.RuntimeOptions) (_result *ConvertBandwidthPackageResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BandwidthPackageId)) {
		query["BandwidthPackageId"] = request.BandwidthPackageId
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ConvertBandwidthPackage"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ConvertBandwidthPackageResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Before you convert a NAT bandwidth package to an Internet Shared Bandwidth instance, make sure you are aware of the following:
 * *   The conversion does not incur any additional fees.
 * *   The conversion does not affect the SNAT or DNAT entries of the NAT Gateway, and has no impact on the running services. However, we recommend that you perform the conversion during off-peak hours.
 * *   After the conversion, the public IP address in the NAT bandwidth package is converted to an EIP. The peak bandwidth and billing method of the Internet Shared Bandwidth instance are consistent with those of the original NAT bandwidth package.
 *
 * @param request ConvertBandwidthPackageRequest
 * @return ConvertBandwidthPackageResponse
 */
func (client *Client) ConvertBandwidthPackage(request *ConvertBandwidthPackageRequest) (_result *ConvertBandwidthPackageResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ConvertBandwidthPackageResponse{}
	_body, _err := client.ConvertBandwidthPackageWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   The **CopyNetworkAclEntries** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeNetworkAclAttributes](~~116542~~) operation to query the status of a network ACL:
 *     *   If the network ACL is in the **Modifying** state, the rules of the network ACL are being copied.
 *     *   If the network ACL is in the **Available** state, the rules of the network ACL are copied.
 * *   You cannot repeatedly call the **CopyNetworkAclEntries** operation to copy the rules of a network ACL within the specified period of time.
 *
 * @param request CopyNetworkAclEntriesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CopyNetworkAclEntriesResponse
 */
func (client *Client) CopyNetworkAclEntriesWithOptions(request *CopyNetworkAclEntriesRequest, runtime *util.RuntimeOptions) (_result *CopyNetworkAclEntriesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.NetworkAclId)) {
		query["NetworkAclId"] = request.NetworkAclId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SourceNetworkAclId)) {
		query["SourceNetworkAclId"] = request.SourceNetworkAclId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CopyNetworkAclEntries"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CopyNetworkAclEntriesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   The **CopyNetworkAclEntries** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeNetworkAclAttributes](~~116542~~) operation to query the status of a network ACL:
 *     *   If the network ACL is in the **Modifying** state, the rules of the network ACL are being copied.
 *     *   If the network ACL is in the **Available** state, the rules of the network ACL are copied.
 * *   You cannot repeatedly call the **CopyNetworkAclEntries** operation to copy the rules of a network ACL within the specified period of time.
 *
 * @param request CopyNetworkAclEntriesRequest
 * @return CopyNetworkAclEntriesResponse
 */
func (client *Client) CopyNetworkAclEntries(request *CopyNetworkAclEntriesRequest) (_result *CopyNetworkAclEntriesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CopyNetworkAclEntriesResponse{}
	_body, _err := client.CopyNetworkAclEntriesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can use BGP to connect a VBR to a data center. Each BGP group is associated with a VBR. You can add a BGP peer that needs to communicate with a VBR to a BGP group and advertise the BGP network in the VBR.
 * BGP groups are used to simplify BGP configurations. You can add BGP peers that use the same configurations to one BGP group. Before you start, you must create a BGP group with the requested autonomous system number (ASN).
 * When you call this operation, take note of the following limits:
 * *   You can specify only the data center that is connected to the VBR through an Express Connect circuit as a BGP peer.
 * *   VBRs support only BGP-4.
 * *   You can create at most eight BGP peers for each VBR.
 * *   Each BGP peer supports at most 110 dynamic routes.
 * *   The ASN of Alibaba Cloud is 45104. You can specify a 2-byte or 4-byte ASN for the data center.
 *
 * @param request CreateBgpGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateBgpGroupResponse
 */
func (client *Client) CreateBgpGroupWithOptions(request *CreateBgpGroupRequest, runtime *util.RuntimeOptions) (_result *CreateBgpGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AuthKey)) {
		query["AuthKey"] = request.AuthKey
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.IpVersion)) {
		query["IpVersion"] = request.IpVersion
	}

	if !tea.BoolValue(util.IsUnset(request.IsFakeAsn)) {
		query["IsFakeAsn"] = request.IsFakeAsn
	}

	if !tea.BoolValue(util.IsUnset(request.LocalAsn)) {
		query["LocalAsn"] = request.LocalAsn
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PeerAsn)) {
		query["PeerAsn"] = request.PeerAsn
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RouteQuota)) {
		query["RouteQuota"] = request.RouteQuota
	}

	if !tea.BoolValue(util.IsUnset(request.RouterId)) {
		query["RouterId"] = request.RouterId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateBgpGroup"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateBgpGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can use BGP to connect a VBR to a data center. Each BGP group is associated with a VBR. You can add a BGP peer that needs to communicate with a VBR to a BGP group and advertise the BGP network in the VBR.
 * BGP groups are used to simplify BGP configurations. You can add BGP peers that use the same configurations to one BGP group. Before you start, you must create a BGP group with the requested autonomous system number (ASN).
 * When you call this operation, take note of the following limits:
 * *   You can specify only the data center that is connected to the VBR through an Express Connect circuit as a BGP peer.
 * *   VBRs support only BGP-4.
 * *   You can create at most eight BGP peers for each VBR.
 * *   Each BGP peer supports at most 110 dynamic routes.
 * *   The ASN of Alibaba Cloud is 45104. You can specify a 2-byte or 4-byte ASN for the data center.
 *
 * @param request CreateBgpGroupRequest
 * @return CreateBgpGroupResponse
 */
func (client *Client) CreateBgpGroup(request *CreateBgpGroupRequest) (_result *CreateBgpGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateBgpGroupResponse{}
	_body, _err := client.CreateBgpGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateBgpPeerWithOptions(request *CreateBgpPeerRequest, runtime *util.RuntimeOptions) (_result *CreateBgpPeerResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BfdMultiHop)) {
		query["BfdMultiHop"] = request.BfdMultiHop
	}

	if !tea.BoolValue(util.IsUnset(request.BgpGroupId)) {
		query["BgpGroupId"] = request.BgpGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.EnableBfd)) {
		query["EnableBfd"] = request.EnableBfd
	}

	if !tea.BoolValue(util.IsUnset(request.IpVersion)) {
		query["IpVersion"] = request.IpVersion
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PeerIpAddress)) {
		query["PeerIpAddress"] = request.PeerIpAddress
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateBgpPeer"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateBgpPeerResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateBgpPeer(request *CreateBgpPeerRequest) (_result *CreateBgpPeerResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateBgpPeerResponse{}
	_body, _err := client.CreateBgpPeerWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateCommonBandwidthPackageWithOptions(request *CreateCommonBandwidthPackageRequest, runtime *util.RuntimeOptions) (_result *CreateCommonBandwidthPackageResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Bandwidth)) {
		query["Bandwidth"] = request.Bandwidth
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.ISP)) {
		query["ISP"] = request.ISP
	}

	if !tea.BoolValue(util.IsUnset(request.InternetChargeType)) {
		query["InternetChargeType"] = request.InternetChargeType
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Ratio)) {
		query["Ratio"] = request.Ratio
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityProtectionTypes)) {
		query["SecurityProtectionTypes"] = request.SecurityProtectionTypes
	}

	if !tea.BoolValue(util.IsUnset(request.Zone)) {
		query["Zone"] = request.Zone
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateCommonBandwidthPackage"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateCommonBandwidthPackageResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateCommonBandwidthPackage(request *CreateCommonBandwidthPackageRequest) (_result *CreateCommonBandwidthPackageResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateCommonBandwidthPackageResponse{}
	_body, _err := client.CreateCommonBandwidthPackageWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateCustomerGatewayWithOptions(request *CreateCustomerGatewayRequest, runtime *util.RuntimeOptions) (_result *CreateCustomerGatewayResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Asn)) {
		query["Asn"] = request.Asn
	}

	if !tea.BoolValue(util.IsUnset(request.AuthKey)) {
		query["AuthKey"] = request.AuthKey
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.IpAddress)) {
		query["IpAddress"] = request.IpAddress
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateCustomerGateway"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateCustomerGatewayResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateCustomerGateway(request *CreateCustomerGatewayRequest) (_result *CreateCustomerGatewayResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateCustomerGatewayResponse{}
	_body, _err := client.CreateCustomerGatewayWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Usage notes
 * When you call this operation, take note of the following items:
 * *   The first IP address and last three IP addresses of a default vSwitch CIDR block are reserved. For example, if the CIDR block of a vSwitch is 192.168.1.0/24, the IP addresses 192.168.1.0, 192.168.1.253, 192.168.1.254, and 192.168.1.255 are reserved.
 * *   The number of instances in the default vSwitch cannot exceed the remaining number of instances supported by the VPC (15,000 minus the number of existing instances).
 * *   Default vSwitches do not support multicasting or broadcasting.
 * *   After you create a default vSwitch, you cannot modify its CIDR block.
 * *   **CreateDefaultVSwitch** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVSwitchAttributes](~~94567~~) operation to query the status of a default vSwitch:
 *     *   If a default vSwitch is in the **Pending** state, it is being configured.
 *     *   If a default vSwitch is in the **Available** state, it is available.
 * *   If a default vSwitch already exists in a region, you cannot call this operation to create a default vSwitch in this region.
 * *   Before you create a default vSwitch, make sure that a default VPC is created. You can call the [CreateDefaultVpc](~~609152~~) operation to create a default VPC.
 *
 * @param request CreateDefaultVSwitchRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDefaultVSwitchResponse
 */
func (client *Client) CreateDefaultVSwitchWithOptions(request *CreateDefaultVSwitchRequest, runtime *util.RuntimeOptions) (_result *CreateDefaultVSwitchResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Ipv6CidrBlock)) {
		query["Ipv6CidrBlock"] = request.Ipv6CidrBlock
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ZoneId)) {
		query["ZoneId"] = request.ZoneId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateDefaultVSwitch"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateDefaultVSwitchResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Usage notes
 * When you call this operation, take note of the following items:
 * *   The first IP address and last three IP addresses of a default vSwitch CIDR block are reserved. For example, if the CIDR block of a vSwitch is 192.168.1.0/24, the IP addresses 192.168.1.0, 192.168.1.253, 192.168.1.254, and 192.168.1.255 are reserved.
 * *   The number of instances in the default vSwitch cannot exceed the remaining number of instances supported by the VPC (15,000 minus the number of existing instances).
 * *   Default vSwitches do not support multicasting or broadcasting.
 * *   After you create a default vSwitch, you cannot modify its CIDR block.
 * *   **CreateDefaultVSwitch** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVSwitchAttributes](~~94567~~) operation to query the status of a default vSwitch:
 *     *   If a default vSwitch is in the **Pending** state, it is being configured.
 *     *   If a default vSwitch is in the **Available** state, it is available.
 * *   If a default vSwitch already exists in a region, you cannot call this operation to create a default vSwitch in this region.
 * *   Before you create a default vSwitch, make sure that a default VPC is created. You can call the [CreateDefaultVpc](~~609152~~) operation to create a default VPC.
 *
 * @param request CreateDefaultVSwitchRequest
 * @return CreateDefaultVSwitchResponse
 */
func (client *Client) CreateDefaultVSwitch(request *CreateDefaultVSwitchRequest) (_result *CreateDefaultVSwitchResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateDefaultVSwitchResponse{}
	_body, _err := client.CreateDefaultVSwitchWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Usage notes
 * When you call this operation, take note of the following items:
 * *   After you create a default VPC, you cannot change its CIDR block. However, you can add secondary IPv4 CIDR blocks to it.
 * *   In each default VPC, cloud services can use a maximum of 60,000 private IP addresses. You cannot increase the quota.
 * *   After you create a default VPC, a vRouter and a route table are automatically created for the VPC.
 * *   At most three user CIDR blocks can be added to a VPC. If a user CIDR block includes another user CIDR block, the one with the shorter subnet mask takes effect. For example, if 10.0.0.0/8 and 10.1.0.0/16 are specified, only 10.0.0.0/8 takes effect.
 * *   **CreateDefaultVpc** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpcAttribute](~~94565~~) operation to query the status of the task:
 *     *   If the default VPC is in the **Pending** state, the VPC is being configured.
 *     *   If the default VPC is in the **Available** state, the VPC is available.
 * *   You cannot repeatedly call the **CreateDefaultVpc** operation within a specific time period.
 * *   You can create only one default VPC in each region.
 *
 * @param request CreateDefaultVpcRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDefaultVpcResponse
 */
func (client *Client) CreateDefaultVpcWithOptions(request *CreateDefaultVpcRequest, runtime *util.RuntimeOptions) (_result *CreateDefaultVpcResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.EnableIpv6)) {
		query["EnableIpv6"] = request.EnableIpv6
	}

	if !tea.BoolValue(util.IsUnset(request.Ipv6CidrBlock)) {
		query["Ipv6CidrBlock"] = request.Ipv6CidrBlock
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateDefaultVpc"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateDefaultVpcResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Usage notes
 * When you call this operation, take note of the following items:
 * *   After you create a default VPC, you cannot change its CIDR block. However, you can add secondary IPv4 CIDR blocks to it.
 * *   In each default VPC, cloud services can use a maximum of 60,000 private IP addresses. You cannot increase the quota.
 * *   After you create a default VPC, a vRouter and a route table are automatically created for the VPC.
 * *   At most three user CIDR blocks can be added to a VPC. If a user CIDR block includes another user CIDR block, the one with the shorter subnet mask takes effect. For example, if 10.0.0.0/8 and 10.1.0.0/16 are specified, only 10.0.0.0/8 takes effect.
 * *   **CreateDefaultVpc** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpcAttribute](~~94565~~) operation to query the status of the task:
 *     *   If the default VPC is in the **Pending** state, the VPC is being configured.
 *     *   If the default VPC is in the **Available** state, the VPC is available.
 * *   You cannot repeatedly call the **CreateDefaultVpc** operation within a specific time period.
 * *   You can create only one default VPC in each region.
 *
 * @param request CreateDefaultVpcRequest
 * @return CreateDefaultVpcResponse
 */
func (client *Client) CreateDefaultVpc(request *CreateDefaultVpcRequest) (_result *CreateDefaultVpcResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateDefaultVpcResponse{}
	_body, _err := client.CreateDefaultVpcWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateDhcpOptionsSetWithOptions(request *CreateDhcpOptionsSetRequest, runtime *util.RuntimeOptions) (_result *CreateDhcpOptionsSetResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DhcpOptionsSetDescription)) {
		query["DhcpOptionsSetDescription"] = request.DhcpOptionsSetDescription
	}

	if !tea.BoolValue(util.IsUnset(request.DhcpOptionsSetName)) {
		query["DhcpOptionsSetName"] = request.DhcpOptionsSetName
	}

	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.DomainNameServers)) {
		query["DomainNameServers"] = request.DomainNameServers
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.Ipv6LeaseTime)) {
		query["Ipv6LeaseTime"] = request.Ipv6LeaseTime
	}

	if !tea.BoolValue(util.IsUnset(request.LeaseTime)) {
		query["LeaseTime"] = request.LeaseTime
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateDhcpOptionsSet"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateDhcpOptionsSetResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateDhcpOptionsSet(request *CreateDhcpOptionsSetRequest) (_result *CreateDhcpOptionsSetResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateDhcpOptionsSetResponse{}
	_body, _err := client.CreateDhcpOptionsSetWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateExpressCloudConnectionWithOptions(request *CreateExpressCloudConnectionRequest, runtime *util.RuntimeOptions) (_result *CreateExpressCloudConnectionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Bandwidth)) {
		query["Bandwidth"] = request.Bandwidth
	}

	if !tea.BoolValue(util.IsUnset(request.ContactMail)) {
		query["ContactMail"] = request.ContactMail
	}

	if !tea.BoolValue(util.IsUnset(request.ContactTel)) {
		query["ContactTel"] = request.ContactTel
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.IDCardNo)) {
		query["IDCardNo"] = request.IDCardNo
	}

	if !tea.BoolValue(util.IsUnset(request.IdcSP)) {
		query["IdcSP"] = request.IdcSP
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PeerCity)) {
		query["PeerCity"] = request.PeerCity
	}

	if !tea.BoolValue(util.IsUnset(request.PeerLocation)) {
		query["PeerLocation"] = request.PeerLocation
	}

	if !tea.BoolValue(util.IsUnset(request.PortType)) {
		query["PortType"] = request.PortType
	}

	if !tea.BoolValue(util.IsUnset(request.RedundantEccId)) {
		query["RedundantEccId"] = request.RedundantEccId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateExpressCloudConnection"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateExpressCloudConnectionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateExpressCloudConnection(request *CreateExpressCloudConnectionRequest) (_result *CreateExpressCloudConnectionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateExpressCloudConnectionResponse{}
	_body, _err := client.CreateExpressCloudConnectionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * **CreateFlowLog** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeFlowLogs](~~87923~~) operation to query the status of a flow log:
 * *   If the flow log is in the **Activating** state, the flow log is being created.
 * *   If the flow log is in the **Active** state, the flow log is created and started.
 *
 * @param request CreateFlowLogRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateFlowLogResponse
 */
func (client *Client) CreateFlowLogWithOptions(request *CreateFlowLogRequest, runtime *util.RuntimeOptions) (_result *CreateFlowLogResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AggregationInterval)) {
		query["AggregationInterval"] = request.AggregationInterval
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.FlowLogName)) {
		query["FlowLogName"] = request.FlowLogName
	}

	if !tea.BoolValue(util.IsUnset(request.LogStoreName)) {
		query["LogStoreName"] = request.LogStoreName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectName)) {
		query["ProjectName"] = request.ProjectName
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceId)) {
		query["ResourceId"] = request.ResourceId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	if !tea.BoolValue(util.IsUnset(request.TrafficPath)) {
		query["TrafficPath"] = request.TrafficPath
	}

	if !tea.BoolValue(util.IsUnset(request.TrafficType)) {
		query["TrafficType"] = request.TrafficType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateFlowLog"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateFlowLogResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * **CreateFlowLog** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeFlowLogs](~~87923~~) operation to query the status of a flow log:
 * *   If the flow log is in the **Activating** state, the flow log is being created.
 * *   If the flow log is in the **Active** state, the flow log is created and started.
 *
 * @param request CreateFlowLogRequest
 * @return CreateFlowLogResponse
 */
func (client *Client) CreateFlowLog(request *CreateFlowLogRequest) (_result *CreateFlowLogResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateFlowLogResponse{}
	_body, _err := client.CreateFlowLogWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Each DNAT entry consists of the following parameters: **ExternalIp**, **ExternalPort**, **IpProtocol**, **InternalIp**, and **InternalPort**. After you add a DNAT entry, the NAT gateway forwards packets of the specified protocol from **ExternalIp:ExternalPort** to **InternalIp:InternalPort** and sends responses back through the same route.
 * When you call this operation, take note of the following limits:
 * *   **CreateForwardEntry** is an asynchronous operation. After you make a request, a DNAT entry ID is returned but the specified DNAT entry is not added. The system adds the entry in the background. You can call the [DescribeForwardTableEntries](~~36053~~) operation to query the status of a DNAT entry.
 *     *   If the DNAT entry is in the **Pending** state, the system is adding the DNAT entry. You can only query the status of the DNAT entry, but cannot perform other operations.
 *     *   If the DNAT entry is in the **Available** state, the DNAT entry is added.
 * *   You cannot repeatedly call the **CreateForwardEntry** operation to add a DNAT entry within the specified period of time.
 * *   All combinations of **ExternalIp**, **ExternalPort**, and **IpProtocol** used in DNAT entries must be unique. You cannot distribute requests to more than one Elastic Compute Service (ECS) instance if these requests are initiated from the same source IP address, received on the same port, and use the same protocol.
 * *   The combinations of **IpProtocol**, **InternalIp**, and **InternalPort** must be unique.
 * *   If one or more DNAT entries in the DNAT table are in the **Pending** or **Modifying** state, you cannot add DNAT entries to the DNAT table.
 * *   You can add at most 100 DNAT entries to a DNAT table.
 * *   For an elastic IP address (EIP) used by an Internet NAT gateway or a NAT IP address used by a Virtual Private Cloud (VPC) NAT gateway, take note of the following limit: If the IP address has IP mapping enabled and is specified in a DNAT entry, the IP address cannot be used by another DNAT or SNAT entry.
 *
 * @param request CreateForwardEntryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateForwardEntryResponse
 */
func (client *Client) CreateForwardEntryWithOptions(request *CreateForwardEntryRequest, runtime *util.RuntimeOptions) (_result *CreateForwardEntryResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.ExternalIp)) {
		query["ExternalIp"] = request.ExternalIp
	}

	if !tea.BoolValue(util.IsUnset(request.ExternalPort)) {
		query["ExternalPort"] = request.ExternalPort
	}

	if !tea.BoolValue(util.IsUnset(request.ForwardEntryName)) {
		query["ForwardEntryName"] = request.ForwardEntryName
	}

	if !tea.BoolValue(util.IsUnset(request.ForwardTableId)) {
		query["ForwardTableId"] = request.ForwardTableId
	}

	if !tea.BoolValue(util.IsUnset(request.InternalIp)) {
		query["InternalIp"] = request.InternalIp
	}

	if !tea.BoolValue(util.IsUnset(request.InternalPort)) {
		query["InternalPort"] = request.InternalPort
	}

	if !tea.BoolValue(util.IsUnset(request.IpProtocol)) {
		query["IpProtocol"] = request.IpProtocol
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PortBreak)) {
		query["PortBreak"] = request.PortBreak
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateForwardEntry"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateForwardEntryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Each DNAT entry consists of the following parameters: **ExternalIp**, **ExternalPort**, **IpProtocol**, **InternalIp**, and **InternalPort**. After you add a DNAT entry, the NAT gateway forwards packets of the specified protocol from **ExternalIp:ExternalPort** to **InternalIp:InternalPort** and sends responses back through the same route.
 * When you call this operation, take note of the following limits:
 * *   **CreateForwardEntry** is an asynchronous operation. After you make a request, a DNAT entry ID is returned but the specified DNAT entry is not added. The system adds the entry in the background. You can call the [DescribeForwardTableEntries](~~36053~~) operation to query the status of a DNAT entry.
 *     *   If the DNAT entry is in the **Pending** state, the system is adding the DNAT entry. You can only query the status of the DNAT entry, but cannot perform other operations.
 *     *   If the DNAT entry is in the **Available** state, the DNAT entry is added.
 * *   You cannot repeatedly call the **CreateForwardEntry** operation to add a DNAT entry within the specified period of time.
 * *   All combinations of **ExternalIp**, **ExternalPort**, and **IpProtocol** used in DNAT entries must be unique. You cannot distribute requests to more than one Elastic Compute Service (ECS) instance if these requests are initiated from the same source IP address, received on the same port, and use the same protocol.
 * *   The combinations of **IpProtocol**, **InternalIp**, and **InternalPort** must be unique.
 * *   If one or more DNAT entries in the DNAT table are in the **Pending** or **Modifying** state, you cannot add DNAT entries to the DNAT table.
 * *   You can add at most 100 DNAT entries to a DNAT table.
 * *   For an elastic IP address (EIP) used by an Internet NAT gateway or a NAT IP address used by a Virtual Private Cloud (VPC) NAT gateway, take note of the following limit: If the IP address has IP mapping enabled and is specified in a DNAT entry, the IP address cannot be used by another DNAT or SNAT entry.
 *
 * @param request CreateForwardEntryRequest
 * @return CreateForwardEntryResponse
 */
func (client *Client) CreateForwardEntry(request *CreateForwardEntryRequest) (_result *CreateForwardEntryResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateForwardEntryResponse{}
	_body, _err := client.CreateForwardEntryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   **CreateFullNatEntry** is an asynchronous operation. After you make a request, a FULLNAT entry ID is returned but the specified FULLNAT entry is not added. The system adds the entry in the background. You can call the [ListFullNatEntries](~~348779~~) operation to query the status of a FULLNAT entry.
 *     *   If the FULLNAT entry is in the **Pending** state, the system is adding the FULLNAT entry. You can only query the status of the FULLNAT entry, but cannot perform other operations.
 *     *   If the FULLNAT entry is in the **Available** state, the FULLNAT entry is added.
 * *   You cannot repeatedly call the **CreateFullNatEntry** operation to add a FULLNAT entry to the FULLNAT table within the specified period of time.
 *
 * @param request CreateFullNatEntryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateFullNatEntryResponse
 */
func (client *Client) CreateFullNatEntryWithOptions(request *CreateFullNatEntryRequest, runtime *util.RuntimeOptions) (_result *CreateFullNatEntryResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AccessIp)) {
		query["AccessIp"] = request.AccessIp
	}

	if !tea.BoolValue(util.IsUnset(request.AccessPort)) {
		query["AccessPort"] = request.AccessPort
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.FullNatEntryDescription)) {
		query["FullNatEntryDescription"] = request.FullNatEntryDescription
	}

	if !tea.BoolValue(util.IsUnset(request.FullNatEntryName)) {
		query["FullNatEntryName"] = request.FullNatEntryName
	}

	if !tea.BoolValue(util.IsUnset(request.FullNatTableId)) {
		query["FullNatTableId"] = request.FullNatTableId
	}

	if !tea.BoolValue(util.IsUnset(request.IpProtocol)) {
		query["IpProtocol"] = request.IpProtocol
	}

	if !tea.BoolValue(util.IsUnset(request.NatIp)) {
		query["NatIp"] = request.NatIp
	}

	if !tea.BoolValue(util.IsUnset(request.NatIpPort)) {
		query["NatIpPort"] = request.NatIpPort
	}

	if !tea.BoolValue(util.IsUnset(request.NetworkInterfaceId)) {
		query["NetworkInterfaceId"] = request.NetworkInterfaceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateFullNatEntry"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateFullNatEntryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   **CreateFullNatEntry** is an asynchronous operation. After you make a request, a FULLNAT entry ID is returned but the specified FULLNAT entry is not added. The system adds the entry in the background. You can call the [ListFullNatEntries](~~348779~~) operation to query the status of a FULLNAT entry.
 *     *   If the FULLNAT entry is in the **Pending** state, the system is adding the FULLNAT entry. You can only query the status of the FULLNAT entry, but cannot perform other operations.
 *     *   If the FULLNAT entry is in the **Available** state, the FULLNAT entry is added.
 * *   You cannot repeatedly call the **CreateFullNatEntry** operation to add a FULLNAT entry to the FULLNAT table within the specified period of time.
 *
 * @param request CreateFullNatEntryRequest
 * @return CreateFullNatEntryResponse
 */
func (client *Client) CreateFullNatEntry(request *CreateFullNatEntryRequest) (_result *CreateFullNatEntryResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateFullNatEntryResponse{}
	_body, _err := client.CreateFullNatEntryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Usage notes
 * You can call this operation to create only pay-as-you-go GA instances.
 *
 * @param request CreateGlobalAccelerationInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateGlobalAccelerationInstanceResponse
 */
func (client *Client) CreateGlobalAccelerationInstanceWithOptions(request *CreateGlobalAccelerationInstanceRequest, runtime *util.RuntimeOptions) (_result *CreateGlobalAccelerationInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Bandwidth)) {
		query["Bandwidth"] = request.Bandwidth
	}

	if !tea.BoolValue(util.IsUnset(request.BandwidthType)) {
		query["BandwidthType"] = request.BandwidthType
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceLocation)) {
		query["ServiceLocation"] = request.ServiceLocation
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateGlobalAccelerationInstance"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateGlobalAccelerationInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Usage notes
 * You can call this operation to create only pay-as-you-go GA instances.
 *
 * @param request CreateGlobalAccelerationInstanceRequest
 * @return CreateGlobalAccelerationInstanceResponse
 */
func (client *Client) CreateGlobalAccelerationInstance(request *CreateGlobalAccelerationInstanceRequest) (_result *CreateGlobalAccelerationInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateGlobalAccelerationInstanceResponse{}
	_body, _err := client.CreateGlobalAccelerationInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * **CreateHaVip** is an asynchronous operation. After you send the request, the system returns a request ID and runs the task in the background. You can call the [DescribeHaVips](~~114611~~) operation to query the status of an HAVIP:
 * *   If the HAVIP is in the **Creating** state, the HAVIP is being created.
 * *   If the HAVIP is in the **Available** state, the HAVIP is created.
 *
 * @param request CreateHaVipRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateHaVipResponse
 */
func (client *Client) CreateHaVipWithOptions(request *CreateHaVipRequest, runtime *util.RuntimeOptions) (_result *CreateHaVipResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.IpAddress)) {
		query["IpAddress"] = request.IpAddress
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	if !tea.BoolValue(util.IsUnset(request.VSwitchId)) {
		query["VSwitchId"] = request.VSwitchId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateHaVip"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateHaVipResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * **CreateHaVip** is an asynchronous operation. After you send the request, the system returns a request ID and runs the task in the background. You can call the [DescribeHaVips](~~114611~~) operation to query the status of an HAVIP:
 * *   If the HAVIP is in the **Creating** state, the HAVIP is being created.
 * *   If the HAVIP is in the **Available** state, the HAVIP is created.
 *
 * @param request CreateHaVipRequest
 * @return CreateHaVipResponse
 */
func (client *Client) CreateHaVip(request *CreateHaVipRequest) (_result *CreateHaVipResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateHaVipResponse{}
	_body, _err := client.CreateHaVipWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * @deprecated
 *
 * @param request CreateIPv6TranslatorRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateIPv6TranslatorResponse
 */
// Deprecated
func (client *Client) CreateIPv6TranslatorWithOptions(request *CreateIPv6TranslatorRequest, runtime *util.RuntimeOptions) (_result *CreateIPv6TranslatorResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AutoPay)) {
		query["AutoPay"] = request.AutoPay
	}

	if !tea.BoolValue(util.IsUnset(request.Bandwidth)) {
		query["Bandwidth"] = request.Bandwidth
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Duration)) {
		query["Duration"] = request.Duration
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PayType)) {
		query["PayType"] = request.PayType
	}

	if !tea.BoolValue(util.IsUnset(request.PricingCycle)) {
		query["PricingCycle"] = request.PricingCycle
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Spec)) {
		query["Spec"] = request.Spec
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateIPv6Translator"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateIPv6TranslatorResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * @deprecated
 *
 * @param request CreateIPv6TranslatorRequest
 * @return CreateIPv6TranslatorResponse
 */
// Deprecated
func (client *Client) CreateIPv6Translator(request *CreateIPv6TranslatorRequest) (_result *CreateIPv6TranslatorResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateIPv6TranslatorResponse{}
	_body, _err := client.CreateIPv6TranslatorWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * @deprecated
 *
 * @param request CreateIPv6TranslatorAclListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateIPv6TranslatorAclListResponse
 */
// Deprecated
func (client *Client) CreateIPv6TranslatorAclListWithOptions(request *CreateIPv6TranslatorAclListRequest, runtime *util.RuntimeOptions) (_result *CreateIPv6TranslatorAclListResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AclName)) {
		query["AclName"] = request.AclName
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateIPv6TranslatorAclList"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateIPv6TranslatorAclListResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * @deprecated
 *
 * @param request CreateIPv6TranslatorAclListRequest
 * @return CreateIPv6TranslatorAclListResponse
 */
// Deprecated
func (client *Client) CreateIPv6TranslatorAclList(request *CreateIPv6TranslatorAclListRequest) (_result *CreateIPv6TranslatorAclListResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateIPv6TranslatorAclListResponse{}
	_body, _err := client.CreateIPv6TranslatorAclListWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * @deprecated
 *
 * @param request CreateIPv6TranslatorEntryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateIPv6TranslatorEntryResponse
 */
// Deprecated
func (client *Client) CreateIPv6TranslatorEntryWithOptions(request *CreateIPv6TranslatorEntryRequest, runtime *util.RuntimeOptions) (_result *CreateIPv6TranslatorEntryResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AclId)) {
		query["AclId"] = request.AclId
	}

	if !tea.BoolValue(util.IsUnset(request.AclStatus)) {
		query["AclStatus"] = request.AclStatus
	}

	if !tea.BoolValue(util.IsUnset(request.AclType)) {
		query["AclType"] = request.AclType
	}

	if !tea.BoolValue(util.IsUnset(request.AllocateIpv6Port)) {
		query["AllocateIpv6Port"] = request.AllocateIpv6Port
	}

	if !tea.BoolValue(util.IsUnset(request.BackendIpv4Addr)) {
		query["BackendIpv4Addr"] = request.BackendIpv4Addr
	}

	if !tea.BoolValue(util.IsUnset(request.BackendIpv4Port)) {
		query["BackendIpv4Port"] = request.BackendIpv4Port
	}

	if !tea.BoolValue(util.IsUnset(request.EntryBandwidth)) {
		query["EntryBandwidth"] = request.EntryBandwidth
	}

	if !tea.BoolValue(util.IsUnset(request.EntryDescription)) {
		query["EntryDescription"] = request.EntryDescription
	}

	if !tea.BoolValue(util.IsUnset(request.EntryName)) {
		query["EntryName"] = request.EntryName
	}

	if !tea.BoolValue(util.IsUnset(request.Ipv6TranslatorId)) {
		query["Ipv6TranslatorId"] = request.Ipv6TranslatorId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.TransProtocol)) {
		query["TransProtocol"] = request.TransProtocol
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateIPv6TranslatorEntry"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateIPv6TranslatorEntryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * @deprecated
 *
 * @param request CreateIPv6TranslatorEntryRequest
 * @return CreateIPv6TranslatorEntryResponse
 */
// Deprecated
func (client *Client) CreateIPv6TranslatorEntry(request *CreateIPv6TranslatorEntryRequest) (_result *CreateIPv6TranslatorEntryResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateIPv6TranslatorEntryResponse{}
	_body, _err := client.CreateIPv6TranslatorEntryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   Before you create an IPsec server, you must create a VPN gateway and enable the SSL-VPN feature for the VPN gateway. For more information, see [CreateVpnGateway](~~120363~~).
 * *   The **CreateIpsecServer** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeVpnGateway](~~73720~~) operation to query the status of a VPN gateway.
 *     *   If the VPN gateway is in the **updating** state, the IPsec server is being created.
 *     *   If the VPN gateway is in the **active** state, the IPsec server is created.
 * *   You cannot repeatedly call **CreateIpsecServer** to create an IPsec server for a VPN gateway within the specified period of time.
 *
 * @param request CreateIpsecServerRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateIpsecServerResponse
 */
func (client *Client) CreateIpsecServerWithOptions(request *CreateIpsecServerRequest, runtime *util.RuntimeOptions) (_result *CreateIpsecServerResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientIpPool)) {
		query["ClientIpPool"] = request.ClientIpPool
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.EffectImmediately)) {
		query["EffectImmediately"] = request.EffectImmediately
	}

	if !tea.BoolValue(util.IsUnset(request.IkeConfig)) {
		query["IkeConfig"] = request.IkeConfig
	}

	if !tea.BoolValue(util.IsUnset(request.IpSecServerName)) {
		query["IpSecServerName"] = request.IpSecServerName
	}

	if !tea.BoolValue(util.IsUnset(request.IpsecConfig)) {
		query["IpsecConfig"] = request.IpsecConfig
	}

	if !tea.BoolValue(util.IsUnset(request.LocalSubnet)) {
		query["LocalSubnet"] = request.LocalSubnet
	}

	if !tea.BoolValue(util.IsUnset(request.Psk)) {
		query["Psk"] = request.Psk
	}

	if !tea.BoolValue(util.IsUnset(request.PskEnabled)) {
		query["PskEnabled"] = request.PskEnabled
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.VpnGatewayId)) {
		query["VpnGatewayId"] = request.VpnGatewayId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateIpsecServer"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateIpsecServerResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   Before you create an IPsec server, you must create a VPN gateway and enable the SSL-VPN feature for the VPN gateway. For more information, see [CreateVpnGateway](~~120363~~).
 * *   The **CreateIpsecServer** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeVpnGateway](~~73720~~) operation to query the status of a VPN gateway.
 *     *   If the VPN gateway is in the **updating** state, the IPsec server is being created.
 *     *   If the VPN gateway is in the **active** state, the IPsec server is created.
 * *   You cannot repeatedly call **CreateIpsecServer** to create an IPsec server for a VPN gateway within the specified period of time.
 *
 * @param request CreateIpsecServerRequest
 * @return CreateIpsecServerResponse
 */
func (client *Client) CreateIpsecServer(request *CreateIpsecServerRequest) (_result *CreateIpsecServerResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateIpsecServerResponse{}
	_body, _err := client.CreateIpsecServerWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   **CreateIpv4Gateway** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [GetIpv4GatewayAttribute](~~407670~~) operation to query the status of an IPv4 gateway:
 *     *   If the IPv4 gateway is in the **Creating** state, the IPv4 gateway is being created.
 *     *   If the IPv4 gateway is in the **Created** state, the IPv4 gateway is created.
 * *   You cannot repeatedly call the **CreateIpv4Gateway** operation to create IPv4 gateways in a virtual private cloud (VPC) within the specified period of time.
 *
 * @param request CreateIpv4GatewayRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateIpv4GatewayResponse
 */
func (client *Client) CreateIpv4GatewayWithOptions(request *CreateIpv4GatewayRequest, runtime *util.RuntimeOptions) (_result *CreateIpv4GatewayResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.Ipv4GatewayDescription)) {
		query["Ipv4GatewayDescription"] = request.Ipv4GatewayDescription
	}

	if !tea.BoolValue(util.IsUnset(request.Ipv4GatewayName)) {
		query["Ipv4GatewayName"] = request.Ipv4GatewayName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	if !tea.BoolValue(util.IsUnset(request.VpcId)) {
		query["VpcId"] = request.VpcId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateIpv4Gateway"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateIpv4GatewayResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   **CreateIpv4Gateway** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [GetIpv4GatewayAttribute](~~407670~~) operation to query the status of an IPv4 gateway:
 *     *   If the IPv4 gateway is in the **Creating** state, the IPv4 gateway is being created.
 *     *   If the IPv4 gateway is in the **Created** state, the IPv4 gateway is created.
 * *   You cannot repeatedly call the **CreateIpv4Gateway** operation to create IPv4 gateways in a virtual private cloud (VPC) within the specified period of time.
 *
 * @param request CreateIpv4GatewayRequest
 * @return CreateIpv4GatewayResponse
 */
func (client *Client) CreateIpv4Gateway(request *CreateIpv4GatewayRequest) (_result *CreateIpv4GatewayResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateIpv4GatewayResponse{}
	_body, _err := client.CreateIpv4GatewayWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   The **CreateIpv6EgressOnlyRule** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeIpv6EgressOnlyRules](~~102208~~) operation to query the status of an egress-only rule.
 *     *   If the egress-only rule is in the **Creating** state, the egress-only rule is being created.
 *     *   If the egress-only rule is in the **Created** state, the egress-only rule is created.
 * *   You cannot repeatedly call the **CreateIpv6EgressOnlyRule** operation to add egress-only rules for an IPv6 address within the specified period of time.
 *
 * @param request CreateIpv6EgressOnlyRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateIpv6EgressOnlyRuleResponse
 */
func (client *Client) CreateIpv6EgressOnlyRuleWithOptions(request *CreateIpv6EgressOnlyRuleRequest, runtime *util.RuntimeOptions) (_result *CreateIpv6EgressOnlyRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceType)) {
		query["InstanceType"] = request.InstanceType
	}

	if !tea.BoolValue(util.IsUnset(request.Ipv6GatewayId)) {
		query["Ipv6GatewayId"] = request.Ipv6GatewayId
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateIpv6EgressOnlyRule"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateIpv6EgressOnlyRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   The **CreateIpv6EgressOnlyRule** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeIpv6EgressOnlyRules](~~102208~~) operation to query the status of an egress-only rule.
 *     *   If the egress-only rule is in the **Creating** state, the egress-only rule is being created.
 *     *   If the egress-only rule is in the **Created** state, the egress-only rule is created.
 * *   You cannot repeatedly call the **CreateIpv6EgressOnlyRule** operation to add egress-only rules for an IPv6 address within the specified period of time.
 *
 * @param request CreateIpv6EgressOnlyRuleRequest
 * @return CreateIpv6EgressOnlyRuleResponse
 */
func (client *Client) CreateIpv6EgressOnlyRule(request *CreateIpv6EgressOnlyRuleRequest) (_result *CreateIpv6EgressOnlyRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateIpv6EgressOnlyRuleResponse{}
	_body, _err := client.CreateIpv6EgressOnlyRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   **CreateIpv6Gateway** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeIpv6GatewayAttribute](~~102226~~) operation to query the state of an IPv6 gateway.
 *     *   If the IPv6 gateway is in the **Creating** state, the IPv6 gateway is being created.
 *     *   If the IPv6 gateway is in the **Created** state, the IPv6 gateway is created.
 * *   You cannot call the **CreateIpv6Gateway** operation to create multiple IPv6 gateways in a virtual private cloud (VPC) at the same time.
 *
 * @param request CreateIpv6GatewayRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateIpv6GatewayResponse
 */
func (client *Client) CreateIpv6GatewayWithOptions(request *CreateIpv6GatewayRequest, runtime *util.RuntimeOptions) (_result *CreateIpv6GatewayResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	if !tea.BoolValue(util.IsUnset(request.VpcId)) {
		query["VpcId"] = request.VpcId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateIpv6Gateway"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateIpv6GatewayResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   **CreateIpv6Gateway** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeIpv6GatewayAttribute](~~102226~~) operation to query the state of an IPv6 gateway.
 *     *   If the IPv6 gateway is in the **Creating** state, the IPv6 gateway is being created.
 *     *   If the IPv6 gateway is in the **Created** state, the IPv6 gateway is created.
 * *   You cannot call the **CreateIpv6Gateway** operation to create multiple IPv6 gateways in a virtual private cloud (VPC) at the same time.
 *
 * @param request CreateIpv6GatewayRequest
 * @return CreateIpv6GatewayResponse
 */
func (client *Client) CreateIpv6Gateway(request *CreateIpv6GatewayRequest) (_result *CreateIpv6GatewayResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateIpv6GatewayResponse{}
	_body, _err := client.CreateIpv6GatewayWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Before you call this operation, take note of the following items:
 * *   When you create an enhanced NAT gateway for the first time, the system automatically creates the service-linked role AliyunServiceRoleForNatgw. Then, the system attaches the permission policy AliyunServiceRolePolicyForNatgw to the role. This allows the NAT gateway to access other resources on Alibaba Cloud. For more information, see [Service-linked roles](~~174251~~).
 * *   After you create an enhanced Internet NAT gateway, a route entry is automatically added to the route table of the VPC. The destination CIDR block of the route entry is 0.0.0.0/0 and the next hop is the NAT gateway. This ensures that traffic is routed to the NAT gateway.
 * *   **CreateNatGateway** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeNatGateways](~~36054~~) operation to query the status of a NAT gateway.
 *     *   If a NAT gateway is in the **Creating** state, the NAT gateway is being created. In this case, you can query the NAT gateway but cannot perform other operations.
 *     *   If a NAT gateway is in the **Available** state, the NAT gateway is created.
 *         It takes 1 to 3 minutes to create a NAT gateway.
 * *   You cannot repeatedly call the **CreateNatGateway** operation to create a VPC NAT gateway or an Internet NAT gateway within the specified period of time.
 *
 * @param request CreateNatGatewayRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateNatGatewayResponse
 */
func (client *Client) CreateNatGatewayWithOptions(request *CreateNatGatewayRequest, runtime *util.RuntimeOptions) (_result *CreateNatGatewayResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AutoPay)) {
		query["AutoPay"] = request.AutoPay
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.Duration)) {
		query["Duration"] = request.Duration
	}

	if !tea.BoolValue(util.IsUnset(request.EipBindMode)) {
		query["EipBindMode"] = request.EipBindMode
	}

	if !tea.BoolValue(util.IsUnset(request.IcmpReplyEnabled)) {
		query["IcmpReplyEnabled"] = request.IcmpReplyEnabled
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceChargeType)) {
		query["InstanceChargeType"] = request.InstanceChargeType
	}

	if !tea.BoolValue(util.IsUnset(request.InternetChargeType)) {
		query["InternetChargeType"] = request.InternetChargeType
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.NatType)) {
		query["NatType"] = request.NatType
	}

	if !tea.BoolValue(util.IsUnset(request.NetworkType)) {
		query["NetworkType"] = request.NetworkType
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PricingCycle)) {
		query["PricingCycle"] = request.PricingCycle
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityProtectionEnabled)) {
		query["SecurityProtectionEnabled"] = request.SecurityProtectionEnabled
	}

	if !tea.BoolValue(util.IsUnset(request.Spec)) {
		query["Spec"] = request.Spec
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	if !tea.BoolValue(util.IsUnset(request.VSwitchId)) {
		query["VSwitchId"] = request.VSwitchId
	}

	if !tea.BoolValue(util.IsUnset(request.VpcId)) {
		query["VpcId"] = request.VpcId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateNatGateway"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateNatGatewayResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Before you call this operation, take note of the following items:
 * *   When you create an enhanced NAT gateway for the first time, the system automatically creates the service-linked role AliyunServiceRoleForNatgw. Then, the system attaches the permission policy AliyunServiceRolePolicyForNatgw to the role. This allows the NAT gateway to access other resources on Alibaba Cloud. For more information, see [Service-linked roles](~~174251~~).
 * *   After you create an enhanced Internet NAT gateway, a route entry is automatically added to the route table of the VPC. The destination CIDR block of the route entry is 0.0.0.0/0 and the next hop is the NAT gateway. This ensures that traffic is routed to the NAT gateway.
 * *   **CreateNatGateway** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeNatGateways](~~36054~~) operation to query the status of a NAT gateway.
 *     *   If a NAT gateway is in the **Creating** state, the NAT gateway is being created. In this case, you can query the NAT gateway but cannot perform other operations.
 *     *   If a NAT gateway is in the **Available** state, the NAT gateway is created.
 *         It takes 1 to 3 minutes to create a NAT gateway.
 * *   You cannot repeatedly call the **CreateNatGateway** operation to create a VPC NAT gateway or an Internet NAT gateway within the specified period of time.
 *
 * @param request CreateNatGatewayRequest
 * @return CreateNatGatewayResponse
 */
func (client *Client) CreateNatGateway(request *CreateNatGatewayRequest) (_result *CreateNatGatewayResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateNatGatewayResponse{}
	_body, _err := client.CreateNatGatewayWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * **CreateNatIp** is an asynchronous operation. After you make a request, the ID of the request is returned but the NAT IP address is not created. The system creates the NAT IP address in the background. You can call the [ListNatIps](~~287000~~) operation to query the status of a NAT IP address.
 * *   If a NAT IP address is in the **Creating** state, the NAT IP address is being created. In this case, you can only query the NAT IP address but cannot perform other operations.
 * *   If a NAT IP address is in the **Available** state, the NAT IP address is created.
 * You cannot repeatedly call the **CreateNatIp** operation to create a NAT IP address within the specified period of time.
 *
 * @param request CreateNatIpRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateNatIpResponse
 */
func (client *Client) CreateNatIpWithOptions(request *CreateNatIpRequest, runtime *util.RuntimeOptions) (_result *CreateNatIpResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.NatGatewayId)) {
		query["NatGatewayId"] = request.NatGatewayId
	}

	if !tea.BoolValue(util.IsUnset(request.NatIp)) {
		query["NatIp"] = request.NatIp
	}

	if !tea.BoolValue(util.IsUnset(request.NatIpCidr)) {
		query["NatIpCidr"] = request.NatIpCidr
	}

	if !tea.BoolValue(util.IsUnset(request.NatIpDescription)) {
		query["NatIpDescription"] = request.NatIpDescription
	}

	if !tea.BoolValue(util.IsUnset(request.NatIpName)) {
		query["NatIpName"] = request.NatIpName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateNatIp"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateNatIpResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * **CreateNatIp** is an asynchronous operation. After you make a request, the ID of the request is returned but the NAT IP address is not created. The system creates the NAT IP address in the background. You can call the [ListNatIps](~~287000~~) operation to query the status of a NAT IP address.
 * *   If a NAT IP address is in the **Creating** state, the NAT IP address is being created. In this case, you can only query the NAT IP address but cannot perform other operations.
 * *   If a NAT IP address is in the **Available** state, the NAT IP address is created.
 * You cannot repeatedly call the **CreateNatIp** operation to create a NAT IP address within the specified period of time.
 *
 * @param request CreateNatIpRequest
 * @return CreateNatIpResponse
 */
func (client *Client) CreateNatIp(request *CreateNatIpRequest) (_result *CreateNatIpResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateNatIpResponse{}
	_body, _err := client.CreateNatIpWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You cannot repeatedly call the **CreateNatIpCidr** operation to create a NAT CIDR block within the specified period of time.
 *
 * @param request CreateNatIpCidrRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateNatIpCidrResponse
 */
func (client *Client) CreateNatIpCidrWithOptions(request *CreateNatIpCidrRequest, runtime *util.RuntimeOptions) (_result *CreateNatIpCidrResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.NatGatewayId)) {
		query["NatGatewayId"] = request.NatGatewayId
	}

	if !tea.BoolValue(util.IsUnset(request.NatIpCidr)) {
		query["NatIpCidr"] = request.NatIpCidr
	}

	if !tea.BoolValue(util.IsUnset(request.NatIpCidrDescription)) {
		query["NatIpCidrDescription"] = request.NatIpCidrDescription
	}

	if !tea.BoolValue(util.IsUnset(request.NatIpCidrName)) {
		query["NatIpCidrName"] = request.NatIpCidrName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateNatIpCidr"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateNatIpCidrResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You cannot repeatedly call the **CreateNatIpCidr** operation to create a NAT CIDR block within the specified period of time.
 *
 * @param request CreateNatIpCidrRequest
 * @return CreateNatIpCidrResponse
 */
func (client *Client) CreateNatIpCidr(request *CreateNatIpCidrRequest) (_result *CreateNatIpCidrResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateNatIpCidrResponse{}
	_body, _err := client.CreateNatIpCidrWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateNetworkAclWithOptions(request *CreateNetworkAclRequest, runtime *util.RuntimeOptions) (_result *CreateNetworkAclResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.NetworkAclName)) {
		query["NetworkAclName"] = request.NetworkAclName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	if !tea.BoolValue(util.IsUnset(request.VpcId)) {
		query["VpcId"] = request.VpcId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateNetworkAcl"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateNetworkAclResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateNetworkAcl(request *CreateNetworkAclRequest) (_result *CreateNetworkAclResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateNetworkAclResponse{}
	_body, _err := client.CreateNetworkAclWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can apply for a dedicated Express Connect circuit for yourself or create a hosted connection for a tenant. After your application is approved, the Express Connect circuit changes to the **Initial** state. You can contact the connectivity provider to start construction.
 * When you call this operation, take note of the following limits:
 * *   If your Alibaba Cloud account has more than five Express Connect circuits that are not in the **Enabled** state, you cannot apply for another Express Connect circuit.
 * *   If your Alibaba Cloud account has an Express Connect circuit with overdue payments, you cannot apply for another Express Connect circuit.
 *
 * @param request CreatePhysicalConnectionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreatePhysicalConnectionResponse
 */
func (client *Client) CreatePhysicalConnectionWithOptions(request *CreatePhysicalConnectionRequest, runtime *util.RuntimeOptions) (_result *CreatePhysicalConnectionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AccessPointId)) {
		query["AccessPointId"] = request.AccessPointId
	}

	if !tea.BoolValue(util.IsUnset(request.CircuitCode)) {
		query["CircuitCode"] = request.CircuitCode
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.LineOperator)) {
		query["LineOperator"] = request.LineOperator
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PeerLocation)) {
		query["PeerLocation"] = request.PeerLocation
	}

	if !tea.BoolValue(util.IsUnset(request.PortType)) {
		query["PortType"] = request.PortType
	}

	if !tea.BoolValue(util.IsUnset(request.RedundantPhysicalConnectionId)) {
		query["RedundantPhysicalConnectionId"] = request.RedundantPhysicalConnectionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	if !tea.BoolValue(util.IsUnset(request.Bandwidth)) {
		query["bandwidth"] = request.Bandwidth
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreatePhysicalConnection"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreatePhysicalConnectionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can apply for a dedicated Express Connect circuit for yourself or create a hosted connection for a tenant. After your application is approved, the Express Connect circuit changes to the **Initial** state. You can contact the connectivity provider to start construction.
 * When you call this operation, take note of the following limits:
 * *   If your Alibaba Cloud account has more than five Express Connect circuits that are not in the **Enabled** state, you cannot apply for another Express Connect circuit.
 * *   If your Alibaba Cloud account has an Express Connect circuit with overdue payments, you cannot apply for another Express Connect circuit.
 *
 * @param request CreatePhysicalConnectionRequest
 * @return CreatePhysicalConnectionResponse
 */
func (client *Client) CreatePhysicalConnection(request *CreatePhysicalConnectionRequest) (_result *CreatePhysicalConnectionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreatePhysicalConnectionResponse{}
	_body, _err := client.CreatePhysicalConnectionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * >  You can call this operation only when the Express Connect circuit is in the **Complete** state.
 *
 * @param request CreatePhysicalConnectionOccupancyOrderRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreatePhysicalConnectionOccupancyOrderResponse
 */
func (client *Client) CreatePhysicalConnectionOccupancyOrderWithOptions(request *CreatePhysicalConnectionOccupancyOrderRequest, runtime *util.RuntimeOptions) (_result *CreatePhysicalConnectionOccupancyOrderResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AutoPay)) {
		query["AutoPay"] = request.AutoPay
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceChargeType)) {
		query["InstanceChargeType"] = request.InstanceChargeType
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Period)) {
		query["Period"] = request.Period
	}

	if !tea.BoolValue(util.IsUnset(request.PhysicalConnectionId)) {
		query["PhysicalConnectionId"] = request.PhysicalConnectionId
	}

	if !tea.BoolValue(util.IsUnset(request.PricingCycle)) {
		query["PricingCycle"] = request.PricingCycle
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreatePhysicalConnectionOccupancyOrder"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreatePhysicalConnectionOccupancyOrderResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * >  You can call this operation only when the Express Connect circuit is in the **Complete** state.
 *
 * @param request CreatePhysicalConnectionOccupancyOrderRequest
 * @return CreatePhysicalConnectionOccupancyOrderResponse
 */
func (client *Client) CreatePhysicalConnectionOccupancyOrder(request *CreatePhysicalConnectionOccupancyOrderRequest) (_result *CreatePhysicalConnectionOccupancyOrderResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreatePhysicalConnectionOccupancyOrderResponse{}
	_body, _err := client.CreatePhysicalConnectionOccupancyOrderWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreatePhysicalConnectionSetupOrderWithOptions(request *CreatePhysicalConnectionSetupOrderRequest, runtime *util.RuntimeOptions) (_result *CreatePhysicalConnectionSetupOrderResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AccessPointId)) {
		query["AccessPointId"] = request.AccessPointId
	}

	if !tea.BoolValue(util.IsUnset(request.AutoPay)) {
		query["AutoPay"] = request.AutoPay
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.LineOperator)) {
		query["LineOperator"] = request.LineOperator
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PortType)) {
		query["PortType"] = request.PortType
	}

	if !tea.BoolValue(util.IsUnset(request.RedundantPhysicalConnectionId)) {
		query["RedundantPhysicalConnectionId"] = request.RedundantPhysicalConnectionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreatePhysicalConnectionSetupOrder"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreatePhysicalConnectionSetupOrderResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreatePhysicalConnectionSetupOrder(request *CreatePhysicalConnectionSetupOrderRequest) (_result *CreatePhysicalConnectionSetupOrderResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreatePhysicalConnectionSetupOrderResponse{}
	_body, _err := client.CreatePhysicalConnectionSetupOrderWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * By default, the IP address pool feature is unavailable. You can apply for the privilege to use the **IP address pool feature** on the Quota Center page. For more information, see [Request a quota increase in the Quota Center console](~~108213~~).
 *
 * @param request CreatePublicIpAddressPoolRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreatePublicIpAddressPoolResponse
 */
func (client *Client) CreatePublicIpAddressPoolWithOptions(request *CreatePublicIpAddressPoolRequest, runtime *util.RuntimeOptions) (_result *CreatePublicIpAddressPoolResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.Isp)) {
		query["Isp"] = request.Isp
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreatePublicIpAddressPool"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreatePublicIpAddressPoolResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * By default, the IP address pool feature is unavailable. You can apply for the privilege to use the **IP address pool feature** on the Quota Center page. For more information, see [Request a quota increase in the Quota Center console](~~108213~~).
 *
 * @param request CreatePublicIpAddressPoolRequest
 * @return CreatePublicIpAddressPoolResponse
 */
func (client *Client) CreatePublicIpAddressPool(request *CreatePublicIpAddressPoolRequest) (_result *CreatePublicIpAddressPoolResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreatePublicIpAddressPoolResponse{}
	_body, _err := client.CreatePublicIpAddressPoolWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   **CreateRouteEntries** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeRouteEntryList](~~138148~~) operation to query the status of a route entry:
 *     *   If the route entry is in the **Creating** state, the route entry is being created.
 *     *   If the route entry is in the **Created** state, the route entry is created.
 * *   You cannot repeatedly call the **CreateRouteEntries** operation to create the same route entry within the specified period of time.
 * **When you call this operation to add custom route entries to the route table of a vRouter, take note of the following items:**
 * *   A route table can contain up to 200 custom route entries.
 * *   The destination CIDR block (**DstCidrBlock**) of a custom route entry cannot be the same as or overlap with the CIDR block of a vSwitch in the virtual private cloud (VPC).
 * *   The destination CIDR block (**DstCidrBlock**) of a custom route entry cannot be 100.64.0.0/10 or its subnets.
 * *   The destination CIDR blocks (**DstCidrBlock**) of route entries in the same route table must be unique.
 * *   If you do not include the mask length when you specify the destination CIDR block (**DstCidrBlock**), the destination CIDR block is considered a host IP address whose mask length is 32 bits.
 * *   Multiple custom route entries can point to the same next hop (**NextHop**).
 * *   The next hop (**NextHop**) of a custom route entry must belong to the same VPC as the route table.
 *
 * @param request CreateRouteEntriesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateRouteEntriesResponse
 */
func (client *Client) CreateRouteEntriesWithOptions(request *CreateRouteEntriesRequest, runtime *util.RuntimeOptions) (_result *CreateRouteEntriesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RouteEntries)) {
		query["RouteEntries"] = request.RouteEntries
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateRouteEntries"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateRouteEntriesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   **CreateRouteEntries** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeRouteEntryList](~~138148~~) operation to query the status of a route entry:
 *     *   If the route entry is in the **Creating** state, the route entry is being created.
 *     *   If the route entry is in the **Created** state, the route entry is created.
 * *   You cannot repeatedly call the **CreateRouteEntries** operation to create the same route entry within the specified period of time.
 * **When you call this operation to add custom route entries to the route table of a vRouter, take note of the following items:**
 * *   A route table can contain up to 200 custom route entries.
 * *   The destination CIDR block (**DstCidrBlock**) of a custom route entry cannot be the same as or overlap with the CIDR block of a vSwitch in the virtual private cloud (VPC).
 * *   The destination CIDR block (**DstCidrBlock**) of a custom route entry cannot be 100.64.0.0/10 or its subnets.
 * *   The destination CIDR blocks (**DstCidrBlock**) of route entries in the same route table must be unique.
 * *   If you do not include the mask length when you specify the destination CIDR block (**DstCidrBlock**), the destination CIDR block is considered a host IP address whose mask length is 32 bits.
 * *   Multiple custom route entries can point to the same next hop (**NextHop**).
 * *   The next hop (**NextHop**) of a custom route entry must belong to the same VPC as the route table.
 *
 * @param request CreateRouteEntriesRequest
 * @return CreateRouteEntriesResponse
 */
func (client *Client) CreateRouteEntries(request *CreateRouteEntriesRequest) (_result *CreateRouteEntriesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateRouteEntriesResponse{}
	_body, _err := client.CreateRouteEntriesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   **CreateRouteEntry** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeRouteEntryList](~~138148~~) operation to query the status of a route entry.
 *     *   If the route entry is in the **Creating** state, the route entry is being created.
 *     *   If the route entry is in the **Created** state, the route entry is created.
 * *   You cannot repeatedly call the **CreateRouteEntry** operation to add a custom route entry to the route table of a vRouter or a VBR within the specified period of time.
 * **When you call this operation to add a custom route entry to the route table of a vRouter, take note of the following limits:**
 * *   A route table can contain up to 200 custom route entries.
 * *   The destination CIDR block (**DestinationCidrBlock**) of a custom route entry cannot be the same as or overlap with the CIDR block of a vSwitch in the virtual private cloud (VPC).
 * *   The destination CIDR block (**DestinationCidrBlock**) of a custom route entry cannot be 100.64.0.0/10 or a subset of it.
 * *   The destination CIDR blocks (**DestinationCidrBlock**) of route entries in the same route table must be unique.
 * *   If you do not include the mask length when you specify the destination CIDR block (**DestinationCidrBlock**), the destination CIDR block is considered a host IP address whose mask length is 32 bits.
 * *   Multiple custom route entries can point to the same next hop (**NextHopId**).
 * *   The next hop (**NextHopId**) of a custom route entry must belong to the same VPC as the route table.
 * *   Equal-cost multi-path (ECMP) routing can be configured by specifying the **NextHopList** parameter.
 *     *   When you add non-ECMP route entries, you must specify **DestinationCidrBlock**, **NextHopType**, and **NextHopId**, and you must not specify **NextHopList**.
 *     *   When you add route entries for ECMP routing, you must specify **DestinationCidrBlock** and **NextHopList**, and you must not specify **NextHopType** or **NextHopId**.
 * **When you call this operation to add a custom route entry to the route table of a VBR, take note of the following limits:**
 * *   A route table can contain up to 200 custom route entries.
 * *   The **NextHopList** parameter is not supported.
 * *   The destination CIDR block (**DestinationCidrBlock**) of a custom route entry cannot be 100.64.0.0/10 or a subset of it.
 * *   The destination CIDR blocks (**DestinationCidrBlock**) of route entries in the same route table must be unique.
 * *   If you do not include the mask length when you specify the destination CIDR block (**DestinationCidrBlock**), the destination CIDR block is considered a host IP address whose mask length is 32 bits.
 * *   Multiple custom route entries can point to the same next hop (**NextHopId**).
 * *   The next hop (**NextHopId**) of a custom route entry must be a router interface associated with the VBR.
 * *   You can add route entries only when the VBR is in the **Active** state, and the Express Connect circuit associated with the VBR is in the **Enabled** state and is not locked due to overdue payments.
 * *   Only non-ECMP route entries are supported. When you add non-ECMP route entries, you must specify **DestinationCidrBlock**, **NextHopType**, and **NextHopId**, and you cannot specify **NextHopList**.
 *
 * @param request CreateRouteEntryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateRouteEntryResponse
 */
func (client *Client) CreateRouteEntryWithOptions(request *CreateRouteEntryRequest, runtime *util.RuntimeOptions) (_result *CreateRouteEntryResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.DestinationCidrBlock)) {
		query["DestinationCidrBlock"] = request.DestinationCidrBlock
	}

	if !tea.BoolValue(util.IsUnset(request.NextHopId)) {
		query["NextHopId"] = request.NextHopId
	}

	if !tea.BoolValue(util.IsUnset(request.NextHopList)) {
		query["NextHopList"] = request.NextHopList
	}

	if !tea.BoolValue(util.IsUnset(request.NextHopType)) {
		query["NextHopType"] = request.NextHopType
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RouteEntryName)) {
		query["RouteEntryName"] = request.RouteEntryName
	}

	if !tea.BoolValue(util.IsUnset(request.RouteTableId)) {
		query["RouteTableId"] = request.RouteTableId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateRouteEntry"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateRouteEntryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   **CreateRouteEntry** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeRouteEntryList](~~138148~~) operation to query the status of a route entry.
 *     *   If the route entry is in the **Creating** state, the route entry is being created.
 *     *   If the route entry is in the **Created** state, the route entry is created.
 * *   You cannot repeatedly call the **CreateRouteEntry** operation to add a custom route entry to the route table of a vRouter or a VBR within the specified period of time.
 * **When you call this operation to add a custom route entry to the route table of a vRouter, take note of the following limits:**
 * *   A route table can contain up to 200 custom route entries.
 * *   The destination CIDR block (**DestinationCidrBlock**) of a custom route entry cannot be the same as or overlap with the CIDR block of a vSwitch in the virtual private cloud (VPC).
 * *   The destination CIDR block (**DestinationCidrBlock**) of a custom route entry cannot be 100.64.0.0/10 or a subset of it.
 * *   The destination CIDR blocks (**DestinationCidrBlock**) of route entries in the same route table must be unique.
 * *   If you do not include the mask length when you specify the destination CIDR block (**DestinationCidrBlock**), the destination CIDR block is considered a host IP address whose mask length is 32 bits.
 * *   Multiple custom route entries can point to the same next hop (**NextHopId**).
 * *   The next hop (**NextHopId**) of a custom route entry must belong to the same VPC as the route table.
 * *   Equal-cost multi-path (ECMP) routing can be configured by specifying the **NextHopList** parameter.
 *     *   When you add non-ECMP route entries, you must specify **DestinationCidrBlock**, **NextHopType**, and **NextHopId**, and you must not specify **NextHopList**.
 *     *   When you add route entries for ECMP routing, you must specify **DestinationCidrBlock** and **NextHopList**, and you must not specify **NextHopType** or **NextHopId**.
 * **When you call this operation to add a custom route entry to the route table of a VBR, take note of the following limits:**
 * *   A route table can contain up to 200 custom route entries.
 * *   The **NextHopList** parameter is not supported.
 * *   The destination CIDR block (**DestinationCidrBlock**) of a custom route entry cannot be 100.64.0.0/10 or a subset of it.
 * *   The destination CIDR blocks (**DestinationCidrBlock**) of route entries in the same route table must be unique.
 * *   If you do not include the mask length when you specify the destination CIDR block (**DestinationCidrBlock**), the destination CIDR block is considered a host IP address whose mask length is 32 bits.
 * *   Multiple custom route entries can point to the same next hop (**NextHopId**).
 * *   The next hop (**NextHopId**) of a custom route entry must be a router interface associated with the VBR.
 * *   You can add route entries only when the VBR is in the **Active** state, and the Express Connect circuit associated with the VBR is in the **Enabled** state and is not locked due to overdue payments.
 * *   Only non-ECMP route entries are supported. When you add non-ECMP route entries, you must specify **DestinationCidrBlock**, **NextHopType**, and **NextHopId**, and you cannot specify **NextHopList**.
 *
 * @param request CreateRouteEntryRequest
 * @return CreateRouteEntryResponse
 */
func (client *Client) CreateRouteEntry(request *CreateRouteEntryRequest) (_result *CreateRouteEntryResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateRouteEntryResponse{}
	_body, _err := client.CreateRouteEntryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   The **CreateRouteTable** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeRouteTableList](~~87602~~) operation to query the status of a custom route table:
 *     *   If the custom route table is in the **Creating** state, the custom route table is being created.
 *     *   If the custom route table is in the **Created** state, the custom route table is created.
 * *   You cannot repeatedly call the **CreateRouteTable** operation to create a custom route table within the specified period of time.
 *
 * @param request CreateRouteTableRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateRouteTableResponse
 */
func (client *Client) CreateRouteTableWithOptions(request *CreateRouteTableRequest, runtime *util.RuntimeOptions) (_result *CreateRouteTableResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AssociateType)) {
		query["AssociateType"] = request.AssociateType
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RouteTableName)) {
		query["RouteTableName"] = request.RouteTableName
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	if !tea.BoolValue(util.IsUnset(request.VpcId)) {
		query["VpcId"] = request.VpcId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateRouteTable"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateRouteTableResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   The **CreateRouteTable** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeRouteTableList](~~87602~~) operation to query the status of a custom route table:
 *     *   If the custom route table is in the **Creating** state, the custom route table is being created.
 *     *   If the custom route table is in the **Created** state, the custom route table is created.
 * *   You cannot repeatedly call the **CreateRouteTable** operation to create a custom route table within the specified period of time.
 *
 * @param request CreateRouteTableRequest
 * @return CreateRouteTableResponse
 */
func (client *Client) CreateRouteTable(request *CreateRouteTableRequest) (_result *CreateRouteTableResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateRouteTableResponse{}
	_body, _err := client.CreateRouteTableWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * When you call this operation, take note of the following limits:
 * *   You can create only one pair of interfaces to be connected between two routers.
 * *   You can create a maximum of five router interfaces for a router.
 * *   If your Alibaba Cloud account has a router interface with overdue payments, you cannot create new router interfaces.
 * *   Each destination CIDR block of route entries in the same route table must be unique.
 * *   A virtual border router (VBR) can serve only as a requester. The VBR must be in the Activated state.
 * *   You can call this operation to create subscription and pay-as-you-go router interfaces.
 *
 * @param request CreateRouterInterfaceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateRouterInterfaceResponse
 */
func (client *Client) CreateRouterInterfaceWithOptions(request *CreateRouterInterfaceRequest, runtime *util.RuntimeOptions) (_result *CreateRouterInterfaceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AccessPointId)) {
		query["AccessPointId"] = request.AccessPointId
	}

	if !tea.BoolValue(util.IsUnset(request.AutoPay)) {
		query["AutoPay"] = request.AutoPay
	}

	if !tea.BoolValue(util.IsUnset(request.AutoRenew)) {
		query["AutoRenew"] = request.AutoRenew
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.FastLinkMode)) {
		query["FastLinkMode"] = request.FastLinkMode
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckSourceIp)) {
		query["HealthCheckSourceIp"] = request.HealthCheckSourceIp
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckTargetIp)) {
		query["HealthCheckTargetIp"] = request.HealthCheckTargetIp
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceChargeType)) {
		query["InstanceChargeType"] = request.InstanceChargeType
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.OppositeAccessPointId)) {
		query["OppositeAccessPointId"] = request.OppositeAccessPointId
	}

	if !tea.BoolValue(util.IsUnset(request.OppositeInterfaceId)) {
		query["OppositeInterfaceId"] = request.OppositeInterfaceId
	}

	if !tea.BoolValue(util.IsUnset(request.OppositeInterfaceOwnerId)) {
		query["OppositeInterfaceOwnerId"] = request.OppositeInterfaceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.OppositeRegionId)) {
		query["OppositeRegionId"] = request.OppositeRegionId
	}

	if !tea.BoolValue(util.IsUnset(request.OppositeRouterId)) {
		query["OppositeRouterId"] = request.OppositeRouterId
	}

	if !tea.BoolValue(util.IsUnset(request.OppositeRouterType)) {
		query["OppositeRouterType"] = request.OppositeRouterType
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Period)) {
		query["Period"] = request.Period
	}

	if !tea.BoolValue(util.IsUnset(request.PricingCycle)) {
		query["PricingCycle"] = request.PricingCycle
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Role)) {
		query["Role"] = request.Role
	}

	if !tea.BoolValue(util.IsUnset(request.RouterId)) {
		query["RouterId"] = request.RouterId
	}

	if !tea.BoolValue(util.IsUnset(request.RouterType)) {
		query["RouterType"] = request.RouterType
	}

	if !tea.BoolValue(util.IsUnset(request.Spec)) {
		query["Spec"] = request.Spec
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateRouterInterface"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateRouterInterfaceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * When you call this operation, take note of the following limits:
 * *   You can create only one pair of interfaces to be connected between two routers.
 * *   You can create a maximum of five router interfaces for a router.
 * *   If your Alibaba Cloud account has a router interface with overdue payments, you cannot create new router interfaces.
 * *   Each destination CIDR block of route entries in the same route table must be unique.
 * *   A virtual border router (VBR) can serve only as a requester. The VBR must be in the Activated state.
 * *   You can call this operation to create subscription and pay-as-you-go router interfaces.
 *
 * @param request CreateRouterInterfaceRequest
 * @return CreateRouterInterfaceResponse
 */
func (client *Client) CreateRouterInterface(request *CreateRouterInterfaceRequest) (_result *CreateRouterInterfaceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateRouterInterfaceResponse{}
	_body, _err := client.CreateRouterInterfaceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call this operation to add SNAT entries to Internet NAT gateways and Virtual Private Cloud (VPC) NAT gateways. In this topic, a NAT gateway refers to both gateway types.
 * Before you call this operation, take note of the following limits:
 * *   **CreateSnatEntry** is an asynchronous operation. After you make a request, an SNAT entry ID is returned but the specified SNAT entry is not added. The system adds the entry in the background. You can call the [DescribeSnatTableEntries](~~42677~~) operation to query the status of the SNAT entry.
 *     *   If the SNAT entry is in the **Pending** state, the system is adding the SNAT entry. You can only query the status of the SNAT entry, but cannot perform other operations.
 *     *   If the SNAT entry is in the **Available** state, the SNAT entry is added.
 * *   You cannot repeatedly call the **CreateSnatEntry** operation to add an SNAT entry to an SNAT table within the specified period of time.
 * *   The vSwitch and Elastic Compute Service (ECS) instance specified in an SNAT entry must be created in the virtual private cloud (VPC) where the NAT gateway is deployed.
 * *   Each vSwitch or ECS instance can be specified in only one SNAT entry.
 * *   If a high-availability virtual IP address (HAVIP) exists in a vSwitch, you cannot create SNAT entries.
 *
 * @param request CreateSnatEntryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateSnatEntryResponse
 */
func (client *Client) CreateSnatEntryWithOptions(request *CreateSnatEntryRequest, runtime *util.RuntimeOptions) (_result *CreateSnatEntryResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.EipAffinity)) {
		query["EipAffinity"] = request.EipAffinity
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SnatEntryName)) {
		query["SnatEntryName"] = request.SnatEntryName
	}

	if !tea.BoolValue(util.IsUnset(request.SnatIp)) {
		query["SnatIp"] = request.SnatIp
	}

	if !tea.BoolValue(util.IsUnset(request.SnatTableId)) {
		query["SnatTableId"] = request.SnatTableId
	}

	if !tea.BoolValue(util.IsUnset(request.SourceCIDR)) {
		query["SourceCIDR"] = request.SourceCIDR
	}

	if !tea.BoolValue(util.IsUnset(request.SourceVSwitchId)) {
		query["SourceVSwitchId"] = request.SourceVSwitchId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateSnatEntry"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateSnatEntryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call this operation to add SNAT entries to Internet NAT gateways and Virtual Private Cloud (VPC) NAT gateways. In this topic, a NAT gateway refers to both gateway types.
 * Before you call this operation, take note of the following limits:
 * *   **CreateSnatEntry** is an asynchronous operation. After you make a request, an SNAT entry ID is returned but the specified SNAT entry is not added. The system adds the entry in the background. You can call the [DescribeSnatTableEntries](~~42677~~) operation to query the status of the SNAT entry.
 *     *   If the SNAT entry is in the **Pending** state, the system is adding the SNAT entry. You can only query the status of the SNAT entry, but cannot perform other operations.
 *     *   If the SNAT entry is in the **Available** state, the SNAT entry is added.
 * *   You cannot repeatedly call the **CreateSnatEntry** operation to add an SNAT entry to an SNAT table within the specified period of time.
 * *   The vSwitch and Elastic Compute Service (ECS) instance specified in an SNAT entry must be created in the virtual private cloud (VPC) where the NAT gateway is deployed.
 * *   Each vSwitch or ECS instance can be specified in only one SNAT entry.
 * *   If a high-availability virtual IP address (HAVIP) exists in a vSwitch, you cannot create SNAT entries.
 *
 * @param request CreateSnatEntryRequest
 * @return CreateSnatEntryResponse
 */
func (client *Client) CreateSnatEntry(request *CreateSnatEntryRequest) (_result *CreateSnatEntryResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateSnatEntryResponse{}
	_body, _err := client.CreateSnatEntryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateSslVpnClientCertWithOptions(request *CreateSslVpnClientCertRequest, runtime *util.RuntimeOptions) (_result *CreateSslVpnClientCertResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SslVpnServerId)) {
		query["SslVpnServerId"] = request.SslVpnServerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateSslVpnClientCert"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateSslVpnClientCertResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateSslVpnClientCert(request *CreateSslVpnClientCertRequest) (_result *CreateSslVpnClientCertResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateSslVpnClientCertResponse{}
	_body, _err := client.CreateSslVpnClientCertWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   The **CreateSslVpnServer** operation is asynchronous. After you send the request, the system returns a request ID, but the operation is still being performed in the system background. You can call the [DescribeVpnGateway](~~73720~~) operation to query the status of the associated VPN gateway and determine whether the SSL server is created.
 *     *   If the VPN gateway is in the **updating** state, the SSL server is being created.
 *     *   If the VPN gateway is in the **active** state, the SSL server is created.
 * *   You cannot repeatedly call the **CreateSslVpnServer** operation for the same VPN gateway within the specified period of time.
 *
 * @param request CreateSslVpnServerRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateSslVpnServerResponse
 */
func (client *Client) CreateSslVpnServerWithOptions(request *CreateSslVpnServerRequest, runtime *util.RuntimeOptions) (_result *CreateSslVpnServerResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Cipher)) {
		query["Cipher"] = request.Cipher
	}

	if !tea.BoolValue(util.IsUnset(request.ClientIpPool)) {
		query["ClientIpPool"] = request.ClientIpPool
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Compress)) {
		query["Compress"] = request.Compress
	}

	if !tea.BoolValue(util.IsUnset(request.EnableMultiFactorAuth)) {
		query["EnableMultiFactorAuth"] = request.EnableMultiFactorAuth
	}

	if !tea.BoolValue(util.IsUnset(request.IDaaSInstanceId)) {
		query["IDaaSInstanceId"] = request.IDaaSInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.IDaaSRegionId)) {
		query["IDaaSRegionId"] = request.IDaaSRegionId
	}

	if !tea.BoolValue(util.IsUnset(request.LocalSubnet)) {
		query["LocalSubnet"] = request.LocalSubnet
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Port)) {
		query["Port"] = request.Port
	}

	if !tea.BoolValue(util.IsUnset(request.Proto)) {
		query["Proto"] = request.Proto
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.VpnGatewayId)) {
		query["VpnGatewayId"] = request.VpnGatewayId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateSslVpnServer"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateSslVpnServerResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   The **CreateSslVpnServer** operation is asynchronous. After you send the request, the system returns a request ID, but the operation is still being performed in the system background. You can call the [DescribeVpnGateway](~~73720~~) operation to query the status of the associated VPN gateway and determine whether the SSL server is created.
 *     *   If the VPN gateway is in the **updating** state, the SSL server is being created.
 *     *   If the VPN gateway is in the **active** state, the SSL server is created.
 * *   You cannot repeatedly call the **CreateSslVpnServer** operation for the same VPN gateway within the specified period of time.
 *
 * @param request CreateSslVpnServerRequest
 * @return CreateSslVpnServerResponse
 */
func (client *Client) CreateSslVpnServer(request *CreateSslVpnServerRequest) (_result *CreateSslVpnServerResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateSslVpnServerResponse{}
	_body, _err := client.CreateSslVpnServerWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * **CreateTrafficMirrorFilter** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [ListTrafficMirrorFilters](~~261353~~) operation to query the status of a filter.
 * *   If the filter is in the **Creating** state, the filter is being created.
 * *   If the filter is in the **Created** state, the filter is created.
 *
 * @param request CreateTrafficMirrorFilterRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateTrafficMirrorFilterResponse
 */
func (client *Client) CreateTrafficMirrorFilterWithOptions(request *CreateTrafficMirrorFilterRequest, runtime *util.RuntimeOptions) (_result *CreateTrafficMirrorFilterResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.EgressRules)) {
		query["EgressRules"] = request.EgressRules
	}

	if !tea.BoolValue(util.IsUnset(request.IngressRules)) {
		query["IngressRules"] = request.IngressRules
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	if !tea.BoolValue(util.IsUnset(request.TrafficMirrorFilterDescription)) {
		query["TrafficMirrorFilterDescription"] = request.TrafficMirrorFilterDescription
	}

	if !tea.BoolValue(util.IsUnset(request.TrafficMirrorFilterName)) {
		query["TrafficMirrorFilterName"] = request.TrafficMirrorFilterName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateTrafficMirrorFilter"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateTrafficMirrorFilterResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * **CreateTrafficMirrorFilter** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [ListTrafficMirrorFilters](~~261353~~) operation to query the status of a filter.
 * *   If the filter is in the **Creating** state, the filter is being created.
 * *   If the filter is in the **Created** state, the filter is created.
 *
 * @param request CreateTrafficMirrorFilterRequest
 * @return CreateTrafficMirrorFilterResponse
 */
func (client *Client) CreateTrafficMirrorFilter(request *CreateTrafficMirrorFilterRequest) (_result *CreateTrafficMirrorFilterResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateTrafficMirrorFilterResponse{}
	_body, _err := client.CreateTrafficMirrorFilterWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   The **CreateTrafficMirrorFilterRules** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [ListTrafficMirrorFilters](~~261353~~) operation to query the status of an inbound or outbound rule:
 *     *   If the rule is in the **Creating** state, the rule is being created.
 *     *   If the rule is in the **Created** state, the rule is created.
 * *   You cannot repeatedly call the **CreateTrafficMirrorFilterRules** operation to create an inbound or outbound rule for a traffic mirroring filter.
 *
 * @param request CreateTrafficMirrorFilterRulesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateTrafficMirrorFilterRulesResponse
 */
func (client *Client) CreateTrafficMirrorFilterRulesWithOptions(request *CreateTrafficMirrorFilterRulesRequest, runtime *util.RuntimeOptions) (_result *CreateTrafficMirrorFilterRulesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.EgressRules)) {
		query["EgressRules"] = request.EgressRules
	}

	if !tea.BoolValue(util.IsUnset(request.IngressRules)) {
		query["IngressRules"] = request.IngressRules
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.TrafficMirrorFilterId)) {
		query["TrafficMirrorFilterId"] = request.TrafficMirrorFilterId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateTrafficMirrorFilterRules"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateTrafficMirrorFilterRulesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   The **CreateTrafficMirrorFilterRules** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [ListTrafficMirrorFilters](~~261353~~) operation to query the status of an inbound or outbound rule:
 *     *   If the rule is in the **Creating** state, the rule is being created.
 *     *   If the rule is in the **Created** state, the rule is created.
 * *   You cannot repeatedly call the **CreateTrafficMirrorFilterRules** operation to create an inbound or outbound rule for a traffic mirroring filter.
 *
 * @param request CreateTrafficMirrorFilterRulesRequest
 * @return CreateTrafficMirrorFilterRulesResponse
 */
func (client *Client) CreateTrafficMirrorFilterRules(request *CreateTrafficMirrorFilterRulesRequest) (_result *CreateTrafficMirrorFilterRulesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateTrafficMirrorFilterRulesResponse{}
	_body, _err := client.CreateTrafficMirrorFilterRulesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * **CreateTrafficMirrorSession** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [ListTrafficMirrorSessions](~~261367~~) operation to query the status of a traffic mirror session:
 * *   If the traffic mirror session is in the **Creating** state, the traffic mirror session is being created.
 * *   If the traffic mirror session is in the **Created** state, the traffic mirror session is created.
 *
 * @param request CreateTrafficMirrorSessionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateTrafficMirrorSessionResponse
 */
func (client *Client) CreateTrafficMirrorSessionWithOptions(request *CreateTrafficMirrorSessionRequest, runtime *util.RuntimeOptions) (_result *CreateTrafficMirrorSessionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.Enabled)) {
		query["Enabled"] = request.Enabled
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PacketLength)) {
		query["PacketLength"] = request.PacketLength
	}

	if !tea.BoolValue(util.IsUnset(request.Priority)) {
		query["Priority"] = request.Priority
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	if !tea.BoolValue(util.IsUnset(request.TrafficMirrorFilterId)) {
		query["TrafficMirrorFilterId"] = request.TrafficMirrorFilterId
	}

	if !tea.BoolValue(util.IsUnset(request.TrafficMirrorSessionDescription)) {
		query["TrafficMirrorSessionDescription"] = request.TrafficMirrorSessionDescription
	}

	if !tea.BoolValue(util.IsUnset(request.TrafficMirrorSessionName)) {
		query["TrafficMirrorSessionName"] = request.TrafficMirrorSessionName
	}

	if !tea.BoolValue(util.IsUnset(request.TrafficMirrorSourceIds)) {
		query["TrafficMirrorSourceIds"] = request.TrafficMirrorSourceIds
	}

	if !tea.BoolValue(util.IsUnset(request.TrafficMirrorTargetId)) {
		query["TrafficMirrorTargetId"] = request.TrafficMirrorTargetId
	}

	if !tea.BoolValue(util.IsUnset(request.TrafficMirrorTargetType)) {
		query["TrafficMirrorTargetType"] = request.TrafficMirrorTargetType
	}

	if !tea.BoolValue(util.IsUnset(request.VirtualNetworkId)) {
		query["VirtualNetworkId"] = request.VirtualNetworkId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateTrafficMirrorSession"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateTrafficMirrorSessionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * **CreateTrafficMirrorSession** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [ListTrafficMirrorSessions](~~261367~~) operation to query the status of a traffic mirror session:
 * *   If the traffic mirror session is in the **Creating** state, the traffic mirror session is being created.
 * *   If the traffic mirror session is in the **Created** state, the traffic mirror session is created.
 *
 * @param request CreateTrafficMirrorSessionRequest
 * @return CreateTrafficMirrorSessionResponse
 */
func (client *Client) CreateTrafficMirrorSession(request *CreateTrafficMirrorSessionRequest) (_result *CreateTrafficMirrorSessionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateTrafficMirrorSessionResponse{}
	_body, _err := client.CreateTrafficMirrorSessionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * When you call this operation, take note of the following limits:
 * *   You can create at most 150 vSwitches in a virtual private cloud (VPC).
 * *   The first IP address and last three IP addresses of each vSwitch CIDR block are reserved. For example, if the CIDR block of a vSwitch is 192.168.1.0/24, the IP addresses 192.168.1.0, 192.168.1.253, 192.168.1.254, and 192.168.1.255 are reserved.
 * *   The number of instances in a vSwitch cannot exceed the remaining capacity of the VPC. The remaining capacity is the difference between 15,000 and the current number of instances.
 * *   Each instance can belong to only one vSwitch.
 * *   vSwitches do not support multicast or broadcast.
 * *   After you create a vSwitch, you cannot modify its CIDR block.
 * *   The **CreateVSwitch** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeVSwitchAttributes](~~94567~~) operation to query the status of a vSwitch:
 *     *   If the vSwitch is in the **Pending** state, the vSwitch is being configured.
 *     *   If the vSwitch is in the **Available** state, the vSwitch is available.
 * *   You cannot repeatedly call the **CreateVSwitch** operation to create a vSwitch in a VPC within the specified period of time.
 *
 * @param request CreateVSwitchRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateVSwitchResponse
 */
func (client *Client) CreateVSwitchWithOptions(request *CreateVSwitchRequest, runtime *util.RuntimeOptions) (_result *CreateVSwitchResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CidrBlock)) {
		query["CidrBlock"] = request.CidrBlock
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.Ipv6CidrBlock)) {
		query["Ipv6CidrBlock"] = request.Ipv6CidrBlock
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	if !tea.BoolValue(util.IsUnset(request.VSwitchName)) {
		query["VSwitchName"] = request.VSwitchName
	}

	if !tea.BoolValue(util.IsUnset(request.VpcId)) {
		query["VpcId"] = request.VpcId
	}

	if !tea.BoolValue(util.IsUnset(request.VpcIpv6CidrBlock)) {
		query["VpcIpv6CidrBlock"] = request.VpcIpv6CidrBlock
	}

	if !tea.BoolValue(util.IsUnset(request.ZoneId)) {
		query["ZoneId"] = request.ZoneId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateVSwitch"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateVSwitchResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * When you call this operation, take note of the following limits:
 * *   You can create at most 150 vSwitches in a virtual private cloud (VPC).
 * *   The first IP address and last three IP addresses of each vSwitch CIDR block are reserved. For example, if the CIDR block of a vSwitch is 192.168.1.0/24, the IP addresses 192.168.1.0, 192.168.1.253, 192.168.1.254, and 192.168.1.255 are reserved.
 * *   The number of instances in a vSwitch cannot exceed the remaining capacity of the VPC. The remaining capacity is the difference between 15,000 and the current number of instances.
 * *   Each instance can belong to only one vSwitch.
 * *   vSwitches do not support multicast or broadcast.
 * *   After you create a vSwitch, you cannot modify its CIDR block.
 * *   The **CreateVSwitch** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeVSwitchAttributes](~~94567~~) operation to query the status of a vSwitch:
 *     *   If the vSwitch is in the **Pending** state, the vSwitch is being configured.
 *     *   If the vSwitch is in the **Available** state, the vSwitch is available.
 * *   You cannot repeatedly call the **CreateVSwitch** operation to create a vSwitch in a VPC within the specified period of time.
 *
 * @param request CreateVSwitchRequest
 * @return CreateVSwitchResponse
 */
func (client *Client) CreateVSwitch(request *CreateVSwitchRequest) (_result *CreateVSwitchResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateVSwitchResponse{}
	_body, _err := client.CreateVSwitchWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateVbrHaWithOptions(request *CreateVbrHaRequest, runtime *util.RuntimeOptions) (_result *CreateVbrHaResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PeerVbrId)) {
		query["PeerVbrId"] = request.PeerVbrId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.VbrId)) {
		query["VbrId"] = request.VbrId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateVbrHa"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateVbrHaResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateVbrHa(request *CreateVbrHaRequest) (_result *CreateVbrHaResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateVbrHaResponse{}
	_body, _err := client.CreateVbrHaWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   You cannot create a destination-based route whose destination CIDR block is 0.0.0.0/0.
 * *   When you create a destination-based route for an IPsec-VPN connection, do not create a route that meets the following conditions: The destination CIDR block is 100.64.0.0/10 or one of its subnets. The next hop is the IPsec-VPN connection. Such a route results in one of the following errors: The status of the IPsec-VPN connection cannot be displayed in the console. The negotiations of the IPsec-VPN connection fail.
 * *   **CreateVcoRouteEntry** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnConnection](~~53046~~) operation to query the status of a route based on the status of the associated IPsec-VPN connection.
 *     *   If the IPsec-VPN connection is in the **updating** state, the route is being created.
 *     *   If the IPsec-VPN connection is in the **attached** state, the route is created.
 * *   You cannot repeatedly call **CreateVcoRouteEntry** to create a route for the same IPsec-VPN connection within the specified period of time.
 *
 * @param request CreateVcoRouteEntryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateVcoRouteEntryResponse
 */
func (client *Client) CreateVcoRouteEntryWithOptions(request *CreateVcoRouteEntryRequest, runtime *util.RuntimeOptions) (_result *CreateVcoRouteEntryResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.NextHop)) {
		query["NextHop"] = request.NextHop
	}

	if !tea.BoolValue(util.IsUnset(request.OverlayMode)) {
		query["OverlayMode"] = request.OverlayMode
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RouteDest)) {
		query["RouteDest"] = request.RouteDest
	}

	if !tea.BoolValue(util.IsUnset(request.VpnConnectionId)) {
		query["VpnConnectionId"] = request.VpnConnectionId
	}

	if !tea.BoolValue(util.IsUnset(request.Weight)) {
		query["Weight"] = request.Weight
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateVcoRouteEntry"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateVcoRouteEntryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   You cannot create a destination-based route whose destination CIDR block is 0.0.0.0/0.
 * *   When you create a destination-based route for an IPsec-VPN connection, do not create a route that meets the following conditions: The destination CIDR block is 100.64.0.0/10 or one of its subnets. The next hop is the IPsec-VPN connection. Such a route results in one of the following errors: The status of the IPsec-VPN connection cannot be displayed in the console. The negotiations of the IPsec-VPN connection fail.
 * *   **CreateVcoRouteEntry** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnConnection](~~53046~~) operation to query the status of a route based on the status of the associated IPsec-VPN connection.
 *     *   If the IPsec-VPN connection is in the **updating** state, the route is being created.
 *     *   If the IPsec-VPN connection is in the **attached** state, the route is created.
 * *   You cannot repeatedly call **CreateVcoRouteEntry** to create a route for the same IPsec-VPN connection within the specified period of time.
 *
 * @param request CreateVcoRouteEntryRequest
 * @return CreateVcoRouteEntryResponse
 */
func (client *Client) CreateVcoRouteEntry(request *CreateVcoRouteEntryRequest) (_result *CreateVcoRouteEntryResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateVcoRouteEntryResponse{}
	_body, _err := client.CreateVcoRouteEntryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * When you create a VBR, the VBR is in the **Enabled** state by default.
 *
 * @param request CreateVirtualBorderRouterRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateVirtualBorderRouterResponse
 */
func (client *Client) CreateVirtualBorderRouterWithOptions(request *CreateVirtualBorderRouterRequest, runtime *util.RuntimeOptions) (_result *CreateVirtualBorderRouterResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Bandwidth)) {
		query["Bandwidth"] = request.Bandwidth
	}

	if !tea.BoolValue(util.IsUnset(request.CircuitCode)) {
		query["CircuitCode"] = request.CircuitCode
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.EnableIpv6)) {
		query["EnableIpv6"] = request.EnableIpv6
	}

	if !tea.BoolValue(util.IsUnset(request.LocalGatewayIp)) {
		query["LocalGatewayIp"] = request.LocalGatewayIp
	}

	if !tea.BoolValue(util.IsUnset(request.LocalIpv6GatewayIp)) {
		query["LocalIpv6GatewayIp"] = request.LocalIpv6GatewayIp
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PeerGatewayIp)) {
		query["PeerGatewayIp"] = request.PeerGatewayIp
	}

	if !tea.BoolValue(util.IsUnset(request.PeerIpv6GatewayIp)) {
		query["PeerIpv6GatewayIp"] = request.PeerIpv6GatewayIp
	}

	if !tea.BoolValue(util.IsUnset(request.PeeringIpv6SubnetMask)) {
		query["PeeringIpv6SubnetMask"] = request.PeeringIpv6SubnetMask
	}

	if !tea.BoolValue(util.IsUnset(request.PeeringSubnetMask)) {
		query["PeeringSubnetMask"] = request.PeeringSubnetMask
	}

	if !tea.BoolValue(util.IsUnset(request.PhysicalConnectionId)) {
		query["PhysicalConnectionId"] = request.PhysicalConnectionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	if !tea.BoolValue(util.IsUnset(request.VbrOwnerId)) {
		query["VbrOwnerId"] = request.VbrOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.VlanId)) {
		query["VlanId"] = request.VlanId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateVirtualBorderRouter"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateVirtualBorderRouterResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * When you create a VBR, the VBR is in the **Enabled** state by default.
 *
 * @param request CreateVirtualBorderRouterRequest
 * @return CreateVirtualBorderRouterResponse
 */
func (client *Client) CreateVirtualBorderRouter(request *CreateVirtualBorderRouterRequest) (_result *CreateVirtualBorderRouterResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateVirtualBorderRouterResponse{}
	_body, _err := client.CreateVirtualBorderRouterWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Before you call this API operation, familiarize yourself with the workflow for creating a hosted connection and the environment requirements. For more information, see [Overview](~~146571~~) and [Operation guide for Express Connect partners](~~155987~~).
 *
 * @param request CreateVirtualPhysicalConnectionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateVirtualPhysicalConnectionResponse
 */
func (client *Client) CreateVirtualPhysicalConnectionWithOptions(request *CreateVirtualPhysicalConnectionRequest, runtime *util.RuntimeOptions) (_result *CreateVirtualPhysicalConnectionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.OrderMode)) {
		query["OrderMode"] = request.OrderMode
	}

	if !tea.BoolValue(util.IsUnset(request.PhysicalConnectionId)) {
		query["PhysicalConnectionId"] = request.PhysicalConnectionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.Spec)) {
		query["Spec"] = request.Spec
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	if !tea.BoolValue(util.IsUnset(request.Token)) {
		query["Token"] = request.Token
	}

	if !tea.BoolValue(util.IsUnset(request.VlanId)) {
		query["VlanId"] = request.VlanId
	}

	if !tea.BoolValue(util.IsUnset(request.VpconnAliUid)) {
		query["VpconnAliUid"] = request.VpconnAliUid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateVirtualPhysicalConnection"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateVirtualPhysicalConnectionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Before you call this API operation, familiarize yourself with the workflow for creating a hosted connection and the environment requirements. For more information, see [Overview](~~146571~~) and [Operation guide for Express Connect partners](~~155987~~).
 *
 * @param request CreateVirtualPhysicalConnectionRequest
 * @return CreateVirtualPhysicalConnectionResponse
 */
func (client *Client) CreateVirtualPhysicalConnection(request *CreateVirtualPhysicalConnectionRequest) (_result *CreateVirtualPhysicalConnectionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateVirtualPhysicalConnectionResponse{}
	_body, _err := client.CreateVirtualPhysicalConnectionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * When you call this operation, take note of the following rules:
 * *   You can specify only one CIDR block for each VPC.
 * *   After you create a VPC, you cannot change its CIDR block. However, you can add secondary IPv4 CIDR blocks to the VPC.
 * *   In each VPC, cloud services can use a maximum of 60,000 private IP addresses. You cannot increase the quota.
 * *   After you create a VPC, a vRouter and a route table are automatically created.
 * *   At most three user CIDR blocks can be added to a VPC. If a user CIDR block includes another user CIDR block, the one with the shorter subnet mask takes effect. For example, if 10.0.0.0/8 and 10.1.0.0/16 are specified, only 10.0.0.0/8 takes effect.
 * *   The **CreateVpc** operation is asynchronous. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeVpcAttribute](~~94565~~) operation to query the status of a VPC:
 *     *   If the VPC is in the **Creating** state, the VPC is being created.
 *     *   If the VPC is in the **Created** state, the VPC is created.
 * *   You cannot repeatedly call the **CreateVpc** operation to create default VPCs within the specified period of time. However, you can repeatedly call this operation to create custom VPCs within the specified period of time.
 *
 * @param request CreateVpcRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateVpcResponse
 */
func (client *Client) CreateVpcWithOptions(request *CreateVpcRequest, runtime *util.RuntimeOptions) (_result *CreateVpcResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CidrBlock)) {
		query["CidrBlock"] = request.CidrBlock
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.EnableIpv6)) {
		query["EnableIpv6"] = request.EnableIpv6
	}

	if !tea.BoolValue(util.IsUnset(request.Ipv4IpamPoolId)) {
		query["Ipv4IpamPoolId"] = request.Ipv4IpamPoolId
	}

	if !tea.BoolValue(util.IsUnset(request.Ipv6CidrBlock)) {
		query["Ipv6CidrBlock"] = request.Ipv6CidrBlock
	}

	if !tea.BoolValue(util.IsUnset(request.Ipv6Isp)) {
		query["Ipv6Isp"] = request.Ipv6Isp
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	if !tea.BoolValue(util.IsUnset(request.UserCidr)) {
		query["UserCidr"] = request.UserCidr
	}

	if !tea.BoolValue(util.IsUnset(request.VpcName)) {
		query["VpcName"] = request.VpcName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateVpc"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateVpcResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * When you call this operation, take note of the following rules:
 * *   You can specify only one CIDR block for each VPC.
 * *   After you create a VPC, you cannot change its CIDR block. However, you can add secondary IPv4 CIDR blocks to the VPC.
 * *   In each VPC, cloud services can use a maximum of 60,000 private IP addresses. You cannot increase the quota.
 * *   After you create a VPC, a vRouter and a route table are automatically created.
 * *   At most three user CIDR blocks can be added to a VPC. If a user CIDR block includes another user CIDR block, the one with the shorter subnet mask takes effect. For example, if 10.0.0.0/8 and 10.1.0.0/16 are specified, only 10.0.0.0/8 takes effect.
 * *   The **CreateVpc** operation is asynchronous. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeVpcAttribute](~~94565~~) operation to query the status of a VPC:
 *     *   If the VPC is in the **Creating** state, the VPC is being created.
 *     *   If the VPC is in the **Created** state, the VPC is created.
 * *   You cannot repeatedly call the **CreateVpc** operation to create default VPCs within the specified period of time. However, you can repeatedly call this operation to create custom VPCs within the specified period of time.
 *
 * @param request CreateVpcRequest
 * @return CreateVpcResponse
 */
func (client *Client) CreateVpc(request *CreateVpcRequest) (_result *CreateVpcResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateVpcResponse{}
	_body, _err := client.CreateVpcWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   **CreateVpcGatewayEndpoint** is an asynchronous operation. After you send a request, the system returns an **EndpointId** and runs the task in the background. You can call the [GetDhcpOptionsSet](~~189208~~) operation to query the status of a gateway endpoint.
 *     *   If the gateway endpoint is in the **Creating** state, the gateway endpoint is being created.
 *     *   If the gateway endpoint is in the **Created** state, the gateway endpoint is created.
 * *   You cannot repeatedly call the **CreateVpcGatewayEndpoint** operation for the same endpoint service within the specified period of time.
 *
 * @param request CreateVpcGatewayEndpointRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateVpcGatewayEndpointResponse
 */
func (client *Client) CreateVpcGatewayEndpointWithOptions(request *CreateVpcGatewayEndpointRequest, runtime *util.RuntimeOptions) (_result *CreateVpcGatewayEndpointResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.EndpointDescription)) {
		query["EndpointDescription"] = request.EndpointDescription
	}

	if !tea.BoolValue(util.IsUnset(request.EndpointName)) {
		query["EndpointName"] = request.EndpointName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PolicyDocument)) {
		query["PolicyDocument"] = request.PolicyDocument
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceName)) {
		query["ServiceName"] = request.ServiceName
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	if !tea.BoolValue(util.IsUnset(request.VpcId)) {
		query["VpcId"] = request.VpcId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateVpcGatewayEndpoint"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateVpcGatewayEndpointResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   **CreateVpcGatewayEndpoint** is an asynchronous operation. After you send a request, the system returns an **EndpointId** and runs the task in the background. You can call the [GetDhcpOptionsSet](~~189208~~) operation to query the status of a gateway endpoint.
 *     *   If the gateway endpoint is in the **Creating** state, the gateway endpoint is being created.
 *     *   If the gateway endpoint is in the **Created** state, the gateway endpoint is created.
 * *   You cannot repeatedly call the **CreateVpcGatewayEndpoint** operation for the same endpoint service within the specified period of time.
 *
 * @param request CreateVpcGatewayEndpointRequest
 * @return CreateVpcGatewayEndpointResponse
 */
func (client *Client) CreateVpcGatewayEndpoint(request *CreateVpcGatewayEndpointRequest) (_result *CreateVpcGatewayEndpointResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateVpcGatewayEndpointResponse{}
	_body, _err := client.CreateVpcGatewayEndpointWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You cannot repeatedly call the **CreateVpcPrefixList** operation to create a prefix list in a region within the specified period of time.
 *
 * @param request CreateVpcPrefixListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateVpcPrefixListResponse
 */
func (client *Client) CreateVpcPrefixListWithOptions(request *CreateVpcPrefixListRequest, runtime *util.RuntimeOptions) (_result *CreateVpcPrefixListResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.IpVersion)) {
		query["IpVersion"] = request.IpVersion
	}

	if !tea.BoolValue(util.IsUnset(request.MaxEntries)) {
		query["MaxEntries"] = request.MaxEntries
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PrefixListDescription)) {
		query["PrefixListDescription"] = request.PrefixListDescription
	}

	if !tea.BoolValue(util.IsUnset(request.PrefixListEntries)) {
		query["PrefixListEntries"] = request.PrefixListEntries
	}

	if !tea.BoolValue(util.IsUnset(request.PrefixListName)) {
		query["PrefixListName"] = request.PrefixListName
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateVpcPrefixList"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateVpcPrefixListResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You cannot repeatedly call the **CreateVpcPrefixList** operation to create a prefix list in a region within the specified period of time.
 *
 * @param request CreateVpcPrefixListRequest
 * @return CreateVpcPrefixListResponse
 */
func (client *Client) CreateVpcPrefixList(request *CreateVpcPrefixListRequest) (_result *CreateVpcPrefixListResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateVpcPrefixListResponse{}
	_body, _err := client.CreateVpcPrefixListWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * If an Express Connect partner has created a virtual border router (VBR) for a tenant before, the Express Connect partner can push the Express Connect circuit that is associated with the VBR to the tenant account by adding a shared port for the tenant account. The service of the tenant is not interrupted in this process.
 * Preparations:
 * Before the Express Connect partner performs the operation, the Express Connect partner must notify the tenant and request the tenant to enable outbound data transfer billing. For more information, see [Enable outbound data transfer billing](~~274385~~).
 * What to do next:
 * 1\\. After the Express Connect partner performs the operation, a shared port is added for the tenant account. The tenant must call the [ConfirmPhysicalConnection](~~324198~~) operation to accept the shared port.
 * 2\\. Then, the Express Connect partner must call the [AttachVbrToVpconn](~~324191~~) operation to associate the VBR with the newly added shared port that belongs to the tenant account.
 *
 * @param request CreateVpconnFromVbrRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateVpconnFromVbrResponse
 */
func (client *Client) CreateVpconnFromVbrWithOptions(request *CreateVpconnFromVbrRequest, runtime *util.RuntimeOptions) (_result *CreateVpconnFromVbrResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.OrderMode)) {
		query["OrderMode"] = request.OrderMode
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.Token)) {
		query["Token"] = request.Token
	}

	if !tea.BoolValue(util.IsUnset(request.VbrId)) {
		query["VbrId"] = request.VbrId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateVpconnFromVbr"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateVpconnFromVbrResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * If an Express Connect partner has created a virtual border router (VBR) for a tenant before, the Express Connect partner can push the Express Connect circuit that is associated with the VBR to the tenant account by adding a shared port for the tenant account. The service of the tenant is not interrupted in this process.
 * Preparations:
 * Before the Express Connect partner performs the operation, the Express Connect partner must notify the tenant and request the tenant to enable outbound data transfer billing. For more information, see [Enable outbound data transfer billing](~~274385~~).
 * What to do next:
 * 1\\. After the Express Connect partner performs the operation, a shared port is added for the tenant account. The tenant must call the [ConfirmPhysicalConnection](~~324198~~) operation to accept the shared port.
 * 2\\. Then, the Express Connect partner must call the [AttachVbrToVpconn](~~324191~~) operation to associate the VBR with the newly added shared port that belongs to the tenant account.
 *
 * @param request CreateVpconnFromVbrRequest
 * @return CreateVpconnFromVbrResponse
 */
func (client *Client) CreateVpconnFromVbr(request *CreateVpconnFromVbrRequest) (_result *CreateVpconnFromVbrResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateVpconnFromVbrResponse{}
	_body, _err := client.CreateVpconnFromVbrWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * # Usage notes
 * By default, an IPsec-VPN connection created by calling the `CreateVpnAttachment` operation is not associated with a resource. You can associate an IPsec-VPN connection with a transit router by calling the [CreateTransitRouterVpnAttachment](~~443993~~) operation.
 * # Prerequisites
 * Before you create an IPsec-VPN connection, make sure that you created a customer gateway in the region where you want to create the IPsec-VPN connection. For more information, see [CreateCustomerGateway](~~120368~~).
 * If you want to add BGP configurations to an IPsec-VPN connection, make sure that an autonomous system number (ASN) is assigned to the customer gateway.
 *
 * @param request CreateVpnAttachmentRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateVpnAttachmentResponse
 */
func (client *Client) CreateVpnAttachmentWithOptions(request *CreateVpnAttachmentRequest, runtime *util.RuntimeOptions) (_result *CreateVpnAttachmentResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AutoConfigRoute)) {
		query["AutoConfigRoute"] = request.AutoConfigRoute
	}

	if !tea.BoolValue(util.IsUnset(request.BgpConfig)) {
		query["BgpConfig"] = request.BgpConfig
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.CustomerGatewayId)) {
		query["CustomerGatewayId"] = request.CustomerGatewayId
	}

	if !tea.BoolValue(util.IsUnset(request.EffectImmediately)) {
		query["EffectImmediately"] = request.EffectImmediately
	}

	if !tea.BoolValue(util.IsUnset(request.EnableDpd)) {
		query["EnableDpd"] = request.EnableDpd
	}

	if !tea.BoolValue(util.IsUnset(request.EnableNatTraversal)) {
		query["EnableNatTraversal"] = request.EnableNatTraversal
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckConfig)) {
		query["HealthCheckConfig"] = request.HealthCheckConfig
	}

	if !tea.BoolValue(util.IsUnset(request.IkeConfig)) {
		query["IkeConfig"] = request.IkeConfig
	}

	if !tea.BoolValue(util.IsUnset(request.IpsecConfig)) {
		query["IpsecConfig"] = request.IpsecConfig
	}

	if !tea.BoolValue(util.IsUnset(request.LocalSubnet)) {
		query["LocalSubnet"] = request.LocalSubnet
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.NetworkType)) {
		query["NetworkType"] = request.NetworkType
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RemoteCaCert)) {
		query["RemoteCaCert"] = request.RemoteCaCert
	}

	if !tea.BoolValue(util.IsUnset(request.RemoteSubnet)) {
		query["RemoteSubnet"] = request.RemoteSubnet
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateVpnAttachment"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateVpnAttachmentResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * # Usage notes
 * By default, an IPsec-VPN connection created by calling the `CreateVpnAttachment` operation is not associated with a resource. You can associate an IPsec-VPN connection with a transit router by calling the [CreateTransitRouterVpnAttachment](~~443993~~) operation.
 * # Prerequisites
 * Before you create an IPsec-VPN connection, make sure that you created a customer gateway in the region where you want to create the IPsec-VPN connection. For more information, see [CreateCustomerGateway](~~120368~~).
 * If you want to add BGP configurations to an IPsec-VPN connection, make sure that an autonomous system number (ASN) is assigned to the customer gateway.
 *
 * @param request CreateVpnAttachmentRequest
 * @return CreateVpnAttachmentResponse
 */
func (client *Client) CreateVpnAttachment(request *CreateVpnAttachmentRequest) (_result *CreateVpnAttachmentResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateVpnAttachmentResponse{}
	_body, _err := client.CreateVpnAttachmentWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * # Usage notes
 * *   **CreateVpnConnection** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](~~73720~~) to query the status of the task.
 *     *   If the VPN gateway is in the **updating** state, the IPsec-VPN connection is being created.
 *     *   If the VPN gateway is in the **active** state, the IPsec-VPN connection is created.
 * *   You cannot repeatedly call **CreateVpnConnection** to create an IPsec-VPN connection on a VPN gateway within the specified period of time.
 *
 * @param request CreateVpnConnectionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateVpnConnectionResponse
 */
func (client *Client) CreateVpnConnectionWithOptions(request *CreateVpnConnectionRequest, runtime *util.RuntimeOptions) (_result *CreateVpnConnectionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AutoConfigRoute)) {
		query["AutoConfigRoute"] = request.AutoConfigRoute
	}

	if !tea.BoolValue(util.IsUnset(request.BgpConfig)) {
		query["BgpConfig"] = request.BgpConfig
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.CustomerGatewayId)) {
		query["CustomerGatewayId"] = request.CustomerGatewayId
	}

	if !tea.BoolValue(util.IsUnset(request.EffectImmediately)) {
		query["EffectImmediately"] = request.EffectImmediately
	}

	if !tea.BoolValue(util.IsUnset(request.EnableDpd)) {
		query["EnableDpd"] = request.EnableDpd
	}

	if !tea.BoolValue(util.IsUnset(request.EnableNatTraversal)) {
		query["EnableNatTraversal"] = request.EnableNatTraversal
	}

	if !tea.BoolValue(util.IsUnset(request.EnableTunnelsBgp)) {
		query["EnableTunnelsBgp"] = request.EnableTunnelsBgp
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckConfig)) {
		query["HealthCheckConfig"] = request.HealthCheckConfig
	}

	if !tea.BoolValue(util.IsUnset(request.IkeConfig)) {
		query["IkeConfig"] = request.IkeConfig
	}

	if !tea.BoolValue(util.IsUnset(request.IpsecConfig)) {
		query["IpsecConfig"] = request.IpsecConfig
	}

	if !tea.BoolValue(util.IsUnset(request.LocalSubnet)) {
		query["LocalSubnet"] = request.LocalSubnet
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RemoteCaCertificate)) {
		query["RemoteCaCertificate"] = request.RemoteCaCertificate
	}

	if !tea.BoolValue(util.IsUnset(request.RemoteSubnet)) {
		query["RemoteSubnet"] = request.RemoteSubnet
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	if !tea.BoolValue(util.IsUnset(request.VpnGatewayId)) {
		query["VpnGatewayId"] = request.VpnGatewayId
	}

	body := map[string]interface{}{}
	bodyFlat := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.TunnelOptionsSpecification)) {
		bodyFlat["TunnelOptionsSpecification"] = request.TunnelOptionsSpecification
	}

	body = tea.ToMap(body,
		openapiutil.Query(bodyFlat))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
		Body:  openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateVpnConnection"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateVpnConnectionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * # Usage notes
 * *   **CreateVpnConnection** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](~~73720~~) to query the status of the task.
 *     *   If the VPN gateway is in the **updating** state, the IPsec-VPN connection is being created.
 *     *   If the VPN gateway is in the **active** state, the IPsec-VPN connection is created.
 * *   You cannot repeatedly call **CreateVpnConnection** to create an IPsec-VPN connection on a VPN gateway within the specified period of time.
 *
 * @param request CreateVpnConnectionRequest
 * @return CreateVpnConnectionResponse
 */
func (client *Client) CreateVpnConnection(request *CreateVpnConnectionRequest) (_result *CreateVpnConnectionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateVpnConnectionResponse{}
	_body, _err := client.CreateVpnConnectionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Usage notes
 * *   Before you create a VPN gateway, we recommend that you understand its limits. For more information, see [Limits on VPN gateways](~~65290~~).
 * *   The **CreateVpnGateway** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call [DescribeVpnGateway](~~73720~~) to query the status of a VPN gateway.
 *     *   If the VPN gateway is in the **provisioning** state, the VPN gateway is being created.
 *     *   If a VPN gateway is in the **active** state, the VPN gateway has been created.
 *
 * @param request CreateVpnGatewayRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateVpnGatewayResponse
 */
func (client *Client) CreateVpnGatewayWithOptions(request *CreateVpnGatewayRequest, runtime *util.RuntimeOptions) (_result *CreateVpnGatewayResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AutoPay)) {
		query["AutoPay"] = request.AutoPay
	}

	if !tea.BoolValue(util.IsUnset(request.Bandwidth)) {
		query["Bandwidth"] = request.Bandwidth
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DisasterRecoveryVSwitchId)) {
		query["DisasterRecoveryVSwitchId"] = request.DisasterRecoveryVSwitchId
	}

	if !tea.BoolValue(util.IsUnset(request.EnableIpsec)) {
		query["EnableIpsec"] = request.EnableIpsec
	}

	if !tea.BoolValue(util.IsUnset(request.EnableSsl)) {
		query["EnableSsl"] = request.EnableSsl
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceChargeType)) {
		query["InstanceChargeType"] = request.InstanceChargeType
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.NetworkType)) {
		query["NetworkType"] = request.NetworkType
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Period)) {
		query["Period"] = request.Period
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SslConnections)) {
		query["SslConnections"] = request.SslConnections
	}

	if !tea.BoolValue(util.IsUnset(request.VSwitchId)) {
		query["VSwitchId"] = request.VSwitchId
	}

	if !tea.BoolValue(util.IsUnset(request.VpcId)) {
		query["VpcId"] = request.VpcId
	}

	if !tea.BoolValue(util.IsUnset(request.VpnType)) {
		query["VpnType"] = request.VpnType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateVpnGateway"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateVpnGatewayResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Usage notes
 * *   Before you create a VPN gateway, we recommend that you understand its limits. For more information, see [Limits on VPN gateways](~~65290~~).
 * *   The **CreateVpnGateway** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call [DescribeVpnGateway](~~73720~~) to query the status of a VPN gateway.
 *     *   If the VPN gateway is in the **provisioning** state, the VPN gateway is being created.
 *     *   If a VPN gateway is in the **active** state, the VPN gateway has been created.
 *
 * @param request CreateVpnGatewayRequest
 * @return CreateVpnGatewayResponse
 */
func (client *Client) CreateVpnGateway(request *CreateVpnGatewayRequest) (_result *CreateVpnGatewayResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateVpnGatewayResponse{}
	_body, _err := client.CreateVpnGatewayWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   Before you call this operation, we recommend that you learn about the match rules of policy-based routes and limits on policy-based routes. For more information, see [Work with policy-based routes](~~110777~~).
 * *   Before you create a policy-based route, make sure that an IPsec-VPN connection is created. For more information, see [CreateVpnConnection](~~120391~~).
 * *   **CreateVpnPbrRouteEntry** is an asynchronous operation. After you send the request, the route information is returned but the operation is still being performed in the background. You can call [DescribeVpnGateway](~~73720~~) to query the status of a VPN gateway.
 *     *   If a VPN gateway is in the **updating** state, the policy-based route entry is being created.
 *     *   If a VPN gateway is in the **active** state, the policy-based route entry is created.
 * *   You cannot repeatedly call **CreateVpnPbrRouteEntry** to create a policy-based route for a VPN gateway within the specified period of time.
 *
 * @param request CreateVpnPbrRouteEntryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateVpnPbrRouteEntryResponse
 */
func (client *Client) CreateVpnPbrRouteEntryWithOptions(request *CreateVpnPbrRouteEntryRequest, runtime *util.RuntimeOptions) (_result *CreateVpnPbrRouteEntryResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.NextHop)) {
		query["NextHop"] = request.NextHop
	}

	if !tea.BoolValue(util.IsUnset(request.OverlayMode)) {
		query["OverlayMode"] = request.OverlayMode
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Priority)) {
		query["Priority"] = request.Priority
	}

	if !tea.BoolValue(util.IsUnset(request.PublishVpc)) {
		query["PublishVpc"] = request.PublishVpc
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RouteDest)) {
		query["RouteDest"] = request.RouteDest
	}

	if !tea.BoolValue(util.IsUnset(request.RouteSource)) {
		query["RouteSource"] = request.RouteSource
	}

	if !tea.BoolValue(util.IsUnset(request.VpnGatewayId)) {
		query["VpnGatewayId"] = request.VpnGatewayId
	}

	if !tea.BoolValue(util.IsUnset(request.Weight)) {
		query["Weight"] = request.Weight
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateVpnPbrRouteEntry"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateVpnPbrRouteEntryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   Before you call this operation, we recommend that you learn about the match rules of policy-based routes and limits on policy-based routes. For more information, see [Work with policy-based routes](~~110777~~).
 * *   Before you create a policy-based route, make sure that an IPsec-VPN connection is created. For more information, see [CreateVpnConnection](~~120391~~).
 * *   **CreateVpnPbrRouteEntry** is an asynchronous operation. After you send the request, the route information is returned but the operation is still being performed in the background. You can call [DescribeVpnGateway](~~73720~~) to query the status of a VPN gateway.
 *     *   If a VPN gateway is in the **updating** state, the policy-based route entry is being created.
 *     *   If a VPN gateway is in the **active** state, the policy-based route entry is created.
 * *   You cannot repeatedly call **CreateVpnPbrRouteEntry** to create a policy-based route for a VPN gateway within the specified period of time.
 *
 * @param request CreateVpnPbrRouteEntryRequest
 * @return CreateVpnPbrRouteEntryResponse
 */
func (client *Client) CreateVpnPbrRouteEntry(request *CreateVpnPbrRouteEntryRequest) (_result *CreateVpnPbrRouteEntryResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateVpnPbrRouteEntryResponse{}
	_body, _err := client.CreateVpnPbrRouteEntryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   **CreateVpnRouteEntry** is an asynchronous operation. After you call the operation, the route configurations are returned but the operation is still being performed in the background. You can call [DescribeVpnGateway](~~73720~~) to query the status of a destination-based route entry.
 *     *   If a VPN gateway is in the **updating** state, the destination-based route entry is being created.
 *     *   If a VPN gateway is in the **active** state, the destination-based route entry has been created.
 * *   You cannot repeatedly call **CreateVpnRouteEntry** to create a destination-based route entry for a VPN gateway within the specified period of time.
 *
 * @param request CreateVpnRouteEntryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateVpnRouteEntryResponse
 */
func (client *Client) CreateVpnRouteEntryWithOptions(request *CreateVpnRouteEntryRequest, runtime *util.RuntimeOptions) (_result *CreateVpnRouteEntryResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.NextHop)) {
		query["NextHop"] = request.NextHop
	}

	if !tea.BoolValue(util.IsUnset(request.OverlayMode)) {
		query["OverlayMode"] = request.OverlayMode
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PublishVpc)) {
		query["PublishVpc"] = request.PublishVpc
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RouteDest)) {
		query["RouteDest"] = request.RouteDest
	}

	if !tea.BoolValue(util.IsUnset(request.VpnGatewayId)) {
		query["VpnGatewayId"] = request.VpnGatewayId
	}

	if !tea.BoolValue(util.IsUnset(request.Weight)) {
		query["Weight"] = request.Weight
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateVpnRouteEntry"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateVpnRouteEntryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   **CreateVpnRouteEntry** is an asynchronous operation. After you call the operation, the route configurations are returned but the operation is still being performed in the background. You can call [DescribeVpnGateway](~~73720~~) to query the status of a destination-based route entry.
 *     *   If a VPN gateway is in the **updating** state, the destination-based route entry is being created.
 *     *   If a VPN gateway is in the **active** state, the destination-based route entry has been created.
 * *   You cannot repeatedly call **CreateVpnRouteEntry** to create a destination-based route entry for a VPN gateway within the specified period of time.
 *
 * @param request CreateVpnRouteEntryRequest
 * @return CreateVpnRouteEntryResponse
 */
func (client *Client) CreateVpnRouteEntry(request *CreateVpnRouteEntryRequest) (_result *CreateVpnRouteEntryResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateVpnRouteEntryResponse{}
	_body, _err := client.CreateVpnRouteEntryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeactivateRouterInterfaceWithOptions(request *DeactivateRouterInterfaceRequest, runtime *util.RuntimeOptions) (_result *DeactivateRouterInterfaceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RouterInterfaceId)) {
		query["RouterInterfaceId"] = request.RouterInterfaceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeactivateRouterInterface"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeactivateRouterInterfaceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeactivateRouterInterface(request *DeactivateRouterInterfaceRequest) (_result *DeactivateRouterInterfaceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeactivateRouterInterfaceResponse{}
	_body, _err := client.DeactivateRouterInterfaceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   The **DeactiveFlowLog** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeFlowLogs](~~87923~~) operation to query the status of a flow log:
 *     *   If the flow log is in the **Deactivating** state, the flow log is being disabled.
 *     *   If the flow log is in the **Inactive** state, the flow log is disabled.
 * *   You cannot repeatedly call the **DeactiveFlowLog** operation to disable a flow log within the specified period of time.
 *
 * @param request DeactiveFlowLogRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeactiveFlowLogResponse
 */
func (client *Client) DeactiveFlowLogWithOptions(request *DeactiveFlowLogRequest, runtime *util.RuntimeOptions) (_result *DeactiveFlowLogResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.FlowLogId)) {
		query["FlowLogId"] = request.FlowLogId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeactiveFlowLog"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeactiveFlowLogResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   The **DeactiveFlowLog** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeFlowLogs](~~87923~~) operation to query the status of a flow log:
 *     *   If the flow log is in the **Deactivating** state, the flow log is being disabled.
 *     *   If the flow log is in the **Inactive** state, the flow log is disabled.
 * *   You cannot repeatedly call the **DeactiveFlowLog** operation to disable a flow log within the specified period of time.
 *
 * @param request DeactiveFlowLogRequest
 * @return DeactiveFlowLogResponse
 */
func (client *Client) DeactiveFlowLog(request *DeactiveFlowLogRequest) (_result *DeactiveFlowLogResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeactiveFlowLogResponse{}
	_body, _err := client.DeactiveFlowLogWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteBgpGroupWithOptions(request *DeleteBgpGroupRequest, runtime *util.RuntimeOptions) (_result *DeleteBgpGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BgpGroupId)) {
		query["BgpGroupId"] = request.BgpGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteBgpGroup"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteBgpGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteBgpGroup(request *DeleteBgpGroupRequest) (_result *DeleteBgpGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteBgpGroupResponse{}
	_body, _err := client.DeleteBgpGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteBgpNetworkWithOptions(request *DeleteBgpNetworkRequest, runtime *util.RuntimeOptions) (_result *DeleteBgpNetworkResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DstCidrBlock)) {
		query["DstCidrBlock"] = request.DstCidrBlock
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RouterId)) {
		query["RouterId"] = request.RouterId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteBgpNetwork"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteBgpNetworkResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteBgpNetwork(request *DeleteBgpNetworkRequest) (_result *DeleteBgpNetworkResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteBgpNetworkResponse{}
	_body, _err := client.DeleteBgpNetworkWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteBgpPeerWithOptions(request *DeleteBgpPeerRequest, runtime *util.RuntimeOptions) (_result *DeleteBgpPeerResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BgpPeerId)) {
		query["BgpPeerId"] = request.BgpPeerId
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteBgpPeer"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteBgpPeerResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteBgpPeer(request *DeleteBgpPeerRequest) (_result *DeleteBgpPeerResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteBgpPeerResponse{}
	_body, _err := client.DeleteBgpPeerWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You cannot repeatedly call the **DeleteCommonBandwidthPackage** operation to delete an EIP bandwidth plan within the specified period of time.
 *
 * @param request DeleteCommonBandwidthPackageRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteCommonBandwidthPackageResponse
 */
func (client *Client) DeleteCommonBandwidthPackageWithOptions(request *DeleteCommonBandwidthPackageRequest, runtime *util.RuntimeOptions) (_result *DeleteCommonBandwidthPackageResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BandwidthPackageId)) {
		query["BandwidthPackageId"] = request.BandwidthPackageId
	}

	if !tea.BoolValue(util.IsUnset(request.Force)) {
		query["Force"] = request.Force
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteCommonBandwidthPackage"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteCommonBandwidthPackageResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You cannot repeatedly call the **DeleteCommonBandwidthPackage** operation to delete an EIP bandwidth plan within the specified period of time.
 *
 * @param request DeleteCommonBandwidthPackageRequest
 * @return DeleteCommonBandwidthPackageResponse
 */
func (client *Client) DeleteCommonBandwidthPackage(request *DeleteCommonBandwidthPackageRequest) (_result *DeleteCommonBandwidthPackageResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteCommonBandwidthPackageResponse{}
	_body, _err := client.DeleteCommonBandwidthPackageWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteCustomerGatewayWithOptions(request *DeleteCustomerGatewayRequest, runtime *util.RuntimeOptions) (_result *DeleteCustomerGatewayResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.CustomerGatewayId)) {
		query["CustomerGatewayId"] = request.CustomerGatewayId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteCustomerGateway"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteCustomerGatewayResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteCustomerGateway(request *DeleteCustomerGatewayRequest) (_result *DeleteCustomerGatewayResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteCustomerGatewayResponse{}
	_body, _err := client.DeleteCustomerGatewayWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   The **DeleteDhcpOptionsSet** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [GetDhcpOptionsSet](~~189208~~) operation to query the status of a DHCP options set:
 *     *   If the DHCP options set is in the **Deleting** state, the DHCP options set is being deleted.
 *     *   If you cannot query the DHCP options set, the DHCP options set is deleted.
 * *   You cannot repeatedly call the **DeleteDhcpOptionsSet** operation to delete a DHCP options set within the specified period of time.
 *
 * @param request DeleteDhcpOptionsSetRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteDhcpOptionsSetResponse
 */
func (client *Client) DeleteDhcpOptionsSetWithOptions(request *DeleteDhcpOptionsSetRequest, runtime *util.RuntimeOptions) (_result *DeleteDhcpOptionsSetResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DhcpOptionsSetId)) {
		query["DhcpOptionsSetId"] = request.DhcpOptionsSetId
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteDhcpOptionsSet"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteDhcpOptionsSetResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   The **DeleteDhcpOptionsSet** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [GetDhcpOptionsSet](~~189208~~) operation to query the status of a DHCP options set:
 *     *   If the DHCP options set is in the **Deleting** state, the DHCP options set is being deleted.
 *     *   If you cannot query the DHCP options set, the DHCP options set is deleted.
 * *   You cannot repeatedly call the **DeleteDhcpOptionsSet** operation to delete a DHCP options set within the specified period of time.
 *
 * @param request DeleteDhcpOptionsSetRequest
 * @return DeleteDhcpOptionsSetResponse
 */
func (client *Client) DeleteDhcpOptionsSet(request *DeleteDhcpOptionsSetRequest) (_result *DeleteDhcpOptionsSetResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteDhcpOptionsSetResponse{}
	_body, _err := client.DeleteDhcpOptionsSetWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   The **DeleteFlowLog** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeFlowLogs](~~87923~~) operation to query the status of a flow log:
 *     *   If the flow log is in the **Deleting** state, the flow log is being deleted.
 *     *   If you cannot query the flow log, the flow log is deleted.
 * *   You cannot repeatedly call the **DeleteFlowLog** operation to delete a flow log within the specified period of time.
 *
 * @param request DeleteFlowLogRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteFlowLogResponse
 */
func (client *Client) DeleteFlowLogWithOptions(request *DeleteFlowLogRequest, runtime *util.RuntimeOptions) (_result *DeleteFlowLogResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.FlowLogId)) {
		query["FlowLogId"] = request.FlowLogId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteFlowLog"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteFlowLogResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   The **DeleteFlowLog** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeFlowLogs](~~87923~~) operation to query the status of a flow log:
 *     *   If the flow log is in the **Deleting** state, the flow log is being deleted.
 *     *   If you cannot query the flow log, the flow log is deleted.
 * *   You cannot repeatedly call the **DeleteFlowLog** operation to delete a flow log within the specified period of time.
 *
 * @param request DeleteFlowLogRequest
 * @return DeleteFlowLogResponse
 */
func (client *Client) DeleteFlowLog(request *DeleteFlowLogRequest) (_result *DeleteFlowLogResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteFlowLogResponse{}
	_body, _err := client.DeleteFlowLogWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   **DeleteForwardEntry** is an asynchronous operation. After you make a request, the ID of the request is returned but the specified DNAT entry is not deleted. The system deletes the entry in the background. You can call the [DescribeForwardTableEntries](~~36053~~) operation to query the status of a DNAT entry.
 *     *   If the DNAT entry is in the **Deleting** state, the system is deleting the DNAT entry. In this case, you can only query the status of the DNAT entry, but cannot perform other operations.
 *     *   If the DNAT entry cannot be found, it is deleted.
 * >  If a DNAT table has DNAT entries in the **Pending** state, you cannot delete the DNAT entries.
 * *   You cannot repeatedly call the **DeleteForwardEntry** operation to delete a DNAT entry within the specified period of time.
 *
 * @param request DeleteForwardEntryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteForwardEntryResponse
 */
func (client *Client) DeleteForwardEntryWithOptions(request *DeleteForwardEntryRequest, runtime *util.RuntimeOptions) (_result *DeleteForwardEntryResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.ForwardEntryId)) {
		query["ForwardEntryId"] = request.ForwardEntryId
	}

	if !tea.BoolValue(util.IsUnset(request.ForwardTableId)) {
		query["ForwardTableId"] = request.ForwardTableId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteForwardEntry"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteForwardEntryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   **DeleteForwardEntry** is an asynchronous operation. After you make a request, the ID of the request is returned but the specified DNAT entry is not deleted. The system deletes the entry in the background. You can call the [DescribeForwardTableEntries](~~36053~~) operation to query the status of a DNAT entry.
 *     *   If the DNAT entry is in the **Deleting** state, the system is deleting the DNAT entry. In this case, you can only query the status of the DNAT entry, but cannot perform other operations.
 *     *   If the DNAT entry cannot be found, it is deleted.
 * >  If a DNAT table has DNAT entries in the **Pending** state, you cannot delete the DNAT entries.
 * *   You cannot repeatedly call the **DeleteForwardEntry** operation to delete a DNAT entry within the specified period of time.
 *
 * @param request DeleteForwardEntryRequest
 * @return DeleteForwardEntryResponse
 */
func (client *Client) DeleteForwardEntry(request *DeleteForwardEntryRequest) (_result *DeleteForwardEntryResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteForwardEntryResponse{}
	_body, _err := client.DeleteForwardEntryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * **DeleteFullNatEntry** is an asynchronous operation. After you make a request, the ID of the request is returned but the FULLNAT entry is not deleted. The system deletes the FULLNAT entry in the background. You can call the [ListFullNatEntries](~~348779~~) operation to query the status of a FULLNAT entry.
 * *   If the FULLNAT entry is in the **Deleting** state, the system is deleting the FULLNAT entry. In this case, you can query the status of the FULLNAT entry, but cannot perform other operations.
 * *   If the FULLNAT entry cannot be found, the FULLNAT entry is deleted.
 * You cannot repeatedly call the **DeleteFullNatEntry** operation to delete a FULLNAT entry within the specified period of time.
 *
 * @param request DeleteFullNatEntryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteFullNatEntryResponse
 */
func (client *Client) DeleteFullNatEntryWithOptions(request *DeleteFullNatEntryRequest, runtime *util.RuntimeOptions) (_result *DeleteFullNatEntryResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.FullNatEntryId)) {
		query["FullNatEntryId"] = request.FullNatEntryId
	}

	if !tea.BoolValue(util.IsUnset(request.FullNatTableId)) {
		query["FullNatTableId"] = request.FullNatTableId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteFullNatEntry"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteFullNatEntryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * **DeleteFullNatEntry** is an asynchronous operation. After you make a request, the ID of the request is returned but the FULLNAT entry is not deleted. The system deletes the FULLNAT entry in the background. You can call the [ListFullNatEntries](~~348779~~) operation to query the status of a FULLNAT entry.
 * *   If the FULLNAT entry is in the **Deleting** state, the system is deleting the FULLNAT entry. In this case, you can query the status of the FULLNAT entry, but cannot perform other operations.
 * *   If the FULLNAT entry cannot be found, the FULLNAT entry is deleted.
 * You cannot repeatedly call the **DeleteFullNatEntry** operation to delete a FULLNAT entry within the specified period of time.
 *
 * @param request DeleteFullNatEntryRequest
 * @return DeleteFullNatEntryResponse
 */
func (client *Client) DeleteFullNatEntry(request *DeleteFullNatEntryRequest) (_result *DeleteFullNatEntryResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteFullNatEntryResponse{}
	_body, _err := client.DeleteFullNatEntryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * When you call this operation, take note of the following items:
 * *   You can delete only pay-as-you-go instances.
 * *   Before you can delete a dedicated instance, disassociate the backend server from the instance first.
 * *   Before you can delete a shared instance, disassociate the elastic IP address (EIP) from the instance first.
 *
 * @param request DeleteGlobalAccelerationInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteGlobalAccelerationInstanceResponse
 */
func (client *Client) DeleteGlobalAccelerationInstanceWithOptions(request *DeleteGlobalAccelerationInstanceRequest, runtime *util.RuntimeOptions) (_result *DeleteGlobalAccelerationInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.GlobalAccelerationInstanceId)) {
		query["GlobalAccelerationInstanceId"] = request.GlobalAccelerationInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteGlobalAccelerationInstance"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteGlobalAccelerationInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * When you call this operation, take note of the following items:
 * *   You can delete only pay-as-you-go instances.
 * *   Before you can delete a dedicated instance, disassociate the backend server from the instance first.
 * *   Before you can delete a shared instance, disassociate the elastic IP address (EIP) from the instance first.
 *
 * @param request DeleteGlobalAccelerationInstanceRequest
 * @return DeleteGlobalAccelerationInstanceResponse
 */
func (client *Client) DeleteGlobalAccelerationInstance(request *DeleteGlobalAccelerationInstanceRequest) (_result *DeleteGlobalAccelerationInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteGlobalAccelerationInstanceResponse{}
	_body, _err := client.DeleteGlobalAccelerationInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * When you call this operation, take note of the following rules:
 * *   You can delete only HAVIPs that are in the Available state.
 * *   Make sure that no route points to the HAVIP that you want to delete.
 * *   Make sure that no elastic IP address (EIP) is associated with the HAVIP that you want to delete.
 * *   The **DeleteHaVip** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeHaVips](~~114611~~) operation to query the status of an HAVIP:
 *     *   If the HAVIP is in the **Deleting** state, the HAVIP is being deleted.
 *     *   If you cannot query the HAVIP, the HAVIP is deleted.
 * *   You cannot repeatedly call the **DeleteHaVip** operation to delete an HAVIP within the specified period of time.
 *
 * @param request DeleteHaVipRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteHaVipResponse
 */
func (client *Client) DeleteHaVipWithOptions(request *DeleteHaVipRequest, runtime *util.RuntimeOptions) (_result *DeleteHaVipResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.HaVipId)) {
		query["HaVipId"] = request.HaVipId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteHaVip"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteHaVipResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * When you call this operation, take note of the following rules:
 * *   You can delete only HAVIPs that are in the Available state.
 * *   Make sure that no route points to the HAVIP that you want to delete.
 * *   Make sure that no elastic IP address (EIP) is associated with the HAVIP that you want to delete.
 * *   The **DeleteHaVip** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeHaVips](~~114611~~) operation to query the status of an HAVIP:
 *     *   If the HAVIP is in the **Deleting** state, the HAVIP is being deleted.
 *     *   If you cannot query the HAVIP, the HAVIP is deleted.
 * *   You cannot repeatedly call the **DeleteHaVip** operation to delete an HAVIP within the specified period of time.
 *
 * @param request DeleteHaVipRequest
 * @return DeleteHaVipResponse
 */
func (client *Client) DeleteHaVip(request *DeleteHaVipRequest) (_result *DeleteHaVipResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteHaVipResponse{}
	_body, _err := client.DeleteHaVipWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteIPv6TranslatorWithOptions(request *DeleteIPv6TranslatorRequest, runtime *util.RuntimeOptions) (_result *DeleteIPv6TranslatorResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Ipv6TranslatorId)) {
		query["Ipv6TranslatorId"] = request.Ipv6TranslatorId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteIPv6Translator"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteIPv6TranslatorResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteIPv6Translator(request *DeleteIPv6TranslatorRequest) (_result *DeleteIPv6TranslatorResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteIPv6TranslatorResponse{}
	_body, _err := client.DeleteIPv6TranslatorWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * @deprecated
 *
 * @param request DeleteIPv6TranslatorAclListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteIPv6TranslatorAclListResponse
 */
// Deprecated
func (client *Client) DeleteIPv6TranslatorAclListWithOptions(request *DeleteIPv6TranslatorAclListRequest, runtime *util.RuntimeOptions) (_result *DeleteIPv6TranslatorAclListResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AclId)) {
		query["AclId"] = request.AclId
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteIPv6TranslatorAclList"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteIPv6TranslatorAclListResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * @deprecated
 *
 * @param request DeleteIPv6TranslatorAclListRequest
 * @return DeleteIPv6TranslatorAclListResponse
 */
// Deprecated
func (client *Client) DeleteIPv6TranslatorAclList(request *DeleteIPv6TranslatorAclListRequest) (_result *DeleteIPv6TranslatorAclListResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteIPv6TranslatorAclListResponse{}
	_body, _err := client.DeleteIPv6TranslatorAclListWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * @deprecated
 *
 * @param request DeleteIPv6TranslatorEntryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteIPv6TranslatorEntryResponse
 */
// Deprecated
func (client *Client) DeleteIPv6TranslatorEntryWithOptions(request *DeleteIPv6TranslatorEntryRequest, runtime *util.RuntimeOptions) (_result *DeleteIPv6TranslatorEntryResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Ipv6TranslatorEntryId)) {
		query["Ipv6TranslatorEntryId"] = request.Ipv6TranslatorEntryId
	}

	if !tea.BoolValue(util.IsUnset(request.Ipv6TranslatorId)) {
		query["Ipv6TranslatorId"] = request.Ipv6TranslatorId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteIPv6TranslatorEntry"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteIPv6TranslatorEntryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * @deprecated
 *
 * @param request DeleteIPv6TranslatorEntryRequest
 * @return DeleteIPv6TranslatorEntryResponse
 */
// Deprecated
func (client *Client) DeleteIPv6TranslatorEntry(request *DeleteIPv6TranslatorEntryRequest) (_result *DeleteIPv6TranslatorEntryResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteIPv6TranslatorEntryResponse{}
	_body, _err := client.DeleteIPv6TranslatorEntryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   The **DeleteIpsecServer** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call [DescribeVpnGateway](~~73720~~) to query the status of a VPN gateway.
 *     *   If a VPN gateway is in the **updating** state, the IPsec server is being deleted.
 *     *   If a VPN gateway is in the **active** state, the IPsec server has been deleted.
 * *   You cannot repeatedly call **DeleteIpsecServer** to delete an IPsec server from a VPN gateway within the specified period of time.
 *
 * @param request DeleteIpsecServerRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteIpsecServerResponse
 */
func (client *Client) DeleteIpsecServerWithOptions(request *DeleteIpsecServerRequest, runtime *util.RuntimeOptions) (_result *DeleteIpsecServerResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.IpsecServerId)) {
		query["IpsecServerId"] = request.IpsecServerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteIpsecServer"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteIpsecServerResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   The **DeleteIpsecServer** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call [DescribeVpnGateway](~~73720~~) to query the status of a VPN gateway.
 *     *   If a VPN gateway is in the **updating** state, the IPsec server is being deleted.
 *     *   If a VPN gateway is in the **active** state, the IPsec server has been deleted.
 * *   You cannot repeatedly call **DeleteIpsecServer** to delete an IPsec server from a VPN gateway within the specified period of time.
 *
 * @param request DeleteIpsecServerRequest
 * @return DeleteIpsecServerResponse
 */
func (client *Client) DeleteIpsecServer(request *DeleteIpsecServerRequest) (_result *DeleteIpsecServerResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteIpsecServerResponse{}
	_body, _err := client.DeleteIpsecServerWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   Before you delete an IPv4 gateway, make sure that no route tables are associated with the IPv4 gateway.
 * *   The **DeleteIpv4Gateway** operation is an asynchronous operation. After you call this operation, the system returns a **request ID**. However, the deletion task is still being run in the background. You can call the [GetIpv4GatewayAttribute](~~407670~~) operation to query the status of the IPv4 gateway.
 *     *   If the IPv4 gateway is in the **Deleting** state, the IPv4 gateway is being deleted.
 *     *   If the IPv4 gateway cannot be queried, the deletion is complete.
 * *   After you call the **DeleteIpv4Gateway** operation to delete an IPv4 gateway, you cannot call the operation again to delete the IPv4 gateway until the deletion task is complete.
 *
 * @param request DeleteIpv4GatewayRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteIpv4GatewayResponse
 */
func (client *Client) DeleteIpv4GatewayWithOptions(request *DeleteIpv4GatewayRequest, runtime *util.RuntimeOptions) (_result *DeleteIpv4GatewayResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.Ipv4GatewayId)) {
		query["Ipv4GatewayId"] = request.Ipv4GatewayId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteIpv4Gateway"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteIpv4GatewayResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   Before you delete an IPv4 gateway, make sure that no route tables are associated with the IPv4 gateway.
 * *   The **DeleteIpv4Gateway** operation is an asynchronous operation. After you call this operation, the system returns a **request ID**. However, the deletion task is still being run in the background. You can call the [GetIpv4GatewayAttribute](~~407670~~) operation to query the status of the IPv4 gateway.
 *     *   If the IPv4 gateway is in the **Deleting** state, the IPv4 gateway is being deleted.
 *     *   If the IPv4 gateway cannot be queried, the deletion is complete.
 * *   After you call the **DeleteIpv4Gateway** operation to delete an IPv4 gateway, you cannot call the operation again to delete the IPv4 gateway until the deletion task is complete.
 *
 * @param request DeleteIpv4GatewayRequest
 * @return DeleteIpv4GatewayResponse
 */
func (client *Client) DeleteIpv4Gateway(request *DeleteIpv4GatewayRequest) (_result *DeleteIpv4GatewayResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteIpv4GatewayResponse{}
	_body, _err := client.DeleteIpv4GatewayWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   **DeleteIpv6EgressOnlyRule** is an asynchronous operation. After you send a request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeIpv6EgressOnlyRules](~~102208~~) operation to query whether the egress-only rule is deleted.
 *     *   If the egress-only rule is in the **Deleting** state, it indicates that the egress-only rule is being deleted.
 *     *   If you cannot query the egress-only rule, it indicates that the egress-only rule is deleted.
 * *   You cannot call the **DeleteIpv6EgressOnlyRule** operation to delete an egress-only rule again when the rule is being deleted.
 *
 * @param request DeleteIpv6EgressOnlyRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteIpv6EgressOnlyRuleResponse
 */
func (client *Client) DeleteIpv6EgressOnlyRuleWithOptions(request *DeleteIpv6EgressOnlyRuleRequest, runtime *util.RuntimeOptions) (_result *DeleteIpv6EgressOnlyRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Ipv6EgressOnlyRuleId)) {
		query["Ipv6EgressOnlyRuleId"] = request.Ipv6EgressOnlyRuleId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteIpv6EgressOnlyRule"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteIpv6EgressOnlyRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   **DeleteIpv6EgressOnlyRule** is an asynchronous operation. After you send a request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeIpv6EgressOnlyRules](~~102208~~) operation to query whether the egress-only rule is deleted.
 *     *   If the egress-only rule is in the **Deleting** state, it indicates that the egress-only rule is being deleted.
 *     *   If you cannot query the egress-only rule, it indicates that the egress-only rule is deleted.
 * *   You cannot call the **DeleteIpv6EgressOnlyRule** operation to delete an egress-only rule again when the rule is being deleted.
 *
 * @param request DeleteIpv6EgressOnlyRuleRequest
 * @return DeleteIpv6EgressOnlyRuleResponse
 */
func (client *Client) DeleteIpv6EgressOnlyRule(request *DeleteIpv6EgressOnlyRuleRequest) (_result *DeleteIpv6EgressOnlyRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteIpv6EgressOnlyRuleResponse{}
	_body, _err := client.DeleteIpv6EgressOnlyRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * - The **DeleteIpv6Gateway** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeIpv6GatewayAttribute](/help/en/virtual-private-cloud/latest/describeipv6gatewayattribute) operation to query the status of an IPv6 gateway:   - If the IPv6 gateway is in the **Deleting** state, the IPv6 gateway is being deleted.
 *   - If you cannot query the IPv6 gateway, the IPv6 gateway is deleted.
 * - After you call the **DeleteIpv6Gateway** operation to delete an IPv6 gateway, you cannot call the operation again to delete the IPv6 gateway until the deletion task is complete.
 * ## Prerequisites
 * Before you delete an IPv6 gateway, you must delete the egress-only rules of the IPv6 gateway. For more information, see [DeleteIpv6EgressOnlyRule](~~102201~~).
 *
 * @param request DeleteIpv6GatewayRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteIpv6GatewayResponse
 */
func (client *Client) DeleteIpv6GatewayWithOptions(request *DeleteIpv6GatewayRequest, runtime *util.RuntimeOptions) (_result *DeleteIpv6GatewayResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Ipv6GatewayId)) {
		query["Ipv6GatewayId"] = request.Ipv6GatewayId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteIpv6Gateway"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteIpv6GatewayResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * - The **DeleteIpv6Gateway** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeIpv6GatewayAttribute](/help/en/virtual-private-cloud/latest/describeipv6gatewayattribute) operation to query the status of an IPv6 gateway:   - If the IPv6 gateway is in the **Deleting** state, the IPv6 gateway is being deleted.
 *   - If you cannot query the IPv6 gateway, the IPv6 gateway is deleted.
 * - After you call the **DeleteIpv6Gateway** operation to delete an IPv6 gateway, you cannot call the operation again to delete the IPv6 gateway until the deletion task is complete.
 * ## Prerequisites
 * Before you delete an IPv6 gateway, you must delete the egress-only rules of the IPv6 gateway. For more information, see [DeleteIpv6EgressOnlyRule](~~102201~~).
 *
 * @param request DeleteIpv6GatewayRequest
 * @return DeleteIpv6GatewayResponse
 */
func (client *Client) DeleteIpv6Gateway(request *DeleteIpv6GatewayRequest) (_result *DeleteIpv6GatewayResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteIpv6GatewayResponse{}
	_body, _err := client.DeleteIpv6GatewayWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You cannot call the **DeleteIpv6InternetBandwidth** operation to delete the same Internet bandwidth at the same time.
 *
 * @param request DeleteIpv6InternetBandwidthRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteIpv6InternetBandwidthResponse
 */
func (client *Client) DeleteIpv6InternetBandwidthWithOptions(request *DeleteIpv6InternetBandwidthRequest, runtime *util.RuntimeOptions) (_result *DeleteIpv6InternetBandwidthResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Ipv6AddressId)) {
		query["Ipv6AddressId"] = request.Ipv6AddressId
	}

	if !tea.BoolValue(util.IsUnset(request.Ipv6InternetBandwidthId)) {
		query["Ipv6InternetBandwidthId"] = request.Ipv6InternetBandwidthId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteIpv6InternetBandwidth"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteIpv6InternetBandwidthResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You cannot call the **DeleteIpv6InternetBandwidth** operation to delete the same Internet bandwidth at the same time.
 *
 * @param request DeleteIpv6InternetBandwidthRequest
 * @return DeleteIpv6InternetBandwidthResponse
 */
func (client *Client) DeleteIpv6InternetBandwidth(request *DeleteIpv6InternetBandwidthRequest) (_result *DeleteIpv6InternetBandwidthResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteIpv6InternetBandwidthResponse{}
	_body, _err := client.DeleteIpv6InternetBandwidthWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   **DeleteNatGateway** is an asynchronous operation. After you make a request, the ID of the request is returned but the NAT gateway is not deleted. The system deletes the NAT gateway in the background. You can call the [DescribeNatGateways](~~36054~~) to query the status of a NAT gateway.
 *     *   If a NAT gateway is in the **Deleting** state, the NAT gateway is being deleted. In this case, you can query the NAT gateway but you cannot perform other operations.
 *     *   If the NAY gateway cannot be found, the NAT gateway is deleted.
 *         After you delete a NAT gateway, you cannot restore the NAT gateway. Proceed with caution.
 * *   You cannot repeatedly call the **DeleteNatGateway** operation to delete a NAT gateway within the specified period of time.
 *
 * @param request DeleteNatGatewayRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteNatGatewayResponse
 */
func (client *Client) DeleteNatGatewayWithOptions(request *DeleteNatGatewayRequest, runtime *util.RuntimeOptions) (_result *DeleteNatGatewayResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Force)) {
		query["Force"] = request.Force
	}

	if !tea.BoolValue(util.IsUnset(request.NatGatewayId)) {
		query["NatGatewayId"] = request.NatGatewayId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteNatGateway"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteNatGatewayResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   **DeleteNatGateway** is an asynchronous operation. After you make a request, the ID of the request is returned but the NAT gateway is not deleted. The system deletes the NAT gateway in the background. You can call the [DescribeNatGateways](~~36054~~) to query the status of a NAT gateway.
 *     *   If a NAT gateway is in the **Deleting** state, the NAT gateway is being deleted. In this case, you can query the NAT gateway but you cannot perform other operations.
 *     *   If the NAY gateway cannot be found, the NAT gateway is deleted.
 *         After you delete a NAT gateway, you cannot restore the NAT gateway. Proceed with caution.
 * *   You cannot repeatedly call the **DeleteNatGateway** operation to delete a NAT gateway within the specified period of time.
 *
 * @param request DeleteNatGatewayRequest
 * @return DeleteNatGatewayResponse
 */
func (client *Client) DeleteNatGateway(request *DeleteNatGatewayRequest) (_result *DeleteNatGatewayResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteNatGatewayResponse{}
	_body, _err := client.DeleteNatGatewayWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   **DeleteNatIp** is an asynchronous operation. After you make a request, the ID of the request is returned but the specified NAT IP address is not deleted. The system deletes the NAT IP address in the background. You can call the [ListNatIps](~~281979~~) operation to query the status of a NAT IP address.
 *     *   If a NAT IP address is in the **Deleting** state, the NAT IP address is being deleted. In this case, you can only query the NAT IP address but cannot perform other operations.
 *     *   If the NAT IP address cannot be found, it is deleted.
 * *   You cannot repeatedly call the **DeleteNatIp** operation to delete a NAT IP address within the specified period of time.
 *
 * @param request DeleteNatIpRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteNatIpResponse
 */
func (client *Client) DeleteNatIpWithOptions(request *DeleteNatIpRequest, runtime *util.RuntimeOptions) (_result *DeleteNatIpResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.NatIpId)) {
		query["NatIpId"] = request.NatIpId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteNatIp"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteNatIpResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   **DeleteNatIp** is an asynchronous operation. After you make a request, the ID of the request is returned but the specified NAT IP address is not deleted. The system deletes the NAT IP address in the background. You can call the [ListNatIps](~~281979~~) operation to query the status of a NAT IP address.
 *     *   If a NAT IP address is in the **Deleting** state, the NAT IP address is being deleted. In this case, you can only query the NAT IP address but cannot perform other operations.
 *     *   If the NAT IP address cannot be found, it is deleted.
 * *   You cannot repeatedly call the **DeleteNatIp** operation to delete a NAT IP address within the specified period of time.
 *
 * @param request DeleteNatIpRequest
 * @return DeleteNatIpResponse
 */
func (client *Client) DeleteNatIp(request *DeleteNatIpRequest) (_result *DeleteNatIpResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteNatIpResponse{}
	_body, _err := client.DeleteNatIpWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You cannot repeatedly call the **DeleteNatIpCidr** operation to delete a NAT CIDR block within the specified period of time.
 *
 * @param request DeleteNatIpCidrRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteNatIpCidrResponse
 */
func (client *Client) DeleteNatIpCidrWithOptions(request *DeleteNatIpCidrRequest, runtime *util.RuntimeOptions) (_result *DeleteNatIpCidrResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.NatGatewayId)) {
		query["NatGatewayId"] = request.NatGatewayId
	}

	if !tea.BoolValue(util.IsUnset(request.NatIpCidr)) {
		query["NatIpCidr"] = request.NatIpCidr
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteNatIpCidr"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteNatIpCidrResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You cannot repeatedly call the **DeleteNatIpCidr** operation to delete a NAT CIDR block within the specified period of time.
 *
 * @param request DeleteNatIpCidrRequest
 * @return DeleteNatIpCidrResponse
 */
func (client *Client) DeleteNatIpCidr(request *DeleteNatIpCidrRequest) (_result *DeleteNatIpCidrResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteNatIpCidrResponse{}
	_body, _err := client.DeleteNatIpCidrWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You cannot repeatedly call the **DeleteNetworkAcl** operation to delete a network ACL within the specified period of time.
 *
 * @param request DeleteNetworkAclRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteNetworkAclResponse
 */
func (client *Client) DeleteNetworkAclWithOptions(request *DeleteNetworkAclRequest, runtime *util.RuntimeOptions) (_result *DeleteNetworkAclResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.NetworkAclId)) {
		query["NetworkAclId"] = request.NetworkAclId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteNetworkAcl"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteNetworkAclResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You cannot repeatedly call the **DeleteNetworkAcl** operation to delete a network ACL within the specified period of time.
 *
 * @param request DeleteNetworkAclRequest
 * @return DeleteNetworkAclResponse
 */
func (client *Client) DeleteNetworkAcl(request *DeleteNetworkAclRequest) (_result *DeleteNetworkAclResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteNetworkAclResponse{}
	_body, _err := client.DeleteNetworkAclWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limit
 * You can only delete a connection over an Express Connect circuit that is in the **Rejected**, **Canceled**, **AllocationFailed**, or **Terminated** state.
 *
 * @param request DeletePhysicalConnectionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeletePhysicalConnectionResponse
 */
func (client *Client) DeletePhysicalConnectionWithOptions(request *DeletePhysicalConnectionRequest, runtime *util.RuntimeOptions) (_result *DeletePhysicalConnectionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PhysicalConnectionId)) {
		query["PhysicalConnectionId"] = request.PhysicalConnectionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeletePhysicalConnection"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeletePhysicalConnectionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limit
 * You can only delete a connection over an Express Connect circuit that is in the **Rejected**, **Canceled**, **AllocationFailed**, or **Terminated** state.
 *
 * @param request DeletePhysicalConnectionRequest
 * @return DeletePhysicalConnectionResponse
 */
func (client *Client) DeletePhysicalConnection(request *DeletePhysicalConnectionRequest) (_result *DeletePhysicalConnectionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeletePhysicalConnectionResponse{}
	_body, _err := client.DeletePhysicalConnectionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   The **DeletePublicIpAddressPool** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [ListPublicIpAddressPools](~~429433~~) operation to query the status of an IP address pool:
 *     *   If the IP address pool is in the **Deleting** state, the IP address pool is being deleted. In this state. you can only query the IP address pool and cannot perform other operations.
 *     *   If you cannot query the IP address pool, the IP address pool is deleted.
 * *   You cannot repeatedly call the **DeletePublicIpAddressPool** operation to delete an IP address pool within the specified period of time.
 * ## Prerequisites
 * Before you delete an IP address pool, make sure that no IP address in the pool is being used.
 *
 * @param request DeletePublicIpAddressPoolRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeletePublicIpAddressPoolResponse
 */
func (client *Client) DeletePublicIpAddressPoolWithOptions(request *DeletePublicIpAddressPoolRequest, runtime *util.RuntimeOptions) (_result *DeletePublicIpAddressPoolResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PublicIpAddressPoolId)) {
		query["PublicIpAddressPoolId"] = request.PublicIpAddressPoolId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeletePublicIpAddressPool"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeletePublicIpAddressPoolResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   The **DeletePublicIpAddressPool** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [ListPublicIpAddressPools](~~429433~~) operation to query the status of an IP address pool:
 *     *   If the IP address pool is in the **Deleting** state, the IP address pool is being deleted. In this state. you can only query the IP address pool and cannot perform other operations.
 *     *   If you cannot query the IP address pool, the IP address pool is deleted.
 * *   You cannot repeatedly call the **DeletePublicIpAddressPool** operation to delete an IP address pool within the specified period of time.
 * ## Prerequisites
 * Before you delete an IP address pool, make sure that no IP address in the pool is being used.
 *
 * @param request DeletePublicIpAddressPoolRequest
 * @return DeletePublicIpAddressPoolResponse
 */
func (client *Client) DeletePublicIpAddressPool(request *DeletePublicIpAddressPoolRequest) (_result *DeletePublicIpAddressPoolResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeletePublicIpAddressPoolResponse{}
	_body, _err := client.DeletePublicIpAddressPoolWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   The **DeletePublicIpAddressPoolCidrBlock** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [ListPublicIpAddressPoolCidrBlocks](~~429436~~) operation to query the status of a CIDR block in an IP address pool:
 *     *   If the CIDR block is in the **Deleting** state, the CIDR block is being deleted. In this state, you can only query the CIDR block and cannot perform other operations.
 *     *   If you cannot query the CIDR block, the CIDR block is deleted.
 * *   You cannot repeatedly call the **DeletePublicIpAddressPoolCidrBlock** operation to delete a CIDR block within the specified period of time.
 * ## Prerequisites
 * Before you delete a CIDR block, make sure that it is not being used.
 *
 * @param request DeletePublicIpAddressPoolCidrBlockRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeletePublicIpAddressPoolCidrBlockResponse
 */
func (client *Client) DeletePublicIpAddressPoolCidrBlockWithOptions(request *DeletePublicIpAddressPoolCidrBlockRequest, runtime *util.RuntimeOptions) (_result *DeletePublicIpAddressPoolCidrBlockResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CidrBlock)) {
		query["CidrBlock"] = request.CidrBlock
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PublicIpAddressPoolId)) {
		query["PublicIpAddressPoolId"] = request.PublicIpAddressPoolId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeletePublicIpAddressPoolCidrBlock"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeletePublicIpAddressPoolCidrBlockResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   The **DeletePublicIpAddressPoolCidrBlock** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [ListPublicIpAddressPoolCidrBlocks](~~429436~~) operation to query the status of a CIDR block in an IP address pool:
 *     *   If the CIDR block is in the **Deleting** state, the CIDR block is being deleted. In this state, you can only query the CIDR block and cannot perform other operations.
 *     *   If you cannot query the CIDR block, the CIDR block is deleted.
 * *   You cannot repeatedly call the **DeletePublicIpAddressPoolCidrBlock** operation to delete a CIDR block within the specified period of time.
 * ## Prerequisites
 * Before you delete a CIDR block, make sure that it is not being used.
 *
 * @param request DeletePublicIpAddressPoolCidrBlockRequest
 * @return DeletePublicIpAddressPoolCidrBlockResponse
 */
func (client *Client) DeletePublicIpAddressPoolCidrBlock(request *DeletePublicIpAddressPoolCidrBlockRequest) (_result *DeletePublicIpAddressPoolCidrBlockResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeletePublicIpAddressPoolCidrBlockResponse{}
	_body, _err := client.DeletePublicIpAddressPoolCidrBlockWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * When you call this operation, take note of the following items:
 * *   You can delete only route entries that are in the **Available** state.
 * *   You cannot delete a route entry of a virtual private cloud (VPC) in which a vSwitch or another route entry is being created or deleted.
 * *   **DeleteRouteEntries** is an asynchronous operation. After you call this operation, the system returns a request ID and runs the task in the background. You can call the [DescribeRouteEntryList](~~138148~~) operation to query the status of a route entry.
 *     *   If the route entry is in the **Deleting** state, the route entry is being deleted.
 *     *   If you cannot query the route entry, the route entry is deleted.
 * *   You cannot repeatedly call **DeleteRouteEntries** within a specific period of time.
 *
 * @param request DeleteRouteEntriesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteRouteEntriesResponse
 */
func (client *Client) DeleteRouteEntriesWithOptions(request *DeleteRouteEntriesRequest, runtime *util.RuntimeOptions) (_result *DeleteRouteEntriesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RouteEntries)) {
		query["RouteEntries"] = request.RouteEntries
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteRouteEntries"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteRouteEntriesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * When you call this operation, take note of the following items:
 * *   You can delete only route entries that are in the **Available** state.
 * *   You cannot delete a route entry of a virtual private cloud (VPC) in which a vSwitch or another route entry is being created or deleted.
 * *   **DeleteRouteEntries** is an asynchronous operation. After you call this operation, the system returns a request ID and runs the task in the background. You can call the [DescribeRouteEntryList](~~138148~~) operation to query the status of a route entry.
 *     *   If the route entry is in the **Deleting** state, the route entry is being deleted.
 *     *   If you cannot query the route entry, the route entry is deleted.
 * *   You cannot repeatedly call **DeleteRouteEntries** within a specific period of time.
 *
 * @param request DeleteRouteEntriesRequest
 * @return DeleteRouteEntriesResponse
 */
func (client *Client) DeleteRouteEntries(request *DeleteRouteEntriesRequest) (_result *DeleteRouteEntriesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteRouteEntriesResponse{}
	_body, _err := client.DeleteRouteEntriesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * When you call this operation, take note of the following rules:
 * *   You can delete only routes that are in the **Available** state.
 * *   You cannot delete a route of a virtual private cloud (VPC) in which a vSwitch or a route is being created.
 * *   Before you call this operation to delete a route of a VBR route table, call the [DescribeRouteEntryList](~~138148~~) operation to query the **NextHopId** of the route first.
 * *   The **DeleteRouteEntry** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeRouteEntryList](~~138148~~) operation to query the status of a route:
 *     *   If the route is in the **Deleting** state, the route is being deleted.
 *     *   If you cannot query the route, the route is deleted.
 * *   You cannot repeatedly call the **DeleteRouteEntry** operation to delete a route from the route table of a vRouter or a VBR within the specified period of time.
 *
 * @param request DeleteRouteEntryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteRouteEntryResponse
 */
func (client *Client) DeleteRouteEntryWithOptions(request *DeleteRouteEntryRequest, runtime *util.RuntimeOptions) (_result *DeleteRouteEntryResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DestinationCidrBlock)) {
		query["DestinationCidrBlock"] = request.DestinationCidrBlock
	}

	if !tea.BoolValue(util.IsUnset(request.NextHopId)) {
		query["NextHopId"] = request.NextHopId
	}

	if !tea.BoolValue(util.IsUnset(request.NextHopList)) {
		query["NextHopList"] = request.NextHopList
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RouteEntryId)) {
		query["RouteEntryId"] = request.RouteEntryId
	}

	if !tea.BoolValue(util.IsUnset(request.RouteTableId)) {
		query["RouteTableId"] = request.RouteTableId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteRouteEntry"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteRouteEntryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * When you call this operation, take note of the following rules:
 * *   You can delete only routes that are in the **Available** state.
 * *   You cannot delete a route of a virtual private cloud (VPC) in which a vSwitch or a route is being created.
 * *   Before you call this operation to delete a route of a VBR route table, call the [DescribeRouteEntryList](~~138148~~) operation to query the **NextHopId** of the route first.
 * *   The **DeleteRouteEntry** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeRouteEntryList](~~138148~~) operation to query the status of a route:
 *     *   If the route is in the **Deleting** state, the route is being deleted.
 *     *   If you cannot query the route, the route is deleted.
 * *   You cannot repeatedly call the **DeleteRouteEntry** operation to delete a route from the route table of a vRouter or a VBR within the specified period of time.
 *
 * @param request DeleteRouteEntryRequest
 * @return DeleteRouteEntryResponse
 */
func (client *Client) DeleteRouteEntry(request *DeleteRouteEntryRequest) (_result *DeleteRouteEntryResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteRouteEntryResponse{}
	_body, _err := client.DeleteRouteEntryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   The **DeleteRouteTable** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeRouteTableList](~~87602~~) operation to query the status of a custom route table:
 *     *   If the custom route table is in the **Deleting** state, the custom route table is being deleted.
 *     *   If you cannot query the custom route table, the custom route table is deleted.
 * *   You cannot repeatedly call the **DeleteRouteTable** operation to delete a custom route table within the specified period of time.
 *
 * @param request DeleteRouteTableRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteRouteTableResponse
 */
func (client *Client) DeleteRouteTableWithOptions(request *DeleteRouteTableRequest, runtime *util.RuntimeOptions) (_result *DeleteRouteTableResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RouteTableId)) {
		query["RouteTableId"] = request.RouteTableId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteRouteTable"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteRouteTableResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   The **DeleteRouteTable** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeRouteTableList](~~87602~~) operation to query the status of a custom route table:
 *     *   If the custom route table is in the **Deleting** state, the custom route table is being deleted.
 *     *   If you cannot query the custom route table, the custom route table is deleted.
 * *   You cannot repeatedly call the **DeleteRouteTable** operation to delete a custom route table within the specified period of time.
 *
 * @param request DeleteRouteTableRequest
 * @return DeleteRouteTableResponse
 */
func (client *Client) DeleteRouteTable(request *DeleteRouteTableRequest) (_result *DeleteRouteTableResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteRouteTableResponse{}
	_body, _err := client.DeleteRouteTableWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * When you call this operation, take note of the following limits:
 * *   You can delete only a router interface that is in the **Idle** or **Inactive** state.
 * *   Before you delete a router interface, you must delete all custom route entries destined for the router interface.
 *
 * @param request DeleteRouterInterfaceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteRouterInterfaceResponse
 */
func (client *Client) DeleteRouterInterfaceWithOptions(request *DeleteRouterInterfaceRequest, runtime *util.RuntimeOptions) (_result *DeleteRouterInterfaceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RouterInterfaceId)) {
		query["RouterInterfaceId"] = request.RouterInterfaceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteRouterInterface"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteRouterInterfaceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * When you call this operation, take note of the following limits:
 * *   You can delete only a router interface that is in the **Idle** or **Inactive** state.
 * *   Before you delete a router interface, you must delete all custom route entries destined for the router interface.
 *
 * @param request DeleteRouterInterfaceRequest
 * @return DeleteRouterInterfaceResponse
 */
func (client *Client) DeleteRouterInterface(request *DeleteRouterInterfaceRequest) (_result *DeleteRouterInterfaceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteRouterInterfaceResponse{}
	_body, _err := client.DeleteRouterInterfaceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * DeleteSnatEntry is an asynchronous operation. After you make a request, the ID of the request is returned but the specified SNAT entry is not deleted. The system deletes the SNAT entry in the background. You can call the [DescribeSnatTableEntries](~~42677~~) operation to query the status of SNAT entries.
 * *   If the SNAT entries are in the **Deleting** state, the system is deleting the SNAT entries. In this case, you can only query the status of the SNAT entries, and cannot perform other operations.
 * *   If no SNAT entry is returned in the response, the SNAT entry is deleted.
 * If some SNAT entries are in the **Pending** state, you cannot delete these SNAT entries.
 *
 * @param request DeleteSnatEntryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteSnatEntryResponse
 */
func (client *Client) DeleteSnatEntryWithOptions(request *DeleteSnatEntryRequest, runtime *util.RuntimeOptions) (_result *DeleteSnatEntryResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SnatEntryId)) {
		query["SnatEntryId"] = request.SnatEntryId
	}

	if !tea.BoolValue(util.IsUnset(request.SnatTableId)) {
		query["SnatTableId"] = request.SnatTableId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteSnatEntry"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteSnatEntryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * DeleteSnatEntry is an asynchronous operation. After you make a request, the ID of the request is returned but the specified SNAT entry is not deleted. The system deletes the SNAT entry in the background. You can call the [DescribeSnatTableEntries](~~42677~~) operation to query the status of SNAT entries.
 * *   If the SNAT entries are in the **Deleting** state, the system is deleting the SNAT entries. In this case, you can only query the status of the SNAT entries, and cannot perform other operations.
 * *   If no SNAT entry is returned in the response, the SNAT entry is deleted.
 * If some SNAT entries are in the **Pending** state, you cannot delete these SNAT entries.
 *
 * @param request DeleteSnatEntryRequest
 * @return DeleteSnatEntryResponse
 */
func (client *Client) DeleteSnatEntry(request *DeleteSnatEntryRequest) (_result *DeleteSnatEntryResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteSnatEntryResponse{}
	_body, _err := client.DeleteSnatEntryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   The **DeleteSslVpnClientCert** operation is asynchronous. After you send a request, the system returns a request ID. However, the operation is still being performed in the system background. You can call [DescribeVpnGateway](~~73720~~) to query the status of a VPN gateway associated with an SSL server. You can check whether an SSL client certificate is deleted based on the status of the VPN gateway.
 *     *   If the VPN gateway is in the **updating** state, the SSL client certificate is being deleted.
 *     *   If the VPN gateway is in the **active** state, the SSL client certificate is deleted.
 * *   You cannot repeatedly call **DeleteSslVpnClientCert** to delete an SSL client certificate from the same VPN gateway within the specified period of time.
 *
 * @param request DeleteSslVpnClientCertRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteSslVpnClientCertResponse
 */
func (client *Client) DeleteSslVpnClientCertWithOptions(request *DeleteSslVpnClientCertRequest, runtime *util.RuntimeOptions) (_result *DeleteSslVpnClientCertResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SslVpnClientCertId)) {
		query["SslVpnClientCertId"] = request.SslVpnClientCertId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteSslVpnClientCert"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteSslVpnClientCertResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   The **DeleteSslVpnClientCert** operation is asynchronous. After you send a request, the system returns a request ID. However, the operation is still being performed in the system background. You can call [DescribeVpnGateway](~~73720~~) to query the status of a VPN gateway associated with an SSL server. You can check whether an SSL client certificate is deleted based on the status of the VPN gateway.
 *     *   If the VPN gateway is in the **updating** state, the SSL client certificate is being deleted.
 *     *   If the VPN gateway is in the **active** state, the SSL client certificate is deleted.
 * *   You cannot repeatedly call **DeleteSslVpnClientCert** to delete an SSL client certificate from the same VPN gateway within the specified period of time.
 *
 * @param request DeleteSslVpnClientCertRequest
 * @return DeleteSslVpnClientCertResponse
 */
func (client *Client) DeleteSslVpnClientCert(request *DeleteSslVpnClientCertRequest) (_result *DeleteSslVpnClientCertResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteSslVpnClientCertResponse{}
	_body, _err := client.DeleteSslVpnClientCertWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   The **DeleteSslVpnServer** operation is asynchronous. After you send a request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeVpnGateway](~~73720~~) operation to query the status of an SSL server based on the status of the associated VPN gateway.
 *     *   If the VPN gateway is in the **updating** state, the SSL server is being deleted.
 *     *   If the VPN gateway is in the **active** state, the SSL server is deleted.
 * *   You cannot repeatedly call the **DeleteSslVpnServer** operation to delete an SSL server from the same VPN gateway within the specified period of time.
 *
 * @param request DeleteSslVpnServerRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteSslVpnServerResponse
 */
func (client *Client) DeleteSslVpnServerWithOptions(request *DeleteSslVpnServerRequest, runtime *util.RuntimeOptions) (_result *DeleteSslVpnServerResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SslVpnServerId)) {
		query["SslVpnServerId"] = request.SslVpnServerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteSslVpnServer"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteSslVpnServerResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   The **DeleteSslVpnServer** operation is asynchronous. After you send a request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeVpnGateway](~~73720~~) operation to query the status of an SSL server based on the status of the associated VPN gateway.
 *     *   If the VPN gateway is in the **updating** state, the SSL server is being deleted.
 *     *   If the VPN gateway is in the **active** state, the SSL server is deleted.
 * *   You cannot repeatedly call the **DeleteSslVpnServer** operation to delete an SSL server from the same VPN gateway within the specified period of time.
 *
 * @param request DeleteSslVpnServerRequest
 * @return DeleteSslVpnServerResponse
 */
func (client *Client) DeleteSslVpnServer(request *DeleteSslVpnServerRequest) (_result *DeleteSslVpnServerResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteSslVpnServerResponse{}
	_body, _err := client.DeleteSslVpnServerWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   The **DeleteTrafficMirrorFilter** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [ListTrafficMirrorFilters](~~261353~~) operation to query the status of a filter:
 *     *   If the filter is in the **Deleting** state, the filter is being deleted.
 *     *   If you cannot query the filter, the filter is deleted.
 * *   You cannot repeatedly call the **DeleteTrafficMirrorFilter** operation to delete a filter within the specified period of time.
 *
 * @param request DeleteTrafficMirrorFilterRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteTrafficMirrorFilterResponse
 */
func (client *Client) DeleteTrafficMirrorFilterWithOptions(request *DeleteTrafficMirrorFilterRequest, runtime *util.RuntimeOptions) (_result *DeleteTrafficMirrorFilterResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.TrafficMirrorFilterId)) {
		query["TrafficMirrorFilterId"] = request.TrafficMirrorFilterId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteTrafficMirrorFilter"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteTrafficMirrorFilterResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   The **DeleteTrafficMirrorFilter** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [ListTrafficMirrorFilters](~~261353~~) operation to query the status of a filter:
 *     *   If the filter is in the **Deleting** state, the filter is being deleted.
 *     *   If you cannot query the filter, the filter is deleted.
 * *   You cannot repeatedly call the **DeleteTrafficMirrorFilter** operation to delete a filter within the specified period of time.
 *
 * @param request DeleteTrafficMirrorFilterRequest
 * @return DeleteTrafficMirrorFilterResponse
 */
func (client *Client) DeleteTrafficMirrorFilter(request *DeleteTrafficMirrorFilterRequest) (_result *DeleteTrafficMirrorFilterResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteTrafficMirrorFilterResponse{}
	_body, _err := client.DeleteTrafficMirrorFilterWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   The **DeleteTrafficMirrorFilterRules** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [ListTrafficMirrorFilters](~~261353~~) operation to query the status of an inbound or outbound rule:
 *     *   If the rule is in the **Deleting** state, the rule is being deleted.
 *     *   If you cannot query the rule, the rule is deleted.
 * *   You cannot repeatedly call the **DeleteTrafficMirrorFilterRules** operation to delete an inbound or outbound rule within the specified period of time.
 *
 * @param request DeleteTrafficMirrorFilterRulesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteTrafficMirrorFilterRulesResponse
 */
func (client *Client) DeleteTrafficMirrorFilterRulesWithOptions(request *DeleteTrafficMirrorFilterRulesRequest, runtime *util.RuntimeOptions) (_result *DeleteTrafficMirrorFilterRulesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.TrafficMirrorFilterId)) {
		query["TrafficMirrorFilterId"] = request.TrafficMirrorFilterId
	}

	if !tea.BoolValue(util.IsUnset(request.TrafficMirrorFilterRuleIds)) {
		query["TrafficMirrorFilterRuleIds"] = request.TrafficMirrorFilterRuleIds
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteTrafficMirrorFilterRules"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteTrafficMirrorFilterRulesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   The **DeleteTrafficMirrorFilterRules** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [ListTrafficMirrorFilters](~~261353~~) operation to query the status of an inbound or outbound rule:
 *     *   If the rule is in the **Deleting** state, the rule is being deleted.
 *     *   If you cannot query the rule, the rule is deleted.
 * *   You cannot repeatedly call the **DeleteTrafficMirrorFilterRules** operation to delete an inbound or outbound rule within the specified period of time.
 *
 * @param request DeleteTrafficMirrorFilterRulesRequest
 * @return DeleteTrafficMirrorFilterRulesResponse
 */
func (client *Client) DeleteTrafficMirrorFilterRules(request *DeleteTrafficMirrorFilterRulesRequest) (_result *DeleteTrafficMirrorFilterRulesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteTrafficMirrorFilterRulesResponse{}
	_body, _err := client.DeleteTrafficMirrorFilterRulesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   **DeleteTrafficMirrorSession** is an asynchronous operation. After you send the request, the system returns a request ID and runs the task in the background. You can call the [ListTrafficMirrorSessions](~~261367~~) operation to query the status of a traffic mirror session.
 *     *   If the traffic mirror session is in the **Deleting** state, the traffic mirror session is being deleted.
 *     *   If you cannot query the traffic mirror session, the traffic mirror session is deleted.
 * *   You cannot repeatedly call the **DeleteTrafficMirrorSession** operation to delete a traffic mirror session within the specified period of time.
 *
 * @param request DeleteTrafficMirrorSessionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteTrafficMirrorSessionResponse
 */
func (client *Client) DeleteTrafficMirrorSessionWithOptions(request *DeleteTrafficMirrorSessionRequest, runtime *util.RuntimeOptions) (_result *DeleteTrafficMirrorSessionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.TrafficMirrorSessionId)) {
		query["TrafficMirrorSessionId"] = request.TrafficMirrorSessionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteTrafficMirrorSession"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteTrafficMirrorSessionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   **DeleteTrafficMirrorSession** is an asynchronous operation. After you send the request, the system returns a request ID and runs the task in the background. You can call the [ListTrafficMirrorSessions](~~261367~~) operation to query the status of a traffic mirror session.
 *     *   If the traffic mirror session is in the **Deleting** state, the traffic mirror session is being deleted.
 *     *   If you cannot query the traffic mirror session, the traffic mirror session is deleted.
 * *   You cannot repeatedly call the **DeleteTrafficMirrorSession** operation to delete a traffic mirror session within the specified period of time.
 *
 * @param request DeleteTrafficMirrorSessionRequest
 * @return DeleteTrafficMirrorSessionResponse
 */
func (client *Client) DeleteTrafficMirrorSession(request *DeleteTrafficMirrorSessionRequest) (_result *DeleteTrafficMirrorSessionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteTrafficMirrorSessionResponse{}
	_body, _err := client.DeleteTrafficMirrorSessionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * When you call this operation, take note of the following limits:
 * *   Before you delete a vSwitch, you must first release or remove all virtual private cloud (VPC) resources, including vSwitches, instances, router interfaces, and high-availability virtual IP addresses (HAVIPs).
 * *   You can delete only vSwitches that are in the **Available** state.
 * *   You cannot delete a vSwitch from a VPC where a vSwitch or a route is being created or deleted.
 * *   **DeleteVSwitch** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeVSwitchAttributes](~~94567~~) operation to query the status of a vSwitch:
 *     *   If the vSwitch is in the **Pending** state, the vSwitch is being deleted.
 *     *   If you cannot query the vSwitch, the vSwitch is deleted.
 * *   You cannot repeatedly call the **DeleteVSwitch** operation to delete a vSwitch within the specified period of time.
 *
 * @param request DeleteVSwitchRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteVSwitchResponse
 */
func (client *Client) DeleteVSwitchWithOptions(request *DeleteVSwitchRequest, runtime *util.RuntimeOptions) (_result *DeleteVSwitchResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.VSwitchId)) {
		query["VSwitchId"] = request.VSwitchId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteVSwitch"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteVSwitchResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * When you call this operation, take note of the following limits:
 * *   Before you delete a vSwitch, you must first release or remove all virtual private cloud (VPC) resources, including vSwitches, instances, router interfaces, and high-availability virtual IP addresses (HAVIPs).
 * *   You can delete only vSwitches that are in the **Available** state.
 * *   You cannot delete a vSwitch from a VPC where a vSwitch or a route is being created or deleted.
 * *   **DeleteVSwitch** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeVSwitchAttributes](~~94567~~) operation to query the status of a vSwitch:
 *     *   If the vSwitch is in the **Pending** state, the vSwitch is being deleted.
 *     *   If you cannot query the vSwitch, the vSwitch is deleted.
 * *   You cannot repeatedly call the **DeleteVSwitch** operation to delete a vSwitch within the specified period of time.
 *
 * @param request DeleteVSwitchRequest
 * @return DeleteVSwitchResponse
 */
func (client *Client) DeleteVSwitch(request *DeleteVSwitchRequest) (_result *DeleteVSwitchResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteVSwitchResponse{}
	_body, _err := client.DeleteVSwitchWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteVbrHaWithOptions(request *DeleteVbrHaRequest, runtime *util.RuntimeOptions) (_result *DeleteVbrHaResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteVbrHa"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteVbrHaResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteVbrHa(request *DeleteVbrHaRequest) (_result *DeleteVbrHaResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteVbrHaResponse{}
	_body, _err := client.DeleteVbrHaWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   The **DeleteVcoRouteEntry** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeVpnConnection](~~53046~~) operation to query the status of a route based on the status of the associated IPsec-VPN connection.
 *     *   If the IPsec-VPN connection is in the **updating** state, the route is being deleted.
 *     *   If the IPsec-VPN connection is in the **attached** state, the route is deleted.
 * *   You cannot repeatedly call the **DeleteVcoRouteEntry** operation to delete a route from the same IPsec-VPN connection within the specified period of time.
 *
 * @param request DeleteVcoRouteEntryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteVcoRouteEntryResponse
 */
func (client *Client) DeleteVcoRouteEntryWithOptions(request *DeleteVcoRouteEntryRequest, runtime *util.RuntimeOptions) (_result *DeleteVcoRouteEntryResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.NextHop)) {
		query["NextHop"] = request.NextHop
	}

	if !tea.BoolValue(util.IsUnset(request.OverlayMode)) {
		query["OverlayMode"] = request.OverlayMode
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RouteDest)) {
		query["RouteDest"] = request.RouteDest
	}

	if !tea.BoolValue(util.IsUnset(request.VpnConnectionId)) {
		query["VpnConnectionId"] = request.VpnConnectionId
	}

	if !tea.BoolValue(util.IsUnset(request.Weight)) {
		query["Weight"] = request.Weight
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteVcoRouteEntry"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteVcoRouteEntryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   The **DeleteVcoRouteEntry** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeVpnConnection](~~53046~~) operation to query the status of a route based on the status of the associated IPsec-VPN connection.
 *     *   If the IPsec-VPN connection is in the **updating** state, the route is being deleted.
 *     *   If the IPsec-VPN connection is in the **attached** state, the route is deleted.
 * *   You cannot repeatedly call the **DeleteVcoRouteEntry** operation to delete a route from the same IPsec-VPN connection within the specified period of time.
 *
 * @param request DeleteVcoRouteEntryRequest
 * @return DeleteVcoRouteEntryResponse
 */
func (client *Client) DeleteVcoRouteEntry(request *DeleteVcoRouteEntryRequest) (_result *DeleteVcoRouteEntryResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteVcoRouteEntryResponse{}
	_body, _err := client.DeleteVcoRouteEntryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * Before you call this operation, take note of the following limits:
 * *   Before you delete a VBR, you must delete all router interfaces of the VBR.
 * *   You can delete only a VBR that is in the** Unconfirmed**,** Enabled**, or** Terminated** state.
 * *   If the owner of an Express Connect circuit wants to delete a VBR that belongs to another Alibaba Cloud account, the VBR must be in the **Unconfirmed** state.
 *
 * @param request DeleteVirtualBorderRouterRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteVirtualBorderRouterResponse
 */
func (client *Client) DeleteVirtualBorderRouterWithOptions(request *DeleteVirtualBorderRouterRequest, runtime *util.RuntimeOptions) (_result *DeleteVirtualBorderRouterResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.VbrId)) {
		query["VbrId"] = request.VbrId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteVirtualBorderRouter"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteVirtualBorderRouterResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * Before you call this operation, take note of the following limits:
 * *   Before you delete a VBR, you must delete all router interfaces of the VBR.
 * *   You can delete only a VBR that is in the** Unconfirmed**,** Enabled**, or** Terminated** state.
 * *   If the owner of an Express Connect circuit wants to delete a VBR that belongs to another Alibaba Cloud account, the VBR must be in the **Unconfirmed** state.
 *
 * @param request DeleteVirtualBorderRouterRequest
 * @return DeleteVirtualBorderRouterResponse
 */
func (client *Client) DeleteVirtualBorderRouter(request *DeleteVirtualBorderRouterRequest) (_result *DeleteVirtualBorderRouterResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteVirtualBorderRouterResponse{}
	_body, _err := client.DeleteVirtualBorderRouterWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * When you call this operation, take note of the following limits:
 * *   Before you delete a VPC, make sure that all resources deployed in the VPC are released or removed, such as vSwitches, instances, and high-availability virtual IP addresses (HAVIPs).
 * *   You can delete only a VPC that is in the **Available** state.
 * *   The **DeleteVpc** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeVpcAttribute](~~94565~~) operation to query the status of a VPC:
 *     *   If the VPC is in the **Deleting** state, the VPC is being deleted.
 *     *   If you cannot query the VPC, the VPC is deleted.
 * *   You cannot repeatedly call the **DeleteVpc** operation to delete a VPC within the specified period of time.
 *
 * @param request DeleteVpcRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteVpcResponse
 */
func (client *Client) DeleteVpcWithOptions(request *DeleteVpcRequest, runtime *util.RuntimeOptions) (_result *DeleteVpcResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.ForceDelete)) {
		query["ForceDelete"] = request.ForceDelete
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.VpcId)) {
		query["VpcId"] = request.VpcId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteVpc"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteVpcResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * When you call this operation, take note of the following limits:
 * *   Before you delete a VPC, make sure that all resources deployed in the VPC are released or removed, such as vSwitches, instances, and high-availability virtual IP addresses (HAVIPs).
 * *   You can delete only a VPC that is in the **Available** state.
 * *   The **DeleteVpc** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeVpcAttribute](~~94565~~) operation to query the status of a VPC:
 *     *   If the VPC is in the **Deleting** state, the VPC is being deleted.
 *     *   If you cannot query the VPC, the VPC is deleted.
 * *   You cannot repeatedly call the **DeleteVpc** operation to delete a VPC within the specified period of time.
 *
 * @param request DeleteVpcRequest
 * @return DeleteVpcResponse
 */
func (client *Client) DeleteVpc(request *DeleteVpcRequest) (_result *DeleteVpcResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteVpcResponse{}
	_body, _err := client.DeleteVpcWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteVpcGatewayEndpointWithOptions(request *DeleteVpcGatewayEndpointRequest, runtime *util.RuntimeOptions) (_result *DeleteVpcGatewayEndpointResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.EndpointId)) {
		query["EndpointId"] = request.EndpointId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteVpcGatewayEndpoint"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteVpcGatewayEndpointResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteVpcGatewayEndpoint(request *DeleteVpcGatewayEndpointRequest) (_result *DeleteVpcGatewayEndpointResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteVpcGatewayEndpointResponse{}
	_body, _err := client.DeleteVpcGatewayEndpointWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You cannot repeatedly call the **DeleteDhcpOptionsSet** operation to delete a prefix list within the specified period of time.
 *
 * @param request DeleteVpcPrefixListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteVpcPrefixListResponse
 */
func (client *Client) DeleteVpcPrefixListWithOptions(request *DeleteVpcPrefixListRequest, runtime *util.RuntimeOptions) (_result *DeleteVpcPrefixListResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PrefixListId)) {
		query["PrefixListId"] = request.PrefixListId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteVpcPrefixList"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteVpcPrefixListResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You cannot repeatedly call the **DeleteDhcpOptionsSet** operation to delete a prefix list within the specified period of time.
 *
 * @param request DeleteVpcPrefixListRequest
 * @return DeleteVpcPrefixListResponse
 */
func (client *Client) DeleteVpcPrefixList(request *DeleteVpcPrefixListRequest) (_result *DeleteVpcPrefixListResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteVpcPrefixListResponse{}
	_body, _err := client.DeleteVpcPrefixListWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   If the IPsec-VPN connection is associated with a transit router, you must first disassociate the IPsec-VPN connection from the transit router before you delete the IPsec-VPN connection.
 * *   If the IPsec-VPN connection is not associated with a resource, you can call the `DeleteVpnAttachment` to delete the IPsec-VPN connection.
 *
 * @param request DeleteVpnAttachmentRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteVpnAttachmentResponse
 */
func (client *Client) DeleteVpnAttachmentWithOptions(request *DeleteVpnAttachmentRequest, runtime *util.RuntimeOptions) (_result *DeleteVpnAttachmentResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.VpnConnectionId)) {
		query["VpnConnectionId"] = request.VpnConnectionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteVpnAttachment"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteVpnAttachmentResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   If the IPsec-VPN connection is associated with a transit router, you must first disassociate the IPsec-VPN connection from the transit router before you delete the IPsec-VPN connection.
 * *   If the IPsec-VPN connection is not associated with a resource, you can call the `DeleteVpnAttachment` to delete the IPsec-VPN connection.
 *
 * @param request DeleteVpnAttachmentRequest
 * @return DeleteVpnAttachmentResponse
 */
func (client *Client) DeleteVpnAttachment(request *DeleteVpnAttachmentRequest) (_result *DeleteVpnAttachmentResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteVpnAttachmentResponse{}
	_body, _err := client.DeleteVpnAttachmentWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   The **DeleteVpnConnection** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeVpnGateway](~~73720~~) operation to query the status of a VPN gateway.
 *     *   If the VPN gateway is in the **updating** state, the IPsec-VPN connection is being deleted.
 *     *   If the VPN gateway is in the **active** state, the IPsec-VPN connection is deleted.
 * *   You cannot repeatedly call **DeleteVpnConnection** to delete an IPsec-VPN connection from the same VPN gateway within the specified period of time.
 * >  After an IPsec-VPN connection between a virtual private cloud (VPC) and a data center is deleted, the communication between the VPC and data center is interrupted.
 *
 * @param request DeleteVpnConnectionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteVpnConnectionResponse
 */
func (client *Client) DeleteVpnConnectionWithOptions(request *DeleteVpnConnectionRequest, runtime *util.RuntimeOptions) (_result *DeleteVpnConnectionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.VpnConnectionId)) {
		query["VpnConnectionId"] = request.VpnConnectionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteVpnConnection"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteVpnConnectionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   The **DeleteVpnConnection** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeVpnGateway](~~73720~~) operation to query the status of a VPN gateway.
 *     *   If the VPN gateway is in the **updating** state, the IPsec-VPN connection is being deleted.
 *     *   If the VPN gateway is in the **active** state, the IPsec-VPN connection is deleted.
 * *   You cannot repeatedly call **DeleteVpnConnection** to delete an IPsec-VPN connection from the same VPN gateway within the specified period of time.
 * >  After an IPsec-VPN connection between a virtual private cloud (VPC) and a data center is deleted, the communication between the VPC and data center is interrupted.
 *
 * @param request DeleteVpnConnectionRequest
 * @return DeleteVpnConnectionResponse
 */
func (client *Client) DeleteVpnConnection(request *DeleteVpnConnectionRequest) (_result *DeleteVpnConnectionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteVpnConnectionResponse{}
	_body, _err := client.DeleteVpnConnectionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * >  You cannot delete a VPN gateway that is associated with an IPsec-VPN connection.
 *
 * @param request DeleteVpnGatewayRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteVpnGatewayResponse
 */
func (client *Client) DeleteVpnGatewayWithOptions(request *DeleteVpnGatewayRequest, runtime *util.RuntimeOptions) (_result *DeleteVpnGatewayResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.VpnGatewayId)) {
		query["VpnGatewayId"] = request.VpnGatewayId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteVpnGateway"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteVpnGatewayResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * >  You cannot delete a VPN gateway that is associated with an IPsec-VPN connection.
 *
 * @param request DeleteVpnGatewayRequest
 * @return DeleteVpnGatewayResponse
 */
func (client *Client) DeleteVpnGateway(request *DeleteVpnGatewayRequest) (_result *DeleteVpnGatewayResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteVpnGatewayResponse{}
	_body, _err := client.DeleteVpnGatewayWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   The **DeleteVpnPbrRouteEntry** operation is asynchronous. After you call the operation, the request ID is returned but the operation is still being performed in the system background. You can call [DescribeVpnGateway](~~73720~~) to query the status of a VPN gateway.
 *     *   If a VPN gateway is in the **updating** state, the policy-based route is being deleted.
 *     *   If a VPN gateway is in the **active** state, the policy-based route has been deleted.
 * *   You cannot repeatedly call **DeleteVpnPbrRouteEntry** to delete a policy-based route within the specified period of time.
 *
 * @param request DeleteVpnPbrRouteEntryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteVpnPbrRouteEntryResponse
 */
func (client *Client) DeleteVpnPbrRouteEntryWithOptions(request *DeleteVpnPbrRouteEntryRequest, runtime *util.RuntimeOptions) (_result *DeleteVpnPbrRouteEntryResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.NextHop)) {
		query["NextHop"] = request.NextHop
	}

	if !tea.BoolValue(util.IsUnset(request.OverlayMode)) {
		query["OverlayMode"] = request.OverlayMode
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Priority)) {
		query["Priority"] = request.Priority
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RouteDest)) {
		query["RouteDest"] = request.RouteDest
	}

	if !tea.BoolValue(util.IsUnset(request.RouteSource)) {
		query["RouteSource"] = request.RouteSource
	}

	if !tea.BoolValue(util.IsUnset(request.VpnGatewayId)) {
		query["VpnGatewayId"] = request.VpnGatewayId
	}

	if !tea.BoolValue(util.IsUnset(request.Weight)) {
		query["Weight"] = request.Weight
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteVpnPbrRouteEntry"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteVpnPbrRouteEntryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   The **DeleteVpnPbrRouteEntry** operation is asynchronous. After you call the operation, the request ID is returned but the operation is still being performed in the system background. You can call [DescribeVpnGateway](~~73720~~) to query the status of a VPN gateway.
 *     *   If a VPN gateway is in the **updating** state, the policy-based route is being deleted.
 *     *   If a VPN gateway is in the **active** state, the policy-based route has been deleted.
 * *   You cannot repeatedly call **DeleteVpnPbrRouteEntry** to delete a policy-based route within the specified period of time.
 *
 * @param request DeleteVpnPbrRouteEntryRequest
 * @return DeleteVpnPbrRouteEntryResponse
 */
func (client *Client) DeleteVpnPbrRouteEntry(request *DeleteVpnPbrRouteEntryRequest) (_result *DeleteVpnPbrRouteEntryResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteVpnPbrRouteEntryResponse{}
	_body, _err := client.DeleteVpnPbrRouteEntryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   The **DeleteRouteEntry** operation is asynchronous. After you send the request, the system returns a request ID but the operation is still being performed in the system background. You can call [DescribeVpnGateway](~~73720~~) to query the status of a VPN gateway.
 *     *   If a VPN gateway is in the **updating** state, the destination-based route is being deleted.
 *     *   If the VPN gateway is in the **active** state, the destination-based route has been deleted.
 * *   You cannot repeatedly call **DeleteVpnRouteEntry** to delete a destination-based route from a VPN gateway within the specified period of time.
 *
 * @param request DeleteVpnRouteEntryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteVpnRouteEntryResponse
 */
func (client *Client) DeleteVpnRouteEntryWithOptions(request *DeleteVpnRouteEntryRequest, runtime *util.RuntimeOptions) (_result *DeleteVpnRouteEntryResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.NextHop)) {
		query["NextHop"] = request.NextHop
	}

	if !tea.BoolValue(util.IsUnset(request.OverlayMode)) {
		query["OverlayMode"] = request.OverlayMode
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RouteDest)) {
		query["RouteDest"] = request.RouteDest
	}

	if !tea.BoolValue(util.IsUnset(request.VpnGatewayId)) {
		query["VpnGatewayId"] = request.VpnGatewayId
	}

	if !tea.BoolValue(util.IsUnset(request.Weight)) {
		query["Weight"] = request.Weight
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteVpnRouteEntry"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteVpnRouteEntryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   The **DeleteRouteEntry** operation is asynchronous. After you send the request, the system returns a request ID but the operation is still being performed in the system background. You can call [DescribeVpnGateway](~~73720~~) to query the status of a VPN gateway.
 *     *   If a VPN gateway is in the **updating** state, the destination-based route is being deleted.
 *     *   If the VPN gateway is in the **active** state, the destination-based route has been deleted.
 * *   You cannot repeatedly call **DeleteVpnRouteEntry** to delete a destination-based route from a VPN gateway within the specified period of time.
 *
 * @param request DeleteVpnRouteEntryRequest
 * @return DeleteVpnRouteEntryResponse
 */
func (client *Client) DeleteVpnRouteEntry(request *DeleteVpnRouteEntryRequest) (_result *DeleteVpnRouteEntryResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteVpnRouteEntryResponse{}
	_body, _err := client.DeleteVpnRouteEntryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * After you enable deletion protection for an instance, you cannot delete the instance. You must disable deletion protection before you can delete the instance.
 *
 * @param request DeletionProtectionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeletionProtectionResponse
 */
func (client *Client) DeletionProtectionWithOptions(request *DeletionProtectionRequest, runtime *util.RuntimeOptions) (_result *DeletionProtectionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ProtectionEnable)) {
		query["ProtectionEnable"] = request.ProtectionEnable
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeletionProtection"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeletionProtectionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * After you enable deletion protection for an instance, you cannot delete the instance. You must disable deletion protection before you can delete the instance.
 *
 * @param request DeletionProtectionRequest
 * @return DeletionProtectionResponse
 */
func (client *Client) DeletionProtection(request *DeletionProtectionRequest) (_result *DeletionProtectionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeletionProtectionResponse{}
	_body, _err := client.DeletionProtectionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeAccessPointsWithOptions(request *DescribeAccessPointsRequest, runtime *util.RuntimeOptions) (_result *DescribeAccessPointsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeAccessPoints"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeAccessPointsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeAccessPoints(request *DescribeAccessPointsRequest) (_result *DescribeAccessPointsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeAccessPointsResponse{}
	_body, _err := client.DescribeAccessPointsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeBgpGroupsWithOptions(request *DescribeBgpGroupsRequest, runtime *util.RuntimeOptions) (_result *DescribeBgpGroupsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BgpGroupId)) {
		query["BgpGroupId"] = request.BgpGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.IsDefault)) {
		query["IsDefault"] = request.IsDefault
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RouterId)) {
		query["RouterId"] = request.RouterId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeBgpGroups"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeBgpGroupsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeBgpGroups(request *DescribeBgpGroupsRequest) (_result *DescribeBgpGroupsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeBgpGroupsResponse{}
	_body, _err := client.DescribeBgpGroupsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeBgpNetworksWithOptions(request *DescribeBgpNetworksRequest, runtime *util.RuntimeOptions) (_result *DescribeBgpNetworksResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RouterId)) {
		query["RouterId"] = request.RouterId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeBgpNetworks"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeBgpNetworksResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeBgpNetworks(request *DescribeBgpNetworksRequest) (_result *DescribeBgpNetworksResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeBgpNetworksResponse{}
	_body, _err := client.DescribeBgpNetworksWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeBgpPeersWithOptions(request *DescribeBgpPeersRequest, runtime *util.RuntimeOptions) (_result *DescribeBgpPeersResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BgpGroupId)) {
		query["BgpGroupId"] = request.BgpGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.BgpPeerId)) {
		query["BgpPeerId"] = request.BgpPeerId
	}

	if !tea.BoolValue(util.IsUnset(request.IsDefault)) {
		query["IsDefault"] = request.IsDefault
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RouterId)) {
		query["RouterId"] = request.RouterId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeBgpPeers"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeBgpPeersResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeBgpPeers(request *DescribeBgpPeersRequest) (_result *DescribeBgpPeersResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeBgpPeersResponse{}
	_body, _err := client.DescribeBgpPeersWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeCommonBandwidthPackagesWithOptions(request *DescribeCommonBandwidthPackagesRequest, runtime *util.RuntimeOptions) (_result *DescribeCommonBandwidthPackagesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BandwidthPackageId)) {
		query["BandwidthPackageId"] = request.BandwidthPackageId
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.IncludeReservationData)) {
		query["IncludeReservationData"] = request.IncludeReservationData
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityProtectionEnabled)) {
		query["SecurityProtectionEnabled"] = request.SecurityProtectionEnabled
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeCommonBandwidthPackages"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeCommonBandwidthPackagesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeCommonBandwidthPackages(request *DescribeCommonBandwidthPackagesRequest) (_result *DescribeCommonBandwidthPackagesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeCommonBandwidthPackagesResponse{}
	_body, _err := client.DescribeCommonBandwidthPackagesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeCustomerGatewayWithOptions(request *DescribeCustomerGatewayRequest, runtime *util.RuntimeOptions) (_result *DescribeCustomerGatewayResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CustomerGatewayId)) {
		query["CustomerGatewayId"] = request.CustomerGatewayId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeCustomerGateway"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeCustomerGatewayResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeCustomerGateway(request *DescribeCustomerGatewayRequest) (_result *DescribeCustomerGatewayResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeCustomerGatewayResponse{}
	_body, _err := client.DescribeCustomerGatewayWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeCustomerGatewaysWithOptions(request *DescribeCustomerGatewaysRequest, runtime *util.RuntimeOptions) (_result *DescribeCustomerGatewaysResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CustomerGatewayId)) {
		query["CustomerGatewayId"] = request.CustomerGatewayId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeCustomerGateways"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeCustomerGatewaysResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeCustomerGateways(request *DescribeCustomerGatewaysRequest) (_result *DescribeCustomerGatewaysResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeCustomerGatewaysResponse{}
	_body, _err := client.DescribeCustomerGatewaysWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeEcGrantRelationWithOptions(request *DescribeEcGrantRelationRequest, runtime *util.RuntimeOptions) (_result *DescribeEcGrantRelationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceType)) {
		query["InstanceType"] = request.InstanceType
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.VbrRegionNo)) {
		query["VbrRegionNo"] = request.VbrRegionNo
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeEcGrantRelation"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeEcGrantRelationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeEcGrantRelation(request *DescribeEcGrantRelationRequest) (_result *DescribeEcGrantRelationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeEcGrantRelationResponse{}
	_body, _err := client.DescribeEcGrantRelationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call this operation to query the information about EIPs in a specified region, including the maximum bandwidth, billing methods, and associated instances.
 *
 * @param request DescribeEipAddressesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeEipAddressesResponse
 */
func (client *Client) DescribeEipAddressesWithOptions(request *DescribeEipAddressesRequest, runtime *util.RuntimeOptions) (_result *DescribeEipAddressesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AllocationId)) {
		query["AllocationId"] = request.AllocationId
	}

	if !tea.BoolValue(util.IsUnset(request.AssociatedInstanceId)) {
		query["AssociatedInstanceId"] = request.AssociatedInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.AssociatedInstanceType)) {
		query["AssociatedInstanceType"] = request.AssociatedInstanceType
	}

	if !tea.BoolValue(util.IsUnset(request.ChargeType)) {
		query["ChargeType"] = request.ChargeType
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.EipAddress)) {
		query["EipAddress"] = request.EipAddress
	}

	if !tea.BoolValue(util.IsUnset(request.EipName)) {
		query["EipName"] = request.EipName
	}

	if !tea.BoolValue(util.IsUnset(request.ISP)) {
		query["ISP"] = request.ISP
	}

	if !tea.BoolValue(util.IsUnset(request.IncludeReservationData)) {
		query["IncludeReservationData"] = request.IncludeReservationData
	}

	if !tea.BoolValue(util.IsUnset(request.LockReason)) {
		query["LockReason"] = request.LockReason
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.PublicIpAddressPoolId)) {
		query["PublicIpAddressPoolId"] = request.PublicIpAddressPoolId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityProtectionEnabled)) {
		query["SecurityProtectionEnabled"] = request.SecurityProtectionEnabled
	}

	if !tea.BoolValue(util.IsUnset(request.SegmentInstanceId)) {
		query["SegmentInstanceId"] = request.SegmentInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		query["Status"] = request.Status
	}

	if !tea.BoolValue(util.IsUnset(request.Filter)) {
		query["Filter"] = request.Filter
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeEipAddresses"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeEipAddressesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call this operation to query the information about EIPs in a specified region, including the maximum bandwidth, billing methods, and associated instances.
 *
 * @param request DescribeEipAddressesRequest
 * @return DescribeEipAddressesResponse
 */
func (client *Client) DescribeEipAddresses(request *DescribeEipAddressesRequest) (_result *DescribeEipAddressesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeEipAddressesResponse{}
	_body, _err := client.DescribeEipAddressesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can query only EIPs that are associated with secondary elastic network interfaces (ENIs) in multi-EIP-to-ENI mode.
 *
 * @param request DescribeEipGatewayInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeEipGatewayInfoResponse
 */
func (client *Client) DescribeEipGatewayInfoWithOptions(request *DescribeEipGatewayInfoRequest, runtime *util.RuntimeOptions) (_result *DescribeEipGatewayInfoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeEipGatewayInfo"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeEipGatewayInfoResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can query only EIPs that are associated with secondary elastic network interfaces (ENIs) in multi-EIP-to-ENI mode.
 *
 * @param request DescribeEipGatewayInfoRequest
 * @return DescribeEipGatewayInfoResponse
 */
func (client *Client) DescribeEipGatewayInfo(request *DescribeEipGatewayInfoRequest) (_result *DescribeEipGatewayInfoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeEipGatewayInfoResponse{}
	_body, _err := client.DescribeEipGatewayInfoWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * To improve user experience in querying monitoring data, we recommend that you call the DescribeMetricList API operation provided by CloudMonitor to query EIP monitoring data. For more information, see [DescribeMetricList](~~51936~~) and [EIP monitoring data](~~162874~~).
 *
 * @param request DescribeEipMonitorDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeEipMonitorDataResponse
 */
func (client *Client) DescribeEipMonitorDataWithOptions(request *DescribeEipMonitorDataRequest, runtime *util.RuntimeOptions) (_result *DescribeEipMonitorDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AllocationId)) {
		query["AllocationId"] = request.AllocationId
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Period)) {
		query["Period"] = request.Period
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeEipMonitorData"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeEipMonitorDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * To improve user experience in querying monitoring data, we recommend that you call the DescribeMetricList API operation provided by CloudMonitor to query EIP monitoring data. For more information, see [DescribeMetricList](~~51936~~) and [EIP monitoring data](~~162874~~).
 *
 * @param request DescribeEipMonitorDataRequest
 * @return DescribeEipMonitorDataResponse
 */
func (client *Client) DescribeEipMonitorData(request *DescribeEipMonitorDataRequest) (_result *DescribeEipMonitorDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeEipMonitorDataResponse{}
	_body, _err := client.DescribeEipMonitorDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeEipSegmentWithOptions(request *DescribeEipSegmentRequest, runtime *util.RuntimeOptions) (_result *DescribeEipSegmentResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SegmentInstanceId)) {
		query["SegmentInstanceId"] = request.SegmentInstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeEipSegment"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeEipSegmentResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeEipSegment(request *DescribeEipSegmentRequest) (_result *DescribeEipSegmentResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeEipSegmentResponse{}
	_body, _err := client.DescribeEipSegmentWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeFlowLogsWithOptions(request *DescribeFlowLogsRequest, runtime *util.RuntimeOptions) (_result *DescribeFlowLogsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.FlowLogId)) {
		query["FlowLogId"] = request.FlowLogId
	}

	if !tea.BoolValue(util.IsUnset(request.FlowLogName)) {
		query["FlowLogName"] = request.FlowLogName
	}

	if !tea.BoolValue(util.IsUnset(request.LogStoreName)) {
		query["LogStoreName"] = request.LogStoreName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectName)) {
		query["ProjectName"] = request.ProjectName
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceId)) {
		query["ResourceId"] = request.ResourceId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		query["Status"] = request.Status
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	if !tea.BoolValue(util.IsUnset(request.TrafficType)) {
		query["TrafficType"] = request.TrafficType
	}

	if !tea.BoolValue(util.IsUnset(request.VpcId)) {
		query["VpcId"] = request.VpcId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeFlowLogs"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeFlowLogsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeFlowLogs(request *DescribeFlowLogsRequest) (_result *DescribeFlowLogsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeFlowLogsResponse{}
	_body, _err := client.DescribeFlowLogsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeForwardTableEntriesWithOptions(request *DescribeForwardTableEntriesRequest, runtime *util.RuntimeOptions) (_result *DescribeForwardTableEntriesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ExternalIp)) {
		query["ExternalIp"] = request.ExternalIp
	}

	if !tea.BoolValue(util.IsUnset(request.ExternalPort)) {
		query["ExternalPort"] = request.ExternalPort
	}

	if !tea.BoolValue(util.IsUnset(request.ForwardEntryId)) {
		query["ForwardEntryId"] = request.ForwardEntryId
	}

	if !tea.BoolValue(util.IsUnset(request.ForwardEntryName)) {
		query["ForwardEntryName"] = request.ForwardEntryName
	}

	if !tea.BoolValue(util.IsUnset(request.ForwardTableId)) {
		query["ForwardTableId"] = request.ForwardTableId
	}

	if !tea.BoolValue(util.IsUnset(request.InternalIp)) {
		query["InternalIp"] = request.InternalIp
	}

	if !tea.BoolValue(util.IsUnset(request.InternalPort)) {
		query["InternalPort"] = request.InternalPort
	}

	if !tea.BoolValue(util.IsUnset(request.IpProtocol)) {
		query["IpProtocol"] = request.IpProtocol
	}

	if !tea.BoolValue(util.IsUnset(request.NatGatewayId)) {
		query["NatGatewayId"] = request.NatGatewayId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeForwardTableEntries"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeForwardTableEntriesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeForwardTableEntries(request *DescribeForwardTableEntriesRequest) (_result *DescribeForwardTableEntriesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeForwardTableEntriesResponse{}
	_body, _err := client.DescribeForwardTableEntriesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeGlobalAccelerationInstancesWithOptions(request *DescribeGlobalAccelerationInstancesRequest, runtime *util.RuntimeOptions) (_result *DescribeGlobalAccelerationInstancesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BandwidthType)) {
		query["BandwidthType"] = request.BandwidthType
	}

	if !tea.BoolValue(util.IsUnset(request.GlobalAccelerationInstanceId)) {
		query["GlobalAccelerationInstanceId"] = request.GlobalAccelerationInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.IncludeReservationData)) {
		query["IncludeReservationData"] = request.IncludeReservationData
	}

	if !tea.BoolValue(util.IsUnset(request.IpAddress)) {
		query["IpAddress"] = request.IpAddress
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ServerId)) {
		query["ServerId"] = request.ServerId
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceLocation)) {
		query["ServiceLocation"] = request.ServiceLocation
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		query["Status"] = request.Status
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeGlobalAccelerationInstances"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeGlobalAccelerationInstancesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeGlobalAccelerationInstances(request *DescribeGlobalAccelerationInstancesRequest) (_result *DescribeGlobalAccelerationInstancesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeGlobalAccelerationInstancesResponse{}
	_body, _err := client.DescribeGlobalAccelerationInstancesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeGrantRulesToCenWithOptions(request *DescribeGrantRulesToCenRequest, runtime *util.RuntimeOptions) (_result *DescribeGrantRulesToCenResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceType)) {
		query["InstanceType"] = request.InstanceType
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeGrantRulesToCen"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeGrantRulesToCenResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeGrantRulesToCen(request *DescribeGrantRulesToCenRequest) (_result *DescribeGrantRulesToCenResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeGrantRulesToCenResponse{}
	_body, _err := client.DescribeGrantRulesToCenWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeHaVipsWithOptions(request *DescribeHaVipsRequest, runtime *util.RuntimeOptions) (_result *DescribeHaVipsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Filter)) {
		query["Filter"] = request.Filter
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeHaVips"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeHaVipsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeHaVips(request *DescribeHaVipsRequest) (_result *DescribeHaVipsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeHaVipsResponse{}
	_body, _err := client.DescribeHaVipsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeHighDefinitionMonitorLogAttributeWithOptions(request *DescribeHighDefinitionMonitorLogAttributeRequest, runtime *util.RuntimeOptions) (_result *DescribeHighDefinitionMonitorLogAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceType)) {
		query["InstanceType"] = request.InstanceType
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeHighDefinitionMonitorLogAttribute"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeHighDefinitionMonitorLogAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeHighDefinitionMonitorLogAttribute(request *DescribeHighDefinitionMonitorLogAttributeRequest) (_result *DescribeHighDefinitionMonitorLogAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeHighDefinitionMonitorLogAttributeResponse{}
	_body, _err := client.DescribeHighDefinitionMonitorLogAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeIPv6TranslatorAclListAttributesWithOptions(request *DescribeIPv6TranslatorAclListAttributesRequest, runtime *util.RuntimeOptions) (_result *DescribeIPv6TranslatorAclListAttributesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AclId)) {
		query["AclId"] = request.AclId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeIPv6TranslatorAclListAttributes"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeIPv6TranslatorAclListAttributesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeIPv6TranslatorAclListAttributes(request *DescribeIPv6TranslatorAclListAttributesRequest) (_result *DescribeIPv6TranslatorAclListAttributesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeIPv6TranslatorAclListAttributesResponse{}
	_body, _err := client.DescribeIPv6TranslatorAclListAttributesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * @deprecated
 *
 * @param request DescribeIPv6TranslatorAclListsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeIPv6TranslatorAclListsResponse
 */
// Deprecated
func (client *Client) DescribeIPv6TranslatorAclListsWithOptions(request *DescribeIPv6TranslatorAclListsRequest, runtime *util.RuntimeOptions) (_result *DescribeIPv6TranslatorAclListsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AclId)) {
		query["AclId"] = request.AclId
	}

	if !tea.BoolValue(util.IsUnset(request.AclName)) {
		query["AclName"] = request.AclName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeIPv6TranslatorAclLists"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeIPv6TranslatorAclListsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * @deprecated
 *
 * @param request DescribeIPv6TranslatorAclListsRequest
 * @return DescribeIPv6TranslatorAclListsResponse
 */
// Deprecated
func (client *Client) DescribeIPv6TranslatorAclLists(request *DescribeIPv6TranslatorAclListsRequest) (_result *DescribeIPv6TranslatorAclListsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeIPv6TranslatorAclListsResponse{}
	_body, _err := client.DescribeIPv6TranslatorAclListsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * @deprecated
 *
 * @param request DescribeIPv6TranslatorEntriesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeIPv6TranslatorEntriesResponse
 */
// Deprecated
func (client *Client) DescribeIPv6TranslatorEntriesWithOptions(request *DescribeIPv6TranslatorEntriesRequest, runtime *util.RuntimeOptions) (_result *DescribeIPv6TranslatorEntriesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AclId)) {
		query["AclId"] = request.AclId
	}

	if !tea.BoolValue(util.IsUnset(request.AclStatus)) {
		query["AclStatus"] = request.AclStatus
	}

	if !tea.BoolValue(util.IsUnset(request.AclType)) {
		query["AclType"] = request.AclType
	}

	if !tea.BoolValue(util.IsUnset(request.AllocateIpv6Addr)) {
		query["AllocateIpv6Addr"] = request.AllocateIpv6Addr
	}

	if !tea.BoolValue(util.IsUnset(request.AllocateIpv6Port)) {
		query["AllocateIpv6Port"] = request.AllocateIpv6Port
	}

	if !tea.BoolValue(util.IsUnset(request.BackendIpv4Addr)) {
		query["BackendIpv4Addr"] = request.BackendIpv4Addr
	}

	if !tea.BoolValue(util.IsUnset(request.BackendIpv4Port)) {
		query["BackendIpv4Port"] = request.BackendIpv4Port
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.EntryName)) {
		query["EntryName"] = request.EntryName
	}

	if !tea.BoolValue(util.IsUnset(request.Ipv6TranslatorEntryId)) {
		query["Ipv6TranslatorEntryId"] = request.Ipv6TranslatorEntryId
	}

	if !tea.BoolValue(util.IsUnset(request.Ipv6TranslatorId)) {
		query["Ipv6TranslatorId"] = request.Ipv6TranslatorId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.TransProtocol)) {
		query["TransProtocol"] = request.TransProtocol
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeIPv6TranslatorEntries"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeIPv6TranslatorEntriesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * @deprecated
 *
 * @param request DescribeIPv6TranslatorEntriesRequest
 * @return DescribeIPv6TranslatorEntriesResponse
 */
// Deprecated
func (client *Client) DescribeIPv6TranslatorEntries(request *DescribeIPv6TranslatorEntriesRequest) (_result *DescribeIPv6TranslatorEntriesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeIPv6TranslatorEntriesResponse{}
	_body, _err := client.DescribeIPv6TranslatorEntriesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * @deprecated
 *
 * @param request DescribeIPv6TranslatorsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeIPv6TranslatorsResponse
 */
// Deprecated
func (client *Client) DescribeIPv6TranslatorsWithOptions(request *DescribeIPv6TranslatorsRequest, runtime *util.RuntimeOptions) (_result *DescribeIPv6TranslatorsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AllocateIpv4Addr)) {
		query["AllocateIpv4Addr"] = request.AllocateIpv4Addr
	}

	if !tea.BoolValue(util.IsUnset(request.AllocateIpv6Addr)) {
		query["AllocateIpv6Addr"] = request.AllocateIpv6Addr
	}

	if !tea.BoolValue(util.IsUnset(request.BusinessStatus)) {
		query["BusinessStatus"] = request.BusinessStatus
	}

	if !tea.BoolValue(util.IsUnset(request.Ipv6TranslatorId)) {
		query["Ipv6TranslatorId"] = request.Ipv6TranslatorId
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.PayType)) {
		query["PayType"] = request.PayType
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Spec)) {
		query["Spec"] = request.Spec
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		query["Status"] = request.Status
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeIPv6Translators"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeIPv6TranslatorsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * @deprecated
 *
 * @param request DescribeIPv6TranslatorsRequest
 * @return DescribeIPv6TranslatorsResponse
 */
// Deprecated
func (client *Client) DescribeIPv6Translators(request *DescribeIPv6TranslatorsRequest) (_result *DescribeIPv6TranslatorsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeIPv6TranslatorsResponse{}
	_body, _err := client.DescribeIPv6TranslatorsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeIpv6AddressesWithOptions(request *DescribeIpv6AddressesRequest, runtime *util.RuntimeOptions) (_result *DescribeIpv6AddressesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AssociatedInstanceId)) {
		query["AssociatedInstanceId"] = request.AssociatedInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.AssociatedInstanceType)) {
		query["AssociatedInstanceType"] = request.AssociatedInstanceType
	}

	if !tea.BoolValue(util.IsUnset(request.IncludeReservationData)) {
		query["IncludeReservationData"] = request.IncludeReservationData
	}

	if !tea.BoolValue(util.IsUnset(request.Ipv6Address)) {
		query["Ipv6Address"] = request.Ipv6Address
	}

	if !tea.BoolValue(util.IsUnset(request.Ipv6AddressId)) {
		query["Ipv6AddressId"] = request.Ipv6AddressId
	}

	if !tea.BoolValue(util.IsUnset(request.Ipv6InternetBandwidthId)) {
		query["Ipv6InternetBandwidthId"] = request.Ipv6InternetBandwidthId
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.NetworkType)) {
		query["NetworkType"] = request.NetworkType
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.VSwitchId)) {
		query["VSwitchId"] = request.VSwitchId
	}

	if !tea.BoolValue(util.IsUnset(request.VpcId)) {
		query["VpcId"] = request.VpcId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeIpv6Addresses"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeIpv6AddressesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeIpv6Addresses(request *DescribeIpv6AddressesRequest) (_result *DescribeIpv6AddressesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeIpv6AddressesResponse{}
	_body, _err := client.DescribeIpv6AddressesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeIpv6EgressOnlyRulesWithOptions(request *DescribeIpv6EgressOnlyRulesRequest, runtime *util.RuntimeOptions) (_result *DescribeIpv6EgressOnlyRulesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceType)) {
		query["InstanceType"] = request.InstanceType
	}

	if !tea.BoolValue(util.IsUnset(request.Ipv6EgressOnlyRuleId)) {
		query["Ipv6EgressOnlyRuleId"] = request.Ipv6EgressOnlyRuleId
	}

	if !tea.BoolValue(util.IsUnset(request.Ipv6GatewayId)) {
		query["Ipv6GatewayId"] = request.Ipv6GatewayId
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeIpv6EgressOnlyRules"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeIpv6EgressOnlyRulesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeIpv6EgressOnlyRules(request *DescribeIpv6EgressOnlyRulesRequest) (_result *DescribeIpv6EgressOnlyRulesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeIpv6EgressOnlyRulesResponse{}
	_body, _err := client.DescribeIpv6EgressOnlyRulesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeIpv6GatewayAttributeWithOptions(request *DescribeIpv6GatewayAttributeRequest, runtime *util.RuntimeOptions) (_result *DescribeIpv6GatewayAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Ipv6GatewayId)) {
		query["Ipv6GatewayId"] = request.Ipv6GatewayId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeIpv6GatewayAttribute"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeIpv6GatewayAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeIpv6GatewayAttribute(request *DescribeIpv6GatewayAttributeRequest) (_result *DescribeIpv6GatewayAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeIpv6GatewayAttributeResponse{}
	_body, _err := client.DescribeIpv6GatewayAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeIpv6GatewaysWithOptions(request *DescribeIpv6GatewaysRequest, runtime *util.RuntimeOptions) (_result *DescribeIpv6GatewaysResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Ipv6GatewayId)) {
		query["Ipv6GatewayId"] = request.Ipv6GatewayId
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	if !tea.BoolValue(util.IsUnset(request.VpcId)) {
		query["VpcId"] = request.VpcId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeIpv6Gateways"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeIpv6GatewaysResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeIpv6Gateways(request *DescribeIpv6GatewaysRequest) (_result *DescribeIpv6GatewaysResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeIpv6GatewaysResponse{}
	_body, _err := client.DescribeIpv6GatewaysWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call this operation to query both Virtual Private Cloud (VPC) NAT gateways and Internet NAT gateways. NAT gateways in this topic refer to both VPC NAT gateways and Internet NAT gateways.
 *
 * @param request DescribeNatGatewaysRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeNatGatewaysResponse
 */
func (client *Client) DescribeNatGatewaysWithOptions(request *DescribeNatGatewaysRequest, runtime *util.RuntimeOptions) (_result *DescribeNatGatewaysResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceChargeType)) {
		query["InstanceChargeType"] = request.InstanceChargeType
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.NatGatewayId)) {
		query["NatGatewayId"] = request.NatGatewayId
	}

	if !tea.BoolValue(util.IsUnset(request.NatType)) {
		query["NatType"] = request.NatType
	}

	if !tea.BoolValue(util.IsUnset(request.NetworkType)) {
		query["NetworkType"] = request.NetworkType
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Spec)) {
		query["Spec"] = request.Spec
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		query["Status"] = request.Status
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	if !tea.BoolValue(util.IsUnset(request.VpcId)) {
		query["VpcId"] = request.VpcId
	}

	if !tea.BoolValue(util.IsUnset(request.ZoneId)) {
		query["ZoneId"] = request.ZoneId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeNatGateways"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeNatGatewaysResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call this operation to query both Virtual Private Cloud (VPC) NAT gateways and Internet NAT gateways. NAT gateways in this topic refer to both VPC NAT gateways and Internet NAT gateways.
 *
 * @param request DescribeNatGatewaysRequest
 * @return DescribeNatGatewaysResponse
 */
func (client *Client) DescribeNatGateways(request *DescribeNatGatewaysRequest) (_result *DescribeNatGatewaysResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeNatGatewaysResponse{}
	_body, _err := client.DescribeNatGatewaysWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeNetworkAclAttributesWithOptions(request *DescribeNetworkAclAttributesRequest, runtime *util.RuntimeOptions) (_result *DescribeNetworkAclAttributesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.NetworkAclId)) {
		query["NetworkAclId"] = request.NetworkAclId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeNetworkAclAttributes"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeNetworkAclAttributesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeNetworkAclAttributes(request *DescribeNetworkAclAttributesRequest) (_result *DescribeNetworkAclAttributesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeNetworkAclAttributesResponse{}
	_body, _err := client.DescribeNetworkAclAttributesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeNetworkAclsWithOptions(request *DescribeNetworkAclsRequest, runtime *util.RuntimeOptions) (_result *DescribeNetworkAclsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.NetworkAclId)) {
		query["NetworkAclId"] = request.NetworkAclId
	}

	if !tea.BoolValue(util.IsUnset(request.NetworkAclName)) {
		query["NetworkAclName"] = request.NetworkAclName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceId)) {
		query["ResourceId"] = request.ResourceId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	if !tea.BoolValue(util.IsUnset(request.VpcId)) {
		query["VpcId"] = request.VpcId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeNetworkAcls"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeNetworkAclsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeNetworkAcls(request *DescribeNetworkAclsRequest) (_result *DescribeNetworkAclsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeNetworkAclsResponse{}
	_body, _err := client.DescribeNetworkAclsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribePhysicalConnectionLOAWithOptions(request *DescribePhysicalConnectionLOARequest, runtime *util.RuntimeOptions) (_result *DescribePhysicalConnectionLOAResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribePhysicalConnectionLOA"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribePhysicalConnectionLOAResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribePhysicalConnectionLOA(request *DescribePhysicalConnectionLOARequest) (_result *DescribePhysicalConnectionLOAResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribePhysicalConnectionLOAResponse{}
	_body, _err := client.DescribePhysicalConnectionLOAWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * By default, the system queries information about all Express Connect circuits in the specified region. You can query Express Connect circuits that meet specific conditions by specifying filter conditions provided by the **DescribePhysicalConnections** operation. For more information about the supported filter conditions, see **Key** in the **Request parameters** section.
 *
 * @param request DescribePhysicalConnectionsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePhysicalConnectionsResponse
 */
func (client *Client) DescribePhysicalConnectionsWithOptions(request *DescribePhysicalConnectionsRequest, runtime *util.RuntimeOptions) (_result *DescribePhysicalConnectionsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Filter)) {
		query["Filter"] = request.Filter
	}

	if !tea.BoolValue(util.IsUnset(request.IncludeReservationData)) {
		query["IncludeReservationData"] = request.IncludeReservationData
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribePhysicalConnections"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribePhysicalConnectionsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * By default, the system queries information about all Express Connect circuits in the specified region. You can query Express Connect circuits that meet specific conditions by specifying filter conditions provided by the **DescribePhysicalConnections** operation. For more information about the supported filter conditions, see **Key** in the **Request parameters** section.
 *
 * @param request DescribePhysicalConnectionsRequest
 * @return DescribePhysicalConnectionsResponse
 */
func (client *Client) DescribePhysicalConnections(request *DescribePhysicalConnectionsRequest) (_result *DescribePhysicalConnectionsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribePhysicalConnectionsResponse{}
	_body, _err := client.DescribePhysicalConnectionsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You cannot query the range of public IP addresses of a classic network by calling the **DescribePublicIpAddress** operation.
 *
 * @param request DescribePublicIpAddressRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePublicIpAddressResponse
 */
func (client *Client) DescribePublicIpAddressWithOptions(request *DescribePublicIpAddressRequest, runtime *util.RuntimeOptions) (_result *DescribePublicIpAddressResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribePublicIpAddress"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribePublicIpAddressResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You cannot query the range of public IP addresses of a classic network by calling the **DescribePublicIpAddress** operation.
 *
 * @param request DescribePublicIpAddressRequest
 * @return DescribePublicIpAddressResponse
 */
func (client *Client) DescribePublicIpAddress(request *DescribePublicIpAddressRequest) (_result *DescribePublicIpAddressResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribePublicIpAddressResponse{}
	_body, _err := client.DescribePublicIpAddressWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeRegionsWithOptions(request *DescribeRegionsRequest, runtime *util.RuntimeOptions) (_result *DescribeRegionsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductType)) {
		query["ProductType"] = request.ProductType
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeRegions"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeRegionsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeRegions(request *DescribeRegionsRequest) (_result *DescribeRegionsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeRegionsResponse{}
	_body, _err := client.DescribeRegionsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Before you call the [DeleteRouteEntry](~~36013~~) operation to delete a route, you can call this operation to query the next hop of the route that you want to delete.
 *
 * @param request DescribeRouteEntryListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeRouteEntryListResponse
 */
func (client *Client) DescribeRouteEntryListWithOptions(request *DescribeRouteEntryListRequest, runtime *util.RuntimeOptions) (_result *DescribeRouteEntryListResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DestCidrBlockList)) {
		query["DestCidrBlockList"] = request.DestCidrBlockList
	}

	if !tea.BoolValue(util.IsUnset(request.DestinationCidrBlock)) {
		query["DestinationCidrBlock"] = request.DestinationCidrBlock
	}

	if !tea.BoolValue(util.IsUnset(request.IpVersion)) {
		query["IpVersion"] = request.IpVersion
	}

	if !tea.BoolValue(util.IsUnset(request.MaxResult)) {
		query["MaxResult"] = request.MaxResult
	}

	if !tea.BoolValue(util.IsUnset(request.NextHopId)) {
		query["NextHopId"] = request.NextHopId
	}

	if !tea.BoolValue(util.IsUnset(request.NextHopType)) {
		query["NextHopType"] = request.NextHopType
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RouteEntryId)) {
		query["RouteEntryId"] = request.RouteEntryId
	}

	if !tea.BoolValue(util.IsUnset(request.RouteEntryName)) {
		query["RouteEntryName"] = request.RouteEntryName
	}

	if !tea.BoolValue(util.IsUnset(request.RouteEntryType)) {
		query["RouteEntryType"] = request.RouteEntryType
	}

	if !tea.BoolValue(util.IsUnset(request.RouteTableId)) {
		query["RouteTableId"] = request.RouteTableId
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceType)) {
		query["ServiceType"] = request.ServiceType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeRouteEntryList"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeRouteEntryListResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Before you call the [DeleteRouteEntry](~~36013~~) operation to delete a route, you can call this operation to query the next hop of the route that you want to delete.
 *
 * @param request DescribeRouteEntryListRequest
 * @return DescribeRouteEntryListResponse
 */
func (client *Client) DescribeRouteEntryList(request *DescribeRouteEntryListRequest) (_result *DescribeRouteEntryListResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeRouteEntryListResponse{}
	_body, _err := client.DescribeRouteEntryListWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeRouteTableListWithOptions(request *DescribeRouteTableListRequest, runtime *util.RuntimeOptions) (_result *DescribeRouteTableListResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RouteTableId)) {
		query["RouteTableId"] = request.RouteTableId
	}

	if !tea.BoolValue(util.IsUnset(request.RouteTableName)) {
		query["RouteTableName"] = request.RouteTableName
	}

	if !tea.BoolValue(util.IsUnset(request.RouterId)) {
		query["RouterId"] = request.RouterId
	}

	if !tea.BoolValue(util.IsUnset(request.RouterType)) {
		query["RouterType"] = request.RouterType
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	if !tea.BoolValue(util.IsUnset(request.VpcId)) {
		query["VpcId"] = request.VpcId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeRouteTableList"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeRouteTableListResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeRouteTableList(request *DescribeRouteTableListRequest) (_result *DescribeRouteTableListResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeRouteTableListResponse{}
	_body, _err := client.DescribeRouteTableListWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeRouteTablesWithOptions(request *DescribeRouteTablesRequest, runtime *util.RuntimeOptions) (_result *DescribeRouteTablesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RouteTableId)) {
		query["RouteTableId"] = request.RouteTableId
	}

	if !tea.BoolValue(util.IsUnset(request.RouteTableName)) {
		query["RouteTableName"] = request.RouteTableName
	}

	if !tea.BoolValue(util.IsUnset(request.RouterId)) {
		query["RouterId"] = request.RouterId
	}

	if !tea.BoolValue(util.IsUnset(request.RouterType)) {
		query["RouterType"] = request.RouterType
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	if !tea.BoolValue(util.IsUnset(request.VRouterId)) {
		query["VRouterId"] = request.VRouterId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeRouteTables"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeRouteTablesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeRouteTables(request *DescribeRouteTablesRequest) (_result *DescribeRouteTablesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeRouteTablesResponse{}
	_body, _err := client.DescribeRouteTablesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeRouterInterfaceAttributeWithOptions(request *DescribeRouterInterfaceAttributeRequest, runtime *util.RuntimeOptions) (_result *DescribeRouterInterfaceAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeRouterInterfaceAttribute"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeRouterInterfaceAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeRouterInterfaceAttribute(request *DescribeRouterInterfaceAttributeRequest) (_result *DescribeRouterInterfaceAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeRouterInterfaceAttributeResponse{}
	_body, _err := client.DescribeRouterInterfaceAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeRouterInterfacesWithOptions(request *DescribeRouterInterfacesRequest, runtime *util.RuntimeOptions) (_result *DescribeRouterInterfacesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Filter)) {
		query["Filter"] = request.Filter
	}

	if !tea.BoolValue(util.IsUnset(request.IncludeReservationData)) {
		query["IncludeReservationData"] = request.IncludeReservationData
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeRouterInterfaces"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeRouterInterfacesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeRouterInterfaces(request *DescribeRouterInterfacesRequest) (_result *DescribeRouterInterfacesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeRouterInterfacesResponse{}
	_body, _err := client.DescribeRouterInterfacesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation to query only dedicated-bandwidth GA instances.
 *
 * @param request DescribeServerRelatedGlobalAccelerationInstancesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeServerRelatedGlobalAccelerationInstancesResponse
 */
func (client *Client) DescribeServerRelatedGlobalAccelerationInstancesWithOptions(request *DescribeServerRelatedGlobalAccelerationInstancesRequest, runtime *util.RuntimeOptions) (_result *DescribeServerRelatedGlobalAccelerationInstancesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ServerId)) {
		query["ServerId"] = request.ServerId
	}

	if !tea.BoolValue(util.IsUnset(request.ServerType)) {
		query["ServerType"] = request.ServerType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeServerRelatedGlobalAccelerationInstances"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeServerRelatedGlobalAccelerationInstancesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation to query only dedicated-bandwidth GA instances.
 *
 * @param request DescribeServerRelatedGlobalAccelerationInstancesRequest
 * @return DescribeServerRelatedGlobalAccelerationInstancesResponse
 */
func (client *Client) DescribeServerRelatedGlobalAccelerationInstances(request *DescribeServerRelatedGlobalAccelerationInstancesRequest) (_result *DescribeServerRelatedGlobalAccelerationInstancesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeServerRelatedGlobalAccelerationInstancesResponse{}
	_body, _err := client.DescribeServerRelatedGlobalAccelerationInstancesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeSnatTableEntriesWithOptions(request *DescribeSnatTableEntriesRequest, runtime *util.RuntimeOptions) (_result *DescribeSnatTableEntriesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.NatGatewayId)) {
		query["NatGatewayId"] = request.NatGatewayId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SnatEntryId)) {
		query["SnatEntryId"] = request.SnatEntryId
	}

	if !tea.BoolValue(util.IsUnset(request.SnatEntryName)) {
		query["SnatEntryName"] = request.SnatEntryName
	}

	if !tea.BoolValue(util.IsUnset(request.SnatIp)) {
		query["SnatIp"] = request.SnatIp
	}

	if !tea.BoolValue(util.IsUnset(request.SnatTableId)) {
		query["SnatTableId"] = request.SnatTableId
	}

	if !tea.BoolValue(util.IsUnset(request.SourceCIDR)) {
		query["SourceCIDR"] = request.SourceCIDR
	}

	if !tea.BoolValue(util.IsUnset(request.SourceVSwitchId)) {
		query["SourceVSwitchId"] = request.SourceVSwitchId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeSnatTableEntries"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeSnatTableEntriesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeSnatTableEntries(request *DescribeSnatTableEntriesRequest) (_result *DescribeSnatTableEntriesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeSnatTableEntriesResponse{}
	_body, _err := client.DescribeSnatTableEntriesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeSslVpnClientCertWithOptions(request *DescribeSslVpnClientCertRequest, runtime *util.RuntimeOptions) (_result *DescribeSslVpnClientCertResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SslVpnClientCertId)) {
		query["SslVpnClientCertId"] = request.SslVpnClientCertId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeSslVpnClientCert"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeSslVpnClientCertResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeSslVpnClientCert(request *DescribeSslVpnClientCertRequest) (_result *DescribeSslVpnClientCertResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeSslVpnClientCertResponse{}
	_body, _err := client.DescribeSslVpnClientCertWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeSslVpnClientCertsWithOptions(request *DescribeSslVpnClientCertsRequest, runtime *util.RuntimeOptions) (_result *DescribeSslVpnClientCertsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SslVpnClientCertId)) {
		query["SslVpnClientCertId"] = request.SslVpnClientCertId
	}

	if !tea.BoolValue(util.IsUnset(request.SslVpnServerId)) {
		query["SslVpnServerId"] = request.SslVpnServerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeSslVpnClientCerts"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeSslVpnClientCertsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeSslVpnClientCerts(request *DescribeSslVpnClientCertsRequest) (_result *DescribeSslVpnClientCertsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeSslVpnClientCertsResponse{}
	_body, _err := client.DescribeSslVpnClientCertsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeSslVpnClientsWithOptions(request *DescribeSslVpnClientsRequest, runtime *util.RuntimeOptions) (_result *DescribeSslVpnClientsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.VpnGatewayId)) {
		query["VpnGatewayId"] = request.VpnGatewayId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeSslVpnClients"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeSslVpnClientsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeSslVpnClients(request *DescribeSslVpnClientsRequest) (_result *DescribeSslVpnClientsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeSslVpnClientsResponse{}
	_body, _err := client.DescribeSslVpnClientsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeSslVpnServersWithOptions(request *DescribeSslVpnServersRequest, runtime *util.RuntimeOptions) (_result *DescribeSslVpnServersResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SslVpnServerId)) {
		query["SslVpnServerId"] = request.SslVpnServerId
	}

	if !tea.BoolValue(util.IsUnset(request.VpnGatewayId)) {
		query["VpnGatewayId"] = request.VpnGatewayId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeSslVpnServers"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeSslVpnServersResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeSslVpnServers(request *DescribeSslVpnServersRequest) (_result *DescribeSslVpnServersResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeSslVpnServersResponse{}
	_body, _err := client.DescribeSslVpnServersWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeTagKeysWithOptions(request *DescribeTagKeysRequest, runtime *util.RuntimeOptions) (_result *DescribeTagKeysResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Keyword)) {
		query["Keyword"] = request.Keyword
	}

	if !tea.BoolValue(util.IsUnset(request.MaxResult)) {
		query["MaxResult"] = request.MaxResult
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceId)) {
		query["ResourceId"] = request.ResourceId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeTagKeys"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeTagKeysResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeTagKeys(request *DescribeTagKeysRequest) (_result *DescribeTagKeysResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeTagKeysResponse{}
	_body, _err := client.DescribeTagKeysWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeTagKeysForExpressConnectWithOptions(request *DescribeTagKeysForExpressConnectRequest, runtime *util.RuntimeOptions) (_result *DescribeTagKeysForExpressConnectResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Keyword)) {
		query["Keyword"] = request.Keyword
	}

	if !tea.BoolValue(util.IsUnset(request.MaxResult)) {
		query["MaxResult"] = request.MaxResult
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceId)) {
		query["ResourceId"] = request.ResourceId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeTagKeysForExpressConnect"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeTagKeysForExpressConnectResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeTagKeysForExpressConnect(request *DescribeTagKeysForExpressConnectRequest) (_result *DescribeTagKeysForExpressConnectResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeTagKeysForExpressConnectResponse{}
	_body, _err := client.DescribeTagKeysForExpressConnectWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   You must specify **ResourceId.N** or **Tag.N** that consists of **Tag.N.Key** and **Tag.N.Value** in the request to specify the object that you want to query.
 * *   **Tag.N** is a resource tag that consists of a key-value pair. If you specify only **Tag.N.Key**, all tag values that are associated with the specified tag key are returned. If you specify only **Tag.N.Value**, an error message is returned.
 * *   If you specify **Tag.N** and **ResourceId.N** to filter tags, **ResourceId.N** must match all specified key-value pairs.
 * *   If you specify multiple key-value pairs, all tags that match the key-value pairs are returned.
 *
 * @param request DescribeTagsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeTagsResponse
 */
func (client *Client) DescribeTagsWithOptions(request *DescribeTagsRequest, runtime *util.RuntimeOptions) (_result *DescribeTagsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.MaxResult)) {
		query["MaxResult"] = request.MaxResult
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceId)) {
		query["ResourceId"] = request.ResourceId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeTags"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeTagsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   You must specify **ResourceId.N** or **Tag.N** that consists of **Tag.N.Key** and **Tag.N.Value** in the request to specify the object that you want to query.
 * *   **Tag.N** is a resource tag that consists of a key-value pair. If you specify only **Tag.N.Key**, all tag values that are associated with the specified tag key are returned. If you specify only **Tag.N.Value**, an error message is returned.
 * *   If you specify **Tag.N** and **ResourceId.N** to filter tags, **ResourceId.N** must match all specified key-value pairs.
 * *   If you specify multiple key-value pairs, all tags that match the key-value pairs are returned.
 *
 * @param request DescribeTagsRequest
 * @return DescribeTagsResponse
 */
func (client *Client) DescribeTags(request *DescribeTagsRequest) (_result *DescribeTagsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeTagsResponse{}
	_body, _err := client.DescribeTagsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeVRoutersWithOptions(request *DescribeVRoutersRequest, runtime *util.RuntimeOptions) (_result *DescribeVRoutersResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.VRouterId)) {
		query["VRouterId"] = request.VRouterId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeVRouters"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeVRoutersResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeVRouters(request *DescribeVRoutersRequest) (_result *DescribeVRoutersResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeVRoutersResponse{}
	_body, _err := client.DescribeVRoutersWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeVSwitchAttributesWithOptions(request *DescribeVSwitchAttributesRequest, runtime *util.RuntimeOptions) (_result *DescribeVSwitchAttributesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.VSwitchId)) {
		query["VSwitchId"] = request.VSwitchId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeVSwitchAttributes"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeVSwitchAttributesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeVSwitchAttributes(request *DescribeVSwitchAttributesRequest) (_result *DescribeVSwitchAttributesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeVSwitchAttributesResponse{}
	_body, _err := client.DescribeVSwitchAttributesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeVSwitchesWithOptions(request *DescribeVSwitchesRequest, runtime *util.RuntimeOptions) (_result *DescribeVSwitchesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.IsDefault)) {
		query["IsDefault"] = request.IsDefault
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RouteTableId)) {
		query["RouteTableId"] = request.RouteTableId
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	if !tea.BoolValue(util.IsUnset(request.VSwitchId)) {
		query["VSwitchId"] = request.VSwitchId
	}

	if !tea.BoolValue(util.IsUnset(request.VSwitchName)) {
		query["VSwitchName"] = request.VSwitchName
	}

	if !tea.BoolValue(util.IsUnset(request.VSwitchOwnerId)) {
		query["VSwitchOwnerId"] = request.VSwitchOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.VpcId)) {
		query["VpcId"] = request.VpcId
	}

	if !tea.BoolValue(util.IsUnset(request.ZoneId)) {
		query["ZoneId"] = request.ZoneId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeVSwitches"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeVSwitchesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeVSwitches(request *DescribeVSwitchesRequest) (_result *DescribeVSwitchesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeVSwitchesResponse{}
	_body, _err := client.DescribeVSwitchesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeVbrHaWithOptions(request *DescribeVbrHaRequest, runtime *util.RuntimeOptions) (_result *DescribeVbrHaResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.VbrHaId)) {
		query["VbrHaId"] = request.VbrHaId
	}

	if !tea.BoolValue(util.IsUnset(request.VbrId)) {
		query["VbrId"] = request.VbrId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeVbrHa"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeVbrHaResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeVbrHa(request *DescribeVbrHaRequest) (_result *DescribeVbrHaResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeVbrHaResponse{}
	_body, _err := client.DescribeVbrHaWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeVcoRouteEntriesWithOptions(request *DescribeVcoRouteEntriesRequest, runtime *util.RuntimeOptions) (_result *DescribeVcoRouteEntriesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RouteEntryType)) {
		query["RouteEntryType"] = request.RouteEntryType
	}

	if !tea.BoolValue(util.IsUnset(request.VpnConnectionId)) {
		query["VpnConnectionId"] = request.VpnConnectionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeVcoRouteEntries"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeVcoRouteEntriesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeVcoRouteEntries(request *DescribeVcoRouteEntriesRequest) (_result *DescribeVcoRouteEntriesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeVcoRouteEntriesResponse{}
	_body, _err := client.DescribeVcoRouteEntriesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeVirtualBorderRoutersWithOptions(request *DescribeVirtualBorderRoutersRequest, runtime *util.RuntimeOptions) (_result *DescribeVirtualBorderRoutersResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Filter)) {
		query["Filter"] = request.Filter
	}

	if !tea.BoolValue(util.IsUnset(request.IncludeCrossAccountVbr)) {
		query["IncludeCrossAccountVbr"] = request.IncludeCrossAccountVbr
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeVirtualBorderRouters"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeVirtualBorderRoutersResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeVirtualBorderRouters(request *DescribeVirtualBorderRoutersRequest) (_result *DescribeVirtualBorderRoutersResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeVirtualBorderRoutersResponse{}
	_body, _err := client.DescribeVirtualBorderRoutersWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeVirtualBorderRoutersForPhysicalConnectionWithOptions(request *DescribeVirtualBorderRoutersForPhysicalConnectionRequest, runtime *util.RuntimeOptions) (_result *DescribeVirtualBorderRoutersForPhysicalConnectionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Filter)) {
		query["Filter"] = request.Filter
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.PhysicalConnectionId)) {
		query["PhysicalConnectionId"] = request.PhysicalConnectionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeVirtualBorderRoutersForPhysicalConnection"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeVirtualBorderRoutersForPhysicalConnectionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeVirtualBorderRoutersForPhysicalConnection(request *DescribeVirtualBorderRoutersForPhysicalConnectionRequest) (_result *DescribeVirtualBorderRoutersForPhysicalConnectionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeVirtualBorderRoutersForPhysicalConnectionResponse{}
	_body, _err := client.DescribeVirtualBorderRoutersForPhysicalConnectionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeVpcAttributeWithOptions(request *DescribeVpcAttributeRequest, runtime *util.RuntimeOptions) (_result *DescribeVpcAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.IsDefault)) {
		query["IsDefault"] = request.IsDefault
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.VpcId)) {
		query["VpcId"] = request.VpcId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeVpcAttribute"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeVpcAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeVpcAttribute(request *DescribeVpcAttributeRequest) (_result *DescribeVpcAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeVpcAttributeResponse{}
	_body, _err := client.DescribeVpcAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeVpcsWithOptions(request *DescribeVpcsRequest, runtime *util.RuntimeOptions) (_result *DescribeVpcsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DhcpOptionsSetId)) {
		query["DhcpOptionsSetId"] = request.DhcpOptionsSetId
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.IsDefault)) {
		query["IsDefault"] = request.IsDefault
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	if !tea.BoolValue(util.IsUnset(request.VpcId)) {
		query["VpcId"] = request.VpcId
	}

	if !tea.BoolValue(util.IsUnset(request.VpcName)) {
		query["VpcName"] = request.VpcName
	}

	if !tea.BoolValue(util.IsUnset(request.VpcOwnerId)) {
		query["VpcOwnerId"] = request.VpcOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeVpcs"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeVpcsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeVpcs(request *DescribeVpcsRequest) (_result *DescribeVpcsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeVpcsResponse{}
	_body, _err := client.DescribeVpcsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeVpnAttachmentsWithOptions(request *DescribeVpnAttachmentsRequest, runtime *util.RuntimeOptions) (_result *DescribeVpnAttachmentsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AttachType)) {
		query["AttachType"] = request.AttachType
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.VpnConnectionId)) {
		query["VpnConnectionId"] = request.VpnConnectionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeVpnAttachments"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeVpnAttachmentsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeVpnAttachments(request *DescribeVpnAttachmentsRequest) (_result *DescribeVpnAttachmentsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeVpnAttachmentsResponse{}
	_body, _err := client.DescribeVpnAttachmentsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeVpnConnectionWithOptions(request *DescribeVpnConnectionRequest, runtime *util.RuntimeOptions) (_result *DescribeVpnConnectionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.VpnConnectionId)) {
		query["VpnConnectionId"] = request.VpnConnectionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeVpnConnection"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeVpnConnectionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeVpnConnection(request *DescribeVpnConnectionRequest) (_result *DescribeVpnConnectionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeVpnConnectionResponse{}
	_body, _err := client.DescribeVpnConnectionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeVpnConnectionLogsWithOptions(request *DescribeVpnConnectionLogsRequest, runtime *util.RuntimeOptions) (_result *DescribeVpnConnectionLogsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.From)) {
		query["From"] = request.From
	}

	if !tea.BoolValue(util.IsUnset(request.MinutePeriod)) {
		query["MinutePeriod"] = request.MinutePeriod
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.To)) {
		query["To"] = request.To
	}

	if !tea.BoolValue(util.IsUnset(request.TunnelId)) {
		query["TunnelId"] = request.TunnelId
	}

	if !tea.BoolValue(util.IsUnset(request.VpnConnectionId)) {
		query["VpnConnectionId"] = request.VpnConnectionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeVpnConnectionLogs"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeVpnConnectionLogsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeVpnConnectionLogs(request *DescribeVpnConnectionLogsRequest) (_result *DescribeVpnConnectionLogsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeVpnConnectionLogsResponse{}
	_body, _err := client.DescribeVpnConnectionLogsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeVpnConnectionsWithOptions(request *DescribeVpnConnectionsRequest, runtime *util.RuntimeOptions) (_result *DescribeVpnConnectionsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CustomerGatewayId)) {
		query["CustomerGatewayId"] = request.CustomerGatewayId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	if !tea.BoolValue(util.IsUnset(request.VpnConnectionId)) {
		query["VpnConnectionId"] = request.VpnConnectionId
	}

	if !tea.BoolValue(util.IsUnset(request.VpnGatewayId)) {
		query["VpnGatewayId"] = request.VpnGatewayId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeVpnConnections"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeVpnConnectionsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeVpnConnections(request *DescribeVpnConnectionsRequest) (_result *DescribeVpnConnectionsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeVpnConnectionsResponse{}
	_body, _err := client.DescribeVpnConnectionsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeVpnCrossAccountAuthorizationsWithOptions(request *DescribeVpnCrossAccountAuthorizationsRequest, runtime *util.RuntimeOptions) (_result *DescribeVpnCrossAccountAuthorizationsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.VpnConnectionId)) {
		query["VpnConnectionId"] = request.VpnConnectionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeVpnCrossAccountAuthorizations"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeVpnCrossAccountAuthorizationsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeVpnCrossAccountAuthorizations(request *DescribeVpnCrossAccountAuthorizationsRequest) (_result *DescribeVpnCrossAccountAuthorizationsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeVpnCrossAccountAuthorizationsResponse{}
	_body, _err := client.DescribeVpnCrossAccountAuthorizationsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeVpnGatewayWithOptions(request *DescribeVpnGatewayRequest, runtime *util.RuntimeOptions) (_result *DescribeVpnGatewayResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IncludeReservationData)) {
		query["IncludeReservationData"] = request.IncludeReservationData
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.VpnGatewayId)) {
		query["VpnGatewayId"] = request.VpnGatewayId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeVpnGateway"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeVpnGatewayResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeVpnGateway(request *DescribeVpnGatewayRequest) (_result *DescribeVpnGatewayResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeVpnGatewayResponse{}
	_body, _err := client.DescribeVpnGatewayWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeVpnGatewaysWithOptions(request *DescribeVpnGatewaysRequest, runtime *util.RuntimeOptions) (_result *DescribeVpnGatewaysResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BusinessStatus)) {
		query["BusinessStatus"] = request.BusinessStatus
	}

	if !tea.BoolValue(util.IsUnset(request.IncludeReservationData)) {
		query["IncludeReservationData"] = request.IncludeReservationData
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		query["Status"] = request.Status
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	if !tea.BoolValue(util.IsUnset(request.VpcId)) {
		query["VpcId"] = request.VpcId
	}

	if !tea.BoolValue(util.IsUnset(request.VpnGatewayId)) {
		query["VpnGatewayId"] = request.VpnGatewayId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeVpnGateways"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeVpnGatewaysResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeVpnGateways(request *DescribeVpnGatewaysRequest) (_result *DescribeVpnGatewaysResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeVpnGatewaysResponse{}
	_body, _err := client.DescribeVpnGatewaysWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeVpnPbrRouteEntriesWithOptions(request *DescribeVpnPbrRouteEntriesRequest, runtime *util.RuntimeOptions) (_result *DescribeVpnPbrRouteEntriesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.VpnGatewayId)) {
		query["VpnGatewayId"] = request.VpnGatewayId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeVpnPbrRouteEntries"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeVpnPbrRouteEntriesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeVpnPbrRouteEntries(request *DescribeVpnPbrRouteEntriesRequest) (_result *DescribeVpnPbrRouteEntriesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeVpnPbrRouteEntriesResponse{}
	_body, _err := client.DescribeVpnPbrRouteEntriesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeVpnRouteEntriesWithOptions(request *DescribeVpnRouteEntriesRequest, runtime *util.RuntimeOptions) (_result *DescribeVpnRouteEntriesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RouteEntryType)) {
		query["RouteEntryType"] = request.RouteEntryType
	}

	if !tea.BoolValue(util.IsUnset(request.VpnGatewayId)) {
		query["VpnGatewayId"] = request.VpnGatewayId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeVpnRouteEntries"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeVpnRouteEntriesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeVpnRouteEntries(request *DescribeVpnRouteEntriesRequest) (_result *DescribeVpnRouteEntriesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeVpnRouteEntriesResponse{}
	_body, _err := client.DescribeVpnRouteEntriesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeVpnSslServerLogsWithOptions(request *DescribeVpnSslServerLogsRequest, runtime *util.RuntimeOptions) (_result *DescribeVpnSslServerLogsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.From)) {
		query["From"] = request.From
	}

	if !tea.BoolValue(util.IsUnset(request.MinutePeriod)) {
		query["MinutePeriod"] = request.MinutePeriod
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SslVpnClientCertId)) {
		query["SslVpnClientCertId"] = request.SslVpnClientCertId
	}

	if !tea.BoolValue(util.IsUnset(request.To)) {
		query["To"] = request.To
	}

	if !tea.BoolValue(util.IsUnset(request.VpnSslServerId)) {
		query["VpnSslServerId"] = request.VpnSslServerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeVpnSslServerLogs"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeVpnSslServerLogsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeVpnSslServerLogs(request *DescribeVpnSslServerLogsRequest) (_result *DescribeVpnSslServerLogsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeVpnSslServerLogsResponse{}
	_body, _err := client.DescribeVpnSslServerLogsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeZonesWithOptions(request *DescribeZonesRequest, runtime *util.RuntimeOptions) (_result *DescribeZonesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ZoneType)) {
		query["ZoneType"] = request.ZoneType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeZones"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeZonesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeZones(request *DescribeZonesRequest) (_result *DescribeZonesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeZonesResponse{}
	_body, _err := client.DescribeZonesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   The **DetachDhcpOptionsSetFromVpc** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeVpcAttribute](~~94565~~) operation to query the status of a DHCP options set:
 *     *   If the DHCP options set is in the **Pending** state, the DHCP options set is being disassociated.
 *     *   If the DHCP options set is in the **UnUsed** state, the DHCP options set is disassociated.
 * *   You cannot repeatedly call the **DetachDhcpOptionsSetFromVpc** operation to disassociate a DHCP options set from a VPC within the specified period of time.
 *
 * @param request DetachDhcpOptionsSetFromVpcRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DetachDhcpOptionsSetFromVpcResponse
 */
func (client *Client) DetachDhcpOptionsSetFromVpcWithOptions(request *DetachDhcpOptionsSetFromVpcRequest, runtime *util.RuntimeOptions) (_result *DetachDhcpOptionsSetFromVpcResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DhcpOptionsSetId)) {
		query["DhcpOptionsSetId"] = request.DhcpOptionsSetId
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.VpcId)) {
		query["VpcId"] = request.VpcId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DetachDhcpOptionsSetFromVpc"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DetachDhcpOptionsSetFromVpcResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   The **DetachDhcpOptionsSetFromVpc** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeVpcAttribute](~~94565~~) operation to query the status of a DHCP options set:
 *     *   If the DHCP options set is in the **Pending** state, the DHCP options set is being disassociated.
 *     *   If the DHCP options set is in the **UnUsed** state, the DHCP options set is disassociated.
 * *   You cannot repeatedly call the **DetachDhcpOptionsSetFromVpc** operation to disassociate a DHCP options set from a VPC within the specified period of time.
 *
 * @param request DetachDhcpOptionsSetFromVpcRequest
 * @return DetachDhcpOptionsSetFromVpcResponse
 */
func (client *Client) DetachDhcpOptionsSetFromVpc(request *DetachDhcpOptionsSetFromVpcRequest) (_result *DetachDhcpOptionsSetFromVpcResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DetachDhcpOptionsSetFromVpcResponse{}
	_body, _err := client.DetachDhcpOptionsSetFromVpcWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Only VPN gateways in specific regions support the quick diagnostics feature. For more information about the supported regions, see [Supported regions](~~430697~~).
 *
 * @param request DiagnoseVpnGatewayRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DiagnoseVpnGatewayResponse
 */
func (client *Client) DiagnoseVpnGatewayWithOptions(request *DiagnoseVpnGatewayRequest, runtime *util.RuntimeOptions) (_result *DiagnoseVpnGatewayResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.IPsecExtendInfo)) {
		query["IPsecExtendInfo"] = request.IPsecExtendInfo
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceId)) {
		query["ResourceId"] = request.ResourceId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.VpnGatewayId)) {
		query["VpnGatewayId"] = request.VpnGatewayId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DiagnoseVpnGateway"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DiagnoseVpnGatewayResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Only VPN gateways in specific regions support the quick diagnostics feature. For more information about the supported regions, see [Supported regions](~~430697~~).
 *
 * @param request DiagnoseVpnGatewayRequest
 * @return DiagnoseVpnGatewayResponse
 */
func (client *Client) DiagnoseVpnGateway(request *DiagnoseVpnGatewayRequest) (_result *DiagnoseVpnGatewayResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DiagnoseVpnGatewayResponse{}
	_body, _err := client.DiagnoseVpnGatewayWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DisableNatGatewayEcsMetricWithOptions(request *DisableNatGatewayEcsMetricRequest, runtime *util.RuntimeOptions) (_result *DisableNatGatewayEcsMetricResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.NatGatewayId)) {
		query["NatGatewayId"] = request.NatGatewayId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DisableNatGatewayEcsMetric"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DisableNatGatewayEcsMetricResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DisableNatGatewayEcsMetric(request *DisableNatGatewayEcsMetricRequest) (_result *DisableNatGatewayEcsMetricResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DisableNatGatewayEcsMetricResponse{}
	_body, _err := client.DisableNatGatewayEcsMetricWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DisableVpcClassicLinkWithOptions(request *DisableVpcClassicLinkRequest, runtime *util.RuntimeOptions) (_result *DisableVpcClassicLinkResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.VpcId)) {
		query["VpcId"] = request.VpcId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DisableVpcClassicLink"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DisableVpcClassicLinkResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DisableVpcClassicLink(request *DisableVpcClassicLinkRequest) (_result *DisableVpcClassicLinkResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DisableVpcClassicLinkResponse{}
	_body, _err := client.DisableVpcClassicLinkWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DissociateRouteTableFromGatewayWithOptions(request *DissociateRouteTableFromGatewayRequest, runtime *util.RuntimeOptions) (_result *DissociateRouteTableFromGatewayResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayId)) {
		query["GatewayId"] = request.GatewayId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RouteTableId)) {
		query["RouteTableId"] = request.RouteTableId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DissociateRouteTableFromGateway"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DissociateRouteTableFromGatewayResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DissociateRouteTableFromGateway(request *DissociateRouteTableFromGatewayRequest) (_result *DissociateRouteTableFromGatewayResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DissociateRouteTableFromGatewayResponse{}
	_body, _err := client.DissociateRouteTableFromGatewayWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DissociateRouteTablesFromVpcGatewayEndpointWithOptions(request *DissociateRouteTablesFromVpcGatewayEndpointRequest, runtime *util.RuntimeOptions) (_result *DissociateRouteTablesFromVpcGatewayEndpointResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.EndpointId)) {
		query["EndpointId"] = request.EndpointId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RouteTableIds)) {
		query["RouteTableIds"] = request.RouteTableIds
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DissociateRouteTablesFromVpcGatewayEndpoint"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DissociateRouteTablesFromVpcGatewayEndpointResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DissociateRouteTablesFromVpcGatewayEndpoint(request *DissociateRouteTablesFromVpcGatewayEndpointRequest) (_result *DissociateRouteTablesFromVpcGatewayEndpointResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DissociateRouteTablesFromVpcGatewayEndpointResponse{}
	_body, _err := client.DissociateRouteTablesFromVpcGatewayEndpointWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Usage notes
 * *   **DissociateVpnGatewayWithCertificate** is an asynchronous operation. After a request is sent, the system returns a request and runs the task in the background. You can call the [DescribeVpnGateway](~~73720~~) operation to query the status the task.
 *     *   If the VPN gateway is in the **updating** state, the SSL certificate is being disassociated from the VPN gateway.
 *     *   If the VPN gateway is in the **active** state, the SSL certificate is disassociated from the VPN gateway.
 * *   You cannot repeatedly call **DissociateVpnGatewayWithCertificate** within a specific period of time.
 *
 * @param request DissociateVpnGatewayWithCertificateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DissociateVpnGatewayWithCertificateResponse
 */
func (client *Client) DissociateVpnGatewayWithCertificateWithOptions(request *DissociateVpnGatewayWithCertificateRequest, runtime *util.RuntimeOptions) (_result *DissociateVpnGatewayWithCertificateResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CertificateId)) {
		query["CertificateId"] = request.CertificateId
	}

	if !tea.BoolValue(util.IsUnset(request.CertificateType)) {
		query["CertificateType"] = request.CertificateType
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.VpnGatewayId)) {
		query["VpnGatewayId"] = request.VpnGatewayId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DissociateVpnGatewayWithCertificate"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DissociateVpnGatewayWithCertificateResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Usage notes
 * *   **DissociateVpnGatewayWithCertificate** is an asynchronous operation. After a request is sent, the system returns a request and runs the task in the background. You can call the [DescribeVpnGateway](~~73720~~) operation to query the status the task.
 *     *   If the VPN gateway is in the **updating** state, the SSL certificate is being disassociated from the VPN gateway.
 *     *   If the VPN gateway is in the **active** state, the SSL certificate is disassociated from the VPN gateway.
 * *   You cannot repeatedly call **DissociateVpnGatewayWithCertificate** within a specific period of time.
 *
 * @param request DissociateVpnGatewayWithCertificateRequest
 * @return DissociateVpnGatewayWithCertificateResponse
 */
func (client *Client) DissociateVpnGatewayWithCertificate(request *DissociateVpnGatewayWithCertificateRequest) (_result *DissociateVpnGatewayWithCertificateResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DissociateVpnGatewayWithCertificateResponse{}
	_body, _err := client.DissociateVpnGatewayWithCertificateWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DownloadVpnConnectionConfigWithOptions(request *DownloadVpnConnectionConfigRequest, runtime *util.RuntimeOptions) (_result *DownloadVpnConnectionConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.VpnConnectionId)) {
		query["VpnConnectionId"] = request.VpnConnectionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DownloadVpnConnectionConfig"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DownloadVpnConnectionConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DownloadVpnConnectionConfig(request *DownloadVpnConnectionConfigRequest) (_result *DownloadVpnConnectionConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DownloadVpnConnectionConfigResponse{}
	_body, _err := client.DownloadVpnConnectionConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) EnableNatGatewayEcsMetricWithOptions(request *EnableNatGatewayEcsMetricRequest, runtime *util.RuntimeOptions) (_result *EnableNatGatewayEcsMetricResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.NatGatewayId)) {
		query["NatGatewayId"] = request.NatGatewayId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("EnableNatGatewayEcsMetric"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &EnableNatGatewayEcsMetricResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) EnableNatGatewayEcsMetric(request *EnableNatGatewayEcsMetricRequest) (_result *EnableNatGatewayEcsMetricResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &EnableNatGatewayEcsMetricResponse{}
	_body, _err := client.EnableNatGatewayEcsMetricWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * When you call this operation, take note of the following limits:
 * *   You can enable only an Express Connect circuit that is in the **Confirmed** state.
 * *   After you enable an Express Connect circuit, it changes to the **Enabled** state.
 *
 * @param request EnablePhysicalConnectionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return EnablePhysicalConnectionResponse
 */
func (client *Client) EnablePhysicalConnectionWithOptions(request *EnablePhysicalConnectionRequest, runtime *util.RuntimeOptions) (_result *EnablePhysicalConnectionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PhysicalConnectionId)) {
		query["PhysicalConnectionId"] = request.PhysicalConnectionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("EnablePhysicalConnection"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &EnablePhysicalConnectionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * When you call this operation, take note of the following limits:
 * *   You can enable only an Express Connect circuit that is in the **Confirmed** state.
 * *   After you enable an Express Connect circuit, it changes to the **Enabled** state.
 *
 * @param request EnablePhysicalConnectionRequest
 * @return EnablePhysicalConnectionResponse
 */
func (client *Client) EnablePhysicalConnection(request *EnablePhysicalConnectionRequest) (_result *EnablePhysicalConnectionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &EnablePhysicalConnectionResponse{}
	_body, _err := client.EnablePhysicalConnectionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) EnableVpcClassicLinkWithOptions(request *EnableVpcClassicLinkRequest, runtime *util.RuntimeOptions) (_result *EnableVpcClassicLinkResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.VpcId)) {
		query["VpcId"] = request.VpcId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("EnableVpcClassicLink"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &EnableVpcClassicLinkResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) EnableVpcClassicLink(request *EnableVpcClassicLinkRequest) (_result *EnableVpcClassicLinkResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &EnableVpcClassicLinkResponse{}
	_body, _err := client.EnableVpcClassicLinkWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   The **EnableVpcIpv4Gateway** operation is asynchronous. After you send the request, the system returns **RequestId**. However, the operation is still being performed in the system background. You can call the [GetIpv4GatewayAttribute](~~407670~~) operation to query the status of an IPv4 gateway:
 *     *   If the IPv4 gateway is in the **Activating** state, the IPv4 gateway is being activated.
 *     *   If the IPv4 gateway is in the **Created** state, the IPv4 gateway is activated.
 * *   You cannot repeatedly call the **EnableVpcIpv4Gateway** operation to activate an IPv4 gateway within the specified period of time.
 *
 * @param request EnableVpcIpv4GatewayRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return EnableVpcIpv4GatewayResponse
 */
func (client *Client) EnableVpcIpv4GatewayWithOptions(request *EnableVpcIpv4GatewayRequest, runtime *util.RuntimeOptions) (_result *EnableVpcIpv4GatewayResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.Ipv4GatewayId)) {
		query["Ipv4GatewayId"] = request.Ipv4GatewayId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RouteTableList)) {
		query["RouteTableList"] = request.RouteTableList
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("EnableVpcIpv4Gateway"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &EnableVpcIpv4GatewayResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   The **EnableVpcIpv4Gateway** operation is asynchronous. After you send the request, the system returns **RequestId**. However, the operation is still being performed in the system background. You can call the [GetIpv4GatewayAttribute](~~407670~~) operation to query the status of an IPv4 gateway:
 *     *   If the IPv4 gateway is in the **Activating** state, the IPv4 gateway is being activated.
 *     *   If the IPv4 gateway is in the **Created** state, the IPv4 gateway is activated.
 * *   You cannot repeatedly call the **EnableVpcIpv4Gateway** operation to activate an IPv4 gateway within the specified period of time.
 *
 * @param request EnableVpcIpv4GatewayRequest
 * @return EnableVpcIpv4GatewayResponse
 */
func (client *Client) EnableVpcIpv4Gateway(request *EnableVpcIpv4GatewayRequest) (_result *EnableVpcIpv4GatewayResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &EnableVpcIpv4GatewayResponse{}
	_body, _err := client.EnableVpcIpv4GatewayWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetDhcpOptionsSetWithOptions(request *GetDhcpOptionsSetRequest, runtime *util.RuntimeOptions) (_result *GetDhcpOptionsSetResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DhcpOptionsSetId)) {
		query["DhcpOptionsSetId"] = request.DhcpOptionsSetId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetDhcpOptionsSet"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetDhcpOptionsSetResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetDhcpOptionsSet(request *GetDhcpOptionsSetRequest) (_result *GetDhcpOptionsSetResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetDhcpOptionsSetResponse{}
	_body, _err := client.GetDhcpOptionsSetWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetFlowLogServiceStatusWithOptions(request *GetFlowLogServiceStatusRequest, runtime *util.RuntimeOptions) (_result *GetFlowLogServiceStatusResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetFlowLogServiceStatus"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetFlowLogServiceStatusResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetFlowLogServiceStatus(request *GetFlowLogServiceStatusRequest) (_result *GetFlowLogServiceStatusResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetFlowLogServiceStatusResponse{}
	_body, _err := client.GetFlowLogServiceStatusWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetIpv4GatewayAttributeWithOptions(request *GetIpv4GatewayAttributeRequest, runtime *util.RuntimeOptions) (_result *GetIpv4GatewayAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Ipv4GatewayId)) {
		query["Ipv4GatewayId"] = request.Ipv4GatewayId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetIpv4GatewayAttribute"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetIpv4GatewayAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetIpv4GatewayAttribute(request *GetIpv4GatewayAttributeRequest) (_result *GetIpv4GatewayAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetIpv4GatewayAttributeResponse{}
	_body, _err := client.GetIpv4GatewayAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call this operation to query information about a specified Internet NAT gateway or Virtual Private Cloud (VPC) NAT gateway. In this topic, "NAT gateway" refers to both gateway types.
 *
 * @param request GetNatGatewayAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetNatGatewayAttributeResponse
 */
func (client *Client) GetNatGatewayAttributeWithOptions(request *GetNatGatewayAttributeRequest, runtime *util.RuntimeOptions) (_result *GetNatGatewayAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.NatGatewayId)) {
		query["NatGatewayId"] = request.NatGatewayId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetNatGatewayAttribute"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetNatGatewayAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call this operation to query information about a specified Internet NAT gateway or Virtual Private Cloud (VPC) NAT gateway. In this topic, "NAT gateway" refers to both gateway types.
 *
 * @param request GetNatGatewayAttributeRequest
 * @return GetNatGatewayAttributeResponse
 */
func (client *Client) GetNatGatewayAttribute(request *GetNatGatewayAttributeRequest) (_result *GetNatGatewayAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetNatGatewayAttributeResponse{}
	_body, _err := client.GetNatGatewayAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetNatGatewayConvertStatusWithOptions(request *GetNatGatewayConvertStatusRequest, runtime *util.RuntimeOptions) (_result *GetNatGatewayConvertStatusResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.NatGatewayId)) {
		query["NatGatewayId"] = request.NatGatewayId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetNatGatewayConvertStatus"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetNatGatewayConvertStatusResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetNatGatewayConvertStatus(request *GetNatGatewayConvertStatusRequest) (_result *GetNatGatewayConvertStatusResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetNatGatewayConvertStatusResponse{}
	_body, _err := client.GetNatGatewayConvertStatusWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call this API operation to query the status of outbound data transfer billing for the current account. For more information about outbound data transfer billing, see [Outbound data transfer billing](~~274385~~) and [Billing](~~54582~~).
 *
 * @param request GetPhysicalConnectionServiceStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetPhysicalConnectionServiceStatusResponse
 */
func (client *Client) GetPhysicalConnectionServiceStatusWithOptions(request *GetPhysicalConnectionServiceStatusRequest, runtime *util.RuntimeOptions) (_result *GetPhysicalConnectionServiceStatusResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetPhysicalConnectionServiceStatus"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetPhysicalConnectionServiceStatusResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call this API operation to query the status of outbound data transfer billing for the current account. For more information about outbound data transfer billing, see [Outbound data transfer billing](~~274385~~) and [Billing](~~54582~~).
 *
 * @param request GetPhysicalConnectionServiceStatusRequest
 * @return GetPhysicalConnectionServiceStatusResponse
 */
func (client *Client) GetPhysicalConnectionServiceStatus(request *GetPhysicalConnectionServiceStatusRequest) (_result *GetPhysicalConnectionServiceStatusResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetPhysicalConnectionServiceStatusResponse{}
	_body, _err := client.GetPhysicalConnectionServiceStatusWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetTrafficMirrorServiceStatusWithOptions(request *GetTrafficMirrorServiceStatusRequest, runtime *util.RuntimeOptions) (_result *GetTrafficMirrorServiceStatusResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetTrafficMirrorServiceStatus"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetTrafficMirrorServiceStatusResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetTrafficMirrorServiceStatus(request *GetTrafficMirrorServiceStatusRequest) (_result *GetTrafficMirrorServiceStatusResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetTrafficMirrorServiceStatusResponse{}
	_body, _err := client.GetTrafficMirrorServiceStatusWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetVpcGatewayEndpointAttributeWithOptions(request *GetVpcGatewayEndpointAttributeRequest, runtime *util.RuntimeOptions) (_result *GetVpcGatewayEndpointAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndpointId)) {
		query["EndpointId"] = request.EndpointId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetVpcGatewayEndpointAttribute"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetVpcGatewayEndpointAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetVpcGatewayEndpointAttribute(request *GetVpcGatewayEndpointAttributeRequest) (_result *GetVpcGatewayEndpointAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetVpcGatewayEndpointAttributeResponse{}
	_body, _err := client.GetVpcGatewayEndpointAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetVpcPrefixListAssociationsWithOptions(request *GetVpcPrefixListAssociationsRequest, runtime *util.RuntimeOptions) (_result *GetVpcPrefixListAssociationsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PrefixListId)) {
		query["PrefixListId"] = request.PrefixListId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetVpcPrefixListAssociations"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetVpcPrefixListAssociationsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetVpcPrefixListAssociations(request *GetVpcPrefixListAssociationsRequest) (_result *GetVpcPrefixListAssociationsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetVpcPrefixListAssociationsResponse{}
	_body, _err := client.GetVpcPrefixListAssociationsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetVpcPrefixListEntriesWithOptions(request *GetVpcPrefixListEntriesRequest, runtime *util.RuntimeOptions) (_result *GetVpcPrefixListEntriesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PrefixListId)) {
		query["PrefixListId"] = request.PrefixListId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetVpcPrefixListEntries"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetVpcPrefixListEntriesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetVpcPrefixListEntries(request *GetVpcPrefixListEntriesRequest) (_result *GetVpcPrefixListEntriesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetVpcPrefixListEntriesResponse{}
	_body, _err := client.GetVpcPrefixListEntriesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetVpcRouteEntrySummaryWithOptions(request *GetVpcRouteEntrySummaryRequest, runtime *util.RuntimeOptions) (_result *GetVpcRouteEntrySummaryResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RouteEntryType)) {
		query["RouteEntryType"] = request.RouteEntryType
	}

	if !tea.BoolValue(util.IsUnset(request.RouteTableId)) {
		query["RouteTableId"] = request.RouteTableId
	}

	if !tea.BoolValue(util.IsUnset(request.VpcId)) {
		query["VpcId"] = request.VpcId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetVpcRouteEntrySummary"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetVpcRouteEntrySummaryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetVpcRouteEntrySummary(request *GetVpcRouteEntrySummaryRequest) (_result *GetVpcRouteEntrySummaryResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetVpcRouteEntrySummaryResponse{}
	_body, _err := client.GetVpcRouteEntrySummaryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * When you call the **GetVpnGatewayDiagnoseResult** operation, you must set one of the **DiagnoseId** and **VpnGatewayId** parameters.
 *
 * @param request GetVpnGatewayDiagnoseResultRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetVpnGatewayDiagnoseResultResponse
 */
func (client *Client) GetVpnGatewayDiagnoseResultWithOptions(request *GetVpnGatewayDiagnoseResultRequest, runtime *util.RuntimeOptions) (_result *GetVpnGatewayDiagnoseResultResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DiagnoseId)) {
		query["DiagnoseId"] = request.DiagnoseId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.VpnGatewayId)) {
		query["VpnGatewayId"] = request.VpnGatewayId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetVpnGatewayDiagnoseResult"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetVpnGatewayDiagnoseResultResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * When you call the **GetVpnGatewayDiagnoseResult** operation, you must set one of the **DiagnoseId** and **VpnGatewayId** parameters.
 *
 * @param request GetVpnGatewayDiagnoseResultRequest
 * @return GetVpnGatewayDiagnoseResultResponse
 */
func (client *Client) GetVpnGatewayDiagnoseResult(request *GetVpnGatewayDiagnoseResultRequest) (_result *GetVpnGatewayDiagnoseResultResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetVpnGatewayDiagnoseResultResponse{}
	_body, _err := client.GetVpnGatewayDiagnoseResultWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   Before you can attach a network instance that belongs to another Alibaba Cloud account to your CEN instance, you must grant permissions to your CEN instance.
 * >  **GrantInstanceToCen** is a Virtual Private Cloud (VPC) operation. Therefore, you must use `vpc.aliyuncs.com` as the domain name when you call this operation. The API version is `2016-04-28`.
 * *   You cannot repeatedly call the **GrantInstanceToCen** operation to grant the permissions on a network instance to a CEN instance. The network instance can be a VPC, a virtual border router (VBR), or a Cloud Connect Network (CCN) instance.
 *
 * @param request GrantInstanceToCenRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GrantInstanceToCenResponse
 */
func (client *Client) GrantInstanceToCenWithOptions(request *GrantInstanceToCenRequest, runtime *util.RuntimeOptions) (_result *GrantInstanceToCenResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CenId)) {
		query["CenId"] = request.CenId
	}

	if !tea.BoolValue(util.IsUnset(request.CenOwnerId)) {
		query["CenOwnerId"] = request.CenOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceType)) {
		query["InstanceType"] = request.InstanceType
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GrantInstanceToCen"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GrantInstanceToCenResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   Before you can attach a network instance that belongs to another Alibaba Cloud account to your CEN instance, you must grant permissions to your CEN instance.
 * >  **GrantInstanceToCen** is a Virtual Private Cloud (VPC) operation. Therefore, you must use `vpc.aliyuncs.com` as the domain name when you call this operation. The API version is `2016-04-28`.
 * *   You cannot repeatedly call the **GrantInstanceToCen** operation to grant the permissions on a network instance to a CEN instance. The network instance can be a VPC, a virtual border router (VBR), or a Cloud Connect Network (CCN) instance.
 *
 * @param request GrantInstanceToCenRequest
 * @return GrantInstanceToCenResponse
 */
func (client *Client) GrantInstanceToCen(request *GrantInstanceToCenRequest) (_result *GrantInstanceToCenResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GrantInstanceToCenResponse{}
	_body, _err := client.GrantInstanceToCenWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Usage notes
 * When you connect a VBR to a VPC that belongs to another Alibaba Cloud account, the VBR must acquire the required permissions from the VPC.
 *
 * @param tmpReq GrantInstanceToVbrRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GrantInstanceToVbrResponse
 */
func (client *Client) GrantInstanceToVbrWithOptions(tmpReq *GrantInstanceToVbrRequest, runtime *util.RuntimeOptions) (_result *GrantInstanceToVbrResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &GrantInstanceToVbrShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.VbrInstanceIds)) {
		request.VbrInstanceIdsShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.VbrInstanceIds, tea.String("VbrInstanceIds"), tea.String("simple"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.GrantType)) {
		query["GrantType"] = request.GrantType
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.VbrInstanceIdsShrink)) {
		query["VbrInstanceIds"] = request.VbrInstanceIdsShrink
	}

	if !tea.BoolValue(util.IsUnset(request.VbrOwnerUid)) {
		query["VbrOwnerUid"] = request.VbrOwnerUid
	}

	if !tea.BoolValue(util.IsUnset(request.VbrRegionNo)) {
		query["VbrRegionNo"] = request.VbrRegionNo
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GrantInstanceToVbr"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GrantInstanceToVbrResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Usage notes
 * When you connect a VBR to a VPC that belongs to another Alibaba Cloud account, the VBR must acquire the required permissions from the VPC.
 *
 * @param request GrantInstanceToVbrRequest
 * @return GrantInstanceToVbrResponse
 */
func (client *Client) GrantInstanceToVbr(request *GrantInstanceToVbrRequest) (_result *GrantInstanceToVbrResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GrantInstanceToVbrResponse{}
	_body, _err := client.GrantInstanceToVbrWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListBusinessAccessPointsWithOptions(request *ListBusinessAccessPointsRequest, runtime *util.RuntimeOptions) (_result *ListBusinessAccessPointsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListBusinessAccessPoints"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListBusinessAccessPointsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListBusinessAccessPoints(request *ListBusinessAccessPointsRequest) (_result *ListBusinessAccessPointsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListBusinessAccessPointsResponse{}
	_body, _err := client.ListBusinessAccessPointsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListDhcpOptionsSetsWithOptions(request *ListDhcpOptionsSetsRequest, runtime *util.RuntimeOptions) (_result *ListDhcpOptionsSetsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DhcpOptionsSetId)) {
		query["DhcpOptionsSetId"] = request.DhcpOptionsSetId
	}

	if !tea.BoolValue(util.IsUnset(request.DhcpOptionsSetName)) {
		query["DhcpOptionsSetName"] = request.DhcpOptionsSetName
	}

	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListDhcpOptionsSets"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListDhcpOptionsSetsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListDhcpOptionsSets(request *ListDhcpOptionsSetsRequest) (_result *ListDhcpOptionsSetsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListDhcpOptionsSetsResponse{}
	_body, _err := client.ListDhcpOptionsSetsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call this operation to query zones that support NAT gateways, including Internet NAT gateways and Virtual Private Cloud (VPC) NAT gateways.
 *
 * @param request ListEnhanhcedNatGatewayAvailableZonesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListEnhanhcedNatGatewayAvailableZonesResponse
 */
func (client *Client) ListEnhanhcedNatGatewayAvailableZonesWithOptions(request *ListEnhanhcedNatGatewayAvailableZonesRequest, runtime *util.RuntimeOptions) (_result *ListEnhanhcedNatGatewayAvailableZonesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListEnhanhcedNatGatewayAvailableZones"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListEnhanhcedNatGatewayAvailableZonesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call this operation to query zones that support NAT gateways, including Internet NAT gateways and Virtual Private Cloud (VPC) NAT gateways.
 *
 * @param request ListEnhanhcedNatGatewayAvailableZonesRequest
 * @return ListEnhanhcedNatGatewayAvailableZonesResponse
 */
func (client *Client) ListEnhanhcedNatGatewayAvailableZones(request *ListEnhanhcedNatGatewayAvailableZonesRequest) (_result *ListEnhanhcedNatGatewayAvailableZonesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListEnhanhcedNatGatewayAvailableZonesResponse{}
	_body, _err := client.ListEnhanhcedNatGatewayAvailableZonesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListFullNatEntriesWithOptions(request *ListFullNatEntriesRequest, runtime *util.RuntimeOptions) (_result *ListFullNatEntriesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.FullNatEntryId)) {
		query["FullNatEntryId"] = request.FullNatEntryId
	}

	if !tea.BoolValue(util.IsUnset(request.FullNatEntryNames)) {
		query["FullNatEntryNames"] = request.FullNatEntryNames
	}

	if !tea.BoolValue(util.IsUnset(request.FullNatTableId)) {
		query["FullNatTableId"] = request.FullNatTableId
	}

	if !tea.BoolValue(util.IsUnset(request.IpProtocol)) {
		query["IpProtocol"] = request.IpProtocol
	}

	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NatGatewayId)) {
		query["NatGatewayId"] = request.NatGatewayId
	}

	if !tea.BoolValue(util.IsUnset(request.NetworkInterfaceIds)) {
		query["NetworkInterfaceIds"] = request.NetworkInterfaceIds
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListFullNatEntries"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListFullNatEntriesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListFullNatEntries(request *ListFullNatEntriesRequest) (_result *ListFullNatEntriesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListFullNatEntriesResponse{}
	_body, _err := client.ListFullNatEntriesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListGatewayRouteTableEntriesWithOptions(request *ListGatewayRouteTableEntriesRequest, runtime *util.RuntimeOptions) (_result *ListGatewayRouteTableEntriesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DestinationCidrBlock)) {
		query["DestinationCidrBlock"] = request.DestinationCidrBlock
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayRouteTableId)) {
		query["GatewayRouteTableId"] = request.GatewayRouteTableId
	}

	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListGatewayRouteTableEntries"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListGatewayRouteTableEntriesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListGatewayRouteTableEntries(request *ListGatewayRouteTableEntriesRequest) (_result *ListGatewayRouteTableEntriesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListGatewayRouteTableEntriesResponse{}
	_body, _err := client.ListGatewayRouteTableEntriesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListGeographicSubRegionsWithOptions(runtime *util.RuntimeOptions) (_result *ListGeographicSubRegionsResponse, _err error) {
	req := &openapi.OpenApiRequest{}
	params := &openapi.Params{
		Action:      tea.String("ListGeographicSubRegions"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListGeographicSubRegionsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListGeographicSubRegions() (_result *ListGeographicSubRegionsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListGeographicSubRegionsResponse{}
	_body, _err := client.ListGeographicSubRegionsWithOptions(runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListIpsecServerLogsWithOptions(request *ListIpsecServerLogsRequest, runtime *util.RuntimeOptions) (_result *ListIpsecServerLogsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.From)) {
		query["From"] = request.From
	}

	if !tea.BoolValue(util.IsUnset(request.IpsecServerId)) {
		query["IpsecServerId"] = request.IpsecServerId
	}

	if !tea.BoolValue(util.IsUnset(request.MinutePeriod)) {
		query["MinutePeriod"] = request.MinutePeriod
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.To)) {
		query["To"] = request.To
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListIpsecServerLogs"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListIpsecServerLogsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListIpsecServerLogs(request *ListIpsecServerLogsRequest) (_result *ListIpsecServerLogsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListIpsecServerLogsResponse{}
	_body, _err := client.ListIpsecServerLogsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListIpsecServersWithOptions(request *ListIpsecServersRequest, runtime *util.RuntimeOptions) (_result *ListIpsecServersResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IpsecServerId)) {
		query["IpsecServerId"] = request.IpsecServerId
	}

	if !tea.BoolValue(util.IsUnset(request.IpsecServerName)) {
		query["IpsecServerName"] = request.IpsecServerName
	}

	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.VpnGatewayId)) {
		query["VpnGatewayId"] = request.VpnGatewayId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListIpsecServers"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListIpsecServersResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListIpsecServers(request *ListIpsecServersRequest) (_result *ListIpsecServersResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListIpsecServersResponse{}
	_body, _err := client.ListIpsecServersWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListIpv4GatewaysWithOptions(request *ListIpv4GatewaysRequest, runtime *util.RuntimeOptions) (_result *ListIpv4GatewaysResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Ipv4GatewayId)) {
		query["Ipv4GatewayId"] = request.Ipv4GatewayId
	}

	if !tea.BoolValue(util.IsUnset(request.Ipv4GatewayName)) {
		query["Ipv4GatewayName"] = request.Ipv4GatewayName
	}

	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	if !tea.BoolValue(util.IsUnset(request.VpcId)) {
		query["VpcId"] = request.VpcId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListIpv4Gateways"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListIpv4GatewaysResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListIpv4Gateways(request *ListIpv4GatewaysRequest) (_result *ListIpv4GatewaysResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListIpv4GatewaysResponse{}
	_body, _err := client.ListIpv4GatewaysWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListNatIpCidrsWithOptions(request *ListNatIpCidrsRequest, runtime *util.RuntimeOptions) (_result *ListNatIpCidrsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NatGatewayId)) {
		query["NatGatewayId"] = request.NatGatewayId
	}

	if !tea.BoolValue(util.IsUnset(request.NatIpCidr)) {
		query["NatIpCidr"] = request.NatIpCidr
	}

	if !tea.BoolValue(util.IsUnset(request.NatIpCidrName)) {
		query["NatIpCidrName"] = request.NatIpCidrName
	}

	if !tea.BoolValue(util.IsUnset(request.NatIpCidrStatus)) {
		query["NatIpCidrStatus"] = request.NatIpCidrStatus
	}

	if !tea.BoolValue(util.IsUnset(request.NatIpCidrs)) {
		query["NatIpCidrs"] = request.NatIpCidrs
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListNatIpCidrs"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListNatIpCidrsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListNatIpCidrs(request *ListNatIpCidrsRequest) (_result *ListNatIpCidrsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListNatIpCidrsResponse{}
	_body, _err := client.ListNatIpCidrsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListNatIpsWithOptions(request *ListNatIpsRequest, runtime *util.RuntimeOptions) (_result *ListNatIpsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NatGatewayId)) {
		query["NatGatewayId"] = request.NatGatewayId
	}

	if !tea.BoolValue(util.IsUnset(request.NatIpCidr)) {
		query["NatIpCidr"] = request.NatIpCidr
	}

	if !tea.BoolValue(util.IsUnset(request.NatIpIds)) {
		query["NatIpIds"] = request.NatIpIds
	}

	if !tea.BoolValue(util.IsUnset(request.NatIpName)) {
		query["NatIpName"] = request.NatIpName
	}

	if !tea.BoolValue(util.IsUnset(request.NatIpStatus)) {
		query["NatIpStatus"] = request.NatIpStatus
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListNatIps"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListNatIpsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListNatIps(request *ListNatIpsRequest) (_result *ListNatIpsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListNatIpsResponse{}
	_body, _err := client.ListNatIpsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListPrefixListsWithOptions(request *ListPrefixListsRequest, runtime *util.RuntimeOptions) (_result *ListPrefixListsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PrefixListIds)) {
		query["PrefixListIds"] = request.PrefixListIds
	}

	if !tea.BoolValue(util.IsUnset(request.PrefixListName)) {
		query["PrefixListName"] = request.PrefixListName
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListPrefixLists"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListPrefixListsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListPrefixLists(request *ListPrefixListsRequest) (_result *ListPrefixListsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListPrefixListsResponse{}
	_body, _err := client.ListPrefixListsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListPublicIpAddressPoolCidrBlocksWithOptions(request *ListPublicIpAddressPoolCidrBlocksRequest, runtime *util.RuntimeOptions) (_result *ListPublicIpAddressPoolCidrBlocksResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CidrBlock)) {
		query["CidrBlock"] = request.CidrBlock
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PublicIpAddressPoolId)) {
		query["PublicIpAddressPoolId"] = request.PublicIpAddressPoolId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListPublicIpAddressPoolCidrBlocks"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListPublicIpAddressPoolCidrBlocksResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListPublicIpAddressPoolCidrBlocks(request *ListPublicIpAddressPoolCidrBlocksRequest) (_result *ListPublicIpAddressPoolCidrBlocksResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListPublicIpAddressPoolCidrBlocksResponse{}
	_body, _err := client.ListPublicIpAddressPoolCidrBlocksWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListPublicIpAddressPoolsWithOptions(request *ListPublicIpAddressPoolsRequest, runtime *util.RuntimeOptions) (_result *ListPublicIpAddressPoolsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.Isp)) {
		query["Isp"] = request.Isp
	}

	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PublicIpAddressPoolIds)) {
		query["PublicIpAddressPoolIds"] = request.PublicIpAddressPoolIds
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		query["Status"] = request.Status
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListPublicIpAddressPools"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListPublicIpAddressPoolsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListPublicIpAddressPools(request *ListPublicIpAddressPoolsRequest) (_result *ListPublicIpAddressPoolsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListPublicIpAddressPoolsResponse{}
	_body, _err := client.ListPublicIpAddressPoolsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Usage notes
 * *   You must specify **ResourceId.N** or **Tag.N** that consists of **Tag.N.Key** and **Tag.N.Value** in the request to specify the object that you want to query.
 * *   **Tag.N** is a resource tag that consists of a key-value pair. If you specify only **Tag.N.Key**, all tag values that are associated with the specified key are returned. If you specify only **Tag.N.Value**, an error message is returned.
 * *   If you specify **Tag.N** and **ResourceId.N** to filter tags, **ResourceId.N** must match all specified key-value pairs.
 * *   If you specify multiple key-value pairs, resources that contain these key-value pairs are returned.
 *
 * @param request ListTagResourcesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListTagResourcesResponse
 */
func (client *Client) ListTagResourcesWithOptions(request *ListTagResourcesRequest, runtime *util.RuntimeOptions) (_result *ListTagResourcesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceId)) {
		query["ResourceId"] = request.ResourceId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListTagResources"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListTagResourcesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Usage notes
 * *   You must specify **ResourceId.N** or **Tag.N** that consists of **Tag.N.Key** and **Tag.N.Value** in the request to specify the object that you want to query.
 * *   **Tag.N** is a resource tag that consists of a key-value pair. If you specify only **Tag.N.Key**, all tag values that are associated with the specified key are returned. If you specify only **Tag.N.Value**, an error message is returned.
 * *   If you specify **Tag.N** and **ResourceId.N** to filter tags, **ResourceId.N** must match all specified key-value pairs.
 * *   If you specify multiple key-value pairs, resources that contain these key-value pairs are returned.
 *
 * @param request ListTagResourcesRequest
 * @return ListTagResourcesResponse
 */
func (client *Client) ListTagResources(request *ListTagResourcesRequest) (_result *ListTagResourcesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListTagResourcesResponse{}
	_body, _err := client.ListTagResourcesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   You must specify **ResourceId.N** or **Tag.N** that consists of **Tag.N.Key** and **Tag.N.Value** in the request to specify the object that you want to query.
 * *   **Tag.N** is a resource tag that consists of a key-value pair. If you specify only **Tag.N.Key**, all tag values that are associated with the specified tag key are returned. If you specify only **Tag.N.Value**, an error message is returned.
 * *   If you specify **Tag.N** and **ResourceId.N** to filter tags, **ResourceId.N** must match all specified key-value pairs.
 * *   If you specify multiple key-value pairs, resources that contain these key-value pairs are returned.
 *
 * @param request ListTagResourcesForExpressConnectRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListTagResourcesForExpressConnectResponse
 */
func (client *Client) ListTagResourcesForExpressConnectWithOptions(request *ListTagResourcesForExpressConnectRequest, runtime *util.RuntimeOptions) (_result *ListTagResourcesForExpressConnectResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceId)) {
		query["ResourceId"] = request.ResourceId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListTagResourcesForExpressConnect"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListTagResourcesForExpressConnectResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   You must specify **ResourceId.N** or **Tag.N** that consists of **Tag.N.Key** and **Tag.N.Value** in the request to specify the object that you want to query.
 * *   **Tag.N** is a resource tag that consists of a key-value pair. If you specify only **Tag.N.Key**, all tag values that are associated with the specified tag key are returned. If you specify only **Tag.N.Value**, an error message is returned.
 * *   If you specify **Tag.N** and **ResourceId.N** to filter tags, **ResourceId.N** must match all specified key-value pairs.
 * *   If you specify multiple key-value pairs, resources that contain these key-value pairs are returned.
 *
 * @param request ListTagResourcesForExpressConnectRequest
 * @return ListTagResourcesForExpressConnectResponse
 */
func (client *Client) ListTagResourcesForExpressConnect(request *ListTagResourcesForExpressConnectRequest) (_result *ListTagResourcesForExpressConnectResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListTagResourcesForExpressConnectResponse{}
	_body, _err := client.ListTagResourcesForExpressConnectWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListTrafficMirrorFiltersWithOptions(request *ListTrafficMirrorFiltersRequest, runtime *util.RuntimeOptions) (_result *ListTrafficMirrorFiltersResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	if !tea.BoolValue(util.IsUnset(request.TrafficMirrorFilterIds)) {
		query["TrafficMirrorFilterIds"] = request.TrafficMirrorFilterIds
	}

	if !tea.BoolValue(util.IsUnset(request.TrafficMirrorFilterName)) {
		query["TrafficMirrorFilterName"] = request.TrafficMirrorFilterName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListTrafficMirrorFilters"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListTrafficMirrorFiltersResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListTrafficMirrorFilters(request *ListTrafficMirrorFiltersRequest) (_result *ListTrafficMirrorFiltersResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListTrafficMirrorFiltersResponse{}
	_body, _err := client.ListTrafficMirrorFiltersWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListTrafficMirrorSessionsWithOptions(request *ListTrafficMirrorSessionsRequest, runtime *util.RuntimeOptions) (_result *ListTrafficMirrorSessionsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Enabled)) {
		query["Enabled"] = request.Enabled
	}

	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Priority)) {
		query["Priority"] = request.Priority
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	if !tea.BoolValue(util.IsUnset(request.TrafficMirrorFilterId)) {
		query["TrafficMirrorFilterId"] = request.TrafficMirrorFilterId
	}

	if !tea.BoolValue(util.IsUnset(request.TrafficMirrorSessionIds)) {
		query["TrafficMirrorSessionIds"] = request.TrafficMirrorSessionIds
	}

	if !tea.BoolValue(util.IsUnset(request.TrafficMirrorSessionName)) {
		query["TrafficMirrorSessionName"] = request.TrafficMirrorSessionName
	}

	if !tea.BoolValue(util.IsUnset(request.TrafficMirrorSourceId)) {
		query["TrafficMirrorSourceId"] = request.TrafficMirrorSourceId
	}

	if !tea.BoolValue(util.IsUnset(request.TrafficMirrorTargetId)) {
		query["TrafficMirrorTargetId"] = request.TrafficMirrorTargetId
	}

	if !tea.BoolValue(util.IsUnset(request.VirtualNetworkId)) {
		query["VirtualNetworkId"] = request.VirtualNetworkId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListTrafficMirrorSessions"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListTrafficMirrorSessionsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListTrafficMirrorSessions(request *ListTrafficMirrorSessionsRequest) (_result *ListTrafficMirrorSessionsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListTrafficMirrorSessionsResponse{}
	_body, _err := client.ListTrafficMirrorSessionsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListVirtualPhysicalConnectionsWithOptions(request *ListVirtualPhysicalConnectionsRequest, runtime *util.RuntimeOptions) (_result *ListVirtualPhysicalConnectionsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IsConfirmed)) {
		query["IsConfirmed"] = request.IsConfirmed
	}

	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.PhysicalConnectionId)) {
		query["PhysicalConnectionId"] = request.PhysicalConnectionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	if !tea.BoolValue(util.IsUnset(request.VirtualPhysicalConnectionAliUids)) {
		query["VirtualPhysicalConnectionAliUids"] = request.VirtualPhysicalConnectionAliUids
	}

	if !tea.BoolValue(util.IsUnset(request.VirtualPhysicalConnectionBusinessStatus)) {
		query["VirtualPhysicalConnectionBusinessStatus"] = request.VirtualPhysicalConnectionBusinessStatus
	}

	if !tea.BoolValue(util.IsUnset(request.VirtualPhysicalConnectionIds)) {
		query["VirtualPhysicalConnectionIds"] = request.VirtualPhysicalConnectionIds
	}

	if !tea.BoolValue(util.IsUnset(request.VirtualPhysicalConnectionStatuses)) {
		query["VirtualPhysicalConnectionStatuses"] = request.VirtualPhysicalConnectionStatuses
	}

	if !tea.BoolValue(util.IsUnset(request.VlanIds)) {
		query["VlanIds"] = request.VlanIds
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListVirtualPhysicalConnections"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListVirtualPhysicalConnectionsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListVirtualPhysicalConnections(request *ListVirtualPhysicalConnectionsRequest) (_result *ListVirtualPhysicalConnectionsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListVirtualPhysicalConnectionsResponse{}
	_body, _err := client.ListVirtualPhysicalConnectionsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListVpcEndpointServicesByEndUserWithOptions(request *ListVpcEndpointServicesByEndUserRequest, runtime *util.RuntimeOptions) (_result *ListVpcEndpointServicesByEndUserResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceName)) {
		query["ServiceName"] = request.ServiceName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListVpcEndpointServicesByEndUser"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListVpcEndpointServicesByEndUserResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListVpcEndpointServicesByEndUser(request *ListVpcEndpointServicesByEndUserRequest) (_result *ListVpcEndpointServicesByEndUserResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListVpcEndpointServicesByEndUserResponse{}
	_body, _err := client.ListVpcEndpointServicesByEndUserWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListVpcGatewayEndpointsWithOptions(request *ListVpcGatewayEndpointsRequest, runtime *util.RuntimeOptions) (_result *ListVpcGatewayEndpointsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndpointId)) {
		query["EndpointId"] = request.EndpointId
	}

	if !tea.BoolValue(util.IsUnset(request.EndpointName)) {
		query["EndpointName"] = request.EndpointName
	}

	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceName)) {
		query["ServiceName"] = request.ServiceName
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListVpcGatewayEndpoints"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListVpcGatewayEndpointsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListVpcGatewayEndpoints(request *ListVpcGatewayEndpointsRequest) (_result *ListVpcGatewayEndpointsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListVpcGatewayEndpointsResponse{}
	_body, _err := client.ListVpcGatewayEndpointsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Usage notes
 * When you call **ListVpnCertificateAssociations**, take note of the following information:
 * *   If you specify only **RegionId**, the SSL certificates associated with all VPN gateways in the specified region are queried.
 * *   If you specify **RegionId** and **CertificateType**, the SSL certificates of the specified type that are associated with the VPN gateways in the specified region are queried.
 * *   If you specify **RegionId** and **VpnGatewayId**, the SSL certificates associated with the specified VPN gateway in the specified region are queried.
 * *   If you specify **RegionId** and **CertificateId**, the VPN gateways associated with the specified SSL certificate in the specified region are queried.
 *
 * @param request ListVpnCertificateAssociationsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListVpnCertificateAssociationsResponse
 */
func (client *Client) ListVpnCertificateAssociationsWithOptions(request *ListVpnCertificateAssociationsRequest, runtime *util.RuntimeOptions) (_result *ListVpnCertificateAssociationsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CertificateId)) {
		query["CertificateId"] = request.CertificateId
	}

	if !tea.BoolValue(util.IsUnset(request.CertificateType)) {
		query["CertificateType"] = request.CertificateType
	}

	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.VpnGatewayId)) {
		query["VpnGatewayId"] = request.VpnGatewayId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListVpnCertificateAssociations"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListVpnCertificateAssociationsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Usage notes
 * When you call **ListVpnCertificateAssociations**, take note of the following information:
 * *   If you specify only **RegionId**, the SSL certificates associated with all VPN gateways in the specified region are queried.
 * *   If you specify **RegionId** and **CertificateType**, the SSL certificates of the specified type that are associated with the VPN gateways in the specified region are queried.
 * *   If you specify **RegionId** and **VpnGatewayId**, the SSL certificates associated with the specified VPN gateway in the specified region are queried.
 * *   If you specify **RegionId** and **CertificateId**, the VPN gateways associated with the specified SSL certificate in the specified region are queried.
 *
 * @param request ListVpnCertificateAssociationsRequest
 * @return ListVpnCertificateAssociationsResponse
 */
func (client *Client) ListVpnCertificateAssociations(request *ListVpnCertificateAssociationsRequest) (_result *ListVpnCertificateAssociationsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListVpnCertificateAssociationsResponse{}
	_body, _err := client.ListVpnCertificateAssociationsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifyBgpGroupAttributeWithOptions(request *ModifyBgpGroupAttributeRequest, runtime *util.RuntimeOptions) (_result *ModifyBgpGroupAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AuthKey)) {
		query["AuthKey"] = request.AuthKey
	}

	if !tea.BoolValue(util.IsUnset(request.BgpGroupId)) {
		query["BgpGroupId"] = request.BgpGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ClearAuthKey)) {
		query["ClearAuthKey"] = request.ClearAuthKey
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.IsFakeAsn)) {
		query["IsFakeAsn"] = request.IsFakeAsn
	}

	if !tea.BoolValue(util.IsUnset(request.LocalAsn)) {
		query["LocalAsn"] = request.LocalAsn
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PeerAsn)) {
		query["PeerAsn"] = request.PeerAsn
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RouteQuota)) {
		query["RouteQuota"] = request.RouteQuota
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyBgpGroupAttribute"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyBgpGroupAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifyBgpGroupAttribute(request *ModifyBgpGroupAttributeRequest) (_result *ModifyBgpGroupAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyBgpGroupAttributeResponse{}
	_body, _err := client.ModifyBgpGroupAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifyBgpPeerAttributeWithOptions(request *ModifyBgpPeerAttributeRequest, runtime *util.RuntimeOptions) (_result *ModifyBgpPeerAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BfdMultiHop)) {
		query["BfdMultiHop"] = request.BfdMultiHop
	}

	if !tea.BoolValue(util.IsUnset(request.BgpGroupId)) {
		query["BgpGroupId"] = request.BgpGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.BgpPeerId)) {
		query["BgpPeerId"] = request.BgpPeerId
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.EnableBfd)) {
		query["EnableBfd"] = request.EnableBfd
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PeerIpAddress)) {
		query["PeerIpAddress"] = request.PeerIpAddress
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyBgpPeerAttribute"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyBgpPeerAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifyBgpPeerAttribute(request *ModifyBgpPeerAttributeRequest) (_result *ModifyBgpPeerAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyBgpPeerAttributeResponse{}
	_body, _err := client.ModifyBgpPeerAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifyCommonBandwidthPackageAttributeWithOptions(request *ModifyCommonBandwidthPackageAttributeRequest, runtime *util.RuntimeOptions) (_result *ModifyCommonBandwidthPackageAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BandwidthPackageId)) {
		query["BandwidthPackageId"] = request.BandwidthPackageId
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyCommonBandwidthPackageAttribute"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyCommonBandwidthPackageAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifyCommonBandwidthPackageAttribute(request *ModifyCommonBandwidthPackageAttributeRequest) (_result *ModifyCommonBandwidthPackageAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyCommonBandwidthPackageAttributeResponse{}
	_body, _err := client.ModifyCommonBandwidthPackageAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call the **ModifyCommonBandwidthPackageIpBandwidth** operation to set the maximum bandwidth of an EIP that is associated with an EIP bandwidth plan. This prevents an EIP from exhausting the bandwidth resources of an EIP bandwidth plan.
 * For example, two EIPs are associated with an EIP bandwidth plan whose maximum bandwidth is 800 Mbit/s. In this case, you can set the maximum bandwidth of one EIP to 500 Mbit/s and that of the other EIP to 400 Mbit/s. After you set the maximum bandwidth values, the first EIP cannot consume bandwidth higher than 500 Mbit/s. The second EIP cannot consume bandwidth higher than 400 Mbit/s.
 * When you call this operation, take note of the following items:
 * *   This operation is valid only for EIPs that are associated with Elastic Compute Service (ECS) instances. This operation is invalid for EIPs that are associated with Server Load Balancer (SLB) instances, NAT gateways, secondary elastic network interfaces (ENIs), or high-availability virtual IP addresses (HAVIPs).
 * *   This operation is in public preview. You can call this operation to set the maximum bandwidth of EIPs only if the EIPs are associated with an EIP bandwidth plan. The feature is not supported in the console.
 * *   You cannot repeatedly call this operation to set the maximum bandwidth of an EIP within the specified period of time.
 *
 * @param request ModifyCommonBandwidthPackageIpBandwidthRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyCommonBandwidthPackageIpBandwidthResponse
 */
func (client *Client) ModifyCommonBandwidthPackageIpBandwidthWithOptions(request *ModifyCommonBandwidthPackageIpBandwidthRequest, runtime *util.RuntimeOptions) (_result *ModifyCommonBandwidthPackageIpBandwidthResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Bandwidth)) {
		query["Bandwidth"] = request.Bandwidth
	}

	if !tea.BoolValue(util.IsUnset(request.BandwidthPackageId)) {
		query["BandwidthPackageId"] = request.BandwidthPackageId
	}

	if !tea.BoolValue(util.IsUnset(request.EipId)) {
		query["EipId"] = request.EipId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyCommonBandwidthPackageIpBandwidth"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyCommonBandwidthPackageIpBandwidthResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call the **ModifyCommonBandwidthPackageIpBandwidth** operation to set the maximum bandwidth of an EIP that is associated with an EIP bandwidth plan. This prevents an EIP from exhausting the bandwidth resources of an EIP bandwidth plan.
 * For example, two EIPs are associated with an EIP bandwidth plan whose maximum bandwidth is 800 Mbit/s. In this case, you can set the maximum bandwidth of one EIP to 500 Mbit/s and that of the other EIP to 400 Mbit/s. After you set the maximum bandwidth values, the first EIP cannot consume bandwidth higher than 500 Mbit/s. The second EIP cannot consume bandwidth higher than 400 Mbit/s.
 * When you call this operation, take note of the following items:
 * *   This operation is valid only for EIPs that are associated with Elastic Compute Service (ECS) instances. This operation is invalid for EIPs that are associated with Server Load Balancer (SLB) instances, NAT gateways, secondary elastic network interfaces (ENIs), or high-availability virtual IP addresses (HAVIPs).
 * *   This operation is in public preview. You can call this operation to set the maximum bandwidth of EIPs only if the EIPs are associated with an EIP bandwidth plan. The feature is not supported in the console.
 * *   You cannot repeatedly call this operation to set the maximum bandwidth of an EIP within the specified period of time.
 *
 * @param request ModifyCommonBandwidthPackageIpBandwidthRequest
 * @return ModifyCommonBandwidthPackageIpBandwidthResponse
 */
func (client *Client) ModifyCommonBandwidthPackageIpBandwidth(request *ModifyCommonBandwidthPackageIpBandwidthRequest) (_result *ModifyCommonBandwidthPackageIpBandwidthResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyCommonBandwidthPackageIpBandwidthResponse{}
	_body, _err := client.ModifyCommonBandwidthPackageIpBandwidthWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   The **ModifyCommonBandwidthPackageSpec** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeCommonBandwidthPackages](~~120309~~) operation to query the status of an EIP bandwidth plan:
 *     *   If the EIP bandwidth plan is in the **Modifying** state, the maximum bandwidth of the EIP bandwidth plan is being modified. In this state, you can only query the EIP bandwidth plan and cannot perform other operations.
 *     *   If the EIP bandwidth plan is in the **Available** state, the maximum bandwidth of the EIP bandwidth plan is modified.
 * *   You cannot repeatedly call the **ModifyCommonBandwidthPackageSpec** operation to modify the maximum bandwidth of an EIP bandwidth plan within the specified period of time.
 *
 * @param request ModifyCommonBandwidthPackageSpecRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyCommonBandwidthPackageSpecResponse
 */
func (client *Client) ModifyCommonBandwidthPackageSpecWithOptions(request *ModifyCommonBandwidthPackageSpecRequest, runtime *util.RuntimeOptions) (_result *ModifyCommonBandwidthPackageSpecResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Bandwidth)) {
		query["Bandwidth"] = request.Bandwidth
	}

	if !tea.BoolValue(util.IsUnset(request.BandwidthPackageId)) {
		query["BandwidthPackageId"] = request.BandwidthPackageId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyCommonBandwidthPackageSpec"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyCommonBandwidthPackageSpecResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   The **ModifyCommonBandwidthPackageSpec** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeCommonBandwidthPackages](~~120309~~) operation to query the status of an EIP bandwidth plan:
 *     *   If the EIP bandwidth plan is in the **Modifying** state, the maximum bandwidth of the EIP bandwidth plan is being modified. In this state, you can only query the EIP bandwidth plan and cannot perform other operations.
 *     *   If the EIP bandwidth plan is in the **Available** state, the maximum bandwidth of the EIP bandwidth plan is modified.
 * *   You cannot repeatedly call the **ModifyCommonBandwidthPackageSpec** operation to modify the maximum bandwidth of an EIP bandwidth plan within the specified period of time.
 *
 * @param request ModifyCommonBandwidthPackageSpecRequest
 * @return ModifyCommonBandwidthPackageSpecResponse
 */
func (client *Client) ModifyCommonBandwidthPackageSpec(request *ModifyCommonBandwidthPackageSpecRequest) (_result *ModifyCommonBandwidthPackageSpecResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyCommonBandwidthPackageSpecResponse{}
	_body, _err := client.ModifyCommonBandwidthPackageSpecWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   When you call **ModifyCustomerGatewayAttribute**, if a value is assigned to **AuthKey**, the operation is asynchronous. After you call the operation, the information about the customer gateway is returned but the operation is still being performed in the system background. You can call [DescribeVpnGateway](~~73720~~) to query the status of a customer gateway.
 *     *   If a VPN gateway is in the **updating** state, the configurations are being modified.
 *     *   If a VPN gateway is in the **active** state, the configurations have been modified.
 * *   When you call **ModifyCustomerGatewayAttribute**, if no value is assigned to **AuthKey**, the operation is synchronous.
 * *   You cannot repeatedly call **ModifyCustomerGatewayAttribute** to modify the configurations of a customer gateway within the specified period of time.
 *
 * @param request ModifyCustomerGatewayAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyCustomerGatewayAttributeResponse
 */
func (client *Client) ModifyCustomerGatewayAttributeWithOptions(request *ModifyCustomerGatewayAttributeRequest, runtime *util.RuntimeOptions) (_result *ModifyCustomerGatewayAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AuthKey)) {
		query["AuthKey"] = request.AuthKey
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.CustomerGatewayId)) {
		query["CustomerGatewayId"] = request.CustomerGatewayId
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyCustomerGatewayAttribute"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyCustomerGatewayAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   When you call **ModifyCustomerGatewayAttribute**, if a value is assigned to **AuthKey**, the operation is asynchronous. After you call the operation, the information about the customer gateway is returned but the operation is still being performed in the system background. You can call [DescribeVpnGateway](~~73720~~) to query the status of a customer gateway.
 *     *   If a VPN gateway is in the **updating** state, the configurations are being modified.
 *     *   If a VPN gateway is in the **active** state, the configurations have been modified.
 * *   When you call **ModifyCustomerGatewayAttribute**, if no value is assigned to **AuthKey**, the operation is synchronous.
 * *   You cannot repeatedly call **ModifyCustomerGatewayAttribute** to modify the configurations of a customer gateway within the specified period of time.
 *
 * @param request ModifyCustomerGatewayAttributeRequest
 * @return ModifyCustomerGatewayAttributeResponse
 */
func (client *Client) ModifyCustomerGatewayAttribute(request *ModifyCustomerGatewayAttributeRequest) (_result *ModifyCustomerGatewayAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyCustomerGatewayAttributeResponse{}
	_body, _err := client.ModifyCustomerGatewayAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifyEipAddressAttributeWithOptions(request *ModifyEipAddressAttributeRequest, runtime *util.RuntimeOptions) (_result *ModifyEipAddressAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AllocationId)) {
		query["AllocationId"] = request.AllocationId
	}

	if !tea.BoolValue(util.IsUnset(request.Bandwidth)) {
		query["Bandwidth"] = request.Bandwidth
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyEipAddressAttribute"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyEipAddressAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifyEipAddressAttribute(request *ModifyEipAddressAttributeRequest) (_result *ModifyEipAddressAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyEipAddressAttributeResponse{}
	_body, _err := client.ModifyEipAddressAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifyExpressCloudConnectionAttributeWithOptions(request *ModifyExpressCloudConnectionAttributeRequest, runtime *util.RuntimeOptions) (_result *ModifyExpressCloudConnectionAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BgpAs)) {
		query["BgpAs"] = request.BgpAs
	}

	if !tea.BoolValue(util.IsUnset(request.CeIp)) {
		query["CeIp"] = request.CeIp
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.EccId)) {
		query["EccId"] = request.EccId
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PeIp)) {
		query["PeIp"] = request.PeIp
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyExpressCloudConnectionAttribute"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyExpressCloudConnectionAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifyExpressCloudConnectionAttribute(request *ModifyExpressCloudConnectionAttributeRequest) (_result *ModifyExpressCloudConnectionAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyExpressCloudConnectionAttributeResponse{}
	_body, _err := client.ModifyExpressCloudConnectionAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifyExpressCloudConnectionBandwidthWithOptions(request *ModifyExpressCloudConnectionBandwidthRequest, runtime *util.RuntimeOptions) (_result *ModifyExpressCloudConnectionBandwidthResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Bandwidth)) {
		query["Bandwidth"] = request.Bandwidth
	}

	if !tea.BoolValue(util.IsUnset(request.EccId)) {
		query["EccId"] = request.EccId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyExpressCloudConnectionBandwidth"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyExpressCloudConnectionBandwidthResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifyExpressCloudConnectionBandwidth(request *ModifyExpressCloudConnectionBandwidthRequest) (_result *ModifyExpressCloudConnectionBandwidthResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyExpressCloudConnectionBandwidthResponse{}
	_body, _err := client.ModifyExpressCloudConnectionBandwidthWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   **ModifyFlowLogAttribute** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeFlowLogs](~~87923~~) operation to query the status of a flow log:
 *     *   If the flow log is in the **Modifying** state, the flow log is being modified.
 *     *   If the flow log is in the **Active** or **Inactive** state, the flow log is modified.
 * *   You cannot repeatedly call the **ModifyFlowLogAttribute** operation to modify a flow log within the specified period of time.
 *
 * @param request ModifyFlowLogAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyFlowLogAttributeResponse
 */
func (client *Client) ModifyFlowLogAttributeWithOptions(request *ModifyFlowLogAttributeRequest, runtime *util.RuntimeOptions) (_result *ModifyFlowLogAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AggregationInterval)) {
		query["AggregationInterval"] = request.AggregationInterval
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.FlowLogId)) {
		query["FlowLogId"] = request.FlowLogId
	}

	if !tea.BoolValue(util.IsUnset(request.FlowLogName)) {
		query["FlowLogName"] = request.FlowLogName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyFlowLogAttribute"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyFlowLogAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   **ModifyFlowLogAttribute** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeFlowLogs](~~87923~~) operation to query the status of a flow log:
 *     *   If the flow log is in the **Modifying** state, the flow log is being modified.
 *     *   If the flow log is in the **Active** or **Inactive** state, the flow log is modified.
 * *   You cannot repeatedly call the **ModifyFlowLogAttribute** operation to modify a flow log within the specified period of time.
 *
 * @param request ModifyFlowLogAttributeRequest
 * @return ModifyFlowLogAttributeResponse
 */
func (client *Client) ModifyFlowLogAttribute(request *ModifyFlowLogAttributeRequest) (_result *ModifyFlowLogAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyFlowLogAttributeResponse{}
	_body, _err := client.ModifyFlowLogAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   **ModifyForwardEntry** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeForwardTableEntries](~~36053~~) operation to query the status of a DNAT entry.
 *     *   **Pending**: indicates that the system is modifying the DNAT entry. You can only query the DNAT entry, but cannot perform other operations.
 *     *   **Available**: indicates that the DNAT entry is modified.
 * *   You cannot repeatedly call the **ModifyForwardEntry** operation to modify a DNAT entry within the specified period of time.
 *
 * @param request ModifyForwardEntryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyForwardEntryResponse
 */
func (client *Client) ModifyForwardEntryWithOptions(request *ModifyForwardEntryRequest, runtime *util.RuntimeOptions) (_result *ModifyForwardEntryResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.ExternalIp)) {
		query["ExternalIp"] = request.ExternalIp
	}

	if !tea.BoolValue(util.IsUnset(request.ExternalPort)) {
		query["ExternalPort"] = request.ExternalPort
	}

	if !tea.BoolValue(util.IsUnset(request.ForwardEntryId)) {
		query["ForwardEntryId"] = request.ForwardEntryId
	}

	if !tea.BoolValue(util.IsUnset(request.ForwardEntryName)) {
		query["ForwardEntryName"] = request.ForwardEntryName
	}

	if !tea.BoolValue(util.IsUnset(request.ForwardTableId)) {
		query["ForwardTableId"] = request.ForwardTableId
	}

	if !tea.BoolValue(util.IsUnset(request.InternalIp)) {
		query["InternalIp"] = request.InternalIp
	}

	if !tea.BoolValue(util.IsUnset(request.InternalPort)) {
		query["InternalPort"] = request.InternalPort
	}

	if !tea.BoolValue(util.IsUnset(request.IpProtocol)) {
		query["IpProtocol"] = request.IpProtocol
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PortBreak)) {
		query["PortBreak"] = request.PortBreak
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyForwardEntry"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyForwardEntryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   **ModifyForwardEntry** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeForwardTableEntries](~~36053~~) operation to query the status of a DNAT entry.
 *     *   **Pending**: indicates that the system is modifying the DNAT entry. You can only query the DNAT entry, but cannot perform other operations.
 *     *   **Available**: indicates that the DNAT entry is modified.
 * *   You cannot repeatedly call the **ModifyForwardEntry** operation to modify a DNAT entry within the specified period of time.
 *
 * @param request ModifyForwardEntryRequest
 * @return ModifyForwardEntryResponse
 */
func (client *Client) ModifyForwardEntry(request *ModifyForwardEntryRequest) (_result *ModifyForwardEntryResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyForwardEntryResponse{}
	_body, _err := client.ModifyForwardEntryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   **ModifyFullNatEntryAttribute** is an asynchronous operation. After you make a request, the ID of the request is returned but the specified FULLNAT entry is not modified. The system modifies the FULLNAT entry in the background. You can call the [ListFullNatEntries](~~348779~~) operation to query the status of a FULLNAT entry.
 *     *   **Modifying**: indicates that the system is modifying the FULLNAT entry. You can query the FULLNAT entry, but cannot perform other operations.
 *     *   **Available**: indicates that the FULLNAT entry is modified.
 * *   You cannot repeatedly call the **ModifyFullNatEntryAttribute** operation to modify a FULLNAT entry within the specified period of time.
 *
 * @param request ModifyFullNatEntryAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyFullNatEntryAttributeResponse
 */
func (client *Client) ModifyFullNatEntryAttributeWithOptions(request *ModifyFullNatEntryAttributeRequest, runtime *util.RuntimeOptions) (_result *ModifyFullNatEntryAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AccessIp)) {
		query["AccessIp"] = request.AccessIp
	}

	if !tea.BoolValue(util.IsUnset(request.AccessPort)) {
		query["AccessPort"] = request.AccessPort
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.FullNatEntryDescription)) {
		query["FullNatEntryDescription"] = request.FullNatEntryDescription
	}

	if !tea.BoolValue(util.IsUnset(request.FullNatEntryId)) {
		query["FullNatEntryId"] = request.FullNatEntryId
	}

	if !tea.BoolValue(util.IsUnset(request.FullNatEntryName)) {
		query["FullNatEntryName"] = request.FullNatEntryName
	}

	if !tea.BoolValue(util.IsUnset(request.FullNatTableId)) {
		query["FullNatTableId"] = request.FullNatTableId
	}

	if !tea.BoolValue(util.IsUnset(request.IpProtocol)) {
		query["IpProtocol"] = request.IpProtocol
	}

	if !tea.BoolValue(util.IsUnset(request.NatIp)) {
		query["NatIp"] = request.NatIp
	}

	if !tea.BoolValue(util.IsUnset(request.NatIpPort)) {
		query["NatIpPort"] = request.NatIpPort
	}

	if !tea.BoolValue(util.IsUnset(request.NetworkInterfaceId)) {
		query["NetworkInterfaceId"] = request.NetworkInterfaceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyFullNatEntryAttribute"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyFullNatEntryAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   **ModifyFullNatEntryAttribute** is an asynchronous operation. After you make a request, the ID of the request is returned but the specified FULLNAT entry is not modified. The system modifies the FULLNAT entry in the background. You can call the [ListFullNatEntries](~~348779~~) operation to query the status of a FULLNAT entry.
 *     *   **Modifying**: indicates that the system is modifying the FULLNAT entry. You can query the FULLNAT entry, but cannot perform other operations.
 *     *   **Available**: indicates that the FULLNAT entry is modified.
 * *   You cannot repeatedly call the **ModifyFullNatEntryAttribute** operation to modify a FULLNAT entry within the specified period of time.
 *
 * @param request ModifyFullNatEntryAttributeRequest
 * @return ModifyFullNatEntryAttributeResponse
 */
func (client *Client) ModifyFullNatEntryAttribute(request *ModifyFullNatEntryAttributeRequest) (_result *ModifyFullNatEntryAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyFullNatEntryAttributeResponse{}
	_body, _err := client.ModifyFullNatEntryAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifyGlobalAccelerationInstanceAttributesWithOptions(request *ModifyGlobalAccelerationInstanceAttributesRequest, runtime *util.RuntimeOptions) (_result *ModifyGlobalAccelerationInstanceAttributesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.GlobalAccelerationInstanceId)) {
		query["GlobalAccelerationInstanceId"] = request.GlobalAccelerationInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyGlobalAccelerationInstanceAttributes"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyGlobalAccelerationInstanceAttributesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifyGlobalAccelerationInstanceAttributes(request *ModifyGlobalAccelerationInstanceAttributesRequest) (_result *ModifyGlobalAccelerationInstanceAttributesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyGlobalAccelerationInstanceAttributesResponse{}
	_body, _err := client.ModifyGlobalAccelerationInstanceAttributesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Usage notes
 * You cannot call this operation to modify the maximum bandwidth of a subscription GA instance.
 *
 * @param request ModifyGlobalAccelerationInstanceSpecRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyGlobalAccelerationInstanceSpecResponse
 */
func (client *Client) ModifyGlobalAccelerationInstanceSpecWithOptions(request *ModifyGlobalAccelerationInstanceSpecRequest, runtime *util.RuntimeOptions) (_result *ModifyGlobalAccelerationInstanceSpecResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Bandwidth)) {
		query["Bandwidth"] = request.Bandwidth
	}

	if !tea.BoolValue(util.IsUnset(request.GlobalAccelerationInstanceId)) {
		query["GlobalAccelerationInstanceId"] = request.GlobalAccelerationInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyGlobalAccelerationInstanceSpec"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyGlobalAccelerationInstanceSpecResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Usage notes
 * You cannot call this operation to modify the maximum bandwidth of a subscription GA instance.
 *
 * @param request ModifyGlobalAccelerationInstanceSpecRequest
 * @return ModifyGlobalAccelerationInstanceSpecResponse
 */
func (client *Client) ModifyGlobalAccelerationInstanceSpec(request *ModifyGlobalAccelerationInstanceSpecRequest) (_result *ModifyGlobalAccelerationInstanceSpecResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyGlobalAccelerationInstanceSpecResponse{}
	_body, _err := client.ModifyGlobalAccelerationInstanceSpecWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You cannot repeatedly call the **ModifyHaVipAttribute** operation to modify the name and description of an HAVIP within the specified period of time.
 *
 * @param request ModifyHaVipAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyHaVipAttributeResponse
 */
func (client *Client) ModifyHaVipAttributeWithOptions(request *ModifyHaVipAttributeRequest, runtime *util.RuntimeOptions) (_result *ModifyHaVipAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.HaVipId)) {
		query["HaVipId"] = request.HaVipId
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyHaVipAttribute"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyHaVipAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You cannot repeatedly call the **ModifyHaVipAttribute** operation to modify the name and description of an HAVIP within the specified period of time.
 *
 * @param request ModifyHaVipAttributeRequest
 * @return ModifyHaVipAttributeResponse
 */
func (client *Client) ModifyHaVipAttribute(request *ModifyHaVipAttributeRequest) (_result *ModifyHaVipAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyHaVipAttributeResponse{}
	_body, _err := client.ModifyHaVipAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * @deprecated
 *
 * @param request ModifyIPv6TranslatorAclAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyIPv6TranslatorAclAttributeResponse
 */
// Deprecated
func (client *Client) ModifyIPv6TranslatorAclAttributeWithOptions(request *ModifyIPv6TranslatorAclAttributeRequest, runtime *util.RuntimeOptions) (_result *ModifyIPv6TranslatorAclAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AclId)) {
		query["AclId"] = request.AclId
	}

	if !tea.BoolValue(util.IsUnset(request.AclName)) {
		query["AclName"] = request.AclName
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyIPv6TranslatorAclAttribute"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyIPv6TranslatorAclAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * @deprecated
 *
 * @param request ModifyIPv6TranslatorAclAttributeRequest
 * @return ModifyIPv6TranslatorAclAttributeResponse
 */
// Deprecated
func (client *Client) ModifyIPv6TranslatorAclAttribute(request *ModifyIPv6TranslatorAclAttributeRequest) (_result *ModifyIPv6TranslatorAclAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyIPv6TranslatorAclAttributeResponse{}
	_body, _err := client.ModifyIPv6TranslatorAclAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifyIPv6TranslatorAclListEntryWithOptions(request *ModifyIPv6TranslatorAclListEntryRequest, runtime *util.RuntimeOptions) (_result *ModifyIPv6TranslatorAclListEntryResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AclEntryComment)) {
		query["AclEntryComment"] = request.AclEntryComment
	}

	if !tea.BoolValue(util.IsUnset(request.AclEntryId)) {
		query["AclEntryId"] = request.AclEntryId
	}

	if !tea.BoolValue(util.IsUnset(request.AclId)) {
		query["AclId"] = request.AclId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyIPv6TranslatorAclListEntry"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyIPv6TranslatorAclListEntryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifyIPv6TranslatorAclListEntry(request *ModifyIPv6TranslatorAclListEntryRequest) (_result *ModifyIPv6TranslatorAclListEntryResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyIPv6TranslatorAclListEntryResponse{}
	_body, _err := client.ModifyIPv6TranslatorAclListEntryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifyIPv6TranslatorAttributeWithOptions(request *ModifyIPv6TranslatorAttributeRequest, runtime *util.RuntimeOptions) (_result *ModifyIPv6TranslatorAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.Ipv6TranslatorId)) {
		query["Ipv6TranslatorId"] = request.Ipv6TranslatorId
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyIPv6TranslatorAttribute"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyIPv6TranslatorAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifyIPv6TranslatorAttribute(request *ModifyIPv6TranslatorAttributeRequest) (_result *ModifyIPv6TranslatorAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyIPv6TranslatorAttributeResponse{}
	_body, _err := client.ModifyIPv6TranslatorAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifyIPv6TranslatorBandwidthWithOptions(request *ModifyIPv6TranslatorBandwidthRequest, runtime *util.RuntimeOptions) (_result *ModifyIPv6TranslatorBandwidthResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AutoPay)) {
		query["AutoPay"] = request.AutoPay
	}

	if !tea.BoolValue(util.IsUnset(request.Bandwidth)) {
		query["Bandwidth"] = request.Bandwidth
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Ipv6TranslatorId)) {
		query["Ipv6TranslatorId"] = request.Ipv6TranslatorId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyIPv6TranslatorBandwidth"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyIPv6TranslatorBandwidthResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifyIPv6TranslatorBandwidth(request *ModifyIPv6TranslatorBandwidthRequest) (_result *ModifyIPv6TranslatorBandwidthResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyIPv6TranslatorBandwidthResponse{}
	_body, _err := client.ModifyIPv6TranslatorBandwidthWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * @deprecated
 *
 * @param request ModifyIPv6TranslatorEntryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyIPv6TranslatorEntryResponse
 */
// Deprecated
func (client *Client) ModifyIPv6TranslatorEntryWithOptions(request *ModifyIPv6TranslatorEntryRequest, runtime *util.RuntimeOptions) (_result *ModifyIPv6TranslatorEntryResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AclId)) {
		query["AclId"] = request.AclId
	}

	if !tea.BoolValue(util.IsUnset(request.AclStatus)) {
		query["AclStatus"] = request.AclStatus
	}

	if !tea.BoolValue(util.IsUnset(request.AclType)) {
		query["AclType"] = request.AclType
	}

	if !tea.BoolValue(util.IsUnset(request.AllocateIpv6Port)) {
		query["AllocateIpv6Port"] = request.AllocateIpv6Port
	}

	if !tea.BoolValue(util.IsUnset(request.BackendIpv4Addr)) {
		query["BackendIpv4Addr"] = request.BackendIpv4Addr
	}

	if !tea.BoolValue(util.IsUnset(request.BackendIpv4Port)) {
		query["BackendIpv4Port"] = request.BackendIpv4Port
	}

	if !tea.BoolValue(util.IsUnset(request.EntryBandwidth)) {
		query["EntryBandwidth"] = request.EntryBandwidth
	}

	if !tea.BoolValue(util.IsUnset(request.EntryDescription)) {
		query["EntryDescription"] = request.EntryDescription
	}

	if !tea.BoolValue(util.IsUnset(request.EntryName)) {
		query["EntryName"] = request.EntryName
	}

	if !tea.BoolValue(util.IsUnset(request.Ipv6TranslatorEntryId)) {
		query["Ipv6TranslatorEntryId"] = request.Ipv6TranslatorEntryId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.TransProtocol)) {
		query["TransProtocol"] = request.TransProtocol
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyIPv6TranslatorEntry"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyIPv6TranslatorEntryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * @deprecated
 *
 * @param request ModifyIPv6TranslatorEntryRequest
 * @return ModifyIPv6TranslatorEntryResponse
 */
// Deprecated
func (client *Client) ModifyIPv6TranslatorEntry(request *ModifyIPv6TranslatorEntryRequest) (_result *ModifyIPv6TranslatorEntryResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyIPv6TranslatorEntryResponse{}
	_body, _err := client.ModifyIPv6TranslatorEntryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifyIpv6AddressAttributeWithOptions(request *ModifyIpv6AddressAttributeRequest, runtime *util.RuntimeOptions) (_result *ModifyIpv6AddressAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.Ipv6AddressId)) {
		query["Ipv6AddressId"] = request.Ipv6AddressId
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyIpv6AddressAttribute"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyIpv6AddressAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifyIpv6AddressAttribute(request *ModifyIpv6AddressAttributeRequest) (_result *ModifyIpv6AddressAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyIpv6AddressAttributeResponse{}
	_body, _err := client.ModifyIpv6AddressAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifyIpv6GatewayAttributeWithOptions(request *ModifyIpv6GatewayAttributeRequest, runtime *util.RuntimeOptions) (_result *ModifyIpv6GatewayAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.Ipv6GatewayId)) {
		query["Ipv6GatewayId"] = request.Ipv6GatewayId
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyIpv6GatewayAttribute"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyIpv6GatewayAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifyIpv6GatewayAttribute(request *ModifyIpv6GatewayAttributeRequest) (_result *ModifyIpv6GatewayAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyIpv6GatewayAttributeResponse{}
	_body, _err := client.ModifyIpv6GatewayAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You cannot repeatedly call the **ModifyIpv6GatewaySpec** operation to change the specification of an IPv6 gateway within the specified period of time.
 *
 * @param request ModifyIpv6GatewaySpecRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyIpv6GatewaySpecResponse
 */
func (client *Client) ModifyIpv6GatewaySpecWithOptions(request *ModifyIpv6GatewaySpecRequest, runtime *util.RuntimeOptions) (_result *ModifyIpv6GatewaySpecResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Ipv6GatewayId)) {
		query["Ipv6GatewayId"] = request.Ipv6GatewayId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Spec)) {
		query["Spec"] = request.Spec
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyIpv6GatewaySpec"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyIpv6GatewaySpecResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You cannot repeatedly call the **ModifyIpv6GatewaySpec** operation to change the specification of an IPv6 gateway within the specified period of time.
 *
 * @param request ModifyIpv6GatewaySpecRequest
 * @return ModifyIpv6GatewaySpecResponse
 */
func (client *Client) ModifyIpv6GatewaySpec(request *ModifyIpv6GatewaySpecRequest) (_result *ModifyIpv6GatewaySpecResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyIpv6GatewaySpecResponse{}
	_body, _err := client.ModifyIpv6GatewaySpecWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You cannot call the **ModifyIpv6InternetBandwidth** operation to modify the Internet bandwidth value of an IPv6 CIDR block at the same time.
 *
 * @param request ModifyIpv6InternetBandwidthRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyIpv6InternetBandwidthResponse
 */
func (client *Client) ModifyIpv6InternetBandwidthWithOptions(request *ModifyIpv6InternetBandwidthRequest, runtime *util.RuntimeOptions) (_result *ModifyIpv6InternetBandwidthResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Bandwidth)) {
		query["Bandwidth"] = request.Bandwidth
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Ipv6AddressId)) {
		query["Ipv6AddressId"] = request.Ipv6AddressId
	}

	if !tea.BoolValue(util.IsUnset(request.Ipv6InternetBandwidthId)) {
		query["Ipv6InternetBandwidthId"] = request.Ipv6InternetBandwidthId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyIpv6InternetBandwidth"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyIpv6InternetBandwidthResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You cannot call the **ModifyIpv6InternetBandwidth** operation to modify the Internet bandwidth value of an IPv6 CIDR block at the same time.
 *
 * @param request ModifyIpv6InternetBandwidthRequest
 * @return ModifyIpv6InternetBandwidthResponse
 */
func (client *Client) ModifyIpv6InternetBandwidth(request *ModifyIpv6InternetBandwidthRequest) (_result *ModifyIpv6InternetBandwidthResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyIpv6InternetBandwidthResponse{}
	_body, _err := client.ModifyIpv6InternetBandwidthWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call this operation to query an Internet NAT gateway or a virtual private cloud (VPC) NAT gateway. The term NAT gateway in this topic refers to both types of NAT gateway.
 *
 * @param request ModifyNatGatewayAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyNatGatewayAttributeResponse
 */
func (client *Client) ModifyNatGatewayAttributeWithOptions(request *ModifyNatGatewayAttributeRequest, runtime *util.RuntimeOptions) (_result *ModifyNatGatewayAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.EipBindMode)) {
		query["EipBindMode"] = request.EipBindMode
	}

	if !tea.BoolValue(util.IsUnset(request.IcmpReplyEnabled)) {
		query["IcmpReplyEnabled"] = request.IcmpReplyEnabled
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.NatGatewayId)) {
		query["NatGatewayId"] = request.NatGatewayId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyNatGatewayAttribute"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyNatGatewayAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call this operation to query an Internet NAT gateway or a virtual private cloud (VPC) NAT gateway. The term NAT gateway in this topic refers to both types of NAT gateway.
 *
 * @param request ModifyNatGatewayAttributeRequest
 * @return ModifyNatGatewayAttributeResponse
 */
func (client *Client) ModifyNatGatewayAttribute(request *ModifyNatGatewayAttributeRequest) (_result *ModifyNatGatewayAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyNatGatewayAttributeResponse{}
	_body, _err := client.ModifyNatGatewayAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * - You cannot call this operation to downgrade a subscription Internet NAT gateway. You can downgrade a subscription Internet NAT gateway only in the console.
 * - When you call this operation to upgrade a subscription Internet NAT gateway, an order is generated. After you complete the payment in the order center, the Internet NAT gateway is upgraded.
 * - **ModifyNatGatewaySpec** is an asynchronous operation. After you make a request, the ID of the request is returned but the Internet NAT gateway is not upgraded. The system upgrades the NAT gateway in the background. You can call the [DescribeNatGateways](/help/en/virtual-private-cloud/latest/describenatgateways) operation to query the status of an Internet NAT gateway.    - If an Internet NAT gateway is in the **Modifying** state, the NAT gateway is being upgraded. In this case, you can only query the NAT gateway but cannot perform other operations.
 *   - If an Internet NAT gateway is in the **Available** state, the Internet NAT gateway is upgraded.
 * - You cannot repeatedly call the **ModifyNatGatewaySpec** operation to resize a pay-by-specification NAT gateway.
 * Internet NAT gateways are available in different sizes. The size of an Internet NAT gateway determines the SNAT performance, which includes the maximum number of connections and the number of new connections per second. However, the size of a NAT gateway does not affect the data throughput. The following table describes the correlations between different sizes of Internet NAT gateways and SNAT performance metrics.
 * | Size | Maximum number of connections | Number of new connections per second |
 * | ---- | ----------------------------- | ------------------------------------ |
 * | Small | 10,000 | 1,000 |
 * | Medium | 50,000 | 5,000 |
 * | Large | 200,000 | 10,000 |
 *
 * @param request ModifyNatGatewaySpecRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyNatGatewaySpecResponse
 */
func (client *Client) ModifyNatGatewaySpecWithOptions(request *ModifyNatGatewaySpecRequest, runtime *util.RuntimeOptions) (_result *ModifyNatGatewaySpecResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AutoPay)) {
		query["AutoPay"] = request.AutoPay
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.NatGatewayId)) {
		query["NatGatewayId"] = request.NatGatewayId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Spec)) {
		query["Spec"] = request.Spec
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyNatGatewaySpec"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyNatGatewaySpecResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * - You cannot call this operation to downgrade a subscription Internet NAT gateway. You can downgrade a subscription Internet NAT gateway only in the console.
 * - When you call this operation to upgrade a subscription Internet NAT gateway, an order is generated. After you complete the payment in the order center, the Internet NAT gateway is upgraded.
 * - **ModifyNatGatewaySpec** is an asynchronous operation. After you make a request, the ID of the request is returned but the Internet NAT gateway is not upgraded. The system upgrades the NAT gateway in the background. You can call the [DescribeNatGateways](/help/en/virtual-private-cloud/latest/describenatgateways) operation to query the status of an Internet NAT gateway.    - If an Internet NAT gateway is in the **Modifying** state, the NAT gateway is being upgraded. In this case, you can only query the NAT gateway but cannot perform other operations.
 *   - If an Internet NAT gateway is in the **Available** state, the Internet NAT gateway is upgraded.
 * - You cannot repeatedly call the **ModifyNatGatewaySpec** operation to resize a pay-by-specification NAT gateway.
 * Internet NAT gateways are available in different sizes. The size of an Internet NAT gateway determines the SNAT performance, which includes the maximum number of connections and the number of new connections per second. However, the size of a NAT gateway does not affect the data throughput. The following table describes the correlations between different sizes of Internet NAT gateways and SNAT performance metrics.
 * | Size | Maximum number of connections | Number of new connections per second |
 * | ---- | ----------------------------- | ------------------------------------ |
 * | Small | 10,000 | 1,000 |
 * | Medium | 50,000 | 5,000 |
 * | Large | 200,000 | 10,000 |
 *
 * @param request ModifyNatGatewaySpecRequest
 * @return ModifyNatGatewaySpecResponse
 */
func (client *Client) ModifyNatGatewaySpec(request *ModifyNatGatewaySpecRequest) (_result *ModifyNatGatewaySpecResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyNatGatewaySpecResponse{}
	_body, _err := client.ModifyNatGatewaySpecWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You cannot repeatedly call the **ModifyNatIpAttribute** operation to modify the name and description of a NAT IP address within the specified period of time.
 *
 * @param request ModifyNatIpAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyNatIpAttributeResponse
 */
func (client *Client) ModifyNatIpAttributeWithOptions(request *ModifyNatIpAttributeRequest, runtime *util.RuntimeOptions) (_result *ModifyNatIpAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.NatIpDescription)) {
		query["NatIpDescription"] = request.NatIpDescription
	}

	if !tea.BoolValue(util.IsUnset(request.NatIpId)) {
		query["NatIpId"] = request.NatIpId
	}

	if !tea.BoolValue(util.IsUnset(request.NatIpName)) {
		query["NatIpName"] = request.NatIpName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyNatIpAttribute"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyNatIpAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You cannot repeatedly call the **ModifyNatIpAttribute** operation to modify the name and description of a NAT IP address within the specified period of time.
 *
 * @param request ModifyNatIpAttributeRequest
 * @return ModifyNatIpAttributeResponse
 */
func (client *Client) ModifyNatIpAttribute(request *ModifyNatIpAttributeRequest) (_result *ModifyNatIpAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyNatIpAttributeResponse{}
	_body, _err := client.ModifyNatIpAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifyNatIpCidrAttributeWithOptions(request *ModifyNatIpCidrAttributeRequest, runtime *util.RuntimeOptions) (_result *ModifyNatIpCidrAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.NatGatewayId)) {
		query["NatGatewayId"] = request.NatGatewayId
	}

	if !tea.BoolValue(util.IsUnset(request.NatIpCidr)) {
		query["NatIpCidr"] = request.NatIpCidr
	}

	if !tea.BoolValue(util.IsUnset(request.NatIpCidrDescription)) {
		query["NatIpCidrDescription"] = request.NatIpCidrDescription
	}

	if !tea.BoolValue(util.IsUnset(request.NatIpCidrName)) {
		query["NatIpCidrName"] = request.NatIpCidrName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyNatIpCidrAttribute"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyNatIpCidrAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifyNatIpCidrAttribute(request *ModifyNatIpCidrAttributeRequest) (_result *ModifyNatIpCidrAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyNatIpCidrAttributeResponse{}
	_body, _err := client.ModifyNatIpCidrAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifyNetworkAclAttributesWithOptions(request *ModifyNetworkAclAttributesRequest, runtime *util.RuntimeOptions) (_result *ModifyNetworkAclAttributesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.NetworkAclId)) {
		query["NetworkAclId"] = request.NetworkAclId
	}

	if !tea.BoolValue(util.IsUnset(request.NetworkAclName)) {
		query["NetworkAclName"] = request.NetworkAclName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyNetworkAclAttributes"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyNetworkAclAttributesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifyNetworkAclAttributes(request *ModifyNetworkAclAttributesRequest) (_result *ModifyNetworkAclAttributesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyNetworkAclAttributesResponse{}
	_body, _err := client.ModifyNetworkAclAttributesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * When you call this operation, take note of the following limits:
 * *   If an Express Connect circuit is in the **Initial**, **Enabled**, or **Rejected** state, you can modify the specifications of the Express Connect circuit and the ID of the redundant circuit.
 * *   If an Express Connect circuit is in the **Canceled**, **Allocating**, **AllocationFailed**, or **Terminated** state, you cannot modify the specifications of the Express Connect circuit.
 * *   After you modify the specifications of an Express Connect circuit that is in the **Rejected** state, the Express Connect circuit enters the **Initial** state.
 *
 * @param request ModifyPhysicalConnectionAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyPhysicalConnectionAttributeResponse
 */
func (client *Client) ModifyPhysicalConnectionAttributeWithOptions(request *ModifyPhysicalConnectionAttributeRequest, runtime *util.RuntimeOptions) (_result *ModifyPhysicalConnectionAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CircuitCode)) {
		query["CircuitCode"] = request.CircuitCode
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.LineOperator)) {
		query["LineOperator"] = request.LineOperator
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PeerLocation)) {
		query["PeerLocation"] = request.PeerLocation
	}

	if !tea.BoolValue(util.IsUnset(request.PhysicalConnectionId)) {
		query["PhysicalConnectionId"] = request.PhysicalConnectionId
	}

	if !tea.BoolValue(util.IsUnset(request.PortType)) {
		query["PortType"] = request.PortType
	}

	if !tea.BoolValue(util.IsUnset(request.RedundantPhysicalConnectionId)) {
		query["RedundantPhysicalConnectionId"] = request.RedundantPhysicalConnectionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Bandwidth)) {
		query["bandwidth"] = request.Bandwidth
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyPhysicalConnectionAttribute"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyPhysicalConnectionAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * When you call this operation, take note of the following limits:
 * *   If an Express Connect circuit is in the **Initial**, **Enabled**, or **Rejected** state, you can modify the specifications of the Express Connect circuit and the ID of the redundant circuit.
 * *   If an Express Connect circuit is in the **Canceled**, **Allocating**, **AllocationFailed**, or **Terminated** state, you cannot modify the specifications of the Express Connect circuit.
 * *   After you modify the specifications of an Express Connect circuit that is in the **Rejected** state, the Express Connect circuit enters the **Initial** state.
 *
 * @param request ModifyPhysicalConnectionAttributeRequest
 * @return ModifyPhysicalConnectionAttributeResponse
 */
func (client *Client) ModifyPhysicalConnectionAttribute(request *ModifyPhysicalConnectionAttributeRequest) (_result *ModifyPhysicalConnectionAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyPhysicalConnectionAttributeResponse{}
	_body, _err := client.ModifyPhysicalConnectionAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You cannot repeatedly call the **ModifyRouteEntry** operation to modify the name and description of a custom route within the specified period of time.
 *
 * @param request ModifyRouteEntryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyRouteEntryResponse
 */
func (client *Client) ModifyRouteEntryWithOptions(request *ModifyRouteEntryRequest, runtime *util.RuntimeOptions) (_result *ModifyRouteEntryResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RouteEntryId)) {
		query["RouteEntryId"] = request.RouteEntryId
	}

	if !tea.BoolValue(util.IsUnset(request.RouteEntryName)) {
		query["RouteEntryName"] = request.RouteEntryName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyRouteEntry"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyRouteEntryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You cannot repeatedly call the **ModifyRouteEntry** operation to modify the name and description of a custom route within the specified period of time.
 *
 * @param request ModifyRouteEntryRequest
 * @return ModifyRouteEntryResponse
 */
func (client *Client) ModifyRouteEntry(request *ModifyRouteEntryRequest) (_result *ModifyRouteEntryResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyRouteEntryResponse{}
	_body, _err := client.ModifyRouteEntryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You cannot repeatedly call the **ModifyRouteTableAttributes** operation to modify the name and description of a route table within the specified period of time.
 *
 * @param request ModifyRouteTableAttributesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyRouteTableAttributesResponse
 */
func (client *Client) ModifyRouteTableAttributesWithOptions(request *ModifyRouteTableAttributesRequest, runtime *util.RuntimeOptions) (_result *ModifyRouteTableAttributesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RouteTableId)) {
		query["RouteTableId"] = request.RouteTableId
	}

	if !tea.BoolValue(util.IsUnset(request.RouteTableName)) {
		query["RouteTableName"] = request.RouteTableName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyRouteTableAttributes"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyRouteTableAttributesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You cannot repeatedly call the **ModifyRouteTableAttributes** operation to modify the name and description of a route table within the specified period of time.
 *
 * @param request ModifyRouteTableAttributesRequest
 * @return ModifyRouteTableAttributesResponse
 */
func (client *Client) ModifyRouteTableAttributes(request *ModifyRouteTableAttributesRequest) (_result *ModifyRouteTableAttributesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyRouteTableAttributesResponse{}
	_body, _err := client.ModifyRouteTableAttributesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifyRouterInterfaceAttributeWithOptions(request *ModifyRouterInterfaceAttributeRequest, runtime *util.RuntimeOptions) (_result *ModifyRouterInterfaceAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeleteHealthCheckIp)) {
		query["DeleteHealthCheckIp"] = request.DeleteHealthCheckIp
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.HcRate)) {
		query["HcRate"] = request.HcRate
	}

	if !tea.BoolValue(util.IsUnset(request.HcThreshold)) {
		query["HcThreshold"] = request.HcThreshold
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckSourceIp)) {
		query["HealthCheckSourceIp"] = request.HealthCheckSourceIp
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckTargetIp)) {
		query["HealthCheckTargetIp"] = request.HealthCheckTargetIp
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.OppositeInterfaceId)) {
		query["OppositeInterfaceId"] = request.OppositeInterfaceId
	}

	if !tea.BoolValue(util.IsUnset(request.OppositeInterfaceOwnerId)) {
		query["OppositeInterfaceOwnerId"] = request.OppositeInterfaceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.OppositeRouterId)) {
		query["OppositeRouterId"] = request.OppositeRouterId
	}

	if !tea.BoolValue(util.IsUnset(request.OppositeRouterType)) {
		query["OppositeRouterType"] = request.OppositeRouterType
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RouterInterfaceId)) {
		query["RouterInterfaceId"] = request.RouterInterfaceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyRouterInterfaceAttribute"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyRouterInterfaceAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifyRouterInterfaceAttribute(request *ModifyRouterInterfaceAttributeRequest) (_result *ModifyRouterInterfaceAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyRouterInterfaceAttributeResponse{}
	_body, _err := client.ModifyRouterInterfaceAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * After you call this operation, the router interface enters the **Activating** state. After the router interface is activated, the router interface enters the **Active** state.
 * >  You cannot modify the specifications of a router interface that has overdue payments.
 *
 * @param request ModifyRouterInterfaceSpecRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyRouterInterfaceSpecResponse
 */
func (client *Client) ModifyRouterInterfaceSpecWithOptions(request *ModifyRouterInterfaceSpecRequest, runtime *util.RuntimeOptions) (_result *ModifyRouterInterfaceSpecResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RouterInterfaceId)) {
		query["RouterInterfaceId"] = request.RouterInterfaceId
	}

	if !tea.BoolValue(util.IsUnset(request.Spec)) {
		query["Spec"] = request.Spec
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyRouterInterfaceSpec"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyRouterInterfaceSpecResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * After you call this operation, the router interface enters the **Activating** state. After the router interface is activated, the router interface enters the **Active** state.
 * >  You cannot modify the specifications of a router interface that has overdue payments.
 *
 * @param request ModifyRouterInterfaceSpecRequest
 * @return ModifyRouterInterfaceSpecResponse
 */
func (client *Client) ModifyRouterInterfaceSpec(request *ModifyRouterInterfaceSpecRequest) (_result *ModifyRouterInterfaceSpecResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyRouterInterfaceSpecResponse{}
	_body, _err := client.ModifyRouterInterfaceSpecWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * **ModifySnatEntry** is an asynchronous operation. After you make a request, the ID of the request is returned but the specified SNAT entry is not modified. The system modifies the entry in the background. You can call the [DescribeSnatTableEntries](~~42677~~) operation to query the status of a SNAT entry.
 * *   **Pending**: indicates that the system is modifying the SNAT entry. You can only query the status of the SNAT entry, but cannot perform other operations.
 * *   **Available**: indicates that the SNAT entry is modified.
 * >  **Pending**: indicates that you cannot modify the SNAT entry in the SNAT table.
 * You cannot repeatedly call the **ModifySnatEntry** operation to modify an SNAT entry within the specified period of time.
 *
 * @param request ModifySnatEntryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifySnatEntryResponse
 */
func (client *Client) ModifySnatEntryWithOptions(request *ModifySnatEntryRequest, runtime *util.RuntimeOptions) (_result *ModifySnatEntryResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SnatEntryId)) {
		query["SnatEntryId"] = request.SnatEntryId
	}

	if !tea.BoolValue(util.IsUnset(request.SnatEntryName)) {
		query["SnatEntryName"] = request.SnatEntryName
	}

	if !tea.BoolValue(util.IsUnset(request.SnatIp)) {
		query["SnatIp"] = request.SnatIp
	}

	if !tea.BoolValue(util.IsUnset(request.SnatTableId)) {
		query["SnatTableId"] = request.SnatTableId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifySnatEntry"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifySnatEntryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * **ModifySnatEntry** is an asynchronous operation. After you make a request, the ID of the request is returned but the specified SNAT entry is not modified. The system modifies the entry in the background. You can call the [DescribeSnatTableEntries](~~42677~~) operation to query the status of a SNAT entry.
 * *   **Pending**: indicates that the system is modifying the SNAT entry. You can only query the status of the SNAT entry, but cannot perform other operations.
 * *   **Available**: indicates that the SNAT entry is modified.
 * >  **Pending**: indicates that you cannot modify the SNAT entry in the SNAT table.
 * You cannot repeatedly call the **ModifySnatEntry** operation to modify an SNAT entry within the specified period of time.
 *
 * @param request ModifySnatEntryRequest
 * @return ModifySnatEntryResponse
 */
func (client *Client) ModifySnatEntry(request *ModifySnatEntryRequest) (_result *ModifySnatEntryResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifySnatEntryResponse{}
	_body, _err := client.ModifySnatEntryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifySslVpnClientCertWithOptions(request *ModifySslVpnClientCertRequest, runtime *util.RuntimeOptions) (_result *ModifySslVpnClientCertResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SslVpnClientCertId)) {
		query["SslVpnClientCertId"] = request.SslVpnClientCertId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifySslVpnClientCert"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifySslVpnClientCertResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifySslVpnClientCert(request *ModifySslVpnClientCertRequest) (_result *ModifySslVpnClientCertResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifySslVpnClientCertResponse{}
	_body, _err := client.ModifySslVpnClientCertWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   If you modify only the **name** of the SSL server, the operation is synchronous. If you also modify other configurations, the operation is asynchronous.
 * *   When **ModifySslVpnServer** is an asynchronous operation, the system returns the request ID but the operation is still being performed in the system background. You can call [DescribeVpnGateway](~~73720~~) to query the status of a VPN gateway.
 *     *   If a VPN gateway is in the **updating** state, the configurations of the SSL server are being modified.
 *     *   If a VPN gateway is in the **active** state, the configurations of the SSL server have been modified.
 * *   You cannot repeatedly call **ModifySslVpnServer** to modify the configurations of an SSL server within the specified period of time.
 *
 * @param request ModifySslVpnServerRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifySslVpnServerResponse
 */
func (client *Client) ModifySslVpnServerWithOptions(request *ModifySslVpnServerRequest, runtime *util.RuntimeOptions) (_result *ModifySslVpnServerResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Cipher)) {
		query["Cipher"] = request.Cipher
	}

	if !tea.BoolValue(util.IsUnset(request.ClientIpPool)) {
		query["ClientIpPool"] = request.ClientIpPool
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Compress)) {
		query["Compress"] = request.Compress
	}

	if !tea.BoolValue(util.IsUnset(request.EnableMultiFactorAuth)) {
		query["EnableMultiFactorAuth"] = request.EnableMultiFactorAuth
	}

	if !tea.BoolValue(util.IsUnset(request.IDaaSInstanceId)) {
		query["IDaaSInstanceId"] = request.IDaaSInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.IDaaSRegionId)) {
		query["IDaaSRegionId"] = request.IDaaSRegionId
	}

	if !tea.BoolValue(util.IsUnset(request.LocalSubnet)) {
		query["LocalSubnet"] = request.LocalSubnet
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Port)) {
		query["Port"] = request.Port
	}

	if !tea.BoolValue(util.IsUnset(request.Proto)) {
		query["Proto"] = request.Proto
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SslVpnServerId)) {
		query["SslVpnServerId"] = request.SslVpnServerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifySslVpnServer"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifySslVpnServerResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   If you modify only the **name** of the SSL server, the operation is synchronous. If you also modify other configurations, the operation is asynchronous.
 * *   When **ModifySslVpnServer** is an asynchronous operation, the system returns the request ID but the operation is still being performed in the system background. You can call [DescribeVpnGateway](~~73720~~) to query the status of a VPN gateway.
 *     *   If a VPN gateway is in the **updating** state, the configurations of the SSL server are being modified.
 *     *   If a VPN gateway is in the **active** state, the configurations of the SSL server have been modified.
 * *   You cannot repeatedly call **ModifySslVpnServer** to modify the configurations of an SSL server within the specified period of time.
 *
 * @param request ModifySslVpnServerRequest
 * @return ModifySslVpnServerResponse
 */
func (client *Client) ModifySslVpnServer(request *ModifySslVpnServerRequest) (_result *ModifySslVpnServerResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifySslVpnServerResponse{}
	_body, _err := client.ModifySslVpnServerWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You cannot repeatedly call the **ModifyVRouterAttribute** operation to modify the name and description of a vRouter within the specified period of time.
 *
 * @param request ModifyVRouterAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyVRouterAttributeResponse
 */
func (client *Client) ModifyVRouterAttributeWithOptions(request *ModifyVRouterAttributeRequest, runtime *util.RuntimeOptions) (_result *ModifyVRouterAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.VRouterId)) {
		query["VRouterId"] = request.VRouterId
	}

	if !tea.BoolValue(util.IsUnset(request.VRouterName)) {
		query["VRouterName"] = request.VRouterName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyVRouterAttribute"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyVRouterAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You cannot repeatedly call the **ModifyVRouterAttribute** operation to modify the name and description of a vRouter within the specified period of time.
 *
 * @param request ModifyVRouterAttributeRequest
 * @return ModifyVRouterAttributeResponse
 */
func (client *Client) ModifyVRouterAttribute(request *ModifyVRouterAttributeRequest) (_result *ModifyVRouterAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyVRouterAttributeResponse{}
	_body, _err := client.ModifyVRouterAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   The **ModifyVSwitchAttribute** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeVSwitchAttributes](~~94567~~) operation to query the status of a vSwitch:
 *     *   If the vSwitch is in the **Pending** state, the vSwitch is being modified.
 *     *   If the vSwitch is in the **Available** state, the vSwitch is available.
 * *   You cannot repeatedly call the **ModifyVSwitchAttribute** operation to modify the name and description of a vSwitch within the specified period of time.
 *
 * @param request ModifyVSwitchAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyVSwitchAttributeResponse
 */
func (client *Client) ModifyVSwitchAttributeWithOptions(request *ModifyVSwitchAttributeRequest, runtime *util.RuntimeOptions) (_result *ModifyVSwitchAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.EnableIPv6)) {
		query["EnableIPv6"] = request.EnableIPv6
	}

	if !tea.BoolValue(util.IsUnset(request.Ipv6CidrBlock)) {
		query["Ipv6CidrBlock"] = request.Ipv6CidrBlock
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.VSwitchId)) {
		query["VSwitchId"] = request.VSwitchId
	}

	if !tea.BoolValue(util.IsUnset(request.VSwitchName)) {
		query["VSwitchName"] = request.VSwitchName
	}

	if !tea.BoolValue(util.IsUnset(request.VpcIpv6CidrBlock)) {
		query["VpcIpv6CidrBlock"] = request.VpcIpv6CidrBlock
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyVSwitchAttribute"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyVSwitchAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   The **ModifyVSwitchAttribute** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeVSwitchAttributes](~~94567~~) operation to query the status of a vSwitch:
 *     *   If the vSwitch is in the **Pending** state, the vSwitch is being modified.
 *     *   If the vSwitch is in the **Available** state, the vSwitch is available.
 * *   You cannot repeatedly call the **ModifyVSwitchAttribute** operation to modify the name and description of a vSwitch within the specified period of time.
 *
 * @param request ModifyVSwitchAttributeRequest
 * @return ModifyVSwitchAttributeResponse
 */
func (client *Client) ModifyVSwitchAttribute(request *ModifyVSwitchAttributeRequest) (_result *ModifyVSwitchAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyVSwitchAttributeResponse{}
	_body, _err := client.ModifyVSwitchAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   **ModifyVcoRouteEntryWeight** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnConnection](~~53046~~) operation to query the status of the associated IPsec-VPN connection and determine whether the weight of the specified destination-based route is modified.
 *     *   If the IPsec-VPN connection is in the **updating** state, the weight of the destination-based route is being modified.
 *     *   If the IPsec-VPN connection is in the **attached** state, the weight of the destination-based route is modified.
 * *   You cannot repeatedly call the **ModifyVcoRouteEntryWeight** operation for the same IPsec-VPN connection within the specified period of time.
 *
 * @param request ModifyVcoRouteEntryWeightRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyVcoRouteEntryWeightResponse
 */
func (client *Client) ModifyVcoRouteEntryWeightWithOptions(request *ModifyVcoRouteEntryWeightRequest, runtime *util.RuntimeOptions) (_result *ModifyVcoRouteEntryWeightResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.NewWeight)) {
		query["NewWeight"] = request.NewWeight
	}

	if !tea.BoolValue(util.IsUnset(request.NextHop)) {
		query["NextHop"] = request.NextHop
	}

	if !tea.BoolValue(util.IsUnset(request.OverlayMode)) {
		query["OverlayMode"] = request.OverlayMode
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RouteDest)) {
		query["RouteDest"] = request.RouteDest
	}

	if !tea.BoolValue(util.IsUnset(request.VpnConnectionId)) {
		query["VpnConnectionId"] = request.VpnConnectionId
	}

	if !tea.BoolValue(util.IsUnset(request.Weight)) {
		query["Weight"] = request.Weight
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyVcoRouteEntryWeight"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyVcoRouteEntryWeightResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   **ModifyVcoRouteEntryWeight** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnConnection](~~53046~~) operation to query the status of the associated IPsec-VPN connection and determine whether the weight of the specified destination-based route is modified.
 *     *   If the IPsec-VPN connection is in the **updating** state, the weight of the destination-based route is being modified.
 *     *   If the IPsec-VPN connection is in the **attached** state, the weight of the destination-based route is modified.
 * *   You cannot repeatedly call the **ModifyVcoRouteEntryWeight** operation for the same IPsec-VPN connection within the specified period of time.
 *
 * @param request ModifyVcoRouteEntryWeightRequest
 * @return ModifyVcoRouteEntryWeightResponse
 */
func (client *Client) ModifyVcoRouteEntryWeight(request *ModifyVcoRouteEntryWeightRequest) (_result *ModifyVcoRouteEntryWeightResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyVcoRouteEntryWeightResponse{}
	_body, _err := client.ModifyVcoRouteEntryWeightWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   Only the owner of an Express Connect circuit can modify the **VlanId** parameter.
 * *   One VLAN ID of an Express Connect circuit cannot be used by two VBRs at the same time.
 * *   The VLAN ID of a VBR in the **Terminated** state is reserved for seven days and cannot be used by other VBRs. The VLAN ID can be used by other VBRs after 7 days.
 * *   You cannot set **LocalGatewayIp**, **PeerGatewayIp**, or **PeeringSubnetMask** for VBRs that do not belong to your Alibaba Cloud account.
 * *   Set **PeeringSubnetMask** to a subnet mask with 24 to 30 bits in length (255.255.255.0～255.255.255.252).
 * *   Set **LocalGatewayIp** and **PeerGatewayIp** to IP addresses that belong to the same CIDR block. For example, you can set LocalGatewayIp to 192.168.XX.XX, PeerGatewayIp to 192.168.XX.XX, and PeeringSubnetMask to 255.255.255.248.
 *
 * @param request ModifyVirtualBorderRouterAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyVirtualBorderRouterAttributeResponse
 */
func (client *Client) ModifyVirtualBorderRouterAttributeWithOptions(request *ModifyVirtualBorderRouterAttributeRequest, runtime *util.RuntimeOptions) (_result *ModifyVirtualBorderRouterAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AssociatedPhysicalConnections)) {
		query["AssociatedPhysicalConnections"] = request.AssociatedPhysicalConnections
	}

	if !tea.BoolValue(util.IsUnset(request.Bandwidth)) {
		query["Bandwidth"] = request.Bandwidth
	}

	if !tea.BoolValue(util.IsUnset(request.CircuitCode)) {
		query["CircuitCode"] = request.CircuitCode
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.DetectMultiplier)) {
		query["DetectMultiplier"] = request.DetectMultiplier
	}

	if !tea.BoolValue(util.IsUnset(request.EnableIpv6)) {
		query["EnableIpv6"] = request.EnableIpv6
	}

	if !tea.BoolValue(util.IsUnset(request.LocalGatewayIp)) {
		query["LocalGatewayIp"] = request.LocalGatewayIp
	}

	if !tea.BoolValue(util.IsUnset(request.LocalIpv6GatewayIp)) {
		query["LocalIpv6GatewayIp"] = request.LocalIpv6GatewayIp
	}

	if !tea.BoolValue(util.IsUnset(request.MinRxInterval)) {
		query["MinRxInterval"] = request.MinRxInterval
	}

	if !tea.BoolValue(util.IsUnset(request.MinTxInterval)) {
		query["MinTxInterval"] = request.MinTxInterval
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PeerGatewayIp)) {
		query["PeerGatewayIp"] = request.PeerGatewayIp
	}

	if !tea.BoolValue(util.IsUnset(request.PeerIpv6GatewayIp)) {
		query["PeerIpv6GatewayIp"] = request.PeerIpv6GatewayIp
	}

	if !tea.BoolValue(util.IsUnset(request.PeeringIpv6SubnetMask)) {
		query["PeeringIpv6SubnetMask"] = request.PeeringIpv6SubnetMask
	}

	if !tea.BoolValue(util.IsUnset(request.PeeringSubnetMask)) {
		query["PeeringSubnetMask"] = request.PeeringSubnetMask
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.VbrId)) {
		query["VbrId"] = request.VbrId
	}

	if !tea.BoolValue(util.IsUnset(request.VlanId)) {
		query["VlanId"] = request.VlanId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyVirtualBorderRouterAttribute"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyVirtualBorderRouterAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   Only the owner of an Express Connect circuit can modify the **VlanId** parameter.
 * *   One VLAN ID of an Express Connect circuit cannot be used by two VBRs at the same time.
 * *   The VLAN ID of a VBR in the **Terminated** state is reserved for seven days and cannot be used by other VBRs. The VLAN ID can be used by other VBRs after 7 days.
 * *   You cannot set **LocalGatewayIp**, **PeerGatewayIp**, or **PeeringSubnetMask** for VBRs that do not belong to your Alibaba Cloud account.
 * *   Set **PeeringSubnetMask** to a subnet mask with 24 to 30 bits in length (255.255.255.0～255.255.255.252).
 * *   Set **LocalGatewayIp** and **PeerGatewayIp** to IP addresses that belong to the same CIDR block. For example, you can set LocalGatewayIp to 192.168.XX.XX, PeerGatewayIp to 192.168.XX.XX, and PeeringSubnetMask to 255.255.255.248.
 *
 * @param request ModifyVirtualBorderRouterAttributeRequest
 * @return ModifyVirtualBorderRouterAttributeResponse
 */
func (client *Client) ModifyVirtualBorderRouterAttribute(request *ModifyVirtualBorderRouterAttributeRequest) (_result *ModifyVirtualBorderRouterAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyVirtualBorderRouterAttributeResponse{}
	_body, _err := client.ModifyVirtualBorderRouterAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You cannot repeatedly call the **ModifyVpcAttribute** operation to modify the name and description of a VPC within the specified period of time.
 *
 * @param request ModifyVpcAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyVpcAttributeResponse
 */
func (client *Client) ModifyVpcAttributeWithOptions(request *ModifyVpcAttributeRequest, runtime *util.RuntimeOptions) (_result *ModifyVpcAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CidrBlock)) {
		query["CidrBlock"] = request.CidrBlock
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.EnableIPv6)) {
		query["EnableIPv6"] = request.EnableIPv6
	}

	if !tea.BoolValue(util.IsUnset(request.Ipv6CidrBlock)) {
		query["Ipv6CidrBlock"] = request.Ipv6CidrBlock
	}

	if !tea.BoolValue(util.IsUnset(request.Ipv6Isp)) {
		query["Ipv6Isp"] = request.Ipv6Isp
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.VpcId)) {
		query["VpcId"] = request.VpcId
	}

	if !tea.BoolValue(util.IsUnset(request.VpcName)) {
		query["VpcName"] = request.VpcName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyVpcAttribute"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyVpcAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You cannot repeatedly call the **ModifyVpcAttribute** operation to modify the name and description of a VPC within the specified period of time.
 *
 * @param request ModifyVpcAttributeRequest
 * @return ModifyVpcAttributeResponse
 */
func (client *Client) ModifyVpcAttribute(request *ModifyVpcAttributeRequest) (_result *ModifyVpcAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyVpcAttributeResponse{}
	_body, _err := client.ModifyVpcAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   The **ModifyVpcPrefixList** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [ListPrefixLists](~~311535~~) to query the status of a prefix list.
 *     *   If the prefix list is in the **Modifying** state, the configuration of the prefix list is being modified.
 *     *   If the prefix list is in the **Created** state, the configuration of the prefix list is modified.
 *     *   After the configuration of the prefix list is modified, you can call the [GetVpcPrefixListAssociations](~~445478~~) operation to query information about the network instances that are associated with the prefix list and determine whether the associated network instances use the new CIDR blocks. If the association **status** of the prefix list is **Created**, the new CIDR blocks are used by the network instances that are associated with the prefix list.
 * *   You cannot repeatedly call **ModifyVpcPrefixList** to modify the configuration of a prefix list within the specified period of time.
 *
 * @param request ModifyVpcPrefixListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyVpcPrefixListResponse
 */
func (client *Client) ModifyVpcPrefixListWithOptions(request *ModifyVpcPrefixListRequest, runtime *util.RuntimeOptions) (_result *ModifyVpcPrefixListResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AddPrefixListEntry)) {
		query["AddPrefixListEntry"] = request.AddPrefixListEntry
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.MaxEntries)) {
		query["MaxEntries"] = request.MaxEntries
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PrefixListDescription)) {
		query["PrefixListDescription"] = request.PrefixListDescription
	}

	if !tea.BoolValue(util.IsUnset(request.PrefixListId)) {
		query["PrefixListId"] = request.PrefixListId
	}

	if !tea.BoolValue(util.IsUnset(request.PrefixListName)) {
		query["PrefixListName"] = request.PrefixListName
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RemovePrefixListEntry)) {
		query["RemovePrefixListEntry"] = request.RemovePrefixListEntry
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyVpcPrefixList"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyVpcPrefixListResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   The **ModifyVpcPrefixList** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [ListPrefixLists](~~311535~~) to query the status of a prefix list.
 *     *   If the prefix list is in the **Modifying** state, the configuration of the prefix list is being modified.
 *     *   If the prefix list is in the **Created** state, the configuration of the prefix list is modified.
 *     *   After the configuration of the prefix list is modified, you can call the [GetVpcPrefixListAssociations](~~445478~~) operation to query information about the network instances that are associated with the prefix list and determine whether the associated network instances use the new CIDR blocks. If the association **status** of the prefix list is **Created**, the new CIDR blocks are used by the network instances that are associated with the prefix list.
 * *   You cannot repeatedly call **ModifyVpcPrefixList** to modify the configuration of a prefix list within the specified period of time.
 *
 * @param request ModifyVpcPrefixListRequest
 * @return ModifyVpcPrefixListResponse
 */
func (client *Client) ModifyVpcPrefixList(request *ModifyVpcPrefixListRequest) (_result *ModifyVpcPrefixListResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyVpcPrefixListResponse{}
	_body, _err := client.ModifyVpcPrefixListWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   **ModifyVpnAttachmentAttribute** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnConnection](~~53046~~) operation to query the status of an IPsec-VPN connection.
 *     *   If the IPsec-VPN connection is in the **updating** state, it indicates that the IPsec-VPN connection is being modified.
 *     *   If the IPsec-VPN connection is in the **attached** state, it indicates that the IPsec-VPN connection is modified.
 * *   You cannot call the **ModifyVpnAttachmentAttribute** operation again on the same IPsec-VPN connection before the previous operation is complete.
 * *   When you call the **ModifyVpnAttachmentAttribute** operation, take note of the following items:
 *     *   If the IPsec-VPN connection is associated with a transit router, you cannot change the type of the gateway connected to the IPsec-VPN connection.
 *     *   If the IPsec-VPN connection is not associated with a resource, you cannot change the type of the gateway connected to the IPsec-VPN connection or the customer gateway connected to the IPsec-VPN connection.
 *
 * @param request ModifyVpnAttachmentAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyVpnAttachmentAttributeResponse
 */
func (client *Client) ModifyVpnAttachmentAttributeWithOptions(request *ModifyVpnAttachmentAttributeRequest, runtime *util.RuntimeOptions) (_result *ModifyVpnAttachmentAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AutoConfigRoute)) {
		query["AutoConfigRoute"] = request.AutoConfigRoute
	}

	if !tea.BoolValue(util.IsUnset(request.BgpConfig)) {
		query["BgpConfig"] = request.BgpConfig
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.CustomerGatewayId)) {
		query["CustomerGatewayId"] = request.CustomerGatewayId
	}

	if !tea.BoolValue(util.IsUnset(request.EffectImmediately)) {
		query["EffectImmediately"] = request.EffectImmediately
	}

	if !tea.BoolValue(util.IsUnset(request.EnableDpd)) {
		query["EnableDpd"] = request.EnableDpd
	}

	if !tea.BoolValue(util.IsUnset(request.EnableNatTraversal)) {
		query["EnableNatTraversal"] = request.EnableNatTraversal
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckConfig)) {
		query["HealthCheckConfig"] = request.HealthCheckConfig
	}

	if !tea.BoolValue(util.IsUnset(request.IkeConfig)) {
		query["IkeConfig"] = request.IkeConfig
	}

	if !tea.BoolValue(util.IsUnset(request.IpsecConfig)) {
		query["IpsecConfig"] = request.IpsecConfig
	}

	if !tea.BoolValue(util.IsUnset(request.LocalSubnet)) {
		query["LocalSubnet"] = request.LocalSubnet
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.NetworkType)) {
		query["NetworkType"] = request.NetworkType
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RemoteCaCert)) {
		query["RemoteCaCert"] = request.RemoteCaCert
	}

	if !tea.BoolValue(util.IsUnset(request.RemoteSubnet)) {
		query["RemoteSubnet"] = request.RemoteSubnet
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.VpnConnectionId)) {
		query["VpnConnectionId"] = request.VpnConnectionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyVpnAttachmentAttribute"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyVpnAttachmentAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   **ModifyVpnAttachmentAttribute** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnConnection](~~53046~~) operation to query the status of an IPsec-VPN connection.
 *     *   If the IPsec-VPN connection is in the **updating** state, it indicates that the IPsec-VPN connection is being modified.
 *     *   If the IPsec-VPN connection is in the **attached** state, it indicates that the IPsec-VPN connection is modified.
 * *   You cannot call the **ModifyVpnAttachmentAttribute** operation again on the same IPsec-VPN connection before the previous operation is complete.
 * *   When you call the **ModifyVpnAttachmentAttribute** operation, take note of the following items:
 *     *   If the IPsec-VPN connection is associated with a transit router, you cannot change the type of the gateway connected to the IPsec-VPN connection.
 *     *   If the IPsec-VPN connection is not associated with a resource, you cannot change the type of the gateway connected to the IPsec-VPN connection or the customer gateway connected to the IPsec-VPN connection.
 *
 * @param request ModifyVpnAttachmentAttributeRequest
 * @return ModifyVpnAttachmentAttributeResponse
 */
func (client *Client) ModifyVpnAttachmentAttribute(request *ModifyVpnAttachmentAttributeRequest) (_result *ModifyVpnAttachmentAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyVpnAttachmentAttributeResponse{}
	_body, _err := client.ModifyVpnAttachmentAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   **ModifyVpnConnectionAttribute** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](~~73720~~) operation to query the status of the VPN gateway. The status of the VPN gateway indicates whether the IPsec-VPN connection is modified.
 *     *   If the VPN gateway is in the **updating** state, it indicates that the IPsec-VPN connection is being modified.
 *     *   If the VPN gateway is in the **active** state, it indicates that the IPsec-VPN connection is modified.
 * *   You cannot call the **ModifyVpnConnectionAttribute** operation again on the same VPN gateway to modify the configuration of an IPsec-VPN connection before the previous operation is complete.
 *
 * @param request ModifyVpnConnectionAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyVpnConnectionAttributeResponse
 */
func (client *Client) ModifyVpnConnectionAttributeWithOptions(request *ModifyVpnConnectionAttributeRequest, runtime *util.RuntimeOptions) (_result *ModifyVpnConnectionAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AutoConfigRoute)) {
		query["AutoConfigRoute"] = request.AutoConfigRoute
	}

	if !tea.BoolValue(util.IsUnset(request.BgpConfig)) {
		query["BgpConfig"] = request.BgpConfig
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.EffectImmediately)) {
		query["EffectImmediately"] = request.EffectImmediately
	}

	if !tea.BoolValue(util.IsUnset(request.EnableDpd)) {
		query["EnableDpd"] = request.EnableDpd
	}

	if !tea.BoolValue(util.IsUnset(request.EnableNatTraversal)) {
		query["EnableNatTraversal"] = request.EnableNatTraversal
	}

	if !tea.BoolValue(util.IsUnset(request.EnableTunnelsBgp)) {
		query["EnableTunnelsBgp"] = request.EnableTunnelsBgp
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckConfig)) {
		query["HealthCheckConfig"] = request.HealthCheckConfig
	}

	if !tea.BoolValue(util.IsUnset(request.IkeConfig)) {
		query["IkeConfig"] = request.IkeConfig
	}

	if !tea.BoolValue(util.IsUnset(request.IpsecConfig)) {
		query["IpsecConfig"] = request.IpsecConfig
	}

	if !tea.BoolValue(util.IsUnset(request.LocalSubnet)) {
		query["LocalSubnet"] = request.LocalSubnet
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RemoteCaCertificate)) {
		query["RemoteCaCertificate"] = request.RemoteCaCertificate
	}

	if !tea.BoolValue(util.IsUnset(request.RemoteSubnet)) {
		query["RemoteSubnet"] = request.RemoteSubnet
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.VpnConnectionId)) {
		query["VpnConnectionId"] = request.VpnConnectionId
	}

	body := map[string]interface{}{}
	bodyFlat := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.TunnelOptionsSpecification)) {
		bodyFlat["TunnelOptionsSpecification"] = request.TunnelOptionsSpecification
	}

	body = tea.ToMap(body,
		openapiutil.Query(bodyFlat))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
		Body:  openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyVpnConnectionAttribute"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyVpnConnectionAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   **ModifyVpnConnectionAttribute** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](~~73720~~) operation to query the status of the VPN gateway. The status of the VPN gateway indicates whether the IPsec-VPN connection is modified.
 *     *   If the VPN gateway is in the **updating** state, it indicates that the IPsec-VPN connection is being modified.
 *     *   If the VPN gateway is in the **active** state, it indicates that the IPsec-VPN connection is modified.
 * *   You cannot call the **ModifyVpnConnectionAttribute** operation again on the same VPN gateway to modify the configuration of an IPsec-VPN connection before the previous operation is complete.
 *
 * @param request ModifyVpnConnectionAttributeRequest
 * @return ModifyVpnConnectionAttributeResponse
 */
func (client *Client) ModifyVpnConnectionAttribute(request *ModifyVpnConnectionAttributeRequest) (_result *ModifyVpnConnectionAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyVpnConnectionAttributeResponse{}
	_body, _err := client.ModifyVpnConnectionAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   **ModifyVpnGatewayAttribute** is an asynchronous operation. After you send the request, the information about the VPN gateway is returned but the operation is still being performed in the system background. You can call the [DescribeVpnGateway](~~73720~~) operation to query the status of a VPN gateway.
 *     *   If a VPN gateway is in the **updating** state, the VPN gateway is being modified.
 *     *   If a VPN gateway is in the **active** state, the VPN gateway has been modified.
 * *   You cannot repeatedly call **ModifyVpnGatewayAttribute** to modify a VPN gateway within the specified period of time.
 *
 * @param request ModifyVpnGatewayAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyVpnGatewayAttributeResponse
 */
func (client *Client) ModifyVpnGatewayAttributeWithOptions(request *ModifyVpnGatewayAttributeRequest, runtime *util.RuntimeOptions) (_result *ModifyVpnGatewayAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AutoPropagate)) {
		query["AutoPropagate"] = request.AutoPropagate
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.VpnGatewayId)) {
		query["VpnGatewayId"] = request.VpnGatewayId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyVpnGatewayAttribute"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyVpnGatewayAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   **ModifyVpnGatewayAttribute** is an asynchronous operation. After you send the request, the information about the VPN gateway is returned but the operation is still being performed in the system background. You can call the [DescribeVpnGateway](~~73720~~) operation to query the status of a VPN gateway.
 *     *   If a VPN gateway is in the **updating** state, the VPN gateway is being modified.
 *     *   If a VPN gateway is in the **active** state, the VPN gateway has been modified.
 * *   You cannot repeatedly call **ModifyVpnGatewayAttribute** to modify a VPN gateway within the specified period of time.
 *
 * @param request ModifyVpnGatewayAttributeRequest
 * @return ModifyVpnGatewayAttributeResponse
 */
func (client *Client) ModifyVpnGatewayAttribute(request *ModifyVpnGatewayAttributeRequest) (_result *ModifyVpnGatewayAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyVpnGatewayAttributeResponse{}
	_body, _err := client.ModifyVpnGatewayAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   You can call the **ModifyVpnPbrRouteEntryAttribute** operation to modify the weight and priority of a policy-based route.
 *     *   If you want to modify only the weight of a policy-based route, call [ModifyVpnPbrRouteEntryWeight](~~127249~~).
 *     *   If you want to modify only the priority of a policy-based route, call [ModifyVpnPbrRouteEntryPriority](~~466870~~).
 *     *   If a policy-based route does not support priorities, you can only call [ModifyVpnPbrRouteEntryWeight](~~127249~~) to modify its weight.
 * *   The **ModifyVpnPbrRouteEntryAttribute** operation is asynchronous. After you send a request, the system returns a request ID, but the operation is still being performed in the system background. You can call [DescribeVpnGateway](~~73720~~) to query the status of a VPN gateway.
 *     *   If the VPN gateway is in the **updating** state, the policy-based route is being created.
 *     *   If the VPN gateway is in the **active** state, the policy-based route is created.
 * *   You cannot repeatedly call the **ModifyVpnPbrRouteEntryAttribute** operation for the same VPN gateway within the specified period of time
 *
 * @param request ModifyVpnPbrRouteEntryAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyVpnPbrRouteEntryAttributeResponse
 */
func (client *Client) ModifyVpnPbrRouteEntryAttributeWithOptions(request *ModifyVpnPbrRouteEntryAttributeRequest, runtime *util.RuntimeOptions) (_result *ModifyVpnPbrRouteEntryAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.NewPriority)) {
		query["NewPriority"] = request.NewPriority
	}

	if !tea.BoolValue(util.IsUnset(request.NewWeight)) {
		query["NewWeight"] = request.NewWeight
	}

	if !tea.BoolValue(util.IsUnset(request.NextHop)) {
		query["NextHop"] = request.NextHop
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Priority)) {
		query["Priority"] = request.Priority
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RouteDest)) {
		query["RouteDest"] = request.RouteDest
	}

	if !tea.BoolValue(util.IsUnset(request.RouteSource)) {
		query["RouteSource"] = request.RouteSource
	}

	if !tea.BoolValue(util.IsUnset(request.VpnGatewayId)) {
		query["VpnGatewayId"] = request.VpnGatewayId
	}

	if !tea.BoolValue(util.IsUnset(request.Weight)) {
		query["Weight"] = request.Weight
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyVpnPbrRouteEntryAttribute"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyVpnPbrRouteEntryAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   You can call the **ModifyVpnPbrRouteEntryAttribute** operation to modify the weight and priority of a policy-based route.
 *     *   If you want to modify only the weight of a policy-based route, call [ModifyVpnPbrRouteEntryWeight](~~127249~~).
 *     *   If you want to modify only the priority of a policy-based route, call [ModifyVpnPbrRouteEntryPriority](~~466870~~).
 *     *   If a policy-based route does not support priorities, you can only call [ModifyVpnPbrRouteEntryWeight](~~127249~~) to modify its weight.
 * *   The **ModifyVpnPbrRouteEntryAttribute** operation is asynchronous. After you send a request, the system returns a request ID, but the operation is still being performed in the system background. You can call [DescribeVpnGateway](~~73720~~) to query the status of a VPN gateway.
 *     *   If the VPN gateway is in the **updating** state, the policy-based route is being created.
 *     *   If the VPN gateway is in the **active** state, the policy-based route is created.
 * *   You cannot repeatedly call the **ModifyVpnPbrRouteEntryAttribute** operation for the same VPN gateway within the specified period of time
 *
 * @param request ModifyVpnPbrRouteEntryAttributeRequest
 * @return ModifyVpnPbrRouteEntryAttributeResponse
 */
func (client *Client) ModifyVpnPbrRouteEntryAttribute(request *ModifyVpnPbrRouteEntryAttributeRequest) (_result *ModifyVpnPbrRouteEntryAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyVpnPbrRouteEntryAttributeResponse{}
	_body, _err := client.ModifyVpnPbrRouteEntryAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   The **ModifyVpnPbrRouteEntryPriority** operation is asynchronous. After you send a request, the system returns a request ID, but the operation is still being performed in the system background. You can call [DescribeVpnGateway](~~73720~~) to query the status of a VPN gateway.
 *     *   If the VPN gateway is in the **updating** state, the policy-based route is being created.
 *     *   If the VPN gateway is in the **active** state, the policy-based route is created.
 * *   You cannot repeatedly call the **ModifyVpnPbrRouteEntryPriority** operation for the same VPN gateway within the specified period of time.
 *
 * @param request ModifyVpnPbrRouteEntryPriorityRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyVpnPbrRouteEntryPriorityResponse
 */
func (client *Client) ModifyVpnPbrRouteEntryPriorityWithOptions(request *ModifyVpnPbrRouteEntryPriorityRequest, runtime *util.RuntimeOptions) (_result *ModifyVpnPbrRouteEntryPriorityResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.NewPriority)) {
		query["NewPriority"] = request.NewPriority
	}

	if !tea.BoolValue(util.IsUnset(request.NextHop)) {
		query["NextHop"] = request.NextHop
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Priority)) {
		query["Priority"] = request.Priority
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RouteDest)) {
		query["RouteDest"] = request.RouteDest
	}

	if !tea.BoolValue(util.IsUnset(request.RouteSource)) {
		query["RouteSource"] = request.RouteSource
	}

	if !tea.BoolValue(util.IsUnset(request.VpnGatewayId)) {
		query["VpnGatewayId"] = request.VpnGatewayId
	}

	if !tea.BoolValue(util.IsUnset(request.Weight)) {
		query["Weight"] = request.Weight
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyVpnPbrRouteEntryPriority"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyVpnPbrRouteEntryPriorityResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   The **ModifyVpnPbrRouteEntryPriority** operation is asynchronous. After you send a request, the system returns a request ID, but the operation is still being performed in the system background. You can call [DescribeVpnGateway](~~73720~~) to query the status of a VPN gateway.
 *     *   If the VPN gateway is in the **updating** state, the policy-based route is being created.
 *     *   If the VPN gateway is in the **active** state, the policy-based route is created.
 * *   You cannot repeatedly call the **ModifyVpnPbrRouteEntryPriority** operation for the same VPN gateway within the specified period of time.
 *
 * @param request ModifyVpnPbrRouteEntryPriorityRequest
 * @return ModifyVpnPbrRouteEntryPriorityResponse
 */
func (client *Client) ModifyVpnPbrRouteEntryPriority(request *ModifyVpnPbrRouteEntryPriorityRequest) (_result *ModifyVpnPbrRouteEntryPriorityResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyVpnPbrRouteEntryPriorityResponse{}
	_body, _err := client.ModifyVpnPbrRouteEntryPriorityWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   The **ModifyVpnPbrRouteEntryWeight** operation is asynchronous. After you send a request, the system returns a request ID, but the operation is still being performed in the system background. You can call [DescribeVpnGateway](~~73720~~) to query the status of a VPN gateway.
 *     *   If a VPN gateway is in the **updating** state, the policy-based route entry is being modified.
 *     *   If a VPN gateway is in the **active** state, the policy-based route entry is modified.
 * *   You cannot repeatedly call the **ModifyVpnPbrRouteEntryWeight** operation for the same VPN gateway within the specified period of time.
 *
 * @param request ModifyVpnPbrRouteEntryWeightRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyVpnPbrRouteEntryWeightResponse
 */
func (client *Client) ModifyVpnPbrRouteEntryWeightWithOptions(request *ModifyVpnPbrRouteEntryWeightRequest, runtime *util.RuntimeOptions) (_result *ModifyVpnPbrRouteEntryWeightResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.NewWeight)) {
		query["NewWeight"] = request.NewWeight
	}

	if !tea.BoolValue(util.IsUnset(request.NextHop)) {
		query["NextHop"] = request.NextHop
	}

	if !tea.BoolValue(util.IsUnset(request.OverlayMode)) {
		query["OverlayMode"] = request.OverlayMode
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Priority)) {
		query["Priority"] = request.Priority
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RouteDest)) {
		query["RouteDest"] = request.RouteDest
	}

	if !tea.BoolValue(util.IsUnset(request.RouteSource)) {
		query["RouteSource"] = request.RouteSource
	}

	if !tea.BoolValue(util.IsUnset(request.VpnGatewayId)) {
		query["VpnGatewayId"] = request.VpnGatewayId
	}

	if !tea.BoolValue(util.IsUnset(request.Weight)) {
		query["Weight"] = request.Weight
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyVpnPbrRouteEntryWeight"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyVpnPbrRouteEntryWeightResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   The **ModifyVpnPbrRouteEntryWeight** operation is asynchronous. After you send a request, the system returns a request ID, but the operation is still being performed in the system background. You can call [DescribeVpnGateway](~~73720~~) to query the status of a VPN gateway.
 *     *   If a VPN gateway is in the **updating** state, the policy-based route entry is being modified.
 *     *   If a VPN gateway is in the **active** state, the policy-based route entry is modified.
 * *   You cannot repeatedly call the **ModifyVpnPbrRouteEntryWeight** operation for the same VPN gateway within the specified period of time.
 *
 * @param request ModifyVpnPbrRouteEntryWeightRequest
 * @return ModifyVpnPbrRouteEntryWeightResponse
 */
func (client *Client) ModifyVpnPbrRouteEntryWeight(request *ModifyVpnPbrRouteEntryWeightRequest) (_result *ModifyVpnPbrRouteEntryWeightResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyVpnPbrRouteEntryWeightResponse{}
	_body, _err := client.ModifyVpnPbrRouteEntryWeightWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   The **ModifyVpnRouteEntryWeight** operation is asynchronous. After you send a request, the system returns a request ID, but the operation is still being performed in the system background. You can call [DescribeVpnGateway](~~73720~~) to query the status of a VPN gateway.
 *     *   If the VPN gateway is in the **updating** state, the weight of the destination-based route is being modified.
 *     *   If the VPN gateway is in the **active** state, the weight of the destination-based route is modified.
 * *   You cannot repeatedly call the **ModifyVpnRouteEntryWeight** operation to modify the weight of destination-based route for the same VPN gateway within the specified period of time.
 *
 * @param request ModifyVpnRouteEntryWeightRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyVpnRouteEntryWeightResponse
 */
func (client *Client) ModifyVpnRouteEntryWeightWithOptions(request *ModifyVpnRouteEntryWeightRequest, runtime *util.RuntimeOptions) (_result *ModifyVpnRouteEntryWeightResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.NewWeight)) {
		query["NewWeight"] = request.NewWeight
	}

	if !tea.BoolValue(util.IsUnset(request.NextHop)) {
		query["NextHop"] = request.NextHop
	}

	if !tea.BoolValue(util.IsUnset(request.OverlayMode)) {
		query["OverlayMode"] = request.OverlayMode
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RouteDest)) {
		query["RouteDest"] = request.RouteDest
	}

	if !tea.BoolValue(util.IsUnset(request.VpnGatewayId)) {
		query["VpnGatewayId"] = request.VpnGatewayId
	}

	if !tea.BoolValue(util.IsUnset(request.Weight)) {
		query["Weight"] = request.Weight
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyVpnRouteEntryWeight"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyVpnRouteEntryWeightResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   The **ModifyVpnRouteEntryWeight** operation is asynchronous. After you send a request, the system returns a request ID, but the operation is still being performed in the system background. You can call [DescribeVpnGateway](~~73720~~) to query the status of a VPN gateway.
 *     *   If the VPN gateway is in the **updating** state, the weight of the destination-based route is being modified.
 *     *   If the VPN gateway is in the **active** state, the weight of the destination-based route is modified.
 * *   You cannot repeatedly call the **ModifyVpnRouteEntryWeight** operation to modify the weight of destination-based route for the same VPN gateway within the specified period of time.
 *
 * @param request ModifyVpnRouteEntryWeightRequest
 * @return ModifyVpnRouteEntryWeightResponse
 */
func (client *Client) ModifyVpnRouteEntryWeight(request *ModifyVpnRouteEntryWeightRequest) (_result *ModifyVpnRouteEntryWeightResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyVpnRouteEntryWeightResponse{}
	_body, _err := client.ModifyVpnRouteEntryWeightWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) MoveResourceGroupWithOptions(request *MoveResourceGroupRequest, runtime *util.RuntimeOptions) (_result *MoveResourceGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.NewResourceGroupId)) {
		query["NewResourceGroupId"] = request.NewResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceId)) {
		query["ResourceId"] = request.ResourceId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("MoveResourceGroup"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &MoveResourceGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) MoveResourceGroup(request *MoveResourceGroupRequest) (_result *MoveResourceGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &MoveResourceGroupResponse{}
	_body, _err := client.MoveResourceGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   You cannot repeatedly call the **OpenFlowLogService** operation within the specified period of time by using an Alibaba Cloud account.
 * *   You can call the [GetFlowLogServiceStatus](~~449624~~) operation to query the status of the flow log feature.
 *
 * @param request OpenFlowLogServiceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return OpenFlowLogServiceResponse
 */
func (client *Client) OpenFlowLogServiceWithOptions(request *OpenFlowLogServiceRequest, runtime *util.RuntimeOptions) (_result *OpenFlowLogServiceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("OpenFlowLogService"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &OpenFlowLogServiceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   You cannot repeatedly call the **OpenFlowLogService** operation within the specified period of time by using an Alibaba Cloud account.
 * *   You can call the [GetFlowLogServiceStatus](~~449624~~) operation to query the status of the flow log feature.
 *
 * @param request OpenFlowLogServiceRequest
 * @return OpenFlowLogServiceResponse
 */
func (client *Client) OpenFlowLogService(request *OpenFlowLogServiceRequest) (_result *OpenFlowLogServiceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &OpenFlowLogServiceResponse{}
	_body, _err := client.OpenFlowLogServiceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) OpenPhysicalConnectionServiceWithOptions(request *OpenPhysicalConnectionServiceRequest, runtime *util.RuntimeOptions) (_result *OpenPhysicalConnectionServiceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("OpenPhysicalConnectionService"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &OpenPhysicalConnectionServiceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) OpenPhysicalConnectionService(request *OpenPhysicalConnectionServiceRequest) (_result *OpenPhysicalConnectionServiceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &OpenPhysicalConnectionServiceResponse{}
	_body, _err := client.OpenPhysicalConnectionServiceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can enable traffic mirroring for different regions. You cannot repeatedly call the **OpenTrafficMirrorService** operation to enable traffic mirroring for one region within the specified period of time.
 *
 * @param request OpenTrafficMirrorServiceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return OpenTrafficMirrorServiceResponse
 */
func (client *Client) OpenTrafficMirrorServiceWithOptions(request *OpenTrafficMirrorServiceRequest, runtime *util.RuntimeOptions) (_result *OpenTrafficMirrorServiceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("OpenTrafficMirrorService"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &OpenTrafficMirrorServiceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can enable traffic mirroring for different regions. You cannot repeatedly call the **OpenTrafficMirrorService** operation to enable traffic mirroring for one region within the specified period of time.
 *
 * @param request OpenTrafficMirrorServiceRequest
 * @return OpenTrafficMirrorServiceResponse
 */
func (client *Client) OpenTrafficMirrorService(request *OpenTrafficMirrorServiceRequest) (_result *OpenTrafficMirrorServiceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &OpenTrafficMirrorServiceResponse{}
	_body, _err := client.OpenTrafficMirrorServiceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) PublishVpnRouteEntryWithOptions(request *PublishVpnRouteEntryRequest, runtime *util.RuntimeOptions) (_result *PublishVpnRouteEntryResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.NextHop)) {
		query["NextHop"] = request.NextHop
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PublishVpc)) {
		query["PublishVpc"] = request.PublishVpc
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RouteDest)) {
		query["RouteDest"] = request.RouteDest
	}

	if !tea.BoolValue(util.IsUnset(request.RouteType)) {
		query["RouteType"] = request.RouteType
	}

	if !tea.BoolValue(util.IsUnset(request.VpnGatewayId)) {
		query["VpnGatewayId"] = request.VpnGatewayId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("PublishVpnRouteEntry"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &PublishVpnRouteEntryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) PublishVpnRouteEntry(request *PublishVpnRouteEntryRequest) (_result *PublishVpnRouteEntryResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &PublishVpnRouteEntryResponse{}
	_body, _err := client.PublishVpnRouteEntryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call this API operation to resume a suspended Express Connect circuit. You can resume only shared Express Connect circuits by calling this API operation.
 *
 * @param request RecoverPhysicalConnectionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RecoverPhysicalConnectionResponse
 */
func (client *Client) RecoverPhysicalConnectionWithOptions(request *RecoverPhysicalConnectionRequest, runtime *util.RuntimeOptions) (_result *RecoverPhysicalConnectionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.Token)) {
		query["Token"] = request.Token
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RecoverPhysicalConnection"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RecoverPhysicalConnectionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call this API operation to resume a suspended Express Connect circuit. You can resume only shared Express Connect circuits by calling this API operation.
 *
 * @param request RecoverPhysicalConnectionRequest
 * @return RecoverPhysicalConnectionResponse
 */
func (client *Client) RecoverPhysicalConnection(request *RecoverPhysicalConnectionRequest) (_result *RecoverPhysicalConnectionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RecoverPhysicalConnectionResponse{}
	_body, _err := client.RecoverPhysicalConnectionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * After the operation is called, the virtual border router (VBR) changes from the **Terminated** state to the **Recovering** state. When the VBR recovers, it enters the **Enabled** state.
 * When you call this operation, take note of the following items:
 * *   Only the owner of the Express Connect circuit can call this operation.
 * *   The Express Connect circuit to which the VBR connects must be in the **Enabled** state.
 *
 * @param request RecoverVirtualBorderRouterRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RecoverVirtualBorderRouterResponse
 */
func (client *Client) RecoverVirtualBorderRouterWithOptions(request *RecoverVirtualBorderRouterRequest, runtime *util.RuntimeOptions) (_result *RecoverVirtualBorderRouterResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.VbrId)) {
		query["VbrId"] = request.VbrId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RecoverVirtualBorderRouter"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RecoverVirtualBorderRouterResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * After the operation is called, the virtual border router (VBR) changes from the **Terminated** state to the **Recovering** state. When the VBR recovers, it enters the **Enabled** state.
 * When you call this operation, take note of the following items:
 * *   Only the owner of the Express Connect circuit can call this operation.
 * *   The Express Connect circuit to which the VBR connects must be in the **Enabled** state.
 *
 * @param request RecoverVirtualBorderRouterRequest
 * @return RecoverVirtualBorderRouterResponse
 */
func (client *Client) RecoverVirtualBorderRouter(request *RecoverVirtualBorderRouterRequest) (_result *RecoverVirtualBorderRouterResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RecoverVirtualBorderRouterResponse{}
	_body, _err := client.RecoverVirtualBorderRouterWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Before you call this operation, take note of the following limits:
 * *   Before you release an EIP, make sure that the EIP meets the following requirements:
 *     *   You can release only an EIP that is in the **Available** state.
 *     *   You can release only a pay-as-you-go EIP. You cannot release a subscription EIP.
 * *   The **ReleaseEipAddress** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeEipAddresses](~~120193~~) operation to query the status of an EIP:
 *     *   If the EIP is in the **Releasing** state, the EIP is being released. In this state, you can only query the EIP and cannot perform other operations.
 *     *   If you cannot query the EIP, the EIP is released.
 * *   You cannot repeatedly call the **ReleaseEipAddress** operation to release an EIP within the specified period of time.
 *
 * @param request ReleaseEipAddressRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ReleaseEipAddressResponse
 */
func (client *Client) ReleaseEipAddressWithOptions(request *ReleaseEipAddressRequest, runtime *util.RuntimeOptions) (_result *ReleaseEipAddressResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AllocationId)) {
		query["AllocationId"] = request.AllocationId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ReleaseEipAddress"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ReleaseEipAddressResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Before you call this operation, take note of the following limits:
 * *   Before you release an EIP, make sure that the EIP meets the following requirements:
 *     *   You can release only an EIP that is in the **Available** state.
 *     *   You can release only a pay-as-you-go EIP. You cannot release a subscription EIP.
 * *   The **ReleaseEipAddress** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeEipAddresses](~~120193~~) operation to query the status of an EIP:
 *     *   If the EIP is in the **Releasing** state, the EIP is being released. In this state, you can only query the EIP and cannot perform other operations.
 *     *   If you cannot query the EIP, the EIP is released.
 * *   You cannot repeatedly call the **ReleaseEipAddress** operation to release an EIP within the specified period of time.
 *
 * @param request ReleaseEipAddressRequest
 * @return ReleaseEipAddressResponse
 */
func (client *Client) ReleaseEipAddress(request *ReleaseEipAddressRequest) (_result *ReleaseEipAddressResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ReleaseEipAddressResponse{}
	_body, _err := client.ReleaseEipAddressWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   After you call the **ReleaseEipSegmentAddress** operation, all EIPs in the specified group are released.
 * *   The **ReleaseEipSegmentAddress** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeEipSegment](~~156063~~) operation to query the status of a group of contiguous EIPs:
 *     *   If the group is in the **Releasing** state, EIPs in the group are being released. In this state, you can only query the group and cannot perform other operations.
 *     *   If you cannot query the group of contiguous EIPs, the contiguous EIPs are released.
 * *   You cannot repeatedly call the **ReleaseEipSegmentAddress** operation to release a group of contiguous EIPs within the specified period of time.
 *
 * @param request ReleaseEipSegmentAddressRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ReleaseEipSegmentAddressResponse
 */
func (client *Client) ReleaseEipSegmentAddressWithOptions(request *ReleaseEipSegmentAddressRequest, runtime *util.RuntimeOptions) (_result *ReleaseEipSegmentAddressResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SegmentInstanceId)) {
		query["SegmentInstanceId"] = request.SegmentInstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ReleaseEipSegmentAddress"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ReleaseEipSegmentAddressResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   After you call the **ReleaseEipSegmentAddress** operation, all EIPs in the specified group are released.
 * *   The **ReleaseEipSegmentAddress** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeEipSegment](~~156063~~) operation to query the status of a group of contiguous EIPs:
 *     *   If the group is in the **Releasing** state, EIPs in the group are being released. In this state, you can only query the group and cannot perform other operations.
 *     *   If you cannot query the group of contiguous EIPs, the contiguous EIPs are released.
 * *   You cannot repeatedly call the **ReleaseEipSegmentAddress** operation to release a group of contiguous EIPs within the specified period of time.
 *
 * @param request ReleaseEipSegmentAddressRequest
 * @return ReleaseEipSegmentAddressResponse
 */
func (client *Client) ReleaseEipSegmentAddress(request *ReleaseEipSegmentAddressRequest) (_result *ReleaseEipSegmentAddressResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ReleaseEipSegmentAddressResponse{}
	_body, _err := client.ReleaseEipSegmentAddressWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) RemoveCommonBandwidthPackageIpWithOptions(request *RemoveCommonBandwidthPackageIpRequest, runtime *util.RuntimeOptions) (_result *RemoveCommonBandwidthPackageIpResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BandwidthPackageId)) {
		query["BandwidthPackageId"] = request.BandwidthPackageId
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.IpInstanceId)) {
		query["IpInstanceId"] = request.IpInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RemoveCommonBandwidthPackageIp"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RemoveCommonBandwidthPackageIpResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) RemoveCommonBandwidthPackageIp(request *RemoveCommonBandwidthPackageIpRequest) (_result *RemoveCommonBandwidthPackageIpResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RemoveCommonBandwidthPackageIpResponse{}
	_body, _err := client.RemoveCommonBandwidthPackageIpWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) RemoveGlobalAccelerationInstanceIpWithOptions(request *RemoveGlobalAccelerationInstanceIpRequest, runtime *util.RuntimeOptions) (_result *RemoveGlobalAccelerationInstanceIpResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.GlobalAccelerationInstanceId)) {
		query["GlobalAccelerationInstanceId"] = request.GlobalAccelerationInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.IpInstanceId)) {
		query["IpInstanceId"] = request.IpInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RemoveGlobalAccelerationInstanceIp"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RemoveGlobalAccelerationInstanceIpResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) RemoveGlobalAccelerationInstanceIp(request *RemoveGlobalAccelerationInstanceIpRequest) (_result *RemoveGlobalAccelerationInstanceIpResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RemoveGlobalAccelerationInstanceIpResponse{}
	_body, _err := client.RemoveGlobalAccelerationInstanceIpWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) RemoveIPv6TranslatorAclListEntryWithOptions(request *RemoveIPv6TranslatorAclListEntryRequest, runtime *util.RuntimeOptions) (_result *RemoveIPv6TranslatorAclListEntryResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AclEntryId)) {
		query["AclEntryId"] = request.AclEntryId
	}

	if !tea.BoolValue(util.IsUnset(request.AclId)) {
		query["AclId"] = request.AclId
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RemoveIPv6TranslatorAclListEntry"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RemoveIPv6TranslatorAclListEntryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) RemoveIPv6TranslatorAclListEntry(request *RemoveIPv6TranslatorAclListEntryRequest) (_result *RemoveIPv6TranslatorAclListEntryResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RemoveIPv6TranslatorAclListEntryResponse{}
	_body, _err := client.RemoveIPv6TranslatorAclListEntryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   The **RemoveSourcesFromTrafficMirrorSession** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [ListTrafficMirrorSessions](~~261367~~) operation to query the status of a traffic mirror session:
 *     *   If the traffic mirror session is in the **Modifying** state, the traffic mirror source is being deleted.
 *     *   If the traffic mirror session is in the **Created** state, the traffic mirror source is deleted.
 * *   You cannot repeatedly call the **RemoveSourcesFromTrafficMirrorSession** operation to delete a traffic mirror source from a traffic mirror session within the specified period of time.
 *
 * @param request RemoveSourcesFromTrafficMirrorSessionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RemoveSourcesFromTrafficMirrorSessionResponse
 */
func (client *Client) RemoveSourcesFromTrafficMirrorSessionWithOptions(request *RemoveSourcesFromTrafficMirrorSessionRequest, runtime *util.RuntimeOptions) (_result *RemoveSourcesFromTrafficMirrorSessionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.TrafficMirrorSessionId)) {
		query["TrafficMirrorSessionId"] = request.TrafficMirrorSessionId
	}

	if !tea.BoolValue(util.IsUnset(request.TrafficMirrorSourceIds)) {
		query["TrafficMirrorSourceIds"] = request.TrafficMirrorSourceIds
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RemoveSourcesFromTrafficMirrorSession"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RemoveSourcesFromTrafficMirrorSessionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   The **RemoveSourcesFromTrafficMirrorSession** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [ListTrafficMirrorSessions](~~261367~~) operation to query the status of a traffic mirror session:
 *     *   If the traffic mirror session is in the **Modifying** state, the traffic mirror source is being deleted.
 *     *   If the traffic mirror session is in the **Created** state, the traffic mirror source is deleted.
 * *   You cannot repeatedly call the **RemoveSourcesFromTrafficMirrorSession** operation to delete a traffic mirror source from a traffic mirror session within the specified period of time.
 *
 * @param request RemoveSourcesFromTrafficMirrorSessionRequest
 * @return RemoveSourcesFromTrafficMirrorSessionResponse
 */
func (client *Client) RemoveSourcesFromTrafficMirrorSession(request *RemoveSourcesFromTrafficMirrorSessionRequest) (_result *RemoveSourcesFromTrafficMirrorSessionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RemoveSourcesFromTrafficMirrorSessionResponse{}
	_body, _err := client.RemoveSourcesFromTrafficMirrorSessionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   The **ReplaceVpcDhcpOptionsSet** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeVpcAttribute](~~94565~~) operation to query the status of a DHCP options set:
 *     *   If the DHCP options set is in the **Pending** state, the DHCP options set is being replaced.
 *     *   If the DHCP options set is in the **InUse** state, the DHCP options set is replaced.
 * *   You cannot repeatedly call the **ReplaceVpcDhcpOptionsSet** operation to replace the DHCP options set associated with a VPC within the specified period of time.
 *
 * @param request ReplaceVpcDhcpOptionsSetRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ReplaceVpcDhcpOptionsSetResponse
 */
func (client *Client) ReplaceVpcDhcpOptionsSetWithOptions(request *ReplaceVpcDhcpOptionsSetRequest, runtime *util.RuntimeOptions) (_result *ReplaceVpcDhcpOptionsSetResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DhcpOptionsSetId)) {
		query["DhcpOptionsSetId"] = request.DhcpOptionsSetId
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.VpcId)) {
		query["VpcId"] = request.VpcId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ReplaceVpcDhcpOptionsSet"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ReplaceVpcDhcpOptionsSetResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   The **ReplaceVpcDhcpOptionsSet** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeVpcAttribute](~~94565~~) operation to query the status of a DHCP options set:
 *     *   If the DHCP options set is in the **Pending** state, the DHCP options set is being replaced.
 *     *   If the DHCP options set is in the **InUse** state, the DHCP options set is replaced.
 * *   You cannot repeatedly call the **ReplaceVpcDhcpOptionsSet** operation to replace the DHCP options set associated with a VPC within the specified period of time.
 *
 * @param request ReplaceVpcDhcpOptionsSetRequest
 * @return ReplaceVpcDhcpOptionsSetResponse
 */
func (client *Client) ReplaceVpcDhcpOptionsSet(request *ReplaceVpcDhcpOptionsSetRequest) (_result *ReplaceVpcDhcpOptionsSetResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ReplaceVpcDhcpOptionsSetResponse{}
	_body, _err := client.ReplaceVpcDhcpOptionsSetWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   If you modify the information about a prefix list but the modification is not automatically applied to the route table that is associated with the prefix list, you can call this operation to apply the latest prefix list to the associated route table.
 * *   The **RetryVpcPrefixListAssociation** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the background. You can call the [GetVpcPrefixListAssociations](~~445478~~) to check whether the prefix list is re-applied.
 *     *   If the prefix list is in the **Modifying** state, the prefix list is being re-applied.
 *     *   If the prefix list is in the **ModifyFailed** state, the prefix list fails to be re-applied.
 *     *   If the prefix list is in the **Created** state, the prefix list is re-applied.
 * *   After you call the **RetryVpcPrefixListAssociation** operation to re-apply a prefix list, you cannot call the operation again until the current task is complete.
 * ## Scenarios
 * A prefix list can be successfully modified if the following requirements are met: CIDR blocks are valid, CIDR blocks do not conflict, and the number of CIDR blocks does not exceed the maximum number of CIDR blocks supported by the prefix list. If issues occur on the resource that references the prefix list, the reference may fail. The issues include the number of prefix list entries exceeding the quota or CIDR blocks conflicting with existing routes. After you resolve the issues, you can call the **RetryVpcPrefixListAssociation** operation to re-apply the prefix list.
 *
 * @param request RetryVpcPrefixListAssociationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RetryVpcPrefixListAssociationResponse
 */
func (client *Client) RetryVpcPrefixListAssociationWithOptions(request *RetryVpcPrefixListAssociationRequest, runtime *util.RuntimeOptions) (_result *RetryVpcPrefixListAssociationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PrefixListId)) {
		query["PrefixListId"] = request.PrefixListId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceId)) {
		query["ResourceId"] = request.ResourceId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RetryVpcPrefixListAssociation"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RetryVpcPrefixListAssociationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   If you modify the information about a prefix list but the modification is not automatically applied to the route table that is associated with the prefix list, you can call this operation to apply the latest prefix list to the associated route table.
 * *   The **RetryVpcPrefixListAssociation** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the background. You can call the [GetVpcPrefixListAssociations](~~445478~~) to check whether the prefix list is re-applied.
 *     *   If the prefix list is in the **Modifying** state, the prefix list is being re-applied.
 *     *   If the prefix list is in the **ModifyFailed** state, the prefix list fails to be re-applied.
 *     *   If the prefix list is in the **Created** state, the prefix list is re-applied.
 * *   After you call the **RetryVpcPrefixListAssociation** operation to re-apply a prefix list, you cannot call the operation again until the current task is complete.
 * ## Scenarios
 * A prefix list can be successfully modified if the following requirements are met: CIDR blocks are valid, CIDR blocks do not conflict, and the number of CIDR blocks does not exceed the maximum number of CIDR blocks supported by the prefix list. If issues occur on the resource that references the prefix list, the reference may fail. The issues include the number of prefix list entries exceeding the quota or CIDR blocks conflicting with existing routes. After you resolve the issues, you can call the **RetryVpcPrefixListAssociation** operation to re-apply the prefix list.
 *
 * @param request RetryVpcPrefixListAssociationRequest
 * @return RetryVpcPrefixListAssociationResponse
 */
func (client *Client) RetryVpcPrefixListAssociation(request *RetryVpcPrefixListAssociationRequest) (_result *RetryVpcPrefixListAssociationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RetryVpcPrefixListAssociationResponse{}
	_body, _err := client.RetryVpcPrefixListAssociationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   **RevokeInstanceFromCen** is a Virtual Private Cloud (VPC) operation. Therefore, you must use `vpc.aliyuncs.com` as the domain name when you call this operation. The API version is `2016-04-28`.
 * *   You cannot repeatedly call the **RevokeInstanceFromCen** operation to revoke the permissions on a network instance that is attached to a CEN instance within the specified period of time. The network instance can be a VPC, virtual border router (VBR), or a Cloud Connect Network (CCN) instance.
 *
 * @param request RevokeInstanceFromCenRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RevokeInstanceFromCenResponse
 */
func (client *Client) RevokeInstanceFromCenWithOptions(request *RevokeInstanceFromCenRequest, runtime *util.RuntimeOptions) (_result *RevokeInstanceFromCenResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CenId)) {
		query["CenId"] = request.CenId
	}

	if !tea.BoolValue(util.IsUnset(request.CenOwnerId)) {
		query["CenOwnerId"] = request.CenOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceType)) {
		query["InstanceType"] = request.InstanceType
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RevokeInstanceFromCen"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RevokeInstanceFromCenResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   **RevokeInstanceFromCen** is a Virtual Private Cloud (VPC) operation. Therefore, you must use `vpc.aliyuncs.com` as the domain name when you call this operation. The API version is `2016-04-28`.
 * *   You cannot repeatedly call the **RevokeInstanceFromCen** operation to revoke the permissions on a network instance that is attached to a CEN instance within the specified period of time. The network instance can be a VPC, virtual border router (VBR), or a Cloud Connect Network (CCN) instance.
 *
 * @param request RevokeInstanceFromCenRequest
 * @return RevokeInstanceFromCenResponse
 */
func (client *Client) RevokeInstanceFromCen(request *RevokeInstanceFromCenRequest) (_result *RevokeInstanceFromCenResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RevokeInstanceFromCenResponse{}
	_body, _err := client.RevokeInstanceFromCenWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) RevokeInstanceFromVbrWithOptions(tmpReq *RevokeInstanceFromVbrRequest, runtime *util.RuntimeOptions) (_result *RevokeInstanceFromVbrResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &RevokeInstanceFromVbrShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.VbrInstanceIds)) {
		request.VbrInstanceIdsShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.VbrInstanceIds, tea.String("VbrInstanceIds"), tea.String("simple"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.GrantType)) {
		query["GrantType"] = request.GrantType
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.VbrInstanceIdsShrink)) {
		query["VbrInstanceIds"] = request.VbrInstanceIdsShrink
	}

	if !tea.BoolValue(util.IsUnset(request.VbrOwnerUid)) {
		query["VbrOwnerUid"] = request.VbrOwnerUid
	}

	if !tea.BoolValue(util.IsUnset(request.VbrRegionNo)) {
		query["VbrRegionNo"] = request.VbrRegionNo
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RevokeInstanceFromVbr"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RevokeInstanceFromVbrResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) RevokeInstanceFromVbr(request *RevokeInstanceFromVbrRequest) (_result *RevokeInstanceFromVbrResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RevokeInstanceFromVbrResponse{}
	_body, _err := client.RevokeInstanceFromVbrWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) SecondApplyPhysicalConnectionLOAWithOptions(request *SecondApplyPhysicalConnectionLOARequest, runtime *util.RuntimeOptions) (_result *SecondApplyPhysicalConnectionLOAResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Bandwidth)) {
		query["Bandwidth"] = request.Bandwidth
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.CompanyName)) {
		query["CompanyName"] = request.CompanyName
	}

	if !tea.BoolValue(util.IsUnset(request.ConstructionTime)) {
		query["ConstructionTime"] = request.ConstructionTime
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.LineType)) {
		query["LineType"] = request.LineType
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PMInfo)) {
		query["PMInfo"] = request.PMInfo
	}

	if !tea.BoolValue(util.IsUnset(request.PeerLocation)) {
		query["PeerLocation"] = request.PeerLocation
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Si)) {
		query["Si"] = request.Si
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SecondApplyPhysicalConnectionLOA"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SecondApplyPhysicalConnectionLOAResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) SecondApplyPhysicalConnectionLOA(request *SecondApplyPhysicalConnectionLOARequest) (_result *SecondApplyPhysicalConnectionLOAResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SecondApplyPhysicalConnectionLOAResponse{}
	_body, _err := client.SecondApplyPhysicalConnectionLOAWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You cannot repeatedly call **SetHighDefinitionMonitorLogStatus** within a specific period of time.
 *
 * @param request SetHighDefinitionMonitorLogStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SetHighDefinitionMonitorLogStatusResponse
 */
func (client *Client) SetHighDefinitionMonitorLogStatusWithOptions(request *SetHighDefinitionMonitorLogStatusRequest, runtime *util.RuntimeOptions) (_result *SetHighDefinitionMonitorLogStatusResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceType)) {
		query["InstanceType"] = request.InstanceType
	}

	if !tea.BoolValue(util.IsUnset(request.LogProject)) {
		query["LogProject"] = request.LogProject
	}

	if !tea.BoolValue(util.IsUnset(request.LogStore)) {
		query["LogStore"] = request.LogStore
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		query["Status"] = request.Status
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SetHighDefinitionMonitorLogStatus"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SetHighDefinitionMonitorLogStatusResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You cannot repeatedly call **SetHighDefinitionMonitorLogStatus** within a specific period of time.
 *
 * @param request SetHighDefinitionMonitorLogStatusRequest
 * @return SetHighDefinitionMonitorLogStatusResponse
 */
func (client *Client) SetHighDefinitionMonitorLogStatus(request *SetHighDefinitionMonitorLogStatusRequest) (_result *SetHighDefinitionMonitorLogStatusResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SetHighDefinitionMonitorLogStatusResponse{}
	_body, _err := client.SetHighDefinitionMonitorLogStatusWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Usage notes
 * Tags are used to classify instances. Each tag consists of a key-value pair. Before you use tags, take note of the following limits:
 * *   The keys of tags that are added to the same instance must be unique.
 * *   You cannot create tags without adding them to instances. All tags must be added to instances.
 * *   Tag information is not shared across regions.
 *     For example, you cannot view the tags that are created in the China (Hangzhou) region from the China (Shanghai) region.
 * *   Virtual private clouds (VPCs), route tables, vSwitches, and elastic IP addresses (EIPs) that belong to the same Alibaba Cloud account and are deployed in the same region share tag information with each other.
 *     For example, if you added a tag to a VPC, the tag is available to vSwitches, route tables, and EIPs that belong to the same account and are deployed in the same region in which the VPC is created. You can select this tag from the editing page without the need to enter the tag again. You can modify the key and the value of a tag or remove a tag from an instance. After you delete an instance, all tags that are added to the instance are deleted.
 * *   You can add up to 20 tags to each instance. Before you add a tag to an instance, the system automatically checks the number of existing tags. An error message is returned if the maximum number of tags is reached.
 *
 * @param request TagResourcesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return TagResourcesResponse
 */
func (client *Client) TagResourcesWithOptions(request *TagResourcesRequest, runtime *util.RuntimeOptions) (_result *TagResourcesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceId)) {
		query["ResourceId"] = request.ResourceId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("TagResources"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &TagResourcesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Usage notes
 * Tags are used to classify instances. Each tag consists of a key-value pair. Before you use tags, take note of the following limits:
 * *   The keys of tags that are added to the same instance must be unique.
 * *   You cannot create tags without adding them to instances. All tags must be added to instances.
 * *   Tag information is not shared across regions.
 *     For example, you cannot view the tags that are created in the China (Hangzhou) region from the China (Shanghai) region.
 * *   Virtual private clouds (VPCs), route tables, vSwitches, and elastic IP addresses (EIPs) that belong to the same Alibaba Cloud account and are deployed in the same region share tag information with each other.
 *     For example, if you added a tag to a VPC, the tag is available to vSwitches, route tables, and EIPs that belong to the same account and are deployed in the same region in which the VPC is created. You can select this tag from the editing page without the need to enter the tag again. You can modify the key and the value of a tag or remove a tag from an instance. After you delete an instance, all tags that are added to the instance are deleted.
 * *   You can add up to 20 tags to each instance. Before you add a tag to an instance, the system automatically checks the number of existing tags. An error message is returned if the maximum number of tags is reached.
 *
 * @param request TagResourcesRequest
 * @return TagResourcesResponse
 */
func (client *Client) TagResources(request *TagResourcesRequest) (_result *TagResourcesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &TagResourcesResponse{}
	_body, _err := client.TagResourcesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Tags are used to classify instances. Each tag consists of a key-value pair. To use tags, make sure that the following requirements are met:
 * *   The keys of tags that are added to the same instance must be unique.
 * *   You cannot create tags without adding them to instances. All tags must be added to instances.
 * *   Tag information is not shared across regions.
 *     For example, you cannot view the tags that are created in the China (Hangzhou) region from the China (Shanghai) region.
 * *   You can add up to 20 tags to each instance. Before you add a tag to an instance, the system automatically checks the number of existing tags. If the maximum number of tags is reached, an error message is returned.
 *
 * @param request TagResourcesForExpressConnectRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return TagResourcesForExpressConnectResponse
 */
func (client *Client) TagResourcesForExpressConnectWithOptions(request *TagResourcesForExpressConnectRequest, runtime *util.RuntimeOptions) (_result *TagResourcesForExpressConnectResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceId)) {
		query["ResourceId"] = request.ResourceId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("TagResourcesForExpressConnect"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &TagResourcesForExpressConnectResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Tags are used to classify instances. Each tag consists of a key-value pair. To use tags, make sure that the following requirements are met:
 * *   The keys of tags that are added to the same instance must be unique.
 * *   You cannot create tags without adding them to instances. All tags must be added to instances.
 * *   Tag information is not shared across regions.
 *     For example, you cannot view the tags that are created in the China (Hangzhou) region from the China (Shanghai) region.
 * *   You can add up to 20 tags to each instance. Before you add a tag to an instance, the system automatically checks the number of existing tags. If the maximum number of tags is reached, an error message is returned.
 *
 * @param request TagResourcesForExpressConnectRequest
 * @return TagResourcesForExpressConnectResponse
 */
func (client *Client) TagResourcesForExpressConnect(request *TagResourcesForExpressConnectRequest) (_result *TagResourcesForExpressConnectResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &TagResourcesForExpressConnectResponse{}
	_body, _err := client.TagResourcesForExpressConnectWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * After you call this operation, the specified Express Connect circuit changes to the **Terminating** state. After the Express Connect circuit is disabled, it changes to the **Terminated** state.
 * When you call this operation, take note of the following limits:
 * *   You can only terminate an Express Connect circuit that is in the **Enabled** state.
 * *   Before you disable an Express Connect circuit, you must delete the virtual border routers (VBRs) associated with it.
 *
 * @param request TerminatePhysicalConnectionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return TerminatePhysicalConnectionResponse
 */
func (client *Client) TerminatePhysicalConnectionWithOptions(request *TerminatePhysicalConnectionRequest, runtime *util.RuntimeOptions) (_result *TerminatePhysicalConnectionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PhysicalConnectionId)) {
		query["PhysicalConnectionId"] = request.PhysicalConnectionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("TerminatePhysicalConnection"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &TerminatePhysicalConnectionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * After you call this operation, the specified Express Connect circuit changes to the **Terminating** state. After the Express Connect circuit is disabled, it changes to the **Terminated** state.
 * When you call this operation, take note of the following limits:
 * *   You can only terminate an Express Connect circuit that is in the **Enabled** state.
 * *   Before you disable an Express Connect circuit, you must delete the virtual border routers (VBRs) associated with it.
 *
 * @param request TerminatePhysicalConnectionRequest
 * @return TerminatePhysicalConnectionResponse
 */
func (client *Client) TerminatePhysicalConnection(request *TerminatePhysicalConnectionRequest) (_result *TerminatePhysicalConnectionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &TerminatePhysicalConnectionResponse{}
	_body, _err := client.TerminatePhysicalConnectionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * After the operation is called, the VBR changes from the **Enabled** state to the **Terminating** state. After the VBR is terminated, it enters the **Terminated** state.
 * >  Only the owner of an Express Connect circuit can call this operation.
 *
 * @param request TerminateVirtualBorderRouterRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return TerminateVirtualBorderRouterResponse
 */
func (client *Client) TerminateVirtualBorderRouterWithOptions(request *TerminateVirtualBorderRouterRequest, runtime *util.RuntimeOptions) (_result *TerminateVirtualBorderRouterResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.VbrId)) {
		query["VbrId"] = request.VbrId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("TerminateVirtualBorderRouter"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &TerminateVirtualBorderRouterResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * After the operation is called, the VBR changes from the **Enabled** state to the **Terminating** state. After the VBR is terminated, it enters the **Terminated** state.
 * >  Only the owner of an Express Connect circuit can call this operation.
 *
 * @param request TerminateVirtualBorderRouterRequest
 * @return TerminateVirtualBorderRouterResponse
 */
func (client *Client) TerminateVirtualBorderRouter(request *TerminateVirtualBorderRouterRequest) (_result *TerminateVirtualBorderRouterResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &TerminateVirtualBorderRouterResponse{}
	_body, _err := client.TerminateVirtualBorderRouterWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UnTagResourcesWithOptions(request *UnTagResourcesRequest, runtime *util.RuntimeOptions) (_result *UnTagResourcesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.All)) {
		query["All"] = request.All
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceId)) {
		query["ResourceId"] = request.ResourceId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.TagKey)) {
		query["TagKey"] = request.TagKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UnTagResources"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UnTagResourcesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UnTagResources(request *UnTagResourcesRequest) (_result *UnTagResourcesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UnTagResourcesResponse{}
	_body, _err := client.UnTagResourcesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   **UnassociateEipAddress** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeEipAddresses](~~120193~~) operation to query the status of an EIP:
 *     *   If the EIP is in the **Unassociating** state, the EIP is being disassociated. In this state, you can only query the EIP and cannot perform other operations.
 *     *   If the EIP is in the **Available** state, the EIP is disassociated.
 * *   You cannot repeatedly call the **UnassociateEipAddress** operation to disassociate an EIP within the specified period of time.
 *
 * @param request UnassociateEipAddressRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UnassociateEipAddressResponse
 */
func (client *Client) UnassociateEipAddressWithOptions(request *UnassociateEipAddressRequest, runtime *util.RuntimeOptions) (_result *UnassociateEipAddressResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AllocationId)) {
		query["AllocationId"] = request.AllocationId
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Force)) {
		query["Force"] = request.Force
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceType)) {
		query["InstanceType"] = request.InstanceType
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PrivateIpAddress)) {
		query["PrivateIpAddress"] = request.PrivateIpAddress
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UnassociateEipAddress"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UnassociateEipAddressResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   **UnassociateEipAddress** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeEipAddresses](~~120193~~) operation to query the status of an EIP:
 *     *   If the EIP is in the **Unassociating** state, the EIP is being disassociated. In this state, you can only query the EIP and cannot perform other operations.
 *     *   If the EIP is in the **Available** state, the EIP is disassociated.
 * *   You cannot repeatedly call the **UnassociateEipAddress** operation to disassociate an EIP within the specified period of time.
 *
 * @param request UnassociateEipAddressRequest
 * @return UnassociateEipAddressResponse
 */
func (client *Client) UnassociateEipAddress(request *UnassociateEipAddressRequest) (_result *UnassociateEipAddressResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UnassociateEipAddressResponse{}
	_body, _err := client.UnassociateEipAddressWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UnassociateGlobalAccelerationInstanceWithOptions(request *UnassociateGlobalAccelerationInstanceRequest, runtime *util.RuntimeOptions) (_result *UnassociateGlobalAccelerationInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.GlobalAccelerationInstanceId)) {
		query["GlobalAccelerationInstanceId"] = request.GlobalAccelerationInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceType)) {
		query["InstanceType"] = request.InstanceType
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UnassociateGlobalAccelerationInstance"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UnassociateGlobalAccelerationInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UnassociateGlobalAccelerationInstance(request *UnassociateGlobalAccelerationInstanceRequest) (_result *UnassociateGlobalAccelerationInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UnassociateGlobalAccelerationInstanceResponse{}
	_body, _err := client.UnassociateGlobalAccelerationInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * When you call this operation, take note of the following limits:
 * *   The ECS instance must be in the **Running** or **Stopped** state.
 * *   The HAVIP must be in the **Available** or **InUse** state.
 * *   The **UnassociateHaVip** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeHaVips](~~114611~~) operation to query the status of an HAVIP:
 *     *   If the HAVIP is in the **Unassociating** state, the HAVIP is being disassociated.
 *     *   If the HAVIP is in the **Inuse** or **Available** state, the HAVIP is disassociated.
 * *   You cannot repeatedly call the **UnassociateHaVip** operation to disassociate an HAVIP within the specified period of time.
 *
 * @param request UnassociateHaVipRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UnassociateHaVipResponse
 */
func (client *Client) UnassociateHaVipWithOptions(request *UnassociateHaVipRequest, runtime *util.RuntimeOptions) (_result *UnassociateHaVipResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Force)) {
		query["Force"] = request.Force
	}

	if !tea.BoolValue(util.IsUnset(request.HaVipId)) {
		query["HaVipId"] = request.HaVipId
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceType)) {
		query["InstanceType"] = request.InstanceType
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UnassociateHaVip"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UnassociateHaVipResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * When you call this operation, take note of the following limits:
 * *   The ECS instance must be in the **Running** or **Stopped** state.
 * *   The HAVIP must be in the **Available** or **InUse** state.
 * *   The **UnassociateHaVip** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeHaVips](~~114611~~) operation to query the status of an HAVIP:
 *     *   If the HAVIP is in the **Unassociating** state, the HAVIP is being disassociated.
 *     *   If the HAVIP is in the **Inuse** or **Available** state, the HAVIP is disassociated.
 * *   You cannot repeatedly call the **UnassociateHaVip** operation to disassociate an HAVIP within the specified period of time.
 *
 * @param request UnassociateHaVipRequest
 * @return UnassociateHaVipResponse
 */
func (client *Client) UnassociateHaVip(request *UnassociateHaVipRequest) (_result *UnassociateHaVipResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UnassociateHaVipResponse{}
	_body, _err := client.UnassociateHaVipWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   The **UnassociateNetworkAcl** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeNetworkAclAttributes](~~116542~~) operation to query the status of a network ACL:
 *     *   If the network ACL is in the **UNBINDING** state, the network ACL is being disassociated from the vSwitch.
 *     *   If the network ACL is in the **UNBINDED** state, the network ACL is disassociated from the vSwitch.
 * *   You cannot repeatedly call the **UnassociateNetworkAcl** operation to disassociate a network ACL from a vSwitch within the specified period of time.
 *
 * @param request UnassociateNetworkAclRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UnassociateNetworkAclResponse
 */
func (client *Client) UnassociateNetworkAclWithOptions(request *UnassociateNetworkAclRequest, runtime *util.RuntimeOptions) (_result *UnassociateNetworkAclResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.NetworkAclId)) {
		query["NetworkAclId"] = request.NetworkAclId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.Resource)) {
		query["Resource"] = request.Resource
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UnassociateNetworkAcl"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UnassociateNetworkAclResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   The **UnassociateNetworkAcl** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeNetworkAclAttributes](~~116542~~) operation to query the status of a network ACL:
 *     *   If the network ACL is in the **UNBINDING** state, the network ACL is being disassociated from the vSwitch.
 *     *   If the network ACL is in the **UNBINDED** state, the network ACL is disassociated from the vSwitch.
 * *   You cannot repeatedly call the **UnassociateNetworkAcl** operation to disassociate a network ACL from a vSwitch within the specified period of time.
 *
 * @param request UnassociateNetworkAclRequest
 * @return UnassociateNetworkAclResponse
 */
func (client *Client) UnassociateNetworkAcl(request *UnassociateNetworkAclRequest) (_result *UnassociateNetworkAclResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UnassociateNetworkAclResponse{}
	_body, _err := client.UnassociateNetworkAclWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UnassociatePhysicalConnectionFromVirtualBorderRouterWithOptions(request *UnassociatePhysicalConnectionFromVirtualBorderRouterRequest, runtime *util.RuntimeOptions) (_result *UnassociatePhysicalConnectionFromVirtualBorderRouterResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PhysicalConnectionId)) {
		query["PhysicalConnectionId"] = request.PhysicalConnectionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.VbrId)) {
		query["VbrId"] = request.VbrId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UnassociatePhysicalConnectionFromVirtualBorderRouter"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UnassociatePhysicalConnectionFromVirtualBorderRouterResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UnassociatePhysicalConnectionFromVirtualBorderRouter(request *UnassociatePhysicalConnectionFromVirtualBorderRouterRequest) (_result *UnassociatePhysicalConnectionFromVirtualBorderRouterResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UnassociatePhysicalConnectionFromVirtualBorderRouterResponse{}
	_body, _err := client.UnassociatePhysicalConnectionFromVirtualBorderRouterWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   The **UnassociateRouteTable** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeVSwitchAttributes](~~94567~~) operation to query the status of a vSwitch:
 *     *   If the vSwitch is in the **Pending** state, the route table is being disassociated.
 *     *   If the vSwitch is in the **Available** state, the route table is disassociated.
 * *   You cannot repeatedly call the **UnassociateRouteTable** operation to disassociate a route table from a vSwitch within the specified period of time.
 *
 * @param request UnassociateRouteTableRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UnassociateRouteTableResponse
 */
func (client *Client) UnassociateRouteTableWithOptions(request *UnassociateRouteTableRequest, runtime *util.RuntimeOptions) (_result *UnassociateRouteTableResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RouteTableId)) {
		query["RouteTableId"] = request.RouteTableId
	}

	if !tea.BoolValue(util.IsUnset(request.VSwitchId)) {
		query["VSwitchId"] = request.VSwitchId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UnassociateRouteTable"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UnassociateRouteTableResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   The **UnassociateRouteTable** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeVSwitchAttributes](~~94567~~) operation to query the status of a vSwitch:
 *     *   If the vSwitch is in the **Pending** state, the route table is being disassociated.
 *     *   If the vSwitch is in the **Available** state, the route table is disassociated.
 * *   You cannot repeatedly call the **UnassociateRouteTable** operation to disassociate a route table from a vSwitch within the specified period of time.
 *
 * @param request UnassociateRouteTableRequest
 * @return UnassociateRouteTableResponse
 */
func (client *Client) UnassociateRouteTable(request *UnassociateRouteTableRequest) (_result *UnassociateRouteTableResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UnassociateRouteTableResponse{}
	_body, _err := client.UnassociateRouteTableWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   Before you delete a secondary CIDR block from a VPC, delete the vSwitch which is created with the CIDR block. For more information, see [DeleteVSwitch](~~35746~~).
 * *   You cannot repeatedly call the **UnassociateVpcCidrBlock** operation to delete a secondary CIDR block from a VPC within the specified period of time.
 *
 * @param request UnassociateVpcCidrBlockRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UnassociateVpcCidrBlockResponse
 */
func (client *Client) UnassociateVpcCidrBlockWithOptions(request *UnassociateVpcCidrBlockRequest, runtime *util.RuntimeOptions) (_result *UnassociateVpcCidrBlockResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IPv6CidrBlock)) {
		query["IPv6CidrBlock"] = request.IPv6CidrBlock
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecondaryCidrBlock)) {
		query["SecondaryCidrBlock"] = request.SecondaryCidrBlock
	}

	if !tea.BoolValue(util.IsUnset(request.VpcId)) {
		query["VpcId"] = request.VpcId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UnassociateVpcCidrBlock"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UnassociateVpcCidrBlockResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   Before you delete a secondary CIDR block from a VPC, delete the vSwitch which is created with the CIDR block. For more information, see [DeleteVSwitch](~~35746~~).
 * *   You cannot repeatedly call the **UnassociateVpcCidrBlock** operation to delete a secondary CIDR block from a VPC within the specified period of time.
 *
 * @param request UnassociateVpcCidrBlockRequest
 * @return UnassociateVpcCidrBlockResponse
 */
func (client *Client) UnassociateVpcCidrBlock(request *UnassociateVpcCidrBlockRequest) (_result *UnassociateVpcCidrBlockResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UnassociateVpcCidrBlockResponse{}
	_body, _err := client.UnassociateVpcCidrBlockWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UntagResourcesForExpressConnectWithOptions(request *UntagResourcesForExpressConnectRequest, runtime *util.RuntimeOptions) (_result *UntagResourcesForExpressConnectResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.All)) {
		query["All"] = request.All
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceId)) {
		query["ResourceId"] = request.ResourceId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.TagKey)) {
		query["TagKey"] = request.TagKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UntagResourcesForExpressConnect"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UntagResourcesForExpressConnectResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UntagResourcesForExpressConnect(request *UntagResourcesForExpressConnectRequest) (_result *UntagResourcesForExpressConnectResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UntagResourcesForExpressConnectResponse{}
	_body, _err := client.UntagResourcesForExpressConnectWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateDhcpOptionsSetAttributeWithOptions(request *UpdateDhcpOptionsSetAttributeRequest, runtime *util.RuntimeOptions) (_result *UpdateDhcpOptionsSetAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DhcpOptionsSetDescription)) {
		query["DhcpOptionsSetDescription"] = request.DhcpOptionsSetDescription
	}

	if !tea.BoolValue(util.IsUnset(request.DhcpOptionsSetId)) {
		query["DhcpOptionsSetId"] = request.DhcpOptionsSetId
	}

	if !tea.BoolValue(util.IsUnset(request.DhcpOptionsSetName)) {
		query["DhcpOptionsSetName"] = request.DhcpOptionsSetName
	}

	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.DomainNameServers)) {
		query["DomainNameServers"] = request.DomainNameServers
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.Ipv6LeaseTime)) {
		query["Ipv6LeaseTime"] = request.Ipv6LeaseTime
	}

	if !tea.BoolValue(util.IsUnset(request.LeaseTime)) {
		query["LeaseTime"] = request.LeaseTime
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateDhcpOptionsSetAttribute"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateDhcpOptionsSetAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateDhcpOptionsSetAttribute(request *UpdateDhcpOptionsSetAttributeRequest) (_result *UpdateDhcpOptionsSetAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateDhcpOptionsSetAttributeResponse{}
	_body, _err := client.UpdateDhcpOptionsSetAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateGatewayRouteTableEntryAttributeWithOptions(request *UpdateGatewayRouteTableEntryAttributeRequest, runtime *util.RuntimeOptions) (_result *UpdateGatewayRouteTableEntryAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.DestinationCidrBlock)) {
		query["DestinationCidrBlock"] = request.DestinationCidrBlock
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.IPv4GatewayRouteTableId)) {
		query["IPv4GatewayRouteTableId"] = request.IPv4GatewayRouteTableId
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.NextHopId)) {
		query["NextHopId"] = request.NextHopId
	}

	if !tea.BoolValue(util.IsUnset(request.NextHopType)) {
		query["NextHopType"] = request.NextHopType
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateGatewayRouteTableEntryAttribute"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateGatewayRouteTableEntryAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateGatewayRouteTableEntryAttribute(request *UpdateGatewayRouteTableEntryAttributeRequest) (_result *UpdateGatewayRouteTableEntryAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateGatewayRouteTableEntryAttributeResponse{}
	_body, _err := client.UpdateGatewayRouteTableEntryAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   If you modify only the **IpsecServerName** parameter, this operation is synchronous. If you modify parameters other than **IpsecServerName**, this operation is asynchronous.
 * *   When the **UpdateIpsecServer** operation is asynchronous, the system returns a request ID after you send the request. However, the operation is still being performed in the system background. You can call [DescribeVpnGateway](~~73720~~) to query the status of a VPN gateway.
 *     *   If the VPN gateway is in the **updating** state, the configuration of the IPsec server is being modified.
 *     *   If the VPN gateway is in the **active** state, the configuration of the IPsec server is modified.
 * *   You cannot repeatedly call **UpdateIpsecServer** to modify the configuration of an IPsec server of the same VPN gateway within the specified period of time.
 *
 * @param request UpdateIpsecServerRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateIpsecServerResponse
 */
func (client *Client) UpdateIpsecServerWithOptions(request *UpdateIpsecServerRequest, runtime *util.RuntimeOptions) (_result *UpdateIpsecServerResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientIpPool)) {
		query["ClientIpPool"] = request.ClientIpPool
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.EffectImmediately)) {
		query["EffectImmediately"] = request.EffectImmediately
	}

	if !tea.BoolValue(util.IsUnset(request.IkeConfig)) {
		query["IkeConfig"] = request.IkeConfig
	}

	if !tea.BoolValue(util.IsUnset(request.IpsecConfig)) {
		query["IpsecConfig"] = request.IpsecConfig
	}

	if !tea.BoolValue(util.IsUnset(request.IpsecServerId)) {
		query["IpsecServerId"] = request.IpsecServerId
	}

	if !tea.BoolValue(util.IsUnset(request.IpsecServerName)) {
		query["IpsecServerName"] = request.IpsecServerName
	}

	if !tea.BoolValue(util.IsUnset(request.LocalSubnet)) {
		query["LocalSubnet"] = request.LocalSubnet
	}

	if !tea.BoolValue(util.IsUnset(request.Psk)) {
		query["Psk"] = request.Psk
	}

	if !tea.BoolValue(util.IsUnset(request.PskEnabled)) {
		query["PskEnabled"] = request.PskEnabled
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateIpsecServer"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateIpsecServerResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   If you modify only the **IpsecServerName** parameter, this operation is synchronous. If you modify parameters other than **IpsecServerName**, this operation is asynchronous.
 * *   When the **UpdateIpsecServer** operation is asynchronous, the system returns a request ID after you send the request. However, the operation is still being performed in the system background. You can call [DescribeVpnGateway](~~73720~~) to query the status of a VPN gateway.
 *     *   If the VPN gateway is in the **updating** state, the configuration of the IPsec server is being modified.
 *     *   If the VPN gateway is in the **active** state, the configuration of the IPsec server is modified.
 * *   You cannot repeatedly call **UpdateIpsecServer** to modify the configuration of an IPsec server of the same VPN gateway within the specified period of time.
 *
 * @param request UpdateIpsecServerRequest
 * @return UpdateIpsecServerResponse
 */
func (client *Client) UpdateIpsecServer(request *UpdateIpsecServerRequest) (_result *UpdateIpsecServerResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateIpsecServerResponse{}
	_body, _err := client.UpdateIpsecServerWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You cannot repeatedly call the **UpdateIpv4GatewayAttribute** operation to modify the name or description of an IPv4 gateway within the specified period of time.
 *
 * @param request UpdateIpv4GatewayAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateIpv4GatewayAttributeResponse
 */
func (client *Client) UpdateIpv4GatewayAttributeWithOptions(request *UpdateIpv4GatewayAttributeRequest, runtime *util.RuntimeOptions) (_result *UpdateIpv4GatewayAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.Ipv4GatewayDescription)) {
		query["Ipv4GatewayDescription"] = request.Ipv4GatewayDescription
	}

	if !tea.BoolValue(util.IsUnset(request.Ipv4GatewayId)) {
		query["Ipv4GatewayId"] = request.Ipv4GatewayId
	}

	if !tea.BoolValue(util.IsUnset(request.Ipv4GatewayName)) {
		query["Ipv4GatewayName"] = request.Ipv4GatewayName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateIpv4GatewayAttribute"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateIpv4GatewayAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You cannot repeatedly call the **UpdateIpv4GatewayAttribute** operation to modify the name or description of an IPv4 gateway within the specified period of time.
 *
 * @param request UpdateIpv4GatewayAttributeRequest
 * @return UpdateIpv4GatewayAttributeResponse
 */
func (client *Client) UpdateIpv4GatewayAttribute(request *UpdateIpv4GatewayAttributeRequest) (_result *UpdateIpv4GatewayAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateIpv4GatewayAttributeResponse{}
	_body, _err := client.UpdateIpv4GatewayAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Before you call this operation, take note of the following limits:
 * *   **UpdateNatGatewayNatType** is an asynchronous operation. After you make a request, the ID of the request is returned but the NAT gateway is not upgraded. The system upgrades the NAT gateway in the background. You can call the GetNatGatewayConvertStatus operation to query the upgrade progress of a NAT gateway. For more information, see [GetNatGatewayConvertStatus](~~184744~~).
 *     *   If a NAT gateway is in the **processing** state, it indicates that the NAT gateway is being upgraded. You can only query the state of the NAT gateway but cannot perform other operations.
 *     *   If a NAT gateway is in the **successful** state, it indicates that the NAT gateway is upgraded.
 *     *   If a NAT gateway is in the **failed** state, it indicates that the system failed to upgrade the NAT gateway.
 * *   You cannot repeatedly call the **UpdateNatGatewayNatType** operation to upgrade a NAT gateway within the specified period of time.
 * *   The billing method and billable items remain the same after the upgrade.
 * *   It takes about 5 minutes to upgrade a standard NAT gateway to an enhanced NAT gateway. During the upgrade, transient connections may occur once or twice. You can determine whether to enable automatic reconnection or use manual reconnection based on your business requirements.
 * *   You can only upgrade standard NAT gateways to enhanced NAT gateways. You are not allowed to downgrade enhanced NAT gateways to standard NAT gateways.
 *
 * @param request UpdateNatGatewayNatTypeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateNatGatewayNatTypeResponse
 */
func (client *Client) UpdateNatGatewayNatTypeWithOptions(request *UpdateNatGatewayNatTypeRequest, runtime *util.RuntimeOptions) (_result *UpdateNatGatewayNatTypeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.NatGatewayId)) {
		query["NatGatewayId"] = request.NatGatewayId
	}

	if !tea.BoolValue(util.IsUnset(request.NatType)) {
		query["NatType"] = request.NatType
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.VSwitchId)) {
		query["VSwitchId"] = request.VSwitchId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateNatGatewayNatType"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateNatGatewayNatTypeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Before you call this operation, take note of the following limits:
 * *   **UpdateNatGatewayNatType** is an asynchronous operation. After you make a request, the ID of the request is returned but the NAT gateway is not upgraded. The system upgrades the NAT gateway in the background. You can call the GetNatGatewayConvertStatus operation to query the upgrade progress of a NAT gateway. For more information, see [GetNatGatewayConvertStatus](~~184744~~).
 *     *   If a NAT gateway is in the **processing** state, it indicates that the NAT gateway is being upgraded. You can only query the state of the NAT gateway but cannot perform other operations.
 *     *   If a NAT gateway is in the **successful** state, it indicates that the NAT gateway is upgraded.
 *     *   If a NAT gateway is in the **failed** state, it indicates that the system failed to upgrade the NAT gateway.
 * *   You cannot repeatedly call the **UpdateNatGatewayNatType** operation to upgrade a NAT gateway within the specified period of time.
 * *   The billing method and billable items remain the same after the upgrade.
 * *   It takes about 5 minutes to upgrade a standard NAT gateway to an enhanced NAT gateway. During the upgrade, transient connections may occur once or twice. You can determine whether to enable automatic reconnection or use manual reconnection based on your business requirements.
 * *   You can only upgrade standard NAT gateways to enhanced NAT gateways. You are not allowed to downgrade enhanced NAT gateways to standard NAT gateways.
 *
 * @param request UpdateNatGatewayNatTypeRequest
 * @return UpdateNatGatewayNatTypeResponse
 */
func (client *Client) UpdateNatGatewayNatType(request *UpdateNatGatewayNatTypeRequest) (_result *UpdateNatGatewayNatTypeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateNatGatewayNatTypeResponse{}
	_body, _err := client.UpdateNatGatewayNatTypeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   The **UpdateNetworkAclEntries** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeNetworkAclAttributes](~~116542~~) operation to query the status of a network ACL:
 *     *   If the network ACL is in the **Modifying** state, the rules of the network ACL are being updated.
 *     *   If the network ACL is in the **Available** state, the rules of the network ACL are updated.
 * *   You cannot repeatedly call the **UpdateNetworkAclEntries** operation to update the rules of a network ACL within the specified period of time.
 *
 * @param request UpdateNetworkAclEntriesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateNetworkAclEntriesResponse
 */
func (client *Client) UpdateNetworkAclEntriesWithOptions(request *UpdateNetworkAclEntriesRequest, runtime *util.RuntimeOptions) (_result *UpdateNetworkAclEntriesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.EgressAclEntries)) {
		query["EgressAclEntries"] = request.EgressAclEntries
	}

	if !tea.BoolValue(util.IsUnset(request.IngressAclEntries)) {
		query["IngressAclEntries"] = request.IngressAclEntries
	}

	if !tea.BoolValue(util.IsUnset(request.NetworkAclId)) {
		query["NetworkAclId"] = request.NetworkAclId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.UpdateEgressAclEntries)) {
		query["UpdateEgressAclEntries"] = request.UpdateEgressAclEntries
	}

	if !tea.BoolValue(util.IsUnset(request.UpdateIngressAclEntries)) {
		query["UpdateIngressAclEntries"] = request.UpdateIngressAclEntries
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateNetworkAclEntries"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateNetworkAclEntriesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   The **UpdateNetworkAclEntries** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeNetworkAclAttributes](~~116542~~) operation to query the status of a network ACL:
 *     *   If the network ACL is in the **Modifying** state, the rules of the network ACL are being updated.
 *     *   If the network ACL is in the **Available** state, the rules of the network ACL are updated.
 * *   You cannot repeatedly call the **UpdateNetworkAclEntries** operation to update the rules of a network ACL within the specified period of time.
 *
 * @param request UpdateNetworkAclEntriesRequest
 * @return UpdateNetworkAclEntriesResponse
 */
func (client *Client) UpdateNetworkAclEntries(request *UpdateNetworkAclEntriesRequest) (_result *UpdateNetworkAclEntriesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateNetworkAclEntriesResponse{}
	_body, _err := client.UpdateNetworkAclEntriesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You cannot repeatedly call the **UpdatePublicIpAddressPoolAttribute** operation to modify the attributes of an IP address pool within the specified period of time.
 *
 * @param request UpdatePublicIpAddressPoolAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdatePublicIpAddressPoolAttributeResponse
 */
func (client *Client) UpdatePublicIpAddressPoolAttributeWithOptions(request *UpdatePublicIpAddressPoolAttributeRequest, runtime *util.RuntimeOptions) (_result *UpdatePublicIpAddressPoolAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PublicIpAddressPoolId)) {
		query["PublicIpAddressPoolId"] = request.PublicIpAddressPoolId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdatePublicIpAddressPoolAttribute"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdatePublicIpAddressPoolAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You cannot repeatedly call the **UpdatePublicIpAddressPoolAttribute** operation to modify the attributes of an IP address pool within the specified period of time.
 *
 * @param request UpdatePublicIpAddressPoolAttributeRequest
 * @return UpdatePublicIpAddressPoolAttributeResponse
 */
func (client *Client) UpdatePublicIpAddressPoolAttribute(request *UpdatePublicIpAddressPoolAttributeRequest) (_result *UpdatePublicIpAddressPoolAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdatePublicIpAddressPoolAttributeResponse{}
	_body, _err := client.UpdatePublicIpAddressPoolAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You cannot repeatedly call the **UpdateTrafficMirrorFilterAttribute** operation to modify the configuration of a filter for traffic mirroring within the specified period of time.
 *
 * @param request UpdateTrafficMirrorFilterAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateTrafficMirrorFilterAttributeResponse
 */
func (client *Client) UpdateTrafficMirrorFilterAttributeWithOptions(request *UpdateTrafficMirrorFilterAttributeRequest, runtime *util.RuntimeOptions) (_result *UpdateTrafficMirrorFilterAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.TrafficMirrorFilterDescription)) {
		query["TrafficMirrorFilterDescription"] = request.TrafficMirrorFilterDescription
	}

	if !tea.BoolValue(util.IsUnset(request.TrafficMirrorFilterId)) {
		query["TrafficMirrorFilterId"] = request.TrafficMirrorFilterId
	}

	if !tea.BoolValue(util.IsUnset(request.TrafficMirrorFilterName)) {
		query["TrafficMirrorFilterName"] = request.TrafficMirrorFilterName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateTrafficMirrorFilterAttribute"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateTrafficMirrorFilterAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You cannot repeatedly call the **UpdateTrafficMirrorFilterAttribute** operation to modify the configuration of a filter for traffic mirroring within the specified period of time.
 *
 * @param request UpdateTrafficMirrorFilterAttributeRequest
 * @return UpdateTrafficMirrorFilterAttributeResponse
 */
func (client *Client) UpdateTrafficMirrorFilterAttribute(request *UpdateTrafficMirrorFilterAttributeRequest) (_result *UpdateTrafficMirrorFilterAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateTrafficMirrorFilterAttributeResponse{}
	_body, _err := client.UpdateTrafficMirrorFilterAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   The **UpdateTrafficMirrorFilterRuleAttribute** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [ListTrafficMirrorFilters](~~261353~~) operation to query the status of an inbound or outbound rule:
 *     *   If the rule is in the **Modifying** state, the rule is being modified.
 *     *   If the rule is in the **Created** state, the rule is modified.
 * *   You cannot repeatedly call the **UpdateTrafficMirrorFilterRuleAttribute** operation to modify an inbound or outbound rule within the specified period of time.
 *
 * @param request UpdateTrafficMirrorFilterRuleAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateTrafficMirrorFilterRuleAttributeResponse
 */
func (client *Client) UpdateTrafficMirrorFilterRuleAttributeWithOptions(request *UpdateTrafficMirrorFilterRuleAttributeRequest, runtime *util.RuntimeOptions) (_result *UpdateTrafficMirrorFilterRuleAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DestinationCidrBlock)) {
		query["DestinationCidrBlock"] = request.DestinationCidrBlock
	}

	if !tea.BoolValue(util.IsUnset(request.DestinationPortRange)) {
		query["DestinationPortRange"] = request.DestinationPortRange
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Priority)) {
		query["Priority"] = request.Priority
	}

	if !tea.BoolValue(util.IsUnset(request.Protocol)) {
		query["Protocol"] = request.Protocol
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RuleAction)) {
		query["RuleAction"] = request.RuleAction
	}

	if !tea.BoolValue(util.IsUnset(request.SourceCidrBlock)) {
		query["SourceCidrBlock"] = request.SourceCidrBlock
	}

	if !tea.BoolValue(util.IsUnset(request.SourcePortRange)) {
		query["SourcePortRange"] = request.SourcePortRange
	}

	if !tea.BoolValue(util.IsUnset(request.TrafficMirrorFilterRuleId)) {
		query["TrafficMirrorFilterRuleId"] = request.TrafficMirrorFilterRuleId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateTrafficMirrorFilterRuleAttribute"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateTrafficMirrorFilterRuleAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   The **UpdateTrafficMirrorFilterRuleAttribute** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [ListTrafficMirrorFilters](~~261353~~) operation to query the status of an inbound or outbound rule:
 *     *   If the rule is in the **Modifying** state, the rule is being modified.
 *     *   If the rule is in the **Created** state, the rule is modified.
 * *   You cannot repeatedly call the **UpdateTrafficMirrorFilterRuleAttribute** operation to modify an inbound or outbound rule within the specified period of time.
 *
 * @param request UpdateTrafficMirrorFilterRuleAttributeRequest
 * @return UpdateTrafficMirrorFilterRuleAttributeResponse
 */
func (client *Client) UpdateTrafficMirrorFilterRuleAttribute(request *UpdateTrafficMirrorFilterRuleAttributeRequest) (_result *UpdateTrafficMirrorFilterRuleAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateTrafficMirrorFilterRuleAttributeResponse{}
	_body, _err := client.UpdateTrafficMirrorFilterRuleAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   The **UpdateTrafficMirrorSessionAttribute** operation is asynchronous. After you send a request, the system returns the request ID. However, the operation is still being performed in the system background. You can call the [ListTrafficMirrorSessions](~~261367~~) operation to query the status of a traffic mirror session.
 *     *   If the traffic mirror session is in the **Modifying** state, the configuration of the traffic mirror session is being modified.
 *     *   If the traffic mirror session is in the **Created** state, the configuration of the traffic mirror session is modified.
 * *   After you call the **UpdateTrafficMirrorSessionAttribute** operation to modify the configuration of a traffic mirror session, you cannot call the operation again to modify the configuration of the traffic mirror session until the previous modification task is complete.
 *
 * @param request UpdateTrafficMirrorSessionAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateTrafficMirrorSessionAttributeResponse
 */
func (client *Client) UpdateTrafficMirrorSessionAttributeWithOptions(request *UpdateTrafficMirrorSessionAttributeRequest, runtime *util.RuntimeOptions) (_result *UpdateTrafficMirrorSessionAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.Enabled)) {
		query["Enabled"] = request.Enabled
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PacketLength)) {
		query["PacketLength"] = request.PacketLength
	}

	if !tea.BoolValue(util.IsUnset(request.Priority)) {
		query["Priority"] = request.Priority
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.TrafficMirrorFilterId)) {
		query["TrafficMirrorFilterId"] = request.TrafficMirrorFilterId
	}

	if !tea.BoolValue(util.IsUnset(request.TrafficMirrorSessionDescription)) {
		query["TrafficMirrorSessionDescription"] = request.TrafficMirrorSessionDescription
	}

	if !tea.BoolValue(util.IsUnset(request.TrafficMirrorSessionId)) {
		query["TrafficMirrorSessionId"] = request.TrafficMirrorSessionId
	}

	if !tea.BoolValue(util.IsUnset(request.TrafficMirrorSessionName)) {
		query["TrafficMirrorSessionName"] = request.TrafficMirrorSessionName
	}

	if !tea.BoolValue(util.IsUnset(request.TrafficMirrorTargetId)) {
		query["TrafficMirrorTargetId"] = request.TrafficMirrorTargetId
	}

	if !tea.BoolValue(util.IsUnset(request.TrafficMirrorTargetType)) {
		query["TrafficMirrorTargetType"] = request.TrafficMirrorTargetType
	}

	if !tea.BoolValue(util.IsUnset(request.VirtualNetworkId)) {
		query["VirtualNetworkId"] = request.VirtualNetworkId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateTrafficMirrorSessionAttribute"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateTrafficMirrorSessionAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   The **UpdateTrafficMirrorSessionAttribute** operation is asynchronous. After you send a request, the system returns the request ID. However, the operation is still being performed in the system background. You can call the [ListTrafficMirrorSessions](~~261367~~) operation to query the status of a traffic mirror session.
 *     *   If the traffic mirror session is in the **Modifying** state, the configuration of the traffic mirror session is being modified.
 *     *   If the traffic mirror session is in the **Created** state, the configuration of the traffic mirror session is modified.
 * *   After you call the **UpdateTrafficMirrorSessionAttribute** operation to modify the configuration of a traffic mirror session, you cannot call the operation again to modify the configuration of the traffic mirror session until the previous modification task is complete.
 *
 * @param request UpdateTrafficMirrorSessionAttributeRequest
 * @return UpdateTrafficMirrorSessionAttributeResponse
 */
func (client *Client) UpdateTrafficMirrorSessionAttribute(request *UpdateTrafficMirrorSessionAttributeRequest) (_result *UpdateTrafficMirrorSessionAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateTrafficMirrorSessionAttributeResponse{}
	_body, _err := client.UpdateTrafficMirrorSessionAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateVirtualBorderBandwidthWithOptions(request *UpdateVirtualBorderBandwidthRequest, runtime *util.RuntimeOptions) (_result *UpdateVirtualBorderBandwidthResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Bandwidth)) {
		query["Bandwidth"] = request.Bandwidth
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.VirtualBorderRouterId)) {
		query["VirtualBorderRouterId"] = request.VirtualBorderRouterId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateVirtualBorderBandwidth"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateVirtualBorderBandwidthResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateVirtualBorderBandwidth(request *UpdateVirtualBorderBandwidthRequest) (_result *UpdateVirtualBorderBandwidthResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateVirtualBorderBandwidthResponse{}
	_body, _err := client.UpdateVirtualBorderBandwidthWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateVirtualPhysicalConnectionWithOptions(request *UpdateVirtualPhysicalConnectionRequest, runtime *util.RuntimeOptions) (_result *UpdateVirtualPhysicalConnectionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.ExpectSpec)) {
		query["ExpectSpec"] = request.ExpectSpec
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.Token)) {
		query["Token"] = request.Token
	}

	if !tea.BoolValue(util.IsUnset(request.VlanId)) {
		query["VlanId"] = request.VlanId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateVirtualPhysicalConnection"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateVirtualPhysicalConnectionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateVirtualPhysicalConnection(request *UpdateVirtualPhysicalConnectionRequest) (_result *UpdateVirtualPhysicalConnectionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateVirtualPhysicalConnectionResponse{}
	_body, _err := client.UpdateVirtualPhysicalConnectionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   **UpdateVpcGatewayEndpointAttribute** is an asynchronous operation. After you send a request, the system returns a **request ID** and runs the task in the background. You can call the [GetVpcGatewayEndpointAttribute](~~311017~~) operation to query the status of a gateway endpoint.
 *     *   If the gateway endpoint is in the **Updating** state, it is being modified.
 *     *   If the gateway endpoint is in the **Created** state, it is modified.
 * *   You cannot call the **UpdateVpcGatewayEndpointAttribute** operation within a specific period of time.
 *
 * @param request UpdateVpcGatewayEndpointAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateVpcGatewayEndpointAttributeResponse
 */
func (client *Client) UpdateVpcGatewayEndpointAttributeWithOptions(request *UpdateVpcGatewayEndpointAttributeRequest, runtime *util.RuntimeOptions) (_result *UpdateVpcGatewayEndpointAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.EndpointDescription)) {
		query["EndpointDescription"] = request.EndpointDescription
	}

	if !tea.BoolValue(util.IsUnset(request.EndpointId)) {
		query["EndpointId"] = request.EndpointId
	}

	if !tea.BoolValue(util.IsUnset(request.EndpointName)) {
		query["EndpointName"] = request.EndpointName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PolicyDocument)) {
		query["PolicyDocument"] = request.PolicyDocument
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateVpcGatewayEndpointAttribute"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateVpcGatewayEndpointAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   **UpdateVpcGatewayEndpointAttribute** is an asynchronous operation. After you send a request, the system returns a **request ID** and runs the task in the background. You can call the [GetVpcGatewayEndpointAttribute](~~311017~~) operation to query the status of a gateway endpoint.
 *     *   If the gateway endpoint is in the **Updating** state, it is being modified.
 *     *   If the gateway endpoint is in the **Created** state, it is modified.
 * *   You cannot call the **UpdateVpcGatewayEndpointAttribute** operation within a specific period of time.
 *
 * @param request UpdateVpcGatewayEndpointAttributeRequest
 * @return UpdateVpcGatewayEndpointAttributeResponse
 */
func (client *Client) UpdateVpcGatewayEndpointAttribute(request *UpdateVpcGatewayEndpointAttributeRequest) (_result *UpdateVpcGatewayEndpointAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateVpcGatewayEndpointAttributeResponse{}
	_body, _err := client.UpdateVpcGatewayEndpointAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Before you call this operation, make sure that a VPC NAT gateway is created. For more information, see [CreateNatGateway](~~120219~~).
 *
 * @param request VpcDescribeVpcNatGatewayNetworkInterfaceQuotaRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return VpcDescribeVpcNatGatewayNetworkInterfaceQuotaResponse
 */
func (client *Client) VpcDescribeVpcNatGatewayNetworkInterfaceQuotaWithOptions(request *VpcDescribeVpcNatGatewayNetworkInterfaceQuotaRequest, runtime *util.RuntimeOptions) (_result *VpcDescribeVpcNatGatewayNetworkInterfaceQuotaResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.NatGatewayId)) {
		query["NatGatewayId"] = request.NatGatewayId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceUid)) {
		query["ResourceUid"] = request.ResourceUid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("VpcDescribeVpcNatGatewayNetworkInterfaceQuota"),
		Version:     tea.String("2016-04-28"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &VpcDescribeVpcNatGatewayNetworkInterfaceQuotaResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Before you call this operation, make sure that a VPC NAT gateway is created. For more information, see [CreateNatGateway](~~120219~~).
 *
 * @param request VpcDescribeVpcNatGatewayNetworkInterfaceQuotaRequest
 * @return VpcDescribeVpcNatGatewayNetworkInterfaceQuotaResponse
 */
func (client *Client) VpcDescribeVpcNatGatewayNetworkInterfaceQuota(request *VpcDescribeVpcNatGatewayNetworkInterfaceQuotaRequest) (_result *VpcDescribeVpcNatGatewayNetworkInterfaceQuotaResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &VpcDescribeVpcNatGatewayNetworkInterfaceQuotaResponse{}
	_body, _err := client.VpcDescribeVpcNatGatewayNetworkInterfaceQuotaWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}
